/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(151);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactRedux = __webpack_require__(30);
	
	var _app = __webpack_require__(145);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_reactDom2.default.render(_react2.default.createElement(
	  _reactRedux.Provider,
	  { store: _store2.default },
	  _react2.default.createElement(_app2.default, null)
	), document.getElementById('root'));

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule reactProdInvariant
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(206);


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentTree
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentFlags = __webpack_require__(103);
	
	var invariant = __webpack_require__(2);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(196);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstrumentation
	 */
	
	'use strict';
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(227);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentTreeHook
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var itemMap;
	var rootIDSet;
	
	var itemByKey;
	var rootByKey;
	
	if (canUseCollections) {
	  itemMap = new Map();
	  rootIDSet = new Set();
	} else {
	  itemByKey = {};
	  rootByKey = {};
	}
	
	var unmountedIDs = [];
	
	// Use non-numeric keys to prevent V8 performance issues:
	// https://github.com/facebook/react/pull/7232
	function getKeyFromID(id) {
	  return '.' + id;
	}
	function getIDFromKey(key) {
	  return parseInt(key.substr(1), 10);
	}
	
	function get(id) {
	  if (canUseCollections) {
	    return itemMap.get(id);
	  } else {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  }
	}
	
	function remove(id) {
	  if (canUseCollections) {
	    itemMap['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  }
	}
	
	function create(id, element, parentID) {
	  var item = {
	    element: element,
	    parentID: parentID,
	    text: null,
	    childIDs: [],
	    isMounted: false,
	    updateCount: 0
	  };
	
	  if (canUseCollections) {
	    itemMap.set(id, item);
	  } else {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  }
	}
	
	function addRoot(id) {
	  if (canUseCollections) {
	    rootIDSet.add(id);
	  } else {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  }
	}
	
	function removeRoot(id) {
	  if (canUseCollections) {
	    rootIDSet['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  }
	}
	
	function getRegisteredIDs() {
	  if (canUseCollections) {
	    return Array.from(itemMap.keys());
	  } else {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  }
	}
	
	function getRootIDs() {
	  if (canUseCollections) {
	    return Array.from(rootIDSet.keys());
	  } else {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  }
	}
	
	function purgeDeep(id) {
	  var item = get(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    remove(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = get(id);
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = get(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent ID is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    create(id, element, parentID);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = get(id);
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = get(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = get(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var type = topElement.type;
	      var name = typeof type === 'function' ? type.displayName || type.name : type;
	      var owner = topElement._owner;
	      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = get(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = get(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = get(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = get(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = get(id);
	    return item ? item.updateCount : 0;
	  },
	
	
	  getRegisteredIDs: getRegisteredIDs,
	
	  getRootIDs: getRootIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var warning = __webpack_require__(3);
	var canDefineProperty = __webpack_require__(68);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      Object.defineProperty(element, '_shadowChildren', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: shadowChildren
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._shadowChildren = shadowChildren;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactReconciler = __webpack_require__(29);
	var Transaction = __webpack_require__(35);
	
	var invariant = __webpack_require__(2);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.props === component._renderedComponent._currentElement) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topAnimationEnd: null,
	  topAnimationIteration: null,
	  topAnimationStart: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topInvalid: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topTransitionEnd: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(5);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMLazyTree
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(57);
	var setInnerHTML = __webpack_require__(48);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setTextContent = __webpack_require__(123);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(240);
	var ReactInstrumentation = __webpack_require__(11);
	
	var warning = __webpack_require__(3);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(152);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(153);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventPluginRegistry = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(58);
	var ReactErrorUtils = __webpack_require__(63);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var invariant = __webpack_require__(2);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var warning = __webpack_require__(3);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 33 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(128);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(286);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(285);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(284);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(179);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(193);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(24);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && typeof object[p] === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DisabledInputUtils
	 */
	
	'use strict';
	
	var disableableMouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var DisabledInputUtils = {
	  getHostProps: function (inst, props) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var hostProps = {};
	    for (var key in props) {
	      if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
	        hostProps[key] = props[key];
	      }
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = DisabledInputUtils;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventConstants = __webpack_require__(17);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactEventEmitterMixin = __webpack_require__(230);
	var ViewportMetrics = __webpack_require__(115);
	
	var getVendorPrefixedEventName = __webpack_require__(262);
	var isEventSupported = __webpack_require__(74);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	var ViewportMetrics = __webpack_require__(115);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var DOMNamespaces = __webpack_require__(57);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var newNodes = reusableSVGContainer.firstChild.childNodes;
	    for (var i = 0; i < newNodes.length; i++) {
	      node.appendChild(newNodes[i]);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(5);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _Actions = __webpack_require__(27);
	
	var _computeChangedRoutes2 = __webpack_require__(177);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(174);
	
	var _isActive2 = __webpack_require__(181);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(178);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(183);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  function createLocationFromRedirectInfo(location) {
	    return history.createLocation(location, _Actions.REPLACE);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, createLocationFromRedirectInfo(redirectInfo));
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.transitionTo(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(28);
	var Danger = __webpack_require__(201);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setInnerHTML = __webpack_require__(48);
	var setTextContent = __webpack_require__(123);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMNamespaces
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(63);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 59 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule KeyEscapeUtils
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypes = __webpack_require__(113);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var canDefineProperty = __webpack_require__(68);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 66 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypesSecret
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 69 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createMicrosoftUnsafeLocalFunction
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 71 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 75 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	
	var getIteratorFn = __webpack_require__(73);
	var invariant = __webpack_require__(2);
	var KeyEscapeUtils = __webpack_require__(59);
	var warning = __webpack_require__(3);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      if (childTag !== '#text') {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reduxLogger = __webpack_require__(280);
	
	var _reduxLogger2 = _interopRequireDefault(_reduxLogger);
	
	var _reduxThunk = __webpack_require__(283);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _reduxPromiseMiddleware = __webpack_require__(281);
	
	var _reduxPromiseMiddleware2 = _interopRequireDefault(_reduxPromiseMiddleware);
	
	var _reducers = __webpack_require__(140);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var middleware = (0, _redux.applyMiddleware)((0, _reduxPromiseMiddleware2.default)(), _reduxThunk2.default, (0, _reduxLogger2.default)());
	
	exports.default = (0, _redux.createStore)(_reducers2.default);
	//export default createStore(reducer, middleware)

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * This action type will be dispatched by the history actions below.
	 * If you're writing a middleware to watch for navigation events, be sure to
	 * look for actions of this type.
	 */
	var CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';
	
	function updateLocation(method) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return {
	      type: CALL_HISTORY_METHOD,
	      payload: { method: method, args: args }
	    };
	  };
	}
	
	/**
	 * These actions correspond to the history API.
	 * The associated routerMiddleware will capture these events before they get to
	 * your reducer and reissue them as the matching function on your history.
	 */
	var push = exports.push = updateLocation('push');
	var replace = exports.replace = updateLocation('replace');
	var go = exports.go = updateLocation('go');
	var goBack = exports.goBack = updateLocation('goBack');
	var goForward = exports.goForward = updateLocation('goForward');
	
	var routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;
	
	var _reducer = __webpack_require__(84);
	
	Object.defineProperty(exports, 'LOCATION_CHANGE', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.LOCATION_CHANGE;
	  }
	});
	Object.defineProperty(exports, 'routerReducer', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.routerReducer;
	  }
	});
	
	var _actions = __webpack_require__(82);
	
	Object.defineProperty(exports, 'CALL_HISTORY_METHOD', {
	  enumerable: true,
	  get: function get() {
	    return _actions.CALL_HISTORY_METHOD;
	  }
	});
	Object.defineProperty(exports, 'push', {
	  enumerable: true,
	  get: function get() {
	    return _actions.push;
	  }
	});
	Object.defineProperty(exports, 'replace', {
	  enumerable: true,
	  get: function get() {
	    return _actions.replace;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _actions.go;
	  }
	});
	Object.defineProperty(exports, 'goBack', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goBack;
	  }
	});
	Object.defineProperty(exports, 'goForward', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goForward;
	  }
	});
	Object.defineProperty(exports, 'routerActions', {
	  enumerable: true,
	  get: function get() {
	    return _actions.routerActions;
	  }
	});
	
	var _sync = __webpack_require__(164);
	
	var _sync2 = _interopRequireDefault(_sync);
	
	var _middleware = __webpack_require__(163);
	
	var _middleware2 = _interopRequireDefault(_middleware);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	exports.syncHistoryWithStore = _sync2['default'];
	exports.routerMiddleware = _middleware2['default'];

/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.routerReducer = routerReducer;
	/**
	 * This action type will be dispatched when your history
	 * receives a location change.
	 */
	var LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';
	
	var initialState = {
	  locationBeforeTransitions: null
	};
	
	/**
	 * This reducer will update the state with the most recent location history
	 * has transitioned to. This may not be in sync with the router, particularly
	 * if you have asynchronously-loaded routes, so reading from and relying on
	 * this state is discouraged.
	 */
	function routerReducer() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
	
	  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  var type = _ref.type;
	  var payload = _ref.payload;
	
	  if (type === LOCATION_CHANGE) {
	    return _extends({}, state, { locationBeforeTransitions: payload });
	  }
	
	  return state;
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]).isRequired,
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	
	    if (router) {
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(189);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(92);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(20);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(51);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(26);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(172);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(85);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(166);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(185);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(167);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(168);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(86);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(170);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(165);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(169);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(171);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(184);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(38);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(173);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(182);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(92);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(175);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(176);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(180);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(88);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(190);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(24);
	
	var _AsyncUtils = __webpack_require__(186);
	
	var _Actions = __webpack_require__(27);
	
	var _createLocation2 = __webpack_require__(188);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if (typeof action === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _PathUtils = __webpack_require__(24);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	_assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  checkpoint: function () {
	    return this._callbacks ? this._callbacks.length : 0;
	  },
	
	  rollback: function (len) {
	    if (this._callbacks) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var quoteAttributeValueForBrowser = __webpack_require__(264);
	var warning = __webpack_require__(3);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(21);
	var ReactElement = __webpack_require__(13);
	
	var emptyFunction = __webpack_require__(14);
	var traverseAllChildren = __webpack_require__(76);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var keyMirror = __webpack_require__(49);
	var keyOf = __webpack_require__(22);
	var warning = __webpack_require__(3);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec;
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function () {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentFlags
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	
	var checkReactTypeSpec = __webpack_require__(117);
	
	var canDefineProperty = __webpack_require__(68);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 107 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactFeatureFlags
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var invariant = __webpack_require__(2);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(222);
	
	var containsNode = __webpack_require__(268);
	var focusNode = __webpack_require__(125);
	var getActiveElement = __webpack_require__(126);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var DOMProperty = __webpack_require__(25);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMContainerInfo = __webpack_require__(214);
	var ReactDOMFeatureFlags = __webpack_require__(217);
	var ReactElement = __webpack_require__(13);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMarkupChecksum = __webpack_require__(235);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdateQueue = __webpack_require__(67);
	var ReactUpdates = __webpack_require__(16);
	
	var emptyObject = __webpack_require__(36);
	var instantiateReactComponent = __webpack_require__(121);
	var invariant = __webpack_require__(2);
	var setInnerHTML = __webpack_require__(48);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNodeTypes
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (ReactElement.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var emptyFunction = __webpack_require__(14);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '15.3.1';

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule checkReactTypeSpec
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(12);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getHostComponentFromComposite
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(112);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactCompositeComponent = __webpack_require__(210);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactHostComponent = __webpack_require__(108);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	var nextDebugID = 1;
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 122 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var setInnerHTML = __webpack_require__(48);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 127 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(291);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 130 */
[305, 287, 288, 290],
/* 131 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectTurtle = exports.selectTurtle = function selectTurtle(turtle) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "TURTLE_SELECTED",
	    payload: turtle
	  };
	};

/***/ },
/* 133 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectUser = exports.selectUser = function selectUser(user) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "USER_SELECTED",
	    payload: user
	  };
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _turtleList = __webpack_require__(137);
	
	var _turtleList2 = _interopRequireDefault(_turtleList);
	
	var _turtleDetail = __webpack_require__(136);
	
	var _turtleDetail2 = _interopRequireDefault(_turtleDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompTurtle = function CompTurtle() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Ninja Turtles List:'
	    ),
	    _react2.default.createElement(_turtleList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_turtleDetail2.default, null)
	  );
	};
	exports.default = CompTurtle;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _userList = __webpack_require__(139);
	
	var _userList2 = _interopRequireDefault(_userList);
	
	var _userDetail = __webpack_require__(138);
	
	var _userDetail2 = _interopRequireDefault(_userDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompUser = function CompUser() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Influential Persons List:'
	    ),
	    _react2.default.createElement(_userList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_userDetail2.default, null)
	  );
	};
	exports.default = CompUser;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var TurtleDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    turtle: state.activeTurtle
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(TurtleDetail, _React$Component);
	
	  function TurtleDetail() {
	    _classCallCheck(this, TurtleDetail);
	
	    return _possibleConstructorReturn(this, (TurtleDetail.__proto__ || Object.getPrototypeOf(TurtleDetail)).apply(this, arguments));
	  }
	
	  _createClass(TurtleDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.turtle) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite Ninja and click...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.turtle.image, width: '250', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.turtle.name,
	            ' aka "',
	            this.props.turtle.aka,
	            '"'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Age: ',
	            this.props.turtle.age,
	            '?'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description: ',
	            this.props.turtle.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Images and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return TurtleDetail;
	}(_react2.default.Component)) || _class);
	exports.default = TurtleDetail;
	// function mapStateToProps(state) {
	//   return {
	//     turtle: state.activeTurtle
	//   };
	// }
	// export default connect(mapStateToProps)(TurtleDetail);

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _turtle = __webpack_require__(132);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TurtleList = function (_React$Component) {
	  _inherits(TurtleList, _React$Component);
	
	  function TurtleList() {
	    _classCallCheck(this, TurtleList);
	
	    return _possibleConstructorReturn(this, (TurtleList.__proto__ || Object.getPrototypeOf(TurtleList)).apply(this, arguments));
	  }
	
	  _createClass(TurtleList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.turtles.map(function (turtle) {
	        return _react2.default.createElement(
	          'li',
	          { key: turtle.id, onClick: function onClick() {
	              return _this2.props.selectTurtle(turtle);
	            } },
	          turtle.name
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return TurtleList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    turtles: state.turtles
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectTurtle: _turtle.selectTurtle }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(TurtleList);

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var UserDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    user: state.activeUser
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(UserDetail, _React$Component);
	
	  function UserDetail() {
	    _classCallCheck(this, UserDetail);
	
	    return _possibleConstructorReturn(this, (UserDetail.__proto__ || Object.getPrototypeOf(UserDetail)).apply(this, arguments));
	  }
	
	  _createClass(UserDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.user) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite famous person and select...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.user.image, width: '300', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.user.name,
	            ' ',
	            this.props.user.last
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Born: ',
	            this.props.user.born
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Would have been ',
	            this.props.user.age,
	            ' yrs. old now, if were still alive.'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description: ',
	            this.props.user.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Photos and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return UserDetail;
	}(_react2.default.Component)) || _class);
	exports.default = UserDetail;
	
	// function mapStateToProps(state) {
	//   return {
	//     user: state.activeUser
	//   };
	// }
	// export default connect(mapStateToProps)(UserDetail);

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _user = __webpack_require__(133);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import store from '../store'
	
	// store.subscribe( () => {
	// console.log("Store changed", store.getState())
	// });
	// //below snippet is a sample of how to add a state into the code
	// //but should be matched by a corresponding reducer function to record and update this new state
	// store.dispatch({type: "ADD_USER_NAME", payload: "Rod"})
	// store.dispatch({type: "ADD_USER_AGE", payload: 23})
	
	var UserList = function (_React$Component) {
	  _inherits(UserList, _React$Component);
	
	  function UserList() {
	    _classCallCheck(this, UserList);
	
	    return _possibleConstructorReturn(this, (UserList.__proto__ || Object.getPrototypeOf(UserList)).apply(this, arguments));
	  }
	
	  _createClass(UserList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.users.map(function (user) {
	        return _react2.default.createElement(
	          'li',
	          { key: user.id, onClick: function onClick() {
	              return _this2.props.selectUser(user);
	            } },
	          user.name,
	          ' ',
	          user.last
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return UserList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    users: state.users
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectUser: _user.selectUser }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(UserList);

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _reducerUsers = __webpack_require__(144);
	
	var _reducerUsers2 = _interopRequireDefault(_reducerUsers);
	
	var _reducerTurtles = __webpack_require__(143);
	
	var _reducerTurtles2 = _interopRequireDefault(_reducerTurtles);
	
	var _reducerActiveUser = __webpack_require__(142);
	
	var _reducerActiveUser2 = _interopRequireDefault(_reducerActiveUser);
	
	var _reducerActiveTurtle = __webpack_require__(141);
	
	var _reducerActiveTurtle2 = _interopRequireDefault(_reducerActiveTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var allReducers = (0, _redux.combineReducers)({
	  users: _reducerUsers2.default,
	  turtles: _reducerTurtles2.default,
	  activeUser: _reducerActiveUser2.default,
	  activeTurtle: _reducerActiveTurtle2.default,
	  routing: _reactRouterRedux.routerReducer
	});
	
	exports.default = allReducers;

/***/ },
/* 141 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "TURTLE_SELECTED":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "USER_SELECTED":
	      return action.payload;
	      break;
	    case "ADD_USER_NAME":
	      return action.payload;
	      break;
	    case "ADD_USER_AGE":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    id: 1,
	    name: "Leonardo",
	    aka: "Leo",
	    age: 17,
	    image: _leonardo2.default,
	    description: "Leonardo is the cool, courageous leader of the Ninja Turtles and a devoted student of Ninjutsu, usually wearing a blue mask and wielding two katanas. Leader in blue."
	  }, {
	    id: 2,
	    name: "Michaelangelo",
	    aka: "Mickey",
	    age: 17,
	    image: _michaelangelo2.default,
	    description: "Michelangelo is the most comical of the Ninja Turtles, usually wearing an orange mask and wielding a pair of nunchucks."
	  }, {
	    id: 3,
	    name: "Donatello",
	    aka: "Donnie",
	    age: 16,
	    image: _donatello2.default,
	    description: "Donatello is the scientist, inventor, engineer and technological genius of the Ninja Turtles, usually wearing a purple mask and wielding a bo-staff."
	  }, {
	    id: 4,
	    name: "Raphael",
	    aka: "Raph",
	    age: 18,
	    image: _raphael2.default,
	    description: "Raphael is the bad boy of the Ninja Turtles, wearing a red mask and wielding a pair of sais."
	  }];
	};
	
	var _leonardo = __webpack_require__(301);
	
	var _leonardo2 = _interopRequireDefault(_leonardo);
	
	var _michaelangelo = __webpack_require__(302);
	
	var _michaelangelo2 = _interopRequireDefault(_michaelangelo);
	
	var _donatello = __webpack_require__(300);
	
	var _donatello2 = _interopRequireDefault(_donatello);
	
	var _raphael = __webpack_require__(303);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    id: 1,
	    name: "Leonardo",
	    last: "Da Vinci",
	    born: "April 15, 1452",
	    age: 564,
	    image: _daVinci2.default,
	    description: "Leonardo di ser Piero da Vinci, more commonly Leonardo a Vinci or simply Leonardo, was an Italian polymath whose areas of interest included invention, painting, sculpting, architecture, science, music, mathematics, engineering, literature, anatomy, geology, astronomy, botany, writing, history, and cartography. He has been variously called the father of palaeontology, ichnology, and architecture, and is widely considered one of the greatest painters of all time. Sometimes credited with the inventions of the parachute, helicopter and tank, he epitomised the Renaissance humanist ideal."
	  }, {
	    id: 2,
	    name: "Isaac",
	    last: "Newton",
	    born: "January 4, 1643",
	    age: 373,
	    image: _Newton2.default,
	    description: "Sir Isaac Newton was an English physicist and mathematician (described in his own day as a \"natural philosopher\") who is widely recognised as one of the most influential scientists of all time and a key figure in the scientific revolution. His book Philosophiæ Naturalis Principia Mathematica (\"Mathematical Principles of Natural Philosophy\"), first published in 1687, laid the foundations for classical mechanics. Newton made seminal contributions to optics, and he shares credit with Gottfried Wilhelm Leibniz for the development of calculus."
	  }, {
	    id: 3,
	    name: "Leonhard",
	    last: "Euler",
	    born: "April 15, 1707",
	    age: 309,
	    image: _Euler2.default,
	    description: "Leonhard Euler was a Swiss mathematician, physicist, astronomer, logician and engineer who made important and influential discoveries in many branches of mathematics like infinitesimal calculus and graph theory while also making pioneering contributions to several branches such as topology and analytic number theory. He also introduced much of the modern mathematical terminology and notation, particularly for mathematical analysis, such as the notion of a mathematical function.  He is also known for his work in mechanics, fluid dynamics, optics, astronomy, and music theory."
	  }, {
	    id: 4,
	    name: "Albert",
	    last: "Einstein",
	    born: "March 14, 1879",
	    age: 137,
	    image: _Einstein2.default,
	    description: "Albert Einstein was a German-born theoretical physicist. He developed the general theory of relativity, one of the two pillars of modern physics (alongside quantum mechanics).  Einstein's work is also known for its influence on the philosophy of science.  Einstein is best known in popular culture for his mass–energy equivalence formula E = mc2 (which has been dubbed \"the world's most famous equation\").  He received the 1921 Nobel Prize in Physics for his \"services to theoretical physics\", in particular his discovery of the law of the photoelectric effect, a pivotal step in the evolution of quantum theory."
	  }, {
	    id: 5,
	    name: "Erwin",
	    last: "Schroedinger",
	    born: "August 12, 1887",
	    age: 129,
	    image: _Schroedinger2.default,
	    description: "Erwin Rudolf Josef Alexander Schrödinger, sometimes written as Erwin Schrodinger or Erwin Schroedinger, was a Nobel Prize-winning Austrian physicist who developed a number of fundamental results in the field of quantum theory, which formed the basis of wave mechanics: he formulated the wave equation (stationary and time-dependent Schrödinger equation) and revealed the identity of his development of the formalism and matrix mechanics. Schrödinger proposed an original interpretation of the physical meaning of the wave function."
	  }, {
	    id: 6,
	    name: "Georges",
	    last: "Lemaitre",
	    born: "July 17, 1894",
	    image: _Lemaitre2.default,
	    age: 122,
	    description: "Georges Henri Joseph Édouard Lemaître was a Belgian priest, astronomer and professor of physics at the Catholic University of Leuven.  He proposed the theory of the expansion of the universe, widely misattributed to Edwin Hubble.  He was the first to derive what is now known as Hubble's law and made the first estimation of what is now called the Hubble constant, which he published in 1927, two years before Hubble's article.  Lemaître also proposed what became known as the Big Bang theory of the origin of the universe, which he called his \"hypothesis of the primeval atom\" or the \"Cosmic Egg\"."
	  }, {
	    id: 7,
	    name: "Mother",
	    last: "Teresa",
	    born: "August 26, 1910",
	    age: 106,
	    image: _MTeresa2.default,
	    description: "Mother Teresa MC, known in the Catholic Church as Saint Teresa of Calcutta was an Albanian-Indian Roman Catholic nun and missionary.  She was born in Skopje (now capital of the Republic of Macedonia), then part of the Kosovo Vilayet in the Ottoman Empire. After having lived in Macedonia for eighteen years, she moved to Ireland and then to India, where she lived for most of her life.  In 1950, Teresa founded the Missionaries of Charity, a Roman Catholic religious congregation, which in 2012 consisted of over 4,500 sisters and was active in 133 countries. They run homes for people dying of HIV/AIDS, leprosy and tuberculosis; soup kitchens; dispensaries and mobile clinics; children's and family counselling programmes; orphanages; and schools. Members must adhere to the vows of chastity, poverty, and obedience, as well as a fourth vow, to give \"wholehearted free service to the poorest of the poor.\""
	  }];
	};
	
	var _daVinci = __webpack_require__(299);
	
	var _daVinci2 = _interopRequireDefault(_daVinci);
	
	var _Einstein = __webpack_require__(293);
	
	var _Einstein2 = _interopRequireDefault(_Einstein);
	
	var _Euler = __webpack_require__(294);
	
	var _Euler2 = _interopRequireDefault(_Euler);
	
	var _Lemaitre = __webpack_require__(295);
	
	var _Lemaitre2 = _interopRequireDefault(_Lemaitre);
	
	var _MTeresa = __webpack_require__(296);
	
	var _MTeresa2 = _interopRequireDefault(_MTeresa);
	
	var _Newton = __webpack_require__(297);
	
	var _Newton2 = _interopRequireDefault(_Newton);
	
	var _Schroedinger = __webpack_require__(298);
	
	var _Schroedinger2 = _interopRequireDefault(_Schroedinger);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _container = __webpack_require__(146);
	
	var _home = __webpack_require__(147);
	
	var _user = __webpack_require__(150);
	
	var _turtles = __webpack_require__(149);
	
	var _notfound = __webpack_require__(148);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var history = (0, _reactRouterRedux.syncHistoryWithStore)(_reactRouter.browserHistory, _store2.default);
	
	var App = function (_React$Component) {
	  _inherits(App, _React$Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        _reactRouter.Router,
	        { history: history },
	        _react2.default.createElement(
	          _reactRouter.Route,
	          { path: '/', component: _container.Container },
	          _react2.default.createElement(_reactRouter.IndexRoute, { component: _home.Home }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'user', component: _user.User }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'turtles(/:name)', component: _turtles.Turtles }),
	          _react2.default.createElement(_reactRouter.Route, { path: '*', component: _notfound.NotFound })
	        )
	      );
	    }
	  }]);
	
	  return App;
	}(_react2.default.Component);
	
	exports.default = App;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Container = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  fontFamily: 'Dosis'
	};
	
	var Container = exports.Container = function Container(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement(Nav, null),
	    props.children
	  );
	};
	var Nav = function Nav() {
	  return _react2.default.createElement(
	    'nav',
	    { className: 'navbar navbar-inverse' },
	    _react2.default.createElement(
	      'div',
	      { className: 'container-fluid' },
	      _react2.default.createElement(
	        'div',
	        { className: 'navbar-header' },
	        _react2.default.createElement(
	          'button',
	          { type: 'button', className: 'navbar-toggle', 'data-toggle': 'collapse', 'data-target': '#myNavbar' },
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' })
	        )
	      )
	    ),
	    _react2.default.createElement(
	      'div',
	      { className: 'collapse navbar-collapse', id: 'myNavbar' },
	      _react2.default.createElement(
	        'ul',
	        { className: 'nav navbar-nav' },
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/' },
	            'Home'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/user' },
	            'Famous People'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/turtles' },
	            'Mutant Turtles'
	          )
	        )
	      )
	    )
	  );
	};

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Home = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Home = exports.Home = function Home() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'Welcome to the World of famE and muTAatIoNs!'
	    ),
	    _react2.default.createElement(
	      'h4',
	      null,
	      '> click on navigation to see more...'
	    )
	  );
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NotFound = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NotFound = exports.NotFound = function NotFound() {
	  return _react2.default.createElement(
	    'h2',
	    null,
	    '404: This page is not found!'
	  );
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Turtles = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compTurtle = __webpack_require__(134);
	
	var _compTurtle2 = _interopRequireDefault(_compTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Turtles = exports.Turtles = function Turtles(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Turtles Page'
	    ),
	    _react2.default.createElement(_compTurtle2.default, null)
	  );
	};

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.User = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compUser = __webpack_require__(135);
	
	var _compUser2 = _interopRequireDefault(_compUser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var User = exports.User = function User() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Famous People Page'
	    ),
	    _react2.default.createElement(_compUser2.default, null)
	  );
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(211);


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (process.env.NODE_ENV !== 'production') {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(154);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(155);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(162);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(156);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(157);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (process.env.NODE_ENV !== 'production') {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 154 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(37);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {
	
	                }
	            }
	        }
	    }
	
	    return targetComponent;
	};


/***/ },
/* 157 */
10,
/* 158 */
[304, 160],
/* 159 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 160 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 161 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 162 */
[305, 158, 159, 161],
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports['default'] = routerMiddleware;
	
	var _actions = __webpack_require__(82);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	/**
	 * This middleware captures CALL_HISTORY_METHOD actions to redirect to the
	 * provided history object. This will prevent these actions from reaching your
	 * reducer or any middleware that comes after this one.
	 */
	function routerMiddleware(history) {
	  return function () {
	    return function (next) {
	      return function (action) {
	        if (action.type !== _actions.CALL_HISTORY_METHOD) {
	          return next(action);
	        }
	
	        var _action$payload = action.payload;
	        var method = _action$payload.method;
	        var args = _action$payload.args;
	
	        history[method].apply(history, _toConsumableArray(args));
	      };
	    };
	  };
	}

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = syncHistoryWithStore;
	
	var _reducer = __webpack_require__(84);
	
	var defaultSelectLocationState = function defaultSelectLocationState(state) {
	  return state.routing;
	};
	
	/**
	 * This function synchronizes your history state with the Redux store.
	 * Location changes flow from history to the store. An enhanced history is
	 * returned with a listen method that responds to store updates for location.
	 *
	 * When this history is provided to the router, this means the location data
	 * will flow like this:
	 * history.push -> store.dispatch -> enhancedHistory.listen -> router
	 * This ensures that when the store state changes due to a replay or other
	 * event, the router will be updated appropriately and can transition to the
	 * correct router state.
	 */
	function syncHistoryWithStore(history, store) {
	  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	  var _ref$selectLocationSt = _ref.selectLocationState;
	  var selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt;
	  var _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay;
	  var adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;
	
	  // Ensure that the reducer is mounted on the store and functioning properly.
	  if (typeof selectLocationState(store.getState()) === 'undefined') {
	    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');
	  }
	
	  var initialLocation = void 0;
	  var isTimeTraveling = void 0;
	  var unsubscribeFromStore = void 0;
	  var unsubscribeFromHistory = void 0;
	
	  // What does the store say about current location?
	  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {
	    var locationState = selectLocationState(store.getState());
	    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);
	  };
	
	  // Init currentLocation with potential location in store
	  var currentLocation = getLocationInStore();
	
	  // If the store is replayed, update the URL in the browser to match.
	  if (adjustUrlOnReplay) {
	    var handleStoreChange = function handleStoreChange() {
	      var locationInStore = getLocationInStore(true);
	      if (currentLocation === locationInStore) {
	        return;
	      }
	
	      // Update address bar to reflect store state
	      isTimeTraveling = true;
	      currentLocation = locationInStore;
	      history.transitionTo(_extends({}, locationInStore, {
	        action: 'PUSH'
	      }));
	      isTimeTraveling = false;
	    };
	
	    unsubscribeFromStore = store.subscribe(handleStoreChange);
	    handleStoreChange();
	  }
	
	  // Whenever location changes, dispatch an action to get it in the store
	  var handleLocationChange = function handleLocationChange(location) {
	    // ... unless we just caused that location change
	    if (isTimeTraveling) {
	      return;
	    }
	
	    // Remember where we are
	    currentLocation = location;
	
	    // Are we being called for the first time?
	    if (!initialLocation) {
	      // Remember as a fallback in case state is reset
	      initialLocation = location;
	
	      // Respect persisted location, if any
	      if (getLocationInStore()) {
	        return;
	      }
	    }
	
	    // Tell the store to update by dispatching an action
	    store.dispatch({
	      type: _reducer.LOCATION_CHANGE,
	      payload: location
	    });
	  };
	  unsubscribeFromHistory = history.listen(handleLocationChange);
	
	  // The enhanced history uses store as source of truth
	  return _extends({}, history, {
	    // The listeners are subscribed to the store instead of history
	
	    listen: function listen(listener) {
	      // Copy of last location.
	      var lastPublishedLocation = getLocationInStore(true);
	
	      // Keep track of whether we unsubscribed, as Redux store
	      // only applies changes in subscriptions on next dispatch
	      var unsubscribed = false;
	      var unsubscribeFromStore = store.subscribe(function () {
	        var currentLocation = getLocationInStore(true);
	        if (currentLocation === lastPublishedLocation) {
	          return;
	        }
	        lastPublishedLocation = currentLocation;
	        if (!unsubscribed) {
	          listener(lastPublishedLocation);
	        }
	      });
	
	      // History listeners expect a synchronous call. Make the first call to the
	      // listener after subscribing to the store, in case the listener causes a
	      // location change (e.g. when it redirects)
	      listener(lastPublishedLocation);
	
	      // Let user unsubscribe later
	      return function () {
	        unsubscribed = true;
	        unsubscribeFromStore();
	      };
	    },
	
	
	    // It also provides a way to destroy internal listeners
	    unsubscribe: function unsubscribe() {
	      if (adjustUrlOnReplay) {
	        unsubscribeFromStore();
	      }
	      unsubscribeFromHistory();
	    }
	  });
	}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(85);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(86);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(187);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(26);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(88);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation, nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(20);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(195);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 186 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	          window.history.pushState(historyState, null, path);
	        }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	          window.history.replaceState(historyState, null, path);
	        }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if (typeof action === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(24);
	
	var _Actions = __webpack_require__(27);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if (typeof entry === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(192);
	var isArguments = __webpack_require__(191);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ },
/* 191 */
/***/ function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ },
/* 192 */
/***/ function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;
	
	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strictUriEncode = __webpack_require__(194);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};


/***/ },
/* 194 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};


/***/ },
/* 195 */
156,
/* 196 */
15,
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var focusNode = __webpack_require__(125);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var FallbackCompositionState = __webpack_require__(204);
	var SyntheticCompositionEvent = __webpack_require__(248);
	var SyntheticInputEvent = __webpack_require__(251);
	
	var keyOf = __webpack_require__(22);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactInstrumentation = __webpack_require__(11);
	
	var camelizeStyleName = __webpack_require__(267);
	var dangerousStyleValue = __webpack_require__(257);
	var hyphenateStyleName = __webpack_require__(274);
	var memoizeStringOnly = __webpack_require__(277);
	var warning = __webpack_require__(3);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	var isEventSupported = __webpack_require__(74);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createNodesFromMarkup = __webpack_require__(270);
	var emptyFunction = __webpack_require__(14);
	var invariant = __webpack_require__(2);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(22);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticMouseEvent = __webpack_require__(46);
	
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactComponent = __webpack_require__(61);
	var ReactPureComponent = __webpack_require__(238);
	var ReactClass = __webpack_require__(102);
	var ReactDOMFactories = __webpack_require__(216);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypes = __webpack_require__(113);
	var ReactVersion = __webpack_require__(114);
	
	var onlyChild = __webpack_require__(263);
	var warning = __webpack_require__(3);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function () {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(29);
	
	var instantiateReactComponent = __webpack_require__(121);
	var KeyEscapeUtils = __webpack_require__(59);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(12);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildrenMutationWarningHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element._shadowChildren === undefined) {
	    return;
	  }
	  if (element._shadowChildren === element.props.children) {
	    return;
	  }
	  var isMutated = false;
	  if (Array.isArray(element._shadowChildren)) {
	    if (element._shadowChildren.length === element.props.children.length) {
	      for (var i = 0; i < element._shadowChildren.length; i++) {
	        if (element._shadowChildren[i] !== element.props.children[i]) {
	          isMutated = true;
	        }
	      }
	    } else {
	      isMutated = true;
	    }
	  }
	  if (!Array.isArray(element._shadowChildren) || isMutated) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Component\'s children should not be mutated.%s', ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	var ReactChildrenMutationWarningHook = {
	  onMountComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  },
	  onUpdateComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  }
	};
	
	module.exports = ReactChildrenMutationWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMIDOperations = __webpack_require__(218);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	var ReactErrorUtils = __webpack_require__(63);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactNodeTypes = __webpack_require__(112);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactReconciler = __webpack_require__(29);
	
	var checkReactTypeSpec = __webpack_require__(117);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var shallowEqual = __webpack_require__(78);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function invokeComponentDidMountWithTimer() {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	  publicInstance.componentDidMount();
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	}
	
	function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	  publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	    var instanceOrElement;
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	      instanceOrElement = new Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	    } else {
	      // This can still be an instance in case of factory components
	      // but we'll count this as time spent rendering as the more common case.
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	      instanceOrElement = Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	    }
	    return instanceOrElement;
	  },
	
	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onError();
	        }
	      }
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      inst.componentWillMount();
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var selfDebugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      selfDebugID = this._debugID;
	    }
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        inst.componentWillUnmount();
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	    }
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onEndProcessingChildContext();
	    }
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	      inst.componentWillReceiveProps(nextProps, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = this._debugID;
	      }
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedComponent === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDefaultInjection = __webpack_require__(229);
	var ReactMount = __webpack_require__(110);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdates = __webpack_require__(16);
	var ReactVersion = __webpack_require__(114);
	
	var findDOMNode = __webpack_require__(258);
	var getHostComponentFromComposite = __webpack_require__(119);
	var renderSubtreeIntoContainer = __webpack_require__(265);
	var warning = __webpack_require__(3);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(9);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(11);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(226);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(220);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var DisabledInputUtils = __webpack_require__(42);
	
	/**
	 * Implements a <button> host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getHostProps: DisabledInputUtils.getHostProps
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var AutoFocusUtils = __webpack_require__(197);
	var CSSPropertyOperations = __webpack_require__(199);
	var DOMLazyTree = __webpack_require__(28);
	var DOMNamespaces = __webpack_require__(57);
	var DOMProperty = __webpack_require__(25);
	var DOMPropertyOperations = __webpack_require__(100);
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactDOMButton = __webpack_require__(212);
	var ReactDOMComponentFlags = __webpack_require__(103);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMInput = __webpack_require__(219);
	var ReactDOMOption = __webpack_require__(221);
	var ReactDOMSelect = __webpack_require__(104);
	var ReactDOMTextarea = __webpack_require__(224);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChild = __webpack_require__(236);
	var ReactServerRenderingTransaction = __webpack_require__(241);
	
	var emptyFunction = __webpack_require__(14);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var isEventSupported = __webpack_require__(74);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(3);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setContentChildForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setContentChildForInstrumentation = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setContentChildForInstrumentation.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getHostProps(this, props, hostParent);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getHostProps(this, lastProps);
	        nextProps = ReactDOMButton.getHostProps(this, nextProps);
	        break;
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setContentChildForInstrumentation.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function () {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setContentChildForInstrumentation.call(this, null);
	    }
	  },
	
	  getPublicInstance: function () {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMContainerInfo
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(77);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMEmptyComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 217 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var DOMPropertyOperations = __webpack_require__(100);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked !== undefined : props.value !== undefined;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, DisabledInputUtils.getHostProps(inst, props), {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMNullInputValuePropHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMSelect = __webpack_require__(104);
	
	var warning = __webpack_require__(3);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  ReactChildren.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var getNodeForCharacterOffset = __webpack_require__(261);
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DOMChildrenOperations = __webpack_require__(56);
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting('#text', this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTreeTraversal
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], false, arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], true, arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], true, argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], false, argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMUnknownPropertyHook
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDebugTool
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(234);
	var ReactHostOperationHistoryHook = __webpack_require__(232);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactChildrenMutationWarningHook = __webpack_require__(208);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performanceNow = __webpack_require__(279);
	var warning = __webpack_require__(3);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = null;
	var currentFlushStartTime = null;
	var currentTimerDebugID = null;
	var currentTimerStartTime = null;
	var currentTimerNestedFlushDuration = null;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || ReactComponentTreeHook.getOwnerID(parentID),
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements || [];
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = null;
	    currentFlushMeasurements = null;
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
	
	  var startTime = _lifeCycleTimerStack$.startTime;
	  var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
	  var debugID = _lifeCycleTimerStack$.debugID;
	  var timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }
	
	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }
	
	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onError: function (debugID) {
	    if (currentTimerDebugID != null) {
	      endLifeCycleTimer(currentTimerDebugID, currentTimerType);
	    }
	    emitEvent('onError', debugID);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (debugID, type, payload) {
	    checkDebugID(debugID);
	    emitEvent('onHostOperation', debugID, type, payload);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	ReactDebugTool.addHook(ReactChildrenMutationWarningHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactUpdates = __webpack_require__(16);
	var Transaction = __webpack_require__(35);
	
	var emptyFunction = __webpack_require__(14);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(198);
	var ChangeEventPlugin = __webpack_require__(200);
	var DefaultEventPluginOrder = __webpack_require__(202);
	var EnterLeaveEventPlugin = __webpack_require__(203);
	var HTMLDOMPropertyConfig = __webpack_require__(205);
	var ReactComponentBrowserEnvironment = __webpack_require__(209);
	var ReactDOMComponent = __webpack_require__(213);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMEmptyComponent = __webpack_require__(215);
	var ReactDOMTreeTraversal = __webpack_require__(225);
	var ReactDOMTextComponent = __webpack_require__(223);
	var ReactDefaultBatchingStrategy = __webpack_require__(228);
	var ReactEventListener = __webpack_require__(231);
	var ReactInjection = __webpack_require__(233);
	var ReactReconcileTransaction = __webpack_require__(239);
	var SVGDOMPropertyConfig = __webpack_require__(243);
	var SelectEventPlugin = __webpack_require__(244);
	var SimpleEventPlugin = __webpack_require__(245);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(31);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventListener = __webpack_require__(124);
	var ExecutionEnvironment = __webpack_require__(9);
	var PooledClass = __webpack_require__(21);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var getEventTarget = __webpack_require__(72);
	var getUnboundedScrollPosition = __webpack_require__(272);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 232 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostOperationHistoryHook
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (debugID, type, payload) {
	    history.push({
	      instanceID: debugID,
	      type: type,
	      payload: payload
	    });
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactClass = __webpack_require__(102);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactHostComponent = __webpack_require__(108);
	var ReactUpdates = __webpack_require__(16);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInvalidSetStateWarningHook
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(256);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(29);
	var ReactChildReconciler = __webpack_require__(207);
	
	var emptyFunction = __webpack_require__(14);
	var flattenChildren = __webpack_require__(259);
	var invariant = __webpack_require__(2);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPureComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactInputSelection = __webpack_require__(109);
	var ReactInstrumentation = __webpack_require__(11);
	var Transaction = __webpack_require__(35);
	var ReactUpdateQueue = __webpack_require__(67);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(237);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement.ref !== prevElement.ref ||
	    // If owner changes but we have an unchanged function ref, don't update refs
	    typeof nextElement.ref === 'string' && nextElement._owner !== prevElement._owner
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	var Transaction = __webpack_require__(35);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactServerUpdateQueue = __webpack_require__(242);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function () {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},
	
	  checkpoint: function () {},
	
	  rollback: function () {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerUpdateQueue
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactUpdateQueue = __webpack_require__(67);
	var Transaction = __webpack_require__(35);
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  /* :: transaction: Transaction; */
	
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 243 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInputSelection = __webpack_require__(109);
	var SyntheticEvent = __webpack_require__(19);
	
	var getActiveElement = __webpack_require__(126);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var EventListener = __webpack_require__(124);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticAnimationEvent = __webpack_require__(246);
	var SyntheticClipboardEvent = __webpack_require__(247);
	var SyntheticEvent = __webpack_require__(19);
	var SyntheticFocusEvent = __webpack_require__(250);
	var SyntheticKeyboardEvent = __webpack_require__(252);
	var SyntheticMouseEvent = __webpack_require__(46);
	var SyntheticDragEvent = __webpack_require__(249);
	var SyntheticTouchEvent = __webpack_require__(253);
	var SyntheticTransitionEvent = __webpack_require__(254);
	var SyntheticUIEvent = __webpack_require__(34);
	var SyntheticWheelEvent = __webpack_require__(255);
	
	var emptyFunction = __webpack_require__(14);
	var getEventCharCode = __webpack_require__(70);
	var invariant = __webpack_require__(2);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  animationEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationEnd: true }),
	      captured: keyOf({ onAnimationEndCapture: true })
	    }
	  },
	  animationIteration: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationIteration: true }),
	      captured: keyOf({ onAnimationIterationCapture: true })
	    }
	  },
	  animationStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationStart: true }),
	      captured: keyOf({ onAnimationStartCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  invalid: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInvalid: true }),
	      captured: keyOf({ onInvalidCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  transitionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTransitionEnd: true }),
	      captured: keyOf({ onTransitionEndCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topAnimationEnd: eventTypes.animationEnd,
	  topAnimationIteration: eventTypes.animationIteration,
	  topAnimationStart: eventTypes.animationStart,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topInvalid: eventTypes.invalid,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topTransitionEnd: eventTypes.transitionEnd,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topInvalid:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topAnimationEnd:
	      case topLevelTypes.topAnimationIteration:
	      case topLevelTypes.topAnimationStart:
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case topLevelTypes.topTransitionEnd:
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticAnimationEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventCharCode = __webpack_require__(70);
	var getEventKey = __webpack_require__(260);
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTransitionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 256 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var warning = __webpack_require__(3);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstanceMap = __webpack_require__(33);
	
	var getHostComponentFromComposite = __webpack_require__(119);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 * 
	 */
	
	'use strict';
	
	var KeyEscapeUtils = __webpack_require__(59);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(12);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(70);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 261 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getVendorPrefixedEventName
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(110);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 266 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(266);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(276);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createArrayFromMixed = __webpack_require__(269);
	var getMarkupWrap = __webpack_require__(271);
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 272 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 273 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(273);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 275 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(275);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 277 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(278);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 280 */
/***/ function(module, exports) {

	"use strict";
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }
	
	var repeat = function repeat(str, times) {
	  return new Array(times + 1).join(str);
	};
	var pad = function pad(num, maxLength) {
	  return repeat("0", maxLength - num.toString().length) + num;
	};
	var formatTime = function formatTime(time) {
	  return "@ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
	};
	
	// Use the new performance api to get better precision if available
	var timer = typeof performance !== "undefined" && typeof performance.now === "function" ? performance : Date;
	
	/**
	 * parse the level option of createLogger
	 *
	 * @property {string | function | object} level - console[level]
	 * @property {object} action
	 * @property {array} payload
	 * @property {string} type
	 */
	
	function getLogLevel(level, action, payload, type) {
	  switch (typeof level === "undefined" ? "undefined" : _typeof(level)) {
	    case "object":
	      return typeof level[type] === "function" ? level[type].apply(level, _toConsumableArray(payload)) : level[type];
	    case "function":
	      return level(action);
	    default:
	      return level;
	  }
	}
	
	/**
	 * Creates logger with followed options
	 *
	 * @namespace
	 * @property {object} options - options for logger
	 * @property {string | function | object} options.level - console[level]
	 * @property {boolean} options.duration - print duration of each action?
	 * @property {boolean} options.timestamp - print timestamp with each action?
	 * @property {object} options.colors - custom colors
	 * @property {object} options.logger - implementation of the `console` API
	 * @property {boolean} options.logErrors - should errors in action execution be caught, logged, and re-thrown?
	 * @property {boolean} options.collapsed - is group collapsed?
	 * @property {boolean} options.predicate - condition which resolves logger behavior
	 * @property {function} options.stateTransformer - transform state before print
	 * @property {function} options.actionTransformer - transform action before print
	 * @property {function} options.errorTransformer - transform error before print
	 */
	
	function createLogger() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var _options$level = options.level;
	  var level = _options$level === undefined ? "log" : _options$level;
	  var _options$logger = options.logger;
	  var logger = _options$logger === undefined ? console : _options$logger;
	  var _options$logErrors = options.logErrors;
	  var logErrors = _options$logErrors === undefined ? true : _options$logErrors;
	  var collapsed = options.collapsed;
	  var predicate = options.predicate;
	  var _options$duration = options.duration;
	  var duration = _options$duration === undefined ? false : _options$duration;
	  var _options$timestamp = options.timestamp;
	  var timestamp = _options$timestamp === undefined ? true : _options$timestamp;
	  var transformer = options.transformer;
	  var _options$stateTransfo = options.stateTransformer;
	  var // deprecated
	  stateTransformer = _options$stateTransfo === undefined ? function (state) {
	    return state;
	  } : _options$stateTransfo;
	  var _options$actionTransf = options.actionTransformer;
	  var actionTransformer = _options$actionTransf === undefined ? function (actn) {
	    return actn;
	  } : _options$actionTransf;
	  var _options$errorTransfo = options.errorTransformer;
	  var errorTransformer = _options$errorTransfo === undefined ? function (error) {
	    return error;
	  } : _options$errorTransfo;
	  var _options$colors = options.colors;
	  var colors = _options$colors === undefined ? {
	    title: function title() {
	      return "#000000";
	    },
	    prevState: function prevState() {
	      return "#9E9E9E";
	    },
	    action: function action() {
	      return "#03A9F4";
	    },
	    nextState: function nextState() {
	      return "#4CAF50";
	    },
	    error: function error() {
	      return "#F20404";
	    }
	  } : _options$colors;
	
	  // exit if console undefined
	
	  if (typeof logger === "undefined") {
	    return function () {
	      return function (next) {
	        return function (action) {
	          return next(action);
	        };
	      };
	    };
	  }
	
	  if (transformer) {
	    console.error("Option 'transformer' is deprecated, use stateTransformer instead");
	  }
	
	  var logBuffer = [];
	  function printBuffer() {
	    logBuffer.forEach(function (logEntry, key) {
	      var started = logEntry.started;
	      var startedTime = logEntry.startedTime;
	      var action = logEntry.action;
	      var prevState = logEntry.prevState;
	      var error = logEntry.error;
	      var took = logEntry.took;
	      var nextState = logEntry.nextState;
	
	      var nextEntry = logBuffer[key + 1];
	      if (nextEntry) {
	        nextState = nextEntry.prevState;
	        took = nextEntry.started - started;
	      }
	      // message
	      var formattedAction = actionTransformer(action);
	      var isCollapsed = typeof collapsed === "function" ? collapsed(function () {
	        return nextState;
	      }, action) : collapsed;
	
	      var formattedTime = formatTime(startedTime);
	      var titleCSS = colors.title ? "color: " + colors.title(formattedAction) + ";" : null;
	      var title = "action " + (timestamp ? formattedTime : "") + " " + formattedAction.type + " " + (duration ? "(in " + took.toFixed(2) + " ms)" : "");
	
	      // render
	      try {
	        if (isCollapsed) {
	          if (colors.title) logger.groupCollapsed("%c " + title, titleCSS);else logger.groupCollapsed(title);
	        } else {
	          if (colors.title) logger.group("%c " + title, titleCSS);else logger.group(title);
	        }
	      } catch (e) {
	        logger.log(title);
	      }
	
	      var prevStateLevel = getLogLevel(level, formattedAction, [prevState], "prevState");
	      var actionLevel = getLogLevel(level, formattedAction, [formattedAction], "action");
	      var errorLevel = getLogLevel(level, formattedAction, [error, prevState], "error");
	      var nextStateLevel = getLogLevel(level, formattedAction, [nextState], "nextState");
	
	      if (prevStateLevel) {
	        if (colors.prevState) logger[prevStateLevel]("%c prev state", "color: " + colors.prevState(prevState) + "; font-weight: bold", prevState);else logger[prevStateLevel]("prev state", prevState);
	      }
	
	      if (actionLevel) {
	        if (colors.action) logger[actionLevel]("%c action", "color: " + colors.action(formattedAction) + "; font-weight: bold", formattedAction);else logger[actionLevel]("action", formattedAction);
	      }
	
	      if (error && errorLevel) {
	        if (colors.error) logger[errorLevel]("%c error", "color: " + colors.error(error, prevState) + "; font-weight: bold", error);else logger[errorLevel]("error", error);
	      }
	
	      if (nextStateLevel) {
	        if (colors.nextState) logger[nextStateLevel]("%c next state", "color: " + colors.nextState(nextState) + "; font-weight: bold", nextState);else logger[nextStateLevel]("next state", nextState);
	      }
	
	      try {
	        logger.groupEnd();
	      } catch (e) {
	        logger.log("—— log end ——");
	      }
	    });
	    logBuffer.length = 0;
	  }
	
	  return function (_ref) {
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        // exit early if predicate function returns false
	        if (typeof predicate === "function" && !predicate(getState, action)) {
	          return next(action);
	        }
	
	        var logEntry = {};
	        logBuffer.push(logEntry);
	
	        logEntry.started = timer.now();
	        logEntry.startedTime = new Date();
	        logEntry.prevState = stateTransformer(getState());
	        logEntry.action = action;
	
	        var returnedValue = undefined;
	        if (logErrors) {
	          try {
	            returnedValue = next(action);
	          } catch (e) {
	            logEntry.error = errorTransformer(e);
	          }
	        } else {
	          returnedValue = next(action);
	        }
	
	        logEntry.took = timer.now() - logEntry.started;
	        logEntry.nextState = stateTransformer(getState());
	
	        printBuffer();
	
	        if (logEntry.error) throw logEntry.error;
	        return returnedValue;
	      };
	    };
	  };
	}
	
	module.exports = createLogger;

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = promiseMiddleware;
	
	var _isPromise = __webpack_require__(282);
	
	var _isPromise2 = _interopRequireDefault(_isPromise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultTypes = ['PENDING', 'FULFILLED', 'REJECTED'];
	
	/**
	 * @function promiseMiddleware
	 * @description
	 * @returns {function} thunk
	 */
	function promiseMiddleware() {
	  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var promiseTypeSuffixes = config.promiseTypeSuffixes || defaultTypes;
	
	  return function (ref) {
	    var dispatch = ref.dispatch;
	
	
	    return function (next) {
	      return function (action) {
	        if (action.payload) {
	          if (!(0, _isPromise2.default)(action.payload) && !(0, _isPromise2.default)(action.payload.promise)) {
	            return next(action);
	          }
	        } else {
	          return next(action);
	        }
	
	        // Deconstruct the properties of the original action object to constants
	        var type = action.type;
	        var payload = action.payload;
	        var meta = action.meta;
	
	        // Assign values for promise type suffixes
	
	        var _promiseTypeSuffixes = _slicedToArray(promiseTypeSuffixes, 3);
	
	        var PENDING = _promiseTypeSuffixes[0];
	        var FULFILLED = _promiseTypeSuffixes[1];
	        var REJECTED = _promiseTypeSuffixes[2];
	
	        /**
	         * @function getAction
	         * @description Utility function for creating a rejected or fulfilled
	         * flux standard action object.
	         * @param {boolean} Is the action rejected?
	         * @returns {object} action
	         */
	
	        var getAction = function getAction(newPayload, isRejected) {
	          return _extends({
	            type: type + '_' + (isRejected ? REJECTED : FULFILLED)
	          }, newPayload ? {
	            payload: newPayload
	          } : {}, !!meta ? { meta: meta } : {}, isRejected ? {
	            error: true
	          } : {});
	        };
	
	        /**
	         * Assign values for promise and data variables. In the case the payload
	         * is an object with a `promise` and `data` property, the values of those
	         * properties will be used. In the case the payload is a promise, the
	         * value of the payload will be used and data will be null.
	         */
	        var promise = void 0;
	        var data = void 0;
	
	        if (!(0, _isPromise2.default)(action.payload) && _typeof(action.payload) === 'object') {
	          promise = payload.promise;
	          data = payload.data;
	        } else {
	          promise = payload;
	          data = null;
	        }
	
	        /**
	         * First, dispatch the pending action. This flux standard action object
	         * describes the pending state of a promise and will include any data
	         * (for optimistic updates) and/or meta from the original action.
	         */
	        next(_extends({
	          type: type + '_' + PENDING
	        }, !!data ? { payload: data } : {}, !!meta ? { meta: meta } : {}));
	
	        /*
	         * @function handleReject
	         * @description Dispatch the rejected action and return
	         * an error object. The error object is the original error
	         * that was thrown. The user of the library is responsible for
	         * best practices in ensure that they are throwing an Error object.
	         * @params reason The reason the promise was rejected
	         * @returns {object}
	         */
	        var handleReject = function handleReject(reason) {
	          var rejectedAction = getAction(reason, true);
	          dispatch(rejectedAction);
	          throw reason;
	        };
	
	        /*
	         * @function handleFulfill
	         * @description Dispatch the fulfilled action and
	         * return the success object. The success object should
	         * contain the value and the dispatched action.
	         * @param value The value the promise was resloved with
	         * @returns {object}
	         */
	        var handleFulfill = function handleFulfill() {
	          var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	          var resolvedAction = getAction(value, false);
	          dispatch(resolvedAction);
	
	          return { value: value, action: resolvedAction };
	        };
	
	        /**
	         * Second, dispatch a rejected or fulfilled action. This flux standard
	         * action object will describe the resolved state of the promise. In
	         * the case of a rejected promise, it will include an `error` property.
	         *
	         * In order to allow proper chaining of actions using `then`, a new
	         * promise is constructed and returned. This promise will resolve
	         * with two properties: (1) the value (if fulfilled) or reason
	         * (if rejected) and (2) the flux standard action.
	         *
	         * Rejected object:
	         * {
	         *   reason: ...
	         *   action: {
	         *     error: true,
	         *     type: 'ACTION_REJECTED',
	         *     payload: ...
	         *   }
	         * }
	         *
	         * Fulfilled object:
	         * {
	         *   value: ...
	         *   action: {
	         *     type: 'ACTION_FULFILLED',
	         *     payload: ...
	         *   }
	         * }
	         */
	        return promise.then(handleFulfill, handleReject);
	      };
	    };
	  };
	}

/***/ },
/* 282 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isPromise;
	function isPromise(value) {
	  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	    return value && typeof value.then === 'function';
	  }
	
	  return false;
	}

/***/ },
/* 283 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch;
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 285 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(128);
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 287 */
[304, 289],
/* 288 */
159,
/* 289 */
160,
/* 290 */
161,
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(292)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 292 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 293 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 294 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 295 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 296 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8246d4457b3d3cffd1d90dbd91ed5f7f.jpg";

/***/ },
/* 300 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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jZdlgrzQv7myFldfJQFOk+E0XjLx/wO6IG3XnQWvfQAAAEx0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlREb25hdGVsbG8yMDEyLnBuZ1IQ5DAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDMtMDdUMjM6NTA6NTkrMDA6MDCf1JlFAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTAzLTA3VDIzOjUwOjU5KzAwOjAw7okh+QAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi42LjktNyAyMDE0LTAzLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ4HTs8MAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADQwNDFqrhIAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMjQ3FC4VkwAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNDI1NzcyMjU5PufDkwAAABJ0RVh0VGh1bWI6OlNpemUAMTIzS0JC4fuycgAAADN0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3RtcC9sb2NhbGNvcHlfYjg3YzQ1OWM0MzQ1LTEucG5nEZaXyAAAAABJRU5ErkJggg=="

/***/ },
/* 301 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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eUFugqPpskfsJlc6HA5vyaOo/69Ysnn/gkJVadt2cWVI17ArEK58Y/valW9sfxIo3/n4mYesSJtZGTStaohRQqdtlVsDMdK66HwbJr1evtrcqLLZ1pR2XKkgYnJDNPhq7r40uVF9bOfl8Vdi1L3FcEDTj23350dVjR2x8pYmJS4zyH/l2N3dXXy52A8ePss9UE5vA/v9jX5Z9osTYmQYvJoYYkdYjESUat7uXX966wvH3nL09PzyuLfzwg2id5KXWS2ZfXmy3/yLrZcn/3R8bfYtVcZdr7FoyBdlVTj05zIej7lx48byjVoC5Lsq4quAEveuTOfP/8crX53O3FMms9MQVULUvNXYd5kiGdTbzZVLX776r4+c27hr/4WdE9Or402MPOmb+K92r1X/dO/y/Pd95Te7UmrGTYbugUoJt6jfx39pyPJ/wX/1//8HVgkkVesS6AMFMDr14Im7jr/5yJvy4/378rXirlGeHZ9fmW8/+enn/7eTj5x4pN6cnNs9v/uVttGnmpm/3vUWflFScVPbKvJK+dAlOJYA+Z4JcwgktgNH2QGmI7VTDE4OV1ePDQf4aG+8uHMNRWNUr1GrQwBwh8qoP88AZxlLgHzPgkReBZTsEEjkVf2LHAJF7ICweL26x1iCYwmQN9R7sQCLPZRdzKtA8mf6l0M/F181CFjGEiBvyPdF/pwXf87Dr4dAw7LHWALkVm7oX/3wL4HwOsb/C6yPRSDGvMY7AAAARnRFWHRjb21tZW50AEZpbGUgc291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZpbGU6VE1OVExlbzIwMTIucG5nJXHGFgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wOS0xNlQyMzoyNzo0MSswMDowMI1cwmAAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDktMTZUMjM6Mjc6NDErMDA6MDD8AXrcAAAARnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjYuOS03IDIwMTItMDgtMTcgUTE2IGh0dHA6Ly93d3cuaW1hZ2VtYWdpY2sub3JnnL25SAAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABh0RVh0VGh1bWI6OkltYWdlOjpoZWlnaHQAMzkze4OWfQAAABd0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAAyNTJ9X9BdAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADEzNzkzNzQwNjFNTtgfAAAAEnRFWHRUaHVtYjo6U2l6ZQAxMzJLQkJkJ/ynAAAAM3RFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL2xvY2FsY29weV82YWIzYWMxMThhYzAtMS5wbmf+cubjAAAAAElFTkSuQmCC"

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9c4d774f69326da06fe8aea6030de373.png";

/***/ },
/* 303 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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fjL+8Y1Pbz/fEymMS0SfiAFUDSEl/6PX9mZb10ZVWVhpJg33frTH7e/dk8OHx4eN56/2j9LXYmKH3Pk664AjWcmt682q9LwCyAV0txSQg93Z3bW1Mq6Nqs/Mx01vf2cqvkmq1uqr/7XzytrVtfL69fWP9ZOSXCIlpaRHoQNc7cev/WDnwZXn1zcP7x/bH3/3Nnu3d/FNvDf3fOnRXvyKD7rbWo4TtwqIhUDP5DHduNovK4BcwFgEWvKTg9361mi90tGl/q8aoTcZN/Lg3mTv1ltHL115dvR5DXFr/GjG4aMJew/GHO7O2LlzwO0fP9y9c2f8hpvU1/dvPSzD1KHKnZmXP3u4H78agh4Cky44jEEHA0O/b/SzlXKrWW2WD+MqLvj9LWj1BTDORX7wPw+//KnPX5s9+8zg91F97sFPDl4OPh0e3Nq7svuGa5tWEtGHLBUdEo3TyXTCq0cPwhc2+lIFlW8e1+nLB8f+lZQ4bsFRt78rGCNqBB0NLYOB4Vs/WdmOlQW5aJG6PGZJFEgxqtu5O75ZleYOpLWHO/Xfbm31XywIX/QuSEqqISaJIZFiZqoSa16fOf5+UPBpMfKNvbH+8eE4/bcqkyVwRAG1xqgCvV5OC48nK4CsLMhF868UrM0khDFq6IIE8K//cP+fRsPipgvabG/3f9O7uA86EKUkaf6XKc6nKZnvxBB/NG34o+N5er2e6w6ngi+LJsQogopBU0xsXFljb3ey2iEf8nWhm4p+63c/wivfuEuM2h01PdEDBEoR6a+tFZct6QVr9bo1PBujNjHHFfOU2JkHect5PeKUySN0nhcsJdryX5NW2arVehoAMhiWxJBw7qTbtzti2uWX6iqoLuaylxnFu8BYvL6wSAAqsppBXa2nCCA/4567TB9F52GW3LHYsRQL0unE+TPgq7VaTz1Auve9TF7QlWbuyoCkpa9XwFit/9cAeRJYnhjzr0CxWu9m/S9ZhZZICVfkQwAAAEp0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlRSYXBoYWVsMjAxMi5wbmekbX/HAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTAzLTA3VDIzOjUwOjQ2KzAwOjAwpTbpMgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wMy0wN1QyMzo1MDo0NiswMDowMNRrUY4AAABGdEVYdHNvZnR3YXJlAEltYWdlTWFnaWNrIDYuNi45LTcgMjAxNC0wMy0wNiBRMTYgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmeB07PDAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAGHRFWHRUaHVtYjo6SW1hZ2U6OmhlaWdodAAzNTRJUkzSAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADI4MVH4/6oAAAAZdEVYdFRodW1iOjpNaW1ldHlwZQBpbWFnZS9wbmc/slZOAAAAF3RFWHRUaHVtYjo6TVRpbWUAMTQyNTc3MjI0NrdD70MAAAASdEVYdFRodW1iOjpTaXplADE1NEtCQs4MVtsAAAAzdEVYdFRodW1iOjpVUkkAZmlsZTovLy90bXAvbG9jYWxjb3B5X2RmZjUwZDE0OTNkZi0xLnBuZ/ZXEo0AAAAASUVORK5CYII="

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var overArg = __webpack_require__(__webpack_module_template_argument_0__);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var getPrototype = __webpack_require__(__webpack_module_template_argument_0__),
	    isHostObject = __webpack_require__(__webpack_module_template_argument_1__),
	    isObjectLike = __webpack_require__(__webpack_module_template_argument_2__);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ }
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjIxZGZjNmRmYzViZjM5M2Q2YjMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvcm91dGVyV2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NTGF6eVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2tleU1pcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc3RvcmVTaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvTGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlRE9NSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWciLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2FjdGlvbnMvdHVydGxlLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9hY3Rpb25zL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC11c2VyLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9jb250YWluZXJzL3R1cnRsZS1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdHVydGxlLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1saXN0LmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci1hY3RpdmUtdHVydGxlLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLWFjdGl2ZS11c2VyLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLXR1cnRsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItdXNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvY29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL3JvdXRlcy9ob21lLmpzIiwid2VicGFjazovLy8uL3JvdXRlcy9ub3Rmb3VuZC5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvdHVydGxlcy5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvdXNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi9jb21wb25lbnRzL1Byb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L34vbG9kYXNoL19pc0hvc3RPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvbWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhMaW5rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJlZGlyZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleFJvdXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaWZlY3ljbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGluZ0NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1RyYW5zaXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYXBwbHlSb3V0ZXJNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvY29tcHV0ZUNoYW5nZWRSb3V0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldENvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldFJvdXRlUGFyYW1zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9oYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaXNBY3RpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL21hdGNoLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlTG9jYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L3F1ZXJ5LXN0cmluZy9+L3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0F1dG9Gb2N1c1V0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0Rhbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01FbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVidWdUb29sLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQW5pbWF0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVG91Y2hFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC1sb2dnZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtcHJvbWlzZS1taWRkbGV3YXJlL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUvZGlzdC9pc1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC10aHVuay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvYXBwbHlNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21iaW5lUmVkdWNlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvfi9zeW1ib2wtb2JzZXJ2YWJsZS9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL0VpbnN0ZWluLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL0V1bGVyLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL0xlbWFpdHJlLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL01UZXJlc2EuanBnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvTmV3dG9uLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL1NjaHJvZWRpbmdlci5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9kYVZpbmNpLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2RvbmF0ZWxsby5wbmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9sZW9uYXJkby5wbmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9taWNoYWVsYW5nZWxvLnBuZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL3JhcGhhZWwucG5nIiwid2VicGFjazovLy8uL34vcmVkdXgvfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiXSwibmFtZXMiOlsicmVuZGVyIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm1pZGRsZXdhcmUiLCJzZWxlY3RUdXJ0bGUiLCJ0dXJ0bGUiLCJ0eXBlIiwicGF5bG9hZCIsInNlbGVjdFVzZXIiLCJ1c2VyIiwiQ29tcFR1cnRsZSIsIkNvbXBVc2VyIiwiVHVydGxlRGV0YWlsIiwic3RhdGUiLCJhY3RpdmVUdXJ0bGUiLCJwcm9wcyIsImltYWdlIiwibmFtZSIsImFrYSIsImFnZSIsImRlc2NyaXB0aW9uIiwiQ29tcG9uZW50IiwiVHVydGxlTGlzdCIsInR1cnRsZXMiLCJtYXAiLCJpZCIsImNyZWF0ZUxpc3RJdGVtcyIsIm1hcFN0YXRlVG9Qcm9wcyIsIm1hdGNoRGlzcGF0Y2hUb1Byb3BzIiwiZGlzcGF0Y2giLCJVc2VyRGV0YWlsIiwiYWN0aXZlVXNlciIsImxhc3QiLCJib3JuIiwiVXNlckxpc3QiLCJ1c2VycyIsImFsbFJlZHVjZXJzIiwicm91dGluZyIsImFjdGlvbiIsImhpc3RvcnkiLCJBcHAiLCJteVN0eWxlIiwiZm9udEZhbWlseSIsIkNvbnRhaW5lciIsImNoaWxkcmVuIiwiTmF2IiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiSG9tZSIsIk5vdEZvdW5kIiwiVHVydGxlcyIsIlVzZXIiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsb0JBQVNBLE1BQVQsQ0FDRTtBQUFBO0FBQUEsS0FBVSxzQkFBVjtBQUNFO0FBREYsRUFERixFQUlFQyxTQUFTQyxjQUFULENBQXdCLE1BQXhCLENBSkYsRTs7Ozs7O0FDTkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUMvSnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsNEI7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBLCtGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLDBCOzs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBb0Q7O0FBRXBELHVCQUFzQixtQkFBbUI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCOztBQUV4QjtBQUNBOztBQUVBLHFDOzs7Ozs7QUN0Q0E7O0FBRUE7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7QUMzTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxRkFBb0YsYUFBYTtBQUNqRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLHdCOzs7Ozs7O0FDcEJsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUEseUM7Ozs7Ozs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBbUMsZ0NBQWdDOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLG1DQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7OztBQ25OQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCOzs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWU7QUFD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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUM7Ozs7Ozs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUM7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1DOzs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLDRCQUE0QjtBQUN2QztBQUNBLGFBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsZUFBYywwQkFBMEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsU0FBUztBQUN0QixjQUFhLFNBQVM7QUFDdEIsY0FBYSxTQUFTO0FBQ3RCLGNBQWEsU0FBUztBQUN0QixjQUFhLFNBQVM7QUFDdEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsNkJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLHNEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEI7Ozs7Ozs7QUN4T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7OztBQ2xCQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7O0FDN0NBOztBQUVBOztBQUVBLHFHQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsa0dBQWtHOztBQUU5TyxvREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQjtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFZO0FBQ1osSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdEQUErQyw4QkFBOEI7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0EscUM7Ozs7Ozs7QUMzSkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDOzs7Ozs7O0FDMUVBOztBQUVBO0FBQ0E7QUFDQSwrQjs7Ozs7O0FDSkE7O0FBRUE7O0FBRUEsb0RBQW1ELGdCQUFnQixzQkFBc0IsT0FBTywyQkFBMkIsMEJBQTBCLHlEQUF5RCwyQkFBMkIsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFOVAsdUNBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTBFOztBQUUxRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVNQUFzTTs7QUFFdE07O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXdCO0FBQ3hCO0FBQ0EsUUFBTyxnQ0FBZ0MseUNBQXlDO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0SEFBMkg7O0FBRTNIO0FBQ0E7O0FBRUE7QUFDQSw0SEFBMkg7O0FBRTNIO0FBQ0E7O0FBRUE7QUFDQSx5RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLGVBQWUsU0FBUyxlQUFlO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBd0IsZUFBZSxTQUFTLGVBQWU7QUFDL0Q7O0FBRUEsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZFQUE0RTtBQUM1RSxzRkFBcUY7QUFDckYsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxxQzs7Ozs7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQSx3RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkI7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7Ozs7Ozs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQsMkM7Ozs7OztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQseUM7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxtSkFBa0o7O0FBRWxKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7Ozs7QUNuVEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Y0FBYSxPQUFPO0FBQ3BCLGNBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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RUg7QUFDQTtBQUNBLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Qjs7Ozs7OztBQzN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDOzs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdHQUF1RztBQUN2RztBQUNBOztBQUVBLGtCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLGtCQUFrQjtBQUM3QixZQUFXLFFBQVE7QUFDbkIsWUFBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixZQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQXlGOztBQUV6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFVBQVU7QUFDckIsWUFBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDOzs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsYUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLFVBQVU7QUFDckIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDOzs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQztBQUNBLGFBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQixZQUFXLFdBQVc7QUFDdEIsWUFBVywwQkFBMEI7QUFDckMsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLFlBQVcsV0FBVztBQUN0QixZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGVBQWU7QUFDMUIsWUFBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxZQUFZO0FBQ3ZCLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxZQUFZO0FBQ3ZCLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsWUFBWTtBQUN2QixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYSxlQUFlO0FBQzVCLGNBQWEsYUFBYTtBQUMxQixjQUFhLFdBQVc7QUFDeEIsY0FBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxhQUFhO0FBQzFCLGNBQWEsV0FBVztBQUN4QixjQUFhLFFBQVE7QUFDckIsZUFBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTEFBb0w7O0FBRXBMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxlQUFlO0FBQzVCLGNBQWEsYUFBYTtBQUMxQixjQUFhLFdBQVc7QUFDeEIsY0FBYSxVQUFVO0FBQ3ZCLGVBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsYUFBYTtBQUMxQixjQUFhLFdBQVc7QUFDeEIsY0FBYSxVQUFVO0FBQ3ZCLGVBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9MQUFtTDs7QUFFbkw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCOzs7Ozs7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCw2Qzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSLDRCQUEyQjtBQUMzQixPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLDJCQUEwQjtBQUMxQixNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkI7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDOzs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7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RUEsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUVBQXdFOztBQUV4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUM7Ozs7OztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsRUFBRTtBQUNmLGNBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQywwQkFBMEI7QUFDMUQscUJBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxrQkFBa0I7QUFDL0IsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDOzs7Ozs7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQixpQkFBaUI7QUFDdkMsd0JBQXVCLHdCQUF3QjtBQUMvQyxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOztBQUVBLDJDOzs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQSx3Qzs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0I7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzS0FBcUs7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCLGNBQWEsMEJBQTBCO0FBQ3ZDLGNBQWEsT0FBTztBQUNwQixlQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUM7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsb0NBQW9DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRDs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtRDs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSwwREFBMEQ7QUFDdkUsY0FBYSxRQUFRO0FBQ3JCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFFBQVE7QUFDckIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxnT0FBK04sK0JBQStCO0FBQzlQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEscURBQW9EO0FBQ3BEO0FBQ0Esd0JBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSwwREFBMEQ7QUFDdkUsY0FBYSxtQkFBbUI7QUFDaEMsY0FBYSxRQUFRO0FBQ3JCLGNBQWEsT0FBTztBQUNwQixlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLDBEQUEwRDtBQUN2RSxjQUFhLE9BQU87QUFDcEIsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsMERBQTBEO0FBQ3ZFLGNBQWEsT0FBTztBQUNwQixjQUFhLE9BQU87QUFDcEIsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0Esd0JBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGFBQWE7QUFDMUIsY0FBYSwwREFBMEQ7QUFDdkUsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSwwQkFBMEI7QUFDdkMsY0FBYSxhQUFhO0FBQzFCLGNBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pELFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsMEJBQTBCO0FBQ3ZDLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9DOzs7Ozs7O0FDNStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDOzs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILG1DQUFrQztBQUNsQztBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQseUM7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Qzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDOzs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLDZHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLGNBQWEsVUFBVTtBQUN2QixjQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRCx3Qzs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQzs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLGNBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBLDBCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDOzs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0M7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBOztBQUVB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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsVUFBVTtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQseUM7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLHVCQUFzQixnQkFBZ0I7QUFDdEMsd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixnQkFBZ0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0M7Ozs7Ozs7QUMxbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDOzs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDOzs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEM7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Qzs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7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dW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGYyMWRmYzZkZmM1YmYzOTNkNmIzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnXG5pbXBvcnQgQXBwIGZyb20gJy4vYXBwLmpzJ1xuaW1wb3J0IHN0b3JlIGZyb20gJy4uL2Rldi9qcy9zdG9yZSdcblxuUmVhY3RET00ucmVuZGVyKFxuICA8UHJvdmlkZXIgc3RvcmU9e3N0b3JlfT5cbiAgICA8QXBwIC8+XG4gIDwvUHJvdmlkZXI+LFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpXG4pXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvaW5kZXguanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaW52YXJpYW50LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcmVhY3RQcm9kSW52YXJpYW50XG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9yZWFjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFRyZWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZE5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhjaGlsZElEKSB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC10ZXh0OiAnICsgY2hpbGRJRCArICcgJyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIGNoaWxkSUQgKyAnICcpIHtcbiAgICAgICAgcHJlY2FjaGVOb2RlKGNoaWxkSW5zdCwgY2hpbGROb2RlKTtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgRE9NIGNoaWxkcmVuIHdpdGhvdXQgZmluZGluZyBhbiBJRCBtYXRjaC5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpIDogX3Byb2RJbnZhcmlhbnQoJzMyJywgY2hpbGRJRCkgOiB2b2lkIDA7XG4gIH1cbiAgaW5zdC5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0O1xuICB2YXIgaW5zdDtcbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiBpbnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gICEoaW5zdC5faG9zdE5vZGUgIT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIGlmIChpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBET00gbm9kZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHBhcmVudHMucHVzaChpbnN0KTtcbiAgICAhaW5zdC5faG9zdFBhcmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBET00gdHJlZSByb290IHNob3VsZCBhbHdheXMgaGF2ZSBhIG5vZGUgcmVmZXJlbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzM0JykgOiB2b2lkIDA7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cblxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxuICAvLyBub2RlLCBhbmQgYGluc3RgIGlzIHRoZSBkZWVwZXN0IGFuY2VzdG9yIHRoYXQgZG9lcy5cbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9ob3N0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSB7XG4gIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbiAgcHJlY2FjaGVDaGlsZE5vZGVzOiBwcmVjYWNoZUNoaWxkTm9kZXMsXG4gIHByZWNhY2hlTm9kZTogcHJlY2FjaGVOb2RlLFxuICB1bmNhY2hlTm9kZTogdW5jYWNoZU5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRUcmVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSByb3V0ZXJXYXJuaW5nO1xuZXhwb3J0cy5fcmVzZXRXYXJuZWQgPSBfcmVzZXRXYXJuZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgd2FybmVkID0ge307XG5cbmZ1bmN0aW9uIHJvdXRlcldhcm5pbmcoZmFsc2VUb1dhcm4sIG1lc3NhZ2UpIHtcbiAgLy8gT25seSBpc3N1ZSBkZXByZWNhdGlvbiB3YXJuaW5ncyBvbmNlLlxuICBpZiAobWVzc2FnZS5pbmRleE9mKCdkZXByZWNhdGVkJykgIT09IC0xKSB7XG4gICAgaWYgKHdhcm5lZFttZXNzYWdlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFttZXNzYWdlXSA9IHRydWU7XG4gIH1cblxuICBtZXNzYWdlID0gJ1tyZWFjdC1yb3V0ZXJdICcgKyBtZXNzYWdlO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgX3dhcm5pbmcyLmRlZmF1bHQuYXBwbHkodW5kZWZpbmVkLCBbZmFsc2VUb1dhcm4sIG1lc3NhZ2VdLmNvbmNhdChhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIF9yZXNldFdhcm5lZCgpIHtcbiAgd2FybmVkID0ge307XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0cnVtZW50YXRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50VHJlZUhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGlzTmF0aXZlKGZuKSB7XG4gIC8vIEJhc2VkIG9uIGlzTmF0aXZlKCkgZnJvbSBMb2Rhc2hcbiAgdmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nXG4gIC8vIFRha2UgYW4gZXhhbXBsZSBuYXRpdmUgZnVuY3Rpb24gc291cmNlIGZvciBjb21wYXJpc29uXG4gIC5jYWxsKGhhc093blByb3BlcnR5KVxuICAvLyBTdHJpcCByZWdleCBjaGFyYWN0ZXJzIHNvIHdlIGNhbiB1c2UgaXQgZm9yIHJlZ2V4XG4gIC5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC8vIFJlbW92ZSBoYXNPd25Qcm9wZXJ0eSBmcm9tIHRoZSB0ZW1wbGF0ZSB0byBtYWtlIGl0IGdlbmVyaWNcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnKTtcbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gZnVuY1RvU3RyaW5nLmNhbGwoZm4pO1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3Qoc291cmNlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciBjYW5Vc2VDb2xsZWN0aW9ucyA9XG4vLyBBcnJheS5mcm9tXG50eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuLy8gTWFwXG50eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcCkgJiZcbi8vIE1hcC5wcm90b3R5cGUua2V5c1xuTWFwLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwLnByb3RvdHlwZS5rZXlzKSAmJlxuLy8gU2V0XG50eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldCkgJiZcbi8vIFNldC5wcm90b3R5cGUua2V5c1xuU2V0LnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0LnByb3RvdHlwZS5rZXlzKTtcblxudmFyIGl0ZW1NYXA7XG52YXIgcm9vdElEU2V0O1xuXG52YXIgaXRlbUJ5S2V5O1xudmFyIHJvb3RCeUtleTtcblxuaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gIGl0ZW1NYXAgPSBuZXcgTWFwKCk7XG4gIHJvb3RJRFNldCA9IG5ldyBTZXQoKTtcbn0gZWxzZSB7XG4gIGl0ZW1CeUtleSA9IHt9O1xuICByb290QnlLZXkgPSB7fTtcbn1cblxudmFyIHVubW91bnRlZElEcyA9IFtdO1xuXG4vLyBVc2Ugbm9uLW51bWVyaWMga2V5cyB0byBwcmV2ZW50IFY4IHBlcmZvcm1hbmNlIGlzc3Vlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbmZ1bmN0aW9uIGdldEtleUZyb21JRChpZCkge1xuICByZXR1cm4gJy4nICsgaWQ7XG59XG5mdW5jdGlvbiBnZXRJREZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBwYXJzZUludChrZXkuc3Vic3RyKDEpLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGdldChpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJldHVybiBpdGVtQnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSBpdGVtQnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gIHZhciBpdGVtID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHRleHQ6IG51bGwsXG4gICAgY2hpbGRJRHM6IFtdLFxuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgdXBkYXRlQ291bnQ6IDBcbiAgfTtcblxuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvb3QoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcm9vdEJ5S2V5W2tleV0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJvb3QoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcm9vdElEU2V0WydkZWxldGUnXShpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIHJvb3RCeUtleVtrZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRJRHMoKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbUJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSb290SURzKCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdEJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXJnZURlZXAoaWQpIHtcbiAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICBpZiAoaXRlbSkge1xuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XG5cbiAgICByZW1vdmUoaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyBuYW1lICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcklEKSB7XG4gICAgb3duZXJOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2UsIG93bmVyTmFtZSk7XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0ge1xuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXQobmV4dENoaWxkSUQpO1xuICAgICAgIW5leHRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob29rIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MCcpIDogdm9pZCAwO1xuICAgICAgIShuZXh0Q2hpbGQuY2hpbGRJRHMgIT0gbnVsbCB8fCB0eXBlb2YgbmV4dENoaWxkLmVsZW1lbnQgIT09ICdvYmplY3QnIHx8IG5leHRDaGlsZC5lbGVtZW50ID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uU2V0Q2hpbGRyZW4oKSB0byBmaXJlIGZvciBhIGNvbnRhaW5lciBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQxJykgOiB2b2lkIDA7XG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbk1vdW50Q29tcG9uZW50KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCc3MScpIDogdm9pZCAwO1xuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZC5wYXJlbnRJRCA9IGlkO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXG4gICAgICAgIC8vIGJlIHB1cmdlZCBmcm9tIG91ciB0cmVlIGRhdGEgc28gdGhlaXIgcGFyZW50IElEIGlzIG1pc3NpbmcuXG4gICAgICB9XG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uQmVmb3JlTW91bnRDb21wb25lbnQoKSBwYXJlbnQgYW5kIG9uU2V0Q2hpbGRyZW4oKSB0byBiZSBjb25zaXN0ZW50ICglcyBoYXMgcGFyZW50cyAlcyBhbmQgJXMpLicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IF9wcm9kSW52YXJpYW50KCcxNDInLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gICAgY3JlYXRlKGlkLCBlbGVtZW50LCBwYXJlbnRJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaXRlbS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGFkZFJvb3QoaWQpO1xuICAgIH1cbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0udXBkYXRlQ291bnQrKztcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5IGNoaWxkIHRocmV3IHdoaWxlIG1vdW50aW5nLiBUaGVuIHRoaXMgaW5zdGFuY2UgbmV2ZXJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxuICAgICAgaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZW1vdmVSb290KGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudGVkSURzLnB1c2goaWQpO1xuICB9LFxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RDb21wb25lbnRUcmVlSG9vay5fcHJldmVudFB1cmdpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHVubW91bnRlZElEc1tpXTtcbiAgICAgIHB1cmdlRGVlcChpZCk7XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICB9LFxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNNb3VudGVkIDogZmFsc2U7XG4gIH0sXG4gIGdldEN1cnJlbnRTdGFja0FkZGVuZHVtOiBmdW5jdGlvbiAodG9wRWxlbWVudCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHRvcEVsZW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gdG9wRWxlbWVudC50eXBlO1xuICAgICAgdmFyIG5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIDogdHlwZTtcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xuICAgICAgaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUgfHwgJ1Vua25vd24nLCB0b3BFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcblxuICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChpZCk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHdoaWxlIChpZCkge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRDaGlsZElEczogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgfSxcbiAgZ2V0T3duZXJJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5fb3duZXIuX2RlYnVnSUQ7XG4gIH0sXG4gIGdldFBhcmVudElEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBhcmVudElEIDogbnVsbDtcbiAgfSxcbiAgZ2V0U291cmNlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0udXBkYXRlQ291bnQgOiAwO1xuICB9LFxuXG5cbiAgZ2V0UmVnaXN0ZXJlZElEczogZ2V0UmVnaXN0ZXJlZElEcyxcblxuICBnZXRSb290SURzOiBnZXRSb290SURzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcbiAgICB2YXIgc2hhZG93Q2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KHByb3BzLmNoaWxkcmVuKSA/IHByb3BzLmNoaWxkcmVuLnNsaWNlKDApIDogcHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NoYWRvd0NoaWxkcmVuJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2hhZG93Q2hpbGRyZW5cbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID0gc2hhZG93Q2hpbGRyZW47XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoLi4uKTogRXhwZWN0ZWQgcHJvcHMgYXJndW1lbnQgdG8gYmUgYSBwbGFpbiBvYmplY3QuICcgKyAnUHJvcGVydGllcyBkZWZpbmVkIGluIGl0cyBwcm90b3R5cGUgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBFeHBlY3RlZCBwcm9wcyBhcmd1bWVudCB0byBiZSBhIHBsYWluIG9iamVjdC4gJyArICdQcm9wZXJ0aWVzIGRlZmluZWQgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cblJlYWN0RWxlbWVudC5SRUFDVF9FTEVNRU5UX1RZUEUgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vd2FybmluZy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogX3Byb2RJbnZhcmlhbnQoJzEyNCcsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiB2b2lkIDA7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICAvLyBBbnkgdXBkYXRlcyBlbnF1ZXVlZCB3aGlsZSByZWNvbmNpbGluZyBtdXN0IGJlIHBlcmZvcm1lZCBhZnRlciB0aGlzIGVudGlyZVxuICAvLyBiYXRjaC4gT3RoZXJ3aXNlLCBpZiBkaXJ0eUNvbXBvbmVudHMgaXMgW0EsIEJdIHdoZXJlIEEgaGFzIGNoaWxkcmVuIEIgYW5kXG4gIC8vIEMsIEIgY291bGQgdXBkYXRlIHR3aWNlIGluIGEgc2luZ2xlIGJhdGNoIGlmIEMncyByZW5kZXIgZW5xdWV1ZXMgYW4gdXBkYXRlXG4gIC8vIHRvIEIgKHNpbmNlIEIgd291bGQgaGF2ZSBhbHJlYWR5IHVwZGF0ZWQsIHdlIHNob3VsZCBza2lwIGl0LCBhbmQgdGhlIG9ubHlcbiAgLy8gd2F5IHdlIGNhbiBrbm93IHRvIGRvIHNvIGlzIGJ5IGNoZWNraW5nIHRoZSBiYXRjaCBjb3VudGVyKS5cbiAgdXBkYXRlQmF0Y2hOdW1iZXIrKztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgdmFyIG1hcmtlck5hbWU7XG4gICAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgICAgdmFyIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgLy8gRHVjayB0eXBlIFRvcExldmVsV3JhcHBlci4gVGhpcyBpcyBwcm9iYWJseSBhbHdheXMgdHJ1ZS5cbiAgICAgIGlmIChjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnByb3BzID09PSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50Ll9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IHVwZGF0ZTogJyArIG5hbWVkQ29tcG9uZW50LmdldE5hbWUoKTtcbiAgICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBSZWFjdFJlY29uY2lsZXIucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGNvbXBvbmVudCwgdHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKTtcblxuICAgIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gICAgICBxdWV1ZS5ub3RpZnlBbGwoKTtcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgaWYgKGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCkge1xuICAgIGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPSB1cGRhdGVCYXRjaE51bWJlciArIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJldXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBfcHJvZEludmFyaWFudCgnMTI1JykgOiB2b2lkIDA7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBfcHJvZEludmFyaWFudCgnMTI2JykgOiB2b2lkIDA7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyNycpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nKSA6IF9wcm9kSW52YXJpYW50KCcxMjgnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogX3Byb2RJbnZhcmlhbnQoJzEyOScpIDogdm9pZCAwO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3IoeyBidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbCB9KTtcblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IGtleU1pcnJvcih7XG4gIHRvcEFib3J0OiBudWxsLFxuICB0b3BBbmltYXRpb25FbmQ6IG51bGwsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogbnVsbCxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcEJsdXI6IG51bGwsXG4gIHRvcENhblBsYXk6IG51bGwsXG4gIHRvcENhblBsYXlUaHJvdWdoOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BFbXB0aWVkOiBudWxsLFxuICB0b3BFbmNyeXB0ZWQ6IG51bGwsXG4gIHRvcEVuZGVkOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BJbnZhbGlkOiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcExvYWRlZERhdGE6IG51bGwsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBudWxsLFxuICB0b3BMb2FkU3RhcnQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUGF1c2U6IG51bGwsXG4gIHRvcFBsYXk6IG51bGwsXG4gIHRvcFBsYXlpbmc6IG51bGwsXG4gIHRvcFByb2dyZXNzOiBudWxsLFxuICB0b3BSYXRlQ2hhbmdlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWVrZWQ6IG51bGwsXG4gIHRvcFNlZWtpbmc6IG51bGwsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wU3RhbGxlZDogbnVsbCxcbiAgdG9wU3VibWl0OiBudWxsLFxuICB0b3BTdXNwZW5kOiBudWxsLFxuICB0b3BUZXh0SW5wdXQ6IG51bGwsXG4gIHRvcFRpbWVVcGRhdGU6IG51bGwsXG4gIHRvcFRvdWNoQ2FuY2VsOiBudWxsLFxuICB0b3BUb3VjaEVuZDogbnVsbCxcbiAgdG9wVG91Y2hNb3ZlOiBudWxsLFxuICB0b3BUb3VjaFN0YXJ0OiBudWxsLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBudWxsLFxuICB0b3BWb2x1bWVDaGFuZ2U6IG51bGwsXG4gIHRvcFdhaXRpbmc6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IGZhbHNlO1xudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuICcgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAgKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAgKlxuICAqIEBwYXJhbSB7b2JqZWN0fSBTeW50aGV0aWNFdmVudFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzLCAnICsgJ3lvdVxcJ3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gJyArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuaXNSZWFjdENoaWxkcmVuID0gaXNSZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQgPSBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGNyZWF0ZVJvdXRlcztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENoaWxkcmVuKG9iamVjdCkge1xuICByZXR1cm4gaXNWYWxpZENoaWxkKG9iamVjdCkgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5ldmVyeShpc1ZhbGlkQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZShkZWZhdWx0UHJvcHMsIHByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcm91dGUgPSBjcmVhdGVSb3V0ZSh0eXBlLmRlZmF1bHRQcm9wcywgZWxlbWVudC5wcm9wcyk7XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGUuY2hpbGRyZW4sIHJvdXRlKTtcblxuICAgIGlmIChjaGlsZFJvdXRlcy5sZW5ndGgpIHJvdXRlLmNoaWxkUm91dGVzID0gY2hpbGRSb3V0ZXM7XG5cbiAgICBkZWxldGUgcm91dGUuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gcm91dGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHJvdXRlcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi4gSlNYXG4gKiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGluIHRoZSBoaWVyYXJjaHkgYXJlXG4gKiBuZXN0ZWQuXG4gKlxuICogICBpbXBvcnQgeyBSb3V0ZSwgY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4gfSBmcm9tICdyZWFjdC1yb3V0ZXInXG4gKlxuICogICBjb25zdCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihcbiAqICAgICA8Um91dGUgY29tcG9uZW50PXtBcHB9PlxuICogICAgICAgPFJvdXRlIHBhdGg9XCJob21lXCIgY29tcG9uZW50PXtEYXNoYm9hcmR9Lz5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwibmV3c1wiIGNvbXBvbmVudD17TmV3c0ZlZWR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICApXG4gKlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSB1c2VkIHdoZW4geW91IHByb3ZpZGUgPFJvdXRlPiBjaGlsZHJlblxuICogdG8gYSA8Um91dGVyPiBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSkge1xuICB2YXIgcm91dGVzID0gW107XG5cbiAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gQ29tcG9uZW50IGNsYXNzZXMgbWF5IGhhdmUgYSBzdGF0aWMgY3JlYXRlKiBtZXRob2QuXG4gICAgICBpZiAoZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkge1xuICAgICAgICB2YXIgcm91dGUgPSBlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKTtcblxuICAgICAgICBpZiAocm91dGUpIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlcy5wdXNoKGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygcm91dGVzIGZyb20gdGhlIGdpdmVuIG9iamVjdCB3aGljaFxuICogbWF5IGJlIGEgSlNYIHJvdXRlLCBhIHBsYWluIG9iamVjdCByb3V0ZSwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMocm91dGVzKSB7XG4gIGlmIChpc1JlYWN0Q2hpbGRyZW4ocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlcyk7XG4gIH0gZWxzZSBpZiAocm91dGVzICYmICFBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBbcm91dGVzXTtcbiAgfVxuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvc2luZyB0aGUgYWJpbGl0eSB0byBkeW5hbWljYWxseSB1c2Uga2V5IHN0cmluZ3MgYXMgdmFsdWVzXG4gKiB0aGVtc2VsdmVzLiBQYXNzIGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleS92YWwgcGFpciBhbmQgaXQgd2lsbCByZXR1cm5cbiAqIHlvdSB0aGUgc3RyaW5nIGtleSBvZiB0aGF0IHNpbmdsZSByZWNvcmQuIFN1cHBvc2UgeW91IHdhbnQgdG8gZ3JhYiB0aGVcbiAqIHZhbHVlIGZvciBhIGtleSAnY2xhc3NOYW1lJyBpbnNpZGUgb2YgYW4gb2JqZWN0LiBLZXkvdmFsIG1pbmlmaWNhdGlvbiBtYXlcbiAqIGhhdmUgYWxpYXNlZCB0aGF0IGtleSB0byBiZSAneGExMicuIGtleU9mKHtjbGFzc05hbWU6IG51bGx9KSB3aWxsIHJldHVyblxuICogJ3hhMTInIGluIHRoYXQgY2FzZS4gUmVzb2x2ZSBrZXlzIHlvdSB3YW50IHRvIHVzZSBvbmNlIGF0IHN0YXJ0dXAgdGltZSwgdGhlblxuICogcmV1c2UgdGhvc2UgcmVzb2x1dGlvbnMuXG4gKi9cbnZhciBrZXlPZiA9IGZ1bmN0aW9uIGtleU9mKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlPZi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMuaGlzdG9yeSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIGFycmF5T2YgPSBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2Y7XG52YXIgb25lT2ZUeXBlID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGU7XG52YXIgZWxlbWVudCA9IF9yZWFjdC5Qcm9wVHlwZXMuZWxlbWVudDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG5mdW5jdGlvbiBmYWxzeShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkgcmV0dXJuIG5ldyBFcnJvcignPCcgKyBjb21wb25lbnROYW1lICsgJz4gc2hvdWxkIG5vdCBoYXZlIGEgXCInICsgcHJvcE5hbWUgKyAnXCIgcHJvcCcpO1xufVxuXG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IHNoYXBlKHtcbiAgbGlzdGVuOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnQgPSBvbmVPZlR5cGUoW2Z1bmMsIHN0cmluZ10pO1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBvbmVPZlR5cGUoW2NvbXBvbmVudCwgb2JqZWN0XSk7XG52YXIgcm91dGUgPSBleHBvcnRzLnJvdXRlID0gb25lT2ZUeXBlKFtvYmplY3QsIGVsZW1lbnRdKTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IG9uZU9mVHlwZShbcm91dGUsIGFycmF5T2Yocm91dGUpXSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbnRlcm5hbFByb3BUeXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmV4dHJhY3RQYXRoID0gZXh0cmFjdFBhdGg7XG5leHBvcnRzLnBhcnNlUGF0aCA9IHBhcnNlUGF0aDtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gZXh0cmFjdFBhdGgoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXlxcL10qLyk7XG5cbiAgaWYgKG1hdGNoID09IG51bGwpIHJldHVybiBzdHJpbmc7XG5cbiAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gZXh0cmFjdFBhdGgocGF0aCk7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocGF0aCA9PT0gcGF0aG5hbWUsICdBIHBhdGggbXVzdCBiZSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggb25seSwgbm90IGEgZnVsbHkgcXVhbGlmaWVkIFVSTCBsaWtlIFwiJXNcIicsIHBhdGgpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIGlmIChwYXRobmFtZSA9PT0gJycpIHBhdGhuYW1lID0gJy8nO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2hcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBpbGVQYXR0ZXJuID0gY29tcGlsZVBhdHRlcm47XG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcbmV4cG9ydHMuZ2V0UGFyYW1OYW1lcyA9IGdldFBhcmFtTmFtZXM7XG5leHBvcnRzLmdldFBhcmFtcyA9IGdldFBhcmFtcztcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBfY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICB2YXIgcmVnZXhwU291cmNlID0gJyc7XG4gIHZhciBwYXJhbU5hbWVzID0gW107XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICBsYXN0SW5kZXggPSAwLFxuICAgICAgbWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyRdKil8XFwqXFwqfFxcKnxcXCh8XFwpL2c7XG4gIHdoaWxlIChtYXRjaCA9IG1hdGNoZXIuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyhbXi9dKyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKionKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKiknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLio/KSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyg/Oic7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyknKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyk/JztcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChtYXRjaFswXSk7XG5cbiAgICBsYXN0SW5kZXggPSBtYXRjaGVyLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogcGF0dGVybixcbiAgICByZWdleHBTb3VyY2U6IHJlZ2V4cFNvdXJjZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHRva2VuczogdG9rZW5zXG4gIH07XG59XG5cbnZhciBDb21waWxlZFBhdHRlcm5zQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dKSBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0gPSBfY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgcmV0dXJuIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBtYXRjaCBhIHBhdHRlcm4gb24gdGhlIGdpdmVuIHBhdGhuYW1lLiBQYXR0ZXJucyBtYXkgdXNlXG4gKiB0aGUgZm9sbG93aW5nIHNwZWNpYWwgY2hhcmFjdGVyczpcbiAqXG4gKiAtIDpwYXJhbU5hbWUgICAgIE1hdGNoZXMgYSBVUkwgc2VnbWVudCB1cCB0byB0aGUgbmV4dCAvLCA/LCBvciAjLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgY2FwdHVyZWQgc3RyaW5nIGlzIGNvbnNpZGVyZWQgYSBcInBhcmFtXCJcbiAqIC0gKCkgICAgICAgICAgICAgV3JhcHMgYSBzZWdtZW50IG9mIHRoZSBVUkwgdGhhdCBpcyBvcHRpb25hbFxuICogLSAqICAgICAgICAgICAgICBDb25zdW1lcyAobm9uLWdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHRcbiAqICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWZcbiAqICAgICAgICAgICAgICAgICAgdGhlcmUgaXMgbm9uZVxuICogLSAqKiAgICAgICAgICAgICBDb25zdW1lcyAoZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAqICAgICAgICAgICAgICAgICAgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZiB0aGVyZSBpcyBub25lXG4gKlxuICogIFRoZSBmdW5jdGlvbiBjYWxscyBjYWxsYmFjayhlcnJvciwgbWF0Y2hlZCkgd2hlbiBmaW5pc2hlZC5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcmVtYWluaW5nUGF0aG5hbWVcbiAqIC0gcGFyYW1OYW1lc1xuICogLSBwYXJhbVZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgLy8gRW5zdXJlIHBhdHRlcm4gc3RhcnRzIHdpdGggbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kgd2l0aCBwYXRobmFtZS5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gJy8nICsgcGF0dGVybjtcbiAgfVxuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlO1xuICB2YXIgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcztcbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnLz8nOyAvLyBBbGxvdyBvcHRpb25hbCBwYXRoIHNlcGFyYXRvciBhdCBlbmQuXG4gIH1cblxuICAvLyBTcGVjaWFsLWNhc2UgcGF0dGVybnMgbGlrZSAnKicgZm9yIGNhdGNoLWFsbCByb3V0ZXMuXG4gIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1hdGNoZWRQYXRoID0gbWF0Y2hbMF07XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcbiAgICAvLyB0aGUgZnVsbCBwYXRoLCBzbyBhbnkgcmVtYWluaW5nIHBhdGhuYW1lIGlzIGEgbmV3IHBhdGggc2VnbWVudC5cbiAgICBpZiAobWF0Y2hlZFBhdGguY2hhckF0KG1hdGNoZWRQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxuICAgIC8vIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgZm9yIHByb3Blcmx5IGNvbnRpbnVpbmcgdGhlIG1hdGNoLlxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJy8nICsgcmVtYWluaW5nUGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHBhcmFtVmFsdWVzOiBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbU5hbWVzKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXM7XG4gIHZhciBwYXJhbVZhbHVlcyA9IG1hdGNoLnBhcmFtVmFsdWVzO1xuXG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBwYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXR0ZXJuKHBhdHRlcm4sIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjMgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICB2YXIgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMy50b2tlbnM7XG5cbiAgdmFyIHBhcmVuQ291bnQgPSAwLFxuICAgICAgcGF0aG5hbWUgPSAnJyxcbiAgICAgIHNwbGF0SW5kZXggPSAwO1xuXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcbiAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMCxcbiAgICAgIHBhcmFtVmFsdWUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XG4gICAgICBwYXJhbVZhbHVlID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3BsYXQpID8gcGFyYW1zLnNwbGF0W3NwbGF0SW5kZXgrK10gOiBwYXJhbXMuc3BsYXQ7XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSShwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKScpIHtcbiAgICAgIHBhcmVuQ291bnQgLT0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5wdXNoLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUFVTSCA9ICdQVVNIJztcblxuZXhwb3J0cy5QVVNIID0gUFVTSDtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnJlcGxhY2UuXG4gKi9cbnZhciBSRVBMQUNFID0gJ1JFUExBQ0UnO1xuXG5leHBvcnRzLlJFUExBQ0UgPSBSRVBMQUNFO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gJ1BPUCc7XG5cbmV4cG9ydHMuUE9QID0gUE9QO1xuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBQVVNIOiBQVVNILFxuICBSRVBMQUNFOiBSRVBMQUNFLFxuICBQT1A6IFBPUFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9BY3Rpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01MYXp5VHJlZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG4vKipcbiAqIEluIElFICg4LTExKSBhbmQgRWRnZSwgYXBwZW5kaW5nIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gaXMgZHJhbWF0aWNhbGx5XG4gKiBmYXN0ZXIgdGhhbiBhcHBlbmRpbmcgYSBmdWxsIHN1YnRyZWUsIHNvIHdlIGVzc2VudGlhbGx5IHF1ZXVlIHVwIHRoZVxuICogLmFwcGVuZENoaWxkIGNhbGxzIGhlcmUgYW5kIGFwcGx5IHRoZW0gc28gZWFjaCBub2RlIGlzIGFkZGVkIHRvIGl0cyBwYXJlbnRcbiAqIGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLlxuICpcbiAqIEluIG90aGVyIGJyb3dzZXJzLCBkb2luZyBzbyBpcyBzbG93ZXIgb3IgbmV1dHJhbCBjb21wYXJlZCB0byB0aGUgb3RoZXIgb3JkZXJcbiAqIChpbiBGaXJlZm94LCB0d2ljZSBhcyBzbG93KSBzbyB3ZSBvbmx5IGRvIHRoaXMgaW52ZXJzaW9uIGluIElFLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3BpY3lqL2lubmVyaHRtbC12cy1jcmVhdGVlbGVtZW50LXZzLWNsb25lbm9kZS5cbiAqL1xudmFyIGVuYWJsZUxhenkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiAvXFxiRWRnZVxcL1xcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuZnVuY3Rpb24gaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpIHtcbiAgaWYgKCFlbmFibGVMYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBub2RlID0gdHJlZS5ub2RlO1xuICB2YXIgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaW5zZXJ0VHJlZUJlZm9yZShub2RlLCBjaGlsZHJlbltpXSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRyZWUuaHRtbCAhPSBudWxsKSB7XG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIHRyZWUuaHRtbCk7XG4gIH0gZWxzZSBpZiAodHJlZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCB0cmVlLnRleHQpO1xuICB9XG59XG5cbnZhciBpbnNlcnRUcmVlQmVmb3JlID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgdHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmVuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgRE9NIGFmdGVyIGluc2VydGlvbiBzb1xuICAvLyBhcHBlbmRpbmcgY2hpbGRyZW4gd29uJ3QgdXBkYXRlIHRoZSBET00uIFdlIG5lZWQgdG8gZW5zdXJlIHRoZSBmcmFnbWVudFxuICAvLyBpcyBwcm9wZXJseSBwb3B1bGF0ZWQgZmlyc3QsIGJyZWFraW5nIG91dCBvZiBvdXIgbGF6eSBhcHByb2FjaCBmb3IganVzdFxuICAvLyB0aGlzIGxldmVsLiBBbHNvLCBzb21lIDxvYmplY3Q+IHBsdWdpbnMgKGxpa2UgRmxhc2ggUGxheWVyKSB3aWxsIHJlYWRcbiAgLy8gPHBhcmFtPiBub2RlcyBpbW1lZGlhdGVseSB1cG9uIGluc2VydGlvbiBpbnRvIHRoZSBET00sIHNvIDxvYmplY3Q+XG4gIC8vIG11c3QgYWxzbyBiZSBwb3B1bGF0ZWQgcHJpb3IgdG8gaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgaWYgKHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIHx8IHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgJiYgdHJlZS5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICYmICh0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09IG51bGwgfHwgdHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSkge1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkTm9kZSwgbmV3VHJlZSkge1xuICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1RyZWUubm9kZSwgb2xkTm9kZSk7XG4gIGluc2VydFRyZWVDaGlsZHJlbihuZXdUcmVlKTtcbn1cblxuZnVuY3Rpb24gcXVldWVDaGlsZChwYXJlbnRUcmVlLCBjaGlsZFRyZWUpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICBwYXJlbnRUcmVlLmNoaWxkcmVuLnB1c2goY2hpbGRUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmVlLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGRUcmVlLm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSFRNTCh0cmVlLCBodG1sKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS5odG1sID0gaHRtbDtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbm5lckhUTUwodHJlZS5ub2RlLCBodG1sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZVRleHQodHJlZSwgdGV4dCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUudGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGV4dENvbnRlbnQodHJlZS5ub2RlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubm9kZS5ub2RlTmFtZTtcbn1cblxuZnVuY3Rpb24gRE9NTGF6eVRyZWUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGh0bWw6IG51bGwsXG4gICAgdGV4dDogbnVsbCxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcbn1cblxuRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZSA9IGluc2VydFRyZWVCZWZvcmU7XG5ET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZSA9IHJlcGxhY2VDaGlsZFdpdGhUcmVlO1xuRE9NTGF6eVRyZWUucXVldWVDaGlsZCA9IHF1ZXVlQ2hpbGQ7XG5ET01MYXp5VHJlZS5xdWV1ZUhUTUwgPSBxdWV1ZUhUTUw7XG5ET01MYXp5VHJlZS5xdWV1ZVRleHQgPSBxdWV1ZVRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTGF6eVRyZWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTUxhenlUcmVlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdGhlIGNvbnRhaW5pbmcgaG9zdCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudCh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXG4gICAqIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwLlxuICAgKi9cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0SG9zdE5vZGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHNhZmVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoc2FmZWx5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBuZXh0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciAhPT0gdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQncyBlbnF1ZXVlZCBiYXRjaCBudW1iZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY3VycmVudFxuICAgICAgLy8gYmF0Y2ggb3IgdGhlIGZvbGxvd2luZyBvbmUuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IFVuZXhwZWN0ZWQgYmF0Y2ggbnVtYmVyIChjdXJyZW50ICVzLCAnICsgJ3BlbmRpbmcgJXMpJywgdXBkYXRlQmF0Y2hOdW1iZXIsIGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29ubmVjdCA9IGV4cG9ydHMuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUHJvdmlkZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUHJvdmlkZXInKTtcblxudmFyIF9Qcm92aWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm92aWRlcik7XG5cbnZhciBfY29ubmVjdCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb25uZWN0Jyk7XG5cbnZhciBfY29ubmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25uZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUHJvdmlkZXIgPSBfUHJvdmlkZXIyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29ubmVjdCA9IF9jb25uZWN0MltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzk1JykgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBfcHJvZEludmFyaWFudCgnMjcnKSA6IHZvaWQgMDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyOCcpIDogdm9pZCAwO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIFRyYW5zYWN0aW9uID0ge1xuXG4gIE1peGluOiBNaXhpbixcblxuICAvKipcbiAgICogVG9rZW4gdG8gbG9vayBmb3IgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBfY3JlYXRlU3RvcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBfYmluZEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IF9hcHBseU1pZGRsZXdhcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtcyA9IHJlcXVpcmUoJy4vZ2V0Um91dGVQYXJhbXMnKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSb3V0ZVBhcmFtcyk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgYXJyYXkgPSBfUmVhY3QkUHJvcFR5cGVzLmFycmF5O1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyQ29udGV4dD4gcmVuZGVycyB0aGUgY29tcG9uZW50IHRyZWUgZm9yIGEgZ2l2ZW4gcm91dGVyIHN0YXRlXG4gKiBhbmQgc2V0cyB0aGUgaGlzdG9yeSBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlckNvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlckNvbnRleHQnLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlczogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBwYXJhbXM6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGNvbXBvbmVudHM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50XG4gICAgfTtcbiAgfSxcblxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGxvY2F0aW9uOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJvdXRlciA9IF9wcm9wcy5yb3V0ZXI7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb247XG5cbiAgICBpZiAoIXJvdXRlcikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgPFJvdXRlckNvbnRleHQ+YCBleHBlY3RzIGEgYHJvdXRlcmAgcmF0aGVyIHRoYW4gYSBgaGlzdG9yeWAnKSA6IHZvaWQgMDtcblxuICAgICAgcm91dGVyID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgICAgc2V0Um91dGVMZWF2ZUhvb2s6IGhpc3RvcnkubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSByb3V0ZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBsb2NhdGlvbiA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkobG9jYXRpb24sICdgY29udGV4dC5sb2NhdGlvbmAgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhIHJvdXRlIGNvbXBvbmVudFxcJ3MgYHByb3BzLmxvY2F0aW9uYCBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItYWNjZXNzaW5nbG9jYXRpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiBoaXN0b3J5LCBsb2NhdGlvbjogbG9jYXRpb24sIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBjb21wb25lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLnByb3BzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMyLmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gX3Byb3BzMi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGVzID0gX3Byb3BzMi5yb3V0ZXM7XG4gICAgdmFyIHBhcmFtcyA9IF9wcm9wczIucGFyYW1zO1xuICAgIHZhciBjb21wb25lbnRzID0gX3Byb3BzMi5jb21wb25lbnRzO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgIGVsZW1lbnQgPSBjb21wb25lbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChlbGVtZW50LCBjb21wb25lbnRzLCBpbmRleCkge1xuICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSByZXR1cm4gZWxlbWVudDsgLy8gRG9uJ3QgY3JlYXRlIG5ldyBjaGlsZHJlbjsgdXNlIHRoZSBncmFuZGNoaWxkcmVuLlxuXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpbmRleF07XG4gICAgICAgIHZhciByb3V0ZVBhcmFtcyA9ICgwLCBfZ2V0Um91dGVQYXJhbXMyLmRlZmF1bHQpKHJvdXRlLCBwYXJhbXMpO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICAgIHJvdXRlUGFyYW1zOiByb3V0ZVBhcmFtcyxcbiAgICAgICAgICByb3V0ZXM6IHJvdXRlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgoMCwgX1JvdXRlVXRpbHMuaXNSZWFjdENoaWxkcmVuKShlbGVtZW50KSkge1xuICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnQsIHByb3ApKSBwcm9wc1twcm9wXSA9IGVsZW1lbnRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgY29tcG9uZW50cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29tcG9uZW50cykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29tcG9uZW50cywga2V5KSkge1xuICAgICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggdGhlIGtleSBhcyBhIHByb3AgdG8gY3JlYXRlRWxlbWVudCB0byBhbGxvd1xuICAgICAgICAgICAgICAvLyBjdXN0b20gY3JlYXRlRWxlbWVudCBmdW5jdGlvbnMgdG8ga25vdyB3aGljaCBuYW1lZCBjb21wb25lbnRcbiAgICAgICAgICAgICAgLy8gdGhleSdyZSByZW5kZXJpbmcsIGZvciBlLmcuIG1hdGNoaW5nIHVwIHRvIGZldGNoZWQgZGF0YS5cbiAgICAgICAgICAgICAgZWxlbWVudHNba2V5XSA9IF90aGlzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c1trZXldLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgfSwgcHJvcHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzLCBwcm9wcyk7XG4gICAgICB9LCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICAhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgcm9vdCByb3V0ZSBtdXN0IHJlbmRlciBhIHNpbmdsZSBlbGVtZW50JykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXJDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjYW5Vc2VNZW1icmFuZSA9IGV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSBmYWxzZTtcblxuLy8gTm8tb3AgYnkgZGVmYXVsdC5cbnZhciBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkueCkge1xuICAgICAgZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IGNhblVzZU1lbWJyYW5lID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG4gIGlmIChjYW5Vc2VNZW1icmFuZSkge1xuICAgIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKG9iamVjdCwgbWVzc2FnZSkge1xuICAgICAgLy8gV3JhcCB0aGUgZGVwcmVjYXRlZCBvYmplY3QgaW4gYSBtZW1icmFuZSB0byB3YXJuIG9uIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgIHZhciBtZW1icmFuZSA9IHt9O1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gQ2FuJ3QgdXNlIGZhdCBhcnJvdyBoZXJlIGJlY2F1c2Ugb2YgdXNlIG9mIGFyZ3VtZW50cyBiZWxvdy5cbiAgICAgICAgICBtZW1icmFuZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF0uYXBwbHkob2JqZWN0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub24tZW51bWVyYWJsZSB0byBwcmV2ZW50IFJlYWN0IGRldiB0b29scyBmcm9tXG4gICAgICAgIC8vIHNlZWluZyB0aGVtIGFuZCBjYXVzaW5nIHNwdXJpb3VzIHdhcm5pbmdzIHdoZW4gYWNjZXNzaW5nIHRoZW0uIEluXG4gICAgICAgIC8vIHByaW5jaXBsZSB0aGlzIGNvdWxkIGJlIGRvbmUgd2l0aCBhIHByb3h5LCBidXQgc3VwcG9ydCBmb3IgdGhlXG4gICAgICAgIC8vIG93bktleXMgdHJhcCBvbiBwcm94aWVzIGlzIG5vdCB1bml2ZXJzYWwsIGV2ZW4gYW1vbmcgYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBvdGhlcndpc2Ugc3VwcG9ydCBwcm94aWVzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVtYnJhbmUsIHByb3AsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09ICdjb250aW51ZScpIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVtYnJhbmU7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmV4cG9ydHMuY2FuVXNlRE9NID0gY2FuVXNlRE9NO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9xdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5LXN0cmluZycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbnZhciBTRUFSQ0hfQkFTRV9LRVkgPSAnJHNlYXJjaEJhc2UnO1xuXG5mdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuIF9xdWVyeVN0cmluZy5zdHJpbmdpZnkocXVlcnkpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuXG52YXIgZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcucGFyc2U7XG5cbmZ1bmN0aW9uIGlzTmVzdGVkT2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSAmJiB0eXBlb2Ygb2JqZWN0W3BdID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmplY3RbcF0pICYmIG9iamVjdFtwXSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byBoYW5kbGUgVVJMIHF1ZXJpZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXJpZXMoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBvcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gb3B0aW9ucy5wYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpbmdpZnlRdWVyeSAhPT0gJ2Z1bmN0aW9uJykgc3RyaW5naWZ5UXVlcnkgPSBkZWZhdWx0U3RyaW5naWZ5UXVlcnk7XG5cbiAgICBpZiAodHlwZW9mIHBhcnNlUXVlcnlTdHJpbmcgIT09ICdmdW5jdGlvbicpIHBhcnNlUXVlcnlTdHJpbmcgPSBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZztcblxuICAgIGZ1bmN0aW9uIGFkZFF1ZXJ5KGxvY2F0aW9uKSB7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkgPT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuXG4gICAgICAgIGxvY2F0aW9uLnF1ZXJ5ID0gcGFyc2VRdWVyeVN0cmluZyhzZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6ICcnIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgYWxsIHRoZSBib29rLWtlZXBpbmcgaGVyZSwgdGhpcyBzaG91bGQganVzdCBzdHJpcCB0aGVcbiAgICAgIC8vIHN0cmluZ2lmaWVkIHF1ZXJ5IGZyb20gdGhlIHNlYXJjaC5cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIHNlYXJjaEJhc2VTcGVjID0gbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXTtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5ID8gc3RyaW5naWZ5UXVlcnkocXVlcnkpIDogJyc7XG4gICAgICBpZiAoIXNlYXJjaEJhc2VTcGVjICYmICFxdWVyeVN0cmluZykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShzdHJpbmdpZnlRdWVyeSAhPT0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5IHx8ICFpc05lc3RlZE9iamVjdChxdWVyeSksICd1c2VRdWVyaWVzIGRvZXMgbm90IHN0cmluZ2lmeSBuZXN0ZWQgcXVlcnkgb2JqZWN0cyBieSBkZWZhdWx0OyAnICsgJ3VzZSBhIGN1c3RvbSBzdHJpbmdpZnlRdWVyeSBmdW5jdGlvbicpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBzZWFyY2hCYXNlID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlYXJjaEJhc2VTcGVjICYmIGxvY2F0aW9uLnNlYXJjaCA9PT0gc2VhcmNoQmFzZVNwZWMuc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaEJhc2UgPSBzZWFyY2hCYXNlU3BlYy5zZWFyY2hCYXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoQmFzZSA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlYXJjaCA9IHNlYXJjaEJhc2U7XG4gICAgICBpZiAocXVlcnlTdHJpbmcpIHtcbiAgICAgICAgc2VhcmNoICs9IChzZWFyY2ggPyAnJicgOiAnPycpICsgcXVlcnlTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIChfZXh0ZW5kczIgPSB7XG4gICAgICAgIHNlYXJjaDogc2VhcmNoXG4gICAgICB9LCBfZXh0ZW5kczJbU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6IHNlYXJjaEJhc2UgfSwgX2V4dGVuZHMyKSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10oaG9vaywgYWRkUXVlcnkobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIoYWRkUXVlcnkobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5wdXNoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZShhcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKCFxdWVyeSwgJ3RoZSBxdWVyeSBhcmd1bWVudCB0byBjcmVhdGVQYXRoIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oIXF1ZXJ5LCAndGhlIHF1ZXJ5IGFyZ3VtZW50IHRvIGNyZWF0ZUhyZWYgaXMgZGVwcmVjYXRlZDsgdXNlIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bGxMb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW2FwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSldLmNvbmNhdChhcmdzKSk7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkpIHtcbiAgICAgICAgZnVsbExvY2F0aW9uLnF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkUXVlcnkoZnVsbExvY2F0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHVzZVF1ZXJpZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEaXNhYmxlZElucHV0VXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lcyA9IHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG5cbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgaG9zdCBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgcHJvcHMsIGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzXG4gICAgdmFyIGhvc3RQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lc1trZXldICYmIHByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaG9zdFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzYWJsZWRJbnB1dFV0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk3JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk5JywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFFdmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgIGZvciAodmFyIGxvd2VyQ2FzZWROYW1lIGluIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50RW1pdHRlck1peGluJyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lID0gcmVxdWlyZSgnLi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZScpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBoYXNFdmVudFBhZ2VYWTtcbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gX2Fzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiAncGFnZVgnIGluIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgfVxuICAgIGlmICghaGFzRXZlbnRQYWdlWFkgJiYgIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcblxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcbnZhciBOT05WSVNJQkxFX1RFU1QgPSAvPCghLS18bGlua3xub3NjcmlwdHxtZXRhfHNjcmlwdHxzdHlsZSlbIFxcclxcblxcdFxcZlxcLz5dLztcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIG5ld05vZGVzID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZC5jaGlsZE5vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0ZXN0RWxlbWVudCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbiBrZXlNaXJyb3Iob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgIShvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2tleU1pcnJvci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuZXhwb3J0cy5tYXBBc3luYyA9IG1hcEFzeW5jO1xuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gbWFwQXN5bmMoYXJyYXksIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcblxuICB2YXIgaXNEb25lID0gZmFsc2UsXG4gICAgICBkb25lQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICBpc0RvbmUgPSArK2RvbmVDb3VudCA9PT0gbGVuZ3RoO1xuXG4gICAgICBpZiAoaXNEb25lKSBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgd29yayhpdGVtLCBpbmRleCwgZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucm91dGVyID0gZXhwb3J0cy5yb3V0ZXMgPSBleHBvcnRzLnJvdXRlID0gZXhwb3J0cy5jb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnQgPSBleHBvcnRzLmxvY2F0aW9uID0gZXhwb3J0cy5oaXN0b3J5ID0gZXhwb3J0cy5mYWxzeSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG52YXIgSW50ZXJuYWxQcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfSW50ZXJuYWxQcm9wVHlwZXMpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVuYyA9IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG52YXIgcm91dGVyU2hhcGUgPSBleHBvcnRzLnJvdXRlclNoYXBlID0gc2hhcGUoe1xuICBwdXNoOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlcGxhY2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ286IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29CYWNrOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvRm9yd2FyZDogZnVuYy5pc1JlcXVpcmVkLFxuICBzZXRSb3V0ZUxlYXZlSG9vazogZnVuYy5pc1JlcXVpcmVkLFxuICBpc0FjdGl2ZTogZnVuYy5pc1JlcXVpcmVkXG59KTtcblxudmFyIGxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBzaGFwZSh7XG4gIHBhdGhuYW1lOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgc2VhcmNoOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgc3RhdGU6IG9iamVjdCxcbiAgYWN0aW9uOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAga2V5OiBzdHJpbmdcbn0pO1xuXG4vLyBEZXByZWNhdGVkIHN0dWZmIGJlbG93OlxuXG52YXIgZmFsc3kgPSBleHBvcnRzLmZhbHN5ID0gSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3k7XG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IEludGVybmFsUHJvcFR5cGVzLmhpc3Rvcnk7XG52YXIgbG9jYXRpb24gPSBleHBvcnRzLmxvY2F0aW9uID0gbG9jYXRpb25TaGFwZTtcbnZhciBjb21wb25lbnQgPSBleHBvcnRzLmNvbXBvbmVudCA9IEludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudDtcbnZhciBjb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnRzID0gSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cztcbnZhciByb3V0ZSA9IGV4cG9ydHMucm91dGUgPSBJbnRlcm5hbFByb3BUeXBlcy5yb3V0ZTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IEludGVybmFsUHJvcFR5cGVzLnJvdXRlcztcbnZhciByb3V0ZXIgPSBleHBvcnRzLnJvdXRlciA9IHJvdXRlclNoYXBlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZXByZWNhdGVQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBwcm9wVHlwZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocHJvcFR5cGUpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGVQcm9wVHlwZShwcm9wVHlwZSwgJ1RoaXMgcHJvcCB0eXBlIGlzIG5vdCBpbnRlbmRlZCBmb3IgZXh0ZXJuYWwgdXNlLCBhbmQgd2FzIHByZXZpb3VzbHkgZXhwb3J0ZWQgYnkgbWlzdGFrZS4gVGhlc2UgaW50ZXJuYWwgcHJvcCB0eXBlcyBhcmUgZGVwcmVjYXRlZCBmb3IgZXh0ZXJuYWwgdXNlLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbi4nKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShwcm9wVHlwZSwgbmFtZSkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCAnVGhlIGAnICsgbmFtZSArICdgIHByb3AgdHlwZSBpcyBub3cgZXhwb3J0ZWQgYXMgYCcgKyBuYW1lICsgJ1NoYXBlYCB0byBhdm9pZCBuYW1lIGNvbmZsaWN0cy4gVGhpcyBleHBvcnQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbi4nKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5mYWxzeSA9IGZhbHN5ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShmYWxzeSk7XG4gICAgZXhwb3J0cy5oaXN0b3J5ID0gaGlzdG9yeSA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoaGlzdG9yeSk7XG4gICAgZXhwb3J0cy5jb21wb25lbnQgPSBjb21wb25lbnQgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGNvbXBvbmVudCk7XG4gICAgZXhwb3J0cy5jb21wb25lbnRzID0gY29tcG9uZW50cyA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoY29tcG9uZW50cyk7XG4gICAgZXhwb3J0cy5yb3V0ZSA9IHJvdXRlID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShyb3V0ZSk7XG4gICAgZXhwb3J0cy5yb3V0ZXMgPSByb3V0ZXMgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHJvdXRlcyk7XG5cbiAgICBleHBvcnRzLmxvY2F0aW9uID0gbG9jYXRpb24gPSBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUobG9jYXRpb24sICdsb2NhdGlvbicpO1xuICAgIGV4cG9ydHMucm91dGVyID0gcm91dGVyID0gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKHJvdXRlciwgJ3JvdXRlcicpO1xuICB9KSgpO1xufVxuXG52YXIgZGVmYXVsdEV4cG9ydCA9IHtcbiAgZmFsc3k6IGZhbHN5LFxuICBoaXN0b3J5OiBoaXN0b3J5LFxuICBsb2NhdGlvbjogbG9jYXRpb24sXG4gIGNvbXBvbmVudDogY29tcG9uZW50LFxuICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICByb3V0ZTogcm91dGUsXG4gIC8vIEZvciBzb21lIHJlYXNvbiwgcm91dGVzIHdhcyBuZXZlciBoZXJlLlxuICByb3V0ZXI6IHJvdXRlclxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVmYXVsdEV4cG9ydCA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkoZGVmYXVsdEV4cG9ydCwgJ1RoZSBkZWZhdWx0IGV4cG9ydCBmcm9tIGByZWFjdC1yb3V0ZXIvbGliL1Byb3BUeXBlc2AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgbmFtZWQgZXhwb3J0cyBpbnN0ZWFkLicpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0RXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL0FjdGlvbnMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczIgPSByZXF1aXJlKCcuL2NvbXB1dGVDaGFuZ2VkUm91dGVzJyk7XG5cbnZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyKTtcblxudmFyIF9UcmFuc2l0aW9uVXRpbHMgPSByZXF1aXJlKCcuL1RyYW5zaXRpb25VdGlscycpO1xuXG52YXIgX2lzQWN0aXZlMiA9IHJlcXVpcmUoJy4vaXNBY3RpdmUnKTtcblxudmFyIF9pc0FjdGl2ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FjdGl2ZTIpO1xuXG52YXIgX2dldENvbXBvbmVudHMgPSByZXF1aXJlKCcuL2dldENvbXBvbmVudHMnKTtcblxudmFyIF9nZXRDb21wb25lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENvbXBvbmVudHMpO1xuXG52YXIgX21hdGNoUm91dGVzID0gcmVxdWlyZSgnLi9tYXRjaFJvdXRlcycpO1xuXG52YXIgX21hdGNoUm91dGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoUm91dGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaGFzQW55UHJvcGVydGllcyhvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihoaXN0b3J5LCByb3V0ZXMpIHtcbiAgdmFyIHN0YXRlID0ge307XG5cbiAgLy8gU2lnbmF0dXJlIHNob3VsZCBiZSAobG9jYXRpb24sIGluZGV4T25seSksIGJ1dCBuZWVkcyB0byBzdXBwb3J0IChwYXRoLFxuICAvLyBxdWVyeSwgaW5kZXhPbmx5KVxuICBmdW5jdGlvbiBpc0FjdGl2ZShsb2NhdGlvbikge1xuICAgIHZhciBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZXByZWNhdGVkSW5kZXhPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICAgIHZhciBpbmRleE9ubHkgPSB2b2lkIDA7XG4gICAgaWYgKGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICYmIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICE9PSB0cnVlIHx8IGRlcHJlY2F0ZWRJbmRleE9ubHkgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5KSBpcyBkZXByZWNhdGVkOyB1c2UgYGlzQWN0aXZlKGxvY2F0aW9uLCBpbmRleE9ubHkpYCB3aXRoIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG4gICAgICBsb2NhdGlvbiA9IHsgcGF0aG5hbWU6IGxvY2F0aW9uLCBxdWVyeTogaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgfTtcbiAgICAgIGluZGV4T25seSA9IGRlcHJlY2F0ZWRJbmRleE9ubHkgfHwgZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICBpbmRleE9ubHkgPSBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9pc0FjdGl2ZTMuZGVmYXVsdCkobG9jYXRpb24sIGluZGV4T25seSwgc3RhdGUubG9jYXRpb24sIHN0YXRlLnJvdXRlcywgc3RhdGUucGFyYW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uRnJvbVJlZGlyZWN0SW5mbyhsb2NhdGlvbikge1xuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFKTtcbiAgfVxuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIGlmIChwYXJ0aWFsTmV4dFN0YXRlICYmIHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAvLyBDb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLlxuICAgICAgZmluaXNoTWF0Y2gocGFydGlhbE5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgZmluaXNoTWF0Y2goX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hNYXRjaChuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlcyA9ICgwLCBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzLmRlZmF1bHQpKHN0YXRlLCBuZXh0U3RhdGUpO1xuXG4gICAgdmFyIGxlYXZlUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmxlYXZlUm91dGVzO1xuICAgIHZhciBjaGFuZ2VSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMuY2hhbmdlUm91dGVzO1xuICAgIHZhciBlbnRlclJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5lbnRlclJvdXRlcztcblxuXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuTGVhdmVIb29rcykobGVhdmVSb3V0ZXMsIHN0YXRlKTtcblxuICAgIC8vIFRlYXIgZG93biBjb25maXJtYXRpb24gaG9va3MgZm9yIGxlZnQgcm91dGVzXG4gICAgbGVhdmVSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmV0dXJuIGVudGVyUm91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICB9KS5mb3JFYWNoKHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUpO1xuXG4gICAgLy8gY2hhbmdlIGFuZCBlbnRlciBob29rcyBhcmUgcnVuIGluIHNlcmllc1xuICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkNoYW5nZUhvb2tzKShjaGFuZ2VSb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5FbnRlckhvb2tzKShlbnRlclJvdXRlcywgbmV4dFN0YXRlLCBmaW5pc2hFbnRlckhvb2tzKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpbmlzaEVudGVySG9va3MoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykgcmV0dXJuIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKTtcblxuICAgICAgLy8gVE9ETzogRmV0Y2ggY29tcG9uZW50cyBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAgKDAsIF9nZXRDb21wb25lbnRzMi5kZWZhdWx0KShuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogTWFrZSBtYXRjaCBhIHB1cmUgZnVuY3Rpb24gYW5kIGhhdmUgc29tZSBvdGhlciBBUElcbiAgICAgICAgICAvLyBmb3IgXCJtYXRjaCBhbmQgdXBkYXRlIHN0YXRlXCIuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCwgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yKSBjYWxsYmFjayhlcnJvcik7ZWxzZSBjYWxsYmFjayhudWxsLCBjcmVhdGVMb2NhdGlvbkZyb21SZWRpcmVjdEluZm8ocmVkaXJlY3RJbmZvKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFJvdXRlR3VpZCA9IDE7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xuICAgIHZhciBjcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcbiAgfVxuXG4gIHZhciBSb3V0ZUhvb2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHJvdXRlcykge1xuICAgIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICAgIGhvb2tzLnB1c2guYXBwbHkoaG9va3MsIFJvdXRlSG9va3NbZ2V0Um91dGVJRChyb3V0ZSldKTtcbiAgICAgIHJldHVybiBob29rcztcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vayhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIGRpZG4ndCBhY3R1YWxseSBtYXRjaCBhbnl0aGluZywgYnV0IGhhbmdcbiAgICAgICAgLy8gb250byBlcnJvci9uZXh0U3RhdGUgc28gd2UgZG9uJ3QgaGF2ZSB0byBtYXRjaFJvdXRlc1xuICAgICAgICAvLyBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHNvbWUgc3RhdGUgaGVyZSBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBtYXRjaFJvdXRlcygpIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICBwYXJ0aWFsTmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG5cbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSBsb2NhdGlvbiBhcmcgaGVyZSBpbmRpY2F0ZXMgdG9cbiAgICAgICAgLy8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiBob29rLlxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gIGZ1bmN0aW9uIGJlZm9yZVVubG9hZEhvb2soKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcbiAgICAvLyB0byBwcmV2ZW50IHRoZSBjdXJyZW50IHdpbmRvdy90YWIgZnJvbSBjbG9zaW5nLlxuICAgIGlmIChzdGF0ZS5yb3V0ZXMpIHtcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3Npbmcgbm8gYXJncyBpbmRpY2F0ZXMgdG8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGFcbiAgICAgICAgLy8gYmVmb3JldW5sb2FkIGhvb2suIFdlIGRvbid0IGtub3cgdGhlIG5leHQgbG9jYXRpb24uXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5saXN0ZW5CZWZvcmUgPSB2b2lkIDAsXG4gICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlLCBmYWxzZSk7XG4gICAgaWYgKCFyb3V0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcykpIHtcbiAgICAgIC8vIHRlYXJkb3duIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZVVubG9hZCkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaG9vayBmdW5jdGlvbiB0byBydW4gYmVmb3JlIGxlYXZpbmcgdGhlIGdpdmVuIHJvdXRlLlxuICAgKlxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cbiAgICogYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIGNhbiByZXR1cm4gZWl0aGVyIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykgdG8gc2hvdyB0aGUgdXNlcixcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgd2FudCB0byBsZWF2ZSB0aGUgcGFnZTsgb3IgYGZhbHNlYCwgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICogQW55IG90aGVyIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoaW4gYnJvd3NlcnMpIHRoZSBob29rIHJlY2VpdmVzIG5vIGFyZ3VtZW50cy5cbiAgICogSW4gdGhpcyBjYXNlIGl0IG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gdW5iaW5kIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgaG9vaykge1xuICAgIC8vIFRPRE86IFdhcm4gaWYgdGhleSByZWdpc3RlciBmb3IgYSByb3V0ZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGFjdGl2ZS4gVGhleSdyZSBwcm9iYWJseSBkb2luZyBzb21ldGhpbmcgd3JvbmcsIGxpa2UgcmUtY3JlYXRpbmdcbiAgICAvLyByb3V0ZSBvYmplY3RzIG9uIGV2ZXJ5IGxvY2F0aW9uIGNoYW5nZS5cbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUpO1xuICAgIHZhciBob29rcyA9IFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhvb2tzKSB7XG4gICAgICB2YXIgdGhlcmVXZXJlTm9Sb3V0ZUhvb2tzID0gIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcyk7XG5cbiAgICAgIFJvdXRlSG9va3Nbcm91dGVJRF0gPSBbaG9va107XG5cbiAgICAgIGlmICh0aGVyZVdlcmVOb1JvdXRlSG9va3MpIHtcbiAgICAgICAgLy8gc2V0dXAgdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKHRyYW5zaXRpb25Ib29rKTtcblxuICAgICAgICBpZiAoaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQpIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQoYmVmb3JlVW5sb2FkSG9vayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChob29rcy5pbmRleE9mKGhvb2spID09PSAtMSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2FkZGluZyBtdWx0aXBsZSBsZWF2ZSBob29rcyBmb3IgdGhlIHNhbWUgcm91dGUgaXMgZGVwcmVjYXRlZDsgbWFuYWdlIG11bHRpcGxlIGNvbmZpcm1hdGlvbnMgaW4geW91ciBvd24gY29kZSBpbnN0ZWFkJykgOiB2b2lkIDA7XG5cbiAgICAgICAgaG9va3MucHVzaChob29rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIHZhciBuZXdIb29rcyA9IGhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmV3SG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IG5ld0hvb2tzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBBUEkgZm9yIHN0YXRlZnVsIGVudmlyb25tZW50cy4gQXMgdGhlIGxvY2F0aW9uXG4gICAqIGNoYW5nZXMsIHdlIHVwZGF0ZSBzdGF0ZSBhbmQgY2FsbCB0aGUgbGlzdGVuZXIuIFdlIGNhbiBhbHNvXG4gICAqIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9ycyBhbmQgcmVkaXJlY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgLy8gVE9ETzogT25seSB1c2UgYSBzaW5nbGUgaGlzdG9yeSBsaXN0ZW5lci4gT3RoZXJ3aXNlIHdlJ2xsXG4gICAgLy8gZW5kIHVwIHdpdGggbXVsdGlwbGUgY29uY3VycmVudCBjYWxscyB0byBtYXRjaC5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoc3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKG51bGwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaGlzdG9yeS50cmFuc2l0aW9uVG8ocmVkaXJlY3RMb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG51bGwsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnTG9jYXRpb24gXCIlc1wiIGRpZCBub3QgbWF0Y2ggYW55IHJvdXRlcycsIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCkgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU6IGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xufVxuXG4vL2V4cG9ydCBkZWZhdWx0IHVzZVJvdXRlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5nZXRIYXNoUGF0aCA9IGdldEhhc2hQYXRoO1xuZXhwb3J0cy5yZXBsYWNlSGFzaFBhdGggPSByZXBsYWNlSGFzaFBhdGg7XG5leHBvcnRzLmdldFdpbmRvd1BhdGggPSBnZXRXaW5kb3dQYXRoO1xuZXhwb3J0cy5nbyA9IGdvO1xuZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZ2V0VXNlckNvbmZpcm1hdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzFdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1BhdGgoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XG59XG5cbmZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufVxuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuIHVhLmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gJyArIG1lc3NhZ2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBkZXByZWNhdGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGhvb2sobG9jYXRpb24sIGNhbGxiYWNrKTtcblxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XG4gICAgLy8gQXNzdW1lIHRoZSBob29rIHJ1bnMgc3luY2hyb25vdXNseSBhbmQgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHJldHVybiB2YWx1ZS5cbiAgICBjYWxsYmFjayhyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyBjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NQ2hpbGRyZW5PcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbmZ1bmN0aW9uIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCBub2RlKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGV4dCBjb21wb25lbnRzLCB3aGljaCByZXR1cm4gW29wZW4sIGNsb3NlXSBjb21tZW50c1xuICAvLyBmcm9tIGdldEhvc3ROb2RlLlxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlWzFdO1xuICB9XG4gIHJldHVybiBub2RlID8gbm9kZS5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbnZhciBpbnNlcnRDaGlsZEF0ID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIFdlIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIChVc2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGwgYnJvd3NlcnMgc29cbiAgLy8gd2UgYXJlIGNhcmVmdWwgdG8gdXNlIGBudWxsYC4pXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59KTtcblxuZnVuY3Rpb24gaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZVswXSwgY2hpbGROb2RlWzFdLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBjaGlsZE5vZGVbMV07XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlWzBdO1xuICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBjbG9zaW5nQ29tbWVudCk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9zaW5nQ29tbWVudCk7XG4gIH1cbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbm9kZSA9IG5leHROb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgc3RhcnROb2RlLCBjbG9zaW5nQ29tbWVudCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgLy8gVGhlIGNsb3NpbmcgY29tbWVudCBpcyByZW1vdmVkIGJ5IFJlYWN0TXVsdGlDaGlsZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlRGVsaW1pdGVkVGV4dChvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHN0cmluZ1RleHQpIHtcbiAgdmFyIHBhcmVudE5vZGUgPSBvcGVuaW5nQ29tbWVudC5wYXJlbnROb2RlO1xuICB2YXIgbm9kZUFmdGVyQ29tbWVudCA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICBpZiAobm9kZUFmdGVyQ29tbWVudCA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gdGV4dCBub2RlcyBiZXR3ZWVuIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGNvbW1lbnRzOyBpbnNlcnRcbiAgICAvLyBhIG5ldyBvbmUgaWYgc3RyaW5nVGV4dCBpc24ndCBlbXB0eS5cbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdUZXh0KSwgbm9kZUFmdGVyQ29tbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgb3BlbmluZyBjb21tZW50LCBhbmRcbiAgICAgIC8vIHJlbW92ZSBhbGwgZm9sbG93aW5nIG5vZGVzIHVwIHVudGlsIHRoZSBjbG9zaW5nIGNvbW1lbnQuXG4gICAgICBzZXRUZXh0Q29udGVudChub2RlQWZ0ZXJDb21tZW50LCBzdHJpbmdUZXh0KTtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgbm9kZUFmdGVyQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCwgJ3JlcGxhY2UgdGV4dCcsIHN0cmluZ1RleHQpO1xuICB9XG59XG5cbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcbiAgICBpZiAocHJldkluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHByZXZJbnN0YW5jZS5fZGVidWdJRCwgJ3JlcGxhY2Ugd2l0aCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihuZXh0SW5zdGFuY2UuX2RlYnVnSUQsICdtb3VudCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHJlcGxhY2VEZWxpbWl0ZWRUZXh0OiByZXBsYWNlRGVsaW1pdGVkVGV4dCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB1cGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlRGVidWdJRCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHBhcmVudE5vZGUpLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNba107XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUDpcbiAgICAgICAgICBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdpbnNlcnQgY2hpbGQnLCB7IHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4LCBjb250ZW50OiB1cGRhdGUuY29udGVudC50b1N0cmluZygpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdtb3ZlIGNoaWxkJywgeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXgsIHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIGNoaWxkcmVuJywgdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIHRleHQnLCB1cGRhdGUuY29udGVudC50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ3JlbW92ZSBjaGlsZCcsIHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTmFtZXNwYWNlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9ET01OYW1lc3BhY2VzLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgQ29tcG9uZW50VHJlZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBpbnN0YW5jZXNcbiAqICAgYW5kIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBDb21wb25lbnRUcmVlO1xudmFyIFRyZWVUcmF2ZXJzYWw7XG52YXIgaW5qZWN0aW9uID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBDb21wb25lbnRUcmVlID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2UgJiYgSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBpbmplY3RUcmVlVHJhdmVyc2FsOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBUcmVlVHJhdmVyc2FsID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmlzQW5jZXN0b3IgJiYgSW5qZWN0ZWQuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RUcmVlVHJhdmVyc2FsKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgaXNBbmNlc3RvciBvciBnZXRMb3dlc3RDb21tb25BbmNlc3Rvci4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgS2V5RXNjYXBlVXRpbHNcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcykge1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBfcHJvZEludmFyaWFudCgnODcnKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBfcHJvZEludmFyaWFudCgnODgnKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSBjaGVja2VkTGluaycpIDogX3Byb2RJbnZhcmlhbnQoJzg5JykgOiB2b2lkIDA7XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3AsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogX3Byb2RJbnZhcmlhbnQoJzg1JykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSkgOiB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDQnKSA6IHZvaWQgMDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVycm9yVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHs/U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHsqfSBiIFNlY29uZCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSwgYikge1xuICB0cnkge1xuICAgIHJldHVybiBmdW5jKGEsIGIpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKlxuICAgKiBUbyBoZWxwIGRldmVsb3BtZW50IHdlIGNhbiBnZXQgYmV0dGVyIGRldnRvb2xzIGludGVncmF0aW9uIGJ5IHNpbXVsYXRpbmcgYVxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgICAgIHZhciBib3VuZEZ1bmMgPSBmdW5jLmJpbmQobnVsbCwgYSwgYik7XG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNTZWNyZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB2YXIgZGlzcGxheU5hbWUgPSBhcmcuY29uc3RydWN0b3IgJiYgYXJnLmNvbnN0cnVjdG9yLm5hbWUgfHwgdHlwZTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMubGVuZ3RoIDwgMjApIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWUgKyAnIChrZXlzOiAnICsga2V5cy5qb2luKCcsICcpICsgJyknO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGN0b3IgJiYgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyAnICsgJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciAnICsgJ3NpZGUtZWZmZWN0cyBhcmUgYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvICcgKyAnYGNvbXBvbmVudFdpbGxNb3VudGAuJywgY2FsbGVyTmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAvLyBEdXJpbmcgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXIgdGhpcyB3aWxsIHN0aWxsIGJlIG51bGwgYnV0IGFmdGVyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcbiAgICAgIC8vIHRoaXMgaGFjay5cbiAgICAgIHJldHVybiAhIWludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbGxlck5hbWUgTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcblxuICAgIC8vIFByZXZpb3VzbHkgd2Ugd291bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgZGlkbid0IGhhdmUgYW4gaW50ZXJuYWxcbiAgICAvLyBpbnN0YW5jZS4gU2luY2Ugd2Ugd2FudCB0byBtYWtlIGl0IGEgbm8tb3AgaW5zdGVhZCwgd2UgbWlycm9yIHRoZSBzYW1lXG4gICAgLy8gYmVoYXZpb3Igd2UgaGF2ZSBpbiBvdGhlciBlbnF1ZXVlKiBtZXRob2RzLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBpZ25vcmUgY2FsbGJhY2tzIGluIGNvbXBvbmVudFdpbGxNb3VudC4gU2VlXG4gICAgLy8gZW5xdWV1ZVVwZGF0ZXMuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldFN0YXRlKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwYXJ0aWFsU3RhdGUgIT0gbnVsbCwgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICsgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIC8vIFRPRE86IGludHJvZHVjZSBfcGVuZGluZ0NvbnRleHQgaW5zdGVhZCBvZiBzZXR0aW5nIGl0IGRpcmVjdGx5LlxuICAgIGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIHZhbGlkYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IF9wcm9kSW52YXJpYW50KCcxMjInLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IHZvaWQgMDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvblxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0SXRlcmF0b3JGblxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdmFsaWRhdGVET01OZXN0aW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcblxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuXG4gICAgICBjYXNlICd0YWJsZSc6XG5cbiAgICAgIGNhc2UgJ2hyJzpcblxuICAgICAgY2FzZSAneG1wJzpcblxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGRvIHtcbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICAgIGlmIChjaGlsZFRhZyAhPT0gJyN0ZXh0Jykge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8sIGluZm8pIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IGxvZ2dlciBmcm9tICdyZWR1eC1sb2dnZXInXG5pbXBvcnQgdGh1bmsgZnJvbSAncmVkdXgtdGh1bmsnXG5pbXBvcnQgcHJvbWlzZSBmcm9tICdyZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUnXG5cbmltcG9ydCByZWR1Y2VyIGZyb20gJy4vcmVkdWNlcnMvJ1xuXG5jb25zdCBtaWRkbGV3YXJlID0gYXBwbHlNaWRkbGV3YXJlKHByb21pc2UoKSwgdGh1bmssIGxvZ2dlcigpKVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdG9yZShyZWR1Y2VyKVxuLy9leHBvcnQgZGVmYXVsdCBjcmVhdGVTdG9yZShyZWR1Y2VyLCBtaWRkbGV3YXJlKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3N0b3JlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRTdGF0ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zdG9yZVNoYXBlLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2FybmluZztcbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogVGhpcyBhY3Rpb24gdHlwZSB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGhpc3RvcnkgYWN0aW9ucyBiZWxvdy5cbiAqIElmIHlvdSdyZSB3cml0aW5nIGEgbWlkZGxld2FyZSB0byB3YXRjaCBmb3IgbmF2aWdhdGlvbiBldmVudHMsIGJlIHN1cmUgdG9cbiAqIGxvb2sgZm9yIGFjdGlvbnMgb2YgdGhpcyB0eXBlLlxuICovXG52YXIgQ0FMTF9ISVNUT1JZX01FVEhPRCA9IGV4cG9ydHMuQ0FMTF9ISVNUT1JZX01FVEhPRCA9ICdAQHJvdXRlci9DQUxMX0hJU1RPUllfTUVUSE9EJztcblxuZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IENBTExfSElTVE9SWV9NRVRIT0QsXG4gICAgICBwYXlsb2FkOiB7IG1ldGhvZDogbWV0aG9kLCBhcmdzOiBhcmdzIH1cbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIFRoZXNlIGFjdGlvbnMgY29ycmVzcG9uZCB0byB0aGUgaGlzdG9yeSBBUEkuXG4gKiBUaGUgYXNzb2NpYXRlZCByb3V0ZXJNaWRkbGV3YXJlIHdpbGwgY2FwdHVyZSB0aGVzZSBldmVudHMgYmVmb3JlIHRoZXkgZ2V0IHRvXG4gKiB5b3VyIHJlZHVjZXIgYW5kIHJlaXNzdWUgdGhlbSBhcyB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gb24geW91ciBoaXN0b3J5LlxuICovXG52YXIgcHVzaCA9IGV4cG9ydHMucHVzaCA9IHVwZGF0ZUxvY2F0aW9uKCdwdXNoJyk7XG52YXIgcmVwbGFjZSA9IGV4cG9ydHMucmVwbGFjZSA9IHVwZGF0ZUxvY2F0aW9uKCdyZXBsYWNlJyk7XG52YXIgZ28gPSBleHBvcnRzLmdvID0gdXBkYXRlTG9jYXRpb24oJ2dvJyk7XG52YXIgZ29CYWNrID0gZXhwb3J0cy5nb0JhY2sgPSB1cGRhdGVMb2NhdGlvbignZ29CYWNrJyk7XG52YXIgZ29Gb3J3YXJkID0gZXhwb3J0cy5nb0ZvcndhcmQgPSB1cGRhdGVMb2NhdGlvbignZ29Gb3J3YXJkJyk7XG5cbnZhciByb3V0ZXJBY3Rpb25zID0gZXhwb3J0cy5yb3V0ZXJBY3Rpb25zID0geyBwdXNoOiBwdXNoLCByZXBsYWNlOiByZXBsYWNlLCBnbzogZ28sIGdvQmFjazogZ29CYWNrLCBnb0ZvcndhcmQ6IGdvRm9yd2FyZCB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvYWN0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLnJvdXRlckFjdGlvbnMgPSBleHBvcnRzLmdvRm9yd2FyZCA9IGV4cG9ydHMuZ29CYWNrID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMucmVwbGFjZSA9IGV4cG9ydHMucHVzaCA9IGV4cG9ydHMuQ0FMTF9ISVNUT1JZX01FVEhPRCA9IGV4cG9ydHMucm91dGVyUmVkdWNlciA9IGV4cG9ydHMuTE9DQVRJT05fQ0hBTkdFID0gZXhwb3J0cy5zeW5jSGlzdG9yeVdpdGhTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWR1Y2VyID0gcmVxdWlyZSgnLi9yZWR1Y2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTE9DQVRJT05fQ0hBTkdFJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlZHVjZXIuTE9DQVRJT05fQ0hBTkdFO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyUmVkdWNlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWR1Y2VyLnJvdXRlclJlZHVjZXI7XG4gIH1cbn0pO1xuXG52YXIgX2FjdGlvbnMgPSByZXF1aXJlKCcuL2FjdGlvbnMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDQUxMX0hJU1RPUllfTUVUSE9EJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuQ0FMTF9ISVNUT1JZX01FVEhPRDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3B1c2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWN0aW9ucy5wdXNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVwbGFjZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLnJlcGxhY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLmdvO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ29CYWNrJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuZ29CYWNrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ29Gb3J3YXJkJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuZ29Gb3J3YXJkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyQWN0aW9ucycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLnJvdXRlckFjdGlvbnM7XG4gIH1cbn0pO1xuXG52YXIgX3N5bmMgPSByZXF1aXJlKCcuL3N5bmMnKTtcblxudmFyIF9zeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bmMpO1xuXG52YXIgX21pZGRsZXdhcmUgPSByZXF1aXJlKCcuL21pZGRsZXdhcmUnKTtcblxudmFyIF9taWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21pZGRsZXdhcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmV4cG9ydHMuc3luY0hpc3RvcnlXaXRoU3RvcmUgPSBfc3luYzJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMucm91dGVyTWlkZGxld2FyZSA9IF9taWRkbGV3YXJlMlsnZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLnJvdXRlclJlZHVjZXIgPSByb3V0ZXJSZWR1Y2VyO1xuLyoqXG4gKiBUaGlzIGFjdGlvbiB0eXBlIHdpbGwgYmUgZGlzcGF0Y2hlZCB3aGVuIHlvdXIgaGlzdG9yeVxuICogcmVjZWl2ZXMgYSBsb2NhdGlvbiBjaGFuZ2UuXG4gKi9cbnZhciBMT0NBVElPTl9DSEFOR0UgPSBleHBvcnRzLkxPQ0FUSU9OX0NIQU5HRSA9ICdAQHJvdXRlci9MT0NBVElPTl9DSEFOR0UnO1xuXG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBsb2NhdGlvbkJlZm9yZVRyYW5zaXRpb25zOiBudWxsXG59O1xuXG4vKipcbiAqIFRoaXMgcmVkdWNlciB3aWxsIHVwZGF0ZSB0aGUgc3RhdGUgd2l0aCB0aGUgbW9zdCByZWNlbnQgbG9jYXRpb24gaGlzdG9yeVxuICogaGFzIHRyYW5zaXRpb25lZCB0by4gVGhpcyBtYXkgbm90IGJlIGluIHN5bmMgd2l0aCB0aGUgcm91dGVyLCBwYXJ0aWN1bGFybHlcbiAqIGlmIHlvdSBoYXZlIGFzeW5jaHJvbm91c2x5LWxvYWRlZCByb3V0ZXMsIHNvIHJlYWRpbmcgZnJvbSBhbmQgcmVseWluZyBvblxuICogdGhpcyBzdGF0ZSBpcyBkaXNjb3VyYWdlZC5cbiAqL1xuZnVuY3Rpb24gcm91dGVyUmVkdWNlcigpIHtcbiAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gaW5pdGlhbFN0YXRlIDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGU7XG4gIHZhciBwYXlsb2FkID0gX3JlZi5wYXlsb2FkO1xuXG4gIGlmICh0eXBlID09PSBMT0NBVElPTl9DSEFOR0UpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7IGxvY2F0aW9uQmVmb3JlVHJhbnNpdGlvbnM6IHBheWxvYWQgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9yZWR1Y2VyLmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGJvb2wgPSBfUmVhY3QkUHJvcFR5cGVzLmJvb2w7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvbmVPZlR5cGUgPSBfUmVhY3QkUHJvcFR5cGVzLm9uZU9mVHlwZTtcblxuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8vIFRPRE86IERlLWR1cGxpY2F0ZSBhZ2FpbnN0IGhhc0FueVByb3BlcnRpZXMgaW4gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIGZhbHNlO1xuICB9cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgX3JlZikge1xuICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5O1xuICB2YXIgaGFzaCA9IF9yZWYuaGFzaDtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICBpZiAocXVlcnkgfHwgaGFzaCB8fCBzdGF0ZSkge1xuICAgIHJldHVybiB7IHBhdGhuYW1lOiB0bywgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfTtcbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiBpcyB1c2VkIHRvIGNyZWF0ZSBhbiA8YT4gZWxlbWVudCB0aGF0IGxpbmtzIHRvIGEgcm91dGUuXG4gKiBXaGVuIHRoYXQgcm91dGUgaXMgYWN0aXZlLCB0aGUgbGluayBnZXRzIHRoZSB2YWx1ZSBvZiBpdHNcbiAqIGFjdGl2ZUNsYXNzTmFtZSBwcm9wLlxuICpcbiAqIEZvciBleGFtcGxlLCBhc3N1bWluZyB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHJvdXRlOlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvcG9zdHMvOnBvc3RJRFwiIGNvbXBvbmVudD17UG9zdH0gLz5cbiAqXG4gKiBZb3UgY291bGQgdXNlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50IHRvIGxpbmsgdG8gdGhhdCByb3V0ZTpcbiAqXG4gKiAgIDxMaW5rIHRvPXtgL3Bvc3RzLyR7cG9zdC5pZH1gfSAvPlxuICpcbiAqIExpbmtzIG1heSBwYXNzIGFsb25nIGxvY2F0aW9uIHN0YXRlIGFuZC9vciBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xuICogaW4gdGhlIHN0YXRlL3F1ZXJ5IHByb3BzLCByZXNwZWN0aXZlbHkuXG4gKlxuICogICA8TGluayAuLi4gcXVlcnk9e3sgc2hvdzogdHJ1ZSB9fSBzdGF0ZT17eyB0aGU6ICdzdGF0ZScgfX0gLz5cbiAqL1xudmFyIExpbmsgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxuXG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlXG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdG86IG9uZU9mVHlwZShbc3RyaW5nLCBvYmplY3RdKS5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgaGFzaDogc3RyaW5nLFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgYWN0aXZlU3R5bGU6IG9iamVjdCxcbiAgICBhY3RpdmVDbGFzc05hbWU6IHN0cmluZyxcbiAgICBvbmx5QWN0aXZlT25JbmRleDogYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uQ2xpY2s6IGZ1bmMsXG4gICAgdGFyZ2V0OiBzdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25seUFjdGl2ZU9uSW5kZXg6IGZhbHNlLFxuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykgdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAhdGhpcy5jb250ZXh0LnJvdXRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8TGluaz5zIHJlbmRlcmVkIG91dHNpZGUgb2YgYSByb3V0ZXIgY29udGV4dCBjYW5ub3QgbmF2aWdhdGUuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICAvLyBJZiB0YXJnZXQgcHJvcCBpcyBzZXQgKGUuZy4gdG8gXCJfYmxhbmtcIiksIGxldCBicm93c2VyIGhhbmRsZSBsaW5rLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gICAgaWYgKHRoaXMucHJvcHMudGFyZ2V0KSByZXR1cm47XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRvID0gX3Byb3BzLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wcy5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wcy5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IF9wcm9wcy5zdGF0ZTtcblxuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgeyBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9KTtcblxuICAgIHRoaXMuY29udGV4dC5yb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdG8gPSBfcHJvcHMyLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wczIucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBfcHJvcHMyLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gX3Byb3BzMi5zdGF0ZTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gX3Byb3BzMi5hY3RpdmVDbGFzc05hbWU7XG4gICAgdmFyIGFjdGl2ZVN0eWxlID0gX3Byb3BzMi5hY3RpdmVTdHlsZTtcbiAgICB2YXIgb25seUFjdGl2ZU9uSW5kZXggPSBfcHJvcHMyLm9ubHlBY3RpdmVPbkluZGV4O1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsndG8nLCAncXVlcnknLCAnaGFzaCcsICdzdGF0ZScsICdhY3RpdmVDbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnb25seUFjdGl2ZU9uSW5kZXgnXSk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghKHF1ZXJ5IHx8IGhhc2ggfHwgc3RhdGUpLCAndGhlIGBxdWVyeWAsIGBoYXNoYCwgYW5kIGBzdGF0ZWAgcHJvcHMgb24gYDxMaW5rPmAgYXJlIGRlcHJlY2F0ZWQsIHVzZSBgPExpbmsgdG89e3sgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoLCBzdGF0ZSB9fS8+LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZ25vcmUgaWYgcmVuZGVyZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiByb3V0ZXIsIHNpbXBsaWZpZXMgdW5pdCB0ZXN0aW5nLlxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuXG5cbiAgICBpZiAocm91dGVyKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIHsgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICBwcm9wcy5ocmVmID0gcm91dGVyLmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lIHx8IGFjdGl2ZVN0eWxlICE9IG51bGwgJiYgIWlzRW1wdHlPYmplY3QoYWN0aXZlU3R5bGUpKSB7XG4gICAgICAgIGlmIChyb3V0ZXIuaXNBY3RpdmUobG9jYXRpb24sIG9ubHlBY3RpdmVPbkluZGV4KSkge1xuICAgICAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb3BzLmNsYXNzTmFtZSA9IGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWN0aXZlU3R5bGUpIHByb3BzLnN0eWxlID0gX2V4dGVuZHMoe30sIHByb3BzLnN0eWxlLCBhY3RpdmVTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljayB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8UmVkaXJlY3Q+IGlzIHVzZWQgdG8gZGVjbGFyZSBhbm90aGVyIFVSTCBwYXRoIGEgY2xpZW50IHNob3VsZFxuICogYmUgc2VudCB0byB3aGVuIHRoZXkgcmVxdWVzdCBhIGdpdmVuIFVSTC5cbiAqXG4gKiBSZWRpcmVjdHMgYXJlIHBsYWNlZCBhbG9uZ3NpZGUgcm91dGVzIGluIHRoZSByb3V0ZSBjb25maWd1cmF0aW9uXG4gKiBhbmQgYXJlIHRyYXZlcnNlZCBpbiB0aGUgc2FtZSBtYW5uZXIuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWRpcmVjdCcsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHJvdXRlID0gKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkoZWxlbWVudCk7XG5cbiAgICAgIGlmIChyb3V0ZS5mcm9tKSByb3V0ZS5wYXRoID0gcm91dGUuZnJvbTtcblxuICAgICAgcm91dGUub25FbnRlciA9IGZ1bmN0aW9uIChuZXh0U3RhdGUsIHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uO1xuICAgICAgICB2YXIgcGFyYW1zID0gbmV4dFN0YXRlLnBhcmFtcztcblxuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHJvdXRlLnRvLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShyb3V0ZS50bywgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm91dGUudG8pIHtcbiAgICAgICAgICBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByb3V0ZUluZGV4ID0gbmV4dFN0YXRlLnJvdXRlcy5pbmRleE9mKHJvdXRlKTtcbiAgICAgICAgICB2YXIgcGFyZW50UGF0dGVybiA9IFJlZGlyZWN0LmdldFJvdXRlUGF0dGVybihuZXh0U3RhdGUucm91dGVzLCByb3V0ZUluZGV4IC0gMSk7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXJlbnRQYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHJvdXRlLnRvO1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocGF0dGVybiwgcGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcGxhY2Uoe1xuICAgICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgICAgICBxdWVyeTogcm91dGUucXVlcnkgfHwgbG9jYXRpb24ucXVlcnksXG4gICAgICAgICAgc3RhdGU6IHJvdXRlLnN0YXRlIHx8IGxvY2F0aW9uLnN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH0sXG4gICAgZ2V0Um91dGVQYXR0ZXJuOiBmdW5jdGlvbiBnZXRSb3V0ZVBhdHRlcm4ocm91dGVzLCByb3V0ZUluZGV4KSB7XG4gICAgICB2YXIgcGFyZW50UGF0dGVybiA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gcm91dGVJbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICAgICAgcGFyZW50UGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGFyZW50UGF0dGVybjtcblxuICAgICAgICBpZiAocGF0dGVybi5pbmRleE9mKCcvJykgPT09IDApIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJy8nICsgcGFyZW50UGF0dGVybjtcbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZyb206IHN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGhcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmNyZWF0ZVJvdXRlck9iamVjdCA9IGNyZWF0ZVJvdXRlck9iamVjdDtcbmV4cG9ydHMuY3JlYXRlUm91dGluZ0hpc3RvcnkgPSBjcmVhdGVSb3V0aW5nSGlzdG9yeTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIHNldFJvdXRlTGVhdmVIb29rOiB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgaXNBY3RpdmU6IHRyYW5zaXRpb25NYW5hZ2VyLmlzQWN0aXZlXG4gIH0pO1xufVxuXG4vLyBkZXByZWNhdGVkXG5mdW5jdGlvbiBjcmVhdGVSb3V0aW5nSGlzdG9yeShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcikge1xuICBoaXN0b3J5ID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGhpc3RvcnkgPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGhpc3RvcnksICdgcHJvcHMuaGlzdG9yeWAgYW5kIGBjb250ZXh0Lmhpc3RvcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlcmAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jb250ZXh0Y2hhbmdlcycpO1xuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIC8vIHNpZ25hdHVyZXMgYW5kIHR5cGUgY2hlY2tpbmcgZGlmZmVyIGJldHdlZW4gYHVzZVJvdXRlc2AgYW5kXG4gIC8vIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCwgaGF2ZSB0byBjcmVhdGUgYG1lbW9yeUhpc3RvcnlgIGZpcnN0IGJlY2F1c2VcbiAgLy8gYHVzZVF1ZXJpZXNgIGRvZXNuJ3QgdW5kZXJzdGFuZCB0aGUgc2lnbmF0dXJlXG4gIHZhciBtZW1vcnlIaXN0b3J5ID0gKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgIHJldHVybiBtZW1vcnlIaXN0b3J5O1xuICB9O1xuICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY3JlYXRlSGlzdG9yeSkge1xuICB2YXIgaGlzdG9yeSA9IHZvaWQgMDtcbiAgaWYgKGNhblVzZURPTSkgaGlzdG9yeSA9ICgwLCBfdXNlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoKTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGV4cG9ydHMuaGFzaEhpc3RvcnkgPSBleHBvcnRzLmJyb3dzZXJIaXN0b3J5ID0gZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBleHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMuUHJvcFR5cGVzID0gZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IGV4cG9ydHMuUm91dGVyQ29udGV4dCA9IGV4cG9ydHMuY3JlYXRlUm91dGVzID0gZXhwb3J0cy51c2VSb3V0ZXMgPSBleHBvcnRzLlJvdXRlQ29udGV4dCA9IGV4cG9ydHMuTGlmZWN5Y2xlID0gZXhwb3J0cy5IaXN0b3J5ID0gZXhwb3J0cy5Sb3V0ZSA9IGV4cG9ydHMuUmVkaXJlY3QgPSBleHBvcnRzLkluZGV4Um91dGUgPSBleHBvcnRzLkluZGV4UmVkaXJlY3QgPSBleHBvcnRzLndpdGhSb3V0ZXIgPSBleHBvcnRzLkluZGV4TGluayA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMuUm91dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXM7XG4gIH1cbn0pO1xuXG52YXIgX1Byb3BUeXBlczIgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2xvY2F0aW9uU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5sb2NhdGlvblNoYXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5yb3V0ZXJTaGFwZTtcbiAgfVxufSk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRQYXR0ZXJuJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuO1xuICB9XG59KTtcblxudmFyIF9Sb3V0ZXIyID0gcmVxdWlyZSgnLi9Sb3V0ZXInKTtcblxudmFyIF9Sb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyMik7XG5cbnZhciBfTGluazIgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmsyKTtcblxudmFyIF9JbmRleExpbmsyID0gcmVxdWlyZSgnLi9JbmRleExpbmsnKTtcblxudmFyIF9JbmRleExpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhMaW5rMik7XG5cbnZhciBfd2l0aFJvdXRlcjIgPSByZXF1aXJlKCcuL3dpdGhSb3V0ZXInKTtcblxudmFyIF93aXRoUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dpdGhSb3V0ZXIyKTtcblxudmFyIF9JbmRleFJlZGlyZWN0MiA9IHJlcXVpcmUoJy4vSW5kZXhSZWRpcmVjdCcpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSZWRpcmVjdDIpO1xuXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XG5cbnZhciBfSW5kZXhSb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJvdXRlMik7XG5cbnZhciBfUmVkaXJlY3QyID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0Mik7XG5cbnZhciBfUm91dGUyID0gcmVxdWlyZSgnLi9Sb3V0ZScpO1xuXG52YXIgX1JvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlMik7XG5cbnZhciBfSGlzdG9yeTIgPSByZXF1aXJlKCcuL0hpc3RvcnknKTtcblxudmFyIF9IaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hpc3RvcnkyKTtcblxudmFyIF9MaWZlY3ljbGUyID0gcmVxdWlyZSgnLi9MaWZlY3ljbGUnKTtcblxudmFyIF9MaWZlY3ljbGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlmZWN5Y2xlMik7XG5cbnZhciBfUm91dGVDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlQ29udGV4dDIpO1xuXG52YXIgX3VzZVJvdXRlczIgPSByZXF1aXJlKCcuL3VzZVJvdXRlcycpO1xuXG52YXIgX3VzZVJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXMyKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dDIpO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGluZ0NvbnRleHQnKTtcblxudmFyIF9Sb3V0aW5nQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0aW5nQ29udGV4dDIpO1xuXG52YXIgX1Byb3BUeXBlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm9wVHlwZXMyKTtcblxudmFyIF9tYXRjaDIgPSByZXF1aXJlKCcuL21hdGNoJyk7XG5cbnZhciBfbWF0Y2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2gyKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeTIpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTIgPSByZXF1aXJlKCcuL2FwcGx5Um91dGVyTWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseVJvdXRlck1pZGRsZXdhcmUyKTtcblxudmFyIF9icm93c2VySGlzdG9yeTIgPSByZXF1aXJlKCcuL2Jyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfYnJvd3Nlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3Nlckhpc3RvcnkyKTtcblxudmFyIF9oYXNoSGlzdG9yeTIgPSByZXF1aXJlKCcuL2hhc2hIaXN0b3J5Jyk7XG5cbnZhciBfaGFzaEhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzaEhpc3RvcnkyKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlJvdXRlciA9IF9Sb3V0ZXIzLmRlZmF1bHQ7IC8qIGNvbXBvbmVudHMgKi9cblxuZXhwb3J0cy5MaW5rID0gX0xpbmszLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4TGluayA9IF9JbmRleExpbmszLmRlZmF1bHQ7XG5leHBvcnRzLndpdGhSb3V0ZXIgPSBfd2l0aFJvdXRlcjMuZGVmYXVsdDtcblxuLyogY29tcG9uZW50cyAoY29uZmlndXJhdGlvbikgKi9cblxuZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gX0luZGV4UmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4Um91dGUgPSBfSW5kZXhSb3V0ZTMuZGVmYXVsdDtcbmV4cG9ydHMuUmVkaXJlY3QgPSBfUmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlID0gX1JvdXRlMy5kZWZhdWx0O1xuXG4vKiBtaXhpbnMgKi9cblxuZXhwb3J0cy5IaXN0b3J5ID0gX0hpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLkxpZmVjeWNsZSA9IF9MaWZlY3ljbGUzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlQ29udGV4dCA9IF9Sb3V0ZUNvbnRleHQzLmRlZmF1bHQ7XG5cbi8qIHV0aWxzICovXG5cbmV4cG9ydHMudXNlUm91dGVzID0gX3VzZVJvdXRlczMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGVyQ29udGV4dCA9IF9Sb3V0ZXJDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IF9Sb3V0aW5nQ29udGV4dDMuZGVmYXVsdDtcbmV4cG9ydHMuUHJvcFR5cGVzID0gX1Byb3BUeXBlczMuZGVmYXVsdDtcbmV4cG9ydHMubWF0Y2ggPSBfbWF0Y2gzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBfdXNlUm91dGVySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gX2FwcGx5Um91dGVyTWlkZGxld2FyZTMuZGVmYXVsdDtcblxuLyogaGlzdG9yaWVzICovXG5cbmV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBfYnJvd3Nlckhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmhhc2hIaXN0b3J5ID0gX2hhc2hIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VTdGF0ZVdpdGhMb2NhdGlvbjtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdpdGhMb2NhdGlvbihzdGF0ZSwgbG9jYXRpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuY2FuVXNlTWVtYnJhbmUpIHtcbiAgICB2YXIgc3RhdGVXaXRoTG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgc3RhdGUpO1xuXG4gICAgLy8gSSBkb24ndCB1c2UgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyBoZXJlIGJlY2F1c2UgSSB3YW50IHRvIGtlZXAgdGhlXG4gICAgLy8gc2FtZSBjb2RlIHBhdGggYmV0d2VlbiBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiwgaW4gdGhhdCB3ZSBqdXN0XG4gICAgLy8gYXNzaWduIGV4dHJhIHByb3BlcnRpZXMgdG8gdGhlIGNvcHkgb2YgdGhlIHN0YXRlIG9iamVjdCBpbiBib3RoIGNhc2VzLlxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYXRpb24sIHByb3ApKSB7XG4gICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGVXaXRoTG9jYXRpb24sIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBY2Nlc3NpbmcgbG9jYXRpb24gcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgZ2V0Q29tcG9uZW50YCwgYGdldENvbXBvbmVudHNgLCBgZ2V0Q2hpbGRSb3V0ZXNgLCBhbmQgYGdldEluZGV4Um91dGVgIGlzIGRlcHJlY2F0ZWQuIFRoYXQgYXJndW1lbnQgaXMgbm93IHRoZSByb3V0ZXIgc3RhdGUgKGBuZXh0U3RhdGVgIG9yIGBwYXJ0aWFsTmV4dFN0YXRlYCkgcmF0aGVyIHRoYW4gdGhlIGxvY2F0aW9uLiBUbyBhY2Nlc3MgdGhlIGxvY2F0aW9uLCB1c2UgYG5leHRTdGF0ZS5sb2NhdGlvbmAgb3IgYHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb25gLicpIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gbG9jYXRpb24pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVXaXRoTG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBsb2NhdGlvbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21ha2VTdGF0ZVdpdGhMb2NhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VSb3V0ZXJIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB1c2VSb3V0ZXJIaXN0b3J5KGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKCgwLCBfdXNlQmFzZW5hbWUyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKmVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbmV4cG9ydHMucmVhZFN0YXRlID0gcmVhZFN0YXRlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgS2V5UHJlZml4ID0gJ0BASGlzdG9yeS8nO1xudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSBbJ1F1b3RhRXhjZWVkZWRFcnJvcicsICdRVU9UQV9FWENFRURFRF9FUlInXTtcblxudmFyIFNlY3VyaXR5RXJyb3IgPSAnU2VjdXJpdHlFcnJvcic7XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIEtleVByZWZpeCArIGtleTtcbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFF1b3RhRXhjZWVkZWRFcnJvcnMuaW5kZXhPZihlcnJvci5uYW1lKSA+PSAwICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFNhZmFyaSBcInByaXZhdGUgbW9kZVwiIHRocm93cyBRdW90YUV4Y2VlZGVkRXJyb3IuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gU2FmYXJpIHByaXZhdGUgbW9kZScpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICB2YXIganNvbiA9IHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICBqc29uID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gcmVhZCBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIEpTT04uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVET01IaXN0b3J5KG9wdGlvbnMpIHtcbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7XG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogX0RPTVV0aWxzLmdldFVzZXJDb25maXJtYXRpb25cbiAgfSwgb3B0aW9ucywge1xuICAgIGdvOiBfRE9NVXRpbHMuZ29cbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdET00gaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZURPTUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZURPTUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZURPTUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBpc0Fic29sdXRlUGF0aChwYXRoKSB7XG4gIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2goKSB7XG4gIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgaWYgKGlzQWJzb2x1dGVQYXRoKHBhdGgpKSByZXR1cm4gdHJ1ZTtcblxuICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKCcvJyArIHBhdGgpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBwYXRoICsgKHBhdGguaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyAoa2V5ICsgJz0nICsgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdbPyZdPycgKyBrZXkgKyAnPVthLXpBLVowLTldKycpLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgdmFyIG1hdGNoID0gcGF0aC5tYXRjaChuZXcgUmVnRXhwKCdcXFxcPy4qP1xcXFxiJyArIGtleSArICc9KC4rPylcXFxcYicpKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuXG52YXIgRGVmYXVsdFF1ZXJ5S2V5ID0gJ19rJztcblxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHF1ZXJ5S2V5ID0gb3B0aW9ucy5xdWVyeUtleTtcblxuICBpZiAocXVlcnlLZXkgPT09IHVuZGVmaW5lZCB8fCAhIXF1ZXJ5S2V5KSBxdWVyeUtleSA9IHR5cGVvZiBxdWVyeUtleSA9PT0gJ3N0cmluZycgPyBxdWVyeUtleSA6IERlZmF1bHRRdWVyeUtleTtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICAgIHZhciBrZXkgPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YXRlID0gdW5kZWZpbmVkO1xuICAgIGlmIChxdWVyeUtleSkge1xuICAgICAga2V5ID0gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIHF1ZXJ5S2V5KTtcbiAgICAgIHBhdGggPSBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBxdWVyeUtleSk7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc3RhdGUgPSBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuICAgICAgICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwgcXVlcnlLZXksIGtleSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihfcmVmKSB7XG4gICAgdmFyIHRyYW5zaXRpb25UbyA9IF9yZWYudHJhbnNpdGlvblRvO1xuXG4gICAgZnVuY3Rpb24gaGFzaENoYW5nZUxpc3RlbmVyKCkge1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSByZXR1cm47IC8vIEFsd2F5cyBtYWtlIHN1cmUgaGFzaGVzIGFyZSBwcmVjZWVkZWQgd2l0aCBhIC8uXG5cbiAgICAgIHRyYW5zaXRpb25UbyhnZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gICAgfVxuXG4gICAgZW5zdXJlU2xhc2goKTtcbiAgICBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgaGFzaENoYW5nZUxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgaGFzaENoYW5nZUxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhbnNpdGlvbihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gICAgdmFyIGFjdGlvbiA9IGxvY2F0aW9uLmFjdGlvbjtcbiAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIHNlYXJjaDtcblxuICAgIGlmIChxdWVyeUtleSkge1xuICAgICAgcGF0aCA9IGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwgcXVlcnlLZXksIGtleSk7XG4gICAgICBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZShrZXksIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRHJvcCBrZXkgYW5kIHN0YXRlLlxuICAgICAgbG9jYXRpb24ua2V5ID0gbG9jYXRpb24uc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SGFzaCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgaWYgKGN1cnJlbnRIYXNoICE9PSBwYXRoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1lvdSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoIHVzaW5nIGhhc2ggaGlzdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudEhhc2ggIT09IHBhdGgpIHtcbiAgICAgIC8vIFJFUExBQ0VcbiAgICAgIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlRE9NSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZVxuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IGxvY2F0aW9uLnN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnB1c2gobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBsb2NhdGlvbi5zdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgfVxuXG4gIHZhciBnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCA9IF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkuZ28obik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICByZXR1cm4gJyMnICsgaGlzdG9yeS5jcmVhdGVIcmVmKHBhdGgpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICBoaXN0b3J5LnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaGlzdG9yeS51bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG5cbiAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBzdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHBhdGgpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcblxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHB1c2hTdGF0ZTogcHVzaFN0YXRlLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlU3RhdGUgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjIgPSByZXF1aXJlKCcuL2NyZWF0ZUxvY2F0aW9uJyk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTG9jYXRpb24yKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmXG4gIC8vYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5rZXkgPT09IGIua2V5ICYmIF9kZWVwRXF1YWwyWydkZWZhdWx0J10oYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbnZhciBEZWZhdWx0S2V5TGVuZ3RoID0gNjtcblxuZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IG9wdGlvbnMuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgZmluaXNoVHJhbnNpdGlvbiA9IG9wdGlvbnMuZmluaXNoVHJhbnNpdGlvbjtcbiAgdmFyIHNhdmVTdGF0ZSA9IG9wdGlvbnMuc2F2ZVN0YXRlO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IG9wdGlvbnMuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgdmFyIGtleUxlbmd0aCA9IG9wdGlvbnMua2V5TGVuZ3RoO1xuXG4gIGlmICh0eXBlb2Yga2V5TGVuZ3RoICE9PSAnbnVtYmVyJykga2V5TGVuZ3RoID0gRGVmYXVsdEtleUxlbmd0aDtcblxuICB2YXIgdHJhbnNpdGlvbkhvb2tzID0gW107XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gW107XG4gIHZhciBjaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAmJiBwZW5kaW5nTG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzLmluZGV4T2YocGVuZGluZ0xvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnQoKTtcblxuICAgIGxvY2F0aW9uID0gbmV3TG9jYXRpb247XG5cbiAgICBpZiAobG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBhbGxLZXlzID0gW10uY29uY2F0KGFsbEtleXMuc2xpY2UoMCwgY3VycmVudCArIDEpLCBbbG9jYXRpb24ua2V5XSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgY2hhbmdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcihsb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBjaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9sb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgICAgYWxsS2V5cyA9IFtfbG9jYXRpb24ua2V5XTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKF9sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5nZUxpc3RlbmVycyA9IGNoYW5nZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgX0FzeW5jVXRpbHMubG9vcEFzeW5jKHRyYW5zaXRpb25Ib29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKHRyYW5zaXRpb25Ib29rc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIGRvbmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwZW5kaW5nTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiAmJiBsb2NhdGlvbnNBcmVFcXVhbChsb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgY29uZmlybVRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkLlxuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gdHJlYXQgUFVTSCB0byBjdXJyZW50IHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShsb2NhdGlvbi5zdGF0ZSwgbmV4dExvY2F0aW9uLnN0YXRlKSkgbmV4dExvY2F0aW9uLmFjdGlvbiA9IF9BY3Rpb25zLlJFUExBQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmluaXNoVHJhbnNpdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobG9jYXRpb24ua2V5KTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGFsbEtleXMuaW5kZXhPZihuZXh0TG9jYXRpb24ua2V5KTtcblxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSAmJiBuZXh0SW5kZXggIT09IC0xKSBnbyhwcmV2SW5kZXggLSBuZXh0SW5kZXgpOyAvLyBSZXN0b3JlIHRoZSBVUkwuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5QVVNILCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgX0FjdGlvbnMuUkVQTEFDRSwgY3JlYXRlS2V5KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJhbmRvbUtleShrZXlMZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBsb2NhdGlvbjtcblxuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gICAgdmFyIHJlc3VsdCA9IHBhdGhuYW1lO1xuXG4gICAgaWYgKHNlYXJjaCkgcmVzdWx0ICs9IHNlYXJjaDtcblxuICAgIGlmIChoYXNoKSByZXN1bHQgKz0gaGFzaDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBjcmVhdGVLZXkoKSA6IGFyZ3VtZW50c1syXTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArICdsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgICBhY3Rpb24gPSBrZXk7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbM10gfHwgY3JlYXRlS2V5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbjNbJ2RlZmF1bHQnXShsb2NhdGlvbiwgYWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpO1xuICAgICAgdXBkYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGdldEN1cnJlbnRMb2NhdGlvbigpLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpIHtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbi5zdGF0ZSwgc3RhdGUpO1xuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKHRyYW5zaXRpb25Ib29rcy5pbmRleE9mKGhvb2spID09PSAtMSkgdHJhbnNpdGlvbkhvb2tzLnB1c2goaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgdHJhbnNpdGlvbkhvb2tzID0gdHJhbnNpdGlvbkhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgfSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgdHJhbnNpdGlvblRvOiB0cmFuc2l0aW9uVG8sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjcmVhdGVLZXk6IGNyZWF0ZUtleSxcbiAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgc2V0U3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10oc2V0U3RhdGUsICdzZXRTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgbG9jYXRpb24ua2V5IHRvIHNhdmUgc3RhdGUgaW5zdGVhZCcpLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3JlZ2lzdGVyVHJhbnNpdGlvbkhvb2sgaXMgZGVwcmVjYXRlZDsgdXNlIGxpc3RlbkJlZm9yZSBpbnN0ZWFkJyksXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3VucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZyb20gbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gdXNlQmFzZW5hbWUoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgYmFzZW5hbWUgPSBvcHRpb25zLmJhc2VuYW1lO1xuXG4gICAgdmFyIGNoZWNrZWRCYXNlSHJlZiA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tCYXNlSHJlZigpIHtcbiAgICAgIGlmIChjaGVja2VkQmFzZUhyZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHVzZSB0aGUgdmFsdWUgb2YgPGJhc2UgaHJlZj4gaW4gSFRNTFxuICAgICAgLy8gZG9jdW1lbnRzIGFzIGJhc2VuYW1lIGlmIGl0J3Mgbm90IGV4cGxpY2l0bHkgZ2l2ZW4uXG4gICAgICBpZiAoYmFzZW5hbWUgPT0gbnVsbCAmJiBfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgICAgIHZhciBiYXNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgICAgICAgdmFyIGJhc2VIcmVmID0gYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICAgIGlmIChiYXNlSHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgYmFzZW5hbWUgPSBiYXNlSHJlZjtcblxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0F1dG9tYXRpY2FsbHkgc2V0dGluZyBiYXNlbmFtZSB1c2luZyA8YmFzZSBocmVmPiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsICcgKyAnYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBUaGUgc2VtYW50aWNzIG9mIDxiYXNlIGhyZWY+IGFyZSAnICsgJ3N1YnRseSBkaWZmZXJlbnQgZnJvbSBiYXNlbmFtZS4gUGxlYXNlIHBhc3MgdGhlIGJhc2VuYW1lIGV4cGxpY2l0bHkgaW4gJyArICd0aGUgb3B0aW9ucyB0byBjcmVhdGVIaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2tlZEJhc2VIcmVmID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgY2hlY2tCYXNlSHJlZigpO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgJiYgbG9jYXRpb24uYmFzZW5hbWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlbmFtZSkgPT09IDApIHtcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZyhiYXNlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gYmFzZW5hbWU7XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09ICcnKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGNoZWNrQmFzZUhyZWYoKTtcblxuICAgICAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBwbmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRCYXNlbmFtZSA9IGJhc2VuYW1lLnNsaWNlKC0xKSA9PT0gJy8nID8gYmFzZW5hbWUgOiBiYXNlbmFtZSArICcvJztcbiAgICAgIHZhciBub3JtYWxpemVkUGF0aG5hbWUgPSBwbmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IHBuYW1lLnNsaWNlKDEpIDogcG5hbWU7XG4gICAgICB2YXIgcGF0aG5hbWUgPSBub3JtYWxpemVkQmFzZW5hbWUgKyBub3JtYWxpemVkUGF0aG5hbWU7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIF9ydW5UcmFuc2l0aW9uSG9vazJbJ2RlZmF1bHQnXShob29rLCBhZGRCYXNlbmFtZShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihhZGRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnB1c2gocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkQmFzZW5hbWUoaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKV0uY29uY2F0KGFyZ3MpKSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgICAgcmVwbGFjZVN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlcGxhY2VTdGF0ZSwgJ3JlcGxhY2VTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcmVwbGFjZSBpbnN0ZWFkJylcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gdXNlQmFzZW5hbWU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XG4gKiBkb2Vzbid0IGxpa2UgZG9pbmcgdGhhdCB3aXRoIHNob3J0aGFuZCBwcm9wZXJ0aWVzIHNvIGZvciB0aGUgcHJvcGVydGllcyB0aGF0XG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxuICogVGhlIDQtdmFsdWUgJ2Nsb2NrJyBwcm9wZXJ0aWVzIGxpa2UgbWFyZ2luLCBwYWRkaW5nLCBib3JkZXItd2lkdGggc2VlbSB0b1xuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XG4gKiBzcGVjaWFsIHByb2RkaW5nLlxuICovXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xuICBiYWNrZ3JvdW5kOiB7XG4gICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZVxuICB9LFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IHtcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgb3V0bGluZVdpZHRoOiB0cnVlLFxuICAgIG91dGxpbmVTdHlsZTogdHJ1ZSxcbiAgICBvdXRsaW5lQ29sb3I6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENhbGxiYWNrUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuX2Fzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogX3Byb2RJbnZhcmlhbnQoJzI0JykgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcyA/IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggOiAwO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAobGVuKSB7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9IGxlbjtcbiAgICAgIHRoaXMuX2NvbnRleHRzLmxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIGNyZWF0ZU1hcmt1cEZvclJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9yUm9vdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FLCAnJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQ7XG4gIHZhciBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXg7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2YoeyBtaXhpbnM6IG51bGwgfSk7XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBob3N0IGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuLy8gbm9vcFxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSBgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyBkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzMnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzQnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICB2YXIgaXNNaXhpblZhbGlkID0gdHlwZW9mU3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbDtcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaXNNaXhpblZhbGlkLCAnJXM6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgJyArICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgKyAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICsgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc1JykgOiB2b2lkIDA7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzYnKSA6IHZvaWQgMDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc3Jywgc3BlY1BvbGljeSwgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkIHByb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc4JywgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OScsIG5hbWUpIDogdm9pZCAwO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBfcHJvZEludmFyaWFudCgnODAnKSA6IHZvaWQgMDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvIGdldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBfcHJvZEludmFyaWFudCgnODEnLCBrZXkpIDogdm9pZCAwO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5fYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzgyJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IF9wcm9kSW52YXJpYW50KCc4MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudEZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHtcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHNlbGVjdGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXG4gKiBAcGFyYW0geyp9IHByb3BWYWx1ZSBBIHN0cmluZ2FibGUgKHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ2FibGVzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoaW5zdCwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wcyhpbnN0LCBwcm9wcyksIHtcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXG4gICAgfTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGdldFNlbGVjdFZhbHVlQ29udGV4dDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBSZWFjdERPTU9wdGlvbiBsb29rcyBhdCB0aGlzIGluaXRpYWwgdmFsdWUgc28gdGhlIGluaXRpYWwgZ2VuZXJhdGVkXG4gICAgLy8gbWFya3VwIGhhcyBjb3JyZWN0IGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuICAgIHJldHVybiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICB9LFxuXG4gIHBvc3RVcGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gICAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB3YXNNdWx0aXBsZSA9IGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgUmVhY3RVcGRhdGVzLmFzYXAodXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlDb21wb25lbnRGYWN0b3J5O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5OiBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGVtcHR5Q29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBlbXB0eUNvbXBvbmVudEZhY3RvcnkoaW5zdGFudGlhdGUpO1xuICB9XG59O1xuXG5SZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbiA9IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RmVhdHVyZUZsYWdzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEhvc3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBob3N0IHRhZ3MuXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgX2Fzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBob3N0IGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IF9wcm9kSW52YXJpYW50KCcxMTEnLCBlbGVtZW50LnR5cGUpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0ge1xuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEhvc3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NQ29udGFpbmVySW5mbyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db250YWluZXJJbmZvJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIG1hcmtlck5hbWU7XG4gIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcbiAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IG1vdW50OiAnICsgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSk7XG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cbiAgKTtcblxuICBpZiAobWFya2VyTmFtZSkge1xuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCB3cmFwcGVySW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi9cbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgc2FmZWx5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xuICB9XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoKCk7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGlmIChyb290RWwpIHtcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5faG9zdFBhcmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxuICogaXQgaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3RcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpICYmIChub2RlLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldkhvc3RJbnN0YW5jZSAmJiAhcHJldkhvc3RJbnN0YW5jZS5faG9zdFBhcmVudCA/IHByZXZIb3N0SW5zdGFuY2UgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhpcy5wcm9wcyBpcyBhY3R1YWxseSBhIFJlYWN0RWxlbWVudFxuICByZXR1cm4gdGhpcy5wcm9wcztcbn07XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcblxuICBUb3BMZXZlbFdyYXBwZXI6IFRvcExldmVsV3JhcHBlcixcblxuICAvKipcbiAgICogVXNlZCBieSBkZXZ0b29scy4gVGhlIGtleXMgYXJlIG5vdCBpbXBvcnRhbnQuXG4gICAqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS4gSG9va2VkIGJ5IGhvb2tzIVxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNycpIDogdm9pZCAwO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIGZhbHNlKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuXG4gICAgdmFyIHdyYXBwZXJJRCA9IGNvbXBvbmVudEluc3RhbmNlLl9pbnN0YW5jZS5yb290SUQ7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFt3cmFwcGVySURdID0gY29tcG9uZW50SW5zdGFuY2U7XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBSZWFjdEluc3RhbmNlTWFwLmhhcyhwYXJlbnRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzM4JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssICdSZWFjdERPTS5yZW5kZXInKTtcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0RWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG5leHRFbGVtZW50KTtcblxuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcztcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIGluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCByb290RWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChob3N0Tm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKGhvc3ROb2RlLl9kZWJ1Z0lELCAnbW91bnQnLCBtYXJrdXAudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vZGVUeXBlc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb2RlVHlwZXMgPSB7XG4gIEhPU1Q6IDAsXG4gIENPTVBPU0lURTogMSxcbiAgRU1QVFk6IDIsXG5cbiAgZ2V0VHlwZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkVNUFRZO1xuICAgIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkhPU1Q7XG4gICAgICB9XG4gICAgfVxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIG5vZGU6ICVzJywgbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMjYnLCBub2RlKSA6IHZvaWQgMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vZGVUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG4vKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuLyoqXG4gKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyIHdlIGRvbid0IHVzZSByZWFsXG4gKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gJyc7XG59XG4vLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG5Qcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICBpZiAoIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBub3Qgd29yayBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBZb3UgbWF5IGJlICcgKyAnc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgbGlicmFyeS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgZm9yIGRldGFpbHMuJywgcHJvcEZ1bGxOYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUmVxdWlyZWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCB3YXMgbm90IHNwZWNpZmllZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gQU5PTllNT1VTO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFZlcnNpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjMuMSc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBfcHJvZEludmFyaWFudCgnMzAnKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNoZWNrUmVhY3RUeXBlU3BlY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvckVhY2hBY2N1bXVsYXRlZFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xuXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KSB7XG4gIHZhciB0eXBlO1xuXG4gIHdoaWxlICgodHlwZSA9IGluc3QuX3JlbmRlcmVkTm9kZVR5cGUpID09PSBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEUpIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuSE9TVCkge1xuICAgIHJldHVybiBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuY29uc3RydWN0KGVsZW1lbnQpO1xufTtcbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQuTWl4aW4sIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBuZXh0RGVidWdJRCA9IDE7XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiB2b2lkIDA7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBuZXh0RGVidWdJRCsrIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzVGV4dElucHV0RWxlbWVudFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG5cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0VGV4dENvbnRlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIHNldElubmVySFRNTChub2RlLCBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUZXh0Q29udGVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tcG9zZTtcbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVzdCA9IGZ1bmNzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3QucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGNvbXBvc2VkLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZihjb21wb3NlZCk7XG4gICAgICAgICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjcmVhdGVTdG9yZTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtpbml0aWFsU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuaGFuY2VyIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gaW5pdGlhbFN0YXRlO1xuICAgIGluaXRpYWxTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG5cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jcmVhdGVTdG9yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQndnSEJna0lCd2dLQ2drTERSWVBEUXdNRFJzVUZSQVdJQjBpSWlBZEh4OGtLRFFzSkNZeEp4OGZMVDB0TVRVM09qbzZJeXMvUkQ4NFF6UTVPamNCQ2dvS0RRd05HZzhQR2pjbEh5VTNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTi8vQUFCRUlBRm9BV2dNQklnQUNFUUVERVFIL3hBQWNBQUFDQWdNQkFRQUFBQUFBQUFBQUFBQUdCd0FGQVFJRUF3ai94QUJERUFBQkFnVUFCd01JQndRTEFBQUFBQUFCQWdNQUJBVUdFUWNTSVRGQlVXRVRJbkVVRmpJemdaR2h3UWdWSTBKaXNmQlNZNkxSSmpSRFJGTnpkSUtTc3ZIL3hBQWJBUUFDQXdFQkFRQUFBQUFBQUFBQUFBQUNCQUVEQlFZQUIvL0VBQ2tSQUFJQ0FnRUNCUU1GQUFBQUFBQUFBQUFCQWdNRUVTRVNNUVVHRTFHaEZVRnhGQ0lqTW1ILzJnQU1Bd0VBQWhFREVRQS9BSEpFaVFLWHpkL20raGlRcHN1WjZ1enAxSlNUVC8zVnlTUGowQUpGcmVpc3RianVTazIxSmVWVm1jUXdnK2dqZXR3OGtwM21CRk53WHRkU1FxMktNM1I1QlIyVHRVOVlzYzB0alB6SFdPNjFOSHdibkJYcndkVFZxODVoUkx2ZWFsOGJrb1R1MmM4Yk9IT0QwaUZiYm12NmxrWUlYS05IVlZuc0t1RzlheE5MNHR5cXV3UjdobjhoR0RvZHRnOTV4MnByWCsyWnZiK1VNVXhvWXk3cjd2Y3NTUXZGYU0zSk1hMUN1MnV5QzAraUZQOEFhSXoxVHN6SGtaN1NKYlIxcDZWbExsa0Vla3VXSFpUQUhQVnhnK0FCaGpLanpVTThJVitwMzFQbmxFK21tVU5xM3BSYm5TcEVnK3B1YlI2MlRtQnFQTm5qczQrSWdpZ1B1Nng2ZmNKOHFaVXFuMWR2dk1WQ1c3cmlWRGRyWXhyRDQ4akhMWmwzVDRxUnRpOFVKWXJiWSt4ZlQ2dWRTUHZKUDdYNTlOMGJHRjRoVmxMUzRmc1ZUcmNRNmlSSWthSlVWVjAxNld0cWd6ZFZtOEZEQ082ak9DNHM3RXBIaWZuQS9vMHR1WmJRNWRGeER0YTlVeDJoS3gvVjJqdFMya0gwZG1Namh1NFJYM00zNTJhU2FYYnlnVlU2a0krc0owWTdxM0RqVVNmZVBZb3d5eHVoUEl0MCtsRnNJOEhvTVlnRzBwWDJMS3B6SGt6TGI5UW15UXkyNW5WU0J2VXJHM2lOa0cyWStkdnBFTFdiMWswRW5VVFRrRkk0YlhITW45Y29HRFVub2w4RFUwWTN5bTlhVSt0OWxERS9LS1NsOXR2T3FRYzZxazU0SEIyZElNVENCK2pvNDRtNUtvMk05bXFUQlVPb1dNZm1ZZnhqUHpZcU10SU9JQzZXcnVmdE8za3JrRkpUVUp0enNtRktTRmRtQU1xWGc3OERZT3BFRCtoMi9aKzRYNXFrMXQ4UHpUYU8yWWUxQWtyVG5Da25BQTJaQjlwNVJVL1NQU3Z0NkNyQjFOVjhBOWNvZ1gwSEJadjZYS053bDNTdncxZjU0aWYwOWJ3bTJ1ZE5udHZxUG84d01YMWF6Tnkwb0lRcnNhakxIdFpLYVNjS2FjRzBiZVJ4OCtFRThhSzNSeVN2blJZcklQVFJlMG53RHVqcTVYYmhvcWtWQWRuV0tlc3kwKzJjQWh4T3pXd05tM0hEWURrUVZiWVc5V0htdHBNcGxYYU9wSTEwZVJUZzNEdGRtb3J4T3orS0dSdDVIM1I5QXc4bU9UVEcxZmNTbkhwbG9BZEZ5ZkxxemQ5ZFdNcW1xbXBoQ3YzYmVRTWU4ZTZHR0RDNzBIa3Fza3JYNnhjODhwZmprUXdzeGo1RjM4MGkrSzROOHdyZE4xa3p0eHNTZFVvekhiemtva3RPTXA5Snhzbkl4eklPZG5Vd3pFUElXdFNFbkpRY0s2SGZIcG1QUXlYVzludWtXbWhXekoyMjZmT1Q5WGFMTTVPNnFVc0t4ck50cHp2NmtuZHd3SVpSakdZd1RDdVJrT3lUa3lVdEFucEt0QVhoUVBKRzNVdFRiS3c3THVMSGQxdHhCeHdJK1VVV2lyUjg5YVJtWjZxT3RPVDc2ZXpTbG81UzJqT2QvRWs0OTBNY3hvWVRzenJJMHVwZG1Fb3JlekVlWmlQT3BhUVZyT0VnWko1UmpJTVlkejQyV29DdEwwbXFZc2libUc4ZHZKT056TFN1S1NsUUJJOWhNRzFKbkdaK2xTYzRWSE13d2gwNC9Fa0g1d082UUFGV1RYTmJkNUU1K1VWdHBPdWkxYU1BUDdneHgvZHBqcmZMTmpsaXlUKzBtTFhyOXhwb25WNUk1YzFHVU5WVWpWbkNsSEpDL1JQOEpnK2NXVXRxVUJuQXpqbkM5bXo1c2FXVVREbmNrTGpsdzBWYmdKaEdNZThZL3dDVU1IT1JGZmlhOUhJMit6NUNyNWlWVnV1dU5TTXV4TjQ3ZGJmYmF3L3ROYnZLUGlGS09mWWVNWE90SEZOeWJjeXdHc3FiS01GcHhzNFUyb2JpbjlZTzQ1QklpdVhYQlNscFp1QW9sa0hZaWUzUzYraWlmVnE2SzJIZ1R3WDYzZHpEdjdCYTBYaE1ZalZLMHFTbFNWQlNWYlFRY2d4Q1lSc3RhNFpLUmt4b1RFSjZ4VlZDdVNrck1pVGFLcHFmVU83S1M0MW5CMVZ3UW44U2lCQ3VwMnZVRnNMc2RzMCtsaHNyVmxYQktSdlVlQUhXT0tocGVSVDB0ekFTRnRPT05nSk9RRXBVUWtEd0dCRzBuTFBxY0UxVVNnekJIZGJSdFF5RHZBNW5tcmp3d0k3QUFnYk9lWVV5TFlRZzZseS9jSklFOUswNzVIWWRVSTJyZVFsaElIRXJVQWZobUNXMzZReEowR215cmllK3hLTk5xMmNRZ0Q1UUUzai9BRWl2YTNyWWE3elRMdjFoUEFIMFVJOUVIeDJqL2NJWmV0MGp0dkwyTTZzRk9YZVhJcGZMY2djdjIyeGM5dk95YlMrem5XVkIrVGR6alVlVHUyOEFkM3RqanNDNS9PS2txUk5nTlZhU1YyRSt3ZGlrT0RabkhJNFB0eU9FRjhBbDZXdFBOMVZOMTJpRW9yTFNjVEV0OTJkYjRnL2l3QjQ0SEVDSC9FY0paVldsM1hZR3VmU3cwekdyamFIVUtiY1NsYUZEQ2txR1FSeUlnY3RHOEtmYzBzb002MHZQTTdKbVNlMk9OS0cvWnhIWDM0T3lDTE1jSGQ2bVBOd210TkRhMCt3TXZXWEtzcks2RlVLaFJWRTUxSkozN0VuL0FDbFpTUFppT2MwUzhVQW9idk5wU2VCZHBhQ3Iya0t4QmRtTVpndnF0eVhPbitVbWU5TkFvM2FWUm1jZlhsMTFTY1Q5NW1XMVpWQ3VoMU85ajJ4ZlV1bFNGSVlMRk5sR3Bac25XVUcwNDFqekozazlUSFlZd1RDZVI0aGZhdWx5NDlsd3ZnSlFTSkZWY3RjbExlbzh4VTU1WDJiUTdxQWRyaXVDUjFNUzRhL1RiZGtGVHRWbUV0TmpZaE85VGg1SkhFd0xXL1E2bGVsWVp1TzZaY3kxTGx6clUybHIzay80amcvV2VnRzEzd2p3aXpOc1ZrMXFDK2Y4UU50aWlpeTBZVVNiWlluTGtyU2NWYXRLRHFra1k3Rm5laEhUaDhCd2c1aWVNU1BwRVlxS1NRZzN0a2lSSWtFeUFUdXl3NmJYNWdWQ1hjZHBsWlJ0YnFFcDNWNXhnYTJNYTJ6QTU0NHhRaXJYdmF3N092VWNWeVNUdW5xYjZ6SDRtK2ZzQTZ3eVR2alBLRk1uRG95WTlOc2RoeG00OWdCa2RKOXFUUjFIcWd1VGU0dHpiS2tGUGljRWZHTFFYbmJCR1JYNmRqL1VKaStxTkxwOCswZkxwQ1ZtZGl2WE1wWHc2aUF0eTJhQUhnQlE2WmpsNUczL0FDakRuNVl4WlBpVFJlcjVIdFA2U2JTazlpcXcyOHJPeE11aFRoUHRBeDhZcnZPdTVyaSt6dEMzSG1XbGJQckNxL1pJVDFDZVBzejRRYlVPaVVtVGxFcmxLWEpNTEc1VFV1aEorQWkxenNQakYyUDVld3FkU2E2dnlCSytUQWUzOUhqTEUraXNYVE91VnlyREJTcDhaWlpPZnVJUEwvd0NEaUpFamZqRlJXa2lsdHZ1U0pFaVFSQi8vOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWdcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydCBjb25zdCBzZWxlY3RUdXJ0bGUgPSAodHVydGxlKSA9PiB7XG5cbiAgLy8gY29uc29sZS5sb2coXCJZb3UgY2xpY2tlZCBvbiB1c2VyOiBcIiwgXG4gIC8vIFx0dXNlci5maXJzdCArIFwiLCBcIiArIFxuICAvLyBcdHVzZXIuZGVzY3JpcHRpb25cbiAgLy8gKTtcbiAgcmV0dXJuIHtcbiAgXHR0eXBlOiBcIlRVUlRMRV9TRUxFQ1RFRFwiLFxuICBcdHBheWxvYWQ6IHR1cnRsZVxuICB9O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9hY3Rpb25zL3R1cnRsZS5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBzZWxlY3RVc2VyID0gKHVzZXIpID0+IHtcblxuICAvLyBjb25zb2xlLmxvZyhcIllvdSBjbGlja2VkIG9uIHVzZXI6IFwiLCBcbiAgLy8gXHR1c2VyLmZpcnN0ICsgXCIsIFwiICsgXG4gIC8vIFx0dXNlci5kZXNjcmlwdGlvblxuICAvLyApO1xuICByZXR1cm4ge1xuICBcdHR5cGU6IFwiVVNFUl9TRUxFQ1RFRFwiLFxuICBcdHBheWxvYWQ6IHVzZXJcbiAgfTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvYWN0aW9ucy91c2VyLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFR1cnRsZUxpc3QgZnJvbSAnLi4vY29udGFpbmVycy90dXJ0bGUtbGlzdCdcbmltcG9ydCBUdXJ0bGVEZXRhaWwgZnJvbSAnLi4vY29udGFpbmVycy90dXJ0bGUtZGV0YWlsJ1xuLy9yZXF1aXJlKCcuLi8uLi9zY3NzL3N0eWxlLnNjc3MnKTtcblxuY29uc3QgQ29tcFR1cnRsZSA9ICgpID0+IChcbiAgPGRpdj5cbiAgICA8aDM+TmluamEgVHVydGxlcyBMaXN0OjwvaDM+XG4gICAgPFR1cnRsZUxpc3QgLz5cbiAgICA8aHIgLz5cbiAgICA8aDM+QmlvOjwvaDM+XG4gICAgPFR1cnRsZURldGFpbCAvPlxuICA8L2Rpdj5cbik7XG5leHBvcnQgZGVmYXVsdCBDb21wVHVydGxlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgVXNlckxpc3QgZnJvbSAnLi4vY29udGFpbmVycy91c2VyLWxpc3QnXG5pbXBvcnQgVXNlckRldGFpbCBmcm9tICcuLi9jb250YWluZXJzL3VzZXItZGV0YWlsJ1xuLy9yZXF1aXJlKCcuLi8uLi9zY3NzL3N0eWxlLnNjc3MnKTtcblxuY29uc3QgQ29tcFVzZXIgPSAoKSA9PiAoXG4gICA8ZGl2PlxuICAgICA8aDM+SW5mbHVlbnRpYWwgUGVyc29ucyBMaXN0OjwvaDM+XG4gICAgIDxVc2VyTGlzdCAvPlxuICAgICA8aHIvPlxuICAgICA8aDM+QmlvOjwvaDM+XG4gICAgIDxVc2VyRGV0YWlsIC8+XG4gICA8L2Rpdj5cbik7XG5leHBvcnQgZGVmYXVsdCBDb21wVXNlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb21wb25lbnRzL2NvbXAtdXNlci5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBTbWlsZXlGYWNlIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL1NtaWxleUZhY2UuanBlZ1wiXG5cbi8vYWx0ZXJuYXRpdmUgY29kZVxuQGNvbm5lY3QoKHN0YXRlKSA9PiB7ICAgIFxuICByZXR1cm4geyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICB0dXJ0bGU6IHN0YXRlLmFjdGl2ZVR1cnRsZVxuICB9O1xufSlcblxuY2xhc3MgVHVydGxlRGV0YWlsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy50dXJ0bGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxoND5cbiAgICAgICAgICAgUGxhY2UgdGhlIGN1cnNvciBvdmVyIHlvdXIgZmF2b3JpdGUgTmluamEgYW5kIGNsaWNrLi4uXG4gICAgICAgIDwvaDQ+KTtcbiAgICB9XG4gIFx0cmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxpbWcgY2xhc3M9XCJpbWctcmVzcG9uc2l2ZVwiIHNyYz17dGhpcy5wcm9wcy50dXJ0bGUuaW1hZ2V9IHdpZHRoPVwiMjUwXCIgYWx0PXtTbWlsZXlGYWNlfSAvPlxuICAgICAgICA8ZW0+XG4gICAgICAgICAgPGg0Pnt0aGlzLnByb3BzLnR1cnRsZS5uYW1lfSBha2EgXCJ7dGhpcy5wcm9wcy50dXJ0bGUuYWthfVwiPC9oND5cbiAgICAgICAgICA8aDQ+QWdlOiB7dGhpcy5wcm9wcy50dXJ0bGUuYWdlfT88L2g0PlxuICAgICAgICAgIDxoND5EZXNjcmlwdGlvbjoge3RoaXMucHJvcHMudHVydGxlLmRlc2NyaXB0aW9ufTwvaDQ+XG4gICAgICAgICAgPGg1PihJbWFnZXMgYW5kIGRlc2NyaXB0aW9ucyBjb3VydGVzeSBvZiBXaWtpcGVkaWEpPC9oNT5cbiAgICAgICAgPC9lbT5cbiAgICAgIDwvZGl2PlxuICBcdCk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFR1cnRsZURldGFpbDtcbi8vIGZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSkge1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHR1cnRsZTogc3RhdGUuYWN0aXZlVHVydGxlXG4vLyAgIH07XG4vLyB9XG4vLyBleHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcykoVHVydGxlRGV0YWlsKTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb250YWluZXJzL3R1cnRsZS1kZXRhaWwuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBiaW5kQWN0aW9uQ3JlYXRvcnMgfSBmcm9tICdyZWR1eCdcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCB7IHNlbGVjdFR1cnRsZSB9IGZyb20gJy4uL2FjdGlvbnMvdHVydGxlJ1xuXG5jbGFzcyBUdXJ0bGVMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY3JlYXRlTGlzdEl0ZW1zKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnByb3BzLnR1cnRsZXMubWFwKHR1cnRsZSA9PiB7XG4gIFx0ICAgIHJldHVybiAoICAgXG4gICAgICAgICAgICA8bGkga2V5PXt0dXJ0bGUuaWR9IG9uQ2xpY2s9eygpID0+IHRoaXMucHJvcHMuc2VsZWN0VHVydGxlKHR1cnRsZSl9ID4gXG4gICAgICAgICAgICB7dHVydGxlLm5hbWV9IFxuICAgICAgICAgICAgPC9saT4gICAgIFxuICBcdCAgICApO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgXHRyZXR1cm4gKFxuICAgICAgPGg0PlxuICAgICAgICA8dWw+XG4gICAgICAgICAge3RoaXMuY3JlYXRlTGlzdEl0ZW1zKCl9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2g0PlxuICBcdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSkge1xuICByZXR1cm4ge1xuICAgIHR1cnRsZXM6IHN0YXRlLnR1cnRsZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hdGNoRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKSB7XG4gIHJldHVybiAoXG4gICAgYmluZEFjdGlvbkNyZWF0b3JzKHtzZWxlY3RUdXJ0bGU6IHNlbGVjdFR1cnRsZX0sIGRpc3BhdGNoKVxuICApO1xufVxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hdGNoRGlzcGF0Y2hUb1Byb3BzKShUdXJ0bGVMaXN0KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbnRhaW5lcnMvdHVydGxlLWxpc3QuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnXG5pbXBvcnQgU21pbGV5RmFjZSBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWdcIlxuXG4vL2FsdGVybmF0aXZlIGNvZGVcbkBjb25uZWN0KChzdGF0ZSkgPT4geyAgICBcbiAgcmV0dXJuIHsgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgdXNlcjogc3RhdGUuYWN0aXZlVXNlclxuICB9O1xufSlcblxuY2xhc3MgVXNlckRldGFpbCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMudXNlcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGg0PlxuICAgICAgICAgIFBsYWNlIHRoZSBjdXJzb3Igb3ZlciB5b3VyIGZhdm9yaXRlIGZhbW91cyBwZXJzb24gYW5kIHNlbGVjdC4uLlxuICAgICAgICA8L2g0Pik7XG4gICAgfVxuICBcdHJldHVybiAoXG4gICAgICA8ZGl2PlxuICAgICAgICA8aW1nIGNsYXNzPVwiaW1nLXJlc3BvbnNpdmVcIiBzcmM9e3RoaXMucHJvcHMudXNlci5pbWFnZX0gd2lkdGg9XCIzMDBcIiBhbHQ9e1NtaWxleUZhY2V9IC8+XG4gICAgICAgIDxlbT5cbiAgICAgICAgICAgPGg0Pnt0aGlzLnByb3BzLnVzZXIubmFtZX0ge3RoaXMucHJvcHMudXNlci5sYXN0fTwvaDQ+XG4gICAgICAgICAgIDxoND5Cb3JuOiB7dGhpcy5wcm9wcy51c2VyLmJvcm59PC9oND5cbiAgICAgICAgICAgPGg0PldvdWxkIGhhdmUgYmVlbiB7dGhpcy5wcm9wcy51c2VyLmFnZX0geXJzLiBvbGQgbm93LCBpZiB3ZXJlIHN0aWxsIGFsaXZlLjwvaDQ+XG4gICAgICAgICAgIDxoND5EZXNjcmlwdGlvbjoge3RoaXMucHJvcHMudXNlci5kZXNjcmlwdGlvbn08L2g0PlxuICAgICAgICAgICA8aDU+KFBob3RvcyBhbmQgZGVzY3JpcHRpb25zIGNvdXJ0ZXN5IG9mIFdpa2lwZWRpYSk8L2g1PlxuICAgICAgICA8L2VtPlxuICAgICAgPC9kaXY+XG4gIFx0KTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVXNlckRldGFpbDtcblxuLy8gZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdXNlcjogc3RhdGUuYWN0aXZlVXNlclxuLy8gICB9O1xuLy8gfVxuLy8gZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKFVzZXJEZXRhaWwpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvY29udGFpbmVycy91c2VyLWRldGFpbC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IHsgc2VsZWN0VXNlciB9IGZyb20gJy4uL2FjdGlvbnMvdXNlcidcbi8vIGltcG9ydCBzdG9yZSBmcm9tICcuLi9zdG9yZSdcblxuLy8gc3RvcmUuc3Vic2NyaWJlKCAoKSA9PiB7XG4vLyBjb25zb2xlLmxvZyhcIlN0b3JlIGNoYW5nZWRcIiwgc3RvcmUuZ2V0U3RhdGUoKSlcbi8vIH0pO1xuLy8gLy9iZWxvdyBzbmlwcGV0IGlzIGEgc2FtcGxlIG9mIGhvdyB0byBhZGQgYSBzdGF0ZSBpbnRvIHRoZSBjb2RlXG4vLyAvL2J1dCBzaG91bGQgYmUgbWF0Y2hlZCBieSBhIGNvcnJlc3BvbmRpbmcgcmVkdWNlciBmdW5jdGlvbiB0byByZWNvcmQgYW5kIHVwZGF0ZSB0aGlzIG5ldyBzdGF0ZVxuLy8gc3RvcmUuZGlzcGF0Y2goe3R5cGU6IFwiQUREX1VTRVJfTkFNRVwiLCBwYXlsb2FkOiBcIlJvZFwifSlcbi8vIHN0b3JlLmRpc3BhdGNoKHt0eXBlOiBcIkFERF9VU0VSX0FHRVwiLCBwYXlsb2FkOiAyM30pXG5cbmNsYXNzIFVzZXJMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY3JlYXRlTGlzdEl0ZW1zKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnByb3BzLnVzZXJzLm1hcCh1c2VyID0+IHtcbiAgXHQgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsaSBrZXk9e3VzZXIuaWR9IG9uQ2xpY2s9eygpID0+IHRoaXMucHJvcHMuc2VsZWN0VXNlcih1c2VyKX0gPiBcbiAgICAgICAgICAgICAge3VzZXIubmFtZX0ge3VzZXIubGFzdH1cbiAgICAgICAgICAgIDwvbGk+XG4gIFx0ICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICBcdHJldHVybiAoXG4gICAgICA8aDQ+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7dGhpcy5jcmVhdGVMaXN0SXRlbXMoKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvaDQ+XG4gIFx0KTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdXNlcnM6IHN0YXRlLnVzZXJzXG4gIH07XG59XG5mdW5jdGlvbiBtYXRjaERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4gKFxuICAgIGJpbmRBY3Rpb25DcmVhdG9ycyh7c2VsZWN0VXNlcjogc2VsZWN0VXNlcn0sIGRpc3BhdGNoKVxuICApO1xufVxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hdGNoRGlzcGF0Y2hUb1Byb3BzKShVc2VyTGlzdCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb250YWluZXJzL3VzZXItbGlzdC5qc1xuICoqLyIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IHN5bmNIaXN0b3J5V2l0aFN0b3JlLCByb3V0ZXJSZWR1Y2VyIH0gZnJvbSAncmVhY3Qtcm91dGVyLXJlZHV4JztcbmltcG9ydCBSZWR1Y2VyVXNlcnMgZnJvbSAnLi9yZWR1Y2VyLXVzZXJzJztcbmltcG9ydCBSZWR1Y2VyVHVydGxlcyBmcm9tICcuL3JlZHVjZXItdHVydGxlcyc7XG5pbXBvcnQgQWN0aXZlVXNlclJlZHVjZXIgZnJvbSAnLi9yZWR1Y2VyLWFjdGl2ZS11c2VyJztcbmltcG9ydCBBY3RpdmVUdXJ0bGVSZWR1Y2VyIGZyb20gJy4vcmVkdWNlci1hY3RpdmUtdHVydGxlJztcblxuY29uc3QgYWxsUmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoe1xuICB1c2VyczogUmVkdWNlclVzZXJzLFxuICB0dXJ0bGVzOiBSZWR1Y2VyVHVydGxlcyxcbiAgYWN0aXZlVXNlcjogQWN0aXZlVXNlclJlZHVjZXIsXG4gIGFjdGl2ZVR1cnRsZTogQWN0aXZlVHVydGxlUmVkdWNlcixcbiAgcm91dGluZzogcm91dGVyUmVkdWNlclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFsbFJlZHVjZXJzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL2luZGV4LmpzXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlPW51bGwsIGFjdGlvbikge1xuXG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIFxuICBcdGNhc2UgXCJUVVJUTEVfU0VMRUNURURcIjpcbiAgXHQgIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbiAgXHQgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn0gIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItYWN0aXZlLXR1cnRsZS5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdGF0ZT1udWxsLCBhY3Rpb24pIHtcblxuICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICBcbiAgXHRjYXNlIFwiVVNFUl9TRUxFQ1RFRFwiOlxuICBcdCAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xuICBcdCAgYnJlYWs7XG4gIFx0Y2FzZSBcIkFERF9VU0VSX05BTUVcIjpcbiAgXHQgIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbiAgXHQgIGJyZWFrO1xuICBcdGNhc2UgXCJBRERfVVNFUl9BR0VcIjpcbiAgXHQgIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbiAgXHQgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn0gIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItYWN0aXZlLXVzZXIuanNcbiAqKi8iLCJpbXBvcnQgTGVvbmFyZG8gZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvbGVvbmFyZG8ucG5nXCJcbmltcG9ydCBNaWNoYWVsYW5nZWxvIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL21pY2hhZWxhbmdlbG8ucG5nXCJcbmltcG9ydCBEb25hdGVsbG8gZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvZG9uYXRlbGxvLnBuZ1wiXG5pbXBvcnQgUmFwaGFlbCBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9yYXBoYWVsLnBuZ1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogXCJMZW9uYXJkb1wiLFxuICAgICAgYWthOiBcIkxlb1wiLFxuICAgICAgYWdlOiAxNyxcbiAgICAgIGltYWdlOiBMZW9uYXJkbyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxlb25hcmRvIGlzIHRoZSBjb29sLCBjb3VyYWdlb3VzIGxlYWRlciBvZiB0aGUgTmluamEgVHVydGxlcyBhbmQgYSBkZXZvdGVkIHN0dWRlbnQgb2YgTmluanV0c3UsIHVzdWFsbHkgd2VhcmluZyBhIGJsdWUgbWFzayBhbmQgd2llbGRpbmcgdHdvIGthdGFuYXMuIExlYWRlciBpbiBibHVlLlwiIFxuICAgIH0sXG4gICAge1xuICBcdCAgaWQ6IDIsXG4gICAgICBuYW1lOiBcIk1pY2hhZWxhbmdlbG9cIixcbiAgICAgIGFrYTogXCJNaWNrZXlcIixcbiAgICAgIGFnZTogMTcsXG4gICAgICBpbWFnZTogTWljaGFlbGFuZ2VsbyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk1pY2hlbGFuZ2VsbyBpcyB0aGUgbW9zdCBjb21pY2FsIG9mIHRoZSBOaW5qYSBUdXJ0bGVzLCB1c3VhbGx5IHdlYXJpbmcgYW4gb3JhbmdlIG1hc2sgYW5kIHdpZWxkaW5nIGEgcGFpciBvZiBudW5jaHVja3MuXCJcbiAgICB9LFxuICAgIHtcbiAgXHQgIGlkOiAzLFxuICAgICAgbmFtZTogXCJEb25hdGVsbG9cIixcbiAgICAgIGFrYTogXCJEb25uaWVcIixcbiAgICAgIGFnZTogMTYsXG4gICAgICBpbWFnZTogRG9uYXRlbGxvLFxuICAgICAgZGVzY3JpcHRpb246IFwiRG9uYXRlbGxvIGlzIHRoZSBzY2llbnRpc3QsIGludmVudG9yLCBlbmdpbmVlciBhbmQgdGVjaG5vbG9naWNhbCBnZW5pdXMgb2YgdGhlIE5pbmphIFR1cnRsZXMsIHVzdWFsbHkgd2VhcmluZyBhIHB1cnBsZSBtYXNrIGFuZCB3aWVsZGluZyBhIGJvLXN0YWZmLlwiXG4gICAgIH0sXG4gICAgIHtcbiAgICAgIGlkOiA0LFxuICAgICAgbmFtZTogXCJSYXBoYWVsXCIsXG4gICAgICBha2E6IFwiUmFwaFwiLFxuICAgICAgYWdlOiAxOCxcbiAgICAgIGltYWdlOiBSYXBoYWVsLFxuICAgICAgZGVzY3JpcHRpb246IFwiUmFwaGFlbCBpcyB0aGUgYmFkIGJveSBvZiB0aGUgTmluamEgVHVydGxlcywgd2VhcmluZyBhIHJlZCBtYXNrIGFuZCB3aWVsZGluZyBhIHBhaXIgb2Ygc2Fpcy5cIlxuICAgICB9XG4gIF1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci10dXJ0bGVzLmpzXG4gKiovIiwiaW1wb3J0IGRhVmluY2kgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvZGFWaW5jaS5qcGdcIlxuaW1wb3J0IEVpbnN0ZWluIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL0VpbnN0ZWluLmpwZ1wiXG5pbXBvcnQgRXVsZXIgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvRXVsZXIuanBnXCJcbmltcG9ydCBMZW1haXRyZSBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9MZW1haXRyZS5qcGdcIlxuaW1wb3J0IE1UZXJlc2EgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvTVRlcmVzYS5qcGdcIlxuaW1wb3J0IE5ld3RvbiBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9OZXd0b24uanBnXCJcbmltcG9ydCBTY2hyb2VkaW5nZXIgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvU2Nocm9lZGluZ2VyLmpwZ1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogXCJMZW9uYXJkb1wiLFxuICAgICAgbGFzdDogXCJEYSBWaW5jaVwiLFxuICAgICAgYm9ybjogXCJBcHJpbCAxNSwgMTQ1MlwiLFxuICAgICAgYWdlOiA1NjQsXG4gICAgICBpbWFnZTogZGFWaW5jaSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxlb25hcmRvIGRpIHNlciBQaWVybyBkYSBWaW5jaSwgbW9yZSBjb21tb25seSBMZW9uYXJkbyBhIFZpbmNpIG9yIHNpbXBseSBMZW9uYXJkbywgd2FzIGFuIEl0YWxpYW4gcG9seW1hdGggd2hvc2UgYXJlYXMgb2YgaW50ZXJlc3QgaW5jbHVkZWQgaW52ZW50aW9uLCBwYWludGluZywgc2N1bHB0aW5nLCBhcmNoaXRlY3R1cmUsIHNjaWVuY2UsIG11c2ljLCBtYXRoZW1hdGljcywgZW5naW5lZXJpbmcsIGxpdGVyYXR1cmUsIGFuYXRvbXksIGdlb2xvZ3ksIGFzdHJvbm9teSwgYm90YW55LCB3cml0aW5nLCBoaXN0b3J5LCBhbmQgY2FydG9ncmFwaHkuIEhlIGhhcyBiZWVuIHZhcmlvdXNseSBjYWxsZWQgdGhlIGZhdGhlciBvZiBwYWxhZW9udG9sb2d5LCBpY2hub2xvZ3ksIGFuZCBhcmNoaXRlY3R1cmUsIGFuZCBpcyB3aWRlbHkgY29uc2lkZXJlZCBvbmUgb2YgdGhlIGdyZWF0ZXN0IHBhaW50ZXJzIG9mIGFsbCB0aW1lLiBTb21ldGltZXMgY3JlZGl0ZWQgd2l0aCB0aGUgaW52ZW50aW9ucyBvZiB0aGUgcGFyYWNodXRlLCBoZWxpY29wdGVyIGFuZCB0YW5rLCBoZSBlcGl0b21pc2VkIHRoZSBSZW5haXNzYW5jZSBodW1hbmlzdCBpZGVhbC5cIlxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDIsXG4gICAgICBuYW1lOiBcIklzYWFjXCIsXG4gICAgICBsYXN0OiBcIk5ld3RvblwiLFxuICAgICAgYm9ybjogXCJKYW51YXJ5IDQsIDE2NDNcIixcbiAgICAgIGFnZTogMzczLFxuICAgICAgaW1hZ2U6IE5ld3RvbixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlNpciBJc2FhYyBOZXd0b24gd2FzIGFuIEVuZ2xpc2ggcGh5c2ljaXN0IGFuZCBtYXRoZW1hdGljaWFuIChkZXNjcmliZWQgaW4gaGlzIG93biBkYXkgYXMgYSBcXFwibmF0dXJhbCBwaGlsb3NvcGhlclxcXCIpIHdobyBpcyB3aWRlbHkgcmVjb2duaXNlZCBhcyBvbmUgb2YgdGhlIG1vc3QgaW5mbHVlbnRpYWwgc2NpZW50aXN0cyBvZiBhbGwgdGltZSBhbmQgYSBrZXkgZmlndXJlIGluIHRoZSBzY2llbnRpZmljIHJldm9sdXRpb24uIEhpcyBib29rIFBoaWxvc29waGnDpiBOYXR1cmFsaXMgUHJpbmNpcGlhIE1hdGhlbWF0aWNhIChcXFwiTWF0aGVtYXRpY2FsIFByaW5jaXBsZXMgb2YgTmF0dXJhbCBQaGlsb3NvcGh5XFxcIiksIGZpcnN0IHB1Ymxpc2hlZCBpbiAxNjg3LCBsYWlkIHRoZSBmb3VuZGF0aW9ucyBmb3IgY2xhc3NpY2FsIG1lY2hhbmljcy4gTmV3dG9uIG1hZGUgc2VtaW5hbCBjb250cmlidXRpb25zIHRvIG9wdGljcywgYW5kIGhlIHNoYXJlcyBjcmVkaXQgd2l0aCBHb3R0ZnJpZWQgV2lsaGVsbSBMZWlibml6IGZvciB0aGUgZGV2ZWxvcG1lbnQgb2YgY2FsY3VsdXMuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAzLFxuICAgICAgbmFtZTogXCJMZW9uaGFyZFwiLFxuICAgICAgbGFzdDogXCJFdWxlclwiLFxuICAgICAgYm9ybjogXCJBcHJpbCAxNSwgMTcwN1wiLFxuICAgICAgYWdlOiAzMDksXG4gICAgICBpbWFnZTogRXVsZXIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJMZW9uaGFyZCBFdWxlciB3YXMgYSBTd2lzcyBtYXRoZW1hdGljaWFuLCBwaHlzaWNpc3QsIGFzdHJvbm9tZXIsIGxvZ2ljaWFuIGFuZCBlbmdpbmVlciB3aG8gbWFkZSBpbXBvcnRhbnQgYW5kIGluZmx1ZW50aWFsIGRpc2NvdmVyaWVzIGluIG1hbnkgYnJhbmNoZXMgb2YgbWF0aGVtYXRpY3MgbGlrZSBpbmZpbml0ZXNpbWFsIGNhbGN1bHVzIGFuZCBncmFwaCB0aGVvcnkgd2hpbGUgYWxzbyBtYWtpbmcgcGlvbmVlcmluZyBjb250cmlidXRpb25zIHRvIHNldmVyYWwgYnJhbmNoZXMgc3VjaCBhcyB0b3BvbG9neSBhbmQgYW5hbHl0aWMgbnVtYmVyIHRoZW9yeS4gSGUgYWxzbyBpbnRyb2R1Y2VkIG11Y2ggb2YgdGhlIG1vZGVybiBtYXRoZW1hdGljYWwgdGVybWlub2xvZ3kgYW5kIG5vdGF0aW9uLCBwYXJ0aWN1bGFybHkgZm9yIG1hdGhlbWF0aWNhbCBhbmFseXNpcywgc3VjaCBhcyB0aGUgbm90aW9uIG9mIGEgbWF0aGVtYXRpY2FsIGZ1bmN0aW9uLiAgSGUgaXMgYWxzbyBrbm93biBmb3IgaGlzIHdvcmsgaW4gbWVjaGFuaWNzLCBmbHVpZCBkeW5hbWljcywgb3B0aWNzLCBhc3Ryb25vbXksIGFuZCBtdXNpYyB0aGVvcnkuXCJcbiAgICB9LCAgXG4gICAge1xuICAgICAgaWQ6IDQsXG4gICAgICBuYW1lOiBcIkFsYmVydFwiLFxuICAgICAgbGFzdDogXCJFaW5zdGVpblwiLFxuICAgICAgYm9ybjogXCJNYXJjaCAxNCwgMTg3OVwiLFxuICAgICAgYWdlOiAxMzcsXG4gICAgICBpbWFnZTogRWluc3RlaW4sXG4gICAgICBkZXNjcmlwdGlvbjogXCJBbGJlcnQgRWluc3RlaW4gd2FzIGEgR2VybWFuLWJvcm4gdGhlb3JldGljYWwgcGh5c2ljaXN0LiBIZSBkZXZlbG9wZWQgdGhlIGdlbmVyYWwgdGhlb3J5IG9mIHJlbGF0aXZpdHksIG9uZSBvZiB0aGUgdHdvIHBpbGxhcnMgb2YgbW9kZXJuIHBoeXNpY3MgKGFsb25nc2lkZSBxdWFudHVtIG1lY2hhbmljcykuICBFaW5zdGVpbidzIHdvcmsgaXMgYWxzbyBrbm93biBmb3IgaXRzIGluZmx1ZW5jZSBvbiB0aGUgcGhpbG9zb3BoeSBvZiBzY2llbmNlLiAgRWluc3RlaW4gaXMgYmVzdCBrbm93biBpbiBwb3B1bGFyIGN1bHR1cmUgZm9yIGhpcyBtYXNz4oCTZW5lcmd5IGVxdWl2YWxlbmNlIGZvcm11bGEgRSA9IG1jMiAod2hpY2ggaGFzIGJlZW4gZHViYmVkIFxcXCJ0aGUgd29ybGQncyBtb3N0IGZhbW91cyBlcXVhdGlvblxcXCIpLiAgSGUgcmVjZWl2ZWQgdGhlIDE5MjEgTm9iZWwgUHJpemUgaW4gUGh5c2ljcyBmb3IgaGlzIFxcXCJzZXJ2aWNlcyB0byB0aGVvcmV0aWNhbCBwaHlzaWNzXFxcIiwgaW4gcGFydGljdWxhciBoaXMgZGlzY292ZXJ5IG9mIHRoZSBsYXcgb2YgdGhlIHBob3RvZWxlY3RyaWMgZWZmZWN0LCBhIHBpdm90YWwgc3RlcCBpbiB0aGUgZXZvbHV0aW9uIG9mIHF1YW50dW0gdGhlb3J5LlwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNSxcbiAgICAgIG5hbWU6IFwiRXJ3aW5cIixcbiAgICAgIGxhc3Q6IFwiU2Nocm9lZGluZ2VyXCIsXG4gICAgICBib3JuOiBcIkF1Z3VzdCAxMiwgMTg4N1wiLFxuICAgICAgYWdlOiAxMjksXG4gICAgICBpbWFnZTogU2Nocm9lZGluZ2VyLFxuICAgICAgZGVzY3JpcHRpb246IFwiRXJ3aW4gUnVkb2xmIEpvc2VmIEFsZXhhbmRlciBTY2hyw7ZkaW5nZXIsIHNvbWV0aW1lcyB3cml0dGVuIGFzIEVyd2luIFNjaHJvZGluZ2VyIG9yIEVyd2luIFNjaHJvZWRpbmdlciwgd2FzIGEgTm9iZWwgUHJpemUtd2lubmluZyBBdXN0cmlhbiBwaHlzaWNpc3Qgd2hvIGRldmVsb3BlZCBhIG51bWJlciBvZiBmdW5kYW1lbnRhbCByZXN1bHRzIGluIHRoZSBmaWVsZCBvZiBxdWFudHVtIHRoZW9yeSwgd2hpY2ggZm9ybWVkIHRoZSBiYXNpcyBvZiB3YXZlIG1lY2hhbmljczogaGUgZm9ybXVsYXRlZCB0aGUgd2F2ZSBlcXVhdGlvbiAoc3RhdGlvbmFyeSBhbmQgdGltZS1kZXBlbmRlbnQgU2NocsO2ZGluZ2VyIGVxdWF0aW9uKSBhbmQgcmV2ZWFsZWQgdGhlIGlkZW50aXR5IG9mIGhpcyBkZXZlbG9wbWVudCBvZiB0aGUgZm9ybWFsaXNtIGFuZCBtYXRyaXggbWVjaGFuaWNzLiBTY2hyw7ZkaW5nZXIgcHJvcG9zZWQgYW4gb3JpZ2luYWwgaW50ZXJwcmV0YXRpb24gb2YgdGhlIHBoeXNpY2FsIG1lYW5pbmcgb2YgdGhlIHdhdmUgZnVuY3Rpb24uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA2LFxuICAgICAgbmFtZTogXCJHZW9yZ2VzXCIsXG4gICAgICBsYXN0OiBcIkxlbWFpdHJlXCIsXG4gICAgICBib3JuOiBcIkp1bHkgMTcsIDE4OTRcIixcbiAgICAgIGltYWdlOiBMZW1haXRyZSxcbiAgICAgIGFnZTogMTIyLFxuICAgICAgZGVzY3JpcHRpb246IFwiR2VvcmdlcyBIZW5yaSBKb3NlcGggw4lkb3VhcmQgTGVtYcOudHJlIHdhcyBhIEJlbGdpYW4gcHJpZXN0LCBhc3Ryb25vbWVyIGFuZCBwcm9mZXNzb3Igb2YgcGh5c2ljcyBhdCB0aGUgQ2F0aG9saWMgVW5pdmVyc2l0eSBvZiBMZXV2ZW4uICBIZSBwcm9wb3NlZCB0aGUgdGhlb3J5IG9mIHRoZSBleHBhbnNpb24gb2YgdGhlIHVuaXZlcnNlLCB3aWRlbHkgbWlzYXR0cmlidXRlZCB0byBFZHdpbiBIdWJibGUuICBIZSB3YXMgdGhlIGZpcnN0IHRvIGRlcml2ZSB3aGF0IGlzIG5vdyBrbm93biBhcyBIdWJibGUncyBsYXcgYW5kIG1hZGUgdGhlIGZpcnN0IGVzdGltYXRpb24gb2Ygd2hhdCBpcyBub3cgY2FsbGVkIHRoZSBIdWJibGUgY29uc3RhbnQsIHdoaWNoIGhlIHB1Ymxpc2hlZCBpbiAxOTI3LCB0d28geWVhcnMgYmVmb3JlIEh1YmJsZSdzIGFydGljbGUuICBMZW1hw650cmUgYWxzbyBwcm9wb3NlZCB3aGF0IGJlY2FtZSBrbm93biBhcyB0aGUgQmlnIEJhbmcgdGhlb3J5IG9mIHRoZSBvcmlnaW4gb2YgdGhlIHVuaXZlcnNlLCB3aGljaCBoZSBjYWxsZWQgaGlzIFxcXCJoeXBvdGhlc2lzIG9mIHRoZSBwcmltZXZhbCBhdG9tXFxcIiBvciB0aGUgXFxcIkNvc21pYyBFZ2dcXFwiLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNyxcbiAgICAgIG5hbWU6IFwiTW90aGVyXCIsXG4gICAgICBsYXN0OiBcIlRlcmVzYVwiLFxuICAgICAgYm9ybjogXCJBdWd1c3QgMjYsIDE5MTBcIixcbiAgICAgIGFnZTogMTA2LFxuICAgICAgaW1hZ2U6IE1UZXJlc2EsXG4gICAgICBkZXNjcmlwdGlvbjogXCJNb3RoZXIgVGVyZXNhIE1DLCBrbm93biBpbiB0aGUgQ2F0aG9saWMgQ2h1cmNoIGFzIFNhaW50IFRlcmVzYSBvZiBDYWxjdXR0YSB3YXMgYW4gQWxiYW5pYW4tSW5kaWFuIFJvbWFuIENhdGhvbGljIG51biBhbmQgbWlzc2lvbmFyeS4gIFNoZSB3YXMgYm9ybiBpbiBTa29wamUgKG5vdyBjYXBpdGFsIG9mIHRoZSBSZXB1YmxpYyBvZiBNYWNlZG9uaWEpLCB0aGVuIHBhcnQgb2YgdGhlIEtvc292byBWaWxheWV0IGluIHRoZSBPdHRvbWFuIEVtcGlyZS4gQWZ0ZXIgaGF2aW5nIGxpdmVkIGluIE1hY2Vkb25pYSBmb3IgZWlnaHRlZW4geWVhcnMsIHNoZSBtb3ZlZCB0byBJcmVsYW5kIGFuZCB0aGVuIHRvIEluZGlhLCB3aGVyZSBzaGUgbGl2ZWQgZm9yIG1vc3Qgb2YgaGVyIGxpZmUuICBJbiAxOTUwLCBUZXJlc2EgZm91bmRlZCB0aGUgTWlzc2lvbmFyaWVzIG9mIENoYXJpdHksIGEgUm9tYW4gQ2F0aG9saWMgcmVsaWdpb3VzIGNvbmdyZWdhdGlvbiwgd2hpY2ggaW4gMjAxMiBjb25zaXN0ZWQgb2Ygb3ZlciA0LDUwMCBzaXN0ZXJzIGFuZCB3YXMgYWN0aXZlIGluIDEzMyBjb3VudHJpZXMuIFRoZXkgcnVuIGhvbWVzIGZvciBwZW9wbGUgZHlpbmcgb2YgSElWL0FJRFMsIGxlcHJvc3kgYW5kIHR1YmVyY3Vsb3Npczsgc291cCBraXRjaGVuczsgZGlzcGVuc2FyaWVzIGFuZCBtb2JpbGUgY2xpbmljczsgY2hpbGRyZW4ncyBhbmQgZmFtaWx5IGNvdW5zZWxsaW5nIHByb2dyYW1tZXM7IG9ycGhhbmFnZXM7IGFuZCBzY2hvb2xzLiBNZW1iZXJzIG11c3QgYWRoZXJlIHRvIHRoZSB2b3dzIG9mIGNoYXN0aXR5LCBwb3ZlcnR5LCBhbmQgb2JlZGllbmNlLCBhcyB3ZWxsIGFzIGEgZm91cnRoIHZvdywgdG8gZ2l2ZSBcXFwid2hvbGVoZWFydGVkIGZyZWUgc2VydmljZSB0byB0aGUgcG9vcmVzdCBvZiB0aGUgcG9vci5cXFwiXCJcbiAgICB9LFxuXG4gIF1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci11c2Vycy5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFJvdXRlciwgUm91dGUsIEluZGV4Um91dGUsIGJyb3dzZXJIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuaW1wb3J0IHsgc3luY0hpc3RvcnlXaXRoU3RvcmUsIHJvdXRlclJlZHVjZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItcmVkdXgnXG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuL2NvbnRhaW5lcidcbmltcG9ydCB7IEhvbWUgfSBmcm9tICcuL2hvbWUnXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi91c2VyJ1xuaW1wb3J0IHsgVHVydGxlcyB9IGZyb20gJy4vdHVydGxlcydcbmltcG9ydCB7IE5vdEZvdW5kIH0gZnJvbSAnLi9ub3Rmb3VuZCdcbmltcG9ydCBzdG9yZSBmcm9tICcuLi9kZXYvanMvc3RvcmUnXG5cbmNvbnN0IGhpc3RvcnkgPSBzeW5jSGlzdG9yeVdpdGhTdG9yZShicm93c2VySGlzdG9yeSwgc3RvcmUpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxSb3V0ZXIgaGlzdG9yeT17aGlzdG9yeX0+XG4gICAgICAgIDxSb3V0ZSBwYXRoPScvJyBjb21wb25lbnQ9e0NvbnRhaW5lcn0+XG5cbiAgICAgICAgICA8SW5kZXhSb3V0ZSBjb21wb25lbnQ9e0hvbWV9IC8+XG4gICAgICAgICAgPFJvdXRlIHBhdGg9J3VzZXInIGNvbXBvbmVudD17VXNlcn0gLz4gIFxuICAgICAgICAgIDxSb3V0ZSBwYXRoPSd0dXJ0bGVzKC86bmFtZSknIGNvbXBvbmVudD17VHVydGxlc30gLz5cbiAgICAgICAgICA8Um91dGUgcGF0aD0nKicgY29tcG9uZW50PXtOb3RGb3VuZH0gLz5cblxuICAgICAgICA8L1JvdXRlPlxuICAgICAgPC9Sb3V0ZXI+XG4gICAgKVxuICB9XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvYXBwLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgSW5kZXhMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuXG52YXIgbXlTdHlsZSA9IHtcbiAgICBmb250RmFtaWx5OiAnRG9zaXMnXG4gIH1cblxuZXhwb3J0IGNvbnN0IENvbnRhaW5lciA9IChwcm9wcykgPT4gKFxuICA8ZGl2IHN0eWxlPXtteVN0eWxlfT5cbiAgICA8TmF2IC8+IFxuICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgPC9kaXY+XG4pXG5jb25zdCBOYXYgPSAoKSA9PiAoXG4gIDxuYXYgY2xhc3M9XCJuYXZiYXIgbmF2YmFyLWludmVyc2VcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWhlYWRlclwiPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm5hdmJhci10b2dnbGVcIiBkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCIgZGF0YS10YXJnZXQ9XCIjbXlOYXZiYXJcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tYmFyXCI+PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi1iYXJcIj48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLWJhclwiPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sbGFwc2UgbmF2YmFyLWNvbGxhcHNlXCIgaWQ9XCJteU5hdmJhclwiPlxuICAgICAgPHVsIGNsYXNzPVwibmF2IG5hdmJhci1uYXZcIj5cbiAgICAgICAgPGxpPjxJbmRleExpbmsgYWN0aXZlQ2xhc3NOYW1lPSdhY3RpdmUnIHRvPScvJz5Ib21lPC9JbmRleExpbms+PC9saT5cbiAgICAgICAgPGxpPjxJbmRleExpbmsgYWN0aXZlQ2xhc3NOYW1lPSdhY3RpdmUnIHRvPScvdXNlcic+RmFtb3VzIFBlb3BsZTwvSW5kZXhMaW5rPjwvbGk+XG4gICAgICAgIDxsaT48SW5kZXhMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nYWN0aXZlJyB0bz0nL3R1cnRsZXMnPk11dGFudCBUdXJ0bGVzPC9JbmRleExpbms+PC9saT5cbiAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG4gIDwvbmF2PlxuKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcm91dGVzL2NvbnRhaW5lci5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbiAgXG52YXIgbXlTdHlsZSA9IHtcbiAgXHRtYXJnaW5MZWZ0OiAzMCxcbiAgXHRtYXJnaW5SaWdodDogMjUsXG4gIFx0Zm9udEZhbWlseTogJ0Rvc2lzJ1xufVxuXG5leHBvcnQgY29uc3QgSG9tZSA9ICgpID0+IChcbiAgPGRpdiBzdHlsZT17bXlTdHlsZX0+XG4gICAgPGJyIC8+XG4gICAgPGgyPldlbGNvbWUgdG8gdGhlIFdvcmxkIG9mIGZhbUUgYW5kIG11VEFhdElvTnMhPC9oMj5cbiAgICA8aDQ+PiBjbGljayBvbiBuYXZpZ2F0aW9uIHRvIHNlZSBtb3JlLi4uPC9oND5cbiAgPC9kaXY+XG4pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy9ob21lLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgTm90Rm91bmQgPSAoKSA9PiAoXG4gIDxoMj40MDQ6IFRoaXMgcGFnZSBpcyBub3QgZm91bmQhPC9oMj5cbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy9ub3Rmb3VuZC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBDb21wVHVydGxlIGZyb20gJy4uL2Rldi9qcy9jb21wb25lbnRzL2NvbXAtdHVydGxlJ1xuXG52YXIgbXlTdHlsZSA9IHtcbiAgXHRtYXJnaW5MZWZ0OiAzMCxcbiAgXHRtYXJnaW5SaWdodDogMjUsXG4gIFx0Zm9udEZhbWlseTogJ0Rvc2lzJ1xufVxuXG5leHBvcnQgY29uc3QgVHVydGxlcyA9IChwcm9wcykgPT4gKFxuICA8ZGl2IHN0eWxlPXtteVN0eWxlfT5cbiAgICA8YnIgLz5cbiAgICA8aDI+VGhpcyBpcyB0aGUgVHVydGxlcyBQYWdlPC9oMj5cbiAgICA8Q29tcFR1cnRsZSAvPlxuICA8L2Rpdj5cbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy90dXJ0bGVzLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IENvbXBVc2VyIGZyb20gJy4uL2Rldi9qcy9jb21wb25lbnRzL2NvbXAtdXNlcidcblxudmFyIG15U3R5bGUgPSB7XG4gIFx0bWFyZ2luTGVmdDogMzAsXG4gIFx0bWFyZ2luUmlnaHQ6IDI1LFxuICBcdGZvbnRGYW1pbHk6ICdEb3Npcydcbn1cblxuZXhwb3J0IGNvbnN0IFVzZXIgPSAoKSA9PiAoXG4gIDxkaXYgc3R5bGU9e215U3R5bGV9PlxuICAgIDxiciAvPlxuICAgIDxoMj5UaGlzIGlzIHRoZSBGYW1vdXMgUGVvcGxlIFBhZ2U8L2gyPlxuICAgIDxDb21wVXNlciAvPlxuICA8L2Rpdj5cbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy91c2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdERPTScpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtZG9tL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfc3RvcmVTaGFwZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0b3JlU2hhcGUnKTtcblxudmFyIF9zdG9yZVNoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0b3JlU2hhcGUpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpIHtcbiAgaWYgKGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gdHJ1ZTtcblxuICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkoJzxQcm92aWRlcj4gZG9lcyBub3Qgc3VwcG9ydCBjaGFuZ2luZyBgc3RvcmVgIG9uIHRoZSBmbHkuICcgKyAnSXQgaXMgbW9zdCBsaWtlbHkgdGhhdCB5b3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgdXBkYXRlZCB0byAnICsgJ1JlZHV4IDIueCBhbmQgUmVhY3QgUmVkdXggMi54IHdoaWNoIG5vIGxvbmdlciBob3QgcmVsb2FkIHJlZHVjZXJzICcgKyAnYXV0b21hdGljYWxseS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJlZHV4L3JlbGVhc2VzLycgKyAndGFnL3YyLjAuMCBmb3IgdGhlIG1pZ3JhdGlvbiBpbnN0cnVjdGlvbnMuJyk7XG59XG5cbnZhciBQcm92aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgUHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4geyBzdG9yZTogdGhpcy5zdG9yZSB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3ZpZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgX3RoaXMuc3RvcmUgPSBwcm9wcy5zdG9yZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICByZXR1cm4gX3JlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBQcm92aWRlcjtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHJvdmlkZXI7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgdmFyIG5leHRTdG9yZSA9IG5leHRQcm9wcy5zdG9yZTtcblxuICAgIGlmIChzdG9yZSAhPT0gbmV4dFN0b3JlKSB7XG4gICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXS5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbn07XG5Qcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl0uaXNSZXF1aXJlZFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9Qcm92aWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb25uZWN0O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9zdG9yZVNoYXBlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RvcmVTaGFwZScpO1xuXG52YXIgX3N0b3JlU2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RvcmVTaGFwZSk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBfc2hhbGxvd0VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dFcXVhbCk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7fTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4geyBkaXNwYXRjaDogZGlzcGF0Y2ggfTtcbn07XG52YXIgZGVmYXVsdE1lcmdlUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHBhcmVudFByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn07XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG52YXIgZXJyb3JPYmplY3QgPSB7IHZhbHVlOiBudWxsIH07XG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgY3R4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGN0eCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvck9iamVjdC52YWx1ZSA9IGU7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0O1xuICB9XG59XG5cbi8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG52YXIgbmV4dFZlcnNpb24gPSAwO1xuXG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbM107XG5cbiAgdmFyIHNob3VsZFN1YnNjcmliZSA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcbiAgdmFyIG1hcFN0YXRlID0gbWFwU3RhdGVUb1Byb3BzIHx8IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHM7XG5cbiAgdmFyIG1hcERpc3BhdGNoID0gdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hcERpc3BhdGNoID0gbWFwRGlzcGF0Y2hUb1Byb3BzO1xuICB9IGVsc2UgaWYgKCFtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgICBtYXBEaXNwYXRjaCA9IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgbWFwRGlzcGF0Y2ggPSAoMCwgX3dyYXBBY3Rpb25DcmVhdG9yczJbXCJkZWZhdWx0XCJdKShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICB9XG5cbiAgdmFyIGZpbmFsTWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHMgfHwgZGVmYXVsdE1lcmdlUHJvcHM7XG4gIHZhciBfb3B0aW9ucyRwdXJlID0gb3B0aW9ucy5wdXJlO1xuICB2YXIgcHVyZSA9IF9vcHRpb25zJHB1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfb3B0aW9ucyRwdXJlO1xuICB2YXIgX29wdGlvbnMkd2l0aFJlZiA9IG9wdGlvbnMud2l0aFJlZjtcbiAgdmFyIHdpdGhSZWYgPSBfb3B0aW9ucyR3aXRoUmVmID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHdpdGhSZWY7XG5cbiAgdmFyIGNoZWNrTWVyZ2VkRXF1YWxzID0gcHVyZSAmJiBmaW5hbE1lcmdlUHJvcHMgIT09IGRlZmF1bHRNZXJnZVByb3BzO1xuXG4gIC8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG4gIHZhciB2ZXJzaW9uID0gbmV4dFZlcnNpb24rKztcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICB2YXIgY29ubmVjdERpc3BsYXlOYW1lID0gJ0Nvbm5lY3QoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tTdGF0ZVNoYXBlKHByb3BzLCBtZXRob2ROYW1lKSB7XG4gICAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShwcm9wcykpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKG1ldGhvZE5hbWUgKyAnKCkgaW4gJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICcgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuICcgKyAoJ0luc3RlYWQgcmVjZWl2ZWQgJyArIHByb3BzICsgJy4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lcmdlZFByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIHBhcmVudFByb3BzKSB7XG4gICAgICB2YXIgbWVyZ2VkUHJvcHMgPSBmaW5hbE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1lcmdlZFByb3BzLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH1cblxuICAgIHZhciBDb25uZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gIXB1cmUgfHwgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkIHx8IHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQ7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBDb25uZWN0KHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgICAgICBfdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wcy5zdG9yZSB8fCBjb250ZXh0LnN0b3JlO1xuXG4gICAgICAgICgwLCBfaW52YXJpYW50MltcImRlZmF1bHRcIl0pKF90aGlzLnN0b3JlLCAnQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciAnICsgKCdwcm9wcyBvZiBcIicgKyBjb25uZWN0RGlzcGxheU5hbWUgKyAnXCIuICcpICsgJ0VpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcgKyAoJ29yIGV4cGxpY2l0bHkgcGFzcyBcInN0b3JlXCIgYXMgYSBwcm9wIHRvIFwiJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICdcIi4nKSk7XG5cbiAgICAgICAgdmFyIHN0b3JlU3RhdGUgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9O1xuICAgICAgICBfdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZVN0YXRlUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlU3RhdGVQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIHN0YXRlUHJvcHMgPSB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShzdGF0ZVByb3BzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcFN0YXRlID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZFN0YXRlID0gbWFwU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSwgcHJvcHMpO1xuICAgICAgICB2YXIgaXNGYWN0b3J5ID0gdHlwZW9mIG1hcHBlZFN0YXRlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMgPSBpc0ZhY3RvcnkgPyBtYXBwZWRTdGF0ZSA6IG1hcFN0YXRlO1xuICAgICAgICB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPSB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzLmxlbmd0aCAhPT0gMTtcblxuICAgICAgICBpZiAoaXNGYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVN0YXRlUHJvcHMoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1hcHBlZFN0YXRlLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZFN0YXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZURpc3BhdGNoUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlRGlzcGF0Y2hQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoUHJvcHMgPSB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShkaXNwYXRjaFByb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcERpc3BhdGNoID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZERpc3BhdGNoID0gbWFwRGlzcGF0Y2goc3RvcmUuZGlzcGF0Y2gsIHByb3BzKTtcbiAgICAgICAgdmFyIGlzRmFjdG9yeSA9IHR5cGVvZiBtYXBwZWREaXNwYXRjaCA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gaXNGYWN0b3J5ID8gbWFwcGVkRGlzcGF0Y2ggOiBtYXBEaXNwYXRjaDtcbiAgICAgICAgdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzID0gdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcy5sZW5ndGggIT09IDE7XG5cbiAgICAgICAgaWYgKGlzRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVEaXNwYXRjaFByb3BzKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShtYXBwZWREaXNwYXRjaCwgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWREaXNwYXRjaDtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHRTdGF0ZVByb3BzID0gdGhpcy5jb21wdXRlU3RhdGVQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0U3RhdGVQcm9wcywgdGhpcy5zdGF0ZVByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHREaXNwYXRjaFByb3BzID0gdGhpcy5jb21wdXRlRGlzcGF0Y2hQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0RGlzcGF0Y2hQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQcm9wcyA9IG5leHREaXNwYXRjaFByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dE1lcmdlZFByb3BzID0gY29tcHV0ZU1lcmdlZFByb3BzKHRoaXMuc3RhdGVQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VkUHJvcHMgJiYgY2hlY2tNZXJnZWRFcXVhbHMgJiYgKDAsIF9zaGFsbG93RXF1YWwyW1wiZGVmYXVsdFwiXSkobmV4dE1lcmdlZFByb3BzLCB0aGlzLm1lcmdlZFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbic7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmUgJiYgIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICEoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0UHJvcHMsIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLm1lcmdlZFByb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdG9yZVN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgcHJldlN0b3JlU3RhdGUgPSB0aGlzLnN0YXRlLnN0b3JlU3RhdGU7XG4gICAgICAgIGlmIChwdXJlICYmIHByZXZTdG9yZVN0YXRlID09PSBzdG9yZVN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB1cmUgJiYgIXRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcykge1xuICAgICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0cnlDYXRjaCh0aGlzLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFoYXZlU3RhdGVQcm9wc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBlcnJvck9iamVjdC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9KTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgKDAsIF9pbnZhcmlhbnQyW1wiZGVmYXVsdFwiXSkod2l0aFJlZiwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ3sgd2l0aFJlZjogdHJ1ZSB9IGFzIHRoZSBmb3VydGggYXJndW1lbnQgb2YgdGhlIGNvbm5lY3QoKSBjYWxsLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgaGF2ZU93blByb3BzQ2hhbmdlZCA9IHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZDtcbiAgICAgICAgdmFyIGhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZDtcbiAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQ7XG4gICAgICAgIHZhciBzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgIHZhciByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLnJlbmRlcmVkRWxlbWVudDtcblxuICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlU3RhdGVQcm9wcyA9IHRydWU7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHB1cmUgJiYgcmVuZGVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlU3RhdGVQcm9wcyA9IGhhc1N0b3JlU3RhdGVDaGFuZ2VkIHx8IGhhdmVPd25Qcm9wc0NoYW5nZWQgJiYgdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzO1xuICAgICAgICAgIHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMgPSBoYXZlT3duUHJvcHNDaGFuZ2VkICYmIHRoaXMuZG9EaXNwYXRjaFByb3BzRGVwZW5kT25Pd25Qcm9wcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCkge1xuICAgICAgICAgIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkVXBkYXRlU3RhdGVQcm9wcykge1xuICAgICAgICAgIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMpIHtcbiAgICAgICAgICBoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkIHx8IGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCB8fCBoYXZlT3duUHJvcHNDaGFuZ2VkKSB7XG4gICAgICAgICAgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCAmJiByZW5kZXJlZEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpdGhSZWYpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9ICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHRoaXMubWVyZ2VkUHJvcHMsIHtcbiAgICAgICAgICAgIHJlZjogJ3dyYXBwZWRJbnN0YW5jZSdcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKFdyYXBwZWRDb21wb25lbnQsIHRoaXMubWVyZ2VkUHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRFbGVtZW50O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBjb25uZWN0RGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmNvbnRleHRUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdXG4gICAgfTtcbiAgICBDb25uZWN0LnByb3BUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdXG4gICAgfTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gdmVyc2lvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFyZSBob3QgcmVsb2FkaW5nIVxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyW1wiZGVmYXVsdFwiXSkoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNoYWxsb3dFcXVhbDtcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCBvYmpBW2tleXNBW2ldXSAhPT0gb2JqQltrZXlzQVtpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdyYXBBY3Rpb25DcmVhdG9ycztcblxudmFyIF9yZWR1eCA9IHJlcXVpcmUoJ3JlZHV4Jyk7XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuICgwLCBfcmVkdXguYmluZEFjdGlvbkNyZWF0b3JzKShhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93cmFwQWN0aW9uQ3JlYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICBuYW1lOiB0cnVlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgY2FsbGVyOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGN1c3RvbVN0YXRpY3MpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXlzW2ldXSAmJiAhS05PV05fU1RBVElDU1trZXlzW2ldXSAmJiAoIWN1c3RvbVN0YXRpY3MgfHwgIWN1c3RvbVN0YXRpY3Nba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tcG9uZW50W2tleXNbaV1dID0gc291cmNlQ29tcG9uZW50W2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNIb3N0T2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvfi9sb2Rhc2gvX2lzSG9zdE9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L34vbG9kYXNoL19vdmVyQXJnLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9pc09iamVjdExpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJvdXRlck1pZGRsZXdhcmU7XG5cbnZhciBfYWN0aW9ucyA9IHJlcXVpcmUoJy4vYWN0aW9ucycpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuLyoqXG4gKiBUaGlzIG1pZGRsZXdhcmUgY2FwdHVyZXMgQ0FMTF9ISVNUT1JZX01FVEhPRCBhY3Rpb25zIHRvIHJlZGlyZWN0IHRvIHRoZVxuICogcHJvdmlkZWQgaGlzdG9yeSBvYmplY3QuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZXNlIGFjdGlvbnMgZnJvbSByZWFjaGluZyB5b3VyXG4gKiByZWR1Y2VyIG9yIGFueSBtaWRkbGV3YXJlIHRoYXQgY29tZXMgYWZ0ZXIgdGhpcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIHJvdXRlck1pZGRsZXdhcmUoaGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSBfYWN0aW9ucy5DQUxMX0hJU1RPUllfTUVUSE9EKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfYWN0aW9uJHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgdmFyIG1ldGhvZCA9IF9hY3Rpb24kcGF5bG9hZC5tZXRob2Q7XG4gICAgICAgIHZhciBhcmdzID0gX2FjdGlvbiRwYXlsb2FkLmFyZ3M7XG5cbiAgICAgICAgaGlzdG9yeVttZXRob2RdLmFwcGx5KGhpc3RvcnksIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9taWRkbGV3YXJlLmpzXG4gKiogbW9kdWxlIGlkID0gMTYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bmNIaXN0b3J5V2l0aFN0b3JlO1xuXG52YXIgX3JlZHVjZXIgPSByZXF1aXJlKCcuL3JlZHVjZXInKTtcblxudmFyIGRlZmF1bHRTZWxlY3RMb2NhdGlvblN0YXRlID0gZnVuY3Rpb24gZGVmYXVsdFNlbGVjdExvY2F0aW9uU3RhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJvdXRpbmc7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc3luY2hyb25pemVzIHlvdXIgaGlzdG9yeSBzdGF0ZSB3aXRoIHRoZSBSZWR1eCBzdG9yZS5cbiAqIExvY2F0aW9uIGNoYW5nZXMgZmxvdyBmcm9tIGhpc3RvcnkgdG8gdGhlIHN0b3JlLiBBbiBlbmhhbmNlZCBoaXN0b3J5IGlzXG4gKiByZXR1cm5lZCB3aXRoIGEgbGlzdGVuIG1ldGhvZCB0aGF0IHJlc3BvbmRzIHRvIHN0b3JlIHVwZGF0ZXMgZm9yIGxvY2F0aW9uLlxuICpcbiAqIFdoZW4gdGhpcyBoaXN0b3J5IGlzIHByb3ZpZGVkIHRvIHRoZSByb3V0ZXIsIHRoaXMgbWVhbnMgdGhlIGxvY2F0aW9uIGRhdGFcbiAqIHdpbGwgZmxvdyBsaWtlIHRoaXM6XG4gKiBoaXN0b3J5LnB1c2ggLT4gc3RvcmUuZGlzcGF0Y2ggLT4gZW5oYW5jZWRIaXN0b3J5Lmxpc3RlbiAtPiByb3V0ZXJcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gdGhlIHN0b3JlIHN0YXRlIGNoYW5nZXMgZHVlIHRvIGEgcmVwbGF5IG9yIG90aGVyXG4gKiBldmVudCwgdGhlIHJvdXRlciB3aWxsIGJlIHVwZGF0ZWQgYXBwcm9wcmlhdGVseSBhbmQgY2FuIHRyYW5zaXRpb24gdG8gdGhlXG4gKiBjb3JyZWN0IHJvdXRlciBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gc3luY0hpc3RvcnlXaXRoU3RvcmUoaGlzdG9yeSwgc3RvcmUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICB2YXIgX3JlZiRzZWxlY3RMb2NhdGlvblN0ID0gX3JlZi5zZWxlY3RMb2NhdGlvblN0YXRlO1xuICB2YXIgc2VsZWN0TG9jYXRpb25TdGF0ZSA9IF9yZWYkc2VsZWN0TG9jYXRpb25TdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFNlbGVjdExvY2F0aW9uU3RhdGUgOiBfcmVmJHNlbGVjdExvY2F0aW9uU3Q7XG4gIHZhciBfcmVmJGFkanVzdFVybE9uUmVwbGEgPSBfcmVmLmFkanVzdFVybE9uUmVwbGF5O1xuICB2YXIgYWRqdXN0VXJsT25SZXBsYXkgPSBfcmVmJGFkanVzdFVybE9uUmVwbGEgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJGFkanVzdFVybE9uUmVwbGE7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHJlZHVjZXIgaXMgbW91bnRlZCBvbiB0aGUgc3RvcmUgYW5kIGZ1bmN0aW9uaW5nIHByb3Blcmx5LlxuICBpZiAodHlwZW9mIHNlbGVjdExvY2F0aW9uU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcm91dGluZyBzdGF0ZSB0byBiZSBhdmFpbGFibGUgZWl0aGVyIGFzIGBzdGF0ZS5yb3V0aW5nYCAnICsgJ29yIGFzIHRoZSBjdXN0b20gZXhwcmVzc2lvbiB5b3UgY2FuIHNwZWNpZnkgYXMgYHNlbGVjdExvY2F0aW9uU3RhdGVgICcgKyAnaW4gdGhlIGBzeW5jSGlzdG9yeVdpdGhTdG9yZSgpYCBvcHRpb25zLiAnICsgJ0Vuc3VyZSB5b3UgaGF2ZSBhZGRlZCB0aGUgYHJvdXRlclJlZHVjZXJgIHRvIHlvdXIgc3RvcmVcXCdzICcgKyAncmVkdWNlcnMgdmlhIGBjb21iaW5lUmVkdWNlcnNgIG9yIHdoYXRldmVyIG1ldGhvZCB5b3UgdXNlIHRvIGlzb2xhdGUgJyArICd5b3VyIHJlZHVjZXJzLicpO1xuICB9XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IHZvaWQgMDtcbiAgdmFyIGlzVGltZVRyYXZlbGluZyA9IHZvaWQgMDtcbiAgdmFyIHVuc3Vic2NyaWJlRnJvbVN0b3JlID0gdm9pZCAwO1xuICB2YXIgdW5zdWJzY3JpYmVGcm9tSGlzdG9yeSA9IHZvaWQgMDtcblxuICAvLyBXaGF0IGRvZXMgdGhlIHN0b3JlIHNheSBhYm91dCBjdXJyZW50IGxvY2F0aW9uP1xuICB2YXIgZ2V0TG9jYXRpb25JblN0b3JlID0gZnVuY3Rpb24gZ2V0TG9jYXRpb25JblN0b3JlKHVzZUluaXRpYWxJZkVtcHR5KSB7XG4gICAgdmFyIGxvY2F0aW9uU3RhdGUgPSBzZWxlY3RMb2NhdGlvblN0YXRlKHN0b3JlLmdldFN0YXRlKCkpO1xuICAgIHJldHVybiBsb2NhdGlvblN0YXRlLmxvY2F0aW9uQmVmb3JlVHJhbnNpdGlvbnMgfHwgKHVzZUluaXRpYWxJZkVtcHR5ID8gaW5pdGlhbExvY2F0aW9uIDogdW5kZWZpbmVkKTtcbiAgfTtcblxuICAvLyBJbml0IGN1cnJlbnRMb2NhdGlvbiB3aXRoIHBvdGVudGlhbCBsb2NhdGlvbiBpbiBzdG9yZVxuICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0TG9jYXRpb25JblN0b3JlKCk7XG5cbiAgLy8gSWYgdGhlIHN0b3JlIGlzIHJlcGxheWVkLCB1cGRhdGUgdGhlIFVSTCBpbiB0aGUgYnJvd3NlciB0byBtYXRjaC5cbiAgaWYgKGFkanVzdFVybE9uUmVwbGF5KSB7XG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlU3RvcmVDaGFuZ2UoKSB7XG4gICAgICB2YXIgbG9jYXRpb25JblN0b3JlID0gZ2V0TG9jYXRpb25JblN0b3JlKHRydWUpO1xuICAgICAgaWYgKGN1cnJlbnRMb2NhdGlvbiA9PT0gbG9jYXRpb25JblN0b3JlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGFkZHJlc3MgYmFyIHRvIHJlZmxlY3Qgc3RvcmUgc3RhdGVcbiAgICAgIGlzVGltZVRyYXZlbGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbkluU3RvcmU7XG4gICAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgbG9jYXRpb25JblN0b3JlLCB7XG4gICAgICAgIGFjdGlvbjogJ1BVU0gnXG4gICAgICB9KSk7XG4gICAgICBpc1RpbWVUcmF2ZWxpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdW5zdWJzY3JpYmVGcm9tU3RvcmUgPSBzdG9yZS5zdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xuICAgIGhhbmRsZVN0b3JlQ2hhbmdlKCk7XG4gIH1cblxuICAvLyBXaGVuZXZlciBsb2NhdGlvbiBjaGFuZ2VzLCBkaXNwYXRjaCBhbiBhY3Rpb24gdG8gZ2V0IGl0IGluIHRoZSBzdG9yZVxuICB2YXIgaGFuZGxlTG9jYXRpb25DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2NhdGlvbkNoYW5nZShsb2NhdGlvbikge1xuICAgIC8vIC4uLiB1bmxlc3Mgd2UganVzdCBjYXVzZWQgdGhhdCBsb2NhdGlvbiBjaGFuZ2VcbiAgICBpZiAoaXNUaW1lVHJhdmVsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtZW1iZXIgd2hlcmUgd2UgYXJlXG4gICAgY3VycmVudExvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgICAvLyBBcmUgd2UgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZT9cbiAgICBpZiAoIWluaXRpYWxMb2NhdGlvbikge1xuICAgICAgLy8gUmVtZW1iZXIgYXMgYSBmYWxsYmFjayBpbiBjYXNlIHN0YXRlIGlzIHJlc2V0XG4gICAgICBpbml0aWFsTG9jYXRpb24gPSBsb2NhdGlvbjtcblxuICAgICAgLy8gUmVzcGVjdCBwZXJzaXN0ZWQgbG9jYXRpb24sIGlmIGFueVxuICAgICAgaWYgKGdldExvY2F0aW9uSW5TdG9yZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUZWxsIHRoZSBzdG9yZSB0byB1cGRhdGUgYnkgZGlzcGF0Y2hpbmcgYW4gYWN0aW9uXG4gICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogX3JlZHVjZXIuTE9DQVRJT05fQ0hBTkdFLFxuICAgICAgcGF5bG9hZDogbG9jYXRpb25cbiAgICB9KTtcbiAgfTtcbiAgdW5zdWJzY3JpYmVGcm9tSGlzdG9yeSA9IGhpc3RvcnkubGlzdGVuKGhhbmRsZUxvY2F0aW9uQ2hhbmdlKTtcblxuICAvLyBUaGUgZW5oYW5jZWQgaGlzdG9yeSB1c2VzIHN0b3JlIGFzIHNvdXJjZSBvZiB0cnV0aFxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAvLyBUaGUgbGlzdGVuZXJzIGFyZSBzdWJzY3JpYmVkIHRvIHRoZSBzdG9yZSBpbnN0ZWFkIG9mIGhpc3RvcnlcblxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICAvLyBDb3B5IG9mIGxhc3QgbG9jYXRpb24uXG4gICAgICB2YXIgbGFzdFB1Ymxpc2hlZExvY2F0aW9uID0gZ2V0TG9jYXRpb25JblN0b3JlKHRydWUpO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgd2UgdW5zdWJzY3JpYmVkLCBhcyBSZWR1eCBzdG9yZVxuICAgICAgLy8gb25seSBhcHBsaWVzIGNoYW5nZXMgaW4gc3Vic2NyaXB0aW9ucyBvbiBuZXh0IGRpc3BhdGNoXG4gICAgICB2YXIgdW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB2YXIgdW5zdWJzY3JpYmVGcm9tU3RvcmUgPSBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0TG9jYXRpb25JblN0b3JlKHRydWUpO1xuICAgICAgICBpZiAoY3VycmVudExvY2F0aW9uID09PSBsYXN0UHVibGlzaGVkTG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFB1Ymxpc2hlZExvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuICAgICAgICBpZiAoIXVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgIGxpc3RlbmVyKGxhc3RQdWJsaXNoZWRMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaXN0b3J5IGxpc3RlbmVycyBleHBlY3QgYSBzeW5jaHJvbm91cyBjYWxsLiBNYWtlIHRoZSBmaXJzdCBjYWxsIHRvIHRoZVxuICAgICAgLy8gbGlzdGVuZXIgYWZ0ZXIgc3Vic2NyaWJpbmcgdG8gdGhlIHN0b3JlLCBpbiBjYXNlIHRoZSBsaXN0ZW5lciBjYXVzZXMgYVxuICAgICAgLy8gbG9jYXRpb24gY2hhbmdlIChlLmcuIHdoZW4gaXQgcmVkaXJlY3RzKVxuICAgICAgbGlzdGVuZXIobGFzdFB1Ymxpc2hlZExvY2F0aW9uKTtcblxuICAgICAgLy8gTGV0IHVzZXIgdW5zdWJzY3JpYmUgbGF0ZXJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHVuc3Vic2NyaWJlRnJvbVN0b3JlKCk7XG4gICAgICB9O1xuICAgIH0sXG5cblxuICAgIC8vIEl0IGFsc28gcHJvdmlkZXMgYSB3YXkgdG8gZGVzdHJveSBpbnRlcm5hbCBsaXN0ZW5lcnNcbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoYWRqdXN0VXJsT25SZXBsYXkpIHtcbiAgICAgICAgdW5zdWJzY3JpYmVGcm9tU3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHVuc3Vic2NyaWJlRnJvbUhpc3RvcnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvc3luYy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEEgbWl4aW4gdGhhdCBhZGRzIHRoZSBcImhpc3RvcnlcIiBpbnN0YW5jZSB2YXJpYWJsZSB0byBjb21wb25lbnRzLlxuICovXG52YXIgSGlzdG9yeSA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBfSW50ZXJuYWxQcm9wVHlwZXMuaGlzdG9yeVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAndGhlIGBIaXN0b3J5YCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgYWNjZXNzIGBjb250ZXh0LnJvdXRlcmAgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWhpc3RvcnltaXhpbicpIDogdm9pZCAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuY29udGV4dC5oaXN0b3J5O1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9IaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMTY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9MaW5rID0gcmVxdWlyZSgnLi9MaW5rJyk7XG5cbnZhciBfTGluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaW5rKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBBbiA8SW5kZXhMaW5rPiBpcyB1c2VkIHRvIGxpbmsgdG8gYW4gPEluZGV4Um91dGU+LlxuICovXG52YXIgSW5kZXhMaW5rID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleExpbmsnLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX0xpbmsyLmRlZmF1bHQsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IG9ubHlBY3RpdmVPbkluZGV4OiB0cnVlIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4TGluaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhMaW5rLmpzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9SZWRpcmVjdCA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcblxudmFyIF9SZWRpcmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWRpcmVjdCk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBbiA8SW5kZXhSZWRpcmVjdD4gaXMgdXNlZCB0byByZWRpcmVjdCBmcm9tIGFuIGluZGV4Um91dGUuXG4gKi9cblxudmFyIEluZGV4UmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4UmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9IF9SZWRpcmVjdDIuZGVmYXVsdC5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJlZGlyZWN0PiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgb25FbnRlcjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVuYyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMuZnVuYztcblxuLyoqXG4gKiBBbiA8SW5kZXhSb3V0ZT4gaXMgdXNlZCB0byBzcGVjaWZ5IGl0cyBwYXJlbnQncyA8Um91dGUgaW5kZXhSb3V0ZT4gaW5cbiAqIGEgSlNYIHJvdXRlIGNvbmZpZy5cbiAqL1xuXG52YXIgSW5kZXhSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhSb3V0ZScsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBzYW5pdHkgY2hlY2sgKi9cbiAgICAgIGlmIChwYXJlbnRSb3V0ZSkge1xuICAgICAgICBwYXJlbnRSb3V0ZS5pbmRleFJvdXRlID0gKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJvdXRlPiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjb21wb25lbnQ6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnQsXG4gICAgY29tcG9uZW50czogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHMsXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jLFxuICAgIGdldENvbXBvbmVudHM6IGZ1bmNcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSb3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSb3V0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgTGlmZWN5Y2xlIG1peGluIGFkZHMgdGhlIHJvdXRlcldpbGxMZWF2ZSBsaWZlY3ljbGUgbWV0aG9kIHRvIGFcbiAqIGNvbXBvbmVudCB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCBhIHRyYW5zaXRpb24gb3IgcHJvbXB0IHRoZSB1c2VyXG4gKiBmb3IgY29uZmlybWF0aW9uLlxuICpcbiAqIE9uIHN0YW5kYXJkIHRyYW5zaXRpb25zLCByb3V0ZXJXaWxsTGVhdmUgcmVjZWl2ZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZVxuICogbG9jYXRpb24gd2UncmUgdHJhbnNpdGlvbmluZyB0by4gVG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLCByZXR1cm4gZmFsc2UuXG4gKiBUbyBwcm9tcHQgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbiwgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykuXG4gKlxuICogRHVyaW5nIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgKGFzc3VtaW5nIHlvdSdyZSB1c2luZyB0aGUgdXNlQmVmb3JlVW5sb2FkXG4gKiBoaXN0b3J5IGVuaGFuY2VyKSwgcm91dGVyV2lsbExlYXZlIGRvZXMgbm90IHJlY2VpdmUgYSBsb2NhdGlvbiBvYmplY3RcbiAqIGJlY2F1c2UgaXQgaXNuJ3QgcG9zc2libGUgZm9yIHVzIHRvIGtub3cgdGhlIGxvY2F0aW9uIHdlJ3JlIHRyYW5zaXRpb25pbmdcbiAqIHRvLiBJbiB0aGlzIGNhc2Ugcm91dGVyV2lsbExlYXZlIG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudFxuICogdGhlIHVzZXIgZnJvbSBjbG9zaW5nIHRoZSB3aW5kb3cvdGFiLlxuICovXG5cbnZhciBMaWZlY3ljbGUgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgLy8gTmVzdGVkIGNoaWxkcmVuIHJlY2VpdmUgdGhlIHJvdXRlIGFzIGNvbnRleHQsIGVpdGhlclxuICAgIC8vIHNldCBieSB0aGUgcm91dGUgY29tcG9uZW50IHVzaW5nIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW5cbiAgICAvLyBvciBieSBzb21lIG90aGVyIGFuY2VzdG9yLlxuICAgIHJvdXRlOiBvYmplY3RcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICAvLyBSb3V0ZSBjb21wb25lbnRzIHJlY2VpdmUgdGhlIHJvdXRlIG9iamVjdCBhcyBhIHByb3AuXG4gICAgcm91dGU6IG9iamVjdFxuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ3RoZSBgTGlmZWN5Y2xlYCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlci5zZXRSb3V0ZUxlYXZlSG9vayhyb3V0ZSwgaG9vaylgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItbGlmZWN5Y2xlbWl4aW4nKSA6IHZvaWQgMDtcbiAgICAhdGhpcy5yb3V0ZXJXaWxsTGVhdmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiByZXF1aXJlcyB5b3UgdG8gZGVmaW5lIGEgcm91dGVyV2lsbExlYXZlIG1ldGhvZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciByb3V0ZSA9IHRoaXMucHJvcHMucm91dGUgfHwgdGhpcy5jb250ZXh0LnJvdXRlO1xuXG4gICAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBMaWZlY3ljbGUgbWl4aW4gbXVzdCBiZSB1c2VkIG9uIGVpdGhlciBhKSBhIDxSb3V0ZSBjb21wb25lbnQ+IG9yICcgKyAnYikgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlIGNvbXBvbmVudD4gdGhhdCB1c2VzIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSA9IHRoaXMuY29udGV4dC5oaXN0b3J5Lmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXJXaWxsTGVhdmUpO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKSB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSgpO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaWZlY3ljbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0xpZmVjeWNsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcblxuLyoqXG4gKiBBIDxSb3V0ZT4gaXMgdXNlZCB0byBkZWNsYXJlIHdoaWNoIGNvbXBvbmVudHMgYXJlIHJlbmRlcmVkIHRvIHRoZVxuICogcGFnZSB3aGVuIHRoZSBVUkwgbWF0Y2hlcyBhIGdpdmVuIHBhdHRlcm4uXG4gKlxuICogUm91dGVzIGFyZSBhcnJhbmdlZCBpbiBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZS4gV2hlbiBhIG5ldyBVUkwgaXNcbiAqIHJlcXVlc3RlZCwgdGhlIHRyZWUgaXMgc2VhcmNoZWQgZGVwdGgtZmlyc3QgdG8gZmluZCBhIHJvdXRlIHdob3NlXG4gKiBwYXRoIG1hdGNoZXMgdGhlIFVSTC4gIFdoZW4gb25lIGlzIGZvdW5kLCBhbGwgcm91dGVzIGluIHRoZSB0cmVlXG4gKiB0aGF0IGxlYWQgdG8gaXQgYXJlIGNvbnNpZGVyZWQgXCJhY3RpdmVcIiBhbmQgdGhlaXIgY29tcG9uZW50cyBhcmVcbiAqIHJlbmRlcmVkIGludG8gdGhlIERPTSwgbmVzdGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIGluIHRoZSB0cmVlLlxuICovXG5cbnZhciBSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cyxcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG9iamVjdCA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIFRoZSBSb3V0ZUNvbnRleHQgbWl4aW4gcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSBmb3Igcm91dGVcbiAqIGNvbXBvbmVudHMgdG8gc2V0IHRoZSByb3V0ZSBpbiBjb250ZXh0LiBUaGlzIGlzIG5lZWRlZCBmb3JcbiAqIHJvdXRlcyB0aGF0IHJlbmRlciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBMaWZlY3ljbGVcbiAqIG1peGluIHRvIHByZXZlbnQgdHJhbnNpdGlvbnMuXG4gKi9cblxudmFyIFJvdXRlQ29udGV4dCA9IHtcblxuICBwcm9wVHlwZXM6IHtcbiAgICByb3V0ZTogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIHJvdXRlOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZTogdGhpcy5wcm9wcy5yb3V0ZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIGBSb3V0ZUNvbnRleHRgIG1peGluIGlzIGRlcHJlY2F0ZWQuIFlvdSBjYW4gcHJvdmlkZSBgdGhpcy5wcm9wcy5yb3V0ZWAgb24gY29udGV4dCB3aXRoIHlvdXIgb3duIGBjb250ZXh0VHlwZXNgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItcm91dGVjb250ZXh0bWl4aW4nKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZUNvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkpO1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUm91dGVyVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlclV0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaXNEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gIHJldHVybiAhaGlzdG9yeSB8fCAhaGlzdG9yeS5fX3YyX2NvbXBhdGlibGVfXztcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICAvLyB2MyBoaXN0b3JpZXMgZXhwb3NlIGdldEN1cnJlbnRMb2NhdGlvbiwgYnV0IGFyZW4ndCBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICByZXR1cm4gaGlzdG9yeSAmJiBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbjtcbn1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyPiBpcyBhIGhpZ2gtbGV2ZWwgQVBJIGZvciBhdXRvbWF0aWNhbGx5IHNldHRpbmcgdXBcbiAqIGEgcm91dGVyIHRoYXQgcmVuZGVycyBhIDxSb3V0ZXJDb250ZXh0PiB3aXRoIGFsbCB0aGUgcHJvcHNcbiAqIGl0IG5lZWRzIGVhY2ggdGltZSB0aGUgVVJMIGNoYW5nZXMuXG4gKi9cblxudmFyIFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGVyJyxcblxuXG4gIHByb3BUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcyxcbiAgICByb3V0ZXM6IF9JbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXMsIC8vIGFsaWFzIGZvciBjaGlsZHJlblxuICAgIHJlbmRlcjogZnVuYyxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLFxuICAgIG9uRXJyb3I6IGZ1bmMsXG4gICAgb25VcGRhdGU6IGZ1bmMsXG5cbiAgICAvLyBEZXByZWNhdGVkOlxuICAgIHBhcnNlUXVlcnlTdHJpbmc6IGZ1bmMsXG4gICAgc3RyaW5naWZ5UXVlcnk6IGZ1bmMsXG5cbiAgICAvLyBQUklWQVRFOiBGb3IgY2xpZW50LXNpZGUgcmVoeWRyYXRpb24gb2Ygc2VydmVyIG1hdGNoLlxuICAgIG1hdGNoQ29udGV4dDogb2JqZWN0XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjogbnVsbCxcbiAgICAgIHJvdXRlczogbnVsbCxcbiAgICAgIHBhcmFtczogbnVsbCxcbiAgICAgIGNvbXBvbmVudHM6IG51bGxcbiAgICB9O1xuICB9LFxuICBoYW5kbGVFcnJvcjogZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRocm93IGVycm9ycyBieSBkZWZhdWx0IHNvIHdlIGRvbid0IHNpbGVudGx5IHN3YWxsb3cgdGhlbSFcbiAgICAgIHRocm93IGVycm9yOyAvLyBUaGlzIGVycm9yIHByb2JhYmx5IG9jY3VycmVkIGluIGdldENoaWxkUm91dGVzIG9yIGdldENvbXBvbmVudHMuXG4gICAgfVxuICB9LFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBfcHJvcHMucGFyc2VRdWVyeVN0cmluZztcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBfcHJvcHMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghKHBhcnNlUXVlcnlTdHJpbmcgfHwgc3RyaW5naWZ5UXVlcnkpLCAnYHBhcnNlUXVlcnlTdHJpbmdgIGFuZCBgc3RyaW5naWZ5UXVlcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgY3JlYXRlIGEgY3VzdG9tIGhpc3RvcnkuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jdXN0b21xdWVyeXN0cmluZycpIDogdm9pZCAwO1xuXG4gICAgdmFyIF9jcmVhdGVSb3V0ZXJPYmplY3RzID0gdGhpcy5jcmVhdGVSb3V0ZXJPYmplY3RzKCk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLmhpc3Rvcnk7XG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gX2NyZWF0ZVJvdXRlck9iamVjdHMudHJhbnNpdGlvbk1hbmFnZXI7XG4gICAgdmFyIHJvdXRlciA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLnJvdXRlcjtcblxuXG4gICAgdGhpcy5fdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW4oZnVuY3Rpb24gKGVycm9yLCBzdGF0ZSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlLCBfdGhpcy5wcm9wcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB9LFxuICBjcmVhdGVSb3V0ZXJPYmplY3RzOiBmdW5jdGlvbiBjcmVhdGVSb3V0ZXJPYmplY3RzKCkge1xuICAgIHZhciBtYXRjaENvbnRleHQgPSB0aGlzLnByb3BzLm1hdGNoQ29udGV4dDtcblxuICAgIGlmIChtYXRjaENvbnRleHQpIHtcbiAgICAgIHJldHVybiBtYXRjaENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLnByb3BzLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciByb3V0ZXMgPSBfcHJvcHMyLnJvdXRlcztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMyLmNoaWxkcmVuO1xuXG5cbiAgICAhIWlzVW5zdXBwb3J0ZWRIaXN0b3J5KGhpc3RvcnkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBoYXZlIHByb3ZpZGVkIGEgaGlzdG9yeSBvYmplY3QgY3JlYXRlZCB3aXRoIGhpc3RvcnkgdjMueC4gJyArICdUaGlzIHZlcnNpb24gb2YgUmVhY3QgUm91dGVyIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdjMgaGlzdG9yeSAnICsgJ29iamVjdHMuIFBsZWFzZSB1c2UgaGlzdG9yeSB2Mi54IGluc3RlYWQuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkpIHtcbiAgICAgIGhpc3RvcnkgPSB0aGlzLndyYXBEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMgfHwgY2hpbGRyZW4pKTtcbiAgICB2YXIgcm91dGVyID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgICB2YXIgcm91dGluZ0hpc3RvcnkgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiByb3V0aW5nSGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXI6IHRyYW5zaXRpb25NYW5hZ2VyLCByb3V0ZXI6IHJvdXRlciB9O1xuICB9LFxuICB3cmFwRGVwcmVjYXRlZEhpc3Rvcnk6IGZ1bmN0aW9uIHdyYXBEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gX3Byb3BzMy5wYXJzZVF1ZXJ5U3RyaW5nO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IF9wcm9wczMuc3RyaW5naWZ5UXVlcnk7XG5cblxuICAgIHZhciBjcmVhdGVIaXN0b3J5ID0gdm9pZCAwO1xuICAgIGlmIChoaXN0b3J5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0l0IGFwcGVhcnMgeW91IGhhdmUgcHJvdmlkZWQgYSBkZXByZWNhdGVkIGhpc3Rvcnkgb2JqZWN0IHRvIGA8Um91dGVyLz5gLCBwbGVhc2UgdXNlIGEgaGlzdG9yeSBwcm92aWRlZCBieSAnICsgJ1JlYWN0IFJvdXRlciB3aXRoIGBpbXBvcnQgeyBicm93c2VySGlzdG9yeSB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYCBvciBgaW1wb3J0IHsgaGFzaEhpc3RvcnkgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2AuICcgKyAnSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSBoaXN0b3J5IHBsZWFzZSBjcmVhdGUgaXQgd2l0aCBgdXNlUm91dGVySGlzdG9yeWAsIHNlZSBodHRwOi8vdGlueS5jYy9yb3V0ZXItdXNpbmdoaXN0b3J5IGZvciBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgUm91dGVyYCBubyBsb25nZXIgZGVmYXVsdHMgdGhlIGhpc3RvcnkgcHJvcCB0byBoYXNoIGhpc3RvcnkuIFBsZWFzZSB1c2UgdGhlIGBoYXNoSGlzdG9yeWAgc2luZ2xldG9uIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1kZWZhdWx0aGlzdG9yeScpIDogdm9pZCAwO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IF9jcmVhdGVIYXNoSGlzdG9yeTIuZGVmYXVsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSh7IHBhcnNlUXVlcnlTdHJpbmc6IHBhcnNlUXVlcnlTdHJpbmcsIHN0cmluZ2lmeVF1ZXJ5OiBzdHJpbmdpZnlRdWVyeSB9KTtcbiAgfSxcblxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShuZXh0UHJvcHMuaGlzdG9yeSA9PT0gdGhpcy5wcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSgobmV4dFByb3BzLnJvdXRlcyB8fCBuZXh0UHJvcHMuY2hpbGRyZW4pID09PSAodGhpcy5wcm9wcy5yb3V0ZXMgfHwgdGhpcy5wcm9wcy5jaGlsZHJlbiksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIHJvdXRlcz47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdm9pZCAwO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuKSB0aGlzLl91bmxpc3RlbigpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgbG9jYXRpb24gPSBfc3RhdGUubG9jYXRpb247XG4gICAgdmFyIHJvdXRlcyA9IF9zdGF0ZS5yb3V0ZXM7XG4gICAgdmFyIHBhcmFtcyA9IF9zdGF0ZS5wYXJhbXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBfc3RhdGUuY29tcG9uZW50cztcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBfcHJvcHM0LmNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIHJlbmRlciA9IF9wcm9wczQucmVuZGVyO1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczQsIFsnY3JlYXRlRWxlbWVudCcsICdyZW5kZXInXSk7XG5cbiAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkgcmV0dXJuIG51bGw7IC8vIEFzeW5jIG1hdGNoXG5cbiAgICAvLyBPbmx5IGZvcndhcmQgbm9uLVJvdXRlci1zcGVjaWZpYyBwcm9wcyB0byByb3V0aW5nIGNvbnRleHQsIGFzIHRob3NlIGFyZVxuICAgIC8vIHRoZSBvbmx5IG9uZXMgdGhhdCBtaWdodCBiZSBjdXN0b20gcm91dGluZyBjb250ZXh0IHByb3BzLlxuICAgIE9iamVjdC5rZXlzKFJvdXRlci5wcm9wVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BUeXBlKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIHByb3BzW3Byb3BUeXBlXTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZW5kZXIoX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICByb3V0ZXI6IHRoaXMucm91dGVyLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcm91dGVzOiByb3V0ZXMsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50XG4gICAgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUm91dGluZ0NvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRpbmdDb250ZXh0JyxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgUm91dGluZ0NvbnRleHRgIGhhcyBiZWVuIHJlbmFtZWQgdG8gYFJvdXRlckNvbnRleHRgLiBQbGVhc2UgdXNlIGBpbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItcm91dGVyY29udGV4dCcpIDogdm9pZCAwO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHRoaXMucHJvcHMpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGluZ0NvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJ1bkVudGVySG9va3MgPSBydW5FbnRlckhvb2tzO1xuZXhwb3J0cy5ydW5DaGFuZ2VIb29rcyA9IHJ1bkNoYW5nZUhvb2tzO1xuZXhwb3J0cy5ydW5MZWF2ZUhvb2tzID0gcnVuTGVhdmVIb29rcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25Ib29rKGhvb2ssIHJvdXRlLCBhc3luY0FyaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaG9vay5hcHBseShyb3V0ZSwgYXJncyk7XG5cbiAgICBpZiAoaG9vay5sZW5ndGggPCBhc3luY0FyaXR5KSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAvLyBBc3N1bWUgaG9vayBleGVjdXRlcyBzeW5jaHJvbm91c2x5IGFuZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBjYWxsIHRoZSBjYWxsYmFjay5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbnRlckhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uRW50ZXIpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25FbnRlciwgcm91dGUsIDMpKTtcblxuICAgIHJldHVybiBob29rcztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkNoYW5nZSkgaG9va3MucHVzaChjcmVhdGVUcmFuc2l0aW9uSG9vayhyb3V0ZS5vbkNoYW5nZSwgcm91dGUsIDQpKTtcbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2tzKGxlbmd0aCwgaXRlciwgY2FsbGJhY2spIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWRpcmVjdEluZm8gPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24sIGRlcHJlY2F0ZWRQYXRobmFtZSwgZGVwcmVjYXRlZFF1ZXJ5KSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRQYXRobmFtZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRobmFtZSwgcXVlcnkpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBgcmVwbGFjZShsb2NhdGlvbilgIHdpdGggYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcbiAgICAgIHJlZGlyZWN0SW5mbyA9IHtcbiAgICAgICAgcGF0aG5hbWU6IGRlcHJlY2F0ZWRQYXRobmFtZSxcbiAgICAgICAgcXVlcnk6IGRlcHJlY2F0ZWRRdWVyeSxcbiAgICAgICAgc3RhdGU6IGxvY2F0aW9uXG4gICAgICB9O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVkaXJlY3RJbmZvID0gbG9jYXRpb247XG4gIH1cblxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShsZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIGl0ZXIoaW5kZXgsIHJlcGxhY2UsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykge1xuICAgICAgICBkb25lKGVycm9yLCByZWRpcmVjdEluZm8pOyAvLyBObyBuZWVkIHRvIGNvbnRpbnVlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25FbnRlciBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXG4gKiB3aXRoIG9uRW50ZXIobmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RJbmZvKSB3aGVuIGZpbmlzaGVkLiBUaGUgZmlyc3QgaG9va1xuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXG4gKlxuICogSWYgYSBob29rIG5lZWRzIHRvIHJ1biBhc3luY2hyb25vdXNseSwgaXQgbWF5IHVzZSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXG4gKi9cbmZ1bmN0aW9uIHJ1bkVudGVySG9va3Mocm91dGVzLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldEVudGVySG9va3Mocm91dGVzKTtcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xuICAgIGhvb2tzW2luZGV4XShuZXh0U3RhdGUsIHJlcGxhY2UsIG5leHQpO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25DaGFuZ2UgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkNoYW5nZShwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5DaGFuZ2VIb29rcyhyb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldENoYW5nZUhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICBob29rc1tpbmRleF0oc3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgbmV4dCk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkxlYXZlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHJ1bkxlYXZlSG9va3Mocm91dGVzLCBwcmV2U3RhdGUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChyb3V0ZXNbaV0ub25MZWF2ZSkgcm91dGVzW2ldLm9uTGVhdmUuY2FsbChyb3V0ZXNbaV0sIHByZXZTdGF0ZSk7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1RyYW5zaXRpb25VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goZnVuY3Rpb24gKG1pZGRsZXdhcmUsIGluZGV4KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShtaWRkbGV3YXJlLnJlbmRlclJvdXRlckNvbnRleHQgfHwgbWlkZGxld2FyZS5yZW5kZXJSb3V0ZUNvbXBvbmVudCwgJ1RoZSBtaWRkbGV3YXJlIHNwZWNpZmllZCBhdCBpbmRleCAnICsgaW5kZXggKyAnIGRvZXMgbm90IGFwcGVhciB0byBiZSAnICsgJ2EgdmFsaWQgUmVhY3QgUm91dGVyIG1pZGRsZXdhcmUuJykgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2l0aENvbnRleHQgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZXJDb250ZXh0O1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIHZhciB3aXRoQ29tcG9uZW50ID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmUucmVuZGVyUm91dGVDb21wb25lbnQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICB2YXIgbWFrZUNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBtYWtlQ3JlYXRlRWxlbWVudCgpIHtcbiAgICB2YXIgYmFzZUNyZWF0ZUVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBfcmVhY3QuY3JlYXRlRWxlbWVudCA6IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiB3aXRoQ29tcG9uZW50LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclJvdXRlQ29tcG9uZW50KHByZXZpb3VzLCBwcm9wcyk7XG4gICAgICB9LCBiYXNlQ3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHdpdGhDb250ZXh0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVyQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlbmRlclJvdXRlckNvbnRleHQocHJldmlvdXMsIHJlbmRlclByb3BzKTtcbiAgICB9LCBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgX2V4dGVuZHMoe30sIHJlbmRlclByb3BzLCB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBtYWtlQ3JlYXRlRWxlbWVudChyZW5kZXJQcm9wcy5jcmVhdGVFbGVtZW50KVxuICAgIH0pKSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVCcm93c2VySGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUJyb3dzZXJIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5mdW5jdGlvbiByb3V0ZVBhcmFtc0NoYW5nZWQocm91dGUsIHByZXZTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBwYXJhbU5hbWVzID0gKDAsIF9QYXR0ZXJuVXRpbHMuZ2V0UGFyYW1OYW1lcykocm91dGUucGF0aCk7XG5cbiAgcmV0dXJuIHBhcmFtTmFtZXMuc29tZShmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgcmV0dXJuIHByZXZTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXSAhPT0gbmV4dFN0YXRlLnBhcmFtc1twYXJhbU5hbWVdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB7IGxlYXZlUm91dGVzLCBjaGFuZ2VSb3V0ZXMsIGVudGVyUm91dGVzIH0gZGV0ZXJtaW5lZCBieVxuICogdGhlIGNoYW5nZSBmcm9tIHByZXZTdGF0ZSB0byBuZXh0U3RhdGUuIFdlIGxlYXZlIHJvdXRlcyBpZiBlaXRoZXJcbiAqIDEpIHRoZXkgYXJlIG5vdCBpbiB0aGUgbmV4dCBzdGF0ZSBvciAyKSB0aGV5IGFyZSBpbiB0aGUgbmV4dCBzdGF0ZVxuICogYnV0IHRoZWlyIHBhcmFtcyBoYXZlIGNoYW5nZWQgKGkuZS4gL3VzZXJzLzEyMyA9PiAvdXNlcnMvNDU2KS5cbiAqXG4gKiBsZWF2ZVJvdXRlcyBhcmUgb3JkZXJlZCBzdGFydGluZyBhdCB0aGUgbGVhZiByb3V0ZSBvZiB0aGUgdHJlZVxuICogd2UncmUgbGVhdmluZyB1cCB0byB0aGUgY29tbW9uIHBhcmVudCByb3V0ZS4gZW50ZXJSb3V0ZXMgYXJlIG9yZGVyZWRcbiAqIGZyb20gdGhlIHRvcCBvZiB0aGUgdHJlZSB3ZSdyZSBlbnRlcmluZyBkb3duIHRvIHRoZSBsZWFmIHJvdXRlLlxuICpcbiAqIGNoYW5nZVJvdXRlcyBhcmUgYW55IHJvdXRlcyB0aGF0IGRpZG4ndCBsZWF2ZSBvciBlbnRlciBkdXJpbmdcbiAqIHRoZSB0cmFuc2l0aW9uLlxuICovXG5mdW5jdGlvbiBjb21wdXRlQ2hhbmdlZFJvdXRlcyhwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xuICB2YXIgcHJldlJvdXRlcyA9IHByZXZTdGF0ZSAmJiBwcmV2U3RhdGUucm91dGVzO1xuICB2YXIgbmV4dFJvdXRlcyA9IG5leHRTdGF0ZS5yb3V0ZXM7XG5cbiAgdmFyIGxlYXZlUm91dGVzID0gdm9pZCAwLFxuICAgICAgY2hhbmdlUm91dGVzID0gdm9pZCAwLFxuICAgICAgZW50ZXJSb3V0ZXMgPSB2b2lkIDA7XG4gIGlmIChwcmV2Um91dGVzKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnRJc0xlYXZpbmcgPSBmYWxzZTtcbiAgICAgIGxlYXZlUm91dGVzID0gcHJldlJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChwYXJlbnRJc0xlYXZpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaXNMZWF2aW5nID0gbmV4dFJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTEgfHwgcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgaWYgKGlzTGVhdmluZykgcGFyZW50SXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaXNMZWF2aW5nO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gb25MZWF2ZSBob29rcyBzdGFydCBhdCB0aGUgbGVhZiByb3V0ZS5cbiAgICAgIGxlYXZlUm91dGVzLnJldmVyc2UoKTtcblxuICAgICAgZW50ZXJSb3V0ZXMgPSBbXTtcbiAgICAgIGNoYW5nZVJvdXRlcyA9IFtdO1xuXG4gICAgICBuZXh0Um91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHZhciBpc05ldyA9IHByZXZSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuICAgICAgICB2YXIgcGFyYW1zQ2hhbmdlZCA9IGxlYXZlUm91dGVzLmluZGV4T2Yocm91dGUpICE9PSAtMTtcblxuICAgICAgICBpZiAoaXNOZXcgfHwgcGFyYW1zQ2hhbmdlZCkgZW50ZXJSb3V0ZXMucHVzaChyb3V0ZSk7ZWxzZSBjaGFuZ2VSb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGxlYXZlUm91dGVzID0gW107XG4gICAgY2hhbmdlUm91dGVzID0gW107XG4gICAgZW50ZXJSb3V0ZXMgPSBuZXh0Um91dGVzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWF2ZVJvdXRlczogbGVhdmVSb3V0ZXMsXG4gICAgY2hhbmdlUm91dGVzOiBjaGFuZ2VSb3V0ZXMsXG4gICAgZW50ZXJSb3V0ZXM6IGVudGVyUm91dGVzXG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvbXB1dGVDaGFuZ2VkUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24gPSByZXF1aXJlKCcuL21ha2VTdGF0ZVdpdGhMb2NhdGlvbicpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlU3RhdGVXaXRoTG9jYXRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzRm9yUm91dGUobmV4dFN0YXRlLCByb3V0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNvbXBvbmVudCB8fCByb3V0ZS5jb21wb25lbnRzKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXRDb21wb25lbnQgPSByb3V0ZS5nZXRDb21wb25lbnQgfHwgcm91dGUuZ2V0Q29tcG9uZW50cztcbiAgaWYgKCFnZXRDb21wb25lbnQpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsb2NhdGlvbiA9IG5leHRTdGF0ZS5sb2NhdGlvbjtcblxuICB2YXIgbmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKG5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gIGdldENvbXBvbmVudC5jYWxsKHJvdXRlLCBuZXh0U3RhdGVXaXRoTG9jYXRpb24sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBmZXRjaGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgdGhlIGdpdmVuIHJvdXRlclxuICogc3RhdGUgYW5kIGNhbGxzIGNhbGxiYWNrKGVycm9yLCBjb21wb25lbnRzKSB3aGVuIGZpbmlzaGVkLlxuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENvbXBvbmVudHMgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgKDAsIF9Bc3luY1V0aWxzLm1hcEFzeW5jKShuZXh0U3RhdGUucm91dGVzLCBmdW5jdGlvbiAocm91dGUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjayk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Q29tcG9uZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbi8qKlxuICogRXh0cmFjdHMgYW4gb2JqZWN0IG9mIHBhcmFtcyB0aGUgZ2l2ZW4gcm91dGUgY2FyZXMgYWJvdXQgZnJvbVxuICogdGhlIGdpdmVuIHBhcmFtcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdXRlUGFyYW1zKHJvdXRlLCBwYXJhbXMpIHtcbiAgdmFyIHJvdXRlUGFyYW1zID0ge307XG5cbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gcm91dGVQYXJhbXM7XG5cbiAgKDAsIF9QYXR0ZXJuVXRpbHMuZ2V0UGFyYW1OYW1lcykocm91dGUucGF0aCkuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwKSkge1xuICAgICAgcm91dGVQYXJhbXNbcF0gPSBwYXJhbXNbcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVQYXJhbXM7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFJvdXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWN0aXZlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSkpID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIHAgaW4gYSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgcCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhW3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGJbcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChhW3BdLCBiW3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHBhdGhuYW1lIG1hdGNoZXMgdGhlIHN1cHBsaWVkIG9uZSwgbmV0IG9mXG4gKiBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaCBub3JtYWxpemF0aW9uLiBUaGlzIGlzIHN1ZmZpY2llbnQgZm9yIGFuXG4gKiBpbmRleE9ubHkgcm91dGUgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIHBhdGhJc0FjdGl2ZShwYXRobmFtZSwgY3VycmVudFBhdGhuYW1lKSB7XG4gIC8vIE5vcm1hbGl6ZSBsZWFkaW5nIHNsYXNoIGZvciBjb25zaXN0ZW5jeS4gTGVhZGluZyBzbGFzaCBvbiBwYXRobmFtZSBoYXNcbiAgLy8gYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgaW4gaXNBY3RpdmUuIFNlZSBjYXZlYXQgdGhlcmUuXG4gIGlmIChjdXJyZW50UGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBjdXJyZW50UGF0aG5hbWUgPSAnLycgKyBjdXJyZW50UGF0aG5hbWU7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgdGhlIGVuZCBvZiBib3RoIHBhdGggbmFtZXMgdG9vLiBNYXliZSBgL2Zvby9gIHNob3VsZG4ndCBzaG93XG4gIC8vIGAvZm9vYCBhcyBhY3RpdmUsIGJ1dCBpbiB0aGlzIGNhc2UsIHdlIHdvdWxkIGFscmVhZHkgaGF2ZSBmYWlsZWQgdGhlXG4gIC8vIG1hdGNoLlxuICBpZiAocGF0aG5hbWUuY2hhckF0KHBhdGhuYW1lLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICBwYXRobmFtZSArPSAnLyc7XG4gIH1cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoY3VycmVudFBhdGhuYW1lLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICBjdXJyZW50UGF0aG5hbWUgKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRQYXRobmFtZSA9PT0gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRobmFtZSBtYXRjaGVzIHRoZSBhY3RpdmUgcm91dGVzIGFuZCBwYXJhbXMuXG4gKi9cbmZ1bmN0aW9uIHJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSB7XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLFxuICAgICAgcGFyYW1OYW1lcyA9IFtdLFxuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcblxuICAvLyBmb3IuLi5vZiB3b3VsZCB3b3JrIGhlcmUgYnV0IGl0J3MgcHJvYmFibHkgc2xvd2VyIHBvc3QtdHJhbnNwaWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICAgIHBhcmFtVmFsdWVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsICYmIHBhdHRlcm4pIHtcbiAgICAgIHZhciBtYXRjaGVkID0gKDAsIF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKShwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09ICcnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gZXhhY3QgbWF0Y2ggb24gdGhlIHJvdXRlLiBKdXN0IGNoZWNrIHRoYXQgYWxsIHRoZSBwYXJhbXNcbiAgICAgICAgLy8gbWF0Y2guXG4gICAgICAgIC8vIEZJWE1FOiBUaGlzIGRvZXNuJ3Qgd29yayBvbiByZXBlYXRlZCBwYXJhbXMuXG4gICAgICAgIHJldHVybiBwYXJhbU5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbVZhbHVlc1tpbmRleF0pID09PSBTdHJpbmcocGFyYW1zW3BhcmFtTmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFsbCBrZXkvdmFsdWUgcGFpcnMgaW4gdGhlIGdpdmVuIHF1ZXJ5IGFyZVxuICogY3VycmVudGx5IGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gcXVlcnlJc0FjdGl2ZShxdWVyeSwgYWN0aXZlUXVlcnkpIHtcbiAgaWYgKGFjdGl2ZVF1ZXJ5ID09IG51bGwpIHJldHVybiBxdWVyeSA9PSBudWxsO1xuXG4gIGlmIChxdWVyeSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICByZXR1cm4gZGVlcEVxdWFsKHF1ZXJ5LCBhY3RpdmVRdWVyeSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgPExpbms+IHRvIHRoZSBnaXZlbiBwYXRobmFtZS9xdWVyeSBjb21iaW5hdGlvbiBpc1xuICogY3VycmVudGx5IGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNBY3RpdmUoX3JlZiwgaW5kZXhPbmx5LCBjdXJyZW50TG9jYXRpb24sIHJvdXRlcywgcGFyYW1zKSB7XG4gIHZhciBwYXRobmFtZSA9IF9yZWYucGF0aG5hbWU7XG4gIHZhciBxdWVyeSA9IF9yZWYucXVlcnk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBhIGJpdCB1Z2x5LiBJdCBrZWVwcyBhcm91bmQgc3VwcG9ydCBmb3IgdHJlYXRpbmcgcGF0aG5hbWVzXG4gIC8vIHdpdGhvdXQgcHJlY2VkaW5nIHNsYXNoZXMgYXMgYWJzb2x1dGUgcGF0aHMsIGJ1dCBwb3NzaWJseSBhbHNvIHdvcmtzXG4gIC8vIGFyb3VuZCB0aGUgc2FtZSBxdWlya3Mgd2l0aCBiYXNlbmFtZXMgYXMgaW4gbWF0Y2hSb3V0ZXMuXG4gIGlmIChwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH1cblxuICBpZiAoIXBhdGhJc0FjdGl2ZShwYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgIC8vIFRoZSBwYXRoIGNoZWNrIGlzIG5lY2Vzc2FyeSBhbmQgc3VmZmljaWVudCBmb3IgaW5kZXhPbmx5LCBidXQgb3RoZXJ3aXNlXG4gICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBjaGVjayB0aGUgcm91dGVzLlxuICAgIGlmIChpbmRleE9ubHkgfHwgIXJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBjdXJyZW50TG9jYXRpb24ucXVlcnkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUm91dGVyVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlclV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyoqXG4gKiBBIGhpZ2gtbGV2ZWwgQVBJIHRvIGJlIHVzZWQgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1hdGNoZXMgYSBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgcmVuZGVyUHJvcHMpIHdoZW4gZmluaXNoZWQuXG4gKlxuICogTm90ZTogWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgaW4gYSBicm93c2VyIHVubGVzcyB5b3UncmUgdXNpbmdcbiAqIHNlcnZlci1zaWRlIHJlbmRlcmluZyB3aXRoIGFzeW5jIHJvdXRlcy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goX3JlZiwgY2FsbGJhY2spIHtcbiAgdmFyIGhpc3RvcnkgPSBfcmVmLmhpc3Rvcnk7XG4gIHZhciByb3V0ZXMgPSBfcmVmLnJvdXRlcztcbiAgdmFyIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbjtcblxuICB2YXIgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2hpc3RvcnknLCAncm91dGVzJywgJ2xvY2F0aW9uJ10pO1xuXG4gICEoaGlzdG9yeSB8fCBsb2NhdGlvbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnbWF0Y2ggbmVlZHMgYSBoaXN0b3J5IG9yIGEgbG9jYXRpb24nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaGlzdG9yeSA9IGhpc3RvcnkgPyBoaXN0b3J5IDogKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykocm91dGVzKSk7XG5cbiAgdmFyIHVubGlzdGVuID0gdm9pZCAwO1xuXG4gIGlmIChsb2NhdGlvbikge1xuICAgIC8vIEFsbG93IG1hdGNoKHsgbG9jYXRpb246ICcvdGhlL3BhdGgnLCAuLi4gfSlcbiAgICBsb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIFBpY2sgdXAgdGhlIGxvY2F0aW9uIGZyb20gdGhlIGhpc3RvcnkgdmlhIHN5bmNocm9ub3VzIGhpc3RvcnkubGlzdGVuXG4gICAgLy8gY2FsbCBpZiBuZWVkZWQuXG4gICAgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoaGlzdG9yeUxvY2F0aW9uKSB7XG4gICAgICBsb2NhdGlvbiA9IGhpc3RvcnlMb2NhdGlvbjtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByb3V0ZXIgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdCkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICBoaXN0b3J5ID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0aW5nSGlzdG9yeSkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gIHRyYW5zaXRpb25NYW5hZ2VyLm1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUgJiYgX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogcm91dGVyLFxuICAgICAgbWF0Y2hDb250ZXh0OiB7IGhpc3Rvcnk6IGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfVxuICAgIH0pKTtcblxuICAgIC8vIERlZmVyIHJlbW92aW5nIHRoZSBsaXN0ZW5lciB0byBoZXJlIHRvIHByZXZlbnQgRE9NIGhpc3RvcmllcyBmcm9tIGhhdmluZ1xuICAgIC8vIHRvIHVud2luZCBET00gZXZlbnQgbGlzdGVuZXJzIHVubmVjZXNzYXJpbHksIGluIGNhc2UgY2FsbGJhY2sgcmVuZGVycyBhXG4gICAgLy8gPFJvdXRlcj4gYW5kIGF0dGFjaGVzIGFub3RoZXIgaGlzdG9yeSBsaXN0ZW5lci5cbiAgICBpZiAodW5saXN0ZW4pIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21hdGNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaFJvdXRlcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uID0gcmVxdWlyZSgnLi9tYWtlU3RhdGVXaXRoTG9jYXRpb24nKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFrZVN0YXRlV2l0aExvY2F0aW9uKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgcmV0dXJuIFtudWxsLCByb3V0ZS5jaGlsZFJvdXRlc107XG4gIH1cbiAgaWYgKCFyb3V0ZS5nZXRDaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBzeW5jID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IHZvaWQgMDtcblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gIH07XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkocGFydGlhbE5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gIHJvdXRlLmdldENoaWxkUm91dGVzKHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICBjaGlsZFJvdXRlcyA9ICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShjaGlsZFJvdXRlcyk7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHJlc3VsdCA9IFtlcnJvciwgY2hpbGRSb3V0ZXNdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycm9yLCBjaGlsZFJvdXRlcyk7XG4gIH0pO1xuXG4gIHN5bmMgPSBmYWxzZTtcbiAgcmV0dXJuIHJlc3VsdDsgLy8gTWlnaHQgYmUgdW5kZWZpbmVkLlxufVxuXG5mdW5jdGlvbiBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5pbmRleFJvdXRlKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuaW5kZXhSb3V0ZSk7XG4gIH0gZWxzZSBpZiAocm91dGUuZ2V0SW5kZXhSb3V0ZSkge1xuICAgIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gICAgfTtcblxuICAgIHZhciBwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKHBhcnRpYWxOZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICAgIHJvdXRlLmdldEluZGV4Um91dGUocGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgIWVycm9yICYmICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGluZGV4Um91dGUpWzBdKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aGxlc3MgPSByb3V0ZS5jaGlsZFJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkUm91dGUpIHtcbiAgICAgICAgcmV0dXJuICFjaGlsZFJvdXRlLnBhdGg7XG4gICAgICB9KTtcblxuICAgICAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocGF0aGxlc3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShwYXRobGVzc1tpbmRleF0sIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yIHx8IGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZXMgPSBbcGF0aGxlc3NbaW5kZXhdXS5jb25jYXQoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSA/IGluZGV4Um91dGUgOiBbaW5kZXhSb3V0ZV0pO1xuICAgICAgICAgICAgZG9uZShlcnJvciwgcm91dGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyLCByb3V0ZXMpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcm91dGVzKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25QYXJhbXMocGFyYW1zLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gcGFyYW1OYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcGFyYW1OYW1lLCBpbmRleCkge1xuICAgIHZhciBwYXJhbVZhbHVlID0gcGFyYW1WYWx1ZXMgJiYgcGFyYW1WYWx1ZXNbaW5kZXhdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zW3BhcmFtTmFtZV0pKSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXS5wdXNoKHBhcmFtVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBbcGFyYW1zW3BhcmFtTmFtZV0sIHBhcmFtVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKSB7XG4gIHJldHVybiBhc3NpZ25QYXJhbXMoe30sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZURlZXAocm91dGUsIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgIHBhcmFtVmFsdWVzID0gW107XG4gIH1cblxuICAvLyBPbmx5IHRyeSB0byBtYXRjaCB0aGUgcGF0aCBpZiB0aGUgcm91dGUgYWN0dWFsbHkgaGFzIGEgcGF0dGVybiwgYW5kIGlmXG4gIC8vIHdlJ3JlIG5vdCBqdXN0IHNlYXJjaGluZyBmb3IgcG90ZW50aWFsIG5lc3RlZCBhYnNvbHV0ZSBwYXRocy5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsICYmIHBhdHRlcm4pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBCeSBhc3N1bXB0aW9uLCBwYXR0ZXJuIGlzIG5vbi1lbXB0eSBoZXJlLCB3aGljaCBpcyB0aGUgcHJlcmVxdWlzaXRlIGZvclxuICAgIC8vIGFjdHVhbGx5IHRlcm1pbmF0aW5nIGEgbWF0Y2guXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSAnJykge1xuICAgICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgICAgcm91dGVzOiBbcm91dGVdLFxuICAgICAgICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICAgICAgICB9O1xuXG4gICAgICAgIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4Um91dGUpKSB7XG4gICAgICAgICAgICAgIHZhciBfbWF0Y2gkcm91dGVzO1xuXG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGluZGV4Um91dGUuZXZlcnkoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFyb3V0ZS5wYXRoO1xuICAgICAgICAgICAgICB9KSwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgKF9tYXRjaCRyb3V0ZXMgPSBtYXRjaC5yb3V0ZXMpLnB1c2guYXBwbHkoX21hdGNoJHJvdXRlcywgaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoIWluZGV4Um91dGUucGF0aCwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgbWF0Y2gucm91dGVzLnB1c2goaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0MikpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT0gbnVsbCB8fCByb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIC8vIEVpdGhlciBhKSB0aGlzIHJvdXRlIG1hdGNoZWQgYXQgbGVhc3Qgc29tZSBvZiB0aGUgcGF0aCBvciBiKVxuICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gbG9hZCB0aGlzIHJvdXRlJ3MgY2hpbGRyZW4gYXN5bmNocm9ub3VzbHkuIEluXG4gICAgLy8gZWl0aGVyIGNhc2UgY29udGludWUgY2hlY2tpbmcgZm9yIG1hdGNoZXMgaW4gdGhlIHN1YnRyZWUuXG4gICAgdmFyIG9uQ2hpbGRSb3V0ZXMgPSBmdW5jdGlvbiBvbkNoaWxkUm91dGVzKGVycm9yLCBjaGlsZFJvdXRlcykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRSb3V0ZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGNoaWxkIHJvdXRlcyB0byBzZWUgaWYgYW55IG9mIHRoZW0gbWF0Y2guXG4gICAgICAgIG1hdGNoUm91dGVzKGNoaWxkUm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEEgY2hpbGQgcm91dGUgbWF0Y2hlZCEgQXVnbWVudCB0aGUgbWF0Y2ggYW5kIHBhc3MgaXQgdXAgdGhlIHN0YWNrLlxuICAgICAgICAgICAgbWF0Y2gucm91dGVzLnVuc2hpZnQocm91dGUpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRDaGlsZFJvdXRlcyhyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBvbkNoaWxkUm91dGVzKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBvbkNoaWxkUm91dGVzLmFwcGx5KHVuZGVmaW5lZCwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IG1hdGNoZXMgdGhlIGdpdmVuIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCBzdGF0ZSkgd2hlbiBmaW5pc2hlZC4gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIHJvdXRlcyAgICAgICBBbiBhcnJheSBvZiByb3V0ZXMgdGhhdCBtYXRjaGVkLCBpbiBoaWVyYXJjaGljYWwgb3JkZXJcbiAqIC0gcGFyYW1zICAgICAgIEFuIG9iamVjdCBvZiBVUkwgcGFyYW1ldGVyc1xuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENoaWxkUm91dGVzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbiwgY2FsbGJhY2ssIHJlbWFpbmluZ1BhdGhuYW1lKSB7XG4gIHZhciBwYXJhbU5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbNF07XG4gIHZhciBwYXJhbVZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNSB8fCBhcmd1bWVudHNbNV0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzVdO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBhIGxpdHRsZSBiaXQgdWdseSwgYnV0IGl0IHdvcmtzIGFyb3VuZCBhIHF1aXJrIGluIGhpc3RvcnlcbiAgICAvLyB0aGF0IHN0cmlwcyB0aGUgbGVhZGluZyBzbGFzaCBmcm9tIHBhdGhuYW1lcyB3aGVuIHVzaW5nIGJhc2VuYW1lcyB3aXRoXG4gICAgLy8gdHJhaWxpbmcgc2xhc2hlcy5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiAnLycgKyBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIH1cblxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShyb3V0ZXMubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICBtYXRjaFJvdXRlRGVlcChyb3V0ZXNbaW5kZXhdLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIG1hdGNoKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgbWF0Y2gpIHtcbiAgICAgICAgZG9uZShlcnJvciwgbWF0Y2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBjYWxsYmFjayk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21hdGNoUm91dGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBhYm91dCByb3V0aW5nLlxuICpcbiAqIEVuaGFuY2VzIGhpc3Rvcnkgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqXG4gKiAtIGxpc3RlbigoZXJyb3IsIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgKG5leHRMb2NhdGlvbikgPT4ge30pXG4gKiAtIG1hdGNoKGxvY2F0aW9uLCAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5PWZhbHNlKVxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZXMoY3JlYXRlSGlzdG9yeSkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2B1c2VSb3V0ZXNgIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciByb3V0ZXMgPSBfcmVmLnJvdXRlcztcblxuICAgIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsncm91dGVzJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKG9wdGlvbnMpO1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksIHJvdXRlcyk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHdpdGhSb3V0ZXI7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG5mdW5jdGlvbiB3aXRoUm91dGVyKFdyYXBwZWRDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHdpdGhSZWYgPSBvcHRpb25zICYmIG9wdGlvbnMud2l0aFJlZjtcblxuICB2YXIgV2l0aFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdXaXRoUm91dGVyJyxcblxuICAgIGNvbnRleHRUeXBlczogeyByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGUgfSxcbiAgICBwcm9wVHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG5cbiAgICBnZXRXcmFwcGVkSW5zdGFuY2U6IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICF3aXRoUmVmID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ2B7IHdpdGhSZWY6IHRydWUgfWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgd2l0aFJvdXRlcigpIGNhbGwuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnByb3BzLnJvdXRlciB8fCB0aGlzLmNvbnRleHQucm91dGVyO1xuICAgICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgcm91dGVyOiByb3V0ZXIgfSk7XG5cbiAgICAgIGlmICh3aXRoUmVmKSB7XG4gICAgICAgIHByb3BzLnJlZiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgX3RoaXMud3JhcHBlZEluc3RhbmNlID0gYztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuXG4gIFdpdGhSb3V0ZXIuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XG4gIFdpdGhSb3V0ZXIuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG5cbiAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyLmRlZmF1bHQpKFdpdGhSb3V0ZXIsIFdyYXBwZWRDb21wb25lbnQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi93aXRoUm91dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5leHBvcnRzLmxvb3BBc3luYyA9IGxvb3BBc3luYztcblxuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZURPTUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZURPTUhpc3RvcnkpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgSFRNTDUncyBoaXN0b3J5IEFQSVxuICogKHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50KSB0byBtYW5hZ2UgaGlzdG9yeS5cbiAqIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZCBvZiBtYW5hZ2luZyBoaXN0b3J5IGluIGJyb3dzZXJzIGJlY2F1c2VcbiAqIGl0IHByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICpcbiAqIE5vdGU6IEluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGZ1bGxcbiAqIHBhZ2UgcmVsb2FkcyB3aWxsIGJlIHVzZWQgdG8gcHJlc2VydmUgVVJMcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGZvcmNlUmVmcmVzaCA9IG9wdGlvbnMuZm9yY2VSZWZyZXNoO1xuXG4gIHZhciBpc1N1cHBvcnRlZCA9IF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIHVzZVJlZnJlc2ggPSAhaXNTdXBwb3J0ZWQgfHwgZm9yY2VSZWZyZXNoO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB0cnkge1xuICAgICAgaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlIHx8IHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldFdpbmRvd1BhdGgoKTtcbiAgICB2YXIgX2hpc3RvcnlTdGF0ZSA9IGhpc3RvcnlTdGF0ZTtcbiAgICB2YXIga2V5ID0gX2hpc3RvcnlTdGF0ZS5rZXk7XG5cbiAgICB2YXIgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGtleSkge1xuICAgICAgc3RhdGUgPSBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuXG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgaGlzdG9yeVN0YXRlLCB7IGtleToga2V5IH0pLCBudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihfcmVmKSB7XG4gICAgdmFyIHRyYW5zaXRpb25UbyA9IF9yZWYudHJhbnNpdGlvblRvO1xuXG4gICAgZnVuY3Rpb24gcG9wU3RhdGVMaXN0ZW5lcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cblxuICAgICAgdHJhbnNpdGlvblRvKGdldEN1cnJlbnRMb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICAgIH1cblxuICAgIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgcG9wU3RhdGVMaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncG9wc3RhdGUnLCBwb3BTdGF0ZUxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhbnNpdGlvbihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICAgIHZhciBhY3Rpb24gPSBsb2NhdGlvbi5hY3Rpb247XG4gICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUoa2V5LCBzdGF0ZSk7XG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG4gICAgdmFyIGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgIGtleToga2V5XG4gICAgfTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGlmICh1c2VSZWZyZXNoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcGF0aDtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQcmV2ZW50IGxvY2F0aW9uIHVwZGF0ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgbnVsbCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUkVQTEFDRVxuICAgICAgaWYgKHVzZVJlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocGF0aCk7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gUHJldmVudCBsb2NhdGlvbiB1cGRhdGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlRE9NSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZVxuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIGhpc3RvcnkucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBoaXN0b3J5LnVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcblxuICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICByZWdpc3RlclRyYW5zaXRpb25Ib29rOiByZWdpc3RlclRyYW5zaXRpb25Ib29rLFxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKCkge1xuICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnLycgOiBhcmd1bWVudHNbMF07XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBfZm91cnRoQXJnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1szXTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGNyZWF0ZUxvY2F0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhICcgKyAnbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgYWN0aW9uID0ga2V5IHx8IF9BY3Rpb25zLlBPUDtcbiAgICBrZXkgPSBfZm91cnRoQXJnO1xuICB9XG5cbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoIHx8ICcnO1xuICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2ggfHwgJyc7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlIHx8IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAga2V5OiBrZXlcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlTG9jYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVMb2NhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnN0YXRlO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGVudHJ5KSB7XG4gICAgbWVtb1tlbnRyeS5rZXldID0gZW50cnkuc3RhdGU7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IG9wdGlvbnMgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBbb3B0aW9uc10gfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogc2F2ZVN0YXRlLFxuICAgIGdvOiBnb1xuICB9KSk7XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGVudHJpZXMgPSBfb3B0aW9ucy5lbnRyaWVzO1xuICB2YXIgY3VycmVudCA9IF9vcHRpb25zLmN1cnJlbnQ7XG5cbiAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnc3RyaW5nJykge1xuICAgIGVudHJpZXMgPSBbZW50cmllc107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICBlbnRyaWVzID0gWycvJ107XG4gIH1cblxuICBlbnRyaWVzID0gZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykgcmV0dXJuIHsgcGF0aG5hbWU6IGVudHJ5LCBrZXk6IGtleSB9O1xuXG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ29iamVjdCcgJiYgZW50cnkpIHJldHVybiBfZXh0ZW5kcyh7fSwgZW50cnksIHsga2V5OiBrZXkgfSk7XG5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ1VuYWJsZSB0byBjcmVhdGUgaGlzdG9yeSBlbnRyeSBmcm9tICVzJywgZW50cnkpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH0pO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICBjdXJyZW50ID0gZW50cmllcy5sZW5ndGggLSAxO1xuICB9IGVsc2Uge1xuICAgICEoY3VycmVudCA+PSAwICYmIGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0N1cnJlbnQgaW5kZXggbXVzdCBiZSA+PSAwIGFuZCA8ICVzLCB3YXMgJXMnLCBlbnRyaWVzLmxlbmd0aCwgY3VycmVudCkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBzdG9yYWdlID0gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpO1xuXG4gIGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gICAgc3RvcmFnZVtrZXldID0gc3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2N1cnJlbnRdO1xuICAgIHZhciBiYXNlbmFtZSA9IGVudHJ5LmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGVudHJ5LnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBlbnRyeS5zZWFyY2g7XG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIChzZWFyY2ggfHwgJycpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGVudHJ5LmtleSkge1xuICAgICAga2V5ID0gZW50cnkua2V5O1xuICAgICAgc3RhdGUgPSByZWFkU3RhdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgaW5kZXggPSBjdXJyZW50ICsgbjtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIGlmIChuKSB7XG4gICAgICBpZiAoIWNhbkdvKG4pKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0Nhbm5vdCBnbyglcykgdGhlcmUgaXMgbm90IGVub3VnaCBoaXN0b3J5JywgbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCArPSBuO1xuXG4gICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG5cbiAgICAgIC8vIGNoYW5nZSBhY3Rpb24gdG8gUE9QXG4gICAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7IGFjdGlvbjogX0FjdGlvbnMuUE9QIH0pKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgc3dpdGNoIChsb2NhdGlvbi5hY3Rpb24pIHtcbiAgICAgIGNhc2UgX0FjdGlvbnMuUFVTSDpcbiAgICAgICAgY3VycmVudCArPSAxO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgb24gdGhlIHRvcCBvZiBzdGFja1xuICAgICAgICAvLyByZW1vdmUgcmVzdCBhbmQgcHVzaCBuZXdcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgZW50cmllcy5zcGxpY2UoY3VycmVudCk7XG5cbiAgICAgICAgZW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX0FjdGlvbnMuUkVQTEFDRTpcbiAgICAgICAgZW50cmllc1tjdXJyZW50XSA9IGxvY2F0aW9uO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRyZXR1cm4gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XG5cdFx0dmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcblx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuXHRcdHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkO1xuXG5cdFx0a2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cblx0XHQvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdHJldFtrZXldLnB1c2godmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSwge30pO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiBvYmogPyBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0cmV0dXJuIHZhbC5zbGljZSgpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKHZhbDIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmljdFVyaUVuY29kZShrZXkpICsgJz0nICsgc3RyaWN0VXJpRW5jb2RlKHZhbDIpO1xuXHRcdFx0fSkuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuXHR9KS5qb2luKCcmJykgOiAnJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0F1dG9Gb2N1c1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSByZXF1aXJlKCcuL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZScpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNJbnB1dEV2ZW50Jyk7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGU6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0OlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIGZhbGxiYWNrIG9iamVjdCwgaWYgYW55LlxudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0OlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kIHx8IGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5yZWxlYXNlKGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMTk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlPcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKCcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoJ2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG52YXIgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSBmYWxzZTtcbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHRyeSB7XG4gICAgLy8gSUU4IHRocm93cyBcIkludmFsaWQgYXJndW1lbnQuXCIgaWYgcmVzZXR0aW5nIHNob3J0aGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IHRydWU7XG4gIH1cbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uJXMgJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lciksIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciBjaGVja1JlbmRlck1lc3NhZ2UgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgICB2YXIgb3duZXI7XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICB9XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihjb21wb25lbnQuX2RlYnVnSUQsICd1cGRhdGUgc3R5bGVzJywgc3R5bGVzKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DaGFuZ2U6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNoYW5nZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UsIHRvcExldmVsVHlwZXMudG9wQ2xpY2ssIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wSW5wdXQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgLy8gSUUxMCsgZmlyZSBpbnB1dCBldmVudHMgdG8gb2Z0ZW4sIHN1Y2ggd2hlbiBhIHBsYWNlaG9sZGVyXG4gIC8vIGNoYW5nZXMgb3Igd2hlbiBhbiBpbnB1dCB3aXRoIGEgcGxhY2Vob2xkZXIgaXMgZm9jdXNlZC5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gMTEpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XG4gIC8vIG9uIERPTSBlbGVtZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgaWYgKGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkZWxldGUgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlZmluaXRpb25cbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XG5cbiAgaWYgKGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcElucHV0KSB7XG4gICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzIChpLmUuLCBub3QgSUU4IG9yIElFOSksIHRoZSBpbnB1dCBldmVudCBpcyBleGFjdGx5XG4gICAgLy8gd2hhdCB3ZSB3YW50IHNvIGZhbGwgdGhyb3VnaCBoZXJlIGFuZCB0cmlnZ2VyIGFuIGFic3RyYWN0IGV2ZW50XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LTExLCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5VXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24pIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnZhbHVlICE9PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudEluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDbGljaykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMjAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGFuZ2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZSgnZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIERhbmdlciA9IHtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzU2JykgOiB2b2lkIDA7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IF9wcm9kSW52YXJpYW50KCc1NycpIDogdm9pZCAwO1xuICAgICEob2xkQ2hpbGQubm9kZU5hbWUgIT09ICdIVE1MJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSA8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlIGFuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogX3Byb2RJbnZhcmlhbnQoJzU4JykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EYW5nZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEVudGVyTGVhdmVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJiB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbl9hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEhUTUxET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQobmV3IFJlZ0V4cCgnXihkYXRhfGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSksXG4gIFByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWNjZXB0OiAwLFxuICAgIGFjY2VwdENoYXJzZXQ6IDAsXG4gICAgYWNjZXNzS2V5OiAwLFxuICAgIGFjdGlvbjogMCxcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGFsbG93VHJhbnNwYXJlbmN5OiAwLFxuICAgIGFsdDogMCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiAwLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogMCxcbiAgICBjZWxsU3BhY2luZzogMCxcbiAgICBjaGFyU2V0OiAwLFxuICAgIGNoYWxsZW5nZTogMCxcbiAgICBjaGVja2VkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNpdGU6IDAsXG4gICAgY2xhc3NJRDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29sU3BhbjogMCxcbiAgICBjb250ZW50OiAwLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogMCxcbiAgICBjb250ZXh0TWVudTogMCxcbiAgICBjb250cm9sczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29vcmRzOiAwLFxuICAgIGNyb3NzT3JpZ2luOiAwLFxuICAgIGRhdGE6IDAsIC8vIEZvciBgPG9iamVjdCAvPmAgYWN0cyBhcyBgc3JjYC5cbiAgICBkYXRlVGltZTogMCxcbiAgICAnZGVmYXVsdCc6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRlZmVyOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkaXI6IDAsXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogMCxcbiAgICBlbmNUeXBlOiAwLFxuICAgIGZvcm06IDAsXG4gICAgZm9ybUFjdGlvbjogMCxcbiAgICBmb3JtRW5jVHlwZTogMCxcbiAgICBmb3JtTWV0aG9kOiAwLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiAwLFxuICAgIGZyYW1lQm9yZGVyOiAwLFxuICAgIGhlYWRlcnM6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGhpZGRlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogMCxcbiAgICBocmVmOiAwLFxuICAgIGhyZWZMYW5nOiAwLFxuICAgIGh0bWxGb3I6IDAsXG4gICAgaHR0cEVxdWl2OiAwLFxuICAgIGljb246IDAsXG4gICAgaWQ6IDAsXG4gICAgaW5wdXRNb2RlOiAwLFxuICAgIGludGVncml0eTogMCxcbiAgICBpczogMCxcbiAgICBrZXlQYXJhbXM6IDAsXG4gICAga2V5VHlwZTogMCxcbiAgICBraW5kOiAwLFxuICAgIGxhYmVsOiAwLFxuICAgIGxhbmc6IDAsXG4gICAgbGlzdDogMCxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb3c6IDAsXG4gICAgbWFuaWZlc3Q6IDAsXG4gICAgbWFyZ2luSGVpZ2h0OiAwLFxuICAgIG1hcmdpbldpZHRoOiAwLFxuICAgIG1heDogMCxcbiAgICBtYXhMZW5ndGg6IDAsXG4gICAgbWVkaWE6IDAsXG4gICAgbWVkaWFHcm91cDogMCxcbiAgICBtZXRob2Q6IDAsXG4gICAgbWluOiAwLFxuICAgIG1pbkxlbmd0aDogMCxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogMCxcbiAgICBub25jZTogMCxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcHRpbXVtOiAwLFxuICAgIHBhdHRlcm46IDAsXG4gICAgcGxhY2Vob2xkZXI6IDAsXG4gICAgcG9zdGVyOiAwLFxuICAgIHByZWxvYWQ6IDAsXG4gICAgcHJvZmlsZTogMCxcbiAgICByYWRpb0dyb3VwOiAwLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWZlcnJlclBvbGljeTogMCxcbiAgICByZWw6IDAsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb2xlOiAwLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNhbmRib3g6IDAsXG4gICAgc2NvcGU6IDAsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IDAsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiAwLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiAwLFxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IDAsXG4gICAgc3JjOiAwLFxuICAgIHNyY0RvYzogMCxcbiAgICBzcmNMYW5nOiAwLFxuICAgIHNyY1NldDogMCxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogMCxcbiAgICBzdHlsZTogMCxcbiAgICBzdW1tYXJ5OiAwLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHRhcmdldDogMCxcbiAgICB0aXRsZTogMCxcbiAgICAvLyBTZXR0aW5nIC50eXBlIHRocm93cyBvbiBub24tPGlucHV0PiB0YWdzXG4gICAgdHlwZTogMCxcbiAgICB1c2VNYXA6IDAsXG4gICAgdmFsdWU6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgd21vZGU6IDAsXG4gICAgd3JhcDogMCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiAwLFxuICAgIGRhdGF0eXBlOiAwLFxuICAgIGlubGlzdDogMCxcbiAgICBwcmVmaXg6IDAsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IDAsXG4gICAgcmVzb3VyY2U6IDAsXG4gICAgJ3R5cGVvZic6IDAsXG4gICAgdm9jYWI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IDAsXG4gICAgYXV0b0NvcnJlY3Q6IDAsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IDAsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiAwLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiAwLFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IDAsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiAwLFxuICAgIGl0ZW1SZWY6IDAsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiAwXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RQdXJlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdFB1cmVDb21wb25lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmVkLCAnUmVhY3QuX19zcHJlYWQgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiBVc2UgJyArICdPYmplY3QuYXNzaWduIGRpcmVjdGx5IG9yIGFub3RoZXIgaGVscGVyIGZ1bmN0aW9uIHdpdGggc2ltaWxhciAnICsgJ3NlbWFudGljcy4gWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byB5b3VyIGNvbXBpbGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXNwcmVhZC1kZXByZWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgIHdhcm5lZCA9IHRydWU7XG4gICAgcmV0dXJuIF9hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0UHVyZUNvbXBvbmVudCxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgaXNWYWxpZEVsZW1lbnQ6IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCxcblxuICAvLyBDbGFzc2ljXG5cbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3MsXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnksXG4gIGNyZWF0ZU1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAvLyBDdXJyZW50bHkgYSBub29wLiBXaWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRyYWNlIG1peGlucy5cbiAgICByZXR1cm4gbWl4aW47XG4gIH0sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvLyBEZXByZWNhdGVkIGhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZy5cbiAgX19zcHJlYWQ6IF9fc3ByZWFkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRSZWNvbmNpbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RhbmNlcywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICB9XG4gICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcbiAgICBjaGlsZEluc3RhbmNlc1tuYW1lXSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY2hpbGQsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXG4gKiBjaGlsZHJlbi4gSXRzIG91dHB1dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpdCBvbnRvIFJlYWN0TXVsdGlDaGlsZCB3aGljaFxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxuICovXG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIH0sIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIHByZXZDaGlsZDtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbCAmJiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gcHJldkNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICAgIC8vIENyZWF0aW5nIG1vdW50IGltYWdlIG5vdyBlbnN1cmVzIHJlZnMgYXJlIHJlc29sdmVkIGluIHJpZ2h0IG9yZGVyXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzEwMSBmb3IgZXhwbGFuYXRpb24pLlxuICAgICAgICB2YXIgbmV4dENoaWxkTW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChuZXh0Q2hpbGRJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobmV4dENoaWxkTW91bnRJbWFnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHJlbmRlcmVkQ2hpbGQsIHNhZmVseSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPT09IGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlzTXV0YXRlZCA9IGZhbHNlO1xuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbikpIHtcbiAgICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4ubGVuZ3RoID09PSBlbGVtZW50LnByb3BzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW5baV0gIT09IGVsZW1lbnQucHJvcHMuY2hpbGRyZW5baV0pIHtcbiAgICAgICAgICBpc011dGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzTXV0YXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbikgfHwgaXNNdXRhdGVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdDb21wb25lbnRcXCdzIGNoaWxkcmVuIHNob3VsZCBub3QgYmUgbXV0YXRlZC4lcycsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayA9IHtcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKSk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBDb21wb3NpdGVUeXBlcyA9IHtcbiAgSW1wdXJlQ2xhc3M6IDAsXG4gIFB1cmVDbGFzczogMSxcbiAgU3RhdGVsZXNzRnVuY3Rpb25hbDogMlxufTtcblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHZhciBlbGVtZW50ID0gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcbiAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5mdW5jdGlvbiB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDb21wb25lbnREaWRNb3VudFdpdGhUaW1lcigpIHtcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgfVxuICBwdWJsaWNJbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lcihwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpIHtcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gIH1cbiAgcHVibGljSW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCk7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHRyYW5zYWN0aW9uLmdldFVwZGF0ZVF1ZXVlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgZG9Db25zdHJ1Y3QgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICBpZiAoIWRvQ29uc3RydWN0ICYmIChpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAhKGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5JbXB1cmVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIG1hcmt1cDtcbiAgICBpZiAoaW5zdC51bnN0YWJsZV9oYW5kbGVFcnJvcikge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmcocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGludm9rZUNvbXBvbmVudERpZE1vdW50V2l0aFRpbWVyLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50OiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcjogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdGFuY2VPckVsZW1lbnQ7XG4gICAgaWYgKGRvQ29uc3RydWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdGFuY2VPckVsZW1lbnQgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBjYW4gc3RpbGwgYmUgYW4gaW5zdGFuY2UgaW4gY2FzZSBvZiBmYWN0b3J5IGNvbXBvbmVudHNcbiAgICAgIC8vIGJ1dCB3ZSdsbCBjb3VudCB0aGlzIGFzIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGFzIHRoZSBtb3JlIGNvbW1vbiBjYXNlLlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdGFuY2VPckVsZW1lbnQgPSBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZU9yRWxlbWVudDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmc6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXA7XG4gICAgdmFyIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSb2xsIGJhY2sgdG8gY2hlY2twb2ludCwgaGFuZGxlIGVycm9yICh3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHRoZSB0cmFuc2FjdGlvbiksIGFuZCB0YWtlIGEgbmV3IGNoZWNrcG9pbnRcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICAgICAgdGhpcy5faW5zdGFuY2UudW5zdGFibGVfaGFuZGxlRXJyb3IoZSk7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKHRoaXMuX2luc3RhbmNlLnByb3BzLCB0aGlzLl9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LnVubW91bnRDb21wb25lbnQodHJ1ZSk7XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcblxuICAgICAgLy8gVHJ5IGFnYWluIC0gd2UndmUgaW5mb3JtZWQgdGhlIGNvbXBvbmVudCBhYm91dCB0aGUgZXJyb3IsIHNvIHRoZXkgY2FuIHJlbmRlciBhbiBlcnJvciBtZXNzYWdlIHRoaXMgdGltZS5cbiAgICAgIC8vIElmIHRoaXMgdGhyb3dzIGFnYWluLCB0aGUgZXJyb3Igd2lsbCBidWJibGUgdXAgKGFuZCBjYW4gYmUgY2F1Z2h0IGJ5IGEgaGlnaGVyIGVycm9yIGJvdW5kYXJ5KS5cbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudDogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICApO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZWxmRGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgc2VsZkRlYnVnSUQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCAmJiAhaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIGluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gdHJ1ZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNhZmVseSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpICsgJy5jb21wb25lbnRXaWxsVW5tb3VudCgpJztcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQoaW5zdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0ICYmIGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA3JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTA4JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tDb250ZXh0VHlwZXM6IGZ1bmN0aW9uICh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCB0aGlzLmdldE5hbWUoKSwgbnVsbCwgdGhpcy5fZGVidWdJRCk7XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQXR0ZW1wdGVkIHRvIHVwZGF0ZSBjb21wb25lbnQgYCVzYCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkIChvciBmYWlsZWQgdG8gbW91bnQpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEzNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdmFyIHdpbGxSZWNlaXZlID0gZmFsc2U7XG4gICAgdmFyIG5leHRDb250ZXh0O1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlByb3BzID0gcHJldlBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gTm90IGEgc2ltcGxlIHN0YXRlIHVwZGF0ZSBidXQgYSBwcm9wcyB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIGlmIChpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lci5iaW5kKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRIb3N0Tm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBmYWxzZSk7XG5cbiAgICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZWxmRGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMuX2hvc3RQYXJlbnQsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBzZWxmRGVidWdJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRkZW4gaW4gc2hhbGxvdyByZW5kZXJpbmcuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHJlbmRlcmVkQ29tcG9uZW50ID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IHRoaXMuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwOScsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzICcgKyAnKFNlZSByZWYgXCIlc1wiIGluICVzIGNyZWF0ZWQgYnkgJXMpLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJywgcmVmLCBjb21wb25lbnROYW1lLCB0aGlzLmdldE5hbWUoKSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgIHJlZnNbcmVmXSA9IHB1YmxpY0NvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0YWNoUmVmOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHJlZnMgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucmVmcztcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSBpdFxuICAgKiBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvciBudWxsLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50IC0gaS5lLiB3aGF0XG4gICAqIGlzIGV4cG9zZWQgYnkgcmVmcyBhbmQgcmV0dXJuZWQgYnkgcmVuZGVyLiBDYW4gYmUgbnVsbCBmb3Igc3RhdGVsZXNzXG4gICAqIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSB0aGUgcHVibGljIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfSxcblxuICAvLyBTdHViXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBudWxsXG5cbn07XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiBSZWFjdE1vdW50LnJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnRUcmVlOiB7XG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgLy8gaW5zdCBpcyBhbiBpbnRlcm5hbCBpbnN0YW5jZSAoYnV0IGNvdWxkIGJlIGEgY29tcG9zaXRlKVxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlclxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgaGF2ZSB0aGUgaXNzdWUgd2l0aCBkZXZ0b29scyBsb2FkZWQgb3ZlciBmaWxlOi8vXG4gICAgICAgIHZhciBzaG93RmlsZVVybE1lc3NhZ2UgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgKHNob3dGaWxlVXJsTWVzc2FnZSA/ICdhbmQgdXNlIGFuIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGEgZmlsZTogVVJMKSAnIDogJycpICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGVzdEZ1bmMgPSBmdW5jdGlvbiB0ZXN0Rm4oKSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZygodGVzdEZ1bmMubmFtZSB8fCB0ZXN0RnVuYy50b1N0cmluZygpKS5pbmRleE9mKCd0ZXN0Rm4nKSAhPT0gLTEsICdJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgJyArICdvZiBSZWFjdC4gV2hlbiBkZXBsb3lpbmcgUmVhY3QgYXBwcyB0byBwcm9kdWN0aW9uLCBtYWtlIHN1cmUgdG8gdXNlICcgKyAndGhlIHByb2R1Y3Rpb24gYnVpbGQgd2hpY2ggc2tpcHMgZGV2ZWxvcG1lbnQgd2FybmluZ3MgYW5kIGlzIGZhc3Rlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1taW5pZmljYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdm9pZCAwO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgU3RyaW5nLnByb3RvdHlwZS50cmltXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25lIG9yIG1vcmUgRVM1IHNoaW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbiAgdmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJyk7XG4gIHZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaycpO1xuXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzXG4gKiogbW9kdWxlIGlkID0gMjExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8YnV0dG9uPiBob3N0IGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSB7XG4gIGdldEhvc3RQcm9wczogRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUJ1dHRvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01CdXR0b24nKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xudmFyIGRlbGV0ZUxpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXI7XG52YXIgZ2V0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7ICdzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcbn07XG5cbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZSB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBfcHJvZEludmFyaWFudCgnNjInLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5faG9zdENvbnRhaW5lckluZm87XG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpbnN0OiBpbnN0LFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NSW5wdXQucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxudmFyIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHZhciBoYXNFeGlzdGluZ0NvbnRlbnQgPSB0aGlzLl9jb250ZW50RGVidWdJRCAhPSBudWxsO1xuICAgIHZhciBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICAvLyBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGlubGluZWQgY2hpbGQgdGhhdCBoYXMgbm8gYmFja2luZyBpbnN0YW5jZTpcbiAgICB2YXIgY29udGVudERlYnVnSUQgPSAtZGVidWdJRDtcblxuICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudCh0aGlzLl9jb250ZW50RGVidWdJRCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBjb250ZW50RGVidWdJRDtcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogX3Byb2RJbnZhcmlhbnQoJzYzJykgOiB2b2lkIDA7XG4gIHZhciBub2RlID0gZ2V0Tm9kZShpbnN0KTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzY0JykgOiB2b2lkIDA7XG5cbiAgc3dpdGNoIChpbnN0Ll90YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFJlc2V0LCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQsICdzdWJtaXQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wSW52YWxpZCwgJ2ludmFsaWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlU2VsZWN0V3JhcHBlcigpIHtcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBfcHJvZEludmFyaWFudCgnNjUnLCB0YWcpIDogdm9pZCAwO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbnZhciBnbG9iYWxJZENvdW50ZXIgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IG51bGw7XG4gICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbnVsbCk7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9SZWFjdERPTUNvbXBvbmVudH0gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBnbG9iYWxJZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcblxuICAgIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcbiAgICB2YXIgcGFyZW50VGFnO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RQYXJlbnQuX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RQYXJlbnQuX3RhZztcbiAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RDb250YWluZXJJbmZvLl9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0Q29udGFpbmVySW5mby5fdGFnO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09IG51bGwgfHwgbmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiBwYXJlbnRUYWcgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5odG1sO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzdmcnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuc3ZnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90YWcgPT09ICdtYXRoJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLm1hdGhtbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKHRoaXMuX3RhZywgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRJbmZvLCB0aGlzLl90YWcsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIGVsO1xuICAgICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPCcgKyB0eXBlICsgJz48LycgKyB0eXBlICsgJz4nO1xuICAgICAgICAgIGVsID0gZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5pcykge1xuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUsIHByb3BzLmlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY3Vhc2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICB9XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIGVsKTtcbiAgICAgIHRoaXMuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG4gICAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvclJvb3QoZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhudWxsLCBwcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUoZWwpO1xuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpO1xuICAgICAgbW91bnRJbWFnZSA9IGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcbiAgICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGlucHV0UG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRleHRhcmVhUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShvcHRpb25Qb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRJbWFnZTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gICAgfVxuICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fZG9tSUQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVIVE1MKGxhenlUcmVlLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlVGV4dChsYXp5VHJlZSwgY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91bnRJbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBtb3VudEltYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgbmV4dCBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuIERvZXMgbm90IHJlbW92ZSBmcm9tXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnM7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxuICAgICAgICAgKiBlYXNpbHkgaW4gYSBjcm9zcy1icm93c2VyIHdheSwgaG93ZXZlciBpdCdzIHZhbHVhYmxlIHRvIGJlIGFibGUgdG9cbiAgICAgICAgICogdGFrZSBhZHZhbnRhZ2Ugb2YgUmVhY3QncyByZWNvbmNpbGlhdGlvbiBmb3Igc3R5bGluZyBhbmQgPHRpdGxlPlxuICAgICAgICAgKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXG4gICAgICAgICAqL1xuICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPCVzPiB0cmllZCB0byB1bm1vdW50LiBCZWNhdXNlIG9mIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGl0IGlzIGltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhIHNpbmdsZSB0b3AtbGV2ZWwgY29tcG9uZW50IHRoYXQgbmV2ZXIgdW5tb3VudHMgcmVuZGVyIHRoZXNlIGVsZW1lbnRzLicsIHRoaXMuX3RhZykgOiBfcHJvZEludmFyaWFudCgnNjYnLCB0aGlzLl90YWcpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbihzYWZlbHkpO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgICBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnModGhpcyk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fZG9tSUQgPSAwO1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH1cblxufTtcblxuX2Fzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29udGFpbmVySW5mb1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuZnVuY3Rpb24gUmVhY3RET01Db250YWluZXJJbmZvKHRvcExldmVsV3JhcHBlciwgbm9kZSkge1xuICB2YXIgaW5mbyA9IHtcbiAgICBfdG9wTGV2ZWxXcmFwcGVyOiB0b3BMZXZlbFdyYXBwZXIsXG4gICAgX2lkQ291bnRlcjogMSxcbiAgICBfb3duZXJEb2N1bWVudDogbm9kZSA/IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgPyBub2RlIDogbm9kZS5vd25lckRvY3VtZW50IDogbnVsbCxcbiAgICBfbm9kZTogbm9kZSxcbiAgICBfdGFnOiBub2RlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbCxcbiAgICBfbmFtZXNwYWNlVVJJOiBub2RlID8gbm9kZS5uYW1lc3BhY2VVUkkgOiBudWxsXG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5mby5fYW5jZXN0b3JJbmZvID0gbm9kZSA/IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIGluZm8uX3RhZywgbnVsbCkgOiBudWxsO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29udGFpbmVySW5mbztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzXG4gKiogbW9kdWxlIGlkID0gMjE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01FbXB0eUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAvLyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCB1c2VzIHRoaXM6XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fZG9tSUQgPSAwO1xufTtcbl9hc3NpZ24oUmVhY3RET01FbXB0eUNvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIG5vZGVWYWx1ZSA9ICcgcmVhY3QtZW1wdHk6ICcgKyB0aGlzLl9kb21JRCArICcgJztcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG5vZGVWYWx1ZSk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIG5vZGUpO1xuICAgICAgcmV0dXJuIERPTUxhenlUcmVlKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCBpbnNlcnQgYSBjb21tZW50IG5vZGUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uXG4gICAgICAgIC8vIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm5cbiAgICAgICAgLy8gbm90aGluZy5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICc8IS0tJyArIG5vZGVWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUVtcHR5Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GYWN0b3JpZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKiBUaGlzIGlzIGFsc28gYWNjZXNzaWJsZSB2aWEgYFJlYWN0LkRPTWAuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSB7XG4gIGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2EnKSxcbiAgYWJicjogY3JlYXRlRE9NRmFjdG9yeSgnYWJicicpLFxuICBhZGRyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdhZGRyZXNzJyksXG4gIGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ2FyZWEnKSxcbiAgYXJ0aWNsZTogY3JlYXRlRE9NRmFjdG9yeSgnYXJ0aWNsZScpLFxuICBhc2lkZTogY3JlYXRlRE9NRmFjdG9yeSgnYXNpZGUnKSxcbiAgYXVkaW86IGNyZWF0ZURPTUZhY3RvcnkoJ2F1ZGlvJyksXG4gIGI6IGNyZWF0ZURPTUZhY3RvcnkoJ2InKSxcbiAgYmFzZTogY3JlYXRlRE9NRmFjdG9yeSgnYmFzZScpLFxuICBiZGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JkaScpLFxuICBiZG86IGNyZWF0ZURPTUZhY3RvcnkoJ2JkbycpLFxuICBiaWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2JpZycpLFxuICBibG9ja3F1b3RlOiBjcmVhdGVET01GYWN0b3J5KCdibG9ja3F1b3RlJyksXG4gIGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JvZHknKSxcbiAgYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2JyJyksXG4gIGJ1dHRvbjogY3JlYXRlRE9NRmFjdG9yeSgnYnV0dG9uJyksXG4gIGNhbnZhczogY3JlYXRlRE9NRmFjdG9yeSgnY2FudmFzJyksXG4gIGNhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2NhcHRpb24nKSxcbiAgY2l0ZTogY3JlYXRlRE9NRmFjdG9yeSgnY2l0ZScpLFxuICBjb2RlOiBjcmVhdGVET01GYWN0b3J5KCdjb2RlJyksXG4gIGNvbDogY3JlYXRlRE9NRmFjdG9yeSgnY29sJyksXG4gIGNvbGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdjb2xncm91cCcpLFxuICBkYXRhOiBjcmVhdGVET01GYWN0b3J5KCdkYXRhJyksXG4gIGRhdGFsaXN0OiBjcmVhdGVET01GYWN0b3J5KCdkYXRhbGlzdCcpLFxuICBkZDogY3JlYXRlRE9NRmFjdG9yeSgnZGQnKSxcbiAgZGVsOiBjcmVhdGVET01GYWN0b3J5KCdkZWwnKSxcbiAgZGV0YWlsczogY3JlYXRlRE9NRmFjdG9yeSgnZGV0YWlscycpLFxuICBkZm46IGNyZWF0ZURPTUZhY3RvcnkoJ2RmbicpLFxuICBkaWFsb2c6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpYWxvZycpLFxuICBkaXY6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpdicpLFxuICBkbDogY3JlYXRlRE9NRmFjdG9yeSgnZGwnKSxcbiAgZHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2R0JyksXG4gIGVtOiBjcmVhdGVET01GYWN0b3J5KCdlbScpLFxuICBlbWJlZDogY3JlYXRlRE9NRmFjdG9yeSgnZW1iZWQnKSxcbiAgZmllbGRzZXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZWxkc2V0JyksXG4gIGZpZ2NhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ2NhcHRpb24nKSxcbiAgZmlndXJlOiBjcmVhdGVET01GYWN0b3J5KCdmaWd1cmUnKSxcbiAgZm9vdGVyOiBjcmVhdGVET01GYWN0b3J5KCdmb290ZXInKSxcbiAgZm9ybTogY3JlYXRlRE9NRmFjdG9yeSgnZm9ybScpLFxuICBoMTogY3JlYXRlRE9NRmFjdG9yeSgnaDEnKSxcbiAgaDI6IGNyZWF0ZURPTUZhY3RvcnkoJ2gyJyksXG4gIGgzOiBjcmVhdGVET01GYWN0b3J5KCdoMycpLFxuICBoNDogY3JlYXRlRE9NRmFjdG9yeSgnaDQnKSxcbiAgaDU6IGNyZWF0ZURPTUZhY3RvcnkoJ2g1JyksXG4gIGg2OiBjcmVhdGVET01GYWN0b3J5KCdoNicpLFxuICBoZWFkOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkJyksXG4gIGhlYWRlcjogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZGVyJyksXG4gIGhncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnaGdyb3VwJyksXG4gIGhyOiBjcmVhdGVET01GYWN0b3J5KCdocicpLFxuICBodG1sOiBjcmVhdGVET01GYWN0b3J5KCdodG1sJyksXG4gIGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2knKSxcbiAgaWZyYW1lOiBjcmVhdGVET01GYWN0b3J5KCdpZnJhbWUnKSxcbiAgaW1nOiBjcmVhdGVET01GYWN0b3J5KCdpbWcnKSxcbiAgaW5wdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucHV0JyksXG4gIGluczogY3JlYXRlRE9NRmFjdG9yeSgnaW5zJyksXG4gIGtiZDogY3JlYXRlRE9NRmFjdG9yeSgna2JkJyksXG4gIGtleWdlbjogY3JlYXRlRE9NRmFjdG9yeSgna2V5Z2VuJyksXG4gIGxhYmVsOiBjcmVhdGVET01GYWN0b3J5KCdsYWJlbCcpLFxuICBsZWdlbmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xlZ2VuZCcpLFxuICBsaTogY3JlYXRlRE9NRmFjdG9yeSgnbGknKSxcbiAgbGluazogY3JlYXRlRE9NRmFjdG9yeSgnbGluaycpLFxuICBtYWluOiBjcmVhdGVET01GYWN0b3J5KCdtYWluJyksXG4gIG1hcDogY3JlYXRlRE9NRmFjdG9yeSgnbWFwJyksXG4gIG1hcms6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcmsnKSxcbiAgbWVudTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudScpLFxuICBtZW51aXRlbTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudWl0ZW0nKSxcbiAgbWV0YTogY3JlYXRlRE9NRmFjdG9yeSgnbWV0YScpLFxuICBtZXRlcjogY3JlYXRlRE9NRmFjdG9yeSgnbWV0ZXInKSxcbiAgbmF2OiBjcmVhdGVET01GYWN0b3J5KCduYXYnKSxcbiAgbm9zY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ25vc2NyaXB0JyksXG4gIG9iamVjdDogY3JlYXRlRE9NRmFjdG9yeSgnb2JqZWN0JyksXG4gIG9sOiBjcmVhdGVET01GYWN0b3J5KCdvbCcpLFxuICBvcHRncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnb3B0Z3JvdXAnKSxcbiAgb3B0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdvcHRpb24nKSxcbiAgb3V0cHV0OiBjcmVhdGVET01GYWN0b3J5KCdvdXRwdXQnKSxcbiAgcDogY3JlYXRlRE9NRmFjdG9yeSgncCcpLFxuICBwYXJhbTogY3JlYXRlRE9NRmFjdG9yeSgncGFyYW0nKSxcbiAgcGljdHVyZTogY3JlYXRlRE9NRmFjdG9yeSgncGljdHVyZScpLFxuICBwcmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3ByZScpLFxuICBwcm9ncmVzczogY3JlYXRlRE9NRmFjdG9yeSgncHJvZ3Jlc3MnKSxcbiAgcTogY3JlYXRlRE9NRmFjdG9yeSgncScpLFxuICBycDogY3JlYXRlRE9NRmFjdG9yeSgncnAnKSxcbiAgcnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3J0JyksXG4gIHJ1Ynk6IGNyZWF0ZURPTUZhY3RvcnkoJ3J1YnknKSxcbiAgczogY3JlYXRlRE9NRmFjdG9yeSgncycpLFxuICBzYW1wOiBjcmVhdGVET01GYWN0b3J5KCdzYW1wJyksXG4gIHNjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnc2NyaXB0JyksXG4gIHNlY3Rpb246IGNyZWF0ZURPTUZhY3RvcnkoJ3NlY3Rpb24nKSxcbiAgc2VsZWN0OiBjcmVhdGVET01GYWN0b3J5KCdzZWxlY3QnKSxcbiAgc21hbGw6IGNyZWF0ZURPTUZhY3RvcnkoJ3NtYWxsJyksXG4gIHNvdXJjZTogY3JlYXRlRE9NRmFjdG9yeSgnc291cmNlJyksXG4gIHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3NwYW4nKSxcbiAgc3Ryb25nOiBjcmVhdGVET01GYWN0b3J5KCdzdHJvbmcnKSxcbiAgc3R5bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0eWxlJyksXG4gIHN1YjogY3JlYXRlRE9NRmFjdG9yeSgnc3ViJyksXG4gIHN1bW1hcnk6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1bW1hcnknKSxcbiAgc3VwOiBjcmVhdGVET01GYWN0b3J5KCdzdXAnKSxcbiAgdGFibGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RhYmxlJyksXG4gIHRib2R5OiBjcmVhdGVET01GYWN0b3J5KCd0Ym9keScpLFxuICB0ZDogY3JlYXRlRE9NRmFjdG9yeSgndGQnKSxcbiAgdGV4dGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHRhcmVhJyksXG4gIHRmb290OiBjcmVhdGVET01GYWN0b3J5KCd0Zm9vdCcpLFxuICB0aDogY3JlYXRlRE9NRmFjdG9yeSgndGgnKSxcbiAgdGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoZWFkJyksXG4gIHRpbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpbWUnKSxcbiAgdGl0bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpdGxlJyksXG4gIHRyOiBjcmVhdGVET01GYWN0b3J5KCd0cicpLFxuICB0cmFjazogY3JlYXRlRE9NRmFjdG9yeSgndHJhY2snKSxcbiAgdTogY3JlYXRlRE9NRmFjdG9yeSgndScpLFxuICB1bDogY3JlYXRlRE9NRmFjdG9yeSgndWwnKSxcbiAgJ3Zhcic6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxuICB2aWRlbzogY3JlYXRlRE9NRmFjdG9yeSgndmlkZW8nKSxcbiAgd2JyOiBjcmVhdGVET01GYWN0b3J5KCd3YnInKSxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiBjcmVhdGVET01GYWN0b3J5KCdjaXJjbGUnKSxcbiAgY2xpcFBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ2NsaXBQYXRoJyksXG4gIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcbiAgZWxsaXBzZTogY3JlYXRlRE9NRmFjdG9yeSgnZWxsaXBzZScpLFxuICBnOiBjcmVhdGVET01GYWN0b3J5KCdnJyksXG4gIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxuICBsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdsaW5lJyksXG4gIGxpbmVhckdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdsaW5lYXJHcmFkaWVudCcpLFxuICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXG4gIHBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdGgnKSxcbiAgcGF0dGVybjogY3JlYXRlRE9NRmFjdG9yeSgncGF0dGVybicpLFxuICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXG4gIHBvbHlsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5bGluZScpLFxuICByYWRpYWxHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgncmFkaWFsR3JhZGllbnQnKSxcbiAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxuICBzdG9wOiBjcmVhdGVET01GYWN0b3J5KCdzdG9wJyksXG4gIHN2ZzogY3JlYXRlRE9NRmFjdG9yeSgnc3ZnJyksXG4gIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcbiAgdHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3RzcGFuJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GZWF0dXJlRmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFncztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlET3BlcmF0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy5cbiAqL1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50SW5zdCwgdXBkYXRlcykge1xuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UocGFyZW50SW5zdCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKG5vZGUsIHVwZGF0ZXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZExpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkIDogcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQocHJvcHMpO1xuXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgICBzdGVwOiB1bmRlZmluZWQsXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgbWF4OiB1bmRlZmluZWRcbiAgICB9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuXG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYGlucHV0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZExpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgY2hlY2tlZExpbmtgIHByb3Agb24gYGlucHV0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZExpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAoIWluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCksICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuXG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcblxuICAgIC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZS4gV2Ugd29uJ3QgZG8gYW55dGhpbmcgaWYgd2UncmUgd29ya2luZyBvblxuICAgIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gICAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gICAgLy8gcmVtb3ZlcyBicm93c2VyLWRlZmF1bHQgdmFsdWVzIChlZyBcIlN1Ym1pdCBRdWVyeVwiKSB3aGVuIG5vIHZhbHVlIGlzXG4gICAgLy8gcHJvdmlkZWQuXG5cbiAgICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICBjYXNlICdkYXRldGltZS1sb2NhbCc6XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnO1xuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gJyc7XG4gICAgfVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvdGhlck5vZGUpO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTAnKSA6IHZvaWQgMDtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01PcHRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIFJlYWN0Q2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuKSB7XG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0ge1xuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgaG9zdFBhcmVudCkge1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB3aGV0aGVyIHRoaXMgb3B0aW9uIGlzICdzZWxlY3RlZCdcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSBudWxsO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHZhciBzZWxlY3RQYXJlbnQgPSBob3N0UGFyZW50O1xuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50Ll90YWcgPT09ICdvcHRncm91cCcpIHtcbiAgICAgICAgc2VsZWN0UGFyZW50ID0gc2VsZWN0UGFyZW50Ll9ob3N0UGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50ICE9IG51bGwgJiYgc2VsZWN0UGFyZW50Ll90YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNlbGVjdFZhbHVlID0gUmVhY3RET01TZWxlY3QuZ2V0U2VsZWN0VmFsdWVDb250ZXh0KHNlbGVjdFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHsgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIGhvc3RQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NT3B0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAob2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbi8qKlxuICogVGV4dCBub2RlcyB2aW9sYXRlIGEgY291cGxlIGFzc3VtcHRpb25zIHRoYXQgUmVhY3QgbWFrZXMgYWJvdXQgY29tcG9uZW50czpcbiAqXG4gKiAgLSBXaGVuIG1vdW50aW5nIHRleHQgaW50byB0aGUgRE9NLCBhZGphY2VudCB0ZXh0IG5vZGVzIGFyZSBtZXJnZWQuXG4gKiAgLSBUZXh0IG5vZGVzIGNhbm5vdCBiZSBhc3NpZ25lZCBhIFJlYWN0IHJvb3QgSUQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byB3cmFwIHN0cmluZ3MgYmV0d2VlbiBjb21tZW50IG5vZGVzIHNvIHRoYXQgdGhleVxuICogY2FuIHVuZGVyZ28gdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIC8vIFRPRE86IFRoaXMgaXMgcmVhbGx5IGEgUmVhY3RUZXh0IChSZWFjdE5vZGUpLCBub3QgYSBSZWFjdEVsZW1lbnRcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xuICB0aGlzLl9zdHJpbmdUZXh0ID0gJycgKyB0ZXh0O1xuICAvLyBSZWFjdERPTUNvbXBvbmVudFRyZWUgdXNlcyB0aGVzZTpcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcblxuICAvLyBQcm9wZXJ0aWVzXG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgdGhpcy5fY29tbWVudE5vZGVzID0gbnVsbDtcbn07XG5cbl9hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLiBUaGlzIG5vZGUgaXMgbm90IGludGVuZGVkIHRvIGhhdmVcbiAgICogYW55IGZlYXR1cmVzIGJlc2lkZXMgY29udGFpbmluZyB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcoJyN0ZXh0JywgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHZhciBvcGVuaW5nVmFsdWUgPSAnIHJlYWN0LXRleHQ6ICcgKyBkb21JRCArICcgJztcbiAgICB2YXIgY2xvc2luZ1ZhbHVlID0gJyAvcmVhY3QtdGV4dCAnO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQob3BlbmluZ1ZhbHVlKTtcbiAgICAgIHZhciBjbG9zaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChjbG9zaW5nVmFsdWUpO1xuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpO1xuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3BlbmluZ0NvbW1lbnQpKTtcbiAgICAgIGlmICh0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5fc3RyaW5nVGV4dCkpKTtcbiAgICAgIH1cbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKGNsb3NpbmdDb21tZW50KSk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIG9wZW5pbmdDb21tZW50KTtcbiAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gY2xvc2luZ0NvbW1lbnQ7XG4gICAgICByZXR1cm4gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlc2NhcGVkVGV4dCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0aGlzLl9zdHJpbmdUZXh0KTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgd3JhcCB0aGlzIGJldHdlZW4gY29tbWVudCBub2RlcyBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkXG4gICAgICAgIC8vIGFib3ZlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXJcbiAgICAgICAgLy8gKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPCEtLScgKyBvcGVuaW5nVmFsdWUgKyAnLS0+JyArIGVzY2FwZWRUZXh0ICsgJzwhLS0nICsgY2xvc2luZ1ZhbHVlICsgJy0tPic7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSBuZXh0VGV4dCBUaGUgbmV4dCB0ZXh0IGNvbnRlbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0VGV4dCwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dFRleHQgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRUZXh0O1xuICAgICAgdmFyIG5leHRTdHJpbmdUZXh0ID0gJycgKyBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0U3RyaW5nVGV4dCAhPT0gdGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBTYXZlIHRoaXMgYXMgcGVuZGluZyBwcm9wcyBhbmQgdXNlIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeVxuICAgICAgICAvLyBhbmQvb3IgdXBkYXRlQ29tcG9uZW50IHRvIGRvIHRoZSBhY3R1YWwgdXBkYXRlIGZvciBjb25zaXN0ZW5jeSB3aXRoXG4gICAgICAgIC8vIG90aGVyIGNvbXBvbmVudCB0eXBlcz9cbiAgICAgICAgdGhpcy5fc3RyaW5nVGV4dCA9IG5leHRTdHJpbmdUZXh0O1xuICAgICAgICB2YXIgY29tbWVudE5vZGVzID0gdGhpcy5nZXRIb3N0Tm9kZSgpO1xuICAgICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucmVwbGFjZURlbGltaXRlZFRleHQoY29tbWVudE5vZGVzWzBdLCBjb21tZW50Tm9kZXNbMV0sIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdE5vZGUgPSB0aGlzLl9jb21tZW50Tm9kZXM7XG4gICAgaWYgKGhvc3ROb2RlKSB7XG4gICAgICByZXR1cm4gaG9zdE5vZGU7XG4gICAgfVxuICAgIGlmICghdGhpcy5fY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgICAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICEobm9kZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIGNsb3NpbmcgY29tbWVudCBmb3IgdGV4dCBjb21wb25lbnQgJXMnLCB0aGlzLl9kb21JRCkgOiBfcHJvZEludmFyaWFudCgnNjcnLCB0aGlzLl9kb21JRCkgOiB2b2lkIDA7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIC9yZWFjdC10ZXh0ICcpIHtcbiAgICAgICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGhvc3ROb2RlID0gW3RoaXMuX2hvc3ROb2RlLCB0aGlzLl9jbG9zaW5nQ29tbWVudF07XG4gICAgdGhpcy5fY29tbWVudE5vZGVzID0gaG9zdE5vZGU7XG4gICAgcmV0dXJuIGhvc3ROb2RlO1xuICB9LFxuXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gICAgdGhpcy5fY29tbWVudE5vZGVzID0gbnVsbDtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRhcmVhXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogX3Byb2RJbnZhcmlhbnQoJzkxJykgOiB2b2lkIDA7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAgIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gICAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK0JlbiBzZWVtZWQgdG8gbGlrZSB0aGlzIHNvbHV0aW9uLlxuICAgIC8vIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46ICcnICsgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHRleHRhcmVhYCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzkyJykgOiB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MycpIDogdm9pZCAwO1xuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG5cbiAgICAvLyBXYXJuaW5nOiBub2RlLnZhbHVlIG1heSBiZSB0aGUgZW1wdHkgc3RyaW5nIGF0IHRoaXMgcG9pbnQgKElFMTEpIGlmIHBsYWNlaG9sZGVyIGlzIHNldC5cbiAgICBub2RlLnZhbHVlID0gbm9kZS50ZXh0Q29udGVudDsgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dGFyZWE7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRyZWVUcmF2ZXJzYWxcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG5cbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IHRlbXBBLl9ob3N0UGFyZW50KSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IHRlbXBCLl9ob3N0UGFyZW50KSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBpbnN0QS5faG9zdFBhcmVudDtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCKSB7XG4gICAgICByZXR1cm4gaW5zdEE7XG4gICAgfVxuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RBKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzQW5jZXN0b3I6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzUnKSA6IHZvaWQgMDtcblxuICB3aGlsZSAoaW5zdEIpIHtcbiAgICBpZiAoaW5zdEIgPT09IGluc3RBKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldFBhcmVudEluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM2JykgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGluc3QuX2hvc3RQYXJlbnQ7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sIGZhbHNlLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgdHJ1ZSwgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAoZnJvbSAmJiBmcm9tICE9PSBjb21tb24pIHtcbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBmcm9tLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRvICYmIHRvICE9PSBjb21tb24pIHtcbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSB0by5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sIHRydWUsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAoaSA9IHBhdGhUby5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW2ldLCBmYWxzZSwgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlLFxuXG4gICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB2YWx1ZUxpbms6IHRydWUsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gICAgY2hlY2tlZExpbms6IHRydWUsXG4gICAgaW5uZXJIVE1MOiB0cnVlLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICBvbkZvY3VzSW46IHRydWUsXG4gICAgb25Gb2N1c091dDogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIGlmIChzdGFuZGFyZE5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBndWVzcyB3aGljaCBwcm9wIHRoZSB1c2VyIGludGVuZGVkLlxuICAgICAgLy8gSXQgaXMgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2FzIGp1c3QgYmxpbmRseSBzcHJlYWRpbmcvZm9yd2FyZGluZyBwcm9wc1xuICAgICAgLy8gQ29tcG9uZW50cyBzaG91bGQgYmUgY2FyZWZ1bCB0byBvbmx5IHJlbmRlciB2YWxpZCBwcm9wcy9hdHRyaWJ1dGVzLlxuICAgICAgLy8gV2FybmluZyB3aWxsIGJlIGludm9rZWQgaW4gd2FyblVua25vd25Qcm9wZXJ0aWVzIHRvIGFsbG93IGdyb3VwaW5nLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcCAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoaXMgcHJvcCBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3BzICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhlc2UgcHJvcHMgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzXG4gKiogbW9kdWxlIGlkID0gMjI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWJ1Z1Rvb2xcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rJyk7XG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vaycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaG9va3MgPSBbXTtcbnZhciBkaWRIb29rVGhyb3dGb3JFdmVudCA9IHt9O1xuXG5mdW5jdGlvbiBjYWxsSG9vayhldmVudCwgZm4sIGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgdHJ5IHtcbiAgICBmbi5jYWxsKGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdLCAnRXhjZXB0aW9uIHRocm93biBieSBob29rIHdoaWxlIGhhbmRsaW5nICVzOiAlcycsIGV2ZW50LCBlICsgJ1xcbicgKyBlLnN0YWNrKSA6IHZvaWQgMDtcbiAgICBkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFdmVudChldmVudCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcbiAgICB2YXIgZm4gPSBob29rW2V2ZW50XTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGNhbGxIb29rKGV2ZW50LCBmbiwgaG9vaywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBpc1Byb2ZpbGluZyA9IGZhbHNlO1xudmFyIGZsdXNoSGlzdG9yeSA9IFtdO1xudmFyIGxpZmVDeWNsZVRpbWVyU3RhY2sgPSBbXTtcbnZhciBjdXJyZW50Rmx1c2hOZXN0aW5nID0gMDtcbnZhciBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBudWxsO1xudmFyIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcblxudmFyIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNsZWFySGlzdG9yeSgpIHtcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcbiAgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suY2xlYXJIaXN0b3J5KCk7XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKSB7XG4gIHJldHVybiByZWdpc3RlcmVkSURzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwgaWQpIHtcbiAgICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gICAgdmFyIHBhcmVudElEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgdHJlZVtpZF0gPSB7XG4gICAgICBkaXNwbGF5TmFtZTogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCksXG4gICAgICB0ZXh0OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFRleHQoaWQpLFxuICAgICAgdXBkYXRlQ291bnQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VXBkYXRlQ291bnQoaWQpLFxuICAgICAgY2hpbGRJRHM6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q2hpbGRJRHMoaWQpLFxuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIG93bmVycyBidXQgdGhpcyBpcyBjbG9zZSBlbm91Z2guXG4gICAgICBvd25lcklEOiBvd25lcklEIHx8IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChwYXJlbnRJRCksXG4gICAgICBwYXJlbnRJRDogcGFyZW50SURcbiAgICB9O1xuICAgIHJldHVybiB0cmVlO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0TWVhc3VyZW1lbnRzKCkge1xuICB2YXIgcHJldmlvdXNTdGFydFRpbWUgPSBjdXJyZW50Rmx1c2hTdGFydFRpbWU7XG4gIHZhciBwcmV2aW91c01lYXN1cmVtZW50cyA9IGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyB8fCBbXTtcbiAgdmFyIHByZXZpb3VzT3BlcmF0aW9ucyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmdldEhpc3RvcnkoKTtcblxuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IG51bGw7XG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gbnVsbDtcbiAgICBjbGVhckhpc3RvcnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJldmlvdXNNZWFzdXJlbWVudHMubGVuZ3RoIHx8IHByZXZpb3VzT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZElEcyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UmVnaXN0ZXJlZElEcygpO1xuICAgIGZsdXNoSGlzdG9yeS5wdXNoKHtcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gcHJldmlvdXNTdGFydFRpbWUsXG4gICAgICBtZWFzdXJlbWVudHM6IHByZXZpb3VzTWVhc3VyZW1lbnRzIHx8IFtdLFxuICAgICAgb3BlcmF0aW9uczogcHJldmlvdXNPcGVyYXRpb25zIHx8IFtdLFxuICAgICAgdHJlZVNuYXBzaG90OiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcylcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFySGlzdG9yeSgpO1xuICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpIHtcbiAgdmFyIGFsbG93Um9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gIGlmIChhbGxvd1Jvb3QgJiYgZGVidWdJRCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWRlYnVnSUQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RGVidWdUb29sOiBkZWJ1Z0lEIG1heSBub3QgYmUgZW1wdHkuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgJiYgIWxpZmVDeWNsZVRpbWVySGFzV2FybmVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdEaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdGFydCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbmZ1bmN0aW9uIGVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAhPT0gdGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnV2UgZGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RvcCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnIGluIFJlYWN0LicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XG4gICAgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSB0cnVlO1xuICB9XG4gIGlmIChpc1Byb2ZpbGluZykge1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgIHRpbWVyVHlwZTogdGltZXJUeXBlLFxuICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gY3VycmVudFRpbWVyU3RhcnRUaW1lIC0gY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvblxuICAgIH0pO1xuICB9XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSBudWxsO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgY3VycmVudFRpbWVyID0ge1xuICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVyU3RhcnRUaW1lLFxuICAgIG5lc3RlZEZsdXNoU3RhcnRUaW1lOiBwZXJmb3JtYW5jZU5vdygpLFxuICAgIGRlYnVnSUQ6IGN1cnJlbnRUaW1lckRlYnVnSUQsXG4gICAgdGltZXJUeXBlOiBjdXJyZW50VGltZXJUeXBlXG4gIH07XG4gIGxpZmVDeWNsZVRpbWVyU3RhY2sucHVzaChjdXJyZW50VGltZXIpO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBudWxsO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XG4gIHZhciBfbGlmZUN5Y2xlVGltZXJTdGFjayQgPSBsaWZlQ3ljbGVUaW1lclN0YWNrLnBvcCgpO1xuXG4gIHZhciBzdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuc3RhcnRUaW1lO1xuICB2YXIgbmVzdGVkRmx1c2hTdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQubmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIHZhciBkZWJ1Z0lEID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLmRlYnVnSUQ7XG4gIHZhciB0aW1lclR5cGUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQudGltZXJUeXBlO1xuXG4gIHZhciBuZXN0ZWRGbHVzaER1cmF0aW9uID0gcGVyZm9ybWFuY2VOb3coKSAtIG5lc3RlZEZsdXNoU3RhcnRUaW1lO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gKz0gbmVzdGVkRmx1c2hEdXJhdGlvbjtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbnZhciBSZWFjdERlYnVnVG9vbCA9IHtcbiAgYWRkSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rcy5wdXNoKGhvb2spO1xuICB9LFxuICByZW1vdmVIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChob29rc1tpXSA9PT0gaG9vaykge1xuICAgICAgICBob29rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUHJvZmlsaW5nO1xuICB9LFxuICBiZWdpblByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBlbmRQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBnZXRGbHVzaEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmx1c2hIaXN0b3J5O1xuICB9LFxuICBvbkJlZ2luRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkZsdXNoJyk7XG4gIH0sXG4gIG9uRW5kRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcbiAgICByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kRmx1c2gnKTtcbiAgfSxcbiAgb25CZWdpbkxpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uRW5kTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVycm9yOiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGlmIChjdXJyZW50VGltZXJEZWJ1Z0lEICE9IG51bGwpIHtcbiAgICAgIGVuZExpZmVDeWNsZVRpbWVyKGN1cnJlbnRUaW1lckRlYnVnSUQsIGN1cnJlbnRUaW1lclR5cGUpO1xuICAgIH1cbiAgICBlbWl0RXZlbnQoJ29uRXJyb3InLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKGRlYnVnSUQsIHR5cGUsIHBheWxvYWQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBkZWJ1Z0lELCB0eXBlLCBwYXlsb2FkKTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25TZXRTdGF0ZScpO1xuICB9LFxuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoZGVidWdJRCwgY2hpbGREZWJ1Z0lEcykge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGlsZERlYnVnSURzLmZvckVhY2goY2hlY2tEZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uU2V0Q2hpbGRyZW4nLCBkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hlY2tEZWJ1Z0lEKHBhcmVudERlYnVnSUQsIHRydWUpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVNb3VudENvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25VcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25Vbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uVGVzdEV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblRlc3RFdmVudCcpO1xuICB9XG59O1xuXG4vLyBUT0RPIHJlbW92ZSB0aGVzZSB3aGVuIFJOL3d3dyBnZXRzIHVwZGF0ZWRcblJlYWN0RGVidWdUb29sLmFkZERldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5hZGRIb29rO1xuUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2s7XG5cblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayk7XG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0Q29tcG9uZW50VHJlZUhvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayk7XG52YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gIFJlYWN0RGVidWdUb29sLmJlZ2luUHJvZmlsaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVidWdUb29sLmpzXG4gKiogbW9kdWxlIGlkID0gMjI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBSZWFjdFVwZGF0ZXMuZmx1c2hCYXRjaGVkVXBkYXRlcy5iaW5kKFJlYWN0VXBkYXRlcylcbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtGTFVTSF9CQVRDSEVEX1VQREFURVMsIFJFU0VUX0JBVENIRURfVVBEQVRFU107XG5cbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xufVxuXG5fYXNzaWduKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luJyk7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9FbnRlckxlYXZlRXZlbnRQbHVnaW4nKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01FbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NVHJlZVRyYXZlcnNhbCA9IHJlcXVpcmUoJy4vUmVhY3RET01UcmVlVHJhdmVyc2FsJyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50TGlzdGVuZXInKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbmplY3Rpb24nKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL1NWR0RPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWUpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdFRyZWVUcmF2ZXJzYWwoUmVhY3RET01UcmVlVHJhdmVyc2FsKTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFJlYWN0RE9NQ29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdFRleHRDb21wb25lbnRDbGFzcyhSZWFjdERPTVRleHRDb21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudEZhY3RvcnkoZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFjdERPTUVtcHR5Q29tcG9uZW50KGluc3RhbnRpYXRlKTtcbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmplY3Q6IGluamVjdFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudEVtaXR0ZXJNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRFbWl0dGVyTWl4aW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdC5faG9zdFBhcmVudCkge1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICB2YXIgY29udGFpbmVyID0gcm9vdE5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5fYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gYW5jZXN0b3IgJiYgZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSB7XG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKGRlYnVnSUQsIHR5cGUsIHBheWxvYWQpIHtcbiAgICBoaXN0b3J5LnB1c2goe1xuICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgfSk7XG4gIH0sXG4gIGNsZWFySGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5fcHJldmVudENsZWFyaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0cy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoaXN0b3J5ID0gW107XG4gIH0sXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBDbGFzczogUmVhY3RDbGFzcy5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5VdGlsczogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgSG9zdENvbXBvbmVudDogUmVhY3RIb3N0Q29tcG9uZW50LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcblxuICB2YXIgd2FybkludmFsaWRTZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge1xuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSB0cnVlO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB3YXJuSW52YWxpZFNldFN0YXRlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5cbnZhciBUQUdfRU5EID0gL1xcLz8+LztcbnZhciBDT01NRU5UX1NUQVJUID0gL148XFwhXFwtXFwtLztcblxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XG4gIENIRUNLU1VNX0FUVFJfTkFNRTogJ2RhdGEtcmVhY3QtY2hlY2tzdW0nLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXG4gICAqL1xuICBhZGRDaGVja3N1bVRvTWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuXG4gICAgLy8gQWRkIGNoZWNrc3VtIChoYW5kbGUgYm90aCBwYXJlbnQgdGFncywgY29tbWVudHMgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIGlmIChDT01NRU5UX1NUQVJULnRlc3QobWFya3VwKSkge1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKFRBR19FTkQsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIiQmJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZFJlY29uY2lsZXInKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZSgnLi9mbGF0dGVuQ2hpbGRyZW4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VJbnNlcnRNYXJrdXAobWFya3VwLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUoY2hpbGQpLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBjaGlsZC5fbW91bnRJbmRleCxcbiAgICBmcm9tTm9kZTogbm9kZSxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSBtYXJrdXAgb2YgYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlU2V0TWFya3VwKG1hcmt1cCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIFB1c2ggYW4gdXBkYXRlLCBpZiBhbnksIG9udG8gdGhlIHF1ZXVlLiBDcmVhdGVzIGEgbmV3IHF1ZXVlIGlmIG5vbmUgaXNcbiAqIHBhc3NlZCBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHF1ZXVlLiBNdXRhdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIGlmICh1cGRhdGUpIHtcbiAgICBxdWV1ZSA9IHF1ZXVlIHx8IFtdO1xuICAgIHF1ZXVlLnB1c2godXBkYXRlKTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZShpbnN0LCB1cGRhdGVRdWV1ZSkge1xuICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoaW5zdCwgdXBkYXRlUXVldWUpO1xufVxuXG52YXIgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGdldERlYnVnSUQgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghaW5zdC5fZGVidWdJRCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIEFSVC1saWtlIGluc3RhbmNlcy4gVE9ETzogVGhpcyBpcyBzaWxseS9ncm9zcy5cbiAgICAgIHZhciBpbnRlcm5hbDtcbiAgICAgIGlmIChpbnRlcm5hbCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpKSB7XG4gICAgICAgIGluc3QgPSBpbnRlcm5hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3QuX2RlYnVnSUQ7XG4gIH07XG4gIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIGRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgIC8vIFRPRE86IFJlYWN0IE5hdGl2ZSBlbXB0eSBjb21wb25lbnRzIGFyZSBhbHNvIG11bHRpY2hpbGQuXG4gICAgLy8gVGhpcyBtZWFucyB0aGV5IHN0aWxsIGdldCBpbnRvIHRoaXMgbWV0aG9kIGJ1dCBkb24ndCBoYXZlIF9kZWJ1Z0lELlxuICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZHJlbiA/IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5ba2V5XS5fZGVidWdJRDtcbiAgICAgIH0pIDogW10pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VUZXh0Q29udGVudChuZXh0Q29udGVudCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VTZXRNYXJrdXAobmV4dE1hcmt1cCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIEhvb2sgdXNlZCBieSBSZWFjdCBBUlRcbiAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgcmVtb3ZlZE5vZGVzID0ge307XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IG51bGw7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAvLyBgbmV4dE1vdW50SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIG5ld2x5IG1vdW50ZWQgY2hpbGQuXG4gICAgICB2YXIgbmV4dE1vdW50SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RQbGFjZWROb2RlID0gbnVsbDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCBsYXN0SW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAvLyBUaGUgYHJlbW92ZWROb2Rlc2AgbG9vcCBiZWxvdyB3aWxsIGFjdHVhbGx5IHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX21vdW50Q2hpbGRBdEluZGV4KG5leHRDaGlsZCwgbW91bnRJbWFnZXNbbmV4dE1vdW50SW5kZXhdLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgIG5leHRNb3VudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKG5leHRDaGlsZCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdLCByZW1vdmVkTm9kZXNbbmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC4gSXQgZG9lcyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhbnlcbiAgICAgKiBiYWNrZW5kIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpIHtcbiAgICAgIHJldHVybiBtYWtlSW5zZXJ0TWFya3VwKG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMjM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTE5JykgOiB2b2lkIDA7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjAnKSA6IHZvaWQgMDtcbiAgICB2YXIgb3duZXJQdWJsaWNJbnN0YW5jZSA9IG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCdzIG93bmVyIGlzIHN0aWxsIGFsaXZlIGFuZCB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZlxuICAgIC8vIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyUHVibGljSW5zdGFuY2UgJiYgb3duZXJQdWJsaWNJbnN0YW5jZS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQdXJlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIFJlYWN0Q29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gUmVhY3RDb21wb25lbnQucHJvdG90eXBlO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWN0UHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihSZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUpO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbih1c2VDcmVhdGVFbGVtZW50KSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdERPTVRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSB1c2VDcmVhdGVFbGVtZW50O1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RVcGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlIC0tIGlmIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIG1ldGhvZCBpc1xuICAgKiBwYXNzZWQgdG8gYHJvbGxiYWNrYCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhhdCBzdGF0ZS5cbiAgICovXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZWFjdE1vdW50UmVhZHkgaXMgdGhlIG91ciBvbmx5IHN0YXRlZnVsIHdyYXBwZXJcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHkuY2hlY2twb2ludCgpO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbl9hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWZcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdE93bmVyJyk7XG5cbnZhciBSZWFjdFJlZiA9IHt9O1xuXG5mdW5jdGlvbiBhdHRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihudWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5SZWFjdFJlZi5hdHRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcblxuICByZXR1cm4gKFxuICAgIC8vIFRoaXMgaGFzIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyB3L3IvdCBlbXB0eSBjb21wb25lbnRzLlxuICAgIHByZXZFbXB0eSB8fCBuZXh0RW1wdHkgfHwgbmV4dEVsZW1lbnQucmVmICE9PSBwcmV2RWxlbWVudC5yZWYgfHxcbiAgICAvLyBJZiBvd25lciBjaGFuZ2VzIGJ1dCB3ZSBoYXZlIGFuIHVuY2hhbmdlZCBmdW5jdGlvbiByZWYsIGRvbid0IHVwZGF0ZSByZWZzXG4gICAgdHlwZW9mIG5leHRFbGVtZW50LnJlZiA9PT0gJ3N0cmluZycgJiYgbmV4dEVsZW1lbnQuX293bmVyICE9PSBwcmV2RWxlbWVudC5fb3duZXJcbiAgKTtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcbiAgZW5xdWV1ZTogZnVuY3Rpb24gKCkge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBuZXcgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0aGlzKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub29wQ2FsbGJhY2tRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKCkge31cbn07XG5cbl9hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB1cGRhdGUgcXVldWUgdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqIEl0IGRlbGVnYXRlcyB0byBSZWFjdFVwZGF0ZVF1ZXVlIHdoaWxlIHNlcnZlciByZW5kZXJpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kXG4gKiBzd2l0Y2hlcyB0byBSZWFjdE5vb3BVcGRhdGVRdWV1ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAqIEBjbGFzcyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICovXG5cbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAvKiA6OiB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb247ICovXG5cbiAgZnVuY3Rpb24gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0cmFuc2FjdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKTtcblxuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuaXNNb3VudGVkID0gZnVuY3Rpb24gaXNNb3VudGVkKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUNhbGxiYWNrID0gZnVuY3Rpb24gZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlUmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlU2V0U3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU1ZHRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLy8gV2UgdXNlIGF0dHJpYnV0ZXMgZm9yIGV2ZXJ5dGhpbmcgU1ZHIHNvIGxldCdzIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gYW5kIHJ1blxuLy8gY29kZSBpbnN0ZWFkLlxuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBjb25maWcgYWxyZWFkeSBzbyB3ZSBleGNsdWRlIGhlcmUuXG4vLyAtIGNsYXNzIChhcyBjbGFzc05hbWUpXG4vLyAtIGNvbG9yXG4vLyAtIGhlaWdodFxuLy8gLSBpZFxuLy8gLSBsYW5nXG4vLyAtIG1heFxuLy8gLSBtZWRpYVxuLy8gLSBtZXRob2Rcbi8vIC0gbWluXG4vLyAtIG5hbWVcbi8vIC0gc3R5bGVcbi8vIC0gdGFyZ2V0XG4vLyAtIHR5cGVcbi8vIC0gd2lkdGhcbnZhciBBVFRSUyA9IHtcbiAgYWNjZW50SGVpZ2h0OiAnYWNjZW50LWhlaWdodCcsXG4gIGFjY3VtdWxhdGU6IDAsXG4gIGFkZGl0aXZlOiAwLFxuICBhbGlnbm1lbnRCYXNlbGluZTogJ2FsaWdubWVudC1iYXNlbGluZScsXG4gIGFsbG93UmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6IDAsXG4gIGFtcGxpdHVkZTogMCxcbiAgYXJhYmljRm9ybTogJ2FyYWJpYy1mb3JtJyxcbiAgYXNjZW50OiAwLFxuICBhdHRyaWJ1dGVOYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZVR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6IDAsXG4gIGJhc2VGcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZVByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJhc2VsaW5lU2hpZnQ6ICdiYXNlbGluZS1zaGlmdCcsXG4gIGJib3g6IDAsXG4gIGJlZ2luOiAwLFxuICBiaWFzOiAwLFxuICBieTogMCxcbiAgY2FsY01vZGU6ICdjYWxjTW9kZScsXG4gIGNhcEhlaWdodDogJ2NhcC1oZWlnaHQnLFxuICBjbGlwOiAwLFxuICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gIGNsaXBSdWxlOiAnY2xpcC1ydWxlJyxcbiAgY2xpcFBhdGhVbml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjb2xvckludGVycG9sYXRpb246ICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsXG4gIGNvbG9yUHJvZmlsZTogJ2NvbG9yLXByb2ZpbGUnLFxuICBjb2xvclJlbmRlcmluZzogJ2NvbG9yLXJlbmRlcmluZycsXG4gIGNvbnRlbnRTY3JpcHRUeXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50U3R5bGVUeXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogMCxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuICBkOiAwLFxuICBkZWNlbGVyYXRlOiAwLFxuICBkZXNjZW50OiAwLFxuICBkaWZmdXNlQ29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246IDAsXG4gIGRpc3BsYXk6IDAsXG4gIGRpdmlzb3I6IDAsXG4gIGRvbWluYW50QmFzZWxpbmU6ICdkb21pbmFudC1iYXNlbGluZScsXG4gIGR1cjogMCxcbiAgZHg6IDAsXG4gIGR5OiAwLFxuICBlZGdlTW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAwLFxuICBlbmFibGVCYWNrZ3JvdW5kOiAnZW5hYmxlLWJhY2tncm91bmQnLFxuICBlbmQ6IDAsXG4gIGV4cG9uZW50OiAwLFxuICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6IDAsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgZmlsbFJ1bGU6ICdmaWxsLXJ1bGUnLFxuICBmaWx0ZXI6IDAsXG4gIGZpbHRlclJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlclVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZENvbG9yOiAnZmxvb2QtY29sb3InLFxuICBmbG9vZE9wYWNpdHk6ICdmbG9vZC1vcGFjaXR5JyxcbiAgZm9jdXNhYmxlOiAwLFxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gIGZvbnRTaXplQWRqdXN0OiAnZm9udC1zaXplLWFkanVzdCcsXG4gIGZvbnRTdHJldGNoOiAnZm9udC1zdHJldGNoJyxcbiAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXG4gIGZvbnRWYXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgZm9udFdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcbiAgZm9ybWF0OiAwLFxuICBmcm9tOiAwLFxuICBmeDogMCxcbiAgZnk6IDAsXG4gIGcxOiAwLFxuICBnMjogMCxcbiAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXG4gIGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsOiAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsXG4gIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgZ2x5cGhSZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6IDAsXG4gIGhvcml6QWR2WDogJ2hvcml6LWFkdi14JyxcbiAgaG9yaXpPcmlnaW5YOiAnaG9yaXotb3JpZ2luLXgnLFxuICBpZGVvZ3JhcGhpYzogMCxcbiAgaW1hZ2VSZW5kZXJpbmc6ICdpbWFnZS1yZW5kZXJpbmcnLFxuICAnaW4nOiAwLFxuICBpbjI6IDAsXG4gIGludGVyY2VwdDogMCxcbiAgazogMCxcbiAgazE6IDAsXG4gIGsyOiAwLFxuICBrMzogMCxcbiAgazQ6IDAsXG4gIGtlcm5lbE1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbFVuaXRMZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogMCxcbiAga2V5UG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5U3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXlUaW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoQWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyU3BhY2luZzogJ2xldHRlci1zcGFjaW5nJyxcbiAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgbGltaXRpbmdDb25lQW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAwLFxuICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgbWFya2VySGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VyVW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcldpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAwLFxuICBtYXNrQ29udGVudFVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2tVbml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogMCxcbiAgbW9kZTogMCxcbiAgbnVtT2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6IDAsXG4gIG9wYWNpdHk6IDAsXG4gIG9wZXJhdG9yOiAwLFxuICBvcmRlcjogMCxcbiAgb3JpZW50OiAwLFxuICBvcmllbnRhdGlvbjogMCxcbiAgb3JpZ2luOiAwLFxuICBvdmVyZmxvdzogMCxcbiAgb3ZlcmxpbmVQb3NpdGlvbjogJ292ZXJsaW5lLXBvc2l0aW9uJyxcbiAgb3ZlcmxpbmVUaGlja25lc3M6ICdvdmVybGluZS10aGlja25lc3MnLFxuICBwYWludE9yZGVyOiAncGFpbnQtb3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlLTEnLFxuICBwYXRoTGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVyblRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyRXZlbnRzOiAncG9pbnRlci1ldmVudHMnLFxuICBwb2ludHM6IDAsXG4gIHBvaW50c0F0WDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c0F0WTogJ3BvaW50c0F0WScsXG4gIHBvaW50c0F0WjogJ3BvaW50c0F0WicsXG4gIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmVVbml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcjogMCxcbiAgcmFkaXVzOiAwLFxuICByZWZYOiAncmVmWCcsXG4gIHJlZlk6ICdyZWZZJyxcbiAgcmVuZGVyaW5nSW50ZW50OiAncmVuZGVyaW5nLWludGVudCcsXG4gIHJlcGVhdENvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXREdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZEV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZEZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc3RhcnQ6IDAsXG4gIHJlc3VsdDogMCxcbiAgcm90YXRlOiAwLFxuICByeDogMCxcbiAgcnk6IDAsXG4gIHNjYWxlOiAwLFxuICBzZWVkOiAwLFxuICBzaGFwZVJlbmRlcmluZzogJ3NoYXBlLXJlbmRlcmluZycsXG4gIHNsb3BlOiAwLFxuICBzcGFjaW5nOiAwLFxuICBzcGVjdWxhckNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyRXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6IDAsXG4gIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0T2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGREZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogMCxcbiAgc3RlbXY6IDAsXG4gIHN0aXRjaFRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdoUG9zaXRpb246ICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAwLFxuICBzdHJva2U6IDAsXG4gIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICBzdHJva2VEYXNob2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICBzdHJva2VMaW5lam9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZU1pdGVybGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgc3VyZmFjZVNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtTGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxlVmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXRYOiAndGFyZ2V0WCcsXG4gIHRhcmdldFk6ICd0YXJnZXRZJyxcbiAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxuICB0ZXh0UmVuZGVyaW5nOiAndGV4dC1yZW5kZXJpbmcnLFxuICB0ZXh0TGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRvOiAwLFxuICB0cmFuc2Zvcm06IDAsXG4gIHUxOiAwLFxuICB1MjogMCxcbiAgdW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcmxpbmUtcG9zaXRpb24nLFxuICB1bmRlcmxpbmVUaGlja25lc3M6ICd1bmRlcmxpbmUtdGhpY2tuZXNzJyxcbiAgdW5pY29kZTogMCxcbiAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxuICB1bmljb2RlUmFuZ2U6ICd1bmljb2RlLXJhbmdlJyxcbiAgdW5pdHNQZXJFbTogJ3VuaXRzLXBlci1lbScsXG4gIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcbiAgdkhhbmdpbmc6ICd2LWhhbmdpbmcnLFxuICB2SWRlb2dyYXBoaWM6ICd2LWlkZW9ncmFwaGljJyxcbiAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcbiAgdmFsdWVzOiAwLFxuICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcbiAgdmVyc2lvbjogMCxcbiAgdmVydEFkdlk6ICd2ZXJ0LWFkdi15JyxcbiAgdmVydE9yaWdpblg6ICd2ZXJ0LW9yaWdpbi14JyxcbiAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcbiAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICB2aWV3VGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6IDAsXG4gIHdpZHRoczogMCxcbiAgd29yZFNwYWNpbmc6ICd3b3JkLXNwYWNpbmcnLFxuICB3cml0aW5nTW9kZTogJ3dyaXRpbmctbW9kZScsXG4gIHg6IDAsXG4gIHhIZWlnaHQ6ICd4LWhlaWdodCcsXG4gIHgxOiAwLFxuICB4MjogMCxcbiAgeENoYW5uZWxTZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICB4bWxuczogMCxcbiAgeG1sbnNYbGluazogJ3htbG5zOnhsaW5rJyxcbiAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnLFxuICB5OiAwLFxuICB5MTogMCxcbiAgeTI6IDAsXG4gIHlDaGFubmVsU2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogMCxcbiAgem9vbUFuZFBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHt9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7fVxufTtcblxuT2JqZWN0LmtleXMoQVRUUlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW2tleV0gPSAwO1xuICBpZiAoQVRUUlNba2V5XSkge1xuICAgIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW2tleV0gPSBBVFRSU1trZXldO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3RFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlbGVjdENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSwgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xudmFyIE9OX1NFTEVDVF9LRVkgPSBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50RWxlbWVudDogcmFuZ2UucGFyZW50RWxlbWVudCgpLFxuICAgICAgdGV4dDogcmFuZ2UudGV4dCxcbiAgICAgIHRvcDogcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICBsZWZ0OiByYW5nZS5ib3VuZGluZ0xlZnRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50ID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX1NFTEVDVF9LRVkpIHtcbiAgICAgIGhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2ltcGxlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNBbmltYXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVHJhbnNpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1doZWVsRXZlbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYWJvcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFib3J0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BYm9ydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25JdGVyYXRpb246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkl0ZXJhdGlvbjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQW5pbWF0aW9uSXRlcmF0aW9uQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvblN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25TdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGJsdXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJsdXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJsdXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheVRocm91Z2g6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29weToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29weTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29weUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbnRlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0V4aXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFeGl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRXhpdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnTGVhdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ092ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ1N0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyb3A6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyb3BDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkdXJhdGlvbkNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW1wdGllZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW1wdGllZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW1wdGllZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuY3J5cHRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5jcnlwdGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5kZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuZGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVycm9yOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FcnJvckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGZvY3VzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Gb2N1czogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRm9jdXNDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW5wdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbklucHV0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW52YWxpZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW52YWxpZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW52YWxpZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5UHJlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVByZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWREYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkTWV0YWRhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlRG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU91dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXN0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGFzdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXVzZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGF1c2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhdXNlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXlpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwcm9ncmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUHJvZ3Jlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblByb2dyZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmF0ZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SZXNldDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmVzZXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNjcm9sbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Nyb2xsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2VkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVrZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdGFsbGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdGFsbGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdGFsbGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VibWl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdWJtaXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1Ym1pdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1c3BlbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1c3BlbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1c3BlbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0aW1lVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hDYW5jZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaEVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRyYW5zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQW5pbWF0aW9uRW5kOiBldmVudFR5cGVzLmFuaW1hdGlvbkVuZCxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBldmVudFR5cGVzLmFuaW1hdGlvbkl0ZXJhdGlvbixcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGV2ZW50VHlwZXMuYW5pbWF0aW9uU3RhcnQsXG4gIHRvcEJsdXI6IGV2ZW50VHlwZXMuYmx1cixcbiAgdG9wQ2FuUGxheTogZXZlbnRUeXBlcy5jYW5QbGF5LFxuICB0b3BDYW5QbGF5VGhyb3VnaDogZXZlbnRUeXBlcy5jYW5QbGF5VGhyb3VnaCxcbiAgdG9wQ2xpY2s6IGV2ZW50VHlwZXMuY2xpY2ssXG4gIHRvcENvbnRleHRNZW51OiBldmVudFR5cGVzLmNvbnRleHRNZW51LFxuICB0b3BDb3B5OiBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogZXZlbnRUeXBlcy5jdXQsXG4gIHRvcERvdWJsZUNsaWNrOiBldmVudFR5cGVzLmRvdWJsZUNsaWNrLFxuICB0b3BEcmFnOiBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6IGV2ZW50VHlwZXMuZHJhZ0VuZCxcbiAgdG9wRHJhZ0VudGVyOiBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6IGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogZXZlbnRUeXBlcy5kcmFnTGVhdmUsXG4gIHRvcERyYWdPdmVyOiBldmVudFR5cGVzLmRyYWdPdmVyLFxuICB0b3BEcmFnU3RhcnQ6IGV2ZW50VHlwZXMuZHJhZ1N0YXJ0LFxuICB0b3BEcm9wOiBldmVudFR5cGVzLmRyb3AsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBldmVudFR5cGVzLmR1cmF0aW9uQ2hhbmdlLFxuICB0b3BFbXB0aWVkOiBldmVudFR5cGVzLmVtcHRpZWQsXG4gIHRvcEVuY3J5cHRlZDogZXZlbnRUeXBlcy5lbmNyeXB0ZWQsXG4gIHRvcEVuZGVkOiBldmVudFR5cGVzLmVuZGVkLFxuICB0b3BFcnJvcjogZXZlbnRUeXBlcy5lcnJvcixcbiAgdG9wRm9jdXM6IGV2ZW50VHlwZXMuZm9jdXMsXG4gIHRvcElucHV0OiBldmVudFR5cGVzLmlucHV0LFxuICB0b3BJbnZhbGlkOiBldmVudFR5cGVzLmludmFsaWQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BUcmFuc2l0aW9uRW5kOiBldmVudFR5cGVzLnRyYW5zaXRpb25FbmQsXG4gIHRvcFZvbHVtZUNoYW5nZTogZXZlbnRUeXBlcy52b2x1bWVDaGFuZ2UsXG4gIHRvcFdhaXRpbmc6IGV2ZW50VHlwZXMud2FpdGluZyxcbiAgdG9wV2hlZWw6IGV2ZW50VHlwZXMud2hlZWxcbn07XG5cbmZvciAodmFyIHR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0eXBlXS5kZXBlbmRlbmNpZXMgPSBbdHlwZV07XG59XG5cbnZhciBPTl9DTElDS19LRVkgPSBrZXlPZih7IG9uQ2xpY2s6IG51bGwgfSk7XG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG5mdW5jdGlvbiBnZXREaWN0aW9uYXJ5S2V5KGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW52YWxpZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZERhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkTWV0YWRhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZFN0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhdXNlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheWluZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQcm9ncmVzczpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSYXRlQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJlc2V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVraW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN0YWxsZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1c3BlbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGltZVVwZGF0ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BWb2x1bWVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2FpdGluZzpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDbGljazpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFuaW1hdGlvbkVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBbmltYXRpb25JdGVyYXRpb246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQW5pbWF0aW9uU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVHJhbnNpdGlvbkVuZDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2hlZWw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb3B5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEN1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBfcHJvZEludmFyaWFudCgnODYnLCB0b3BMZXZlbFR5cGUpIDogdm9pZCAwO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0ucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1trZXldO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ29tcG9zaXRpb25FdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljSW5wdXRFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0tleWJvYXJkRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvYWRsZXIzMi5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRhbmdlcm91c1N0eWxlVmFsdWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXI7XG52YXIgc3R5bGVXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fCBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIEFsbG93ICcwJyB0byBwYXNzIHRocm91Z2ggd2l0aG91dCB3YXJuaW5nLiAwIGlzIGFscmVhZHkgc3BlY2lhbCBhbmRcbiAgICAgIC8vIGRvZXNuJ3QgcmVxdWlyZSB1bml0cywgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXJuIGFib3V0IGl0LlxuICAgICAgaWYgKGNvbXBvbmVudCAmJiB2YWx1ZSAhPT0gJzAnKSB7XG4gICAgICAgIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBvd25lci5nZXROYW1lKCkgOiBudWxsO1xuICAgICAgICBpZiAob3duZXJOYW1lICYmICFzdHlsZVdhcm5pbmdzW293bmVyTmFtZV0pIHtcbiAgICAgICAgICBzdHlsZVdhcm5pbmdzW293bmVyTmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICB2YXIgd2FybmluZ3MgPSBzdHlsZVdhcm5pbmdzW293bmVyTmFtZV07XG4gICAgICAgICAgd2FybmVkID0gd2FybmluZ3NbbmFtZV07XG4gICAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2EgYCVzYCB0YWcgKG93bmVyOiBgJXNgKSB3YXMgcGFzc2VkIGEgbnVtZXJpYyBzdHJpbmcgdmFsdWUgJyArICdmb3IgQ1NTIHByb3BlcnR5IGAlc2AgKHZhbHVlOiBgJXNgKSB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgJyArICdhcyBhIHVuaXRsZXNzIG51bWJlciBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LicsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZSwgb3duZXJOYW1lIHx8ICd1bmtub3duJywgbmFtZSwgdmFsdWUpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZSArICdweCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRET01Ob2RlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG5cbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20uZmluZGRvbW5vZGVcbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHZhciBpbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgcmV0dXJuIGluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSA6IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZERPTU5vZGUgd2FzIGNhbGxlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQ0JykgOiB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc0NScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogdm9pZCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICogQHBhcmFtIHtudW1iZXI9fSBzZWxmRGVidWdJRCBPcHRpb25hbCBkZWJ1Z0lEIG9mIHRoZSBjdXJyZW50IGludGVybmFsIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgaWYgKHRyYXZlcnNlQ29udGV4dCAmJiB0eXBlb2YgdHJhdmVyc2VDb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gICAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuLCBzZWxmRGVidWdJRCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAgICAgcmV0dXJuIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICB9LCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydPJyArIHN0eWxlUHJvcF0gPSAnbycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcblxuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xudmFyIHN0eWxlID0ge307XG5cbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfVxuXG4gIC8vIFNhbWUgYXMgYWJvdmVcbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG9ubHlDaGlsZFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnMTQzJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL29ubHlDaGlsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplLmpzXG4gKiogbW9kdWxlIGlkID0gMjY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvY29udGFpbnNOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2VycyBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdFxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBvYmouY2FsbGVlICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgY2FuXFwndCBiZSBgYXJndW1lbnRzYC4gVXNlIHJlc3QgcGFyYW1zICcgKyAnKGZ1bmN0aW9uKC4uLmFyZ3MpIHt9KSBvciBBcnJheS5mcm9tKCkgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4gKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzXG4gKiogbW9kdWxlIGlkID0gMjcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaXNOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzXG4gKiogbW9kdWxlIGlkID0gMjc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL3BlcmZvcm1hbmNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qc1xuICoqIG1vZHVsZSBpZCA9IDI3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfVxuXG52YXIgcmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHN0ciwgdGltZXMpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSh0aW1lcyArIDEpLmpvaW4oc3RyKTtcbn07XG52YXIgcGFkID0gZnVuY3Rpb24gcGFkKG51bSwgbWF4TGVuZ3RoKSB7XG4gIHJldHVybiByZXBlYXQoXCIwXCIsIG1heExlbmd0aCAtIG51bS50b1N0cmluZygpLmxlbmd0aCkgKyBudW07XG59O1xudmFyIGZvcm1hdFRpbWUgPSBmdW5jdGlvbiBmb3JtYXRUaW1lKHRpbWUpIHtcbiAgcmV0dXJuIFwiQCBcIiArIHBhZCh0aW1lLmdldEhvdXJzKCksIDIpICsgXCI6XCIgKyBwYWQodGltZS5nZXRNaW51dGVzKCksIDIpICsgXCI6XCIgKyBwYWQodGltZS5nZXRTZWNvbmRzKCksIDIpICsgXCIuXCIgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMyk7XG59O1xuXG4vLyBVc2UgdGhlIG5ldyBwZXJmb3JtYW5jZSBhcGkgdG8gZ2V0IGJldHRlciBwcmVjaXNpb24gaWYgYXZhaWxhYmxlXG52YXIgdGltZXIgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gXCJmdW5jdGlvblwiID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xuXG4vKipcbiAqIHBhcnNlIHRoZSBsZXZlbCBvcHRpb24gb2YgY3JlYXRlTG9nZ2VyXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBmdW5jdGlvbiB8IG9iamVjdH0gbGV2ZWwgLSBjb25zb2xlW2xldmVsXVxuICogQHByb3BlcnR5IHtvYmplY3R9IGFjdGlvblxuICogQHByb3BlcnR5IHthcnJheX0gcGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRMb2dMZXZlbChsZXZlbCwgYWN0aW9uLCBwYXlsb2FkLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZW9mIGxldmVsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobGV2ZWwpKSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiBsZXZlbFt0eXBlXSA9PT0gXCJmdW5jdGlvblwiID8gbGV2ZWxbdHlwZV0uYXBwbHkobGV2ZWwsIF90b0NvbnN1bWFibGVBcnJheShwYXlsb2FkKSkgOiBsZXZlbFt0eXBlXTtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBsZXZlbChhY3Rpb24pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGxvZ2dlciB3aXRoIGZvbGxvd2VkIG9wdGlvbnNcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGxvZ2dlclxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBmdW5jdGlvbiB8IG9iamVjdH0gb3B0aW9ucy5sZXZlbCAtIGNvbnNvbGVbbGV2ZWxdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMuZHVyYXRpb24gLSBwcmludCBkdXJhdGlvbiBvZiBlYWNoIGFjdGlvbj9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy50aW1lc3RhbXAgLSBwcmludCB0aW1lc3RhbXAgd2l0aCBlYWNoIGFjdGlvbj9cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvcHRpb25zLmNvbG9ycyAtIGN1c3RvbSBjb2xvcnNcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvcHRpb25zLmxvZ2dlciAtIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgY29uc29sZWAgQVBJXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMubG9nRXJyb3JzIC0gc2hvdWxkIGVycm9ycyBpbiBhY3Rpb24gZXhlY3V0aW9uIGJlIGNhdWdodCwgbG9nZ2VkLCBhbmQgcmUtdGhyb3duP1xuICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLmNvbGxhcHNlZCAtIGlzIGdyb3VwIGNvbGxhcHNlZD9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy5wcmVkaWNhdGUgLSBjb25kaXRpb24gd2hpY2ggcmVzb2x2ZXMgbG9nZ2VyIGJlaGF2aW9yXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvcHRpb25zLnN0YXRlVHJhbnNmb3JtZXIgLSB0cmFuc2Zvcm0gc3RhdGUgYmVmb3JlIHByaW50XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvcHRpb25zLmFjdGlvblRyYW5zZm9ybWVyIC0gdHJhbnNmb3JtIGFjdGlvbiBiZWZvcmUgcHJpbnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9wdGlvbnMuZXJyb3JUcmFuc2Zvcm1lciAtIHRyYW5zZm9ybSBlcnJvciBiZWZvcmUgcHJpbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVMb2dnZXIoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gIHZhciBfb3B0aW9ucyRsZXZlbCA9IG9wdGlvbnMubGV2ZWw7XG4gIHZhciBsZXZlbCA9IF9vcHRpb25zJGxldmVsID09PSB1bmRlZmluZWQgPyBcImxvZ1wiIDogX29wdGlvbnMkbGV2ZWw7XG4gIHZhciBfb3B0aW9ucyRsb2dnZXIgPSBvcHRpb25zLmxvZ2dlcjtcbiAgdmFyIGxvZ2dlciA9IF9vcHRpb25zJGxvZ2dlciA9PT0gdW5kZWZpbmVkID8gY29uc29sZSA6IF9vcHRpb25zJGxvZ2dlcjtcbiAgdmFyIF9vcHRpb25zJGxvZ0Vycm9ycyA9IG9wdGlvbnMubG9nRXJyb3JzO1xuICB2YXIgbG9nRXJyb3JzID0gX29wdGlvbnMkbG9nRXJyb3JzID09PSB1bmRlZmluZWQgPyB0cnVlIDogX29wdGlvbnMkbG9nRXJyb3JzO1xuICB2YXIgY29sbGFwc2VkID0gb3B0aW9ucy5jb2xsYXBzZWQ7XG4gIHZhciBwcmVkaWNhdGUgPSBvcHRpb25zLnByZWRpY2F0ZTtcbiAgdmFyIF9vcHRpb25zJGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgdmFyIGR1cmF0aW9uID0gX29wdGlvbnMkZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZHVyYXRpb247XG4gIHZhciBfb3B0aW9ucyR0aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcDtcbiAgdmFyIHRpbWVzdGFtcCA9IF9vcHRpb25zJHRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9vcHRpb25zJHRpbWVzdGFtcDtcbiAgdmFyIHRyYW5zZm9ybWVyID0gb3B0aW9ucy50cmFuc2Zvcm1lcjtcbiAgdmFyIF9vcHRpb25zJHN0YXRlVHJhbnNmbyA9IG9wdGlvbnMuc3RhdGVUcmFuc2Zvcm1lcjtcbiAgdmFyIC8vIGRlcHJlY2F0ZWRcbiAgc3RhdGVUcmFuc2Zvcm1lciA9IF9vcHRpb25zJHN0YXRlVHJhbnNmbyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9IDogX29wdGlvbnMkc3RhdGVUcmFuc2ZvO1xuICB2YXIgX29wdGlvbnMkYWN0aW9uVHJhbnNmID0gb3B0aW9ucy5hY3Rpb25UcmFuc2Zvcm1lcjtcbiAgdmFyIGFjdGlvblRyYW5zZm9ybWVyID0gX29wdGlvbnMkYWN0aW9uVHJhbnNmID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoYWN0bikge1xuICAgIHJldHVybiBhY3RuO1xuICB9IDogX29wdGlvbnMkYWN0aW9uVHJhbnNmO1xuICB2YXIgX29wdGlvbnMkZXJyb3JUcmFuc2ZvID0gb3B0aW9ucy5lcnJvclRyYW5zZm9ybWVyO1xuICB2YXIgZXJyb3JUcmFuc2Zvcm1lciA9IF9vcHRpb25zJGVycm9yVHJhbnNmbyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IDogX29wdGlvbnMkZXJyb3JUcmFuc2ZvO1xuICB2YXIgX29wdGlvbnMkY29sb3JzID0gb3B0aW9ucy5jb2xvcnM7XG4gIHZhciBjb2xvcnMgPSBfb3B0aW9ucyRjb2xvcnMgPT09IHVuZGVmaW5lZCA/IHtcbiAgICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoKSB7XG4gICAgICByZXR1cm4gXCIjMDAwMDAwXCI7XG4gICAgfSxcbiAgICBwcmV2U3RhdGU6IGZ1bmN0aW9uIHByZXZTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBcIiM5RTlFOUVcIjtcbiAgICB9LFxuICAgIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiIzAzQTlGNFwiO1xuICAgIH0sXG4gICAgbmV4dFN0YXRlOiBmdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG4gICAgICByZXR1cm4gXCIjNENBRjUwXCI7XG4gICAgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICByZXR1cm4gXCIjRjIwNDA0XCI7XG4gICAgfVxuICB9IDogX29wdGlvbnMkY29sb3JzO1xuXG4gIC8vIGV4aXQgaWYgY29uc29sZSB1bmRlZmluZWRcblxuICBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybWVyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIk9wdGlvbiAndHJhbnNmb3JtZXInIGlzIGRlcHJlY2F0ZWQsIHVzZSBzdGF0ZVRyYW5zZm9ybWVyIGluc3RlYWRcIik7XG4gIH1cblxuICB2YXIgbG9nQnVmZmVyID0gW107XG4gIGZ1bmN0aW9uIHByaW50QnVmZmVyKCkge1xuICAgIGxvZ0J1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChsb2dFbnRyeSwga2V5KSB7XG4gICAgICB2YXIgc3RhcnRlZCA9IGxvZ0VudHJ5LnN0YXJ0ZWQ7XG4gICAgICB2YXIgc3RhcnRlZFRpbWUgPSBsb2dFbnRyeS5zdGFydGVkVGltZTtcbiAgICAgIHZhciBhY3Rpb24gPSBsb2dFbnRyeS5hY3Rpb247XG4gICAgICB2YXIgcHJldlN0YXRlID0gbG9nRW50cnkucHJldlN0YXRlO1xuICAgICAgdmFyIGVycm9yID0gbG9nRW50cnkuZXJyb3I7XG4gICAgICB2YXIgdG9vayA9IGxvZ0VudHJ5LnRvb2s7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gbG9nRW50cnkubmV4dFN0YXRlO1xuXG4gICAgICB2YXIgbmV4dEVudHJ5ID0gbG9nQnVmZmVyW2tleSArIDFdO1xuICAgICAgaWYgKG5leHRFbnRyeSkge1xuICAgICAgICBuZXh0U3RhdGUgPSBuZXh0RW50cnkucHJldlN0YXRlO1xuICAgICAgICB0b29rID0gbmV4dEVudHJ5LnN0YXJ0ZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgICAgLy8gbWVzc2FnZVxuICAgICAgdmFyIGZvcm1hdHRlZEFjdGlvbiA9IGFjdGlvblRyYW5zZm9ybWVyKGFjdGlvbik7XG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSB0eXBlb2YgY29sbGFwc2VkID09PSBcImZ1bmN0aW9uXCIgPyBjb2xsYXBzZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgICAgfSwgYWN0aW9uKSA6IGNvbGxhcHNlZDtcblxuICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSBmb3JtYXRUaW1lKHN0YXJ0ZWRUaW1lKTtcbiAgICAgIHZhciB0aXRsZUNTUyA9IGNvbG9ycy50aXRsZSA/IFwiY29sb3I6IFwiICsgY29sb3JzLnRpdGxlKGZvcm1hdHRlZEFjdGlvbikgKyBcIjtcIiA6IG51bGw7XG4gICAgICB2YXIgdGl0bGUgPSBcImFjdGlvbiBcIiArICh0aW1lc3RhbXAgPyBmb3JtYXR0ZWRUaW1lIDogXCJcIikgKyBcIiBcIiArIGZvcm1hdHRlZEFjdGlvbi50eXBlICsgXCIgXCIgKyAoZHVyYXRpb24gPyBcIihpbiBcIiArIHRvb2sudG9GaXhlZCgyKSArIFwiIG1zKVwiIDogXCJcIik7XG5cbiAgICAgIC8vIHJlbmRlclxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgaWYgKGNvbG9ycy50aXRsZSkgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiJWMgXCIgKyB0aXRsZSwgdGl0bGVDU1MpO2Vsc2UgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKHRpdGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29sb3JzLnRpdGxlKSBsb2dnZXIuZ3JvdXAoXCIlYyBcIiArIHRpdGxlLCB0aXRsZUNTUyk7ZWxzZSBsb2dnZXIuZ3JvdXAodGl0bGUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5sb2codGl0bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldlN0YXRlTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbcHJldlN0YXRlXSwgXCJwcmV2U3RhdGVcIik7XG4gICAgICB2YXIgYWN0aW9uTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbZm9ybWF0dGVkQWN0aW9uXSwgXCJhY3Rpb25cIik7XG4gICAgICB2YXIgZXJyb3JMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtlcnJvciwgcHJldlN0YXRlXSwgXCJlcnJvclwiKTtcbiAgICAgIHZhciBuZXh0U3RhdGVMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtuZXh0U3RhdGVdLCBcIm5leHRTdGF0ZVwiKTtcblxuICAgICAgaWYgKHByZXZTdGF0ZUxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMucHJldlN0YXRlKSBsb2dnZXJbcHJldlN0YXRlTGV2ZWxdKFwiJWMgcHJldiBzdGF0ZVwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5wcmV2U3RhdGUocHJldlN0YXRlKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBwcmV2U3RhdGUpO2Vsc2UgbG9nZ2VyW3ByZXZTdGF0ZUxldmVsXShcInByZXYgc3RhdGVcIiwgcHJldlN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbkxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMuYWN0aW9uKSBsb2dnZXJbYWN0aW9uTGV2ZWxdKFwiJWMgYWN0aW9uXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLmFjdGlvbihmb3JtYXR0ZWRBY3Rpb24pICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIGZvcm1hdHRlZEFjdGlvbik7ZWxzZSBsb2dnZXJbYWN0aW9uTGV2ZWxdKFwiYWN0aW9uXCIsIGZvcm1hdHRlZEFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvciAmJiBlcnJvckxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMuZXJyb3IpIGxvZ2dlcltlcnJvckxldmVsXShcIiVjIGVycm9yXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLmVycm9yKGVycm9yLCBwcmV2U3RhdGUpICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIGVycm9yKTtlbHNlIGxvZ2dlcltlcnJvckxldmVsXShcImVycm9yXCIsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRTdGF0ZUxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMubmV4dFN0YXRlKSBsb2dnZXJbbmV4dFN0YXRlTGV2ZWxdKFwiJWMgbmV4dCBzdGF0ZVwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5uZXh0U3RhdGUobmV4dFN0YXRlKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBuZXh0U3RhdGUpO2Vsc2UgbG9nZ2VyW25leHRTdGF0ZUxldmVsXShcIm5leHQgc3RhdGVcIiwgbmV4dFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCLigJTigJQgbG9nIGVuZCDigJTigJRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9nQnVmZmVyLmxlbmd0aCA9IDA7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgLy8gZXhpdCBlYXJseSBpZiBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSA9PT0gXCJmdW5jdGlvblwiICYmICFwcmVkaWNhdGUoZ2V0U3RhdGUsIGFjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ0VudHJ5ID0ge307XG4gICAgICAgIGxvZ0J1ZmZlci5wdXNoKGxvZ0VudHJ5KTtcblxuICAgICAgICBsb2dFbnRyeS5zdGFydGVkID0gdGltZXIubm93KCk7XG4gICAgICAgIGxvZ0VudHJ5LnN0YXJ0ZWRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgbG9nRW50cnkucHJldlN0YXRlID0gc3RhdGVUcmFuc2Zvcm1lcihnZXRTdGF0ZSgpKTtcbiAgICAgICAgbG9nRW50cnkuYWN0aW9uID0gYWN0aW9uO1xuXG4gICAgICAgIHZhciByZXR1cm5lZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobG9nRXJyb3JzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybmVkVmFsdWUgPSBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRW50cnkuZXJyb3IgPSBlcnJvclRyYW5zZm9ybWVyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5lZFZhbHVlID0gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nRW50cnkudG9vayA9IHRpbWVyLm5vdygpIC0gbG9nRW50cnkuc3RhcnRlZDtcbiAgICAgICAgbG9nRW50cnkubmV4dFN0YXRlID0gc3RhdGVUcmFuc2Zvcm1lcihnZXRTdGF0ZSgpKTtcblxuICAgICAgICBwcmludEJ1ZmZlcigpO1xuXG4gICAgICAgIGlmIChsb2dFbnRyeS5lcnJvcikgdGhyb3cgbG9nRW50cnkuZXJyb3I7XG4gICAgICAgIHJldHVybiByZXR1cm5lZFZhbHVlO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUxvZ2dlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC1sb2dnZXIvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHByb21pc2VNaWRkbGV3YXJlO1xuXG52YXIgX2lzUHJvbWlzZSA9IHJlcXVpcmUoJy4vaXNQcm9taXNlJyk7XG5cbnZhciBfaXNQcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0VHlwZXMgPSBbJ1BFTkRJTkcnLCAnRlVMRklMTEVEJywgJ1JFSkVDVEVEJ107XG5cbi8qKlxuICogQGZ1bmN0aW9uIHByb21pc2VNaWRkbGV3YXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGh1bmtcbiAqL1xuZnVuY3Rpb24gcHJvbWlzZU1pZGRsZXdhcmUoKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICB2YXIgcHJvbWlzZVR5cGVTdWZmaXhlcyA9IGNvbmZpZy5wcm9taXNlVHlwZVN1ZmZpeGVzIHx8IGRlZmF1bHRUeXBlcztcblxuICByZXR1cm4gZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcblxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgICBpZiAoISgwLCBfaXNQcm9taXNlMi5kZWZhdWx0KShhY3Rpb24ucGF5bG9hZCkgJiYgISgwLCBfaXNQcm9taXNlMi5kZWZhdWx0KShhY3Rpb24ucGF5bG9hZC5wcm9taXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY29uc3RydWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBhY3Rpb24gb2JqZWN0IHRvIGNvbnN0YW50c1xuICAgICAgICB2YXIgdHlwZSA9IGFjdGlvbi50eXBlO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICB2YXIgbWV0YSA9IGFjdGlvbi5tZXRhO1xuXG4gICAgICAgIC8vIEFzc2lnbiB2YWx1ZXMgZm9yIHByb21pc2UgdHlwZSBzdWZmaXhlc1xuXG4gICAgICAgIHZhciBfcHJvbWlzZVR5cGVTdWZmaXhlcyA9IF9zbGljZWRUb0FycmF5KHByb21pc2VUeXBlU3VmZml4ZXMsIDMpO1xuXG4gICAgICAgIHZhciBQRU5ESU5HID0gX3Byb21pc2VUeXBlU3VmZml4ZXNbMF07XG4gICAgICAgIHZhciBGVUxGSUxMRUQgPSBfcHJvbWlzZVR5cGVTdWZmaXhlc1sxXTtcbiAgICAgICAgdmFyIFJFSkVDVEVEID0gX3Byb21pc2VUeXBlU3VmZml4ZXNbMl07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRBY3Rpb25cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgcmVqZWN0ZWQgb3IgZnVsZmlsbGVkXG4gICAgICAgICAqIGZsdXggc3RhbmRhcmQgYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBJcyB0aGUgYWN0aW9uIHJlamVjdGVkP1xuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhY3Rpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGdldEFjdGlvbiA9IGZ1bmN0aW9uIGdldEFjdGlvbihuZXdQYXlsb2FkLCBpc1JlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgKyAnXycgKyAoaXNSZWplY3RlZCA/IFJFSkVDVEVEIDogRlVMRklMTEVEKVxuICAgICAgICAgIH0sIG5ld1BheWxvYWQgPyB7XG4gICAgICAgICAgICBwYXlsb2FkOiBuZXdQYXlsb2FkXG4gICAgICAgICAgfSA6IHt9LCAhIW1ldGEgPyB7IG1ldGE6IG1ldGEgfSA6IHt9LCBpc1JlamVjdGVkID8ge1xuICAgICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgICB9IDoge30pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ24gdmFsdWVzIGZvciBwcm9taXNlIGFuZCBkYXRhIHZhcmlhYmxlcy4gSW4gdGhlIGNhc2UgdGhlIHBheWxvYWRcbiAgICAgICAgICogaXMgYW4gb2JqZWN0IHdpdGggYSBgcHJvbWlzZWAgYW5kIGBkYXRhYCBwcm9wZXJ0eSwgdGhlIHZhbHVlcyBvZiB0aG9zZVxuICAgICAgICAgKiBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZC4gSW4gdGhlIGNhc2UgdGhlIHBheWxvYWQgaXMgYSBwcm9taXNlLCB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgdGhlIHBheWxvYWQgd2lsbCBiZSB1c2VkIGFuZCBkYXRhIHdpbGwgYmUgbnVsbC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgZGF0YSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoISgwLCBfaXNQcm9taXNlMi5kZWZhdWx0KShhY3Rpb24ucGF5bG9hZCkgJiYgX3R5cGVvZihhY3Rpb24ucGF5bG9hZCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHBheWxvYWQucHJvbWlzZTtcbiAgICAgICAgICBkYXRhID0gcGF5bG9hZC5kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb21pc2UgPSBwYXlsb2FkO1xuICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcnN0LCBkaXNwYXRjaCB0aGUgcGVuZGluZyBhY3Rpb24uIFRoaXMgZmx1eCBzdGFuZGFyZCBhY3Rpb24gb2JqZWN0XG4gICAgICAgICAqIGRlc2NyaWJlcyB0aGUgcGVuZGluZyBzdGF0ZSBvZiBhIHByb21pc2UgYW5kIHdpbGwgaW5jbHVkZSBhbnkgZGF0YVxuICAgICAgICAgKiAoZm9yIG9wdGltaXN0aWMgdXBkYXRlcykgYW5kL29yIG1ldGEgZnJvbSB0aGUgb3JpZ2luYWwgYWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dChfZXh0ZW5kcyh7XG4gICAgICAgICAgdHlwZTogdHlwZSArICdfJyArIFBFTkRJTkdcbiAgICAgICAgfSwgISFkYXRhID8geyBwYXlsb2FkOiBkYXRhIH0gOiB7fSwgISFtZXRhID8geyBtZXRhOiBtZXRhIH0gOiB7fSkpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEBmdW5jdGlvbiBoYW5kbGVSZWplY3RcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIERpc3BhdGNoIHRoZSByZWplY3RlZCBhY3Rpb24gYW5kIHJldHVyblxuICAgICAgICAgKiBhbiBlcnJvciBvYmplY3QuIFRoZSBlcnJvciBvYmplY3QgaXMgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgICAqIHRoYXQgd2FzIHRocm93bi4gVGhlIHVzZXIgb2YgdGhlIGxpYnJhcnkgaXMgcmVzcG9uc2libGUgZm9yXG4gICAgICAgICAqIGJlc3QgcHJhY3RpY2VzIGluIGVuc3VyZSB0aGF0IHRoZXkgYXJlIHRocm93aW5nIGFuIEVycm9yIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtcyByZWFzb24gVGhlIHJlYXNvbiB0aGUgcHJvbWlzZSB3YXMgcmVqZWN0ZWRcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBoYW5kbGVSZWplY3QgPSBmdW5jdGlvbiBoYW5kbGVSZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgdmFyIHJlamVjdGVkQWN0aW9uID0gZ2V0QWN0aW9uKHJlYXNvbiwgdHJ1ZSk7XG4gICAgICAgICAgZGlzcGF0Y2gocmVqZWN0ZWRBY3Rpb24pO1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBAZnVuY3Rpb24gaGFuZGxlRnVsZmlsbFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gRGlzcGF0Y2ggdGhlIGZ1bGZpbGxlZCBhY3Rpb24gYW5kXG4gICAgICAgICAqIHJldHVybiB0aGUgc3VjY2VzcyBvYmplY3QuIFRoZSBzdWNjZXNzIG9iamVjdCBzaG91bGRcbiAgICAgICAgICogY29udGFpbiB0aGUgdmFsdWUgYW5kIHRoZSBkaXNwYXRjaGVkIGFjdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0aGUgcHJvbWlzZSB3YXMgcmVzbG92ZWQgd2l0aFxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGhhbmRsZUZ1bGZpbGwgPSBmdW5jdGlvbiBoYW5kbGVGdWxmaWxsKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICB2YXIgcmVzb2x2ZWRBY3Rpb24gPSBnZXRBY3Rpb24odmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICBkaXNwYXRjaChyZXNvbHZlZEFjdGlvbik7XG5cbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGFjdGlvbjogcmVzb2x2ZWRBY3Rpb24gfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2Vjb25kLCBkaXNwYXRjaCBhIHJlamVjdGVkIG9yIGZ1bGZpbGxlZCBhY3Rpb24uIFRoaXMgZmx1eCBzdGFuZGFyZFxuICAgICAgICAgKiBhY3Rpb24gb2JqZWN0IHdpbGwgZGVzY3JpYmUgdGhlIHJlc29sdmVkIHN0YXRlIG9mIHRoZSBwcm9taXNlLiBJblxuICAgICAgICAgKiB0aGUgY2FzZSBvZiBhIHJlamVjdGVkIHByb21pc2UsIGl0IHdpbGwgaW5jbHVkZSBhbiBgZXJyb3JgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBvcmRlciB0byBhbGxvdyBwcm9wZXIgY2hhaW5pbmcgb2YgYWN0aW9ucyB1c2luZyBgdGhlbmAsIGEgbmV3XG4gICAgICAgICAqIHByb21pc2UgaXMgY29uc3RydWN0ZWQgYW5kIHJldHVybmVkLiBUaGlzIHByb21pc2Ugd2lsbCByZXNvbHZlXG4gICAgICAgICAqIHdpdGggdHdvIHByb3BlcnRpZXM6ICgxKSB0aGUgdmFsdWUgKGlmIGZ1bGZpbGxlZCkgb3IgcmVhc29uXG4gICAgICAgICAqIChpZiByZWplY3RlZCkgYW5kICgyKSB0aGUgZmx1eCBzdGFuZGFyZCBhY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlamVjdGVkIG9iamVjdDpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgIHJlYXNvbjogLi4uXG4gICAgICAgICAqICAgYWN0aW9uOiB7XG4gICAgICAgICAqICAgICBlcnJvcjogdHJ1ZSxcbiAgICAgICAgICogICAgIHR5cGU6ICdBQ1RJT05fUkVKRUNURUQnLFxuICAgICAgICAgKiAgICAgcGF5bG9hZDogLi4uXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bGZpbGxlZCBvYmplY3Q6XG4gICAgICAgICAqIHtcbiAgICAgICAgICogICB2YWx1ZTogLi4uXG4gICAgICAgICAqICAgYWN0aW9uOiB7XG4gICAgICAgICAqICAgICB0eXBlOiAnQUNUSU9OX0ZVTEZJTExFRCcsXG4gICAgICAgICAqICAgICBwYXlsb2FkOiAuLi5cbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oaGFuZGxlRnVsZmlsbCwgaGFuZGxlUmVqZWN0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUvZGlzdC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUvZGlzdC9pc1Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2g7XG4gICAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIHRodW5rID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKCk7XG50aHVuay53aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gdGh1bms7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgtdGh1bmsvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYXBwbHlNaWRkbGV3YXJlO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IF9jb21wb3NlMltcImRlZmF1bHRcIl0uYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvYmluZEFjdGlvbkNyZWF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMjg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbWJpbmVSZWR1Y2VycztcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAnaW5pdGlhbFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2FuaXR5KHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgc2FuaXR5RXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNhbml0eShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNhbml0eUVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNhbml0eUVycm9yKSB7XG4gICAgICB0aHJvdyBzYW5pdHlFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMjg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgd2luZG93ICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpKGdsb2JhbCB8fCB3aW5kb3cgfHwgdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L34vc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVCTEFFc0FBRC8vZ0JrUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEE2THk5amIyMXRiMjV6TG5kcGEybHRaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPa1ZwYm5OMFpXbHVYekU1TWpGZllubGZSbDlUWTJodGRYUjZaWEpmTFY5eVpYTjBiM0poZEdsdmJpNXFjR2YvMndCREFBWUVCUVlGQkFZR0JRWUhCd1lJQ2hBS0Nna0pDaFFPRHd3UUZ4UVlHQmNVRmhZYUhTVWZHaHNqSEJZV0lDd2dJeVluS1NvcEdSOHRNQzBvTUNVb0tTai8yd0JEQVFjSEJ3b0lDaE1LQ2hNb0doWWFLQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0NqL3dBQVJDQUVoQU53REFTSUFBaEVCQXhFQi84UUFIQUFBQVFVQkFRRUFBQUFBQUFBQUFBQUFCUUlEQkFZSEFBRUkvOFFBUmhBQUFnRURBd0VIQVFRR0NBUUZCUUVBQVFJREFBUVJCUkloTVFZVElrRlJZWEdCQnpLUm9SUWpNN0hCMFJVV0pFSlNjckxoTkdKemdrTlRrcUx3Q0dOa2c3UEMvOFFBR0FFQUF3RUJBQUFBQUFBQUFBQUFBQUFBQUFFQ0F3VC94QUFqRVFFQkFBSUNBd0VBQWdNQkFBQUFBQUFBQVFJUkF5RVNNVUVUSW1FRU1sR1IvOW9BREFNQkFBSVJBeEVBUHdERkpJZDJvWGg5WjMvZlQ4cU1rSjJIRk9LTTNsMGYvdlAvQUtqWFhjYnNpN09RRHpXR1Y3UEgwRVNGbkpaaVN3OWFUQ2YxcUU5TWlwTjRnaWJQVGNNWXFLT01jOURSQXMwWXlvK0tYdDlxVGJETWFtcEtyeHpXU3pJU2ttSUVjajYxSkVkTFdPZ2FNMmNUaVhBNUdEVTBRa3dqNXpTWUF5c1N2SEZQdUc3c1lQVTUrYVZwcUpxNUoxQ2JPT3RRdWFtYXQveDgzelVNRG10b3pyaWE4T2M4R3ZXSEpwSnBrNCsxZVYxZVVCNmE0SGtWNVhVak9SakpJcndHdVFIeS9LdldYYmpkbW1UelBQRmVnbjFxVkFJd1JnY244cWJuR1pUZ1lCNlViTWhkemNDcDBrZmQydzkvV284STd1UVp3YzBYampXYUU1UGxTdEVnZGFUOXkvUFEwVmdjVEp1R2FFTEgrdVpPaEJ4UlMwaDdvRWhzNThxS2NQaDh5Z1orbE9ZSHFmeHFQSU15cmpnMUpLZE90SWtWUCtLdXYrcy8rbzFOUmNnK2xRNGovYUxqL3JQL0FLalJ2UlkwbTFLeWlrQUtTVG9yRDFCWVpwWjA4VlgxVmcwbkdjRHp4US9IR2VLMUg3VkV4MjJ1NDdPMEMyY1NJZ1dJQURPUFNxSGMyMXlPdHN5aCtSbGVhV09XNGVVMVJld0diZFBpcGdTcTNGY2FqQ28yQnNkQUN2Tk94MzJwS2VjRURrN2twZUkyc1FUNlVwVXgxb0Ftc1h5Y3RDcFh6R3cwaHRldTBjQVFKN2dxYVhqVDNGbFZRRFMzeVVVZVdUVllYdEpPUHZReGZuU3Y2enNRQWJaRGpwaHFQQ2p5Z0xxbk4vUDdOaW9vRlNycVdLZVY1U0pGWmprZ0VFVjZJSUNDUVp4akhCVWVkYXhDR2Mwa2lwejIwSVFzMHNvVUhCOEhJL09tMnQ0dCtGbmJIcnMvM28yRVExNTYxT2pzMWtiQXVGSHFTcDRyMytqWk51VmtSczg5Q0tOalNBQlhvRlRWMDZRNXpKR0JUZ3NtTVpIZlJBRGc1eUtOalNLQUJnb2FmZUhjZ09lUlM0clF4TU16UXliczRDc1RTRWlMU2hqTkh0SE9DLzVVR1hhNFVFT3RLYVpkeFZnUFkxSWpDeUFCREdXUEFHOENvOTdBd1psd0JJbkRBSE5JRzdSRDN1V0dRZWhvdkJibllXQndLR2FkSXVDSkQ1OFpvcDNwSTJweUtWT0lVb1ZiancvZk5UWWhrRGRVQzRpSW5EZE1taWFJb1hMSG4wcGthbUs5NG0wODVxWUNNREpvUko0Ym8vTlN2RTNLazRwNko1QzJibTVIbDMwbitvMGYwSnpGcWRuSW9CS1RJd0I2Y0dxN0JuOUp1ZjhBclNmNmpWZzBNYjlRdGg1RngxcWVUNmVDNTlvdXpQOEFTR3AzR29UM2VaTGh0d0NnZ0RpcTlKMlVsVTVNN1NEb0FjMXBjY0phM0lZRGFENGFhbGlWc0JjQWl1U2NsblRvdUVyUG91eXNvS1p5dTdrSEo1cFYxMmR1SVZJL1NBMmZKWmVsVzI2VEYyaExOaFJqclFTNVFOSkozZWNaSkJxcG5hVnhrVlc1MFM1TW1YbE9NOGdQbWtOcGwyeFpXNUFIVVBqK0ZXWlUzQStJZ255cHlLMmFXVGFEMUI2MVhuVStLbFQ5bjdsMUpBejZaSy95cGgrelUzVXFEZ1l3cDVxK3RheWQyZUNWREhuMHA2MjB1OHZiOHgyTURTc3YzdG80VWVwUFFDbitsTHdaci9WMlZReGtSOEJzWjNEcFNwOUN1VmcvVU8wcnR5ZWh4anBXb3ZvZHRheXN1cmF0YnhZUE1Wc0RNMmZUMHJwSU96Y0IzQzAxQzdPM0Iza1JnL2hSK28vTm1FdWd5M0JqN3VPY0ZseEp2WUhMZW85cTkvb1M4aGkydzJrbTRIeE1TQ1QvQUxWcDlyZTZWR0NrR2dSRkFNWWtuWTBXdGJDMHVYa1Z0SWh0Y0RKWVROd1BYMnBYbXMrSE9PVmlkdG9Hb3RKdE1MZ055U1JnRDhhT1FkbTB0ZzRsWXN6RGxnZU1IR09LMHlmVGtnM0JWQzdtMmpjM21DQ1A0MVh0VXU0YlNCQVZVeXZuQ0lmVmo1Ky90Uit0eTlEd2tVcVRUWWJkMlZSdGNqcjFvWGMyY0tPVE9oSVBSbzN3RFIyOXVqSnU3M0N5Y0ZzZUVBRStYSE5RZFVzNUVHOHMyN1pnZ3Ixd09sYVMzNml3TGlTM3M1ZThpTXlNUWNkNWc4WTU0cUhiUlc1QmtFa3A1d1BDS0pkbnRWN2k1RnRJc1R3U1l4dUdkcCt0WGlLMnRwQkdUQmJzR0grQWV2V25sbDRpVGJOWk5QZG1EUnJKdFBuSUFLYlFOQTA0emdxY0gzclcyMDZ4VkNaTE9JcU9BUlZHN2VXa1ZuZXhyQkVzYU9tY0w1KzlHUEo1WFF1R3UxZXNaQWtwM0RJTkdySmtIaWJwNUNnMWd1U1RqcFJZT3NhQUVEUFNxcFEzZWd5U29GSEc3cUtsT28ycms5S1lMNUliQUFweG03d0hibjVvQ0pLQzl6Z2ZGVFVUQ2dVT1VFVFl6eURVNGx6NWtld3FrbXJjL3dCb3VQOEFyUDhBNmpWbDdOak9xMm94bnhpcTNhRE04K1AvQURuL0FOUnExZGswM2F6YTQ1d1Nmd0JxT1Q2ZURVNTI3dFVDa0FlZUtZaEttNnpoZ01kS2xZN3kyVGN1N0k0Tk54SWdsWTQ4dlN1RjFodCtzYksrME1DT2xETzQyUnN3SnlCNVZaSHRVNU8zSkk4alVPZTBYdVhZWlhhdlF0MTVweWxZQlF3cm5KVnNuclQwc1BnNFE3dWVRS25SeHhyanhPUFhJbzVwVmhiM1RTVDNULzJDMlR2SnlPQ3d6d2c5MlBGVmNpMEMyTm5ERllSM3VyTTBkbzVKaWhqR0hud2VjZWkrOWRlYXJMZnM4UzdiV3pCQ3Jid0RDZ1o4ejFKK2FrNmpKTHFGeEJMUGhXemhFSFJFQjRVZXdxTUlRSGxZcXVDdy9lYVcvd0RwaHBzNGhLNmdrQlc5T3RSWllNQWt1d3h4UnFhTVA0dTdYTGM1RlFiNklGUERHQU9laHFwVTJHTkpzV3VTeUpJU1diWmsrV1FlYTFUczUyZk9xeVdObzhzaGhqYnY3bDl2REJSdFJTZWg1eWZPcXY4QVo1cERYTHl6U3dyK2pJNnM3TWNaQTZEUHorNnR1N04yd2hzMmxJSGVUc1dJSDNRUElEMitLY25sbG9XK09JZWV4K2xOSVpicTJXNWZiamRJT25xYXFldi9BR2U2TEx2bUVUUnNBY2dOZ0gzOXZwV255RGc5TTRxdWRvOTYyVW1PT01ualAwcXM4WmpPaXh5dHZiQnRjN1BhUllSU2lHSWhoeURucWFwOHNTdERkUlRicEZYeHJ6bmFEajY4R3JUMnpuMk03SzJSNSt4cWx3M2tZblJKWmU3MzVRdUJuZzlSKytsaHV6WXoxdFV0YjArU3luNzZOZ0FHenZHT2M5RGlydjJYbC9TdEp0NWRnSlh3bjJPZWxRTlh0OVB2VU1aZG1PQnRiWU1xZU9UejgrdFNleDROcFp2QVN1QS9IaHlmalBTdE1ydkZFbXFQc1JKbFZBR0g2RStWVVQ3UlpBMnFRTHR3Vml3UHhxNnh6Z1RCOGNGdjhQdlZPKzBhQ1NiVzBlTUl5ckN2M1Q1bm1seC83SG42QnRHZ0RRdElXOEpiQkFvdERZd3k1TFNlRURPZmVobW16UFphY1QzWTNPL0I5S21Nelc4WnhJV0V2UE5hMW5FSzVVbGxXTnVNMUxnVXBFUWZUclVLUEJ1RHVib2NnVVZuUVBCaGZUbW1BV01rVDU2blA0MU55d1BBcUVGMnlsUWVoNjFPWGVSeFZwSXN2MjAyUC9OZi9VYXQvWTVDMnRRNE9QQzV5ZmlxaFlmdFpmOEFxUDhBNmpWNTdFSURyQ0VqL3dBTmgwK0t5NWZWVngvR2hRSURkd1JnRUFBZnVxSUpYQWxJWTdzOFpQdlJtMEN2cTBBQ1l4bno5Rk5EWXdnT0NBQWE0blVlZ01za2E4aytYSnFCY05JTFNWMmNFOTRGVmNkY2NtakZzcTVSZU1aUE5RTGtnYWV5TXErS1hJSUhJNHBRSVlrWW9ITzBESHBSeThsTmxvZW4yaWhkOTBQMDJZZW9QRVlQd0FUOWFETWpDM0dWR1NwK3RGdTJOd1lkZm1oVmVJVWloQUlCd0ZRRCtkVVNBekR2YllsY0FBOVBta05jSUlXS29NN3VnK3RLYTUyL295dEV1VEdDZmVveXlxNEdJUU10MHlmU2thWmJScmNCQVY1QzgxQnY0UWlTREhQU2lOdmN3eFRzV1FrYlR4dXhpbzJwdEdrakRKd1FyWVBVWjhqUlBZcXc2TnFqalFEWUNJdENTWGxlTmR6b05vVWNmSjYxZXRPMXk2MDdzZmFUTGFDNW1qVHUyQ3RnY2M1QXprOGM0ckxkSGxkVkllTldXUkNEMUczNmo0NlZwOGVqV3ZhTFJyQmdaSmJhM2FRdEZGSVU3MXlBQUNUNURyOGdWZUc5OUp5MXJzUzA3dE5GZmFGTnFheDdVaFF0S3BJTzBnZEt5WFcvdE4xRFY3dHJUUklvR2lrd0E3ajhmenE1NmhvQTdIL1p6clNXVUVjVWswV3dJc2pTc0J6eXpuRzV1dVRnVm1YMlVSUUxOUGJySEFaSlkyS1N5eDd5Tnk3V0hYb1IvR3J5dDEybWEzMHBuYVhWcDd1Q1FtV3p1SHpoakFmdS9TcVpxYnUxb3ZWV1d0cTF6N1BQME84V1FUV01Wb3NUS2tWdWhHNGRRT1JnYysxWTkyeGtoanUzaGl6bm8yVGs3dk90T095OVJHY3Z1bzgyb3JKRVprTzBrSGNoSG5RODZqY3dYTFNXc3pvR3lOb1BCb2VIWnRxa2xsejkwOUtlc3U3aXY0djBtTnBZMWZsRUdTMk9uRmJhMHoyMHJTWmJxUzJ0Skx0QXR4MVpRTURPZVB4RlErMWR1c2w3RzhtVkJPWEk4eFJYUjVvcjBXa3R1eGtSeGxjakgwOXFGZHQrNFc3WlF6aTVVS2RvNkFHc0ovczB2cFY1SDNTOXpFakNJTmxXWWRhZHVZSkhoM3UrVlBUSGxYT2p5V2dsSXhHcDJqMU5lejNkcmJ4cXNZY2tqb3c2R3RVQnNFTW1STDVaeHoxTkdsY2lJcFFyOUtaMFJSSGxRYzA3RmZzY3E2WnoweFZXYkl3b3hLYyt0RW95ZHZHRFE0OHluSXhrMFFSZ3E0R2Fvam1sV1Uwc2NzeUxsTzhibjZtdFA3TldFVnJwcHVGeVpjWUJQbDBxcGRqdjdSWmlHUGtoMjNmaWF2ZHJCTmJ3bU51SXl1UUQ4MXpjMlhlbXZIUHF5NlRsOVZqUG9ySG4vSWFFeE1RcTU5S0w2SjR0U0pKeUJGTC9BUHpOQlZCQ3I4ZXRjemNUdGxaaXBVRWtrNHh6NVZEdnhzMHRIZjd6U01RUFBIU243Wmp1QklrRzBldFI5ZDQwNndabUpMb3hBejA4UnBUMmRSbVltS0RJd09Pdithbk8xVzZYdFhxbTRuSXVKQi83cVp1QWYwVGN2a3BJK2FLYXRCM3ZhQzRsbVhDemlPWUVlanFHcXQ2U0UzYk1MaEEzOTBCT0tiaUlhWXFBdzVKSkhuVW02akRhakpqTzBQZ2ZTbWJUS3pGanlOcFBGQWVKbERJd1VOakdNanpxTVpqSmZYSWRza3VNazlhbGtLOGE0NnM0Sm9aS1ZGM093eG52T1BmbW5CVmdzcG5ObzNpSVhPMERQV3RPK3lTOEVtbGFoQTV3WWJqZmsvNFdYK2Ftc2xzcm5kWndLRkJiTE1UVjQreXE5eHFtbzJ3WUtseENOdWZOMUpQN2lhckMrT1d5eTd4RXZ0aTdUTFpkZ1paVnM3bDJ1d1ZqSGRrNEdjYmpqb01ldnJYeno5bld1dnArdjJwaGdrZUNRRVQ1encyZU1lbGFUck9oZHR0WWx2WmhESkpERHZpQmtuMmQ0VjhsSHB6MDZjVmtHcWFWckdsYWxKQzFzNk0yQXl4eUIrZnBXa3ZsdmFML0FCMXByWGJmdEU4VVk3bGhzSXlQWVY4L2RwWFo5VmtkemxtOFI5czFaN2U3MUZOR2tHcHh5QlZuQ1FiK1RnamtINDRxcjlvbys3MUhrNVlxQzFWeFllS2M4dkpBaDJoWkdac01BTnZybXAybGFSY2Frd2FIS3dnamZMNUtmUWVwcUZib3BMTktKTzVVZUlwamQ5TThaclV0TnM5T3N0SGhHajNNdDFhT1RMMzhvQ3V4SUhCQTRCSFRIdFdtZVhpakhIYVZwRWFXMDhFY1MrQ05RRno3VldQdEdFaDdRL3FpQW5keDd5dFdXMVA5cEc0OGpqSDFyM1d1d21xZG9OWmxleGFNUW9pT1djNEpHM09LeHh5a3kzV2xtNXFLTmNHUHVFU01zRVh4RTFEdUVnbklmZmcrUXpSTFdOTHV0T2tsdDVWSkpPQVZOVnhVekx0YzdjSEZiNDk5czZreHlneTdOd1dNK25GZWQweXpiQm5PZURUYlc4aU5nb1RucGlwTVVURndzNVpTQndLb2lTZHo1UE5FWW1Rb0NBUHhvYUJnc0tKMmlLc0l5U0NUbW1Tdy9aMjRFTnljYzk4U2ZqTmFkZDNuNlhGQUZVS0ZRTGtlWXJHK3hsMFliaDQySkN5c2NmT2ExWFNWbU52TVpFYnV4dEVaSTRQWE5jdk5QNWJhOFY2V3JzMUdHMWNaSUlXQ1ZqbnArek5DWndXQ0R6QUpJeHhSM1FXRWJhamRFWmFHellEeXlXSVQrTkFydktPb1BQQkZjN2M1R0FxQmlUdXhqQU5EdFprQlcxaklQaGpYR0Q4NW9oc0JqWGFwNUJISnpRM1YyYVdkRllEd2VCZVBMLzRhSjdGT002dmJBTG5wNjBhZGxtMC9TNzBrbnUyL28rZjJLNWFNL1ZTUi93QnRBSkJoRDdEeW9ub1YwdHEvYzNTczlsZEtZN2hWNUlIVlhYL21VOGo2anpwa2p6QUM3S2hzbnhGcy9GZWFmQ2paTXNvU1BhZHgyNUhuVFdxYWROcDJvbTJua0RNRTNDUkRsWkZKQlZoN0VZTklqa2RkUGtqMkVsK053OU92OGFORFpjU3JsUURnTG5wNVVGd1RPeEpVNzM4elJ1SUFTc1hHUWluenhRTXliRkRJcUE3dXVNbnpwd3FMd1F4ZDFGRW1kN0VzQ2dESGtjREh6VHVuVHo2Wklra1RHRzdobHlHYis0UUJnKy9uVUtPZDNzNFpYWDlZZ08wampJeUtYRmRPYlZTd0FLa25KNms5YzBHMnpzN3JPbmRwZEVsRW5kN2xIOW9oQis2VDVqejJuMXJQZTJ6OW5kRXRVdmRQamplTnQyWEI1WSs1K2FEOW5yMXB0ZDB1MnRyZ0M3dkxpT0FpRS9kUW5MNS83UXh4Ukw3Uyt4OWxaNi9iMkxQTEJwMm9ndFpNN2w0Ky9ITFF0bjdwSXd5bnp3dzhxdlZ5bTc4VHVTNmpBOWQxazNkOXRqWEZ1c25lNTh1bmxRTmJPZS91WG5tQlZXT2ZmSDhLMnJWL3NvbHRld09zOW83c0dDVzFpYWVDM3p5VVFqTHQ4akpBOU9heW5VTmVpTUloMHFMTEJjdk15K0ZmZ2VmeWE2TWIxMUdOL3NHMUlyRnR0b2hoVjVJOTZsZG45YmwwcmZDMjU3S1U3blFkVmIvRXY4UjUwSkxGbUpZbG1KNUo2azBwa1pNYnVNMWVwWnFwMjB5emxXZWFPV053eWtBcTRQQkdhdkZwZnkydGhjeW1NbktBQmcyTThWZytsMzEzcDBnbXRHeW1mRkczS044aitJclhkRTdiNkZxR2kyMW5ORWJXL0JQZXJQd0cvd0FyZENQd05jL0poWTF3eVZUdFFKbzdZWHpFaEdPQ090VmhiUVR1a2lCdVd5eFBtS3NmYW02ZmZjUnhxQlpPT04za2ZhZ21tek0xcUY2QWNBMXJqMUVaZTB1MGdEWE9UMEZPMzZvR0xZR2NVaUZ4RVNjNWFrM2JGNGlTY0RGUDZRWkZHSkpqeVBXaTBhS1VIaHpRZUJjeWpCbzFCRXhqSFUxZFNCNlJlSkE2c2MrRnlmenJidXpQYWFEV3RCaXRyZUZvelpzRmtabCs4U0NSODFnbG1NZzRiSEovZldwL1pVQXVtMzdPM1c2UVk5ZkIvdldmUGpOYlh4WHZUWCt6VDJXL1VMZlVybHJXSzRpUkZjSnVKd3diSDVVNWVXdlpkc2w5VTFBam9kc0E1NW9WWXdtODFXMXQ0eGxwSlVRRDU2L2xtcDNhT3dlNjdTTnBlbndySmV1N1N5U2trQThGZ3FqcHRDNDU4elhISFNjZURzdU5rWjFEVll3UmtFd0E1TkluMHpzM1BjQXJydHpFaEp3WHRlbisxQmJvbExpTHZnVk1ad3dJNUdPQ0taYVVHNGZEL3F6bkF4MDVwYi9vYUdaOUQwVjJLUWRwNEcvelc3RGo1cUVMTzJnMVMzaXRieU85aktsaklpbFFEMDZINHFFV1dLSUZUeVd4K0FwNnpJalF6RWtFeG5wODBXaUppeVEzZGxGcGQxS2lYTnZnMmt6SHdFTTNpaVkrWFBJUFFVTjFpM3VkUGRMUzVoTU1xZ3NRM21QYnlJNlV6TVZNN2pQR0I1VVNoMW1TSzNTMHZVVytzR0dCRE45NUIveU4xWHAwNmNVQUU3ek1SYms1SGw5YUNLUTBhcXc2blBIeFYxbTBteHZZczZMcUVRbWJsYk83YnUzYmcvZGI3cmZHYXFPdmFkZTZDSXhxZHJOYnUyQU84WEFKOVFlaCtsWGltdk5VdllJTGVDRzM4Y216OVlDZUYrdEJKNzJlOGx3WHd2R1FuQ2dmRlIxWXlRK1lKWTUvRS95cEY1ZFI2ZlpQTTNBUUVnQThrK1FyU1k2WjI3V3I3TjdpK1h0N1lIUjdhSzRudFVsMnBKbmFaSFFnRTRQa092eldtL2FsZWFoTnAwdW5kcHJiUzU5TWlFZHpKK2lHU09ZT3ZpRFJ1U1FweUNPUjBKOWFydjhBOU4rbHNOWXZibVFabXQ3ZEJJVDVTU2t1MzRCVUh4UTM3ZU5mZlVOUy9vN1RKWTFXOG5TSXlPMk1vQUZ6N0FuUDBxcnZXcFJOZlRYYUQ3YTlSN1MyK29hTm9tZ1doMDY1czVJSjViZ3VCQ2pJVllsaHhnQStnejByRkJwcTJWb2x0bmU3Y3U1R00rZy9EbjYxYzMxRnJiUVlOQnRtMjJNTEdlNksvd0RqeStXVDVxT2dIcVNmU3E3dGE0a1lucVR1NitkWEttd0doc2tSOTVIUHZUR3FJcXhKakJ5ZktpdDJ1MXZDTVo2Zk5DNXdyWFZzcHdjdjRobXJsVFU3VDdNL29pQWpuR1RTM3RFQnhzQnoxSGtLS1FLRWczRVk0cm9FVnZFUmtBWlB2VTdQUUZleHlkeDNiU2tSTHlGT2NDbjlQa2pNQ3FwM0JSZytvcUpyVHNiZ0xuQzg4VkJpa2FOdzZIRENxMXVKV0JGVnBTUnlLVGRZRURCaVJtaGtOL1BHY2dxZmtVcWU3a3VDTiswRDBBcHlEWnl6T0pQYWpsc1QzUW9CYi90RndldEYxM2dEYlRwUkIwdlRrYzNHUjl5RVNENU5hajJBdEV0dERWMVhtV1RjeCtGRlp6cGF2L2JTdlFXeTFxSFkzZEYyYnRBNHp1Y244aFdQTmVtbkY3V2ZUcjFyQzhGMUdvYVZVY0tXT01FcVZ6OGpOU2RPMTZTenZ0SXVWaDNTV3R1YlZ6dTVsWG5Id1JrRDZVSG5PSTI2ZTFKZzhNaXZnWUMxeXR6MXk1WGFTMjd3c1NmVTU1cUlrbTVaQ3cyakdEajFxY1FxUVJxY0hLRWtuMTVxSW9Sa0tmZTZEcDhVb2RJdUcyeHhLQ1FjNSthZVdRL29qa0huYUFmOXFadWltL0lQRzdBL0NuNGlvZ1FSbGR3WHhmSlkvd0FCVEpDbkxLMHA0NEFHS2c2dkcwa1lqRWp4SEFkV1U4a1VUdkNYbnVCazRMZnlGUnI4YjVJMEgrRUtlZlBOT0ZVU1NYY0Y1eU82WUhKenowNlVDN1Ezczg5aWxrODgwa0tBaUtKbkxLak54d1BMeXF3UENkN0tBUHVIZ2tlWnFxWWVUVTVXWWhva0picnlHendNZm5XbUtjamthZHhDa1pQaUFBSlBVNEZBN2tuVnUwZHBZam0zZ2J2NXZnZVgxT0tKYXRkaTF0WkpuUFFjVVA3TXdiTkJ1YjEvMjk2NXkzb3U3YUIrODFwT3B0bmYrUG9mN0tTZEsreS9XOVcrN2MzUWt1ZDJjRUt3S3hmKzBCdis2c0oxS1JydlVadFFuOFg5eTJVOUZVY2J2NVZ1M2FlYTAwbjdMZFZ0REtFTnhxa3Rza2E0QmRZNU5vVWV3U05RZmFzRTFHYmZjSkV2aWxjZ2JWNENqMVBvTWVWTC9pcWlUSEVDZ0hCa2JjY2VubC9Hdlk4SUQ1WnBESHZibkkrNk9CN1VxUTVVa2Nwa2dFZWVLcElOcnpUQ0FORTJFQjhZSFg2VVAwYUFTVGQ2M08wNEZHYmw0MWdsTXZDWU9RZk9nbWh5YmJobEFPQ000OUt1ZWszMnNlb1RDR3dibm9PZWE2MG5JMFZaaG5kSU1qNlVLMTI0ekNJODhtaVduRGRwVnFOd1dHT0liMjlTZWNVdGRIOVZ1NzM5OFRJd0xrOUFjNHBvVTdjc2h1SE1TamFUMVBPYWF6V2lDbDRxVEI5MS9pbXJVSzA2Sy9Dc2NFK21hZmtpYUNXU1BPY0hGQUx0L3dCb3RHNG53ZzZtZ3RxQ1pBUE9pcU1Rb0hXaWg1cDhrMGNONFRHVkRXNkRKSFd0VDdLc2Y2cVdQZW5vVy9lS3FIYW1hS1RzSnBGM0RDSXBaWkdqYkhtQUt0SFlrbTU3SldVa2h3RzNZSHdjVmh5OXpiVGo5ak1oWEE4K2E5UW5mRXVSOTNKRk5PY3I3QmlEVW1GRllBODdzQUVlMWN6ZElNUCtNbmFNWllkZmlrQjBJY2hUNFFBT25yU1pja3hzRG4wK0tTcS8yWEIrODc4L0FGSTBYVVJDWkFrY3lrb3U0K0VnRDYxRXM1eEdzMkNIVUtwSjh2UCtkZTMyVk1wYkJMS0FQZ0d1dFkvN0VmRHl3SE5WUFJmVDEyNmJwVy92NUhubkdjVTNkdUhJWS9lM0x6VGN3TGQ2Q2NIZi9La1RxQkh5U0NDQ2Z3b0p3YmJKSzVJNmVmbHpWWGpHMUdQK0ppeHFYcThybFJGR1NTNTNIMzlNME4xU2RiZTFZbmphSzB4aU1xcTNhcTZlNnVZcktISloyQXdQVW5BbzNxWDZqU0hzN1VaWkVFVWVPdVIwL01WVmRJa00rdlJ6UHljbGgvQ3JaZDIwcHQrK1puZ3R5MjJXUmVvSG9ENWU1OGhXMlUxcU01MzJzSGEvdE5MMmwxeVpyUGZIYXhzWElZZ3BicytHa0MrUlpteWZZWXo2VlY0WFJwTHFXTlNJb3gzYUFuSkxIcVNmTS96cVRxUGQyT2w5ekFpeG9CdFZWNHdLSHlLWWJDQ0RwSTQ3eHZrLzdZcVpEdFBXcHlweU9ENVV4SkwzTXJZNWpiN3kvd0FSU3JkKzdpMitmbFF5L3VlNGhhYnF4OElIdlZTRUg2M2RkNUtJVlBnVGx2YzB2UzRlNmlhUnVDMzdxaldrUTJtV2JMTWVlYVZQZGxRVVRqcldtdmlmN042aE4zczV4MFVZK3RXQldSTklnRGtyR0VHeEIxUEhKTlZVOUQ3MWIrN0FoaVhidUlVZUp2aWxrSXIzY3lTRmlJdHE1NDhzVXk2N1dJeUQ4VVd2QzdNVjNkUEljVUxsajJFRG1uS0s4SElxVVdabys4WWtsanlUVVZlbFNFTEdMYnhnSE5NaTRXS3NDT3RGVVVzb05DNFYzT0JuSG5VOFNPQmdVd09kbzlVMHk4N0xhUHArbVRCMmhkblllbVJWNjdFUWJPeUdsRGN4SlYrQi9uTllwcGtZTWFlSTlLM2JzZU5uWkxTVVhBekVjbno1WTFoelRXT21uRjNSQm94R2hKOFRrbmp5RlB4RHhSNWJHU01uMXIxNDhSZ0tNRHpyeVU1a0NwZzR3YTVIUVJLQ0FNNEdBYVFaTWxNOUFHUDhLZnVHSGR4b0FjK2VmbW9rZzRtNSs2b0dUUkFIM2I3M0toUTNHS24yYW9ZQUpkK0ZVWTI0UFBGQ0lnWG5MZjhBTWZ5cXlkbU5NbDFmVW9iS0lpTjU1Q043YzdWQXlUajJBNlZWbnhJZTBZT1dZWVV5ZFFQZWl2YTdzcEwyZDdLLzAxcWw1SEVNcXpXK3dsa0I5VDZnZFJpckJxVTZkaWRWdCs2N0phcnFNU1NodjAyT0w5SWNuMVVEaGZvT0tHZmFkOXBWaC9VeUdhNzA1NDlRbW1iOUZzN3hRTWtIaDNUcnRIWEJBeWNldFZqai93Q2xhelRVN1ZyWVc4ODg4Q1R5Z3NMVEo3NUkvd0M2N2pvb2JKd0R6eG1xTDJ3djhsYmFOdUR5MURaOWV2WlpiaVdTVGZMUEswMDB6SHh5c2ZNbWhseEs4OGp5U0hMR3VuRERYZFk1WmJXYnNucHBWUmVTREJjZUFIMHF3U0V0SGgyWXhFNUVaUGhQdVI5S2c2SzQvbzZKSnBFaC9WK0hkeG5IcDcxSWlsV1NGV0lLNUpIUG9EMStDT2FqTHVuUFNQY1p1cnFPSnVlZWZpaCtwemQ5cVJLOUI1Q2kwS2dTelNuSUNqQVB1YXJ6RWk5YklPT29xb1ZFZHhlSTlBY1orS3E5MU1ieTg5WWsrN1JMWEx2dW9oYnhzZDdqeEgwRkRiY0NPUEo2bXF4bjByVHJ2aGNjZ1krS0h1ZHpFMDdPNUp3S1lIU3JpU2h5UVBjVmNaMjI3UWNkT0JtcWpiQUc1aEIveHIrK3JhMFcrUXZrdDdBOUtuSlVSTzdCY256b1ZmamJKakdQZjYwZktqYWNkUlFyVmsyZ0hQbjB4U3h2WW9hbFB4bkFJcGhhZFRyV2lUOGZCR0ttSkpoZWNBMURpNFpjOU0xS2NLV29BWnBLa3hMNDhERmZRSFpVcW5aN1JZbk8waTJVZ1k1SXI1MTBtNWI5Rjh2WE5mUVdneUQraU5LSllobHRJeGcvRlkvNUU2WHdqVjB3MmphNHg3VkVOeXNUQmprL1NsZDlic2N2TVZKR1N1M3BYaldzTTZkNTNvS2pxZWdOY2pvTTNGOUgzc0prRERjTWtlbk5JbnZJdHJLQTJYOFhOUTlZamlXOFZGWThKZ2djNTVwazkyR2JlU3hBNDVwNkxacHBSRVlnQ2ZFQ2VQZXJOMksxV0swN1E2WksweGdINlNzVHV3NEFZRlNmam1xcGNpUGV1QzIwY0Rta2pZWUhSamhHWWVmdFZhTGJkTzI5L3dCbzlOaGtXMDFIUjQ4SWYyanlKSVFlTTR3UUQxODYrV1B0TDF1LzFlN3RCcWJhYzdXMlkxTnF1Q2VPU3g2bitkYlZIZGRuZTNmWnE5anVyZlVicnRSb2R1a1VzTmxNNGtuVUR3TUZCOFE4aWNaQjQ4eFdHOW83REFsZVBTMjBlMmpKRHRjZzk0eDlNSG5OYTR6K1c2enk5S3JMM1NxVmlZdjRqaHl1TWp5NHJyVTdaME8wTVIwRk01NHFkcE1Ja20zc0R0WDAvT3QyU3hXamwzUm4rOG80OWpVdHM0TFpPZXRSZTVoa3VaREFycGJrWlRka0VuLzVpbVpvQ293a2tpc2YrYk5ackVMaHBCcGdJKzh4TEgzSFNnZDFLc0Z0MzdueEhoVjh5YXNXcHFzRnFOekhiQ2d5ZmdWUWIyNE4xTzhuS3Jud3I2Q25oTmpKNGhhYWN2SVNXUEpOU1ptQWovTG1vOEgzUng3MHFUenorTmFJTXNjMTVYZWRkUUM0ZUo0Lzg0L2ZWemloQ3FHWW5tcVVDUVF3OGptcm5BQkxFc2diY3UzT0I1Q3B6VmlUT0N4NEI2VUYxTXNjQTlNNW8rWFF4a0FucFZkdlczczNYZzBzUlVNVkx0SkJFWHlvTzRZNXFJdlduVnJSS1dER3paeHNwM0FQUjF4VVJlYVYrRkVBVHBvVHVENll4WDBQYW94MHUwbWlVSkgranhyejVZVUN2bkhTam0zSG5tdnBHeXVvcGV5OXFqRmxrVlF2NEFWbC9rZkY4S0dKekRQaHNFQWNpbGk4Y25FTEhZb0pHVnlLSE8vNjg3Z3hHM2ozcjJHUllMYWJKWWs4WTlUbml1YXhySzllN2trSTd3Z3RnRElBQnBMdUZkNHBHMkVkYVN1WnBWa2hqeUJ3QjhjVTFQQkk4a2pHUHhIa2ltRGMvT1R2UGhweVJ0c0RzOHFxNFllRStkTVBDNmcrRHFCVUthVjVieWFMYit6NXgvaHA2SlVadFZ2dEI3WnphcnBkekxhM2lUTVVsaU9HQUlHUjZZUG9lQ0tSMmh2YmpVN2I5SjFPWjU5UmFRelRTbHNodHpFREhrQWVUOUtPWG5aNk84bXVMbTRrbE83YXdWU0FCZ1krZVFLRWRwYlNHeDA1RmlCM1R5cm5KNktpbkFBOGh6VzBzdW1kbFZyR1NCNjhWWnJXSkxTMVJTQmw4S005VDYwSDBheWUrdjBST2krSnF1TnpHUmFTV2lxZ0J3VEtSeUR4MDgrS3JLL0N4aUUxd280d090TjI3ZC9md1I0SURPTS9TcGJSb1NkcWdmeHBoWmxzMmx2SkFDTGVObkE5VGpBSDRtcFVoZHROUUc4V1VUY254eWtlWG9LcXRLbGxlZVI1Wm0zU3lNV1pqNWsxN0V1ZVQwL2ZXa21wcG5ic3RPQjZHdWMrZ3hUaURnNHBweGpOTUVldGVVb0RKK0s4UEZNUFJSM1E1bkVRa1p0a01Cd1hQOTRmNFI3MEJINTFaZERoZGJObzdtTUJRKzljakpHZXVhbkwwY0tlNlNiSlVqbWgxNHJjbFJ4MUpvdGNSTEczaVJkcDZNdlNvN1JyMDhqVXluUVZldE9DbDNrSWhuS2pvUm1rTG5OYVJKMUIwcGRJWHBTeDlhY0lCMG45a25IcCsrdGUxZlhXMHEvL0FFZUh2SHR0aXVJK01LU09ockk5R1h3UlpCQXlNbjJ6V2w5cFZ0N3JWWlo3Rzd0M2o3dEJ1RGRTQjVWSEpKYjJlRjZOdDJtdkhrSWl0OG4xMmRLaXpkcFpXQlJ5eXFTUHVKem1ub3RMdEJwYXp5eTNEWFVwWW9rYkFJb0J4elNScE9sU1c1RWE2aWJuY0Rsbkd6SG4rZFoveFgybDJuYk8xc3c2SmJTeTdlVWFUQy9QRkZFN2M2TTBXOXJlOFU5R0cxT0QrUFNxL0hvdGpjbmR0dVkyTEVFN3hqOE1WeDdOMmFveGxOeS9ubEdVZnZGVGNjRlRMS0Q5NzJyMHlheU11bGJsbFhoMXVDcWsrbU9hcjUxcTREeWFnenhxc3pZWWtjRXJ6aW43THM1cFZ5UUo3dStpY3R1S3Bib3kvVGtWNXFIWnpUSUlzRFV0UjVKa0EvUlYyZ255NE5FbU02RjhyMkgzR3ZTWFNrdmNSZ00zQ3FNSE5NZHQ1R056WlJTSExKRVdiNUp4L0NudE43UFl2YmVWcEpER2poeUhRRE9Ea1VHN1JYcTMycnp6eG5kR01JaDlRUFA2bk5YSk45SXU5ZGpQWTE0eGJ6aFFlOTM1WnZieXFiY1hwUU9IUjFiZDRsSzRJcDdUVWcwWFNBN05zWlU3MlNUSE9ldFJtakt1OHp0M2hsMnNyYmNEYWVSKytwOTNhdmlISnFhQVk3dHg5S0g2bGRDV3d1ZHBPNDdBYyttNy9haTRnVStqZlRwVUhWclpScGx5VVU3aHRicDVBaitkVk5GVlpSU3pZRlNQMmFZSDUwdTJUQzVQSlBXdkx3Wng2ZWZOV2g3YXJ1UWtpbXJrK1BBR0JVbXdYS0hQclNMNVZVREdOM21hRE5Rb1dYb1Q5S1JJbTA0T01pcDFwdGExQTR5T3ZOUjB0Ymk4THRCR1dVSEc0NEF6ODA5a2QwaTJ1SnJ1S1NHRXZHamdzeDRHUFBtclZzYUp6M2JBSTNrMU5QdXRWZ0hDeE1vWGFENFZPSzVwQVBDMlFENzVGWjI3WEpvNFpJd29Fd0E5ZWV0QUxpNVdLUjFpTzVTZU9lbE82aVNqRlNlQ09EUWtkYXJHRmFkeXprc3h5Zk0wdGFRZ3pUaWozcTBsaWxqNXBJOHFjQVB4VGhJdWpRNGdYYnljREFxN2FEcE13VXlYSlFaNXhueXFzNlpvTnpIcFZyZlBISXRyTVNrY203cVJSV0hUM0JCRTB2OEE2eldlZDM5UEVkMTFlNWt0MHRHamxqVk01WG9UbnBRT080dkVaekdvSlBsbmlwMXZHMXVpd2xtYmdzTTBoblhkNGZ2SHFmZXM1MTB0Rmd2WjBEN29TWHlPajhWTVhWWjBqWWZvckhQVWgrb3BDbFNDTTVPY25pcFVpdGFhVC9TRDkyMFRrcHRCeXlnZVpIa0tMb3pRMWtpSjkxazRiR09IQXhTTGpXRk1BamEwbkxrYzdtQXg4Vkg3KzNtajNic2dqakZJTGh4akc1czBhZzJScXVydW1pTXNhdkRKTTNkS0dQTzNIaUkvZDlhcVE0QUlBd1BLaVd2TkovU1VrTXZIY0FSaGM5UE0vbWFIVnBqTlJGdTFzN1F6RzgwdTFqZys3Y3lSb0NQUTBYMUdIOUZpaGlZNUt4cU0vQXhVVFRiSnJucy9wTXR1dVpZWlk1Q0NjWlZYNS9MTkV0WENYWGY0NGZncWZpc3JmaS83QlJJQUFCK0dhUks2eUk4WjREamIxOWVLWUoyb1haZ3FEN3pOMEZJaVNlN1lpMlRiR1IrMWxHQjlCMU5Wb2diYUVjb2MrRTR4WE91OEhxTTFOMUMzTVZ4amVIQkdTd0dNbnovT21kbkdSODFlMGt3NGlpSlBIRkQ1WGFlWGdkZWdwNjZrYlp0SDFvam9lbk5NZHhIeWZRVS9YWUp0clNRUUNLSkdaM0lCSUhDNTh6NlVjaWtTMkxXb1JValRpUGpnaXBXMFd5Qlk4QWUvbjgxQ3ZaRkJBWWVFOVFmSTFHOXExb3VmOVpFMGJnRlNPZ29MTkxMYW51Mk9VL3VzZXZ3YW45OElseUNTbnZ6UXJVTG9TNEdPbFBHRlROek0wbVNUa1ZIRmNHT1RYcTFhVGlkT2FkQTU4cWJVY1U2b3BndGVjVTV0YnlyeEFjQ25ndnJ4UkNRckR0SGZUNkJaNlpJUitqV3psMDU1eWFreDMwd0F4bjhhdlhaM1ROSWEyaTNhSnBibkErL0dUbjU1cTEyK2o2TXZNdlpuUW5RRWRJV0J4LzZxeXk1WlBpOGNMV2NXYlBQYVcwanQ0aXB5TStWS1pmUEJCclY3ZXcwUXdFUjludEZYWmtZN2h1UE1ZOFZleVdPa3BHQ2V6K2lFKzhMYy93RHZyTDlZMG5IV1VZMi9kSkI5cWF1TFlTb1ZZdnRJNUFPQWEwdmJwa2s1aWk3TjZPeEJ3ekMzZkM4ZFB2MUpGaHBTZnRkQzBZazgrR0dRZi83by9TUS9CanFXZ3Qyd21jZW5wVG9RN2g2SHJXc3pXR2pEWjNmWnJSNVdZQnNZbDgvL0FObE1QcHVtT015ZG5ORVQyTFRBL2dIby9XRitkWXByUXhmc2NrN2xVNVA0ZndxQnlUZ2RUMHJRUHRLc2JLMTA2MGx0ZEowNnprZWZhSmJaNVNTb1VuYWQ3RWZsVkZ0SW5udW9ZNDFMTVdCd1BZNXJmRExjMnp5bXEwclFZamE2WEJibnFtNVI3bnJVWFVQMVZ4TWNZVTVZWS9HamN0dm1KeWd3UTI0VVAxZXludUVqZUJlVzhKejBIcldFdmJUWFNyUjI4VnpjZDQ2bG1EZENjZ1o5cUs5ekkrMkdDTjVKVzRWSTFMTWVuUURrMUowdlJyMldjUXd4OTdQTGhFampRbG1iT0FCNzF2dllic3FuWmZUcml5dGhETjJtdW9jM3QyVGxMS005RXovQWNzUm5vQlZYSXBHRXgvWjUyaXU3YUdaN1NLelJ6a05lVHJGa0h6eHlmeW9nZnNsMWRWWHZ0UzB5TU1oWU12ZVNLZlFad092cjByUmRYRnJhYWhhNlgyWXNaTlp2MVFpZHBWRGhlZnZzVDRVSDREM29iTnFHb2FlOXcydTZyYWdLM0Z2RXBjN1FQdXF4d0FQajByTDlNL2pTWVlxSGJmWkRkVHpxWmUwZWpyRG5CWkk1WDZkZklmdnJ6dEJvdjlXYmsyUmFPV0krS0c0ais3TU1aejgrMWFMb21xRzVpYWJUaUk5T0liZWpRNUxmRFVFMWJVclBXb1cwdU54UENQQzVZQUVOMUJCOGlLSnlaVzlpNFl5ZE16dUxqZ2pPZlEwT3VIM2pCODZlMXUybDB2VUpMVjVGa0Nud3VweUdGREpIWnVuV3VuR2ZXTmV2S0ZRcVR3T2hxQktRV3lPbFBPanYxNEZNT3UwZ2VkWEVrQWMwcFJYQVU3RXU3am5OTWlrSEZQSUs1WXVQQ2FXcU5ucFNCeEJ4VHVQbjhhYVJUa0Nud3A5cUFzdlo3V3JtT0JNZHowSFdNR3JWSDJsdlNvSDltSUgvQU9Pbjhxem5RWkIzU1pPT0tzMExaR2V0WlpZeGVOV2dkcHI4cVQvWmg1Y1FLUDRWdzdUM3k0UDZqcDV3cC9LcTRINHJpNUl3TW5IcFdYakYrVldNZHJMOE1mOEFoajdHQk1mdXB1WHRQZk5nbU94UHNiWlA1VlcyZm5PQlhHUTRvOFlQS2paN1JYcWx2MVZrdTRja1FBZnhxTyt1M2JaTFJXWjUvd0RKL3dCNkVzNUl6Z1UyVGo5OVB4ZzhxUjJtMUNlOGh0UktzU0xHekVDT1BaMUdLcnE3TS9zOGZCeFJpOVVPTUVnNDVvY0VWWkFjZ2duenJUSHFJcVZHd1VJT0ZCNjV6U0oyR1c2L0lKcGFzbmc4UTloMXJwT1F3em5QMG9DNy9ZZGYyT25kcDcrOTFGbGo3aXljeFRzL01MRWdFcXA2c1I0UWZMUHZWM1BhdE5YczcrOWkxTmJIU0JjR0dTM2dZRzRkOWdZbG5QQ3JqamVjNVBBNlZpK2t6UzJseXp4c1J1VXFRRG5JUFdyR0lyUzQwb0kwY1F4SVg1VVo2QVkvS3M4NXVyeHVvdEdsOXJiL0FGSzJIWi9zZnBrTVl1WmR2ZmI5cG5iQjhUc1RsemdIbnB4UVM0dTlEMEhVRFByTS93RFdLK0tzRTRJdFkzSG9uV1FaR01uajJvSFlCTENlS1NKdnVNVHN5UU9oOU9sQ1pyR0tlZDVHWnQ1SExNU1NhSmpOaTVVMXJmYW5VOVN1N2llYVo0b3BTRDNhSENyajBBNEZRN0xXNWJKUDdPSGFRbk9TS1dkUFl1UVc0SFFtcFVWcEZBbTZYYTNvSzExakpwSGFzNmhkeXpUYm5EYjg1TzZsd1B2QUk4cWs2amJpWExJcERMOTBmd29kRVNyWkhROFZjOUpTWlpRbzJqclVROG4zcFpCejYrOWVxdk5NaVFPS1dBZUtVRndhWHNQSEhGQVNMZkxxTTRiNXFYR25vY2ZQSXFGR1dYRzAxTnQ1aWg1Rktta0lnT055YnZjVWg0MURlRWtDaVRTeG5SNVhBaU1ydXFBNThTTHlUK1BGRGNDaVVValFRbmNJUjZWWklTTWNZcXI2Q283aVBqbjFxMFJaSUhURlRrTVR5RURrNFBzYThZQnM5QjhVcFZQcDlLOUFJUHBuMnJOWnJhYzlSWGhRbnJ6OWFrTXJBWXh6N1UyVUo2clFERFIvTklNZkhUODZlN3Jrbm40cmpHY0dtRUtTTmlNcmc4LzRxZ3NHM0VFdjhZb3EwU25KWU5uMnFNMENsZ0FYSjhzbkZNaktnNVhBZjhLVTZsZ2VTUHJUM2RoU0F3WWUxY1l4amhEK2RBUjBWMTVEakdNNUZFSXBtU0VoanlSNlZHU05pY2JjZkJwMHF5eG5JSm9vSWtrNXpnZmhURzk5eC9kMHBRY2Y0VytLVG5QUlNmbWdHU3pqSUdlZmVrdHZZWVlxZm1udzNoQUErYTlZREdSZ21nQjd4RWNrQ2hsOWI3Sk84UVlWdW85RFZpOFRjQkNmWUNtWHMrOUxveWpCSFFuSDRWVXBXSzZCbnBYb1hKOXFrVDJ6UVRORzQ4UTgvWDNya2p4NWZsVnBOcW5oelhGZWV0U0FudFhyUjBBMmk0QXFUR3ZUaWtxaHA5RXhTTXVOVkJKSVBJd01IenIwQWYzZ2MvT0tXb1B4VGtxbDIzeVNCbmJra25uNjBBeHBIL0RRZjVSVmlUNzYvSDg2NnVxY2hpa245bjlLY2orNjMwL2ZYVjFaMVpRNkg0cE12M3E2dXBHVDUvU201UEwvQU9lVmRYVXlKbSs0UGlvTGZjK3BycTZuQ3BjZlJhZFA3UDhBR3VycVptYmY3NStLY0hYL0FMYTZ1b3BmRWQvMnIwbCtvK2E2dXBrWWwvWS9oU3ZLdXJxQThYN2crUlR6ZnNGK2E2dW9wd0oxajlwSC9rL2pVU0hvYTZ1cTU2UlRpL3hydjhYeFhWMU1IVSs3VDBmM3Z3cnE2a2NPL3dCMmxSOUQ4MTFkUkNmLzJRPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL0VpbnN0ZWluLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELy9nQkpSbWxzWlNCemIzVnlZMlU2SUdoMGRIQnpPaTh2WTI5dGJXOXVjeTUzYVd0cGJXVmthV0V1YjNKbkwzZHBhMmt2Um1sc1pUcE1aVzl1YUdGeVpGOUZkV3hsY2k1cWNHZi80Z0ljU1VORFgxQlNUMFpKVEVVQUFRRUFBQUlNYkdOdGN3SVFBQUJ0Ym5SeVVrZENJRmhaV2lBSDNBQUJBQmtBQXdBcEFEbGhZM053UVZCUVRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTl0WUFBUUFBQUFEVExXeGpiWE1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFwa1pYTmpBQUFBL0FBQUFGNWpjSEowQUFBQlhBQUFBQXQzZEhCMEFBQUJhQUFBQUJSaWEzQjBBQUFCZkFBQUFCUnlXRmxhQUFBQmtBQUFBQlJuV0ZsYUFBQUJwQUFBQUJSaVdGbGFBQUFCdUFBQUFCUnlWRkpEQUFBQnpBQUFBRUJuVkZKREFBQUJ6QUFBQUVCaVZGSkRBQUFCekFBQUFFQmtaWE5qQUFBQUFBQUFBQU5qTWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFpYaDBBQUFBQUVaQ0FBQllXVm9nQUFBQUFBQUE5dFlBQVFBQUFBRFRMVmhaV2lBQUFBQUFBQUFERmdBQUF6TUFBQUtrV0ZsYUlBQUFBQUFBQUcraUFBQTQ5UUFBQTVCWVdWb2dBQUFBQUFBQVlwa0FBTGVGQUFBWTJsaFpXaUFBQUFBQUFBQWtvQUFBRDRRQUFMYlBZM1Z5ZGdBQUFBQUFBQUFhQUFBQXl3SEpBMk1Ga2dockMvWVFQeFZSR3pRaDhTbVFNaGc3a2tZRlVYZGQ3V3R3ZWdXSnNacDhyR20vZmRQRDZURC8vLy9iQUVNQUJnUUZCZ1VFQmdZRkJnY0hCZ2dLRUFvS0NRa0tGQTRQREJBWEZCZ1lGeFFXRmhvZEpSOGFHeU1jRmhZZ0xDQWpKaWNwS2lrWkh5MHdMU2d3SlNncEtQL2JBRU1CQndjSENnZ0tFd29LRXlnYUZob29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS1AvQUFCRUlBUjhBM0FNQklnQUNFUUVERVFIL3hBQWNBQUFCQlFFQkFRQUFBQUFBQUFBQUFBQUdBUU1FQlFjQ0FBai94QUJNRUFBQkF3SUVBd1VGQmdNR0FnWUxBQUFCQWdNUkFBUUZFaUV4QmtGUkV5SmhjWUVIRkRLUm9TTkNVckhCMFNUaDhCVVdNelJpOFhLQ1ExUnprOFRUSlVSVFk1U2lvNlN5czhQL3hBQWFBUUFDQXdFQkFBQUFBQUFBQUFBQUFBQUNBd0FCQkFVRy84UUFKUkVBQWdJQ0F3QUNBZ01CQVFBQUFBQUFBQUVDRVFNaEJCSXhJa0VUVVNNeVlRVlMvOW9BREFNQkFBSVJBeEVBUHdENTR4TXQrOEt5TmhLU1NmVCt0NmdxaWRCOHFrNGhQYnFDdVdsUkkxazBsQm5oRTZqZWxiV1VLU3R0U2tMR29LU1FmblhKK0lVbmxWbFdLb2c2eDQxNEFURVVnRW45YTkwcVVXZHlJNUUwZ2puU2VBNVY0ZERVb2gwRlNJcndVWkpyam5GZEhwVUpZcEovbzE1SzQxL1N1RDQ3eFM5ZVlxVVMyZEZSSTVWMEZ5UDNGTkNOTmhYUWd4Q2hPNEFxVVN4VktNVHRYaW84K2RjS01DU2ZEV2x5a0dJZzFLSnNYT2ZDYTc3WlU3SkgvS0tiTVRxVDUwa2dRUjlhbEZXUGg1WFBLUno3Z3B6dGlCR2hUMHFPUkkwRmVqclVwRjJ4NHVBZ1FsSUk1Z1FhVE1UdjlhYjlLOXZ2VlVTMmRsWkIwMXIzYkVwZ0pRQi93aXVCRWVQV2tCQUVFYTFLSlk4cTRkVUNCQVNCSGRTQlhIYXFqVlJqa0lyalFHWlNUMHJ4a2t5UlBPcFJMWjRMSUlxM3d1NGFSYkVPMktMaFdiUlp6YmRONnBsQ0R5OUtzY1B1aXl3VWdyQXpUM1RwVUpZdUlvaTRjMEFHWWlCVUdOZldyTEVKVmNPR1pCVWRhZ3FFVEkwbXFSR01FYWpxZVZJUnBIV25DTnBFVndSQko1MFJSeVFLWFdhOEppdmE1djUxQ0h1bkt2R0JwcFN4WFBPb1E2SDBwZXNhZU5Ja0dZQWtuYWk3Z25oK3d4dkVuTEc5VStsOHQ1MEtRNWxBMDZScnNlbTRxMHJLYlNWZ2dkNmZ0TFp5NmVEVElsUjE4QU9wb292dUNMeTF4KzVzbE9vOTJhVUllT2hVa2lSQ2V2THBJcVhpTmszaHRvR0xOQVMxQXpLbVZPSHFUVk10YkhmWnJoMWc3eFdpM3VMWnE5TFRDM1dtM2w1VXZQQ0FoSjVBYjd6NDFxMTJjR3h0OVdGNHpoU0VKUWhDdXhXeUczR2xEY3AwMVRQekhLc2U0WVN0akdMWjhFNWlvaElCMU02VDVDdDlZWVk0Z3MyeGRFQzZhMVM0UGpiVjFCNWcxRnZSSkt0bVpjVGV6M0ViRzBLc0hidDhRdzR5VXVXOXMybTViQk13U0JKSGtmQ0lvR2Rid3E1VmRzWW93TFcrUjNtM0xJSlpCVitGYlI3bzU2cEFQaFcvbCs4d0paYnVra0puUnhHcVZIcjRWVzhVWVRoZkZsaTZ0UFpzNHEwUHM3b0NRZjhBU3ZxRFYxK2dVLzJZSi9aTm9ZaCs1QlBWQ0ZSNnlKK1FwVllOYUpRa291N2h5ZC80ZEtTUC9xR3BsNWh3UmMzRnUrMFdMdTNVUTRsR3dQV09oR3RWUlU2MHNONTh4TzBhazBOak9wTnh6aGUvd25EclRFVEQrRzNTUXBENkI4TXlJV05jcGtFYmtlUEtxRTd4c2FPY0J4dTZ0Y0t1OEp2UUg3RjVDajJaM1JtMEpISTlZUE9nKzl0RjJ4UXNkOWhVaERnMk1IWTlENEdyOUJxaUxQU2s5ZVZLQkJNN1Vta0NvV2U4cTlKNWhKOUs4TmE5QUFxRVBBK0EycjBpRDNZL1N2YVY0ODZvaHp6bllWTnMybkhHWlpMb0FKQnl0WmhQbjVSVUk3MU50QS8yWDJDOHFaMTA1ODZzaE12a3FiZlVsU1lJSm1ETlF5Tk5kNXFmaXlpNWlGeXRSNzNhSzV6enFGRzM3VUNlaTJ0alMwaU5wOUthVW1CcnZVc3AxNWIwMnBFbnlvaWlLVW5VaWtqWGFuMUk3eCt0TnFUc1BwRldpaHNmclN4clBuWGhwSU5LZE5RS2hDMXMyTGUzdEdibHg0RzZVNUNHY3VrZFZIa2FsWU5qRHVCNDh6Zk5KbnM4eVZEL0FFcUJCK1ZWdDR3NHdrV3JuZFVoS1ZLSFNkZjFwdGpOY0dVa3FYOE9VRFVua2FOdWdmVGIzN2UzeGF5YXYyRkJOeVd3UTRDVkIxSkVwa0hmYzY2YzZITGdNT0gzZS9BUXBXcUZBOTFYa2V2Z2FYZ3hHTVlkaDZiUm9zbHM2NVhHVk9LUlBJUXBPV1BHYXRyN0Qzc1JEZHRkTHpBS0tnaktrcUU5TW9IMUpxNU9MOEJncEwxNkpQQi9CN3ZhS3VseTIwc3dra1NvcG5UVGxPbEhkbFpQNEpjcExzRnB5STBranpxbzRSdHNjd3A1dHkwV2wvRFdoQnRMMXdsVUQ4RGtkMCtCa1Vmb1V6akNVZGsyNjFjcWsrNVhLQ2gxVWJsSVBkV254U1NLRlJRVGJIQmF0WDdLMm5VcFdoU2ZpalFlQnJNdUx1RCtJc1BiZS9zQktMaTNNcTdJS0NWQTlCT2grbEdiejE1WU9ydG1VcmJRQ1R0M3ZueXFOY1l2ZUlUTFdkMXprcFNpZnB6cTIwL1NsYThQbXU0R0lXV1BQbkYyTGhxK2RCS2t2cHlxVWR2S1BLdXJlMURDWlVTcDFVRlNoK1FyWXZhYmFweFQyY1gxNjZBN2UyWlMrQ1JxazVnREhRUVRXUTJUajJJcFFMZElWbCtMWFUrbEprdXV4MFpObmJUSksxd3NqVHBYVDFrZ3NLUTRncWFXUm1STUVrQXdwSkd5aEoxMk94a1U4aHRVNVZTbUkzRVU2NGxTa0U1U1kwMUZTeU5PZ1R4YkRsV0RxY2l3N2J1QWx0MkltTjBrY2xEbVBYYW9ITDlLTWJxM0wxdGNzclVRZ3RMY2ovV2hKS1QrbmxOQi9JRVJGR25ZTFZDVjZrSTFwZkxhb1E5WG84YTlIU1BPazI2VkNoSkdZVHI1MUxRVzB0TmxUeWtsUW5LVUV4ckhMeXFHUnJUcmlWS1MzcWRFeHI1bW9XWE9LWmZmYmdvK0h0Rng0aVRVUUNwbUtrbS91bFFSbWNVcUR5MXFJQkNlbTFBdkFuNklOZHV0TEdtc3pYUmdhYlRTSGZ4bU5EVm9GamJpQVFJaW1DZ3lacWNFeUNhNVVnRTdhVlpSWHJUQmcrbGNSMTU2Vk9kYUdXVWtWRlVnZ3hyMHF5RHJEN3o3d0MxRjF4V2dLdC9uUlR3N2JwYmN6c3BCV2tkKzRWb2xJNkQ5NkhzT2FUbnpMSnlEZktkVitGSEhEdGdyRTFwN1JJUmJOZjhBUnArRWVIaWRmU2hsT2dvd0NIRDhRTExRUmIyeTNtTk11NHplZzFpcm15dk1iU0Q3cGdqYUU5UTJxVDZreWF2OER3OWxsdE1JQTZuZWl1MVpUa0EweTcwbDVHTmpqUUFuRytLV0draFZpVVpWYVJiS1VQb2FsVzNIRndvZGppdGhiUDhBZUNnMnA1YkJrY3hJMFBqTmFUYTJTVmdrRFRtUlhkNWdWbGVXNmtYTnUwNmc3aFltcVdTZjB5M2lqOWxEdy9pK0hZeDlqYUt1Y0x1VXBVcjNaNXdQb2VFYjVwSjBKNUdmQ2xlc1RjVzd6d1o3SjF0d3RQTlpncklyY1FSdWtqVko1aWVZTkQyTDhKUFlBOE1Vd0FyV2hrNTEyaE1uU2U4Z25jeE9oM0duU2lEaDdpSzF4SzBSY1d5MkE2NG1Gb2MrRlkvQ29hU0pueFNhZGp5ZHRTOUU1TWZYYThLZG0zUzdkTzJGd2hKdEwxb3RFTDFFeUNKOHlBUFdnMzJqK3lwVm80ckZ1RUd5MFc0VXExYU9xZE4wZVBoV200alpkcG5ldEJtYlI5b3BCMGNaMSs4TjRuWld4ODZ2RVhDZ0FyS2t1ZGVkT1VVOU1VNU5PejVyd0M1dDhaVWJXL2FTeGlhQi93QUljSDRnUHpGUjdHMVVHNzBQZy93NjhwSFdkYTBYMm04RzIrSk1PWXBoYUUybUtXNTdSWmEwemY2Z09SbmZyV2U0TmpUTisrNWFZa2syK0lySTdRQTVVT3FBaWR0NEZacHdjSG8wUmwyUTFhdUN5eEN4dlhFeWkzZlE4c1JNcEI3dzEzRVZaY1ZjRTJlSnFmZHdkcEZwaUNKVUcwaksxY3AzR24zRkVSSEttOFh0RkphSVFnRkdzamMrSXJSN3V4elhUU2hyT1ZNandTQUQ4aFJRM3NHZWo1bnVHSGJkNXhtNGJXMDhnNVZ0ckVLU2FiMUIwcmFlSitITGJGeUc3eGsrOGdGTGQwMW9vZWY0aDRHc3E0aHdWL0JuMEJiaUhyZDRFdFBJMENvMElJNUVkS1lBbVZSMTg2VHBYcVRuVUpZbFNGU1VOa3B6ZDBSb2RLam5lblZLVUVOZ2QyRS9xYWhFWG1NSktjUmV6SE1Tb24xcUZxb2d6NTAvaVJQdjF4bTNEcXdPZk9vNkRsMjNwYThHUDBjT3Bub2FWR25lVUpGSkJLdGRFalduVXBrUU9XdXAycXloQWxTdHpBRmVBSUVjcWVTTXVtNXBRbktkZktyVEtHQ2tCT3hBalh3cU8ra0RZUk9ncWU0azVUcm9haXFqdFVFZ1FBVlJ5Ty84cXV5cUZZbHR4Q0c1N1E4L3dEcjUxcXZCTENXc05aME1LT29uUVZsT0hkNTU5eFJKaE8vald2Y0tJV213WVFVd3FBYXpaWHMwUVh4TkJzRkFJVEd3K3RXOXE0QVRyUTYycFZ2YkZ3eENSSjlLdE1KVXE0T2N6SUhJVXB1eGtZMEZkaTdsVEE1K05XS0ZKalNJTy84QXRWTmg2b0crdStsVHdveG1NNmN3S09EcEVhc1M3U0RKamY4QU9zUzQvdEhlSDhXL3RPMWJ6WWRjci9pR1JwQ3o5NEg3cWoxNml0bnVuSVR6Z2IwRzhaMlNjUXdlNXQxQW5PbjY5YUtTdFdWR1NUMzREdkRIR0RhbDJscmlMNVhhT3FIdWw4UUFwdGZKSy9IbDQwZDNHTzJkcmVvWnZvdEhGckpCV1lhVkhOQzl0ZWgxRmZOOWsrcXhjdWJLNUJWYnVISzRrN0pJMldQRWFlbGFUWjQvYVlsd20vaE9LTFNNUmFhN0ZJVi8wbWtKV1BUZitkT3haYld4R2ZEMGxyd0xNUXhOaGJ6TDF1NjI2MjYwdEp5S0JoV2NrcE1jNEkrZFlqN1NNSFFtL0Z6YklBQkVrRHAvS3RCeHhGcHcxam9iZFNHY1BMVFNISEVwaExUaVV4bVVCeU9xU2ZLcVhpNWp0N0J0NWhZY2JLd3BLeEJDa0s1eU9XbTlITGIyS2pyd0FjSzRpdUxRQm0velhOc05Bb243UkhoUFAxb3d3dmp4RmtodHRiNjc2elNwT1ZKaExyWUIxMVB4Q09WQ2Q3aGFrUDhBd2ZGb29ScDUxVVBXb3p0QUpFcUpTUjRpbCtQUXoxRzNQNHhZWWt5WGNKdTdkNUx3aElXNEVFRW43eVRxUEtzNzlxYmR2YllkaGRxMHNLVzB0WGUyS2hHcCtldEJDcmZNNEVwYlNwZVlBUU5ablNwL0dXSUt2OGJlbHdPSlpKYkNrL0NTTnlQQW5XbXAyTGFvb052U3ZIYm5YanFERmNuZUtzbzkrdGR1QlJTM0FFQk9ranhOY0FTYTdJVkNlOEJwMThhb3RGdGlhaDc5Y0VjM0ZHUFdtRUNTU2R6VW5HQWtZaGNJYkgyYVhWaFBpTXgxcUsyRE93M3BhOEdQMGVKbE9VYUNkdXRPdEo1a2VNVndrWmlDbW4yMHAzR3cxbW9TaDFLRktwZnZRUG52VHJjZG1lcE90S2tBVEFCTWJURlN5VVIzZFFkQ0RGUUxvbHJQQjE3b0hQbFA1MWJ1Q1cxRXgzWWlxbDhCVDZpcUpCekFEYXJSVkV2QXJaeGJTMTZKVG0zTmFOaE9PMjF1cHBydEc1QUEwSTE1L3dCQ3Myd3BMOTBoTGR2M2xaaURPZ0E2azZhQ3JZTllLNGdzb3hLNGR1Z0pWa3R6aytmNjFteUszWnJ4MTFTYk5nWGk3ZDdaM2JkdkNuQXlvZ0o2MU1zc2FPSG9DMU5xVWs2d0JKMjZVRCt4MXQyNHhkL09GT1c2Q243UWpSSjEwTkdYSDdwd2hoTGpUSUtYMTVRUnBCTko4dHNjNCtSWDJXRnQ3UWJWdHhMYXV4bm1GS016KzlGT0Q4VVdXSkhzMnloRGcrN05ZZGhuRVRHR1hTTzBRSFhGclZsQXRBVzFFQkpPWmN5QkNrL01WcUZ2ZTJkNjRxMHViSldHNHEybk1XRmJMSDRtMWN4NEhVVmE3MWJRTFVMcUxzTHJsWlVreUI0K05WZDRKWVZHc2crbFA0WThYV0NoM2RPaFVlWS9lbXJ4Q2dsUlVFZ0hsVFl5WW1jVEF1TTdMM2JHbmlCM0ZxekQ5YVpzWGtYMXI3azZQNHUzNzFzN3pJR3VYMGphaXYyZ1dwZGZRNEJySkVnVUJOanNWQndrb1UzM3BuVUdnVDZqZXY1RlFaOFVZdU1YNFpXK3NEMzFZOTNXam1YQ1J0NEhlaEl2WW5ncjkzYjJTd3F3YlFGS1plVG1RU0l6S0EzU1NlbFQyN3BiYWplTnRJZGJjeWwxQjNiV05sQWROVHI0MUN4N0VVTzROZU9KMWRLY2t6cnZ2K1ZhNHk3R09VWERSS3N1SmNLeEZwSzhSL2dsQld1WXlrZ0Q3cEFtZkNQS2FwTVF1OEdUZEZkbmRxV2hKS2tEM2RZMWp4QTYwUEphVXF5S3hPeVZEOWFoaU52R21PS0ZLVExwdkUyYlc3WnVXQ3B4MXAwT29HU0VnamFTZGQvQ3FRU0VBRWt3SW1sMzJyM2pWbEhPMGJVbjFycWtOUWdnM0hPbFdCbFIzbzA2eHpOSU5DS1V3UW5UbCt0VVdpNnhNSjk3ZUkxbFoxbWRlZjUxSEc1OERGUFlrb205dUJtbFBhS2p5bW1BWjAxamZ6cFM4R1AwbE5JT1V6ck1iYlUrVWxSQWlkZGRkcWpvY09kQ1FERS9wVmczb2taWk0vU3FZU0ZiUVNJa21laGtWM2tsUkNTWjJNR3UwaUFJQWdiazArMGdaVEJtUEdLbGxVS0dBR1NOU0FJMU5VZUp0ZG00RmlJSWlpTHMrNEFtWWlPVk0zOWg3ell1SlpTU3RCempsUFdvcFVWUlY0RmhydC9aT3NNQXFXNGZobUFST3MwY1hkcmFjUDRFVXMyZG8xY0tBU0FrQXJjVjRuejhhRStIN3gzRGxEczRDaUNsVTdqV2kzaFcxWGoyT0IyNGh4TEVaVWRWY3ZsV1hMT1NrMGRMQmlVa24ralN2WnJncmVFWUdsSkFVNnZ2TFZ6VW82ay9rS3Z1TExOdSs0ZWRaS0cxT0VoVGFsQ2NxaHNhazI5b3F5dG0yeVNwUlNDUURWYmk5OFFVdExTVWlZMTUwTzE2WFhhV2dMd2xoeTFjeTMrR1owQllWS1dPMVFzaUlKMGs3RGZvT2xHVDl0YjQycExsMGg0dnpuUTZRV2xKUCttUUs3d2R0eHQzT1RtYm1RRFJLbHhPVWMwbWlqZFZZRTRwU3RJcTdERHZkbEdYbkhEckFVWWo2VjdFbEpEWkFNQ05kZDZtWFRxVzBoV20rMUQrSlhvSXlnbWF2WXVrQ1hFclNIMEhTZk9zMHh5MU51NHB0WUlTcFVpT2VrMXFWNG1VTGNPM0lVTDhRcHQ3NXhKdDBGZnVDQ0hDTk84cU9menBjNVVPd1IzWUlvdTBOdDlxd3VTQVpCR25pRDRWVjRxVzNzS1c1YkpXaEQ0ektRVE9UWFlIbnFQclVqRmxCaHAwNVFsVGlvZ0dkOUFLZzRobFp3OXRDcDBSQThTWXJWeFUyN1puNXpVZEk0dzFzWEdCSkJJK3lleVpmQlEzK2FSVkFwQlE0dEIzU29waWVsRWVBb1VNQ3ZuUjhQYUlBRWM1bVo5RFZWajZFdDQzZXBUOFBhWmhIaWtHdGpXck9jbnVpQ1pwTnRKcFJxRE5kZm5RaERlMjFKOUs3T3gxcmc4NmhEMWVVWWlCUHJYZ09acnNtQU54UFExVENqNldsK2hJZWRqa28vblRLQjNaMkZTY1NNWFRxUnNGSDg2aW8xVU9sTFhnYjlIbXdjdzExSmpTcmEwSUlBbmxJTlZZT29NZDRIbUtsMnJwQ3hyRWJlTkN5MFhEYUlQZDJIS05UcitkUG9RZ0o3L2RQV0tqSUpjNlFSVTVoQlFmaDAzMEg1VURDSDBNcElUazE1Q1JCSHJVOWkzaUZEV1FlNmYzcG0zYVdWcXltQWRaMzVWWU1OeVlJZ2lkcUNUSWdWNG5zeFozU0hXUkNIUWR2eERlbXNGeFIvRFN0NjNlN054U2hHdSsxWHZFOXVGWVN0eU8rMHZOTWNqdUtFN05uTmROcUtPNEZBbmxvS0N1eTJiY1UzR09qYXNQNGt4ekU3ZnQ4SXQxdUJNU2wxSlNUNGFuWDBxeXRVNHpqeTMwWDltTFZDR2prY1BkbGZJZk1WQTRmeE1XZHc1bU9WdHpLWkhMU2laZkVGc3Z1ZHBIbVRyNTBLaGEyeTVaVkZ1b25QQ3VKQzd0dXlmQVJkcy9adW9PNElOWGEzVW8wT25oUVZlTzJ6bHd1K3NuQTNmTkRNb0pnZHFrY2lQeU5Xcjk5MnpUYXdTY3drSG1ha0xXaVNsR1h5Uk52M3prN3VvMzlhb0ZCVGlwMXkxWnJVVk5HZG8yamVvUkl6a2lCNFV6cUtjdjBWbDhVaHNoUnlwa0pCT21wSUg2MVE4YVhGcmhlR09neENnRXBRQm9WUnVlcHFYeFNsMTlwcTF0eWUwY1ZJOU5mMHJKdUo3Mi91OFNMTjQ2VkZneGxKMEI2MEhUdk92b05UVU1kL1pHZGZMcmlYcmtETVREYllQMXFIaUR5M015bDZaUnQ1MDAwRkc5UkprekdncVd1M0Q2NGVXT3pCZ050Q1lIajByb1k0cEtrY3pKSnlkc011RjhKVC9kZEFkbjdSMHFLZW9BQUg1cVArMUFPT0JTY1p2RXJWbktITXNqbUJvUHBGYXhoRi9aS3dvdDI5eXcwcUNsS2JoUVJrMGc4elBtUGxXVTR4bFZpbHdwQ2dwQldTa2ptS2ZQU3BDSVhic2hKMDNyM0k3MTBJQTZUWFBYOXFTeHh6OWE1TVR2WFhMeHBPUjZkS29naDEyTmRrd0FJNWRhYkExcDRuUVpZR2xSaDQ5c3NyNXhLN3E0V2tDRk9LSWpwT2xNNkFURk8zSklmZEJHeWxiZWRNZ2tIV1NRZGFXRS9SOXM1UjRuZUtmUU5nUnowcU0yb0VwSmsrSHJVbEcrbXZYeG9TMFhkcEVJSmlScEE1MWFzR0ZKMUdnMEhoTlUySHdqS05mSWIxYnNwSkFKSGxJMjlLWElNdFd3a0FFcFRKK1ZUbXlCRWZFQnJIT3E5cVFtTWtrUkEvT3BXVXBJME8zTDYwcGtSM2NvUmNNS2FjQUNIVWxFSHg1MER0UE9XUzRXVkpXeWNxaEEvV2pncXlvVE1HT1g3MFA4UTJnRDZMb3A3cGhEZ0EzNkg5S2lZM0hLZzM0Y3hIQjNiTzBEeTNoMnFRQzRzSFJSNUVnMFRwd3ZERk41Y3lDMmRpSm41eldZNEZoMXdsaHkzWkNYV0ZLMENpUVVuemcwZFdOcGNzc2dQclFTUDljelFKV3pUS2V0SW4zV0FZYWkzY2VzbSt6dUVvN3FnbzYrQjFxTWhaU0xaSDRSbUlwN3RpRUZQWGVUdFVWYmpiYmhKVkJJK1ZQakdqSk9iWllDNEpXclRTbUgza3BsUUlBMTFxQ2JtZEVhODRtdTJyTnk3K05SUzNNR1B2VVRWQWQ5amRtbFQ3N3Q0UkNVakkyU04rcHJHZUswazQ3ZHJTUUZCVUdERmJ0aUFETmlHMmhsQUVKSFNzWTRpc1VYVFdJWGpDZ0hXVkxVdFA0a0E3am9SUXcxSUtUdUxCYXhTRlhpYzNOSi9LaVBER0VxSlF5em5DZThvRG1OdlRwNjBMcGRMTGdVblZRbUovcldwS01Wdlc3WjlwcDR0b2ZUa1hsRUhMekE2VC9LdDBXa1lwSnZ3UGJiRDdkOWJaZHRqYXNMYzdOTG5iSkFKOHp5MzJyUHNhVWhlSzNoWlFFTmgwcFFnYTVRTkJURGp6cmphR25YbHJiUnFoSzFGUVQ1QTdVM3lOWEtTWlVZdGVpUVpQV3VSRWJiMTQ2Y3Q2OEprVUFhRWl1YTdWc0s0UG5WRUZTQVNQR3BuWUxRbFBhSXlraWU5ejFJcUdEQnFhSmNiUm55SEtJQktRVEVrNyt0REx3YmhTY3RraS9KOTh1U1pudFZILzVqVENOeHBYYjVsMWNmalBPYTRURUVuMG9TUDBWSmhVRXlLa051WllDZmlPNXFOT1dQMHJvTDFFUlVaRVhsbXRPWVNxSW5sVjVablAzazhqdnpvYXNIUkFnRTBTV0svaEpJMC9xS1hJTk11R3RXOUJ2eU5TRUs3b25ValNhYlpuS0JJbUprMCtsWUh4SFNTT3UxSmFMUjBrQWlUcE5RY1NRMExWOVQ0UFpCQkN0UVBXYWtyY1NmaEFram5wUWh4dGlBYXRoYXRyQ2xGV1pVSytId29zZVB2S2lwejZxeC9oemlSV0dKVWhhVk9Na3lDbU82ZVlOSFZweFBaUFc2Vjl1U1NOVTh4V0lZZmRsdTVSbVhsQk1abzA5UjBva1E3Mkt3bHl6Ylc0b1prcWJYQWNIaFRaWSt2aEZQdnMwdiszMm5pUXd1VG9DWmlucmNtNUlVZGZIbFFYZ1dMMmh1T3p1TE1NY3BWcnIrVmFOWU1JZllRdTJVZ29qUVQvV2xCMm9Kd2JPclZpU0N2YnBQNTFaV2d6T1FQaFR5Tk1Nc2thS2tENVZPUVVNTktXNGNxVWlUT3dxcnRXRDFyUlhjUk9oakQzbHFWQkNUcjBGQVdFWVFwL0I4WGRkUVQyalNyZHNIY3FXWmp6MCtkRXVNbTR4ZTd0MHBRVVc2bEZTRVJxdVB2S1BJRGxWeTdhcFJnK0QyMXVnSlFwMHVLS2RjMEVpUjFHMnZQV2l4UnQyeThzdXFwSHpiY3RMdDdsMWh3ZmFOTExhdk5KSVAxRk5FK1pvcDlwakxEUEhPS290aWtKS2tLVkg0eWdGWDEvT2hWV3BJbXRWR1VXZjMwcjIwN1VnM01nMHBnVDRWWkJ0V25LdmN4WFIyMnBDUENxTEVNY3pyWEozRWZXdWlEL3RTS0ErdFFoejk2clMzU095VE1iRGZ5RlZjQ2ZXclcxQVUwTW8wQVNQWEtLQ2ZnN0IvWWJjRU9xQm5Rbld1ZE5QUGFuTGtaWFhBZERtTk1xT29qblFndlRGSm5mNVJTSk5MRWpTa0hqNjYxWkN4dzV3aHdUOEpFUkZFK0dySlNOWU92TG5RamFuS29IVFR4cStzN3RGdTBwYmtJVDFWejhvb0pKc0pPbHNLMmxoTGFFaFV6eUc1cXB4UEhiV3pLZzg4blA4QWdUcXIxNmV0REdNWS9kT29MZG9TeXlvNnIxeksvYWgwSWt5WkpKMUo1MGNjRlA1QzNsdGZFSXNUNHJ1SHdVV3FPeVQrSTdtcUM1dUhMaFdkMVJLanoxL1dwdHBaczNRbEJLU04wenFLZGR3Z2hKTFpKamxXNkhHbTQzRmFNY3VSQlNxVDJWRUtBMUVwTlgrRFlxR0cwMnQrZ1BXcXhJekE5MDlRUnFDT284aklxbWNaVTNJQWtjd2E4MCtVSUtkWUE3cDZUU25CTDR5R3FiZTRtbzRUYTRMY0JDSDcrNHNVcUhjZGVRbTVZVi96b3lsSTlEUlRobUdQNFpjdXNXN3JieGJJTTI3bVpDZ1JJVUFkZFFSV000QzlmTU9YQnNTaDl0cHBUejdDanVnZkVvRHFOekZhL3dBSzR0YVlyZ3pZdzExYW4ybTBvdUdsQ0ZOSFVEekJBR29yTGx3MnJScXg1cTFJS08zVjJZVzVLWS9FSXFMWnVLeHpFMHNwemU2QmVSS1lndXFISVRVaXp0VUJzdUl6QmZOSjFCOEQxR3RVMXZnSDlyUExiUXAxVnUwdklodU5VQTh5T3BJMzlCU3Z4dTB2b05aRjFiK3cvc3VFWGIxeDI2eCsxY3RNS1lqS3lvWlZQSkJudkg4Sk95UjZrN1U3aWVGdllnNmxTbkJic3BTUXBMYVIzRWJrQThnQkdzY3BvRGJ3amlYZ3pDci9BQnJENzgzTmcwQTY5aHJoenNPSUJnN2FwVUpCMDFxS3YycVlqeEp3amkrSHQ0QlpXQWVhVGJPNGcxZUs3Z2NNRVpWRGZMbTJPbTlhb3BHYVgrR1NZamRveHZHYnQ1UVBaM2o2M1VEWWdmZEkvd0NVQ3F5NncxMXRjTi9hb0czV3B5TElxVm50WlFwdFNuRUlXQ0ZCS1FDREhpSm9oU3czZDJUTi9hZ2RtdE9ZaVBoVU54ODYyNE1jTWtYR1hwaTVHV1dLU2xIeGdBUVIxTmVPbFcySld6VGQyNjJSbElVWUk4NnJIVzFJVnlVT1JHMVpwUmNYUnFqTlNHOVJ5M3J3NjE2SUlyMGFkS1d4Z2hFZEtUV3VsQ0JYSkhJYzZvZ2huZU5hdGNPR1pnbU9jZlFWVnhySnE0d2xKVmJFNi9GK2dvTWpwRHNDdVl6ZEt6UHVxTzZscU92blVjK0VWS3ZobHVua2JaVmxQeU1iMUgyNTFFQy9Ua3p5cHhLU2RCcWE0bkpHYWRkaHpOU0dHVnZLbFl5b0owUVAxcDJIQkxLNmlKeTVvNDFzYlhjSnR5RXBBVzdIL0tQM3BHWDFGeEs3a2x3VHFlbFcvdUF1a2hvSU9jZkNwSTFxdXZiSjYxdU96ZDBWR2g1RWVGYTN4bmdmYjB5TGtSemZFdEc3WkR3VElDMEVTT2tWVllsaGp0b3BLa2dxWlY4SlBLcGVDM2Z1OXdsRHF5R0Y2SzV3ZVJvd1Rob3ZjN1QwaGxTY3NqNkVWcWZUa1EvVFJqYzU4YkorMHpPV3M3SzB1Sk1GT3hxL3cxNFhTQXBJR2RKZ29BNTB1SjRJL1pYSFpPZ2xDdmdjR3loVGRneTVoOTEycVFUQjd5U1kwclB4NXl4UzZ2dzA1NHh5dzdMMGw0cmhZdUVGeEtDbFcyYnI1ME1YTm10dFpuZjZWcVY0dzJ3eFp2RWhUVndGTnVFSFROOTAvblZCakdGU3NxUk9RekVqNlZweTQ0NUZabHc1NVkzVEEvRGJoZHRmdFB0S1VsYUZTY3U4RVFmcE5hYjdIV1ZONGJpOStFTnFhUTYweTZWSXpCS1lKQjhCUE9zMnY3QnhwU1ZKQThJNjFaOEpjWVl0d3c2OHJEM0VLWWYwdUxkMUFVbDNscnptSkZjMmNYRk9MT25DU25Va2ZScWJac1c0dWJkYWtJMmNRb3pCNUtCM2lyUGh5ellheEpiaFN2M1pLRXBjZVFDUUZBZ3pNUkEvU2hyMlRZMnhqOXM2bFFJTGFBcHhPaEJiSnlranB2RUhZNjlLT0xxemZzSHM3RHF1MGJHZHBZMER6WjJCNVR5STJrZU5KUzFZMnlyOXBUaldIOE40KzdhT2xQYjJpbW5HMG1ZV1NFaFEvd0JLcE92bk5ZRFlQMm45Mk1Vd3h6dUxTUThsVGhoQldrZ0JJOFNKK1ZiZHh3d01kNGZ2RzdBaHQ0TW9jU2hSQVNwWGFBbEk5RW1QSFN2bS9HRzV2bjF3VWhheXFQTTBWL2FJa1hOKzA1ZU1vdWJkOVVyYlNsL3N5VE84bFFNVDVBbjZWWjhHcGI5emR0NFVHczYrNytEN3c4K3ZuVlZ3ZGVEdFYyQ3pvNm1VQUpHNG1CUHFhOWU1c012MUtUQ1FwS2tFK1kwUHpqNTF1d0tQVHV2VG5jbVVuUDhBR3lrWG11cnBUeXQxcUpJbVkxMnF5dzdEQmMyRG1aS2M1V29hN3dPZGMydHVJYldFa2hhWlQ0aWpDd3RBMWh0dVVKUzRsU1FRb2RacXNGTnRzUGt0eGlrak5NU3c5eTBjZ2lSeXF1OHFNK0xraE4xYmpROXlZODZvUGNoY0l6SklTY3N6TzVtS1JreFhOeGdQeFp2Z3BUS3M2ZzB2OVJUajdEakJJY1RIaUthcERpNHVtYUUwMWFGalViVlo0V1NMZFhlKzkxOEJWV2F0TUxVRTJ4a1QzalNzbmcvQTZtTGlRQ2J5NEdzQjFZK1JxQ3B4UVVFSkdaWElWSXhKWDhVK3BRajdSUklqYlUwbUZXcW5sNXpwTzU1QVU3RGllUjBqUG15S0NiWTVhVzV6Skt4bVdvNmswUVlmWkpkTVFaalFSdWZPb2JqR1JLY2lTTXVwNVZMd2wvdG53MkFRdEl6YXlKanArMWRySEJZMTFSeHNzM1A1QkxZV0NXbXdsS1FTUnpwTVV3eHU5c1ZzcUNRczZvV1Rzb0RUOUJTV044RWxLYnBNU1lDZ05QWHBWeG1TcHZNQUlWcVBFVXVkL1ltTHJhTXJldFhMZDFUVHlNcmlEQ2s3d2FMdURNUVU2d3F5ZE1yYUdaa25tam1QUXg2SHdwM2liRGM0RjJrSmtES3FFYStCTlVtRk9JdExsbFp5OTB6cnBGWTEvSFBSMHBWbngvNkc3MXFMMXhGdXJiS1ZnY3BvV3hwbnNseUVrS084L2xSaGF3c0I1dlZMaVlCSEljLzJxczRsczB1Tjl1WVNoY0FxalJLdVJKNUErUE90R1JKN1JrNDhuRjlXUmJGNFgvQ2R4YmsvYldEZ1VERzZER3Z5bXBqVGFMbXhTN3Jubkl2emdSOUtIc0RkTE4yODNwbGNTVU9KL0VnN2owcTJ3VzQ5M3ZITEo0a0lXcklmQThqOVJyVE1NdThLKzBCeU1mU2RyeGtXOHcxR3BVdEtFa3dDb1VJWTdoeUdGQnkzV0NTZGNvZ2VsYWU3YjVZUzRBSk9tazFCdk1PYXVtRk51SkVIdzIxb2NrVk9OTXJEbWVPVmd6N0srTC83b2NVTVhiNFY3bXM5bmNKR2d5cTBWUFVSQjgwcE5mVjF1OG0rdE94WlN6ZGE5c3hLaWxLa2thaEt1VWlDSytNc2N3dFZsZHJRcE1KK2xhejdIT0w4U2F3VlZpcTRhVzVoeENXZTJSbWxvZzVRSUlNSjczMHJtdE9McG5aaTFOV2pRdUoybVA3SXU4UndwcTVKdFB0TDJ6QkJjQ0I5NUkyTUhmcHFlVmZPdDhDN2NQTENRbExpMUxDUWN3VE92NjE5STJ1TnVYV0ttN2NhUmIzYnV1Wm9RMjRxSUl5a25VanhnNjFrdnRTNGJ0Y0h2a1grRXBMVmhmT0hQYkJQZHRuWW1BZndLMUlHNGdqb2FGVS9BOW96K3lVcGkrWmVTcFdacFlYcG9TT2V2bFJoeGhaaHpDM0xsb1IzQTRueEhUNVU1d0dwa3F1V0g3TkZ3anN5NHBTZ05BUEh4NWVOWFdPQU9XZDBGd0FwS3pBMlFJTUpIbHBXcmovYStqRnk2dUwrd0k0VFVtOXN1ekpoVFNpVXhyRS8wSzBBMnFVTnBiQ1V3bElBSUZaandNNHByR0MxQXlLQVdSTWJmMXRXc1lrVTJ5VnJST1Vvem85Uis5Rmg4c0RsTzVLS002NDFaS3I1SzBrcVNFQkpNVEJIKzlNWUxaNXJJa2lWWjRtRHJBMUg1VjFqMXlROCtsSkMwa3hQaEcvblYvZ1RUVEdDMnhKekxXa3VRTmRUL1Fvc0QvazdGY2g5Y1NpRDExWmpzMUZlcWRpQ05UUTNpRmdwZ2RvMkZka1RCbmxXbHUyTExwVTJWUFNOeUdaSHpOVjY4S3c0cFcyTDZRcnVsQzBSQk8zS3RlYkZETEduNlpPUHlKWTJacU9rU0t0Y09WbHQrc21hallwWk9XTjA0MnBKU0VLS1R6ZzFNd3pzUGRFNXM0WEp6ZEpuU1BTSzRPZE9DcG5vK00xTjJpRmVpYjUxcFJFSVdyTVowTUhyVjNnNlcxcFYyYWtyV2tTVWpVK0dsVStJSkNiKzh5eGw3ZHlDRE9tWTdWT3dOU20yWlFRRktWcitsYThHUjQzb3hac2Y1RnNzM0NyY3AxbmJuVUc1N1cxdVV1dEhJc1FzUnlxNkJQdkRRTTVwNzJrLzF0VFdNV3dMU0NBbjhKVU52WHBYUVdkVFgrbUI0WEIvdEZuWktieEcxUzYwQ0ZINGtqa2Fmd2krY3NycFZsYy9hTVRPY0FuSjQrVkMzRFYwNWI0c3l5bFVOdnJ5RUhhZVZYZVA0dTliMnlWMlJMU0FwQ2tMMlU0U3I0ajRST256bzdVbzdFU3h0VHBCc3BsRGlEc3BDdWczQm9GeDNDbFdsNmxBbnMxVEN6cEkvd0J0Nk5jRnVFUDI5czdHVnE0UklnNklVTkNQNjYxSXhTMEx0czQzbFNwUUVvbjhRMi9iMXJMa2hlbU93NUhCMlUvRGJxV1FoaFJIWnFNVE9rMWZYTm0wOWJ1TXZvQmFjN3FoNGRLRExTNFJxVlowa3ozUUpQOEF2cFJsZzkrbS90b2NURHFVZytZNngrZFNFdm9QTERmWkdiM0ZtOWhPS1hGb3NxS21TU2xVZkdqa2ZVZnJVZTd2UXhpNEtkTTZRdEpubldoOFQ0VUw2Mk4yd2tHNnRVU2svaVRyS2YycktNV1NvTFM0blpHZzVSMC9PZ1UzZ2xhOEdwTFBDbjZhdmJPRytzcllzOTl4NEFEV3BIdTdER2pxdTFKNUpFQ3FEMmRYcWIxcTNhbUZBcVNRRHNTQ0IrdEY5cUdqWkUzSU1NNm1EdjRHdFVuYjBjOVJyMEMrTkxCdTRzWEhGTmRtcEtNN1o2aWhUZ080OXk0aWgxd28reVhNSFJVQ1FQV3RBeGNpL3RIM25Va3JuYndqYjByTitIck4rNTRxdExacEJXUTdLc3hnSlNKS2lUeUFHczFqNU1mR2RIaHp0Tkd2RzZObGlWdGJOdkhJNjRpZGRSS2hxRHlrZlEwQWNTOFgzZU4yS2JGeHBsbTNiZDdSV1U1MXVLRWdTb2dRQUNkQjFxVHhyaXlVRmhPR1hVb1dsV2RhVS9Fa2QwQks5d21CMEU3N1VJMnJiU24wRzY3Vk51b0ZJVTJQdlFjb0I4U0t5eFJ0Yk5RNFl0T3h3dGd1SUFDa0JjcVNFclNvaWNoamNEZWQ2YTRqbHZCN3hham03c21UL3FTS3M4SmFXelpXemJxZ1hBMmhDaW5xQnI5YXJPTjBxYndaeHBNSE80bEpuem44d0szVjBWSExjdnlUdG1aNGFvc1l3eTZrN0tNeFdvM1Y4ZzRGYnFuTmxPUStLZDZ6SzBSLzZRVCsvT2lHMHhJckNjUHVGSEpsZ1NyZm1EOUtHT29PaHMxZVZGYmVzbHk4VTJrRlNTb0pBRkg0c0RaaGxnaUVvUUVnY3RxcE9HV0E1aTlvdEtRRm9kektISVpkVCtYeU5HK0l0ZHJiajhTVEFJcThQeDJCeXZra2lodXRBaGNBRWtJVjR6c2ZuUWJpcTEzTnhkb1FvRUpWbEd1aGcveW9ueGQwTTRjK3VaS0ZKNStJb1Z3SWU5NXlzOTF4MVdrNmdWdlRyWmhTOVk3eEZhSmVTaFNrQ0Z0SkprYzh0RE51MTJLVkpXRDhXbW5LdEp4RzFiY2JaS2xCQ0FnU3BXZ0FHbFo5ZkxsMUpLd05Eb0JvTlRYTDVzVktLYTlPdi96Y2pqS240VitJd3E1ZlVnUWhUaWlrQXpwbXF4dzA5bmFnaUFjMjlRYjV2N1pSZ0R2cUVUc1FkdnJVMjBURExjZ2c1K1c4ZjcwdExZMXZSYjJ5aXBhWEZsSVJKSGpHL3dDdFcyTXNnWU9VRWxTZ0FWYS9lSWtpb0xqRU5ObzU3cW5sVTI2ZFc5Z3BXc2Q1MTVhd0J5QVNFMHp3WDlnRXB3dFhFNWlGQlFVbFhsVnp4cmNPS2ZZS05MZTRWN3hsNUJmM284enI1MVNZZ2doM01RUnlqcFQ5eTRwL0JHV2lWS1N4OElPdVhXZEt0WlgxY1dVOFM3S1NERGdmRkc4aXJDNlY5ZzZxVW4vMmErby9XdEZ0VktlYkxUdWo3T2l2RWNpT29yQnNNdVZNUElXT1ptdGd3UytPSTRVeS9ici9BSSswUU13NXJSMThlbnJXbU1sT1BZeFpZZmpsL2hFeC9DQWk3OThiMGFXZnRobG52SFpWTjIvYVdxMEtibnVtUWR4Ukg3dzNjMitaQWlVd3B0UW56SGlLcEhXK3dkTFpuc2pxZzlQTWVHb3BiVmJReUUrMmdtdHJ0QzJVUElNcFVKSTZIbURRQnh4ZzZXZ3Q1aElES3BJQSs1NEdpTEQ3Z1c5d1Vsd0ZoVzhjajFxd3hTMlJkV2JqUVBkV2tpU05OcUpydEVGUy9IS3pKK0NjUk9INHZCVkEzajFIOWZPdFh4YVRickxhME50M0pDazVqQUI1cFByV0pQSmV3L0VFcnlaWFdYTlVucURxRDlhMSt5ZmJ4UGhkOVRKVXR0YlNWbzhDRHI2aldwZ25jYS9ST1RDcGRsNHh2RGliVzhTMWN0RktYQkJISWp3UE9zK3VMZDFuaWsyeUNvdk9PT1d5ZGRWSE1VNjFhVzJNdjJHZXl1eXA2M0N1NlNlKzM0cEpxWncyeU1UNDJ0Yjd0UmNDMFN1NWNWbHlxblNNdzZ5UjlhdmxZL2paT0c2bFJTY1Z1dHJ4WnhpM0pMTnNrTUFubmwwSitjMU80RnNEZTNDbm5zeHRyZFllS0NCbFV2VUlCbmZhZFBLcS9IN1hMaTk4M2JxQlNIQ082TkFTZG84OVBPdEZ3ZkRQN0p3UzN0bFFYaC9pRW5aVzVTUEFiQ3NtS055czJjbWZXTkw3TEt5QmNlaVRxYW8rUFhFeGJvVkpLM0ZSQjJpUDNvaHd3ZnhFY3VzVUhlMFFrdTJ4QkloS2pIci9BQ3JSa2RHUENya2lpd3V6U3ErU1ZSQ2MwQTlTRFVIaU5seXh2TFI5UHdIdWowcS80YkxsMlcwcUVxUVNvcTZ3RHAvWFdvL0d0dWxWaGFFSkFIYUtUTXp5L3JTaHY0TVkzV1pGbndVKzJyRVgxejMxTkJTUjhnWjhkcU1uM080Y3NFSFdack5QWjgvbHUxQnd3cEtZTTdGTTZuNjFvVHlpRzlkQ1ByUjQ5cXhlYlVxQS9qSjBJd3g3WDQxSitXdFV2Q0VkbTJTUGh6R3AzdEEwdzQ2NkFpcS9oZjdDMFpYdXB3SEtrN0hVNm45dWRPN3BhWXFNRzRhL1lVNHE2ZzRVbE1rTENrbzMwSkpCanhvQXhBUStBa1FBUHc3Nm5XamQxcGIxbzgzcXRTRkIxVVJNd2RmUXhRanhJRXRYVnRrVGx6TUpVZGR6SmsxaDVGeVZuUjRxVUpVUEt0MCsrQUZDRDNqR2tnRTgvcFZxeGhyTDk3Yk1xU0VnT0pLZ25uRlFiWUZWODNtTzZwQjJtaUREVWs0b25VZDBiRHhycE9FZXRVY3Q1SktWcGplSjJpbUdIaWdGek1uTklIVGxwU0tiN1BCR2tyR1ZYWmpmcWRUVnJmS0xhaXJST200SDllRmQ0Z3puWVEyVWtwU2hNRUQ0VEgxRlpaWWRYRTBRNU82a1pYaUdZb1dWREtkSkpCM3Jtd1QydGhjcEdwQXpEVFVVUmNSMm85eWNPWHZBVG9JTy9PcW5oWm9QM2J0c1ZETS9idUpUL3dBV1dSV1ZwcVd6ZW1uRzBVTEpoQkhRelJqd25qRG1IUHR1SVVPNm9EWGJ5UDhBWE9nOGdvdUZwT25oVm5oUzR1bXhvUVZDYWR4NTA2WWprUTdSTmt1R2JXOWNTNWF2QzBBbVIyWmtHZXMxRXY4QUFmZWJaVFJ2V2xhZ2d6T282aXErM2NoQVVDcnlxZTIvbDVnSHIvS3RjbzZvNWtacE8xNkNyVnNteXVKTjh5bHdheDJaL2VqbkExb3U3RlFNWm14TWNsRGxRcmlpa3M0b2tPaEttWHBYTzBUK2Y4NkljRWRSYXVOU0VsaHp1S0lQeUlyUEY5WlVicC95UVVnSzlvR0VGdTRWZXRJN3E5VmdjbERjK29nK2RkK3pmR0JhM3Z1RnlSN3MrU084ZEVrNkg1L25SL2pkbGJQc0VGQktGaUNrNmlzZ1EwdkM4VVcyc1RrV1VrYm1PUi9XaG1uQjlrVEUxa2owbDZpMTR2dEZZZmlEN0t5VjVUS1ZFYnBPb290OWtWbXR2QjhSdlZJaEZ3NmxJVVRFWlFldi9FUGxRenhhNmNRd3V6ZkJ6dUtHUVFETy93QVA2K3NVYXJXeGgrR1lSdzB3c2YyamtTSGdQK2lLZ0ZMV1kzSTFnY2pxZHFIUE56U1EzQkRvbTJVZUE0UWNRNHF1c1JlYkh1VEw2bHRTbU02OXZVRGZ6aWpKL1Zwc25tczc4OUJyVWkxYmJRQWx0T1ZwSUFRSUE5ZlBuVE4yZ0JMS1pFU3BVZW8vYWpoRHFqUGx5ZDNaM2hZKzNFN3g4cURlUDA5KzBXUDlRSHpQNlVaNGVBSHpCMXlrZVJpaFBqWEk0Nnd5ZFNsQjU4NU5TZmhlRCt5R09EeEZ1aVFOQXBKUHlpbmVPV0ZMd3hwU0pLQTZGQWVrVjdnd0RLUVZFakxxQ2RUcUt0T0lHUXF3Q0FxYzZ1N0kyTWZLb3Y2aFMxa3NCT0J3bzQydGxRRXJaY1NOTmlCSStvclFpc3VXcVY2NWpCang1MERjTG9ESEdOdWxXNndzQ2VYZE5HekNwWmNSdEI1K05GZzhBNUsrUUdjZktBdzhBNnpBMDhEVlB3Njdtc0FGU3JMM1FJazc3RHJ2dFUvMmhxaTFhbUpLb0VjOS93QnFyZUZsT05zcmNSdWxha2pyQm9Nai9rRzhlUDhBRUdXQnFWY05YSlVrSlVXVkpJQjE4alBQU2hiaXNMOTl0bzI5M1Q5NmRKVkZFbkQyUmhaVTRvQUxIZTVKMzBqK2RRT003VkNjVFpBUVNPd0VIL21WNDBqTS9nYU1LdVpCc0pWZUNZbEtqbEFNZ2N2MG9rdzFzSmVRK05BWW54b2N3NU9TOURaM0VnblNqTERFWm1ZSXJxMzhVY2VhK1oxZXRwV2xabUlVblh4aXU3OVNvU1VpWTFOZWRJVTJzS0VxS2tqWG5wVHF3bFNDSUdtbXU4VXNqS0s3YmF1Z3NCQVV1TlVtQ29lTWM2b01JdEVOY1FJZFEzbEtWS1drYkNZTkVWNWFoYXM3VUpkVHFsVXg5YVp3eTBjdU1WTnhjWkd3RXdxRkR2SzhCNDBYV0xWbHhuSmFSbm5GZHVMWEczdXovd0FOZmZUck9oNVV6aGJtVzRaVm1PaWhNYjFjZTBGckpldHJLWUlKU2FvckFBM0RZNmtWaGxIcGxwSFRoTHZpVFpxRm9vZGdsSlR2c25jMCtsekk1TUUrWXF0dDNXdzJFa3lxTk9kZHJ2TE5Fak80dFhXTkszMDM0Y210aitKQk40d2tMVEpTRGxJT3l2NkZRckY5VnVTd2hKdU96VnEyaHhKS2V0S3JFTFZRSVE2NENaRXh0Vk5pQ005eWg5cFNRVmtoUlNTa3lCdWVXdFo4Mk4rcEd6anlYOVpNMFN5eE5GMWEvYUIxdFlHWDdST1g4NkZ1SnNPWWRVSHMwbFJBQ2h5UGoxcXJ0Y2V2TEoxSVRlZDVCZ3BkVUZBOVFlY1ZlWWh4UlorNk5xRnRiWER6bnhmKzZubkEwT3ZoVlFsMlZNazhiakpTaUQ2RnVzb3RtcmNLOTlRU0drcEJVUXNrZDRBYjlSNG53b2g0TnRHN2ZHN3R0OVNoZk0yK1lvY01MVVZIdnE4ZWg1NjFTNGFwVnZpV0g0bXRSU1czSEVvQjBDVlpEbDE4ZGFhd1ZicnZGbG82aHdsYlRpbExXREFDZVpuWFF6dEZaby8ycEcyYStETlpZWmN5RXVKeWhXbXRSNzF3ZHFBZ2dKR2swMjNmdHFRQ3R4dEt0Z0F2dEZmUWFWMjAwMjRvckNYbkZIYk5vSzFIUGUvQnkxN3JpTklCazlUTkJYSDF5QmpuY0lVVXBoVWVHbEdwU1VPaGE0Q1U2bVBwUU54VmFtNHYzbkdVRlJ6RXdWUklPdWxLbVB3NmV5dzRSUW4zZHhSTUVDWWptZjhBYXJUSHovQVpVcUdZS081MjBxRnd5MkUyaTgya1pVbncwK2RTc2ZQOE1nS2pMckpQTUNpWDlRWmYzQXpBbk0zRjlrY3hVUVY2K0lRVCtsR2x3c00zQ3N4MFdOQVB5K2RBZkNzSjQwczVsUVV0YWROdFVFQ2ozRm9RcHR3d29pUHpxOFRwRmNoYk0vOEFhRzRGSnQweUlLODBlaHF2NFpLdXpjQVZyR2JMbXA3MmdPaHk4WjJDZ0ZIVHpJcm5neGFBOWNGeEtJRGNDZmlKUDRZMjIzcGNsMnkwT3h2cGdzSzhKYUFIYnZ3V2tFRUNmaVYwaXF6aTI2TG1JTXFLRFBZai93REpWV2xoY2w1YTIzY29WbWtSSHlGVlhGREtGWGx1b21KWkdnLzRsVWZKeHJIajJMNDJaNU0xakZwYzIvdjVoYUNVTFZsS1U1UnkvblJqaGF1K01wU1VSeTFpcGIzc2Q0eVRmTGZ0ZUZMNUtZMFF1NnNvOHY4QUg4OWZwWG1mWmI3U1dYaXRyaG02UnJJaTl0UC9BRHFrYzZyWko4V1RkbzVXaENuQUk1a2tjNXBwUWtRVmFRRHZWK3h3RjdRbE5aYnZoSzd6eEdkdStzOWZtOVQ2T0F1T1FTZjdvWHdFL3dEWExJNmY5L1IvbGcxNktmR3lKK0Frb0NTa2hYUG5VREwyRndGSFZCMG5lamwzMmRjYXVLekhoUEVBWm4vTldSLy9BTDFHZTltdkhUaGc4SjNxZ05pYnF6Qi8vZWFLT2FIN0JmR3kvb3k3MmtvejI5dStBTXFpTnVzVUdXNXlsQi9rSzNUaVgyVWNlNHRoak51M3dwZEljUXZQSzd1emdhZjl2UXN4N0NmYVVnak53d3ZRL3dEWHJYL3phelpacHpUVE4zSHh5ampxU0tHMnVBK2xwQU1KRVp4cG1VZkFkS0lXTFZBQUxWbm4wMVU2NEI5QlZyYSt4VGp6TW50K0c3b1J1UmMyWituYjBRMm5zdTR5dGtaZjdzWWtvOWZlTFA4QUwzbXRhejQ2OU1rK05rdTBnUERkemtDUXhiSVNPU0QvQUNwdDlLVnNsdHhnRWFpVW45cTBCSHM3NDBpRjhMWWdEMUQxa2Y4QXhOSXIyWjhYbEtvNGN4SUs1SHRMTDAvOVpxbm5oK3dWeHN2L0FKTWV2RFpOQUp1VXRPS1FPOEhBUVFQRHdxT3RlRkZLUmFOZmFpVm5TRW1CdHJyenJUOFU5alhHVit0bHc4TlBvZEh4cjdhMHpSSC9BRzVHaDhPZFZsbjdFdVBMZDErZUhidFNDaEtVRVhGcEpNeVQvbU5Qck5aY21SWG8zWThjcStTQm5CcHU3bGxoQ3N6VWpNQ2tFS0Fna1FkOWg4cU5iSEI4TjdidG1MZHREdTRLUm9lZXhxYnc3N0orTXNOdlZPdjhMMzdpQTJVSWk0c3Bra1NmOGZ3cStSd0x4aTBzbHZoVEVTa21RUGVMSVIvOXhRd2xGYllPYUU1UFNLM01HMDl4RFV4ckxZSDVVeTVldUFFRXdrYmhDWW1pSmZCUEZpMEhOd3BpZVlpUDh6Wi9NL3hGUjE4QmNWcU1mM1N4THpOM1pmUC9BQjZkM2greER4WlAwVTZWcFdncFNGRW5tVEpvS3gxOE9ZbTZwQXpCS3NvSFNPbGFjMXdKeGMyQVJ3cmlXYmYvQURObVAvRVZSTyt5dmpONDVsOE5ZbUZIVTViaXkzNTYrOFVEbkg2WXpIam1uYlJUY05MN0swY0w2WlNGakxHaEFNeDYxenhIY3R0MjZFRXgycWlBbFhRRHJSaGgzczQ0dHRyQXRLNGJ4TmJoMWxUOW5xZi9BSWcxQXh2MmFjYTRnbHRDT0ZzUVNsQU9wdUxLSjh2ZVAxcWxrVlVYK0tUbGJSbEdFb0xIRitIZDVPWVhDWUU2UVQvT2ozRjNnRUpLU1JHMm1uenJpeTlqL0h6T0wyOTA1dzFkbHBwZWVQZUxNa1JzUDhjZEtKTHYyZDhhdk41UndyaVU2Nis5V1EzNWY1aXBISkZFeTRweStqQytNRjlyaWJhaEoreUVHSTZ6WGVBa1c1QkExTzVvOXhqMkplMEc1dW0zTFhobTVLUW1DSEx5MFRySjZQSGxUbGg3R2ZhR3lnSmY0VmZNYTl5K3ROZkQvR3BtTEpDTTNKa3lZcHZFb3BGUFpnRnpObjBBMGcxRDRvZGNGMWE2YSs3aWN3Zy9FcXRGdGZaWnhvU1JjY0xZZ0FvYUtGM1puS2YrL3FCeEI3SWVPcnk2Wk5wd3ZlRnR0ckpLN3UwVEp6S09uMjU2aXE1ZVdHU0ZMWXZpWU1tT2ZacWovOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9FdWxlci5qcGdcbiAqKiBtb2R1bGUgaWQgPSAyOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVCOUFIMEFBRC8vZ0JDUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEE2THk5amIyMXRiMjV6TG5kcGEybHRaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPa3hsYldGcGRISmxMbXB3Wi8vYkFFTUFCZ1FGQmdVRUJnWUZCZ2NIQmdnS0VBb0tDUWtLRkE0UERCQVhGQmdZRnhRV0Zob2RKUjhhR3lNY0ZoWWdMQ0FqSmljcEtpa1pIeTB3TFNnd0pTZ3BLUC9iQUVNQkJ3Y0hDZ2dLRXdvS0V5Z2FGaG9vS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tQL0FBQkVJQVVJQTNBTUJFUUFDRVFFREVRSC94QUFkQUFBQkJBTUJBUUFBQUFBQUFBQUFBQUFEQVFJRUJRQUdCd2dKLzhRQVF4QUFBUU1EQXdFRkJRVUhBUWNFQXdBQUFRSURFUUFFSVFVU01VRUdFeUpSWVFjeWNZR1JGQ09oc2NFSUZUTkNZdEh3SkJaU1UzS0M0ZkUwVmFLeVk4TFMvOFFBRndFQkFRRUJBQUFBQUFBQUFBQUFBQUFBQUFFQ0EvL0VBQ1FSQVFFQkFBSUNBd0VCQUFJREFBQUFBQUFCRVNFeFFWRUNFbUdCY1ZLUm9kSHcvOW9BREFNQkFBSVJBeEVBUHdEVHRWdVU5NjhnUEtNTDRDRE1WbHJ5bzdpNmh3YmJuSUVFN0ZWUkRWZHJLVERxQ0VqcnlSUFRGR2RSL3RLeTRvQXRMQ3NBekhXYUxhY2J1NEtPUXBSTTdRdk5WQ2ZiWElXRklYUDlWVEFaalVHOWtPTkhiSmtBWm1nWTVlTXVFQWtwM0dDWlY0YUFhWGJkS2lydkZUa1lPS29Ja3RsUkJkV0RFYzBCbW1rakllSVNvYzdaL0QvT2FpcTI3WkJTQUNWRWN5a3lLcUVRMkVCSmJVRXhsUmc4RTBDOXp1VVNYRWdnU0lKSitOQklMSzBxQTNpQW1SQmlQblFHVXd2dUpLc0ttQUl6MXFDTWxLa2xNdWdlbU0xUmd1U0MyRXZKVnV4dDNDUm1JcUJYdFRLazdBb0pVTXlBSng2aWdBMDljU0ZxZVVCSEFVT0tvTWx5NWRVUHZWR09TQ1RueW9DRnk3eUpWQVBXb3ZneEtybzRVVkFtQmxWRUUrMDNhRXRoU2xRUmdaRkZuc0p5NXVWZ3dwWUgrOUpvbUdKdkx2YkFKQUdlb0gxcWg3Vjljb1dvaHhRa2M3aVlvYUtuVTdsSUkrMHVEUDhBeFZDb3ZMWXRXMHU5Rnk0cFRCMmxVYmhJcUtwWGRQdWtKKzhaZFNQbm4xcXBrVnI5cyt5bzRkVEE0TTFURUp3TFRDUnVBbklVS0lHSFZoZU5paUFad0tCd3VIQWtRa2d4MG1hQnpsMDZrQWdIcGtSazBHSnVpRUJSU0RQbWtHZ1EzU1lLbEJFbFdSR0tCVlhiUVdDQTM0UU9ETkE4WGFGcG5JSStmMG9IOTRPcGNnK1p4OHFCVXV3U0E0b0dPQ1B6b0R0TEFVb2I5b1YvTUFhQTYzeTJZMzRqUEppS0w0UUx2VmxOdEFKVU1Zd1RRMVR1WGx3OGtxU1RFeEpNVVFOQ0hYREEzRS9nUjZVRXhqUnIxOVBodG5WN2lBQWtIUHBRWTVZdU1yS1hiZDVDZ1lJVWtpSW9KbHRZdU5EdnJOVHBFOEFBeDhSTkJaYWRxQ1hIUTFkcVMwWWdxS1lDajVFZERVV0o2RUo3dmI0SjVPVFJjTWVDVWJKMkZVSGdtZWVhSFRDQzRuWnRTVC9LWkVUTkRURjJySzFFRUdaQktRc0RqcEh4b2x4aTBOdE5LQUFPNmV2K1RSUk5pRTQrK0h5aWdtNmhxcTAzUy9lU2lTSkJQMG9LMTNXM3hoYmo0amdoWHhwaWFqWE9zUE9OSlNwMXpPWlVaNjhSNVZUVVJlb2xhZkY3eE9RcEFJaWhhWTNkb1ZQZ2FnOHdtaUNwdUxjaUYyeUZxNEVFaWMwR09xc1ZJTzYyZVNSSk8xUXdmclFSMXMyU2dtRnZUL051SDVVQ3B0TFJTVlM4ZjZRT2ZLZ2pHMWhTUzJ2Y1kvd1VCRVdheWtsUkJJeEpvTURLeUk4RUpNWkJIWFB4elFGVGJLVVZFcVNUdDZLQTRvQ04yam9XRm9naWVKRkJGMU5icVNRc2trK3VQb0RRVVNRWFhBa2s1TVlvTzRlenYyUVBhdTB4ZGF1bGJOcVVsUVIxakVUNVZSMnJTZlpkMmZRbE96VG1WdWxPM3ZCTzFQOEFlcGh2cHVXbmRrZEpza0h1TFZPK0luYlB3aXJEVURWT3pHajNEYTBQMkxDNEUrN3pVV1Y1dTl0ZlpWbnM3YzJyK21OOTJ4Y0V3dEpNZzhrWXFMcm5kaHRlS210UUpVRGdLa1NhSjQ1R1pXdEx2Y0lVcGFnZkFWR0NSUUhXTHZ2RHRiZGdESUJtaHBpemVkMlIzVnpId25yMHhtaG9LWG4wbUljaVlWdmJqOGF1R3NOMFZRREFWQndVaW1HaUYwbkhsamlZOUtaVFUvVTFJRHpvS1pSdXpzWHlLaUt4d0kya3FRNUl3QnVtcUF1SVNVNEQweEIzRGsvU2dqS2JTRkhjNXRJNENrOCtsQTFiU2RxaktOMHdQQ1IwOUtBUmJLVUs5M0hrck5BUkREb2xXMVJFR2M5YUJpdDRiSkFWSmdTUlFNUXRhRXBVazdraFdRZk9neEx5NWtISjljMEJrWEtra2hRQkJ5TWZuUUtibFE4UUdlUVRRRkQ2VU5FS0JVcFk5MzlhQ1ltN1VHMCs5SUV5RkhOQlFhdGNxZFdySjV4UmVHeGV5YlJrYTEyM3NXSGtndE5UY0tCNEpIdWo2MGhNZTF0TFFpMlliYjhKWEF4MStNY2ZXb1l2MkQ0dGdsYXdtQ1RrVHp4V3RQNG1sb0ZNSVR3TWtERkdjVjE4eTZoQlVuS1J6MU1lZjQwNVZ5ajJ5YUtuVU96N2pOeXh1VWxhWEc5cytCUThqMGtZUHhxTEhtZlgySHJGQ1lhQXR5WWFkTFlHMytrK3ZwODZGVXIxMHBDMm5rU2tweVBROVJSVnMzcWptMUN0cWlrZ1pTWkJxWW1wYmV1dkRDUXVZQUIvdFJkU0crMHJxSVM0VFB3QnhWNU9FaFhhVzNBRW9SS2p0eWdDZjhpbTA0Ri9lbW1xSkxqS0NxYzdXSnB0RlpxcXJJUHUvZUtTa21QZDRFOFZFNFZ6aUxaU1NwTndRT0pOVkRPNlFvRGJkSkdZR2Z6b0dLYWNrSHYwckhCZzhVVTBvZFVuUGRtQlB4b2lPcEMvNVdrS0FQeU5BMWVDa0ZwYVl3b2hYNlVDaFJCVGx3RHBRSWw0bEp5c1JqS0pvRURnTWtxUVl4bE1VQm15MXNFaHJqclBOQVFKUXNGTzFvSGtRdmlnTWxMWVZCUW54Q0JCSFEwQkgxTjdGcUxmQ1NDQWVEUWF0ZUsrOVZ5UG5RZGgvWnZzbTA2anFXcVByUzIwMkVzNzF3QW4rWW1mcFV0a1dSNm1zR0VJV201amZLTndKNE9LZHE1bDJ4N1k2dGU5b3JYVE5LdlhyQ3pTZ3F1Rld0c3Q5MUNqd3Bld0dCSDYxUHI5ald4OWx1eXV0WGxoWjZwcGZ0SXV0V2RTUXBLVnRKK3pMSTk1Q2tqSTh2TWVWSlBoNFRhNmJhdVB2V3FSZU5sdDREWTRtWmc5WTh4aXRkSHRVNnphdFhGbzQyNGxLa3FTZHFWamxRR0JUU1BNWGEzUzd1MFZjV2JOb3NoMVc4TkpDU2hZUEcwSzRJOURUS3JrRjVweE4wK3dnN0xodWR6S3NidlVlbzhxSmRIMGRMYnRxRU9CWmNTWUtSUEZDTFg3cElUdGJVa3BnN1ZBbmNueU5SUU83VHVRQUZidW0yaWNISnRFN0M0OHB3b0J4dFNKbU1mQ2k4RjdsQy9FUW96NTBGbnFXbHQvYVZoTndrQUs0Vm5GRXhWdTZZZ0VqdjBSbnhBeno1VlV3QmVsUXFVdk1DY3lTSStkRndKZW5MU1FCM2F2NXQxQ3NGZytoRUozUXJ5WE5FQ2NzN2hIUlF3UlArZWxBTXNQSmVVbnhEY1RKSW9GZERvQ2dBb281NmpOQUVwZkFTTnBnZElvRlNIc0ZTSnhreFFFYkRwSThCSkdUMG9KVERTeVZFc2dpQVRKR1I1L0dnSUdUNHZ1cEtVekJQa2VhYXVJR3BGTExXenUxSlVaTTVpS0kxMXhYalVaeFJldTNRL1p6MmZ2NzNmY0xiVzVaMmFrcWN0MHZCQ3lWQ1pTRlFsU29Ud1NLbGsvcXpoNko3TzlyOU4wYTMwaExGM3FXdTZhOHdxNGIreFdqano3YUVtRkpXaFB1d2NHZURqTk0vNGdtczNydWlhRllONk5kb2J2ZFRjVmRYVDRHMVJjV25lQko0T1FuUEFGTHlZaCt6TnpXZTljZFU4L3ArdTY1Ykt1bE4vWjByWmJMU2twTHFrbnhGeUZoUElDb2s5S3YxMUxYUkc5QTdZM0EzSDJnT040bUdkR1lTZi9BSkZWWFBqMWQvN24vbzM4Ujcvc2wybit5azNQYi9WSHdoU1Z3aXd0V3pBT1loSE5UNi9IOS83SmExZDcyY01hNFYyNjlhMTY0MUFORlllZnZJMks2SGFFaEl6MGlrbng5TGVtbTl0ZllIMmd1dXo2TlJaMUcydWRhdG1TVjJ5QVQzeEVtRUtJQm1PaDY0bXRTZkhwblhuZEZ5VzFvSVF0SmlGN1JCSi92NlZscUxWTHdkYVFVaHdiZW03ck5RSVhqUHZMRS83cXB6UkRrdnIzcERianlVYmlWSm1aQkVBWjlZb3ZLV0hlWWt3ZVRFMEZqcU9wa1BuY2hra25IaEZFMVdYVjhwWlBnYkE0allLR283ajVLUUZJYmdaOEl6UTA4dTdrNTJBak1SSlA0MExUMm53azdrb1J1eVRneEh3bWhNUGR1QUViVjJ6WlJ6Qkp5VDE1b2FHWDF1S0tuV0dncUFNVDllYUc4czc4d0FsbHJha3labWZ6b2FLSFFCdjdwdmQ4dm4xOWVLSEdzUTZGalozYlFVZXVCRkNjcERiKzFDU0MwZ2RBU0R6ejBvb1pmQkozdXR3QU1KQmswRFZ2YmxyVWp2RkRQQ014MDVvTmM3UkxVcFpLZDhUamNlQlZFUHNpTlBWMnUwUk90clNqU2pmc0M4V3JoTFBlSjNreC9UTk91U3QwZXUyazlyKzBXbjJMajdXbTNSV2xseFEyN0VoUkFjSFRnbUQ1R3ArbjQ5QWV4S3lSb1dnSFVYbVMwNXFQM3JUWm5hMjBBSUtVa2tqY1pXUlBLcXBXNjNtbHVzMjc2TEhUV05jMDFheTYyMGgxRGIxcXBXU254NFVpWklNZ2lZeUtienduK2o5bU5QMUcyMUovVmRYdG1MZThkWUZuYjI3VG05TnF4TzRoU3VGTFVxQ1l3SVNLdVhvMk54c1VCa2crOG84azgwUFk3am5lSTJxMmlTRWtlVkZreEF0RWhpOVc0MGxBTzBKT1BlQUZQeEwwdUcxa3BTRmdwV1JNSDhhZytmdXAybHZlOXNOZmR0dGlMTVg5d3BDRXFnRkpkVnRBcWF1RVV3bHRSN3UzZFdQOXhMd25ucDBtZ0VxMmFVMGh4TFZ5VW5jQVJCelBCOVJRTyt3dG5BKzFoVUVrbHRKbWdLYkMzRUJhM3dmTHU2Q0pxamI0ZFZ1TWtrajNQV3F5Z2JsSlZsSVVabjNlUE9hQUNueUNkemFBZnBGQUV2cksweWdaSG5FMEJFdjdSbHRBRThFODBDS3VsaVpiU3JqUE5BMDNTaW95Z2NtVFFLaTVKQUlRa0VHZ2VYMWxaSlFneC9MUFByUVBUY09xVWtKUWpieWNjVDFvREt2bkM1dEhDZkNJVG5paTZZcGQyc1lVN2s5RXhVdzBxV3IzYkJiZk15VEdKbXFhS05HdkxvQUMyZHp4dnpSR3ZhcHByMW02b1BObEdmS2d0ZXpLWDlhdTA2WXU0Q0ZLdDNXbW5GSjNLNEVJK0JJSHdweEd0ajI3cGV0WExtaDJPa3R0MjJsNncweW43UTFkdEZRYkFUdDNwQUkzSkpHRFBGVGxOaTUweHdsTEtMcGR2OXREVVBQV3lDMGhTdVpDQ1NZK2RWZGJBenR1VzVKQmM0SkdhYXlhbGtOa0dUUGthaTZWUUN2Y3hKZ0NPdFhmWnFPNjBGUG9hTzRsU3VKMjQrTlF2TVUvdEU3UXNkbU95bXI2b1VPUFAyMW92YWdHU2xSRURQVEpCcTJtdkRtbHZ1cHRGRnBLbkFUbFJTVlNldjQxRjBiOTRPdFhJV29EZjAzSndmU090RFlNOXFqYlJTcGxMWVV2eExTWmxLb2o1ajFvYWlmdkFxVHVDVWM0Z3hRMkpTYndaQVMyQURHZXREVnBmNjFjZmFTc3NzcmdrZ2x0TXhqMHBocXJWcXUxNWU2MHRrWjJ5aEVVeE5SWGRSWldwVzYzVDhka2ZQbWh3QWJ5elB2TkpNSGtBLzNxZ3h1TEJhVkxMT1NTUGRQOS9qUTRONy9UbEdWcE1kUENvZnJSQ3B1YkVMUGhISWozdXZOUllDcTh0VXdsQTY0d3IrOVUzZ3FidTMzWWIzSkp3TmgvV2lkSmJlb0pRMFZKdDJ5Q2NBdGo4Zm5RSzFycTIzRmR4Yk5BRVRCUU1la3g1MEEzdTBtb1pHNUNRUElZK1dLRlJWNjFxRGdudjFaSU9FbWdSbS92MW1DOHJBeE1BVXdVbXN1dXVPSHZYRkxrbmt6UXhzUHNhU2x6Mm9kblV1NVI5cEtpRHdZU1QrbFM5RDFEZGFxYjN0dnJPb3V0WFRsbmJNc2FlaERDZHlpbksxS1BwdUlBK0ZNcTVXMTIzYW5SeHFCc2J4dEF1RkozQXNIdlMyZVFGbElJU2NqQk5PYVpXMzZIY3BlYUtrcFdsQTJrQmFZSW56OHFxTEo5YllRb2t6MHBoT1VOaTRCdWlCSklFaW1HS3Z0TVhGV0Z5UEVQRGhXY2VmNVZMRHcxRHRUWnQ2dlkzbW5YSTIyOTlibEJtU2tFanI1K2RMREhscTFTblFQdFdrYWhhQjlkdmNyQWNQZ0t2aG1sMVpHTHZ0TGVKUmM2ZVZvUHZEdmprRHl6aW5KaGpOMXBiaU5yemJ5aUoyT0JlWS9xRVJJOCt0RERRdlJWVDRiaEpIUFg5S0dEcVowZVREN29rOGJCK3RERmZxak12TEliQkFVZmQrTlZGVmNGU1ZybEsyeXJ6OWFDSTR0c3FCM3FUTWc0b0VDdHF0cVhrcTVCOHFBWldUS3BTUngwTkFRcVVFcFVFSjR4SXBveVFGNVFrU1ptQ01qcFFJaHdrb1VOb0k2R2FCZDZ5bFVKOFBKR1lGQXJsemtrb1R0d09EeC81b0dKdUFXanVDZ0ZjeDlhQmdDVnBVRkVnQVRCU2MwQ0JaQUlDTnM1TXpORjBWSnlWaHNwVDFvbitLNi9DbEVxejY4MFhVbnNocW43azdUNlhxS3AyV3o2VnFnL3k4SDhEVXByMXpyVFRkMXJ1Z1dyQTIybDlicmN1RnRUTHc1UWt4MEdUVTNWdGRMN09JMDJ3czB0MjFvMHdsSUEzQ0RuOGdhMXJQQ2NsNE5YaTNXazkzdUVreE82cm94TjJwMXJmeDFnWm4xcWJWMFBTeVZ1S1dRb2dpRHU2Q2t1R2lhd2dxdGdqeEZTOENmV202VzdGTy9hSmNDVk9vS2tKQjlNeEhTaTY4d2UyNjJiMDN0aXRhVWxLcmxsTHFrcUVlTEk2L0FVVFhOSExpU0lPWTh1YUdtOTh2YUJ1SVQxd0lvYkNJZFVWZUpVL3dEU0RORFUzdlFra0tTaVo2cFA5NkxxZnFiYXZ0THNERWtHQ0ROR1ZTK2x3U1NGQXhKb0lhbEtNejVUaytsQU5MamlDTm9TbjFpaTdVKzAxOTIzVnVYcDJrWE04cHVMQkNnUjhvb2l4UGFlMFYvRzdJZG1GcE1ZREx6Wk1lcVhSVGF2Q0ZxdXVhWmRxU2Jic3ZwVmlBTTl6Y1hKM0h6OFRoajRVU1lyYmw5bDUwT1cxc0xSb2dEdWtPcVdQaktpVG1nd1BzcHQxb1cwc3VrZUYwUEZJVC8wOEg2MEFBRXJVcFJXcVVwa1R6TkFpdUJ1Y1VBT25XZ1V1YlVrZDRxUE9nUkt5a0tJY1VDQno1MEJTOG9RbEszQ25vRFFDY1FoMUpWM2l0MDVCRkJWckcxUkJFZWxCM1AyTWR0cnE4dWRKMHU1dUQzOXFPNGJXZVMzMHlmTGo1Q3MyRDAvcGh0MmQ0ZENWRUFGRTRDaDEvNzFyUUxWZFJTU2kzc2RyampoZ3hJQUdPdFRmU0piRWpEcmhIa2xKNFArVFZWYldiU1VpUURBaWVoTlFHWlljdkx4UzRVR0JBM0VDRmZDZzUxN1N2YkYyWjdCRjJ4c1FOYTE5R0RiTk9lRmsvOEE1VjVDZitVU3IwSE5MUjVVN2M5dk5hN2JhNE5VMTU1dFRpVUZwbGxsc0piWVFUTzFQVTU2a2sxUnJya2xTUUNrL1NnYnZWUHVwSjZVRDBUTUFJSjh1cG9KWldzcVZ0WlFSUG5RVDlXdEFYbGJFa0tCSmlhaTlxbDFwMXBSZ3FINjFVUlZJV0pCS3dlb1BGQWlrcmdxSkpqem9HYmZFWkNRZlByUVlwT1R1Z0tHS0FSU0RCS2NueU5BMERrSHo0b0VLSjZHT0tCaUJCQmd4UHBRRVUzZ1lNQ1Nab0dsSUlNZ2dEeUhGQTd3Z1pHWjhxQlNRbFU1QkdaanJRRmJnb1Zubm1Jb0lsMDBKSmpucGlnaldkM2NhZmV0WE5tNnRtNGFVRkljU1lJTk1Ib0gyZmUwOXpXZ2hqVjcxNFBJQUNrSkFTa1lncXh5S3ptTG11eTJuYUxTV2tmY3ZObEFTQVN0UUJQV1AxaW9mVnNPaFhLNzlRRmlnT0dmNUlJU09PZWxiaUxEdFQybTdQZGlkT1RjZHJOVFlaVW9TMWJBbFRqaDhrb0hpVjhZanppcGJJc2p6TDdVUGJ4ci9hcEx0am9aYzBMUnpLWWFYL3FYaC9Xc2U0UDZVK2NFbW1leXh4WlMwcFNBbkE2aW1HR2Q1NGRzS2ptcVljbFpFZVhUMCtkRXhJYUFmWDRWUXJ5Sm91RHF0MUNVNXdKa1JSQjBXdTRFcXhKTVRReGJhdUUvYUhGRlFDaVloUk5EcFUzSTNZU2QyMmV2K1lvSXFrK0RrU1BTYUFKU29ZVEt0d2dTSnp6UU9OczZwTGlnbGVFaFJsUCtUUU1ERDJTRXFPTW5iTWZoUUNVeTV1VEtWRG9mQ2FCcTBxQ0FTRlRNNUZBSE14dUlqeW9FUEVKSjQ1eDVVRGtrK0lFcUtZekVVQ2JzRXEzVG1nY2xhdGdrcXhpSW9KU1cwcmlKQVBTZUtBemJVQ1ZLSjI5QVlvYWM3dENDVXBVSkFrVUZUZnRRa0tpS0NQcDE1Y2FmZXQzTm81c2VhTzVKL1FqclFlMnZZTmE2RjJ1N0sydXF2eGNYWkd5NFpXMmtCSzR5UFVkUjZHa3VGcUo3ZnZhZGVlejVWbDJYN0lXTFZuZFhOdDlvVmQ5Mk5yRFpVVWdOcGlDdVVtU2NBUmdrNGwyckhsVFViMjYxRzlldkwrNmZ2TDE0eTVjWERoY2NXZmljMGt6bzNVTzUyN1k3eE1nU1NEVk5RM0R1TUlPT1pQV2hwTWN5RDU1b2twNkNtZHhPS0xweUZncWdEaWhxV3k2OENra2hROGptaHF5YmViS2NxUUQ1VkQ3TjExRFN0UUZ5NFUyVDRoUms3VThrOU1VeGUvQ3R1ZEx2VkhObytNeEVBZjhBNjFVeEMvZCtvRmF2dTNFWUovaUFabnJpaGxNYjB6VUZGSlZzZ0tqeFhFZlRQTlRURHpwMTRyTHJ0dkFPRkc0R1BTZDFOTXFLdlQzQ0ZiN3UzK1Q0L3dENnFtVkVjMHQ1T3dpNnQxaFdSRCtmL3RReWtPbFBGTWwrM2s4bnZ4ai9BT1ZFeGNkayt4djc2djdwV3AzeHNOSXNiVmQ3ZlhqWTcxVGJZd2tKVE9WcVVVZ0Q0K1ZQR21CZHFleGw5MmUxUVdxSDI3KzBlWmJ1N1M3YjhBdUdIRXloZTA1U1l3UjBJUE5EdFJ0NlRkNUMyVkFLQmlUeWZwUmNwaTlNdUVTcHh0VWVxZlA1VU1wUHNOeVFRVzE4aVBBUDdVUklSYTNLa2dGaFlQTTdZQmlnUVc3dTRBdDVQcC8zcG1neHRsaHVWTkdZa3FLY1I5ZmpWeWl0MUpoUXR5VklnQXh4K2RRYThzK05SNWswSG9mOWtIV05XWjdTMzlsYnRPTzZTdHBCZlVueGR5NU1KTWN3Y2drY1FLbURvZjdZbWtXN25aalJOY0JiUmVXdDBiWXBVb0JUalRpY2dlY0tTay9NMWQ4RHlZdDhpQWt6aUpQRkFKYWxPNUpKUHdvR09ZTzJLRE4wRElQem9ISVdBUitCb0hKV1pBQUpIU2dPMFRzeUR6d0NLQXkxZ3FKa2lUNTBIUzlZTjBiaHhDcmgvY2xlVTdpYXl1dGZ1VXZBbFNpUm1mRW81K1UxY2lJRHJUZ1dyeE43akpJSjRucG5yVndLaG5mRWhCM0htQlBHYUxTclpTa05sUlNFbmttRFJFZDFrRkJJVzBzSmpqRS9LZ3R1eTNZN1Z1MXJ5N2ZRR2JPNGRiVWhDa09YTGJKOFV4Q1ZrRlFFZnlneFRqMkQ5dWV4VjEyU3ZyS3p2cnV5dW5ybTBSZWY2VkNraEFLbEoybmNBVGxCekZMK0M5N0ZuUnJUMlY5cWxkb0didHl5MUhWTE93VzdZclQzck8xcHgxRGdTU0FzQlVTa2tUSjZnVTZHcjl2TmJ0TzBPdDJ5dElZZlowelQ5UHR0TnNrM0VkOFdta2tibGhPQW9razRvS0JMQzBLaVZsWUV6UFRwRk1EVmhaOEpMeUFPTnJpaGtmT2l3b1c3a0JkeW53eEFjVlVrS2xmYWIxRzBKdXJ5UW5udkNhcG9yVjlxS1hSRDl5Vmc0a3o5S0duUDYxcVZzMFVyZmRTQW5BVnQ4K2FHdGQxVFg3dTlSM2FuSlI1RkNmN1VOVThFcTg2SW1XTDF6YWhiMXJkTHQxQ1A0YnBRbytVUnpVc2w3V1hCTG05dXI1OE9YbDAvY3VBUUZQdUtXUjh5VFNTVG8wZ1ZDUkhQWHlxcG9wVWxTZjVnZktjZkdnRVRKNTY0b3VzSW5xWWpORFdBU1JKT09oTkVGVElJamswQjIwbmFkMlBROWFHbnVKSmNWdE9KUGxRZFYxdHhYMmh3ZjZZbmNaS1hBRlRVWEd1dkpjQldVb1Frai9kVWs1L1ROREFWaHdLSCtuSlQvd0FxU1o5RFJORlpscVQzVHFTZ2srNTF3T25TaTFDZWZJS1pDeEN1TmhIU3FnTGx5Z2Q0cDFZMnFCNmtGTWRlT0tEcDFpV3ZaZjJSYTFKWWFiN2I2NHdmc0FkRXEweXpNZ3U1NFd2cDlPaEJYL2lzNTVhZDI1N1VOOXBkVXQ3cGtQSmF0dFB0ckpDWFhBcGN0b2dtZXNxS2puT2FrMUZqMklZT3U5anUxM1ptMis5MU5hV2RXMDlsS2s3bjNHSkRpQU9xaTJxUUJuRlhOcStOSjJnN0w5bXgyRnRlMG5aTFY5U3ZiZE40alRyMFh0dWxBTDZtdThKYndJQTRJTTg4MC9pS0IvU0ZNZG1yTFhROGhiTnhlUDJKYjdzUzB0dENWaVRNRUZLcCtWQlVYS2tCTW9Ta2daa0FBbWFCcUVtY0lBSG5QUStrMEIxb1VzcFZzU01BKy84QTVGQ0N1dk5XZHVwNVFTQ0VuYjRqUDUwWEdsMzE0NWQzQldwU2lQVTFKRVJUSFRtcUhvRW1jUlFQeW9SVXd3OVBoSVBuVkQwa2ZLT2xETkZLdkJrY0NJb1laeEhIem9Ua1pTVkFSR0FaaWdTZkZnU0JGQVpJQUpVWStIblFFa3JpRTdVVUJ5eVZxVWRvNU5CMGJVYk1pOGNBZHRWS0JQSVRqeXFDcGYwVUtVVnRpM3p5Z2dZUGx6VFZ3RDl6OHBTbG9yeEFDMVorbEREMTZWY0FlNjRrR0lDWEZENlVXbU8yRndsS28rMUZBT0ZCY3hqMW9sYlI3T2RCYWF1Nzd0UDJrRDZ1eitoQkxxMkhJUDJ5NVA4QUN0eHpNbUNjUkVUZzFkemxNYWgybTFyVmRmMTYrMWZWMzNITHU4VjNpb1NDbEEvbFFtZUFrWUE5S2tpMnFodFQ0QjhVSUdKVTBEOEtxRnQ3bTl0YnkzdWJXNCt6WEZ1c09zdk5JS0ZJVU9GQWpNMHMwWHZhTHRqMm83UldOdGE2MWZ0M05vMHRUNlcwMmlHa2x3OHVLQ0VqY3N5ZkVaNVBtYWZ0cTZzYmUrdHJqMlBYTmlweTAvZURIYUpGeTB3VENsSVhhbENsQlBNU2taNEZUeVkwcDk5WVd1R0xXU09pQ0txSE11cVRuWmJ4OCtmMG9Kamx5cmJ2RFZzUVJqSkZGNGE3cnQ2WG5kZ0RZQ2NlQ2MxRFZaQkNKUEpOVkNRU1k2MEJpZzd3bEp3bm1ock9oSDVVWFdjZ2RLSWUySWduOGFBMGN3UFFlbEY0d3FVRStWRHZzNHFnamFabWliaDJOeVNvWVR6UmRIUWdCSUxzU2Y4QXpRMmlJbFFNQWhQRTlhSWtMS2QzdWcvRTBIcEJ6UWRDMUM5VXRqV0dyVmU0TDdtNldsVGF2VGVVQWo1L1dwc3ZhNWFoYWwyT0duN1RkUDJ5RU95VXFjRFJRdjRMQ2dEOWFYTzRSVDNuWkZ0YVphZTBwTThIdzQ5TU9HcDlwZkpsVkY3b3Zkb0pWZTZRVkFqK1p4T1BsTWVkTm50ZVVLMTBxNnZyaTN0TEYyd2V1WDNRMnl5M2VxRzVhakNSQkZXWmJtbmhlKzBUVXJmVG1iUHNycEY0MDdwbWtENzUxRngvNm05VlBldUh6Q1RLUlBFR25GNlJ6cHg4dXJBZFdwU1JrdzZrOWZVVlNFUDJaUk81dzQ0QTJRZktvWUc2R2drQXVDRGpoTWo2Y1ZUQVVJWkJJNzVxZHVESFdoZ20xdG1GaDFqZWxPTUdhR0M5eWw1U2Z2V2RwUkt0c3dUaVJ6aW9ZS20wdDBxSGV1TnFaaVJCTzREeTUvR2hnZDBwcGl6V3N1c2JnMllCa3hReHoyNFgzdHdwUmlTZWxVd2hQaTNSZ2NVVEVsbHJZeVhWRHhkQjFvdUJ4NFQwUDUwUWhWZzhSd2FLYU9SUXdka2xLY1FDUkZERGhKOCtLR0NwVWQzaFB5QW9ZeE1ieGdFZWhvWU00Q2hISFVEL0FMVU1ZbEt6ekI2elJCVUtPSlVBZmhrMFhCRkx5WVFGRHptaU9uWEJSM3lnN3VJM2RIYy9qMHFMbzloclY1cFoyV0w0REJ3dGh4WWNaWC96SVVDRDlLbWVqZllyOTcyWjFDVHFXanVhWS84QThmUzFkNDBUNWxoZkgvU29WcmI1UDhDc095VmxxdW8yYkZsck9scnRIM2tvZGZCVTI2eWttQ29zcmdrQVp3YW1yZGJDZXo1OW1GbnFXcjZxUTMyajc1N1Q5RlpDTWJZQVZlRGd3RXFWdDhpcjZhdkhFVHR5MTFDQVQ5MmdOOG8zQXg2a21meHJJeldyQi9STlp1dE4xRzNRaTl0SEMwNmxCM29KZ0VGSm5JSUlJUHJWUkhUY0lPM0tVays2TnNtUGhPYWNyd1VMU2hRVHRDVHhsdkhxZWZLaWNFNzFvRCtjeGozWW9NUzRneUlCanpCb3ZBUGV0dHFCR3dtZWdQVDUwSmNTeGNOclZ2VzJncU9RVEl4UG5OVERWWjJvdkFMWkNFb1FrckV4RW1xY05RU0NvbmJrMFE5Q0NWZ0hqazBOSHVWSHdOekFBay8yb0JqZytWQXhYU1lvdWlCR2VRS0lKaUFaR09QaFJkT2FCVHUzWUg1MHB2c1VBSGpFMU5UUm0waElLaDczVURQK0NtcnBIbGhTRUJPZkZ4TkpUYWZLbFlLdHRVMmtLUUkvVVVRWWJSSVVDVEo0b09vNnFXQXR3QjFlOEtJVnVHT2FsRmE1Y05JU3BDM0ZxQU9NZ1RpaXhHTHpBQ3R6aTQ0ancvWDBvZ0xydG9Tb09sd3dtQkpUakZHbTNkcXUyRmgybTBmUjdOelJMcFYxcHRvMWFXOStxNVBlcUFURGlWaUNGcEpBS1RnajUwbTB4UXBRMDlhQmxXaU9yV0FVbFlVdmM1dVBLc0dRT2dFVmNxZWVtLzhBYnpRa1gvWlRRZTE5bnBxMzdwNjBaWjFObGFuTnpTa3A3cHR3QUFZVVdpayt1M3pwNFJjMjJpbzB2UlA5a0U2QmFydnIvUWJtL3dCUWVMU2xMUmQ3ZThZWjNISTJwUVFRT3BCcHZPSGh5VmVoYXE2cEsyZXpicE1CV1cxUi93RGFwLzhBZHJnYSt6V3ZwbEo3UFhJQmpLV2laUHgzVmNRbit6R3Yvd0RzRjJZSTkyMmNtaW9iblpqWDBFcVgyZTFDRG1EYU8vaGlnVDl4YTRFZUxRdFIybmtpemRBZ2Y5T2FaVEdrOW8wdm92U2grM2RZSS9sY1FVbjZFVXhGVnR5UnlCNVVFcG53b0tpZlVqOHFBSlVTU1ZaVWZLZ1dja1JpZ3daelFQbVZlbmxRS0pKOVBTZ0lqM1ZmUHBVQldISk8xVlQrQndKQkFTZmhWQWlTWGs4Z1ZSSUNpTnBNWW9DbEhlWlZtYzBEOWtsVzNpVFFkbTFDOFFibGV3MnFWQ2MvWkVBRFBsRlRhdUttOHZ1N2QzTnFiUjBKRnMyQ2ZVR1B4cHRFQjI4Y1BpUmNxQ1U5UWhBejlLQUQxMjhRRDl0dUJ1NElJNG5IRkJHWGN2S1VTTCs1SW5QM2l1bndwZ2F0YnluQ2s2bGNLUkl6dVhING1tVDBWMDNRdFhiMGpzcDJQdjhBVUdqcU9paFdvYUZxckVTWFcxT0I5dUpQdkptUnh3UmlhYytFUnV6V3VwMXIyOTJldE83MFcycGFpNHliZDR5UTI2eXBsS1QwNGlrV3VZcTA5NjNVVzF2dGtzcUxlRGlVa2puNENoYlNwc2xMY2szS0VnSXdOM0o4cWNJYW14ZlNvcFJkbVNaL2lWTW5wZVJVMjJvSVVOdDg3M2ZRb2ZNejVjMWNucEFiNjgxZXlzbGxPcjNhRWtFYlJjTGo4Nm1UMGEwTzdmZGZlVXQ1NXgxZVpVdFJVVDlhMEJSd21jem1nSzRyRzBIRkFQcElQRkE3TUUrWm9NRUFZb0hJSXhBb0hwT09JaWdlMnFFWkVkYzBEZ0pQWHBRRTNtQ0QrVkJpeDQyeU9lRFFHRWdjVUJXWko4aDBvSlpDZHlwU2s1NW9PaTZvODc5dU8xMUFDU1loUFh5SHBVV0taeFQ3aXRvZFJCRVJ0T2FJaHVwZUNWSzc1QUE0T3ptaldvcTF2clVRMnJ4QWtsS0VIa0RQRkVvRGkzMEdQQ25md296SDBxakVQdm1CdmJNZWZwUkRoYzNDbGhvcThHL3ZPN0xoMjdpSUtvNG1NVFFQUmRYRFRqVHJKS1hteUZJV2h5RkpJeUNENWlnWXQ1MUNFcURLNUtlWm5yMG9ISnVGeUpRNms4NUFnbWdSZHl0TGhqQ1ZkRklvQk9YdVNvS1FBSUcwR0JRVmV1YWd0YktXd29GSXhoYzBHdnA4VG5uMU5BOUhLbC95K3RBa21jcCtNMERTQ0UvclFQNFZpTWV0VHNZVDRhb2NrNS9XZ1Vxa2NZTkFvQ3VZekZBOXNxSE13TTBCZ1pQdTBHSzhKVDVBanB6UUdCaGNTZWV0QVpqQU05ZUlvTEJJYlZKVTRsSms0SW9PbDNuY3VYQjJsNUlLdmVXeUNBZnJUQld1V3dDVk9KRnlxSkVKWUVEMTVwbjRJeTdjbWY4QVQzcWlFZ0NHQnlmblRLSFc5dXdYRXFjYTFBSkpJQkRDVEg0L0dtWDB0cVZkMittb1oybHk5QU9EdXRRZW1NeUlxWmZRZ3RzYVdwU0M1ZVhEUmtBSlZacVA0N3F2OE5FWHB1a2Q0alpyTnVnS3g5NWJ1Sm5HUmlZcWIvcVFGV2k2Y2xQM2VzNmFwS3VmRTRpZnFtbXhjczdSMDZJbGF0d3ViTlNTSjJwdUFuZG5ISUZQNmhybWhQZ0JUWGRxWHlDaDFLZ1NPQU0xUXh6UnI0K05DSEZIZG53N3MvSTBFTzUwbTdDU3BiVGdRRGs5MmY3VUdtYXVzbTRVQ0lnK1VZb0liWVBrYzBCQ0lTQkFtWk5BemNwU3BKaytjelFZRDErZEJrRUtVT2MwQkVwSkVjVUQ5b0VDZUtERkt3Q0RFOWFCeW5JekF6NVVERXJVUWZLZ2VrbnhTc0FtZ2NTcm5lREdmeG9EbVFzQ0JJUG41MEJnNEV5RkNBRFFHS3h1VjhmS2FEMG00N2RXN3JnRnFBUXFTU0VUSHhLdWFvVmwrL0R1VkpUSXdGQmdIOFY1cC9RSzgxZTZHOURoY21QNUZzSitaaFZadFZXcjE2OVM0ZGphaU9aNzlvQ290bXBkbjJ0djJ2ZnRtM0FPcFUwcUIxRVNKcHQ5cGtUeDJ4ZTM3anBOdXBzR0NrMjZGRkk4ekN6VisxOXJnRG5hMng3MG04N042YXBNazdITFBhUjVTUk5YN2ZMMm1JaDdUZG5IbGZlZG5OSVRIVXRGT1k2ZUNuMytYc3dKV3E5Z2wyNFZlYUJZa0grVnA0cFA2WXA5cVdNZnZQWlE0eUM1cEY2ejBPeDVVVDhRcXA5L3lJcUwwK3pSQ2tkMHgyZ2FSbUZOWENGWi93Q29mclQ3ZmcxTHRaZmRrR3JGU3RPdiswLzJvcUpTRkZyYkJua2lEekg0MU5uci93QWpranpoY2VVb3FVcVR5b3lhb2MxSGVBcTRIeXFncnhFaFFNcUluQjRIUUdnR1U3UnhIeDZVQ1JnUitWQVFlSGtjbWdXU2VJK3RBUUpWdUFUQkpPQ1RRSVdGN1VFclFRUmlLQWV6d3lTT0tCeU1nWkFnNHBvVklJSGhLWjU0b0hEY0ZSS1BwUUdiV0lLREpQQmdVRWx0VWdTQWxSelBuUVNHa3VLM0VRQnVQVG4xb092WGliaGJpaUVlNlNNTEJGTEJXUDNJWVdVT0thUWR2SGVwM0g1R29HT3ZGOVNGdDkrVXdEQ0J1a2VrRE9SVnkxWlZVODQ2b0tXMkgxSUdKVUkvU29VTDdRK0NGTnFNbUNRVmdSOFpvU25KNzVTOGdaRVIzb0h3R0tHSExiZWR3cGFGcUFnS0xoTWZPaERIclpTRXFFTkNjekNpY2N3YUdCSXRRVndsNW1USjl6bkhFazAxTVloYkFKbFpYRUdNUVQvYWdocmV0aWdKQzMxR1RHUUJIMHFqVTllZFNwOVFRVlFEMU5RVTgxUVZKeW1RRDF6UUtrNTU5S0J5bEh6eDhLQkNzek9aSm5HS0JOM2lNa0RyazBEa3FBR0NKajQwQlczQWt6MTZoSXFhQ2ZhTjZFeWxlUGVPSXFnS25OdzY4Y1JGQTNlcmtDUG5RT1R1bVNUUUVTQ0ZZbWZqUU9ZUXNLa2c4eWFDY21DTXlBY3lLQXhhVko1Z0dCbUtEMW5wbnNJVWRPY3V1MW1zM2wvZEJKY09uNllmczdKTUh3Qlh2cUo4OGZDdFNmRHJOVGxNdGZaanBGcFoycmY3dXM5TnNYSVc4MGhnOTZxVXp0VzZ1VmtEcmtUVnRTV3Q1WWQ3S3RJTFNHclFOTkpDWUNmZDh1a0RpczZvN2VsZG5yeDRLUmIyaTE1bFFTRlNUNjArM29BMURzTm85MGtyWHA5bTRDTnNxWlNSQitVelZsSEEvd0JvYjJjTjlrT3o3SGFIczh1NHRrbTZRMWRNcElMYVFvR0ZBSGp4QUR5elV2STgrSHRCcXlBUWJzbWVwUUpyUDFpc1BhSFV5QUZPb1hCd1ZOakZNQy83UTNweVc3ZWZQYkg2MDVEMmUwVGdjKy90bTFKaUQzWktTQlRrQXVkZGRVNzkwbEhkam9vYzA1RmRlWEs3dFpXN3RDam5BcWlLTW5OQVdDRDBvRmlKbkZCdmZZWDJVZHJlMmltWE5MMDRzMlRnM0p2THM5MDF0ODA5VmZJR3RUNCsrQjN6c2QreS9wTm8zMy9hZlVYdFZjNk1Xd051MFBpY3FQNFU0blE2SHBYc283SDZMdCt4YUJZSjJueExkYjcxVS9GWk5MODc0SE4vMnBPeDJrdGRobWRhMHpUcksyZnRMMXBEanJMQWJVdEMwbEpTWTVBTzAxTDhyWnlQS2hiSU9Sa2VsUUlVQUdNWTlLREFpUVpvRlEySk1tQjhLQWdSeG5OQTVDTVo0SGtLQ1F5Q1I1eG5OQVZDVHRKZ2VFengwNjBFOUN0b3oxTTlhRHMvYUQyaGUwSHNndHkvMC9VN2pVRXY3V2xwdkdnOGhPMmRwU0FCdG1USjY5ZUtsK1BvZHk3SysxRFE5ZDdETjZscVY5YU0zWXQwRjYzQ3gzaTNOb2tKYW5kbGNnRE5QdG5Ia1hXaDYyeHFPcHZocXl1TGExZFFnaFRyUUNkMEh3cUhTUlYyK1JWM1dodjltUzQ1bzZtM2RQMmxhYlJ3a0tiemtJVnhHWkFQMXEvNEpXaTlxVlAzQXQxMnQyeS9pVXVvSXg4ZUk5UlV3VXY3U0xDYnoySjlvMXZ5bnVneThrREdVdklpYXRSNFVmYkFJakkvU29xT3RPZHBCQkdEUUljOVI4WW9HbEFtZXRBaWtnSm5yOEtCaTQyZ2c1b0dwSEE4NkF3Z0t3UHhvUFNuN09Ic2I3TjlxK3pyWGFqdERkL2IxZDh0dE9uSVZ0YlpVa3dPOTZxSndvREFnaVptclBsSi9vOUkzMnQ2Zm96QzBXTEs3NTlsQUJadEFrN1lHQVZFaEtSOFNLejl2UW91eUhhM3REMnAxQjVDdEliMGhpMmQydWh4MFhCV2tpVWxLaytFZzlZbURpYVNYeU4yZFNFd1gzRTdqNkFab09mZnRDMmlMMzJOZHFHdG9VcGxoRDZUNm9jU3Y4dnpxd2VFYnB2YXM0SG1QV2dqcEdaSmo0MEdiVEhJZzBCVUlKR0lqa3lPS0FvZ3E4UDA1b0hzb0NpQndUbWFBektDcFFJMmtIT1JRU3cwSjNwL0E0TkFSU1lVUnQ0OUppZzlFWDlvekt5YlpCVE9VbFFpZlBqTlVjcjdXNk03Mlg3UVd2YTZ6dEV1TnRQQlR0cTRJU29FUVlJeUpCNTZVM2VoM2YyZWF1NTJ0N0Z1YXpjaHUxMDY4WHROcTI0dHdrcFZDVUtWeVZISEFGWm43UjBsNW9uU2RQYWRTbGxib1VRMEZZUVlCQ2ZpUHpxaUZjWEgyTXRsdHhLMU5LeUFZL09uUTBMOW92dGhwVDNzcDFUVEU2dFpmdkc2WGJvVGJoNUpjSTcxS2xlRVp3QkpxZmFYaUR4dzZRcHdIY0RHUEtxQXlKNmZNMEdBY1R4UE5CaWtuY1lpZUtBWndyYVRpT29vQU9ZOFB6NG9ISlRBOCt0QWRDT0Q1MEhvejlsZG0yMWpSZGEwTkxwdHJoTngzNzdpUU55bWlrQVFUeGtINjFObmtlak5ON0RhQlpzTk5odGI3YlJLdHI3eWxwVW84cVVEZ2srWnE3T3hzemJsdmJzaHRvb1NsQ1lDUlUzUlY2aGNwU25lNlJ1R1pIUWVRb05DOXBPdUt1ZXhQYUsxYmNiUzB2VExoS2xLQUluWWNmcFFlSGk5dmJRcFdGRWVmNFZRRGhVY2Y1MG9GNFNUQStFVUJXMVNtQUppZ3lDWUlJVVBUa1VCRUFwTUF3VDFpWW9KYlFHd2trZ0RnaWdLa3FPNUtpWkdLQWdWeks4Z2tjVFFlaGxPMlNuRkJUYlpXWmtoWkJNZWVhcTVFZTRWcGJ5SFVPdG9XMlJ0S0ZiaUNtTXlLbXlkR0tQVC93QjNkbkxwMWZaOTI2MHp2UEV0dTNmVUVLSTRWc01pZlVWbTVlNHVHT2RwNzVMU21YZFoxcFRaTzRKVS9KUkhRWXhnbmluMW5vVXZhSFd6YzZWZk5QWGQrOHBiUi9qUEtWQkhCK05NaU9JTmZ4UURNeWZ5clNKWklDaEpqclFOUGlJaWZQSFNnd1NWY0VqOHFCWEFGS3h3S0FhOEdUT0Fab0FIN3haTkFjSndveWZEaWdWQkpNRXhRYkgySzdVYXYyUDFnNnBvRnlscDlTQzA0aHhBVzI2akIycUh5R2VhbG1qMUw3Sk8zdW9kczlHTDdxZEt1THdLVWgyeFZxSGN1TndmZTJFWlNRY0dUNVVHNjNOMjVwVGgrMzZlNDJrK0x1Ylo1Q3lmU1NxbkJxdTFqdE16ZXRoVEZ0ZEpXQ0VNMlMxSjN2TE9jaEp3a2RUU2p6MTdZZTN5M3UrMGV3dUduN2twS0x0MWxPMWxub1dteC9NZk5ScCtqa0RQallSQWpIVStsVU5TUnRFRHpNVURsS0VIcmlQalFZRHlTb0dnTWtnQVNaSDBvTTd6QUVpQkhGQVZ0NlFRUlBTZ01ISWd6ZzhHZ0tiaEtTUUNCbnpvTy9QTnNaVWxGd0FldTBUL0FKL25TcW4ydFExS2JTNnBEYkRoUVNWNzFtTTlZanpySDYxcXIxSmhKTWkzZklrWjNqSHppcmFhZ09XNmkwQXF5Y2dxOHdlUlFxRGRzcENYaDlqMitBanhLa2pIbEhOQnhzQ0xoekJHMG41VlVFM1lUQTlLREpPQVBMNjBHU1FveGdlbUtCUXFUSFQxTkF4NHczQTg2QnJXR3pJTkFRQUJuTTVQUHlwb2MyUEdSRUNPdEFkQUtXd09uRlRZR3dBcEtoSVdPRE1FZk1WUkt0dFoxSzBjMzIybzNUYStKNzBtZnJRUzBkcXRmUmJYRnUzcXR5aHE0RzF5RENsRHkzQVRCNjV6VXdWVnVtU0V4ejBGVUt4RGFGSVBSY2NVR0xCUW85T3VNNG9CcVdNNXdhQm9YZ254ZklVQmZISUlTZlFuRkJuZHVFektmaE9hQjZRdklrRDFvQ1FSQndUeG5pZ3NMYTNMelpVU3lEdUk4VGdRZnBRZWxyeTFYdmsyNnlxREJDejhxclVtS2x6VG5Gb1ZOczZBQURKVVpQU2FrM0RFWjJ3Y2NRcHhkdUNoc0RDbEVtS21XR0sxMjFjRERoTnVrcEFDdHhKems1NWtITlF4VzNMQ0hFRkJZS1FjWlFUOUQ4NkdOUmQ3RDZZU3BhbmIxRzdPRUQ2VmRUQTBka3RGRWVLOVdBa3lTb0ROTkpESE96ZWt0clNFTVhDd2VxcDQrdERDcDBiVGU4aHF4UTRrWUJVbFFuOGFJYnJXajJOcnBnV05NYVE4RktCVnVQVDgrYURuejQrOFY1RGdBelZEOXNOZ255b0NML2dvVDV5Wm9FYkpnbFJudzlhQ1RrTmc0azlLQVNpT2dvR1NaSHB3YUJ5Wk04MERtMXFLU2tHRXpKeFFQN3VYTndVUlBsUU5XMm1SR1Q1bFZBcFNKRUorbEE3WWR2V2M5YUFnU2Rva1JGQVp0QkJHQkp6bWdSVGNPUU00bWdjcEJWdXpRUElNbkhXZzlYM1NRc0FSSXhPNXlEOHFvaDdGQXFHd3lKSlVIQkFGRFVLNEN5c29ReW9RVEEzQThlVlNyS2hxWmRVbmIzVHllUk80RXdjNHJCVUIxcDRBQUM2a0RvSjNWckRVVjFwMVNDU2k1QXlGYlVnZ1V3MUVZdGlFYmx0WE1oSkFnREl4VUloSnRYbmxxVDNEcDhXNGxZanBnRHI2MVQ5Tk9tdnlkMXF0UkpBRzVZVGdVTDJxTzE3YTJOTDJLYVlRSUp5NXVJNEdQS2lPUnZZV2VPVFYwUFBBa2NDS0F6M3VEbU1SK3RBTk1iczVpcHlEcVY0UUtvWkpFa2lnYkFKQlBQd29FUFdnZTN3SlBUbWdPZ2tLQTg2QkZueDUrR2FCU0J4T2FCUUNBY0NQaFFHYUhod01RUG5RRkNRQ0l3UHdvRWNRUXNUSjZab0RJU0FpQ01uaWdPaUU3aEUrSStsQjY0MVQ3SXhxVGxrM2FzUFBnRlhoVkc0QWllYXRvcDFxYUNpcGVuYmt5VElXQmp5OWVsVGtRYnRMTFpLRTZVVXBLYy9mVE5PUlhyUXpnSXNsU0lHWEIrR0t6M1ZxRSs0eVd6L29IQkFrK0tDUld1ZUNJQ3Jsa2dBMlYwM3RNNGN6SUhIcUt5aVA5b3RFRUtMR29EdkZTQnZ3ZjdWUkZkZHMxRkpGcmZ1VGxJTG5Yb1BwVVdveGR0MHFPM1RuRGtnQmJtQ0QweG1xVnJYYlIxWXN3RldZYWdFa3FVU2MrZElqbUNzcTZjMVFmYURqcjVpZ0krRDNjR01wR1k5YUJpRWdRQVJFZldnT3BJMm1QZW9CaFBrVEZCaDVOQXhVeitWQTlITUVUSFdnTWtsSjhNZ21nYTdLL0VveVQxb0hORHdrbWVJRkE1TWhKRkFSb0VwSFF4OUtDWTJEZ2dTRG1TT0tBYWs4bk0rWG5RU1dtOTZZUHdvRHBRUEZFSEo1T2FEMVA3U3JadXo3WUpmVGNJSWV0VkVCdHdwQUlXSkUrZm1hdDVHc1hMZ1RBU3RVWlRIZThZNEhtS3pab2d1dnZnTEtsdUJLUjczZmpFLytLZlVRbkx0d0RkdGNuTUh2aHp6L0FIcUxRSFhIRk5LbEQ2Z015SEJBSkZDSzE5eFFWdGk2QldBSkNnWjY5ZVBqVktocVpjTHlDeW04VTZESUNWZ2srY0Rta21rb2x3eVJ0YkNMd0JJZ0pXNEFab3VvUzJ2RHZLSEVrOVZQa2dFZWdvbDdhdDJ2YlNobEtJWkN0c21GS0ovR2lORVFKV24xTlVURzBlTHI4YURMa1FTVEE0RTBBMEFod2crN0E2VUVsYWZDUDkwWndhQnFVN2NmUG5wUU54bkVnNGswRENNazlCbko1OUtERXdCeVlpZ0lBSkE2SDFvSHJTQWtjOFVHSlNJaFVHUjlLQWlVcGpnQW40MEJtVURZbVJucFFTME5uYk9ZK25TZ1lzU1JCL0dnT2lRbUV3c3htS0E3YVJ0eWdLeWVSbWc5VjZscExsMDZUZFd6N2kyMGJONjBqM1ptQWV1YXVDdGYwQkplVE5nNjJ0Q0JLUUFjbnI4OFlvSzEvcysyb3FEakR3Q3pCS1d3U1BqbnpvSUMrejdZZU1zWFFtUUU5eWNmR0RtcGtXb2J2WitGdUFvdXNrcUgzU2g4em1tUk5RaDJlVzQ0VklhdkVwalAzUzRBK05YQTlQWk45eGFpeGJYNVBSYmFGQWlmWEdhV1R6RmxISFk2Rk5xTnBkT3VFRWVNWjlUSlZpcG5vMm5mN0hObFN3aTFHN21YRk5pUFByVGp3bGFiN1VkRGEwKzBDa3B0MHBnRVE2Q280UGtQaFVIR2tKQktJODZvc0cyb0lKQUlQTVp6UU51L2RXUUJ4ejA1NlVBbTA3SEVnKzhPVkF6UVNsN2kyZ0VJQ1JqSE9UMW9BYkNKSVB4enhRTlVuT0JKb0dFVHlJR2ZqUUx0QUdlUHBRSEtZQkltWUI0eFFOSUtnRE9Qam1nVnRJSkE4OFpvREpTUWlCQjlhQWpZQVFPWXhtWm9KU2VQRVRQUXh6L2VnYzZDcVZFeHdBZkwwb0hNd0UrRVRCa0VVRXBwYVFnQWlhRDJ5OHRydkhDR3k0U25Fb2dmRE5hMW5mQ3N1YmdKRXBzMm9JS2dWR0t5MGdYTncrcEpjVjlqYWJHUW1SajhxQ3RmMUFKZVVPL3R0d1daS1lKNCtOQ29GMXFoSk0zYkFPSWxSS2dma0tuOUVCZXFIZWUrdjkrNGtvaHRaUDBBcTlDSis4UVZIL1h2cVFTSUNHRCtFOUtuOEljM2V0R1VkL2ZnbE85UVFsS1JIeEpxY2Vsd291MnRvS25OU0tjNER5RXdhdjhBRXJuM3Ridm1WMk8xS0wwN1JFdXZvVk9QU2c0b3lDWEVEMWptcUxKQ2R6U3BnUjVabWdqM1JsSzVuNUNLQmlkdmZrcUpDY1lIV2dQdUNreURnbmhJZ1VEUWtxVVNKaWNSUU5YdVBDVEhVbklvQkw0eVQ5S0J5U1FmUC9PbEJMWldsTWxhaUJ3UkUwQVZESkFHSmtFOWFCVzhxRWpqclFGVnRBT2VlWUZBclJCU0FyR0tDWTN1M0pVTUVSSi83VUJ5NmhTRkFJaFN1SXlQV2dHSEVxeWttWkVEZ2dVQjJFU2pDVW5QSlVmN1VIc0hWeUVFOTAwb0VLSmdJSm5QVE5XVnJocnp6enExZ0cxZkhKamJVTVY3djJrb0pSWVBMVVV4RzNhUm55cW5DQVdkWFJJYjAxU1VLaE9TRXlQbldlUzRqS1kxUlNzczJpRnh0LzhBVVNmb0RVblp3alhGbHFnQklmczBna1FxSmc5Uk5YYVhFWWFicUJYNHJ1eUtTSmp1emdlWEZTMUlNblIzOXdLdFNhWlVZOTIzSkpIbE1DaTFKdDlNV2xMYmYyOHFNNVVMVTVINGRSUkwyMEQycWFldTNiVVRldlBCU1lPNXNKQWdEMXF4SEpHQjk2Z0U5ZVBXcUxGa0FtVkFnZVFNVUFydG9ndVFrN2drbVBLZ2pOcFZ1ek82QURQblFGS0JzVWVNY3hRUFNNeVJuaWFCaWhJZ3pKeWFBSlRPQ1B3b0ZUNm5CTkJNYlFGcGtyZ2ZyOGFCWEVuaWZEME5BeE1EM2djOHpRS3MvakdQS2dHbFh1U1lCb0piRHBHMkZtT1lvQzk2U3VVQ0VyRXdrSEZBamFmRWxTYzR6NlVGZ3krdERZQ0FJK0FvYTljWHIxektrb3VVNVBFS3hOQnJ0N2RYdTljUE5GQWtBS2NJTS9DbUN1ZXU3ODRVR2k0bit2Y1RuclBXbUFOeGZYcWRvTENGek1FeDg0enpVeXJVVzQxYStjUWhwOWh4VGFQQzJudkkyejVFVTUxRUp5NmZkU1hGMnE1Vndkd0VINjAwUWU5Y0t5TzR1a2s3b0ljRXlQT25mS3cwSlVwc0xXemRqcVpjQmtlVTBRVmtObDFLQmF2QXJWdFNWUFJKTVJPZk9talJmYU9XQ2h3SVplYmRTRGxheG1JK3ZXcm81d2xKRnlrNUlWSmtmaWFDZTJJa2pKaVNmT2dIZEpKU3VaamFmS2dqTXdIRlRNY1RRU0NESlVtVDhmMW9CRkJpRlJua2lnYTV3QlB3b0I1S3VvZ3h6UUtsT1J6SEJvSmFOeWhDU1lIbFFLNENFeU13ZWtpZ0VFcWtpU1I4YUJ5Z290a0RtZXBvQWhNSkJtQUJFelFUclh5UHhTZjg2VUdHU280Nm1jMERtTXJLU1kyK3VLQ1VncUNZVE1EeU5CNjl2RXZyUnU3Z2hFS3hKbUo4L2puOEswektDdTIza3JTMkZiMGhaVnhzSkJ4a1ZGVjF3aGFFQXBhSWc0MnJCM1ZGVnkwRUpsVERwakFWUE1uSXB5dFFMcGpkdWxwd0dkb0pTREE4dUtJQTViVzVXWVpXa0RrS2pyMG40elFWeFlZL2hwN3dLVGtnSVNxSTU0NlU3RG1XMnlrUjN3QTZsb1NNWUhHYW1VTVdsbExxQ1ZQays5dERRRUU0L1NsNEhPZmFhVU5yaENIUEdaKzhRQVp3UDBwQno5aFAzdU9VazRqTVZSYVc2VXFSNzJPREhOQXg5cEs3ZDhJRzVXMGovUFdncjJOeE80aUZFREIvT2dtSWJJVE1uMVB4b0doczdVd1lIVUdnRTgzdVBQaUV6NVVBMW9HTUtBbmlnWWtldkhTZ2xKQkN1aGpQRkFSU0FHd1VreFFEUWd3QklrZzBDcVJ6eEhrYUFHMHdEQStmbFFUTE5DVllJSW5neE5BVjRqd2dnbWVCSDFuMW9HSWNsU29KK1BOQk5aSjdzU21mZ1lvUGFkdzVzQ0IzaTlqZ3lFT0R6eDFyVmwwUkZYUnVFUWdPcFVFUnRMZzU4L3hySUNwZ0tiN3dKdUVxbFNSM1lUMEhNMEVaelNkcDJPTlhJUXZ4Q0d3WnhrbWkwcnVtRnhRVzIxZXFHREJaQlB6eFJsRmMwZEliQVZiWFNUL3hEYWJpWkk2MDFVWnJTV1VwVWxEVjZGTnFJSk5rT3ZUMWswR0d6c0xaOFcrcUxjc0VPRXQyMXlwZ2xwemR3aFpqd0xIa2NIb2FBcU94dHM4dFNYYjUxSlFTWURKZ0dlU1lvT0ZlMjdUV3RMMUZ0bG01VzZkOGJlN2lPWi96MXFEbURDUVgyazdlUW9UaXFMVzNRQWtqQmxKRVJ4UVp0bGFrZ1NWSTRIWG5OQkF0Mnh1S1NvUU9CejBFMEUwTVlKVUR0Z1NSbWdBdHBYQkVuekZBSmFDQ0lCZ2VlYUJpbXBXWXlRZVU1b0doc0QzaEN2S09JNG9KTFVKVnRBeHhuNFVEMUpUNlNBQnRJNjBBWVNJQ3VJNDlLQjZnUW1JeHlCUUJPV3hqd2dtS0E5dWRxeHRqSFU5UlFaY0pWMzVjVktrcDQzRE9ldjBvSTI3Wm1NQTUrRkJQYWNQZHA2aU1kS0QzUmJzdE9hcW9PTm9VQTBDQXBJTVpWL1lWMCtYVEU3aGpscGI3U2ZzN1U3bFoyQ29zQzFlMlkrejNYM0xlQ1FQQ01Zb3FFd2xQZW9FQ053RVIvVFV5YUpxUENmRGpQVDRVdmNVWmhhdnVSdVZHMWVKK0ZWQTdsMXd1cUJjV1FFbU1uK21zK0ZiTllJUmNXSmJ1RXBkYldraFNGamNGQ09DRHpSRlRldG9Ta2JVSkgzZ0dCMHhXaDVaL2FVU0U2NVlGSUFLZ3FTQnpXYXJqOXY4QXhMZjRmclVGNGdmY0U5ZHMvaFFGNHVER0ozVEhYRkJYV3Y4QUFkUFdVNStSb0xJQUJSZ0RqOUtDTy94OEZmb0tBSXlYcHpDZjdVQ1hZQWFWQUF5YUNFNzc1LzVnS0NRUEVTRlpHNDgwQ3lmQm5tWit0Qml3SlNZRXduOGpRWWY0S3ZoUVIydjRhLzhBbU5BYTN3MHNqa0NnVjhraFpKTWtEODZDR3NueFo2VUVrT0xTbElTdFFFY0EwSC8vMlE9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvTGVtYWl0cmUuanBnXG4gKiogbW9kdWxlIGlkID0gMjk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvL2dCS1JtbHNaU0J6YjNWeVkyVTZJR2gwZEhBNkx5OWpiMjF0YjI1ekxuZHBhMmx0WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2sxdmRHaGxjbFJsY21WellWOHdPVFF1YW5Cbi85c0FRd0FHQkFVR0JRUUdCZ1VHQndjR0NBb1FDZ29KQ1FvVURnOE1FQmNVR0JnWEZCWVdHaDBsSHhvYkl4d1dGaUFzSUNNbUp5a3FLUmtmTFRBdEtEQWxLQ2tvLzlzQVF3RUhCd2NLQ0FvVENnb1RLQm9XR2lnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ28vOEFBRVFnQTVRRGNBd0VpQUFJUkFRTVJBZi9FQUIwQUFBQUhBUUVCQUFBQUFBQUFBQUFBQUFBQkFnTUZCZ2NFQ0FuL3hBQkRFQUFCQWdRRUF3VUZCUVlGQXdVQUFBQUJBZ01BQkFVUkJoSWhNVUZSWVFjVEluR0JGREtSb2JFSUZTTkN3VE5EVW1MUjRSWWtjb0x3b3NMaU5IT1NzdkgveEFBYkFRQUNBd0VCQVFBQUFBQUFBQUFBQUFBQ0F3RUVCUUFHQi8vRUFESVJBQUlDQVFRQkFnUUZBZ2NCQUFBQUFBQUJBaEVEQkJJaE1VRVRVUVVpTXZBamNaSEI0V0dCQmhRa1FsS3gwZkgvMmdBTUF3RUFBaEVERVFBL0FMMTJhMTVpWWxsVXcrQmN2b2tFWmREdHBGOUhuR1ZZbnB6a2tpUXhEU0VudkdrRHZVSi9PamlQMWk5NGNyVFZZcGpNeXl2TUZKQk9zWURScDNiZGs2bllRWUJIQ0dFdjJoWWVHc1JSdzVxTmpwRWJpU2hTZUpLUzdUYWdtNkhOVXFHaW0xY0ZBODQ3bFBJU2tyY1VsQ0J1b213QTZtTWM3VU8yV24wbVhtS2ZoZHdUZFNJS1ZUUTFhWjUyL2lNTXg0NVRkUklsTlE1WmoxY1dpbXo4N0s5K0podVdlV3lIMERSZVUydmFHS1ZYSlZWMHU2RkovTnhpaUNwVERUanRuTTRXc3FXRjZoUkoxSmg2V25KVnhYNDJaazIzR29qVGVsNDVEeGEyNkx4TllnbHMyVUp2cHBsZ1NkZm1Wb2VUTDVoZnczSjJKaW55eTVhNXpxV3UvdW0yOFNNbE9ld3N1WjBnTnExQjNNQThFVXFTSCt2S1hiNExIV3B0bVh3MzdIY0V1cVNiY1NvRzVNUFlTN1NNU1lmQlpwdFVlN2hwWGhZZS9FYnR5c2R2U00vbko5YzNNWjFtd0dpRTMyRUlsbkNsMG4rS0hSMDZVYWx5WjJmUDZrcmo0UFE4ajIvMW51Lzh6U3BCODhTaGFrSDRheFg2OTJyVml0dWs1bFNqUi9LMnEvempMSmR3aFhROEkyYnNQN09Hc1JQL0FIN1gyU3Vpc0xzeXdyUVRiZzN2L0luanpPbkF3bWVMRmpXNW9HRXBTNFFXQ3NKWXB4cGxtNU5UMHRJRS93RHJacFJTaFgrZ2JyOU5Pc2JkaGJzNkZCY2JkL3hEVkgzUjc0QVFsdFgrMGdrZkdMaTAra05vUTJoQ0cwZ0pRbEFzQUJzQU9VUEJaUEw2eFRiM0RXNUlNTUpHeTEzNmdRc0pValk1aEJCVUhtc05ZNVJBZG5KV3A2WWxKRng2WERhZTdTVnJLd1RZQWE2RGVQS0hhcDJ0MWZGS0hhZEpQcWxxUUZFS0RmaFUvYitMaUIwK01ldWlRYmtIV01iN2FPeWFYeE93OVZzUE50eTFkU015MmtnSlJPZER5WHlQSGpEOFRTbDh3TGphNFBJTTJyTVRmNnhIdVd2cHRFclVXWFplWWRZbUcxdFBOcUtGb1dteWtxR2hCSEF4Rk9hS1BLTlNIUldZeXJlQzNnMTZ3UjR3WkozVVNvTHBOV2xaNURZY0xLcjVDYlpoYTFyeGM1cnRQbkMyVXlWTmwyRm44N2poY3Q2YVJueGdjZG9DV0tFM2NrR3B5WENaMDFHZG1hbE9PemM4OHA1OXozbG42QWNJNXIyM2dlY0hZSGpERWt1RUEzN252S2tOQmRCbFduUmRLbVJlL1dLVExLZHdYaWJ1VlgrNnB4ZmdQQnRaNGVSaTd5TTdKcXBERXkxTk1HVVMwazk3bkFUWURlOFpYMm85cGVIbktZOVRxYW43em16b0hVNk5Obm5tNGtkSTg3SEhLZkNSb1Rrazdac3Z0RFFsVE1MZFEyd0JtSzFxQUFIVXhuZUxPMlBEMUV6czA4cXFzMm5Tek9qWVBWZkgwdkhuU3ZZdXJGWVlReFB6NzdzczJMSlp2WkE5QnY2eFhYWFNUdnB5RVhjZWk4eks4ODcvQU5wZHNiZG8xZHhTNm9UczBXWk81eXlqQktVQWRlS3ZXS004OWZjdzJ0ZGhyOElaY09vMWkvREdvcWtWbkp2c0RhbXk0UStDRUsvTU4wSG4xOG9lcWxObUtjNDJIMHBVMjZuTzA4ZzNRNG5tRCtrY2gzaVRwbFhWTFNia2pOTmlhcHJ4dXBsVzdhdjRrSGdmckJ5dGN4Q1ZlUzBkbVRrbXRxb01UaVpaUzdwV2p2clh0YTJsNGxNVTFHbU1VcVpsMHpFc0hIRWxJYllzU2ZoR2VUMU9VdzAzTk5manlUcHMyOWJqL0NvY0ZRd2hGaGNKSHdoSG94bExmWWJ5TlIyaHNqVk9ieWp0UU5pTjd4ekkxVUxiWHZIZTBtNDZRNlF0RnM3UE1Mek9MOFR5bEtsc3lXMW5QTU9qOTB5UGVVZm9PcEVlenBGbVVwMGhMU2tvMEdaR1dRbGxsdEkwQ1JwL3puR1Y5Z3VHL3VMQkFxVHFDSitza082alZEQTl3ZXVxdlVScVRTVXFRWHBwV1Jsc2FBNlg2eGxacDc1ZjBMdU9PMUVrek1oU0ZLU2xLVURkU3pvQnpqbVRYRzFPRkxLSFhramRZOEtmUWJ4VWEvaVNVU2dxbkpscVRwNmRnNHJMbjlOekVkSllwbjZpbnU4TFVHWm0wSFFURXgrQXo1NjZtSmpoYlZuTnF6VG1wdnZMRW9LUE13NkhDVG9DZlNNcm5aMnNTM2l4QmpXa1VSUEZtVVFsU3gwdXJYNVJIL2UrSEhENDhhNHNtMWNWeTZGNWZraTBXSTZXL3dENHhUbWtiSVZxRy96aExpZ3BKemVVWkd4VnFPbFFFbjJpVnFUYy9LbW9Na3AvNmtpTEZJMURFemJYZnlreFI4VXlRRjFLazFobCszbGNwSmducFd2dHIvdmdoWkV6S1B0UDRPWlEwemltU1FFdWxhWmVkQUZzOS9jY1BYVEtlZWtlYTVpNVVlWWoyeGpsK1N4cGdDdnlNcWwxRTZKZFdhVmZSa2VhY1Q0a2hTVDFHaEdoanhOTUc2czF1R29oMkZOZksvQXZKeTdReXJuQ1lVZFJDZUVXQUVHWUtERUVkbzQ2eFZyd1Yra0JKMDlZVjYyamlDYVZQekhzaVpmdm5lNUdvYXpuSjhObzVsUEZYR0VrRlMwb1NDVnFOa3BBdVNlUUVPek1qTlNxRXJtcFdZWlF2VkNuR3lBZldFTGFoNnhUbEZ5U3RJWUtvYmRWdmZicEJxc2RpQ09ZaGtrazYzaGlFeVZCbFlQRFdHenFZTzQ2UWs3NndRSVIyRUgxZ0hZd0U2NkdKSkpPaVZaZE1XNDI0MG1aa0h4bG1KVmZ1ckhNSGdvY0RIYlVLS2dTeXFuUW5WVGxML09rL3RaYitWeFAvY05JZ0k3YVRVWnFtVGFabVFlTFR5ZExqWlE1RWJFZElWS0RUM1I3Q1V2REVvQUswa2NmbkYzN004TUt4YmpDbjBvZ2lXV3J2WmxZL0t5alZmeDBIckVlaVdrTVNLQzZlbHFuVm5kVW9UWm1ZUE5zbjNWZnltTnUrenRTUHV1aVZxcXp6S21abVlmRWtuT2toU0cyd0ZMc09xaVBoQ011WDVhNlkzSERtL0J0a3V5akpueUlabEdVaEtBU0VvU2dhQzU0QUFSUWNhMTZlcWhNdlI1bG1tMGhzM21Lck5DM2VXNE5JUDVSek8vQ0k3RXVMYTlYcXpPVW1sVTFpVWtaREtGT1RibGtDNHVGRUQzemF4NUNLcE4xQ2kwOThUTlVtbDRrcWlEWkNEWk1zMHIrVkk4UDFNTHc0SGR0REpUTEhoMlJrM0hSTVVHbFRGZm5kelZxcXZLeUR6VG00ZjZSNnc1V3FyVG0zRnQ0dHhqTVRXVTIrN0tDMlVOK1JXTlQ4WXBGYnhIWEsybnU1aDR0TUgzWlp2d05KSFVEVlhyREZQb1Rpd2xiWXNiRDNsaEkrSklBaThzRmZOa2RmZnYvQU9DZDk4UlJhV01XME9uYTRld1l3aTJ6OVFXTXg2MjFQemg5WGFkaUc0RENhZExwNEpibDFLSHpNUjBsZ3VjZlJtWFB5REtPazAzOWJtSkJuQVNyMkZTazFxUEh2d3I2R0dLV21qM3orckJheXNmYjdUcTB0SlRQeVZNbld1S1hHQ245VERrdFdzSXp6NlhabW1UZUhwNG53emxQY3lwQjVuTHc4eEMwOW5kUmNSYVhtWlZ5KzNpSStjUk5kd1RYNk5LcW1KeVN2TERVdXRMQ3ducWJiUTZQK1huOUxwL29MZnF4NzVMZzdOVERjL0tPMVNaWm5TbEJjbEt1eUFQYVdCcXRwMERUTUI0aDVSNDBxRHFYcHA5eHZSQzNGcVNPaFVTUGxHM1ZuRVM2TmdpdlN4VWJQSUNaWkovSTZzNUZXNWVFaytrWVN2UVc0V2l2TEhzbTBGdXRJSk91bGpDUnRyZldEQjhYV0FSWTI0eHh3U2Q5ZG9WYS9XRXdvYXB2SEVNSk8vbkM3bnA2d2c2V01MQjYyamptYWJnaGRNWWsrOFJNeXJyNmxBdU1UTExmZU5PV3RkQ2pxUjAraHZGdlM2c2xTa3VxRnhycmNmT0dwSmltRngyWG1xYkl5U2dRR2tobE8zbmJlRVROTG1HbHFXeTRGSkFOa3IxU2ZJN2lQUDVKS2NtejZ6OFB4dlQ0SXdqVHIydjkvdjJJTEdsRWJtcEp0eVRwcUhaMVpzSEVLRFFBSTk0blFLNUFIbkdYVGpEc3JNT01URFpiZGJWWmFGRFVHTklybGVxbERRMDRsaHR5VW1CYStjcVFWY1VxQkhMNDZ4bXMyOTM4eTg3M2JiV2RSVmthR1ZDYjhBT0FqUzBhbnRwOUhqZjhTUFR5eTdvSnFmbFZTL1BybS9leHNubkJYdkF2QkgxaThlWUJCcDBJTittMEE4YmJ3WEFnUnh3NWJTRGJ0bk4rTUVueEpCdnJDMER4RHJvYlJ4eDJNV0YxRWFKOFhXUFlHRHBCK21ZTW9rcE9yV3VZUkxKZGVLbFhKV29aaUNlbHdQU1BLdUZaUkUvaUdseWFnVklmbTJXMURtQ3NBL0tQWmRUdG5YbDBGejhJbzZqNW5SWnc4S3pBZTErWmZSak54TFNuUFp2WjJrdXRoUnlGVmliMjJKc1JFREsrRW9XdEtybllBZU1qa2xQQWRZc25hUE1CV002dXlsUnpKYmx6WWNEa3NmMGc4THk2TzdjenBTWERsSlhiVWkwRmsxdnBRcExrZGgwaXlTdHZnT2dVeGMrc21aVXRoby91a0h4ZjdsZm9Jc016UldKZVhTbVRrcFJSRy9mTjMwODk0YlFuMlowRkY4bXh5bUpSbWJTdE5zMWxiYVJpNXRSa3l5M1NaczRjTU1hMnBVWjNpU2pUS2xxY1d4SXJVRGJ1aTBlN1NPbHVQVXhFTjBLeWtxWVlaN3pRSHV6NGJubHhqVkg1R1ptSENHWmdOTTI5MVRZVmJ5dnJETEZJbFdsRU4zTGlWV1c1WUVrOHVrTmpxR28wVFBDcnNyMHhTUkkwbGMyWGxJRGFMZ2haVC93eEEwVEgySzVDb29OS3JLaTFleXBOMWZmTkxUeFNwS2lmbGFOTnFrZ21hcFMyYldCdGJ6NFJVNUxERXJQdXFSTU9XZUNnVFpzSlVDRHA1MmdzT1pSVGJGWk1MeWNGQjdZS216TnprbWlUYU1zaDNOTU95dDc5eXZRWmI4cjN0ME1aMGVzVHVPcHRNN2lxcExRZncyM2xObzF2b2sydjZrRXhBR056RzI0cHYyUFBaRWxOMTBGeGhhdFJlRytJTU9DREFZZ3dhRHJ2QTgvbkJjWTRrVVJvZUVHa0FpQUxHL1dFcFVRTGF4d0pzMkthdTZxWnFFNm1YYis2VzMzR2ZhbEwzV2tDNFNPWlVkUFdLTTVqYXJGZDIzVU5wdGJMYk5mMU1heFZNSXlrNWdtZVpTMkpaSmJVL0tsUjl3ZzVzNmllS3JhOUxSNThKdUJHWG8vU3o3cVhUTnJKOFIxdU9NVnZhVmNWeDErUlpwN0ZiczVRSDZmTk5wVzQ2cEpEZ3NBbXh2Y2ZTMFZna1gzaE40QmpRaGpqRGlKUjFPcXk2cHFXVjIwcS9zR0RwQjM2d2owZ2Vlc01LdEM3anlnQTY3d2dSMFMwbzlNL3NrZUhpdFJza2VzY2RRbHNnS0lOb2VZWlc2cXpLQ3NqZTNEMWp2WnA4dXdFcWR2TU9jaG9pLzFNUEdaQWJVbHRBU2dmbFRvUGxFZmtGdDl5d2RuYktaZkcxQWNtRnBTRXp6UnlnM0oxNDhvOVl1cVM0TGtqeEhYb09NZUs1ZWJkWWRiZFpPVnhsUVdnMjJVazNFZW9xMVhzdUNIYW8zb3FZbGtxYUE0cmRTQUFQVW40UlZ5UWJtbDdqWVNXMzhqSVhIM2F6aVBFbFVzVk5PTzUraVFWRktma2tSUDBoWVlkYkJOZ3BGcmRSRS9nL0RhSlBENzByTk41SHBzWm5qeEFJc2tlaCtaaUJuSlYyVlV0aDFKUyt5cXg4eHhpcnJvcmR4MFg5REsxVDdKeDRsVE9kSTIxQXZ1WUtRQkFTNkYyRnJGTjl5TnpEZExjRHpiYTFId3BOMUo0WEVPVFNrdXRPSmxWaEIwS2xsUUJGOTdSbDF6UnF4ZkZzNnB1YWVkWVczSnFVMmtEeE9KM0J0c09zTzBpYWsvWWtOeTc2QThBQ3E1MUt1TnhFZEx6YUdtUWhLWmtFYUZIY0VnaUl1b0lrWnRhVktkUkx6S0ZaZ3B4QlFiamxjUWFqZkFMazI3THZQdkpia0huZ29YU2tFQUhqY0NLbGp2RmJXRzZlcGJTa0dkbUVFTUl0cmYrSTlCSEhWWjlNaFRselUwNnQyWFpBZFdwQ2haUnY0VWpxVEdNWWtxOHhYS3E5T3pXaWwrRkNBYmh0QTJTUCtieFowdW05U1Z2cEZYVmF2MDRWSHRrUytvcVVwU2xaaVRjazhUeE1NR0ZLaEJHb2pkWEJnQTA0N3dzSGErblNHanZDZ1k0NnJGbUVtREkwRUpNU2NoU0RyQ3lrSzEwRU5DSEVuVGUwY1EwYloyZ1NkVnFVb21ucW5uR0pDV0pTdHBzYjY3cUIxSTJ0cmJwR1MxR2x1eTg4NDA0MlphWGJBVVhWS3pqTHRlL0VrOEJ4alhhbS9PUDFPWW1ucHdMVStsTm04b0xZdHA0U09GckMydTBaZmllZG1Lak5NU0hzVHpjeExxVU83QnpGZDdXSVNPblV4azZOeWo4c2VnOG1TVTV1M1pBdnFRcFo3cEJRMk5FZ201UFVubkRWeGFKaG1sSmFmN3FiS25wb0FxTXBMcUYwQWNYSFBkUUJ4M1BPMFJjeUVCOVliS1NqbWdFSjlMNjI2bU5HTWsrRUNObUJmYUM0R3dpUnByQ1FrekxvQkE5d0hpZWNNc2xjajBuSU50bzcyZDFKMmEyK1A4QVNPaDZjOTFJSGhBc0FOaDBBamtlbUE0cnhXM3VxNU9zTVp4cmJRWDJKaVZHK3duSkxvNkhKaFdwSGg2bldFdHU2V3ZZRWVVYzVVbFJPMTc2UWJaT2F3QmlhQWJIMkQ0ckhuRytZRFE3aVRDZENsM3ZGSzA1dHdyT3ZpZENpbHNmN1U2K29qQW1SWjYwZW9Pd2FYRG5ad2xkdFV6cnFmVE1EK3NMblNhWVVQS0xRekxxdWdtMXkyRkMreHZ1SWljWDBBenphWnlTVGVaUU1xa2JGeEk0ZjZoODR1RHN0L2xXRkFmc3lVSHlKdC9TRU9JSzJsRTVjd0ZpZWZuRlRMRlpGeVdjYzNqZG94dWxQS1ljZUNrS1A1U2s2RUhscnRFZzJ0cGFFSVNpeXhmVUtJdHB0MWk0VmFuTXpBY1creVVyQXQzellBV1A2K3NWYVNvYzVjcE02WGJuMzNVaTRIWEtCR2JMVHl2ZzA0YXVOY2dhYW1pblFCWUd3Qi80RERUaVp2dlQzNlhGQlIwQlNJanFYWEUxQ2VWSlNLaTdNSWM3ckpsSXViMkZqdFl4RDQ3cjFRYWtwNlNwa3M2cDFnV25acG9aa3k2Q2JHeEdtK2wrRWREU1pYS3R0RXkxV0tNYlVpblkrcnlLbk5mZDhqbFJJU3poTjBmdlhOaW8rV29IcVlvN3gxTjk0NkhFNUZDMEljQVdrYmNoRzNpeHJISGFqRnl6ZVNXNW5DYmNZYlZEaWhsVVJiYmVHeWRJWUtRUjMwaFFPa0pHMjhBR0lSdzRDT0kwZ2phQWs2Nndkb0k0UjYydENncXcxK2tGYmVFa2tIUzBjY2JTNndoaFBjdE91T2tpNWNJRmlvNjI2SGpZeFZhMEpwcGJ5dzRpVGtsSkhmVGFSZDFmOG5NY290Z25HWnh0d1RiYnpFcWx3bEswTEtWTEtScG1Kdm0xNERiNFJBMVNzMDlwbGJWVEJXMDc0QzBQR29wdnZ3MjNqRXhib3ZoV016eGp1M1I4L2YyeWxyZGVubVZ5ZEpsbE5TS1BFc1hBelcvTTZzNmVoTmhFUzRuSXNvQzBydCtaSnVQanhpenlMekZRS25xb3BLYUpMT3BSN0hMT2hrcUtyaEt6NFQ0UWJYVVJmV3cxaUxybExWSXI3eGhxWk1wM2kyZThjUjRDNGs2cFFvSHhqS1VtK20vcWRPRWtudEFTZFdSaUVsYXdsT3BKc0k3NXQyNlV0b3loS2ZEWVJ4eTF3ck1OeWJDRk9pemlsQ3dQVXhZU091a0RTKytnNHdQTDR3a0t1ZVd1dG9Wc2Q3d2FBRWk0dWJqaHhoeEJzb1dQV0dsOHhEako4WEhXT09PMXBObkVIZS9HUFZuMmJVZC8yY3piZGg0S2c1bDYzU2t4NVVaM1QwTWVxL3NzQlp3ZlZDUmRDYWhZZEQzYVlUa0RnelNBMEZ0T29WeGNJdDVpOGNiVFpiY1huc0xKc3E0djZ4TmxrQ1ltTXUxMHErc0tRd2t6Q1NRUUZlRTI4b1RHSXh5SzNPeVNKcGxRUXRTVkpHWWNSRkt4bzQ1UzZBNnBKSHRUL3dDRzFiZlVha2VRalVaNmdKV2xTbTFPRFFqTGZRbU1tN1NwdGdOc1N5VUlMN1F5b081R1llTDAwaG1QQjZqMm9DV1ZSVnN4Mm1KY2tIc2lIMU1MbUp4bGxMb1BpUWtYSzFENHhlOFUxbVdWWEpPa3NOcFRoRUlNbTZKUTVYWDBGUXpFSzB2Y2pZYm1LaXNwUlhXRkJvdW9sVXFXVUQ4eEkyK2dqZmNVWVlicVBaMlpLV1pRMDQzS29jWUFUN2ppVWhTYmVvaTdxOFhwL0xIN29SaHlidVdlUzhVVWxGTW5uR21IQzR3VkxMT2NXY1NnS0lBV25ncTF1a1FSNC9JeHQvYmRLbXAwRENXS2U2TFQwM0ttU20wa1dJZGIxRi9uR0pPcHlMSTVSVXh1MG1PWnlxSGVKMDk0UXdiYmlPaFJ5dTNISFdHNWhBU2N3MEI1UTFvR3hrSHFid0wvQUFnaEI3N1FzSUFPb3NZV0RwRFlPZ2hTVHJCSWdYeDBndmo2UXE5K3NHQVR0SEVKbTFTc2hJek00SFoxYjZrRUFKYUNoa1BRN0cyMmdJaU94VGc2a1ZDY0UwaW91eWdLQjRFU3VjcUF2WUVBZ2hYTFEzR3NTOUxwejdUQ1hKcWJzOHNuT2dBS0NkdGI3MzMrVVNFelU1TkVzRXkwdzJtN3FXM080YUM4b1ZwcUwrN2JNYmJYQTRtTUNHU1VaZksralJqZ2tzYjlUaS8xWmwwL2hkNlJrblhwV1Z0TnlqcGFtbTVncGNVbFdhMW13THBYcHFkT09seHJIQlJhcE5FVkZpZnE4M0xGY3Rab3FtRnBWM2lVNVcwMkFKSXlLVWkzaEFDdDlMSFVLblUyS1czbmVjUm5BN2xwR1Vya3pja0Z6TGtPWFlsUVZxT1JqTmNWVElxdE5rcDN2a3ZxWldxV3plMm9KeTNLaGxZUDRpUmMrOFNvY0w3QWFHS2J5Y1NYOXlwS0tqMFIxWmw2ZExUNlUweWFEN0tVRE5sekZJVUFBYktVQm1CTnpzTGJkWWpGV0pKdGZwQkk5eFI1bTBDK21zYUVWU29VMkpOMG5VYndhZU8vbENUOGVVRURZMmdpQnhYdW5qYUNhOTYzemhRdVlRM2NMMGlTQ1ZsNzVVZjZyYWphUFZ2MlhmQmdpb0d5dGFrclhoYnUweDVVbGgrRzMxSmoxdDltMWtOZG1xM3RQeEo5Ni9Pd0NSK2tLeWRrcm8xRmtkNDdOcUk0SkgxZzFJOTVOdGR3ZVJoeW1lT1htWFA0bkxlZ0ZvWW5YQTI0Q1RwNXdtS0piT1BFRlM3dVRVc3VCQktiM09nVHBxVEhuakVOUSs4YW0vTmhSVTBrNVd5ZExnY2ZVbUx6Mm1WbGJrNC9TV0ZlRXFDblNEc0NMNWYxTVFVMVJtNWZzNVRVVmdGNnBUeVdFNmU0MDNjbTNVcUh5alowZUpZMHB2ejBVYzg5MXhYZ2hPenFtZTE0cmtWT0l1WG5pcXl2NFFrbjlJOUxTa3FudVFoYWIyUW42Umh2WmF4bnhuVHlQeUpjV2Y4QTRIK3NlaEcwQkxxZ1JZWkVneFgrSVNySWt2WVpwbDhoblhiamh4dXJkbUZUYWwya0pka1VpY1pDVTIxUWJxdGJta21QRTg2Z0JZT2hDaHBIMGNxRXNpYWtYR0hCZEQ2Rk5LSE1LQkg2eDg4cTdKcWtweWFsRmdwWEx2TFpJUERLb2lLRVdXa1FMbXFRZDdHMEVEZEJCTnhhSEZnNVZEY2Evd0Q3REtDUmM2NkNMS0JZd3RPVldYcnZDZUVQT0M2UVJ2dERSSHBDNUttRXVVRlkrY0M5emVBT2tIMDFpRGdJTm9jQnZEWStFR0xIaGVKT05hWk5ScXp5UTluYmtzMTNDUEFrL3FxSitWcEVwSWxTMjI4N3RpTzlXYm5VNmdjaERNdE5aWE83ZDhEcVJxaEdaU2hibUxYaERsZnByRjJsdXVCU1RZb0RSSkI4dDQ4OVBmTGlLNE52QkhEQjc4a2s1ZjFaVGUwNzJuN3dacUNYWEVxV2hVc3ZLcys2YitIeUlLaDFpZ2cySjZScGVOWm1WcVZIZVRMOTkzaWJMVG5ZV2k5dXBGdWNab2tYTnZwR3JvMjNCSitDanJZeFdTNDlNWGZ3aE9tbXNGYzg0Q2pkVjRUeWk4VWhlWThONEpWOWVjQVFlL0NKN0lFb1VkaERtenNNblJVT3A5OFJ5OWlHVEVvRGxidnpKTWV5ZXgyWCs2T3kya0pjdUM5TEdZVmNmbVdvcUgxRWVPYWUwWDNHV2tlODRRMk9ZS2piOVk5eFV0Z0pSSnlUZWtwSnRObzg4b0NZQ1owZWkxMGhvdFUxcEt2ZUtibnpNVkRIOVhGSGxWT0hLVmcyUW0vdks0RCtzWEp4MU12SjNWYmJUU01DeHhWMTF1dk9xYktsc01xN3BwS2RjeDJ1UE02UXpSWVBWbnowTHo1Tml2eUl3YlNWNGp4S2ZibGxUS0Vyblp0Wk9wU05UOFNRSWxjVGp1T3pEQmN0WWhicGRtTGREY2o1TEVTMkdhUXJEakdOMVB1QXpNdFNFcGNJMlF0YUZLS1I1YUR6amg3VExNMDdCMGlCWlRGTFNvZ2ptRUQvQUxUR242bnFab3BkTHI5UDVLampzeHR2ditmNEVkamN1WE1WdnVFYU5TcXJYNmtDTjFDZngxZ2JsR2wvT01qN0ZHclRWV21EK1ZEVFlKNWxSTWE2MmJ6cXdUc0xSbWZFSGVkbHJUcjhOQnpBL0FCNUVINXg0bSswRFNtcWRqeXBsbEdSYnN3c3JIQTNBVWsrZGlSNlI3Y21CL2wxL0dQSnYycVpMTGl0TXlCbzR3MDVmbjd5VDlCQ2NIS2toa3VHanoycTk5ZFRmYU9hOXI2eDFMQkNqWStMZU9RN3E4NGFpUlNkUnJzZU1JVU40VUNldG9KWE1iUk1sd2N1eHV4QXVZQTZEZUhPTnQrY0lVbFFKTUxmQVNFbStrR1BPQmZTREJOdHhBOEU4bzlCVmZEemxIZGRtblpWcVlaY1VGaC9LVkpTU0RhOTl1UG1iUnpzTFNrbnVHa3RaamV5UDZ4cXJoWjluWExyUUZOcUJTVUhXNE85NHpLdFU5ZEdxUGRhK3l1a2xsWjRqK0U5UkdIbHh0S3piMGJqRjdVcVpHVmx0Y3hLUElXVmVKSkdwM3VJeFFJVTB0eEN0Q2dsSjh4cEc1UDNVa25oYlNNa3hYTENVcTh6YloxUVhiZ0w3eGErSHlxVGlCOFNoY1ZMMklXQUFZSUdGQS9EckdzakdDc1JDZ2VjS2dyZ2NvTklFUTREYlNGdER4SjFJRUlVVTJzRERqQnNvSGUyc0Q1T2ZSZU96aW5xcW1NNlBLcHNjMDBsUnZwb254SC9BT3NleUdaYXFJUm5sMHlpY3d6V0pWeGp6WDltcWxHZnh5SmhTYmlUbEhIZjl5aUVqNm1QVk5kcWN0UTZPL096aXJNc0kyRzZqc0VqcVRZUUV1WFJIUlRjYjR3bnBPaUxwOHpKc056enlNamJyVGx3RTdGUkIxSDlZaWV5RERwbjZpcXF6TFlNdEtMeU1KSS9hUDhBOFhra2ZNamxGUGt4UFl6eEt0YnB5dU9YY2RVblZMRFNlQThob09aTWVncVF6TDRkd3puUWhMY3ZKeXluTFgyc0NvMzY5WXU1ZjlOaDlHUDFTN0swZnhaNzMwalA1eDFVMWhmRzh3a2t1VlNyb3B6Ui9pQVVoSDBLb2crMTE5SzhidlM2UGNsWmRwaEk0QVdLdis2Sitoc0tWUmV6K25LSDQxUnFLNnM4Q1B5b3pPWFB4VEZCeG5QKzNZdXJMN1JLKzhtMW9iQ2RTcktjZ3Q4SXNhWmZpdCtGZjdMOWhlWi9JbDkrL3dDNXAzWWxLM29kU21sRDlwTnBRazg4b0g2bU5IWTBtbHExMUkrY1UraktsY0RZR3BiTlNLaSt0V1pUYllCVTQ2cTZpQnJiVG4wamptc2Z1cHpHV3BpRUtWYXhlZUp0Ym9CK3NZT3MxZU5acE9UTlhUYVBMa3hyWWpRMzlXWExjb3duN1FOREZVZUFXMkNWMGFheUtJOTExcXpxZmtGRDFoMnRZaG5hbTYyOVVaNEFKQktFb09SQ2ZJQTc5VGVPUjJvZmVUS1V6VDAzTnRKYlcyTTRXNE1xMDVWVzVBZ2tlc1U4ZnhLRUpPNHVpOC9oR1NVVTl5czhqdW96V1VBZFJlT0ZWZ1RmZVBVY3ZnM0E3NENIYVBLdDY1YkZiamFoL3dCVjR5SHRvd3RROE0xeVRUaDJaVXRtWmFMampDbk01WklOaHFkYkhnRHlNVzlQclk1bnRTb1ZxTkJQRERlMm1qT000Qk84SG1CNFdoZVVGTU5FWlRydzR4ZGRvb2NCZzN1QnREbHVWNFpHbTBMU3ZhOEFuWkxUQXBQS0ViYVh0NlErbnhDNCtNV2loNEN4RFc2ZWlla1pFR1djSnlLY1dFWmdPSUI0ZFlHYzR3NWs2SmhHVTNVVlo2TDlwZGwzME12cUtrdUhLMjZCWXFWL0Fya2VSR2g2R0lySHJpRTBVdEZGMXAvRUtpQ1NramtlR2tUUmxmYVdIdmFVNVM0TXFDRldGN2l4SElnZ0gwaXVWMWFwMmtJVE1XRXk2bGFIVWhadUYySUl2dHY5UkZYSkJVMGl6REkxSk1xMGk2bDlxMXdRWXpUdENJVFh1N0JKeXRwdnB6aTY0VmNMa3ZkVnlVNkdLTGo1eEs4VVRTVWFoQ1VJSnZmVUFYK3NWdEhHc3pYOURRMTByd29yd0Z5UDFneXEwSjIyM2dzdk84YTVpaGttQUU2M0pNRjBGdldGWmRRRkUzTzBjaUdCWUFUcEMydFZBQ0FXVlc4QkJIVTJnaytBMkkxNndWY2tlRDA1OWxWaHRxUnJ0UWRLVUp6TnM1MVdBQ1VncVZyNmlPL3RIeGE1aWlxc3lsT0MxVTVoekt3aEkxbUhEcG50OGtqckdXWU94S3FUd0sxUlpGU2tHWW1ISDUxZHJaaGNCRGQrVmszSjhoempXK3ptbXBwVWd4aU9lWkQ5UW1sZHhSNVJXaGNjVVAyaEhLMXpmZ2tFN2tSY3dZbzQxNnN1WDRSVXl6Y3BiRjE1TkR3YmhodkQxRFZMUGhKcUwrVmMycEp2WS9sYkI1SnZyekp2SFgyblRqaU1CVE1teVFINTliY2tnQTZxTGl3UHBlSWtZeXcvSVBKazZoWDZlSDBIOFJTMzA1bHIvTW8yMnVkaHlFWmgyaWRxOU9ucHFSKzVIblhWeUw2bnc5a0FRWEFMSnRmY0oxTjdibUs4YWxsM3pZeHhhaHRpaTlZcXhWTDRaeDhYRXNsOFVpbHBrSk5zSEtrT3JzVktKNUJJQTBpcTRHWWJaVW5FTlVKVEp0dWxUUU9wZFZxU2V1dWdqTUtKV2Z2L0FCUXcxVW5IRm9mVXBUaTh4VTQ0UUNjb1BOVzErRWFoVVhYWjFoaStSdHB0SlMweTJQQTJCcFllbHRkNFRyTmZqMDBObVBsc3Q2UFFUenkzVDZSMFlreEhPNGhxTGMzTTNTMDFwTHl5RGNOSjQrYWpwYzlPVU9ybWdxWHpsU3VRdGJVeFh1N1huVUdnU3Uxc3dPZ0hJUjMwaDFMSUxiK1VwVnRjOWRiUjViSTNrZTZSNmZFbGpXMktFR29zc3ZabTJXMHFKdVZLQUNvY0dLS2JJZ0xuSjBJYzN5cDhSNitYckhaTWV4cmJVM015aUZvVnNoZGlUOHJ4eXR5ZEdTck1pa3lnSk4xWm13cy9POFF0dmxETGt1aDMvR0ZFbW1yR1liY0Z2M2lRcTBWbnRFb3VGcWhncXIxQVM4dEx6N0tBdVhtMlVoQld2UUJCdDcxOXJIOUlzc3pTcUpQclMvTVU2V1M2MlIrTTIyR3ovd0JJRng1eFRlMWVqeWpHQkhabVVjN3NzVGpSVWc2OTRDQ0FBZVl2ZnlFV05NbDZzZHJvcjZqbkZMY3I0TUVjWktWMktoQ1BFTi9FT1VkYjJWV2gxQjJ0SE9kRFk2OGpIcGRwNWhzWk9scmJRSVVzYVhoRUltdHJHTGxFN2d1UmxxaGlHV2FuNyt4by9FZEEvTUJ3OVRhUFJjdFhaZnVFQnN0QkFGa2hKc0FCc0xjSTh2U1U0OUpUQWVsMTVWajRFY2pGdmxzWlM1YUh0TXM4bDNpR2xETDZSbjZ2QkxMSk5jbzA5RG54NG90UGhucEowSmNVdElTRkl5MlVNdlRnZUJIT0tyWFpoYUpsaHA5MHFXU1ZwWG1BTGdCRndlbytZMWl6UFREV2RURXVDK3RJL0VLZkVsSTZuYThWZkVLQzYyMkZadkJaWXkyQkJHeCtIMWkzT0M3S0ZsUm9zbTNJZTFzamRMeTFhNldCTndQbkdUWWtkTDFkbjNGQ3hMeXRMVzJOdjBqVW0zRi9lRlFTb2hLZzVmUVdCRnVYQ01ucnR4V0p6TWJrdXFKUG1ZcmFSVmtreTdySCtGRTRMbUR0YzZ3UXNiUXEra2FLUm1CZzVmT0ZJOTdYZUd4cHFkL09GZzJTVHhNRWlCU1QzcnVVSEttSHBWSUN4blRkVzJvam5iTmlEdnJIV0ZnbTRBdWVQV0RYSUw0SkZwNVRSVGtVVWpiUXhaWi9HZGZxUlpYTzFXYmNXd3lXR3lGWk1yWjNBeWdialF4VUFvbXdQQThvNm03RUFDOERKczVNNlMrUU5OUFNFSldWRlZ3VFkvbE1JQ2IydmU1NHdwSUFLaHJ3OTB3c003S1pNcmtwNWlaUlpDbW5FdVgzT2h2SG9FSzcxVmdMcEtRVWttd1hjWEFJOHIvOEVlZG0wZ25SRndlS28zTEROVkUxaG1sT2dxNzFES1czVlpicEJUcGM4eHByME1aZnhHRnFNa2F2dzZkWEU2M0VMTm1sTERSTnlrRVh2YlUyOVBsSExMTFJMTGIvQU0wb2VJcXpBREtMbnJIVk1NckxwS2NpeUNSbnpKdWpwYmVFdXRvV0xUYTFrYUFacko0Y2hyOHpHY28rRFJjNjVaS1B2eTAyd29UVGFIVzdBS3Vra0V4RHpGR3c4ODJFSllTMDJBVGxTOHRBSG9ERGlsRmxTUlQ1Tnh0VmorS0RZbjA0K3NWcXNWNWNoNEtnL1UzRjVpRmhtWENNbm1TYkgwaHNjRS9BdVdweCtXVEF3cFFWS1E4bCtkUXNXT2NUcXdFcHZxYms2QzNPTVl4bldGVkNzVGpFdFBURXhTSmQ0b2xVcWNKU1VwMDd5M002NnhNWTFyNmFyTHBrYWVxYk1vRG5jY21GMlc2ZUF5M05rajVtS1E1b253NldNYW1qMDhvdmZQc3pOWnFsSmJJZERTNzczdjFocFE2YndxK3B0c2RvU2RocEdrWmdnNmkxdFliaGF6ZmJlRUNFNU9Sc1FRSUFnUUZCSHNsaW5xWVpTdzhvS3pBcUNrN0U4VTI2Y09uckhCVXBOQ1dsb3NBU2s2NVIrc1NzL1BKVzBwcGhKVThMRVppYnRuZ2JBSDRSV3FxN09UTENsRnhMSzdsS2t0dDJzb2NMcU45ZjZSMG1xcEEwL0pRWitWTGM1UGQwbGFsS3N2d0pKSnNMZnBHUTF6S2FyTUZCdWxTcmd4b21JcTgvaHFyb1FHdStROHhiTWREbUJQSFk3OEl6bXB6SzUrY2VtMUlDTTZ0UU5oRmJCQnhtMittWHMrU004TVlydEhGQmp6MWdRT084WExLRkF2emhlcEF2OFliNDdRc2JXSnRCUlpBcEhLOE9KTnRmaERhVHI1d3JmYURUQloxSU55TDZrNngyc3IwRnJnYmtFUndOa1dUdnpqclJmUzJ0dEk2UjBUcExsaUFRSURhaVh0N1podmFFSkYvNm1ITWxsSkpUZnB3TUtZWThnNjZxSk1hMzJQVTJhclVvK3hMT05vYmxYUEdGSnViTEducGNHTW9hYVVTTEl0ZmJtWTNEN09sTXE4dGlhWmRlcDc2S1c5TFpYWFhVRkFDZ1FVWmI2cU43alRuZUZ5aEdmRWxhQ1U1WStZdW1hRkpZSFVwZDVwM05iUUpTa0RTSkVZTWFTK0FqTHB1YmNZMEJFdWxMaU5OYjJQd2g1VXVETUt0dngrQWprc2NlSXhGeXk1SmN5WlNGNFNTbEl0WXFBS3ZoSExVc0Z5ODZsUlcwbFdkS2dBUnhBQkVhTXRvQnovYXJoMGh0cG9KbEVLQXVVTEN2VFFRZTlld3Q3bXV6emZqM3NkVE5NKzFVT3pNNFcxTDdxM2hkS1JlM1FrUjV2bkdpUm1OejU3anBIMFBucFZOZ2hKQ1ZKZEtXMWNpUWN2enRIbEg3UldDMktMVkpXdjBwc05TTldVcnZtZGd4TUFYVUIwVnFmTUdEdVBhUkVXN3BtSEszTzBJVWROcngwVGpMckFTWFFtNnRyR09UZmpyRVBJcTRIcURUcGdKZ3ZTQUw4SUVMNzVDQkIrY0Z4TUNPSlI3TGxGb1RMTEFDQXBBVXBDcmE2ZWU4Ujh5VktjRGlYRXFRNk1xa2xBSGlBOE8zdytFS0sxeXpEcS9DQXRCUUNTYmtuK2dIemlQbUhjcU1xdGIrSFdCY2ZGQXBtWmRzbEtRbVdwODAzTDJMYmhTNDdtTmxaZ05BTnRDUFBXS0JUNUJoNm5WRnhheUVoR25HeWhyZjlJMnF1ekVuTnlMclZWU0hKY05udldVcXNWQ3gxdndzUURjYXhpODNOcGs4UE15N05zNzl5U0J1T2NJdVgwb3VhZFJxVXBlRi9CWEJyckF2dndnUUx4YXNxVUFia2NJQU9zQVdnZW5wRXBrVUxHOExUcUlhU1FOVGMyaTgwM0FFL01NTU92T2hIZkpDa3BTMlNTQ05JUGZHUGJCYWI2S2sya213NDJqdlpiVVJxUGpHaFNIWmk2cHdCYnIyVytwS1FJMFREblpOSnQ1WEhtUzUvd0M2Ymo0UkcvZDlLQitudG1KVXFqVGxTY1NpU2xYSDFmeURRZVoyalVzSWRqODVVTzdYVWxoQ1QrN2IySG1yK2tiVFJjTHlNZ3loQ1drNmFBSkZoRmxwN2FtU3BPVkFhQkdRSkJDaHp2NjhvN2JYMUVQSi93QVNvNFM3TUtOUmxoYUdrbDVPN2hHWlo5VCtrWCtsVTVtVlJkcEd0K090b2RTZ0pVRkMydnpqclpVQjRZWEtYRkloVyt6b1VtejdZNTNNUEpBOXJXT0ZoOUk1blYzbVdDRHJlMTRlYlVUUE84Z0FQbENXd3hheGRZdndTWVMybi9LcVQwL1NEV2ROTlNRUkNXVkR1ckhpRDlJaXpxT0dvcFNwSldSb1VvVWZSUXZHUy9hTXBZbWV6bXJrcDhjbTgxTko2QXJzVDgxeHEwOFQ3RWJuVU5LSHdGLzBpQ3h4VEdhNUp6Vk9mL1kxR1NkbGxjZ1Q0a24wSWl4QjhVTGZaNEJxQ3MwcmxPN1pGanh0RVdlY1RGYmxIcEdibVpTWlJrZllXcGx4UEpTVFkvTVJEeHpWY2xoU2NseUNEZ29CMmdiSkJBdkE0OG9PSk9QVmsxTktWTnN0a0hJMmtyU0w3SFdPT2VYWktsY2gvZUJBaVUzeUMxMFV1dE9xYmw1OVNRbXlKVnl5YkMzN05YOVl4ZDlTbExDU29sS0JaSUoyRUNCQzJIRDZSb2pyQXQ4NEVDT2ZaQUFJTUNCQWdvOUhCb0hpQVBsSHF6czFLSnpBK0huNWhHWnd5Z1FUZmZJU2tmSklnUUlzUjZzVGtMZUN5Z3JDV2R0dGY3UkxVcW9qdXNwYUp5bXc4WDlvRUNJbEowUW9wa2ttcG9HWlBjSFk2OTUvYUhCVjBsb3I5bk9ZZnovMmdRSXJTbTdHS0NvZSsvN0lCOW5ObGJqdlA3UTZjUWdoS2hLa0c0L2Uvd0JvRUNBYkMyb0RlSlI3WUZHVVBnMEE3My94aFp4UUc1aHhYc1pKTmgrMTZmNllFQ0FiQ1VVSy93QVVncTFrenNmM3YvakNWNG9EYVVqMk1tNFA3M3AvcGdRSTZ6dGlJNmN4VUN5VWV4Ym9WKys2Vy9oam1xZUowdk9TdDVLd1NiZnRkeHNlRUNCQnhrd1hDSjVPN2Z3dzMyalRiMHV6M1FuSmRtWldrSFFMS2JLUHJsdjZ4bWxyd0lFT2svbFJFVlFWb0FnUUlBTU13QkFnUjFzNC85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL01UZXJlc2EuanBnXG4gKiogbW9kdWxlIGlkID0gMjk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvL2dCWlJtbHNaU0J6YjNWeVkyVTZJR2gwZEhBNkx5OWpiMjF0YjI1ekxuZHBhMmx0WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2tkdlpHWnlaWGxMYm1Wc2JHVnlMVWx6WVdGalRtVjNkRzl1TFRFMk9Ea3VhbkJuLytJTVdFbERRMTlRVWs5R1NVeEZBQUVCQUFBTVNFeHBibThDRUFBQWJXNTBjbEpIUWlCWVdWb2dCODRBQWdBSkFBWUFNUUFBWVdOemNFMVRSbFFBQUFBQVNVVkRJSE5TUjBJQUFBQUFBQUFBQUFBQUFBQUFBUGJXQUFFQUFBQUEweTFJVUNBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVJZM0J5ZEFBQUFWQUFBQUF6WkdWell3QUFBWVFBQUFCc2QzUndkQUFBQWZBQUFBQVVZbXR3ZEFBQUFnUUFBQUFVY2xoWldnQUFBaGdBQUFBVVoxaFpXZ0FBQWl3QUFBQVVZbGhaV2dBQUFrQUFBQUFVWkcxdVpBQUFBbFFBQUFCd1pHMWtaQUFBQXNRQUFBQ0lkblZsWkFBQUEwd0FBQUNHZG1sbGR3QUFBOVFBQUFBa2JIVnRhUUFBQS9nQUFBQVViV1ZoY3dBQUJBd0FBQUFrZEdWamFBQUFCREFBQUFBTWNsUlNRd0FBQkR3QUFBZ01aMVJTUXdBQUJEd0FBQWdNWWxSU1F3QUFCRHdBQUFnTWRHVjRkQUFBQUFCRGIzQjVjbWxuYUhRZ0tHTXBJREU1T1RnZ1NHVjNiR1YwZEMxUVlXTnJZWEprSUVOdmJYQmhibmtBQUdSbGMyTUFBQUFBQUFBQUVuTlNSMElnU1VWRE5qRTVOall0TWk0eEFBQUFBQUFBQUFBQUFBQVNjMUpIUWlCSlJVTTJNVGsyTmkweUxqRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZoWldpQUFBQUFBQUFEelVRQUJBQUFBQVJiTVdGbGFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQllXVm9nQUFBQUFBQUFiNklBQURqMUFBQURrRmhaV2lBQUFBQUFBQUJpbVFBQXQ0VUFBQmphV0ZsYUlBQUFBQUFBQUNTZ0FBQVBoQUFBdHM5a1pYTmpBQUFBQUFBQUFCWkpSVU1nYUhSMGNEb3ZMM2QzZHk1cFpXTXVZMmdBQUFBQUFBQUFBQUFBQUJaSlJVTWdhSFIwY0RvdkwzZDNkeTVwWldNdVkyZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaR1Z6WXdBQUFBQUFBQUF1U1VWRElEWXhPVFkyTFRJdU1TQkVaV1poZFd4MElGSkhRaUJqYjJ4dmRYSWdjM0JoWTJVZ0xTQnpVa2RDQUFBQUFBQUFBQUFBQUFBdVNVVkRJRFl4T1RZMkxUSXVNU0JFWldaaGRXeDBJRkpIUWlCamIyeHZkWElnYzNCaFkyVWdMU0J6VWtkQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR1JsYzJNQUFBQUFBQUFBTEZKbFptVnlaVzVqWlNCV2FXVjNhVzVuSUVOdmJtUnBkR2x2YmlCcGJpQkpSVU0yTVRrMk5pMHlMakVBQUFBQUFBQUFBQUFBQUN4U1pXWmxjbVZ1WTJVZ1ZtbGxkMmx1WnlCRGIyNWthWFJwYjI0Z2FXNGdTVVZETmpFNU5qWXRNaTR4QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIyYVdWM0FBQUFBQUFUcFA0QUZGOHVBQkRQRkFBRDdjd0FCQk1MQUFOY25nQUFBQUZZV1ZvZ0FBQUFBQUJNQ1ZZQVVBQUFBRmNmNTIxbFlYTUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBS1BBQUFBQW5OcFp5QUFBQUFBUTFKVUlHTjFjbllBQUFBQUFBQUVBQUFBQUFVQUNnQVBBQlFBR1FBZUFDTUFLQUF0QURJQU53QTdBRUFBUlFCS0FFOEFWQUJaQUY0QVl3Qm9BRzBBY2dCM0FId0FnUUNHQUlzQWtBQ1ZBSm9BbndDa0FLa0FyZ0N5QUxjQXZBREJBTVlBeXdEUUFOVUEyd0RnQU9VQTZ3RHdBUFlBK3dFQkFRY0JEUUVUQVJrQkh3RWxBU3NCTWdFNEFUNEJSUUZNQVZJQldRRmdBV2NCYmdGMUFYd0Jnd0dMQVpJQm1nR2hBYWtCc1FHNUFjRUJ5UUhSQWRrQjRRSHBBZklCK2dJREFnd0NGQUlkQWlZQ0x3STRBa0VDU3dKVUFsMENad0p4QW5vQ2hBS09BcGdDb2dLc0FyWUN3UUxMQXRVQzRBTHJBdlVEQUFNTEF4WURJUU10QXpnRFF3TlBBMW9EWmdOeUEzNERpZ09XQTZJRHJnTzZBOGNEMHdQZ0Erd0QrUVFHQkJNRUlBUXRCRHNFU0FSVkJHTUVjUVIrQkl3RW1nU29CTFlFeEFUVEJPRUU4QVQrQlEwRkhBVXJCVG9GU1FWWUJXY0Zkd1dHQlpZRnBnVzFCY1VGMVFYbEJmWUdCZ1lXQmljR053WklCbGtHYWdaN0Jvd0duUWF2QnNBRzBRYmpCdlVIQndjWkJ5c0hQUWRQQjJFSGRBZUdCNWtIckFlL0I5SUg1UWY0Q0FzSUh3Z3lDRVlJV2dodUNJSUlsZ2lxQ0w0STBnam5DUHNKRUFrbENUb0pUd2xrQ1hrSmp3bWtDYm9KendubENmc0tFUW9uQ2owS1ZBcHFDb0VLbUFxdUNzVUszQXJ6Q3dzTElnczVDMUVMYVF1QUM1Z0xzQXZJQytFTCtRd1NEQ29NUXd4Y0RIVU1qZ3luRE1BTTJRenpEUTBOSmcxQURWb05kQTJPRGFrTnd3M2VEZmdPRXc0dURra09aQTUvRHBzT3RnN1NEdTRQQ1E4bEQwRVBYZzk2RDVZUHN3L1BEK3dRQ1JBbUVFTVFZUkIrRUpzUXVSRFhFUFVSRXhFeEVVOFJiUkdNRWFvUnlSSG9FZ2NTSmhKRkVtUVNoQktqRXNNUzR4TURFeU1UUXhOakU0TVRwQlBGRStVVUJoUW5GRWtVYWhTTEZLMFV6aFR3RlJJVk5CVldGWGdWbXhXOUZlQVdBeFltRmtrV2JCYVBGcklXMWhiNkZ4MFhRUmRsRjRrWHJoZlNGL2NZR3hoQUdHVVlpaGl2R05VWStoa2dHVVVaYXhtUkdiY1ozUm9FR2lvYVVScDNHcDRheFJyc0d4UWJPeHRqRzRvYnNodmFIQUljS2h4U0hIc2NveHpNSFBVZEhoMUhIWEFkbVIzREhld2VGaDVBSG1vZWxCNitIdWtmRXg4K0gya2ZsQisvSCtvZ0ZTQkJJR3dnbUNERUlQQWhIQ0ZJSVhVaG9TSE9JZnNpSnlKVklvSWlyeUxkSXdvak9DTm1JNVFqd2lQd0pCOGtUU1I4SktzazJpVUpKVGdsYUNXWEpjY2w5eVluSmxjbWh5YTNKdWduR0NkSkozb25xeWZjS0Ewb1B5aHhLS0lvMUNrR0tUZ3BheW1kS2RBcUFpbzFLbWdxbXlyUEt3SXJOaXRwSzUwcjBTd0ZMRGtzYml5aUxOY3REQzFCTFhZdHF5M2hMaFl1VEM2Q0xyY3U3aThrTDFvdmtTL0hMLzR3TlRCc01LUXcyekVTTVVveGdqRzZNZkl5S2pKak1wc3kxRE1OTTBZemZ6TzRNL0UwS3pSbE5KNDAyRFVUTlUwMWh6WENOZjAyTnpaeU5xNDI2VGNrTjJBM25EZlhPQlE0VURpTU9NZzVCVGxDT1g4NXZEbjVPalk2ZERxeU91ODdMVHRyTzZvNzZEd25QR1U4cER6alBTSTlZVDJoUGVBK0lENWdQcUErNEQ4aFAyRS9vai9pUUNOQVpFQ21RT2RCS1VGcVFheEI3a0l3UW5KQ3RVTDNRenBEZlVQQVJBTkVSMFNLUk01RkVrVlZSWnBGM2tZaVJtZEdxMGJ3UnpWSGUwZkFTQVZJUzBpUlNOZEpIVWxqU2FsSjhFbzNTbjFLeEVzTVMxTkxta3ZpVENwTWNreTZUUUpOU2syVFRkeE9KVTV1VHJkUEFFOUpUNU5QM1ZBblVIRlF1MUVHVVZCUm0xSG1VakZTZkZMSFV4TlRYMU9xVS9aVVFsU1BWTnRWS0ZWMVZjSldEMVpjVnFsVzkxZEVWNUpYNEZndldIMVl5MWthV1dsWnVGb0hXbFphcGxyMVcwVmJsVnZsWERWY2hseldYU2RkZUYzSlhocGViRjY5WHc5ZllWK3pZQVZnVjJDcVlQeGhUMkdpWWZWaVNXS2NZdkJqUTJPWFkrdGtRR1NVWk9sbFBXV1NaZWRtUFdhU1p1aG5QV2VUWitsb1AyaVdhT3hwUTJtYWFmRnFTR3FmYXZkclQydW5hLzlzVjJ5dmJRaHRZRzI1YmhKdWEyN0VieDV2ZUcvUmNDdHdobkRnY1RweGxYSHdja3R5cG5NQmMxMXp1SFFVZEhCMHpIVW9kWVYxNFhZK2RwdDIrSGRXZDdONEVYaHVlTXg1S25tSmVlZDZSbnFsZXdSN1kzdkNmQ0Y4Z1h6aGZVRjlvWDRCZm1KK3duOGpmNFIvNVlCSGdLaUJDb0ZyZ2MyQ01JS1NndlNEVjRPNmhCMkVnSVRqaFVlRnE0WU9obktHMTRjN2g1K0lCSWhwaU02Sk00bVppZjZLWklyS2l6Q0xsb3Y4akdPTXlvMHhqWmlOLzQ1bWpzNlBObytla0FhUWJwRFdrVCtScUpJUmtucVM0NU5OazdhVUlKU0tsUFNWWDVYSmxqU1duNWNLbDNXWDRKaE1tTGlaSkptUW1meWFhSnJWbTBLYnI1d2NuSW1jOTUxa25kS2VRSjZ1bngyZmk1LzZvR21nMktGSG9iYWlKcUtXb3dhamRxUG1wRmFreDZVNHBhbW1HcWFMcHYybmJxZmdxRktveEtrM3FhbXFIS3FQcXdLcmRhdnByRnlzMEsxRXJiaXVMYTZocnhhdmk3QUFzSFd3NnJGZ3NkYXlTN0xDc3ppenJyUWx0SnkxRTdXS3RnRzJlYmJ3dDJpMzRMaFp1Tkc1U3JuQ3VqdTZ0YnN1dTZlOElieWJ2Ulc5ajc0S3ZvUysvNzk2di9YQWNNRHN3V2ZCNDhKZnd0dkRXTVBVeEZIRXpzVkx4Y2pHUnNiRHgwSEh2OGc5eUx6Sk9zbTV5ampLdDhzMnk3Yk1OY3kxelRYTnRjNDJ6cmJQTjgrNDBEblF1dEU4MGI3U1A5TEIwMFRUeHRSSjFNdlZUdFhSMWxYVzJOZGMxK0RZWk5qbzJXelo4ZHAyMnZ2YmdOd0YzSXJkRU4yVzNoemVvdDhwMzYvZ051Qzk0VVRoek9KVDR0dmpZK1ByNUhQay9PV0U1ZzNtbHVjZjU2bm9NdWk4NlVicDBPcGI2dVhyY092NzdJYnRFZTJjN2lqdXRPOUE3OHp3V1BEbDhYTHgvL0tNOHhuenAvUTA5TUwxVVBYZTltMzIrL2VLK0JuNHFQazQrY2Y2Vi9ybiszZjhCL3lZL1NuOXV2NUwvdHovYmYvLy85c0FRd0FHQkFVR0JRUUdCZ1VHQndjR0NBb1FDZ29KQ1FvVURnOE1FQmNVR0JnWEZCWVdHaDBsSHhvYkl4d1dGaUFzSUNNbUp5a3FLUmtmTFRBdEtEQWxLQ2tvLzlzQVF3RUhCd2NLQ0FvVENnb1RLQm9XR2lnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ28vOEFBRVFnQkxnRGNBd0VSQUFJUkFRTVJBZi9FQUJ3QUFBSURBUUVCQVFBQUFBQUFBQUFBQUFRRkFnTUdCd0VBQ1AvRUFFRVFBQUlCQWdRREJ3SUZCQUVEQXdJSEFBRUNFUU1oQUFRU01RVkJVUVlUSW1GeGdaR2g4QlFqTXJIQlF0SGg4VklIRldJa2NvSXpvaFlsUTBTUzB1TC94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFCQWdNQUJBVUcvOFFBTFJFQUFnSUNBZ0lDQWdJQkF3VUJBQUFBQUFFQ0VRTWhFakVFUVNKUkV6SkNZWEVqa2JFRkZJR2gwZkQvMmdBTUF3RUFBaEVERVFBL0FPRjVpalVHWWhRek1hcmVMZVFTVDV4NitlRkc0SHRLN2lBQUtaSkdtQUJ6NThvZ1lBRDZxd0JFTVRVS256QXZFa2pjZExkY1l4UTZFVkdBWTZOVW5WejZiZW1NWUl5NmxrQU05NFRDd1ltOHovazRKajJwU1JGcEN1NkhVcElONE45TVc4NytaR01ZcVR1eUNFWjBMV003ZW84dDhZeGU2cFdlRWNHREFXb1lBdmY3K2tZdzBPeXVxbEtvV0pxSFNvTVNvSW4xOWVmTEdMeTZJMUtacHVEY2drK0hja2pkZXZNNHhNdTNhbnExQWhJTUMvcDYvd0FqR01WVmFOT29OV2xRQ1NGSjlSODdqQWVrRFQweXhNcFVjeWxJTXNYazdqenZmMXhMbVBHRFg2RjFISlpnSlZLb3pBcW9KQ1N1L1A0R0tYRXFzYytBUlE0ZG1haXMxTUZiRWkwVzVpZjVHSjNBbkRFU3pmQ3N4U2dzV0pCMURTZHhzUDNJdzBad2JvZVVaTG9XZHlwZ1ZHbVFUQ0F5THdJUHppbkxqcEFqcFV5ekxVZ2xSVHBTb29JSU84U2VVOGpleDVnWTEzc1pNcmFXSWxVMU55YllIOWp2Z28xRXF5QUswQldGb0pxRVFPbzl5YitmbmdrcGtHUkJYZ3ZZTUFEOWJSdUw0S0ZMMTEyRlFhRk1xSENqWURsN0g5OFpqUjdKclZZVlgxalVDQXBNL3AyOTdiWUZYb2FYUlVsWHZBUlVPb2FUb0traUR5K3B4dUZiSmx0Tnl0Q1JKYlZQcUpKdVRhTnZwaWI3TVdtUVhkSDd6VnZhSThyM3RoakZRWWhwT3BiYXZFSXRhOEgzK01Za2ZaZWpxVHhVVll5UmVvaXg4bS9yakZRWE0xME5lc05JUDVwMUtKL1ZQUHpzRGpFdVpaM2xPbTRmeFZEVUhoSFVubFBwRStVNHczSkZCYzFhaStJcXk2VllpdzNCTS8zNVJqRzVJc0g2aVdWZ1NicXRPQWJreVo5b3hnTjJ5T3BkVUJtUlZBTFNadEhtZkw3NTRLbFJCYWFWRlZkZXN5WldDWmc3RG5OeHRqQWJzc3kxTXZSTlF5UUpZN0hWRi9pMk1Ba0tyWFlMcVhiWWcyNS9NRTRCanlpemF0SUtoakYra3lKK1o5Y1lOc2hVSi9SWURWc3c5QjlOdm5CTkhza3dPbGtieElZaFEwU2RvTWY3d0gwUGRiUEZwMW5WRnAweGVTUE1rQ0RmOXZLK0ovRmV4NHhsUDBiSGdOR2p3OGlsbmFDR3E2TWdNekRIL2p5TzhUYzd4eXh5NWFsMHpvaEdVUFJxTXJ4UkJsM0ZmaDYxTzhVa29YOEN4c0NQSUF5ZlhIUE9ITHAvK3pxZzVSN0ErT3BUejJZcVZlSHJTRHNBcjB4cHBVeEJnUnVaaTl4YzRiRGFXeU9UY3RDS3JUek9YQU5jZDRvOGZpWUVmSG5qcGhKQ1NGbFpRMUdmMEZWMU5ZRXhzWWovQU9VOHNXVXRpUG9URlNhdDJwd29CVXliV0oyR0twMkt1aXhOQlk2VzBEb3Q0NWs5ZDR3Ym96VFo2c0IzcG5XcnJ5SUZwaUczOWNhN01sWFpHc2loRDNaTHNRSHNEc1oySHZob2dsR3dkU1pxbFNZM0FPd3RhZnI4a1lkQWhHbVMxa21RQU83WWtTU0lIWDl2bkFZekw2Q3BvQkxyTnd3QTNrenYxODhLTExvblVScC9MWVFDTEUyTWJmdisyTVRMcVZlb1FOUjBFc2JxQVNJNWZmVENHSzFxaEhZTnFZdXZLYlduKzJDWStwbW1nSUVnRXpCVVd4aGxHdENYTlA4QW01bFdVR0tyQW55a3gwNUdQOVlham1wRSs4YW9uampXSlZqQnVKMkh6NXpPQUdqeXJWSWhsSUFWdFZqRzUybjJNRDF3REJCOGRJRUc0bG1tcHFFOHdiQTlENUhHTVZNU2FMU0piK2dFbVlQSWlQTGIxNll3UzltVW9VRlJYTVJkdDduYVBUR01mVWFpRUJucGxnZkV4RnB0ZmIwK250akdDS1ZkVFRVVWxKYlNZS043OUxZREdpUmJ3ZUVDNUg5WDdBYmY0dDZyMzdHcEgyWG9WY3k2MHFTNjNaZ2ZDbDc4djMreGhYSlI3WThjYmJ0SFJ1eW4vVGRzOWxxTmJNMVdaM0N1QURwV0lOeWVmK2VXT0x5UE9TMUU3c2ZpeGt0bW5mc1p3WElFaXZTSmNSYzBTUU9VemVQODQ0MzVFcGRNc3NheDlJK2ZLNVRJSXowYUwwZzRVTlZaQ0tqaWYwSlA2UmU1OHg3R001U0RQb1UxcTFYTlVxaTBjdFNwMFE3TzRZclNwaEwyTEVqa0RKdk05WXhXTVdMS1FtcjhSeWxVRjZ5MWtRdE5OaWhBSjVpUkVkZDhVVUwwbWM4cHBiU0V1Zk5HbitmbHExV25UQmtNVEpqclByYkY0UnBVSkozdXdDaldOWE9hYXFkOVNBQkJVTUdNY2gvNUczVVd3NzFzV0liVDRJWHBxOURKNWp1cDFNVkFZamNUeW13eGxsSDRyMFFvOFBSSEQwbEpXbExNYWlhU0lIbjc0cHp0bTRnVmVtOUlNakxScGtuVnBNVzllbUdiMnFGa3FCN280WTZQQnZLelBMZmtQakZFMkl1d2NOM1FIZUNXVmlUL0FCL0h6Z3BzTFBKcHZWcU1Bd1VrL3FFZ2NnUUNPVTNIcmc5azVQUktpVlZmeXd4YUNRUUpBazhzRVZOdDB5UnJJMWVXcUtyQWxpUXU0aXh0OTdZREhTWDBFVVJycElyeUNGdnA1YjI5TGpDalVxNktpTlg2bExCUkFnQVJhZjhBV01SUGFTcnB2WVQ0ZlRHRzVQMkljMUlyVlNKSjcxcGsvd0JPb3p0YzdlM3ZnMmM1RlJWRTZnRk1FOGdUQXRKNWI0QmdsR1JrVXNBd21WWXJadWMrd0pNZWZuZ21QVnI5NG9wZ016ZFpFQzhmejB4akZsSjFZQU8vNVlKdFBJZnE4NXZmbGdNSzdKVXdIMkFBQktzSUZyOCtsenZnQmFvOE5IVUNGL3BKL3BIei9HTXpCT1JINm5XQklraU4rUVBUQ1N2Vk1hS3V4bHczZ2ViNHBYVk12U3JWRmFBU0xLSnZjOHB3bWJOQ0NPakhnYzRuWk93SC9UcHNqVW9admk5Y1JLTXFNZEltNTUrWHpqeHMzbWVranZ4NDFCV2RIeTlISTVITHJsOG85UXRvQ29xQXdJQnVZdGZuamovYmFLV0pPS0ptYzByMXE3MU12VHBoZEswMEpVV01HQnVkK3A5TVdnNlJyWFJsZTArWEZQTHZVaW9HTndqRXlUekxFYnNlZzI4OGRHT2JYUXJ2b3crYm8xS2xTa3RTa3dxS1pacWpTZlFEa0JqcWkvalpHU0dQRWkvRlZwOTVuc3pWclpkVm9yVHpUbHRDZ0NTb0hoQStwakNSblhSb3FNbFZiTXR4Ykp0bG1yMHFGUmx5eGE3WDhNaThIcjlMSEhWR2FPZk5oNHF3THN6bDJkbTFWS01KSGdrM0pubnVJTVFiNE04a2FxZ2VQQnkwenBmRHVIMFc0Y1JtYzNUU3V2aVZlOUVtNUkwRURhQmNkWnh5OHFaZmp4MEJjU291MUdyV1Y2VDF0bVZ4QVlFd1Q1allpOFd4WlR2YUZ2Um11SlVYRk1hWUtPcWp3VEZ6MU8zUEhRbnk2WnBSNUpHY3pBUUVudVNTU2Y2dGh5Ry9uaXkxN0ljV2dEUEJpQXdRaFhPbUFkckhEUmFzUjhnVUYyRlhUcVh4a0Vjb084ajQrVGg3WG8xUDJHSkpSbWlHTWtneGJ5NjI1WURDb3F5MTZhR0xzQWJNTFNRTnR2dTJGc1pJOUxVd3poMUdnZ3RJQUo4dHVjMnhna3FkSU1GVlhCWW9Kc1BFZWYwK01ZWGd2b2xUb21ycmNMb0phNmxvZzRTMkRoL1FqcW51Y3pYcXVxSDh4NTFIeGZQSW0yM21PWnhRNVNiMFZLK0JlNzhPa2liYy9EMXdBbndhblZEWGRXWGFaSks3N0h6QStTZHpqR0kwTXJUcWFoVFVTb0hPSU1lR3grL2pHTUVVc3U5TU1Ub0xDOGVjM0g4ei9uQ3RoU0x4Uzd4VWNzQTRZNmlSRndDRDczSS92aldQT095eW9XZ2F3SUVGU0Z0NW1QZytzNFZ0dG9XbU5PejNEam5hNnFhYnRJOFRDVEEvOXZVMnQ1NGptbldpMk9CMlRzemt2d09TZW5ScGhLcXdIWUFFVXhlVkhYelBYSGo1SlNjajFNU1NWRitiNGhXcDUzTDkxVU5UTUVBS0hHb2xRRGM4bDY0S3hwN1ptV054NnRScXJxekR3bjZ4U1g5VUEzbitNQndTRkhIRHVKVWEyV3A1bk5WcTFncmxYSVVqbGU4OHRnTUs0TjlCVkdUNDcyblRNWmx6a0tOV3UvNktkUmhDSXZSQjdiNHZqd3lxMks1bWN6TjZZcTExN3pNdVY4S0JtYUkzTVl0R2xwaDR0OUZOYmgzRUF3cVY4dG1zdlFjNmdXUWdRQkV6TmhneGtyb0VvM3NEcTVwUlNDVlhlcHBCMHp6WSt2dGgwbnV5TTNUMEU1M0p2U3ltVHpPVG1oays2aFRWalhtSHZKVkJzb1BQb043NDBKdTZacFNyb3JDc29LbVdWVldTcHNwTWlSZmI2M3dXK1NzWkpKVWdzQ3ZtdUgxa3FNV2JMS05URnlTcWtuY2Y4YmdUdk16aFU5QVViV3p6TTBtcm93cjBnRVFxejAyQWtRRzhYbU9mdmdwaFRhUm5zOWxhQldvL2NqOVVLZE80MjI2M052NzR2R1ZDOTlpL081SWpMcWZBRXB3U1prUjBuRm90RVpKSVZrb2dZRkthbmRENXo5MnhWVUtWUXFzL2RhZEJhQVFaS21CdDk4b3diRFNQcWJhNnZkbnBZTjV5YjJ2TWZ2akdlbFpOWVVveERpUkI1a2lJUDg0eExuSW03TVFsZ1VJa2MvOEFmOThZUE5sZ2ZTQW9SYWdGaENBd0JzTUNrVUZXYVJlOXI2QVVobUFrVFlFbi93RHJnbkRZUmxLZXVuNFEwY2lvdXczZ24za1d4aldlb2xQUUQzakJRUVRZaTloQjVjL2ZHb05udEhRR2NsbW1aL1NJQUp2RWN4NWVjWXdTT1hxa21YVnRJRUFrd0RlZVZ1djF3ckNpMVNTakVCLytVcU92K2hnRDgyVXJTVWxoSlJBUUptUUx5WW43OWNDNlp1YjdTTi8vQU5QcURWVWMwaHFyTkNKQWcwN2p4VzNpVDhqcGp6L0psdloyK091V3pwK2NyWmJoWEMxbzVOUWFqZ0pURHQ0VU1FNm05Ti9VNDRWOHVqcmFhTTYxVXJVb1pmTGxYck1uNWo2aXhZUVRKTWJiNzR1cmloYjlsV2Q0b01nQVdiS1pnRkZiUlVrRVNDTld3bmF3OHVXTnh0YTdGYzZBTXkyVzRyU3BzNGNWR1VIOWVrQWd5VHBQN0hCVWVLMk12bUJQMmJyWnZPTXVUTHZVWndGQ1Q0ZmNueS8wTVVXWlZUTkxESTBYQ09IWjNoZFpSU3pOWFZUZFZabTBPTlgvQUI4MXNUMU1lbUlUbXNpdUkwTVRYczE5ZFY0OXd6TTBLOUdwWHpMTnFRNkNqQ0JGMnZwQUl0SFRIUFRqTk5zZlVWUnlmdEZ3UE9jT3AwZS9LbXRVbFVGRUZ6TVdsajA2K1dQVHg1SXZTT1ROaWVuRXlCenVhRkROVWxmUWE4MGlnQTFFS0MwQTdqYmx2aXFoeDJpRGQ2WS9wNWxjclZWNnVxb3BRQ1VBaHdRTFNUYnorZVdFY1c5SWZsVEdsWGlZeXBXcFF6R1djRWdsYVoyQm1ReEc5aVJ6dkdKdkcxMlYvSXVrSFpUTjArSVZIcHBxZW5wbEdlV0lJQkJVbnpIeGhKZkRabDhuUXE0K2k1Ykw5N2xsUTVlcVkwTWJvNHN5eDZZcmpha3JCS1BCaVdwVExOVk5KYWl6TE1GSWlCeWcydGZGa3liVm9Bek5GSktCZHlDQkJBSjZqeXhkU3BXaVhUQUVmU0cvUUpsU0dzSWc3WW9uWVNkT25xWlhwMlZnVEhsR3dQVEJONm8rWFpXSVlDN0ViSHA5TVlUOGFJTUlDdHJGeGNnUnFJNWV1TWJnajZuVHBsWWR4VEttSUxqNXhySFF2clBOYXZjQUdzUUNDUnp1ZkxhZmZHT0FsUnJGYVMrQWlvVElBdmVPV01aS3d0TklCQ3MyaW9KTUhjM3VmS2Y0Nll3OVVSTXNnVWdCN3J0RzNMNXdHdzBlb2trQXdMQzhDWkhLKzMrc0syWXNVSzFBd0FReE1zQUJQT0QvQUd0ZWVnT01NNDE3SzZiUzlOaVFBYkVYanA5K3VBMTdHaXV6ZGRpTS9UeUlwa0tVMDBxb0RJUnpHd0h4anovSWkzMGpyeHlwVWg3VTR2OEFpQzlXcGxpMUtrZ0tyYTRtQUFkK254aUNnMHRJc3NqYjJEWnpqSzBNc2N0bE5SZXE4TzVpSUFuOThQSEhKTzJibkZ1akxaek9EdnFWTm1OUm1nRXNlVjcvQUI4WTZJcGNXNjZKdVM1VWRPN0Y4RFU1V205U29XSnRid2diZE1lZG15dTJlamhna3JOcFV5Z3BaWHU2Q3ZUSjVySXVEMWp6dmpqZVMvWlZwdnNvcWNCN3hXZk5VV0loVElNQlNPWHBnckpVZEJUU2RDYk41VE1aS3JXcDVIdndDNGlxU2ROeHNRYjlNV2hKUHNQNDAxWmtlT1ZzOVQ0ZlVXdFJsWUFhcTdUTjdSYzNKSCtzZGVCeHR0SE5rZzZvekhEdUFveHkzZVVpZGNyNERKMnVmSTljWG5tb2hqOGR0YkdlWTRJMVBMMUFWWUwzbGxpU2JjdkxuNjRuSHlIWjBTOGE0MFluUFVzeHd3bVdWcUxBYUhITGY1MzJ4NkVhbWVaa2k4UmR3ampWWEo2U2hhbUlnd2JNUnluMitjREppVFZDS2J1eGxWNDR2RWU4eTVVVTZsWWhnQ1kxTU9oNmtRUG5FbERoMFA4QWtjbnNMbzVnSm1hTkhNWllxS3M5MjlJMmN6Qmc4aU9tTTJHTGJlMERjWXlTQUZxVGtJNEJCaS8zKzE4Tkdld3pqUmxhaU5UVndHRXEwaSsrMThkYTFSQzYwRTBTQlZBWVNOTTZJM21iL2ZYeXdiR0NtYlZSOFhpS3FiaTA5ZmpHQjJDMUN3VmYwV0FGeCtyYy9mcmdqRjZkeVZIZUZWTUFEOG9HUkdCWUxNOW1tcC9pYWlrVE5VaVlnbVpuZjFKM3hqZ1BxY21tQzE0aUlPOTk0bWVRM2cyeGd4VkI2VkQzS05mWElnRXhNamYrY0k1VTZvWmtxajZabG9zZjZ0ejBQdmdyZXdsWmZTODFWZ3VTU1M0Z0dKdDZZMUdzcG9sbUJMU0dZR1BqMTY0dzdtbXdsR0RGTklNS0xFajdQKzhCOURSb2U4QlI2b3BVa1lLenNRcGt4ZGlmN2ZjNDVwZkhzcW5WVU8rSlArSFJCVDFvakFVcGtOdGJvZWs5SUk4OFJWdVIwUytNZGlIT2VQTU9XZDExSHd3QUJ0NnhpNjB0aytON1FSbDh1Mll6T1cwYWxXbXFsOVN4OW4rMkp5a29KcjdLWThmSjJkNjdKcDNPVnBvRllzUkpnaVdNQ1Q2Mng0ZmtPNU9qMThhcUp0OG02bFNIVUhZanBqblJISmZvT3RvSTBpTU5icWlHN3NEem1VeTlha1E5QlhPOGFKSTZZSEpsb1RrbjJZSHROd1VWS2VoWWVCQVhScGlSYTNYL0FCaXVISzFkbldxa0wrRTluM0pwYVFvRXowNWJEejgvWER5eldQWEdKTGpIQzJ5OU4xWWtpYmFTUko1ZXd3SVNacnRXY3U3Y1pCNkpVcUIzVXlmRHNlUittUFg4YkpiUEo4dU90bk9xdWNPUXpwQ3pVUVF3UXRJQk84OWY0eDZPcEhreWRBK2V6T3VveHk3RW9wa2FSRWM0OVFRYjRaSkxzUnpsNk5mMlM0dm51STE4cmtYSXFWcWxWYU5NaFJJSklubGJZWTVzcW82c00zUHMxSEUyUTFzMWxxYi9BSW5McnJDUGRTOEVqVUxXODl0c1NpdVd6b24yWlRNVWlLYW1VYVdZYnpPMThkTVhkTWpMc0RkdEw2OVFLZ1JjYmUzcml0aU43SWFwUS84QU5WdE5qTS9Zd1E5RTJDbGpvalNCdTBBMjZ5ZW43WUhJbitUK2o1MHFXMEwzZ2pmV28vMzY0MWxLRUdjcWQvbUtra0VNU0RhNU0vV2VYdmduRFJiU3FBYWFqQUtpd1dpNHROejViaTJDRTlDbEF2aDBGQnJLdEEyTno1enY2WVdnaEhkZ05VZGRSRFFOaHpGLzNIek9NWXJDd2xCcVpXSG5VdHdUdk44YXpGdENrakZBMHZVZTFwTWt4NzRsa2U3SGhCU2V6VThONEJsNEI0aWFsSXNFYnVxVlBXMEZ4dmVCZmw5TWM4c2ovaWR1UERGTFp2OEFzL3dISlU2NjVqaCtSZWdWUTBrcVpnUVFTQ0NZSHJ5SHhqbHlaVyt5L0NLMlZkbytCcFF5RkpWcGo4TlNHaEhFNnFqa2tYNkRjKy9RWU9PYWx0QmNlVE1MeFpWU29HaG1TWUphWWdEcC9PT2xkRVhjWG9KNERuRFc0bHFxRXc2cVcvOEF1RW4wR0plUzZpeS9qdDNzN3Z3TTA2U1VHS3hVV21KQzNPcUI5YjQ4V1R0czlUdGFOVGs2akZmRzBqYnFSaVhSTEl2cEJqVnRNNldueUl4cFNTZE5rZU45a0RtQ1ZETWhVUk55SU9GMEhndWtBWjE2TlRXc0RrTGkvdFBQREowdEY0UmtrZ1loU3BaTFFUQnZKRnJTT2ZYQ0w3Wlcvc3ozR0tsS3U5UjNjc2dJSUlKQysxOXNXajNwYUdYVkhPKzFlV0dieTlmdTExS0FHTEdUNFFaeDZIano0dTJjL2tRNXhwSTRwMmtwSmwrTHRUUWx3RkdybGZtZW5USHV4NnY3UG5NeXFWQU9VcUtnTi9IcUlqZTFwSDMxd1gwVGo3UnJleDJheStTNHRTYW5TYk1PN2FLZWxyZ2tFKzNOZVdPZktyV2pweFZGR3M0aFdvMEdxVVNQRVYxT1lBa2tHZHR0OXNUaEd0RjV5U2RpTkNLMlZCVVNEVm5WRnZYeXhhT3RFM3ZZdXpOSmhKUlhGNzZWdDc0b21JMWV5VkNqTk5BdzBvUkFFekhLUisyR3RCc0k3cW5KN3VJZXgvbitmTENXQ2lMS2hQalJXTzl0aE4vM0p3UmRtYXFvRnpiVkRFak1FZ0cwWFltZnFaMnVCaHprc3JWSGJMb3ZpWWxJaGx1Ynp5MjJtTUVKWUZBb3U0VXRmVDRSMDNrZVFGNHdBaEhkYWRERU1CcFlxVE1SQWtSZ1dZblZWNFVFRUtGMm5mOEFmNytjQmpKTmpyczFsS21Zei9lMGtKTk1HQ0k4SmczUHpqbnpTNGxzU3AwemFaTlV5ZE9sY2Q0NnlSdVprR1k5dW9BeHh0dDdYUjNXbjBOY3Z4aXRrYStxalZTb1drRWprQ05sMkhyaFhDTSt3dVgwRnIyczc3SlBrbVNrbXVtYWRTdlVZYTNGcldzc3liN3dNSXNLakxYUWVmMlovaWxIZ3RTa2hXdlJmTU9CcVdtajkxVEVHQUp1eHZ1VHoyeFpPZlM2TjhXTCtGVTZkVGpOT2hsdTdWRG9RUWJBemN5ZlA3dmdlUktvdXhzTWJsL1IwamlQSHFuQ2NvVGxxWXFab3dsTUVjNC9lK1BOamhqa2xiUFJjdU1hUmhPSWNZN1E1aWptS2pjV3FGVWI4L3VWSXAwdWNCeVluckU0NzRZc1VlNG5PM1B2a0k2dmJUaXRDbWFGTGlqVXlSQU5PdW9BOUFEaDRlRmhsOHVPam1ma1NUcGhuRE8zUGFISktOZkZhMWVtWi9MeklGUmZyL2ZBbjRtS2ZVVFkvSWNlemRjRjdSNXZqdFNqV3lpdlR5OUFsOHc3THFsb3NQS2V2bGp6OG5qd3hTcG5xWWN2NVkySzg5MnpTaGsvdzdsNnBVa3VxaURBYXdubDUrdUxSOFJ5MDBUelo0d2JTWXFQYjJsbVhLMWNyU3BrblptSXY1WDIvdGpvZmdPQzdvNVY1dXRFVzdjWmFsUnFLK1JxUFVKc1EzaE0ybnozeGw0THUyN00vTmwrck9VZHFxdEtweFdwVm9TS1JFcjZSc1o2V3g2Mk5KUlNQRnp5Y3BPUUxRb2Q1b3B3TzhXYmtTQ0NldnlaOU1NeWNmczJmWTdKaW5tOVRhZFRmcE9tQUlJajN4elpYclIxNDZ2WmJ4SnhVNHBWNzFqcllNUVJQb0NSOVBTMkdqRzQ4Z1piNUpFNktvY25wWnpyRlh4Q0pXQ1B2NXdhZGh2UUtvWkdkNExMK3FDQk8zWHJoZ0hxdXlTQnAwcmVXOHdOaU1NS2VxRHBRcVFKdDExRHBnVU5aOUFlNUpPL0x6d1JkR1hybW1jeFVGWFFWZXF5aStyK296SFFiZXdPSE9Jamw1YWt0TmFqa0tBUUlrZ0ViL3pHQ01FVWFlcW16QXlTcTdqeENSZU92VDBqQUNHMGhOVlNWQkVhREFISVQ5ZXVGWVNMUTFMVjNzeWJoemM3Ry94dE9GOTBQRnBkbXQ3QThIeldmcTFobDlJOEJmdkdiU0ZGcit1T1R5Y2lXanN3eDNiTjdTN081aGlncDAxcjFDeFFCUk1FZ0dTZXZsT09iODN4cEhTOGFZczRwdytyUUxMVGlvRXA2OVM3UllFam1CSkFrN25iREthcWpmam9WVmVINWdWS3RPdHFScWRQVTRJMm5ZWWVMVmdrcVZpVE5jTTRobUs5Q3BUZjhzRUtGQjBoVkIzUFdaSTlNVjV4U0kvaWZLeHAyY28xS1BGOHRyVlQzZFdXazNBRVFENTdlK0llVEs0dWtkSGp4Y1pXZG56blpUSzhZeXNWRUNWR3NXUUhVZC9hVE8rUEtXWndscEhwdVM0N09lY1o3RjVUSVpsS2VlcU8ya251cVZVZ1VYV1A2ZVFZRzk5LzM2NGVWZm9uazhWWkkvRm1EN1hka3M3eEhqQnpncjVjcTlORkplb3FoQUJwbFl0cDVoZVdQUXcrWEZZNlBPeWVEYzdUR25aenNrL0djMVd5aWttblRwNmxlbTJ4QTZrWEIvbkhQbThqZ2RjUEdqN083ZGoreitYNEoyYnovREVVQU03QUVYWWdnQzU1M25IazVjN25PMlZjZUVvOGVqODZkdU1nY3YycXplVThTMHhwcUFBeHExYno2WTkzd3BwNGxKbkg1K09YNVdvKy93RDRoVG5jbytUNFZVemxGYUJxclZBN2w2WlpnSjNnMjZHK09pR1htNlp6emc0TFFveTJlcTFsRmFyUlFqVmMwQUZXTjlvaUx4aTdWOW5OR1RrN0ZuRkgxWnBTL2lJQUEydlA3bTJNbFJ6emQyRThKVXVsTmFJMWtOc040RXo2ZStNMGFQVkcxNFBUcEtoRlNveVprazFOTHJHcGdiRlQ2Y3JZNTVMUjBiVERPSURMVnFLMUNIVndwUStFU2J3ZjdZWEhKcFV5azZlMEs2ZXFtZExOT3Z5SFFnbmUzTEZsc24xMlJabVdYSkFCTTc4b1ArY0VPaUNlSjNZYVlQVUhmeStQcU1FVXNwYXU3RE5CRFRZajR4akVhcWgzMVBVUW56TVl4aktaaFdyWmwxTEZRYXJBQmlSc1NRWjJISWUrSE9JOEFwQVZIQ1NkRWdnYVNEL3k2bjBQcmdqQkZNZ2dDbnExRXFGNVdnYnpnQkRxTEZuZTdFU1JHbzdnUkcvVDk4S3doZVRvTTFTa3BWbFhYRWxyUVB1UFBFNU5KM1pTTWJSMlBzTms2V1ZvMVd6RE9Nc0dRaE5JSmR1VWVkdjV4NVBrT1VuWjZPTnFLTnYrTXlZeWROUUdGSFVlNnBKYzFHSWlGanJCbHo3UnZqbXFXam81cEM3aUNaV2pVcDFIVFdxa01LZEgvd0RWWmJxcS93RGlDZjV4U0xjZG01cG5qY0JGVEsxRXpGZW1jMVdLWm1vYWJBZ1BjeDFnR0ZIWDV3SGxmSWJsRjZveDNhcDZPWC9BSXRRSUtnWlNCNEFGQnVTUnkzUHZQcDBZN2JSSExOTFNNSHdMaVNLK1ZVMUFIdXBZbmF3bS9XZWZwam96UnVMUW1ITFVyWitrZXlPZXAxOHBUZW9kV3BRc3plUnk5ZXB4NFdaVkk5T2FjNEpvWjhmNFZrdU5aVHVzd29BMVROcnhqUm5TSjRwenhtRHJmOU5NaFhyTm96SkpCblFLUWdmWGEyT2hlWk9NZEhUTExIMmpZOW51QWNQNE5rNjZaUFNheEFGU3JGemJsNVk1Y21XVTJRbmtseVdpeGFiSytZQVdYYWtDQ0xtelJIMXhOclpSdFduNlB6Ny9BTlJlN3pIYnJQdFNmUVZLcWpXc3dCdDh6ajN2RGIvQTBpSGtyL1ZqWlZtem1YeTdLOUlaaWkya3hFbjFqRHhmdHVoSlFiVlUvd0RZem1jeWRUTjFCVHllU0ZDak1zNXA2UWVuOFd4MXd5ZmJPS2VMaStqRjhXWHU4KzZhUVNFMG1adHkvajduSFFuYVBOeUtwTWM5amFScTVvb2lqdmZDdExjQm5NZ2llZ0VtZVVZbmw2MHhzU3VSdU16UXkxV2hRUlVWZ1B5elVXNVl6TW4zRmpqbWhhV3pveWFkb0NvMWhVR2wySnJvSW1ZMWxSdWZPQmh4WXQzc1hWcXFzNkdsNGc0SkY1dmU4OUo2NHBBMHV5a0xET0hCMHhxSkF2TnpJOG8vYkZBRU1rTytyYWFaWUJsQWczMWVZUDF0akFzSVdub3BxRFVSUUdJZ2pZYlg4N1l3YUpaYWc1cG1FRldER29xUWZRNFVhek41dkxzOVd2cFV5S3pIVHpNTWZwZjZZb2NCUlRxVldnenJWZkNTUlkzL0FMZW1DWXR5K29PbzFORGJrL0pQbHlKOVBQR0dEOHFuZHUwSTBqbHBCOGlKOHp0aWVRWkRUaG1aSGZpWTBzNEVSL1NONDlmbTNuaVRqY1MyT1ZJM1BEdUlMM0NvMU1zaXN6dGVKNVI1QUFUNzQ1WlFzNkl5RzJWNG03Vis4Y0FLdEl4cDVDTmhmL2NERVpRTHhZWlM0c2F6MGN6bTJaSWN3cUVRQ2Zmb0FQS1IwT0pxTldNbVU4UzdTVnUrekNyVWRYZEZKWmxCWVd0cDZBWEErY05IRW10aDVWczVwMms0ZzlhaFhWM1pXUmpvTEV5RTliMjJ4MjRZeFJ6Wkg3TTN3aGpVenFvZkNWTXlUUE8rT25Lb3RhSjRaSGZPeEhGbVRJNWVkV29lRnAvYi9PUG5mSmg4ajZMeFgrU0ZIUjhublRtcWJMWXdTQ05wZzQ0NUxpTlBHb3NKUmtFbEFxaytJZ1duek9BNkp0TUZxOFNvMGFsWExaWU16VUIrYVZnd1R5SFV4aHFIaGpjL2xJT3lKVVZYTFdBcHhmenZHQjdKNWVsWDJmbTcvcUZURkh0bG4xbUlxQnJ6YTVBSHB0ODQ5N3d0WTEvKzlrdk1qZVRsL2ovaEQ3aEFuSjB3dFdhVEhVRnRIbi9ySExuVHUwZWhocHJaWDJqTlA4SWRKSWp4QVRwdUpJSTYzNVlwNC9LVFRPZnkrRUZSeEhpbWs4UnpVdEVFUUNEYzgrZVBidE5LajVYTCt6R0haNnZVbzV0WHAwbnFrS1VKVWthWjlQNllrZWZwaEp3NUlPR1ZObS95aTFINGU3MXN1OU1Nd0toejRpU0o1YzVQbGprZW1kampxencwRkJwVkgxTUpKWUtmMURuQmpjREJUZGc0Mlo3TlZOVGlnYVlDQUhTRHRHc2pmcEVXeGFQUkp1blJDdVNjdFdQZGtOcEpWajVkT2w1d3huMHluSzF0T2JWVUVBMFZPc2I4NU4rZlBERUE2blVINGlwNFFWWVJxdkE1Zk1FZkdGT2hsUGVGN21uckhJcXhGdm5mRENtZHppbXBtYWdtUXpzUU45bjJQVXp6dGh6aUthZE95enUxNUoyTzBEejJqMXhoaHBsNlVVbmFWT2tXa21GdGYrUGpHQ1d1MnhRcUNOUHdmTDczd29UN0w1bHFEc1VWZFNUR3RyeVpIK3ZiQ1Mzb0tsVE5SMlZydm02Wm9ueFAzZFFONHA4ek5zY3M0Y1hSMFFkb1pyV3FMUmRWZVMybFZDdHVKTnZYRTJrNUt6cWlXWk5xcHA1ZEdLaEZxWEJmeE5lOXVYK01DVVZib0xkTkE3Wm5WbjYzZk9raFNBSmthdmYrZW1ER1B4RE9XekVkb014cnFWYUlzTkxHSms5TjhkY0ZVYk9USklYY0ZjTHhIS2hualVZMWVkNzRwbDZGd1N0bmEreWxQLzBoOENxb2FCeWdua1Q4M3g0bms5bjBmaFBSMExoK1lYTG8wQUdWMCtLMC93Q3NlYktQS1IyU1hJSi9GNXppTmI4SGtpVmRoNHFvV2RBamYxOHVlR1VXbVRxT0w1eUVmYXpqNTdDNmFOYmhPYXpHWHJFVktXWVNvcXlZOFFKLzUySlBXY1d3NGZ6S295SXl6S1VYSytodjJSN2I4TTQ5bHF6WlRWU3FwVDhWS3I0U2t4L25FOHVDZUIwU2pKWmtwSTV4L3dCVDgvd2M4ZHI5eFVENXFybFdwWmxWUE9KRUhtYkRib01kL2g0OGxKcm9HYkxCTGkreEwyV3pUdGsycHZHdFlJRFg1YjdlbUxaNFh0aitITlA0b1c5cnM2eHFJa0VnS1dZN1R2UHZJR0wrSGo5bkovMURNM3BITjhubEsvRWVJTFRwdmQ5V3JXUkNLZHpQcmowT1ZXZUU0eWY3R240ZHc3TEptS0ZQZ2hlcTYrRjZ6alRMSHk2Ymk1L2pFbkpOT3krT0x2US9YTDUwVjhxMmZxRUlxbHFGTmpaMkpna25tTjcrV09lNDhkRHppMUpOaEdacktLU0xUTWhwSUpCNTlTT2VCRjA3TFRNMjFHYWkxckZTU21ycnY5Yi9BRXhkUzBjOGxib0xhbXJ2VUZVNmk2bUZVMk1qbGdjaGVBcXpPV3FVczJ0V2cyblF5MnRwZFRhQVBuNll2Q1lzb2JHcUtwa213UVFQVWpDRmZaVzFaVU9sd3MvK1ZNTWZjemdVSndNdFVxTU0wN0VsR0x1TGJSSkIvZjR4YzVTd0ZHcE9WRHNxekFpSW0wam9aSDdZQVExQ1B3N1N4RVNBUTBpWm1QUHp4akh3cUVWYWFqOUtnQVRjL1Q0akNzSWZ3VGhlYTQxbU82eXlNS1ZPMnVkSUFFbjlWaHZFa2pwenhMSktFZSt5dUtMZitEcFBaZnMvVnAxY3hYRk5RY3hSMDB3ejd5cGtrY3ZzNDRNbVN6dGhCUmFvTjRYMlphcStYUnFRT29MQkIyRjRFRWRZT0p2TFVVaXlqY2hOeFhMZmhPSVo2bVdiWFNySFU0WGNEWS92OWNQamxhRmxHbTJaK3RtU2xhdFVkQ3BwNjJZSFRMN1JjZFRQemk4WTh0SE85TXduRzJpclRlU1hKWmkzNy9Gc2RtTlVxT1hKUFpUd05tYmkyVlVCbEFxZ2FoeXVNTlBjV1BqZHRJNzkyY0pUTEtwUWtpcHBpMEN3Qkg5L1RIejJkZkpuMHZqU3FLTmZsS1lxVmtvbURxQjlJQi9ienh5czZKU05GbGN4bE9FNWFBLzVsZHBneEp0RWJiOU1UYWxQbzVNejV5UE9KUFQ0cGxDajBqVnBheEt2QU16SE93YkJVWGpmeERHTkhGZTJuWlBQWkRqQS93Q3hVV0ZITVV5dFlvM2VVekJCMG1EWWYzeDYzajVZNU1UL0FDOXA2SjVzRG11VVRuR1pvVmtyVkJuR0tWWklLeDltTm9PMlBUeDVMVkhsWmVhbmJOTHdHcVVIZUt1a2FWVnBQa1puNm5ITmxqWjZHR2VyWXE3VDVvOTFtNjZTR1Nub0E2RXRBTWRiSGx6eGJCajR1amo4dkp5Um5lelZKODdubHl0QjlOSXF1dUpNa21CQS93Q1VrL1BURnBmRm5uUm0ra2QwN0Q4QjRmbDhpT0k1bWpseUZaZ2h1QWVyK2hNZ1k4ZnlNemNxaWVsaXhKUlFKMm00ZFd6SEY4MW5HTkx2R3BvbE9sVHVLRk0yV2ZXWkhUbml1R2ZHS1Q3SjVJSlMwWnVwUktsUlRaRldtMmhEc0NlUTk3UWY3NDZaNzJKVkdienRSM1ZsQjhlb3JJTVFWdFBrWW5Gc2ZST1lXZTk3NXl3RGdvQ1FCWmlEYTNLeElnWUV1d3g2QWtyOTZhYjZsL01FTkpzU09SNTlNTndaR2M5bG1VcmhVQXFUSVVpUW9nOUpHTndLYVBhSVpWT2drU1pJWlJ2SHJoakdOekZRNjZ5c1JyVjN1Q1IvVVR2NWpsNVl1Y1lUUVlzaExDQ3F5R1pyTllINzlUaFI0U1hzSm9hVFJDQzUyRUdiVHQvT01DWGJHL0JzZ2N4blN1bXlFTkxHSjJqMzJ4REpLbVBqamJPb2NJeVNqS010R2xUWkIvOEFVZVBCSElBVzY0OC9KSzVXenRncVZCMlhHWnAxQlRwVURRcENFWWxmRXhpZEpKOXZMQ1dtNktOYjBhYnN4eE42R1ZwdDNuZkVFeXpBQUFhaklCK2s0NXNrWFpSV2pNZHJ4VmRUWHlWTFd5dHFOUGJ2QkY1dHlHM1hGY0QrMk5OY29tSnpuQ1RuNkxQa3E2Q2tISGVxQnBaVm1mOEE0OHpmcGpzamtxVkhMS1BLTmV6bkhhT3BTcDUwaWk4cXBKRTduNC9mSG9RMnJPTEpCUkYzREhGSE8wWEZnRElITVJlY0dTdE5CeE9tbWQ1N0g1K2xtc3NoWnBCRWdBejV6NlhHUEU4cUZObnYrRmxUVk0zQzExU3JTcUxxa0JrRnJIbkgvdHh3VWVoTktoVm5lRVp2dFR4aVV6dGJKNVhMTEt1cWtrdHlFUkUyeGFNbzRWMVp6ckhVdVZpYmpmWkxpOU51OHpuRTg1bWxCbnZLY01GLytCaTkrV0dqbWhMK0svMk96SGlqTDNRakZLdmxtZWpsK0tVU0dXUHpMYWZZRVRhTjhYU3hQdER5aHhUU1puODdscXY0a0Q4WGxHYVAxMDZlclNQbi9XT3VHU2xvOFR5b3hUdTlnK1VkcUl6Q0d1V3FIU1VMaU5RamZ6MkdLU2Rxem1qTXovYVd0VVRJNllBYXJWWVJ6Z0dmOFk2c2Y3TC9BQWNlYWVtZ1hzbG1teStaYW5UMW10bUlRRmJSWTh4ei93QVkyUlhJamphWC9rN253L2lqRGhGQVZNMkM5RngzTk1zUEdRQUZCZ2NoSkk4OGVWa3hyazZQVGhUUlZ4WGlkR2x3K2tsT3M1eldZTldvSFlYOFMrS3AxZzJWUnp1ZVdOR0cwVGxYYUV0SlZlZzhPTk9zS1ZrRzBiZkZ4aStTVmFReVNhMkxPTDhIWE4wZTl5a1ZjMEc4ZVhJQUZUVCtrckg5WG41NHBpeTdVV1F5WXIybUphS1ZSM0RWdEpjRFF6UjlMSDM4OFdxTGRwaUpWcGdpNVdUM3hwNlhSbTBrS1FUSWlUKy9uaHVaT1VDOVpMQ3cwZ0FXdFBzZm5HS0VnNXBxRlR1QUkyTVcrdU1BeHRiU014VWd1ejk2ekV4YWRUVzg1SHZmRnpoc3RRc3RZSlQ3endrZ1dpZkxDaGlIRm5SbGVGbDJZbU54WWY1K2NZZDlteDdKMDlXVXJQVENDclVlQTVNYUNiU1JIcmpqOGh1MmRHRmFSMHpLVWtvVGxLYXFxVVdTVzNMTmVSZnpqSEN6cHVuMFhLaXdHT2s5MkFuNlptUllmVVNmUENlN0tyWlJTRlJLS2EyVUdqVk9zQWFaTzhiOU9lQTY5anBXVWNUcVZobGU5OElkQUNHcUdOd1NTZk8yL3RoVXFZMi9Sekx0TFhOT21IUmxjMjFPVTBoemNRZlNRZk8yUFJ4UVV2MlJ5NVhTMGMvempHcm1tZW9RSFlqVWVaa3o4L1RIYkhTcEhCTkxzcnBVelN6SXBxeExmMG14Ti9zWUwvb0VlMGplZGplTU53bk5VNmVaRGFBeEkwOUkvYTMxeHllWGdVbGNUdnc1L3dBZWpyS2NRcFpuTDBNMVRZdlNZd1hPMFJZbnl4NDdoVDZQWVdWU2hZNzRmeEpLZEk5eUNyTkJGaWZrODhSeVExUldNa3k3UGNPek9leXNVNnA4YVFkQ3dUUElIbGhJdU9QdEZhWHN5K1o3QXF0ZG1yMEM3dGNHbXdhNDNuYy82eDF4OHhxa3VoUHdRbW02L3dDVEo4YTdQWm5LYW5ZYUtLK0tCQnRjU2VtTzNGNUVadlo1L2tlSHhWcm96RlFqSkdvTldvd1JxLzQrZnlmcHp4MVJYSTRacmd6RjUvTi9qTThocUU5MmdPbTl6OXo2N1k2WXF0bkJrYWxJdTdQVWdjMmMzV0pWa2J3d3Y2aVlqQW14b3JvNkprODBUdzVGcUJtUGVLWS9xTjIxTjVHM3ZmSEZPRHV6c2pPTFZFbnFWYTJhNzV3MXdpZUVTRkVXOXJDM0lZS1FQN0RzdTRHa0Z4VEdxMG1OK1h6em5tTUQrVmxWMXN2elFmTGQxVGNnclVwcURJa2dFYlQxODhLdDNadFZvU1p5Z296TktvRVZaYlE0VmZESUoyRWRjV2dpTWdEdnFlb293T2tPUXdrRGw2ZW56aW5Ga3BOMkRPZ0dncGRvaTRrSDcvdmh4aU9aQ05VR3N2SVVDUTBUYnpQN1lGaWNqTTFEVFd2bUdjTnFGVWp5UGl2YU5zZEJ4azZUK0pOUThNeHZCWWV2TGUvWENqTFF6eUM5L1RxeUZKUUJpQ0NBUnNWamU4LzJ3cmRGRWt6UmRqc3BuYUdacTVldFFZS0ZoS3JSRWJ6ZTU1WTVjN2kwV3gydEhXT0g1U3JVSmVyVENMVmlvN245SWJjcXZYSG5UbHhSMXhmMkVaM0xuSTVidkUwNmdOUURibUxYNlNZdmdSbFk4bnJRTncyaS93Q0dZVlhWbmRtcXQ0WnZibjBBbkN2YnBqUWRxd1R2MHlqVU0xbm5RY1BxVVJUckJrMWFTcEkxZXQvcmh1NkhiZGFPZmRxT0cxTXZ4S3BRUnFkZWcxUmpUZWxkWHB3U3BKNU1JajR4NkdHVlJwbkZsdDlHRjQ1UVU4UnJHbXRRZUhTeWtURENKKy9QSFdtMnRITExyWlcrV3BQbXNwbUdWKzRxYW1jVTExRWRZdnNNYmt1bUNFRzJxTjlTN09KbitEZC9TTFBVcEdGcVNWQkZwdHRFMzg1T09CWjVRblRlajFjZmo4b092b1hjSTQ5bU9CMS93dWF2U01DQ1ROdWNiUmJGSllsUDVSSXJOTEg4SDBiYnM5MmtvVjh1aU95bFk4TG00QnZ2YmVjY0diQktCMjRNNmwwem91VjQ4aTVjV0U2Q0NnYVJ5dDc3NDRaeGxkSGJITkZxMkJVdTBGSitJQ2pUVU5NdDRQMUVIWSszUEN2Rlc2SGhtdlNabU8zSEZFeTlKcUZOZFRQTGhRUHI2ZVdPenhjTGN1WDJjL21aNmp4czQxMmw0aUNCbHFSWHZXRitnOVBVNDluRkZyL0I0ZWJMNk14U0FNYVdPbHpjU0pBODhkTHIwY1NIbEtvUHhLVVVsWUlDaWQyaS93QkwreHhPU2JhS1JrK2pUNWRNMVh5ajV2Sm9LaFRRM2RLWkxnTVJiMkIvL2xpYzVkcjZMd2cyT2tXczlmTHY0aGw4elNCQmdEUzIyNDlMK3VPZE5kbGFsSFREc21OZVdQNG1zYWZka0JtMGFpSWprUFlZV2Nrbm9yRk45bnVpcG1jMDFPb3dwcUpVUFVRZ2d4WVFEYThYNkRBVFNUYUVWc1QxVFVySVdxb2lQM2gxS3BNQyt4bm5JT0xKcFUwTEs3RlZlazlOdkFpa3Ewc1BMb1IvT0x4bFpLU1pUcVl1MHJ1eGlERWNvKyt1RFJySUtxc0oxb1J5bEp3YUU0b3lkWjlPYnFsTHAzcEdtWmp4RzNQMXhVNVMzTDFnYTlOdzU4SXZGaUw4emdVTU9lRTEwVE5IdkNGUjRVRy9sSHJ2UHNZeExMSFE4ZmkwMGRMNEpuTTVrc3F0T28xQTBsWTFKS1JJYXhJSnVOd2ZiSEZPTmFPcE90bW80ZnhITUFBTFdvd2lRb1NYS0hwMCtjYzBrbStMS3hsZlk4YWozOUhVNzAzVW5VQVdZbC9LUnltTjhSY2ttVlM1SUZWS2xKNjlRcW9wZ2xWM2gzdFlFKzhZeiswVVM0cWpNOFg0aFFwMWErVGRXYkxzeFYxbmRpWUJIbmlzSTJyRWxNekdjYW53OU5OTExxMUdveTA1aVNYM2t4NUVSTTdZdWs1S3lMbGJNZnhHZ2xiT1Z1NFlsZThaWUE4Uk1EYWJiQWs0N1lOeFd6bHlLenpzcFhwSm1XWE1VMXFLcGQ0SUJFbFlQdnQ3WVhMSDJpbUIzcG5YT3cxRDhJOWZJNWltOU9uVWl0UVlnQU11a0FnZWh2R1BJejI0Yy9aNi9pZkVVZHVleXdZVml0T0ZhR3BWRkVhR0c0UGtiWXY0bmxKS21MNWZqYy9ramx0V25uT0U1a3RTMVV5V1pRNnpEWDU0OVZVK3p5cHhuRG9kWlB0Ym0wcGlqWHk5UmdCK3FsVTNIb2ZzWTU4dmpKN1JTUGt1S290b2RxblNvekpTekNzU0NDcnFXdE8wYi96dGdyeHJTdERmOXpTRXZHdTBWZXEzZTFVZHExL3pIZlV3a200OUkrdUtZc1g0M1NJWmN2SlhabFhmdnFtc3F6Rm1NMjFFZGZYN09PbGFWSExLVGs3WmJRMDBxZ3FsYlNKTWtnRGVQUXdMNFZnUXh5eW44Y0xPNnM0SkVSS2tTUVQxQS9qQXVpbEpOTTdsMkw0RW1YeTlETVphb3labkxQb2FtVk12U0xTcEEzZ0NiK1J4NVBrWkhibzlURkcwbU1PS2NEb0pRN3BDRVpaWXFWTWZxL1dzYittSVlzbEZaWTNrZklFVEwwY25MWjRvMVBSREVpZFlBTm81bmEzbGk4M3lldXlTZGFZQm1zNGM1bUt6bGhScGtnRmxVV0VXOThPNFNTMlRTU1lpekRCVldtN0xxYXJjMUR2TmlEODRvazNvRW1yRjNFVFRZMUZoWVdTQ043d1krdjF4YUtaR1VoVzZNMVE5MkVnTE84bmI2WHhhd1VSY0dvdE5nek1OTUNYTnZyZ2kwWTJvU2F0WUlJMVZYai94T29pLzc0dFJ4MFc1VXIzaUZSSU1CaHZ6OHhFWUFiR3RPbzFhdFVwVm5KbHdTWWdqblllVWNzTE50cXFIaTdhczFuRHM3bUVvd1FLaWhRdXVESUFtQ09zakhKS0owcWFacWNuV3JabGF0UjZ6RFVvQldvMTFKdnRIemlMU1R1aDRtaHlQRkNtVlYyWFMwYVNDdzBqenR5eHpUaXVWbFU2MEFjUzQxbWF3MHFVNzlMQkEwYUp0OVJ6d3lnbm9kTzA3TXBVektEUE1NMnpKVHBVMnJNNGFEcWlLYXoxdVcyNllyeHFOUjJSbFA3Rk9mcTVLblJvbkwxV0ZkUzZnVldEck1CUURFR2ZJamFMNHJqaTZwazIvb3N5K1dJbzVnMUZBSUoxSCtxZEpKUG1TQ0IvYVRnTnU5TWZqOGJaazhzMm5OVlhSaWxJTXN3Yk1DWWtiUjF4MVNYS0ZleUdOMUswZm9XcHhMaG5hSGlUVitBNXZLdm5GY1pnVXZFamtpQUdBSUZqY0hyT1BDVVp0Ty9zOWJIbFhGQjlWcVdmeVNPb1lVNmlocmtRRHRlM0l3TVJqQnhuYU85UGxFdzNhdmgxQ21rT2thcXBqVUJLRW45aisrTy9ES1o1L2tLUG81VFhSOHRXcXAzYjkwR0pYd2tBaVkzNTgrblBIcXIvSjU5TDZLYzVtZTZva3I0U2ZDRFBNY2g4SCsrR1d4SlY5Q0d1WHFNMVIwSlRjRXJJQitQU2NPdE01WDJWcW9BMk1yQ2lUOWZmNlh3YnN3UXNsRkJDRUJ6T2x2MzYzSStjQmd2WXl5dVlVQ2srbVhSbFZrSi80M2lldksvVENTaTVkRkc5V2R1N004UnluR09DWlNubDh3dERpZVdwaGFURjlJekZJTUNMOG1GNVUrdThqSG1aSWNaUGw3UFJ4WkU0cE4wTXN6eGJQbkxsR1ducUVvYWlBaDBBL3FpZmtERVlZNHA5bEpjMDlDM0tWSzlXa2xCNmRUTUdtbXBuYlpPckVuNjR0Sko3RVVHdXhQbXFpcTVPb29oc2Flb0V6dEVqbHQ5Y1ZpM0pxeVV0TVRadk1kNWxuV2lBcU0xZ3hrOWIrVng4NHFsUXZZc3FHbTFiVXdFYkVsWjJBM2pGWUVIdVZGY290VXFFWUJkdkRKOURnbFN1b1lJaW9pZVRnbWI3anl3Yk5Sa3FxRTFtVmFiRXRWWXBKbitvL1hZNDZEaUowYWpBQnpMYngxRWZUa2JZRkFvSmRTd2RsTEtJbGZGZUk1ZlRHZFZRWDFvYmNFenhUdnN0bXF4MHVvQ3NyVERXMi92NllqTlVoc2RyUnIrSGNhZmhiNmM1cXFJU0ZEL3FEMjJiMmlmWEhITldyT3RQam9lMWMzazN5VEd1NHk3a0hTYWFnazlCUFQvT09lbTMwVXR2YVF2NGptS2JWU3RldGxhZVdVUXAxU1dGZ1pqbGVJK3VHZHFsUUx2cGdkYk9wbmFReXVSRGQxUzAxejNvVUNvWkVGZ0J2dkIyaTIySGpHVWRzUnU5VVdaYmc2bnVucjFLTjFKYUtpaHlTMG53OHR4ZHJXNTRNczFLcUt4eExzQTdaWnluUzFKbGFKcDBuWWlGcUJoSUVFTDFpQVBNNE9CUGkyelozYlNSazZPVllqdTFLNnBVMUZtWTh2M25IYkw0cFMram53L3RUTjV3Y3J3L2krVHpuZG83MFVEQ0pVT29KTWpiN0dQT3liaTRwSFhqZ3I3T2hyVXl0RGlKL0N0Vi9DWnhPOEFhRkMxQitzUjB1RDVnNDRuR1RpMnZSNk9PVGNhRjNhTEswS29wTFZZQkFaMUh4R0R6STg3ZnpiQnhTbEVYSnhaZyswZVdTblFxc0F3b2dGVHFYeE9aSjB4TnZXTFI1WDlQRmtiZlJ4Wm9LS09YVm5xNW5NWmlxdFBSUkZqSFR5NWN6ZTIrT3hmWjVrM2JLcW41am95a3FzYVZHbUFBT1pITW42emh1OWlFVXFhYmF2NnQyM2dnanpOeFB6eXdURUZKQkdyVUNZRXFZSW5sN3diNEZBRCtIVlZMU3hXb0UvcGduYmIrUDJHMk5UVzB5cTJxTlQyZHEvaDZtdVFLWVh2cEJnc1ZKdUFDSjVHUmVUam15d1VuYjJXeHg0OTdPZzhPN1EwT0p3alZvcUVhcUZhdEpWbmdXUG5QTDN4eHl4VTdSMHZLMk5pSytYb0xtS2JaZHFkVlBHR0VkMjNNanpqbDB4T0NjaG0zVjJaRGk5S3ZVemROZ2l3VktsVkVEbElIUVk2OFRUVFJHY2FhRkF6S0duWE5TSVNtUDFYOFZ2Q2JYM1B6aWdrWkpzcERkNCtxVTBzTGtKQmczdU1QSFF2RDVjajVuM1l0SWlBWmk4WC8zendSaWgzQ21DYWFrVFl6MTVYd2FCWmxNODFUdjZ5cnJEbHlWRWdtTlVSUDN2am9PTXJiVUtqRUFscmN5Q2VVZ2IrZnZqR0w2TlpRQUFqU0hHelhNRVNJK01DakVzd29UZlRLcVlJQnVQSSt2TENPT3dtaTRKeDdVZ284UmR0U2doSDJJSkVFTkVlbUk1SVU3WFJTRS9UTkhTNHZsY3RST1hxSEoxNkJTekd1VlBQejJnM3RqbjR0L3FqcjU4VlF0eitjcFZhckRoaTBLQmo5WC9FQVJ6SFQzeFJKcGJJenBQNHNERC9ocU5ONmRVWmhXSVoxSlBqSkZwSjN1RDlNSDl0U0hVcUxLWEg2N1VobDJyaWhTVlRiTHBwYW9EYmZyR0YvRkd3U3lTZnNRY1g0blZyaW1LZFpsN3VRdWxqcFNTSkE1a3pNazc0cGloeDBMa2x5Nlp2OEEvcFgyZi9IYXVMNSttRFJweXl4Y2xnUU9lOTUzeHkrVm0zU09yeFlyaTJ6WThZNEJTeWZFTXJWcVV6WFRNUDhBaDJwVlNHTlNxUkxBZFFENVk1WTVHenBjWW8rN2Q1K2pWejNCUlNOTTE4dGx5WE5KNWhUb0NnMy9BUEZyRzhIQnhPVW90ZllZejNTSzh2cjRrVVFzcERVZzcxS3A4Tk1RTlJjbllYT054VGRJYmxxMmN6N1pjWUdjek5mSzVKaXVXUjZpc1VVS1hVOGlKL3FBbjBJRVdJeDM0b2NlenpzK1RtcVJnOHd3ZXBwcHNBaVRlL2k4L2JIV2tjSkU2a0xrbHBDa3daOFZoRzNJZnZnOUdJcTVRbFNDRkIxWE80NUM5NzlQUEJNUWVtRVpZRTZKM2k5OXRyV3hqRFhnenBTeldxcFNxVmRTbFFDQURwNmsrNXVMMndzazYwUEEzWFo3TFpXdlNxOFJ6MVB1YUliOGhXTEk1YVpFZmQ0eHlTbEs2UjF3ZW14bW1hWE44Tld2Q2lwMzQwYUFCQmtDUkhNOU1TdVhKeGtPcWFzdnpuRllwVUtiT3FueGVFbXdPODMzblNwMzVZV0VIVFlGTGRFZUk1MUMxQUVoRFM4UU14QUEybVIwajN4WEFuZTBMbG1xdjZNVndQdnYrMTZxMGhpZFZ5VGJrRDFqcnp4MDBqbXh0cDJNV2VxSEJiVXBDNkJjeVR2QjY0MUZPYVBSS295dzZ3ZzNINm9VaWQvdWNBUE5FSHBrYVJCTnR3b1BNOWNNWXhOYlFLbGVEQldveElZZE9Yd1RpNXlFSGJ1U3hhRVphamNoR3EvTGtCYmJCTVQ3OUZEQU9OTEd4VllOcDZmUCtzWXdXbFNuVzBMVnErTW0xcmJ5TDlZZzRWb0pZeW9jeWk5NHVwajRXbTQzSDl1WExDdHlXakZ0SlpTbENLOFRNZ25tT2NXd05vYTc3TEh6MVg4dHFaQ2drRWhtbWVSM20yM25HQlY5ZzY2UHF2RjY5UlVwQ3FIMGlBcktGMEEvV0ptM25oVkNtTThsSVdWYzFYY0tRVFNwZjhRVEVkRDAzdzFDdVNsbytvSzlaeFJRL211VnBLQ0xhcGo3OWNCMUhiREZLMGZxUHNsd3FqbE10a01qbFF2Y1BHaUZNRktJQkJQUDlXa25IZzVKdHlia2UxalNVTkgzYkRNRThQNGptMDFrNVJxV1h5andSNDJyQXM4OVlVMzhoaDhTYW5USGxUVkl5UFp6c3UzRVZmTzUzTTBzaGtCTG12VlM5UURkMVgvajVtMkt5eWNIUktNVkYzSUI3WmNUeS9EdUNQbHVIVVN1VnN1dk1rZDdtamFDWVBnUWZxMGpGTUVlVHYwVHo1RkJWN09PWjFobDhtRkVyV3FTWUFrcXZVbmNmNG5IcFJpa2ViTnNEU21HOFRyVDhZSmcyRzl2M2pEMmdKcWlvQTFDNFNZREVFaXdzRC9CeGhYdDZMR0pWd0thc1NZRVJjRzIzWGxiK01ZQjhLVFU2eWhnVlNRSkp0dUpJZy82R05ZV211eG4yY3lkUE52VU5TcWFUSXc4SVFzU09RM0VieDdZV1VtdWg0UlQ3Tkxrc2pTemVacEFack9QUUR5eHFLQ1BEdXRqQWorY1NjOWYyZE1lTWVocm5DbVhxZmxVM1hLVVFXMU51OVRWT3BqdFk4dk0yaStKSzJ0alNkdjQ5Q1ROY1ZwUG02YVVIcGdCajhibjJGNTlUaWtJdU1XYy93Q1NwVXlXZXk5RE5Wb3FadDNCWWwwZ1hQa2Q0djZjc0dFcXVMTTdrVzFIU2tEVFJrQVZRc3gvanBIeGh3cEpJOHFJck14QnFFRVJxVUdKOHV0djJ4ckVLbHFDbVgxa2xpU3h2dElzUiszdGhhQ1dvYWdXS0ZFVkZIUHZQdmxHR0tHT3pSVTFxaTNWZ1NBVU1TUXhGdW00K01kQnlBOVVMM2lhVlNDeDU3QW1JZ2UwK3VNWThwb1hGTldnVEVONmlkdmZmckdNWXVwMDZqZ3J1QVNQRTBTeGo2eko5c0FJVTFQU3dacVlCMWt6MFlXdVR6dGZBWmo0MG1xekNoeUhnaVJ5TXdjS1k4cjFOUDVTRlhCVWlCL1R2QSs3NEFMb3J5dE44d2FqVkF1a1gxTUFSSkhQNCttTU1sOW50VEs5MmxONWtmMUFSWXp6UDBuR05RWDJkcHJVNC9sYWJnbEVxaGl0cHNRM3p5eFBJL2l4b0s1SS9WWEFLcVU2V1pxTUFGeVhEcXlGVklsaTFXRjlDZE1lK1BDbW0yejJvZnFrWTN0Vm5FcGNMNGJ3bk5QVkZPdFdxWnpNVkZDczZVNmFzUENOcDFFd01kRUlwelQ5RThyYWVnT2x4SFBjWldoVFlOUXlRcUpUeTJUcHhyclZGSGgxRS8wZ2I3QWRMemlxaFV0Z2IrSnkvdGx4Sk9LZG9xM2NQVi9DVUFLYXVZdVZIaVlBY2l3SUhrQmp0eFkxR05IQmt5S2Nyc3lKWjgxbUZaUHpRU1FFVUFjOXZmOEFiRit1eU1uZlFRcWtWRkQvQUtwa0U3SDE4dnZmQUJ4YVd3ZG4wVlM2QnVnTUFpUmV3NVIwMlB0aGt6RlZGTmJnT3FNMjBtZjFSWWREL2pjWURCN0RxdFB1TzVZTFRlSEpJZExNUUx5T2NubGpCWjVsS3RUS1ZxZFNreXM2S1ZMTUpEMDRnZzh6SUorTWFrd1hReVR0UFhXbnFxOTJnL1NkRktMenkrOXdNVC9IYktmbGNlaWpOZHBxOVZXcEpUNzFEYjg4YXR1Z0hQY0QyT0NzWUhtY2hBOVNwVllWR2dRMHdpd0J6dGl0S2liZnNaWkxqVmZMcVVySnE4WllWRE9vMk0veGliaHUwRlpOZG1tNFp4RVptbWU3RFZFSkhqWnJneHRIUGFad3JHVTdEWHBrb05YaEFqYTRrV1BtZWQvVEN0cGRqclpDcnAwNlFCY2VJQnJ6YjVGdC9QRG1LcUlYTUJtVVNBeEEwRWlCdVBVd2NZZmtqSnZTTDV1cXFHcXpMVk1Xc0JxTi9QRjdSeWxPWUNtb0pWMlVqbEpPeHZ2di9iQk1TN3dhaVdaaVo4WjIxWG1KR3dqM0dBWXRWYWFVZEx6NHhNeFl4c1o4NzlNWUpKalJWM1ZTYnNkT20wQ1pJQlBtTUJndEh0Yk5OV1Y1Wk5OOVJKSTVXdjA2NEFUN0taRU84T1QzbDFnam9UZjk4Qm1TdGhsSWFGSnBxNEJzTG1TREhuOSsrRktTU3JSSHVGZk0wVlJDVE5yWG4rWUg3NEQ2RlI1d1JpbkVLemFOTENoVmM2Q0RIbk93Rm9rRHBoWjZXd3g3dEg2SjRSbURuS1hFTkNHcDM5REtVU0FaREFscXNHTFgxQWUyUEh5cW16MmNUdEl6SGF4RXpIR3Nxck5xN3RDamJuVWRiRW5jYytXSzRsUzJKbWE2TXIyaTQzVnl6bWxsYXVoNjlGc3RTR3hwVVlJZXBISXQra2VSbm5qdHh3NUsyY3VYSlVhVE1KbkdhaFJLSVdWbVVKYlpSQkgzNll0RzZPRWp3K2pEaHRBVUNRUnpKSUczcE8rS1MyVWlvL1pkbVdCUlgwYUNRQnRjUUxqck1nK2VBTkpyN0JLZEJxb1BpQ2ttWEhRM0k4djk0MWtVckdyWlZNdGwycnZUUVZDUUFvM2lkcDVkUE8rTXRsSXlVVlRGZWNxVWhYQVlhQ2c4TURZamtKM3Zibno2NElzNWNuYUsyUStKVEVQWXpVbThEbjZFL0dNS1ZwU1ovQzZycUEyRzgzMlAzZkJScXNwYWlxazY2aW05Z2szMytQcmdtcWp4cUJTUWRTQlJJTEVnekV6Ymw1NDFnYUs2bEFhQlVndVNaTnp0MCttTXFzSEVsU2F2bGFnZW5LTUZJSWkwYndlZlA2REdsRkEydWgvdzdqRE9nb1Y1YldOSmFaMG5wUG50N0RFcFFLUW5ROUpXcVZiVUNOMU8yOXhIWEdiS2Q5RkJka01zNEdyeER4UmcwUDhBRXp0WUQ4VlVJSWFwM2pxYi93RGtZK2JmR0tISUNnS3pNZTdsUitwWW1TVHpqZjEvdGhnbnRiU01zaUdEREt4QnVaaUQvRXhPK01ZSFVsMUlDd0JOU1F4bllUN1lKZ3hja3lsSHFHRnFqU3VnbVpJdVBtODR4bEcyZVprTGw4d2FmNnU3dkEyc1AxRDI1ZWVGWThsUWJsQzFLcjR6SkpFdE1neWJtZWRodjU0VmdSTlhIZUlOR2xUSk4rY2Y2dHlPQVlZWkhRMmVPWllQb3k5Rm5obWdCaUNJOTV3aytneDlpN2d0S2FXYjFFd0tBcHlBVGRoYTNTMDN4cHBOMHhzS3QwZm96c0h3eWx3YnN2VHptYUlOVmFKck16Q3dNQktlL1FRY2VQbHlxYzZQWHdxa2MzNHh4TEo1YktQbU14S2lxN0RRRExiR3c4N2kvd0RmSFZDRnBJNXNzNmt6bnFOWHoxYk01NnFTQURPcmJmYjBIM2ZIZnhVWW5GQ1hLWUJtR09Zek1oeVNXdHZid3dML0FFUHJoaVl3U2FXVUNJYWY1aS9wM0VHMFg1VDcrbUFZcWRScWw0WUxFU2RNUjEzK3ljWXdadytqM3VhZVdDQkFUcU1FQmVSTWVlRmtQRWh4SmorSXBJdW9BeUZBSWptQlBXK05EbzArd2JNVXFRVU1LYWsyQVpUTUM5dVptSkVYMk1IRGlBZFduWHRxaDEwM0treElrbmZsdGpHS0JxTklXY3NRQk84Q2YyNVQ2WUtBVHBvdXRpM2VBYXR5TEFBRTR6TVgwdzFSaVhKWUFlTHc3UlkzTzFyNFVmOEFpU3p0TUl0T21OUmI5UmIrbUlOajdBNElvUG5LZWpVWHA2cFd6QUVDWU1SUFdEOXhoZ0FwcEt0OVVnRGUvVDdQTTR3bzI0UnhONlJGRE42bnAyS21MZ2pZZnZoWndEQ1krYXRVcGtIdXFqaHhxbmY3dk9NV001VzFMbXFySVFUcmVWRUNibjZ5RGhySUFMaVhDd1AxZUtMVGVQdjBPR0NmVms3eW1RZkROeUFPbCtXM3JqR0NzalROT1dsZGJEYU51djhBRnNFQzdaZXcvd0QzTlZsQ253S1EweEN4KzRQMHdDc3VnVTFDS2xCd1ZKVmhBZzNJdmNmR0F5YTloRkJ1N29rQm1CY3lMbWR6MHR0cXQ1WVZqQldTWXRYck1vSlVMdHpraWJmVS9Zd3JNSFZLeVVleithcHFvRlhNVkZVek1hRU4vd0J5ZksrSlA5Z2x2WlBoaDRqbjhqazZhNm16bVpXbjNjd2RHeHQwQUpQdGpaNWNWeUtZTkg2QjdiOFF5L0R1ejlhbnJDcFZxR25xVjVpbWlpYjhnRmdEek9QS3hRNXpzOWJKL3B4UitjTS9tcTNHODczbFVuOFBUWFRUVFZ0TXdJNm1CZnl4N0VGd2lqeUpQbE5zdDRybWZ3MlFwWkZLYW83alZYT2tmcEYxU09rUmJ6d0lybk5zSXNwVDNmZUVFNmR5b3Z0SXYxMyt4aHlSN1VyTXBxSHdzeEdrSFVJamEzbFAzdGdtTE9BWkVjVjRsU29oalRwSDh5cFVCL1JTRjJueTVEemlOc0xLVkllRVRZTFNvNXovQUxobTh1bFBMVTNxSmxzdlRWU3FxcUpyYVI2QUQxakVKejBqb2pEc3llZnFsYzNSTFVneXNzZzZURW5mMzUvR09oTzFaeVZXaStua3U5cXF1WWN1MXd3TUM1dnk4cDlNTEtWT2g0eHRGMzRUTHNpNndOSU1rRXlvQXQ4V3dZdXlrVkdQWk9zUXRKMlVkMnFyQThNUmMyamtOb3RhK0NMa2NkVUwzTE5SMUJkTEZkQzZya1QvQUl0T01TUGFWSmc4a2dVNXV6RXlMSGw2d2ZmQk1mUFRTa29YTUJTdC9BQjRwbHZyWVc4OFl4N3hDcFd6ZEVtdlRZMFhVTUgwemFJL1VaakdNeE02bWtZUmpVdktrQzF1ZnAxOWNNSURkNVlhUXVoWlV3SWtUUHZ1TVl3KzRmeEdtdEFuTUxYMXN4YUVwekU5YjlaK21FNERLWlZuS0lOZk1haUNPOFl6c056L0FEYjNPSC9JS0ExZ0dlTktxWEFtOEdmUDY0Zit3a3FkSHd4UzB1ZFNnRWYxVCsyTWFQWXhwNVZhZElHb2RkUm1KVnJIdzh5UFBBS1BzSDRwVUlDMkFMZzJXd0FnMkI1QzN2QXhnUG9YZ05VcWpRZkcwU0JhVDE2WDZlV0F5Y2ZZWUdMcXVreEg2QW8vVUlnTjZ5SndQUTZEY2lHcUFHaElxVmFoQ3JJQjJBQXZ6L25FbjB5bVAyUzQyeHFaNU1yR3FsUVFVL0EwaWY2aUNQYkFoK29QWnZ2K2srWFhNOXQ4cFZNTlF5R1RiTUVBV0ZSNUZoOTc0NXZNeU5SMFg4UEhjN1B2K3NQSDE0aHh4K0VaYXFXeStVQzBuSUlBTEM3ajBKTTh0aGhmRHdwSnpmWlR6TXlsVVRHMHROREpHcVgwcUNSVFFnQmpGd1RQUCtiN1k3RWNRdXFLK1lyOS9WY1BWWWd1dzN2dWZqREFCYzM0RkswNHN4STA3RWVVSGZyNzRJMCt5L2hmRG00dFhxcjMrWG9VS05QWFdxMWlWQ3IwQUYyTnRoME8yK0FwY0FZb2ZGamJzdFNkT0daMnM2NkJtWFdrQmFZUUFuMk1pUDhBMmplNXhQTTdhWlhEMHg1bXFvb2NBb0pUVWp2TXpWRHp5RWdiN2JDUVIwd2lqYnNyeXFJaXpacDFxOVdtVkJrblRxTmpNYmpyL1lXbStMcFVxSk4yZVZKVmxxdTVKUThvc0NmMzV6Z2dJVmFnVlFFa1dCR2tqMDJ0eXhqRU05US9DNVBMMFVwaG1xbnZTcE13dTNYbUkrUGZHTnhzcHllVnJFbHRUV0o4UXNZaTErY2dZQnVOQmh5N3NGcFVOS2FtaDUzWVJzT3ZNQTROMXNLVnVnakk4UG9KUnJabk1yT21ZRlEyOTc3Q05yekdKT1Z1aHVCS3BUcXZsQXRLdVJScVVhbFlxaUErQUtUYWR0NGdkZkl5eVcwQnhTUmpxRlNLTFRUSWZTUzB3dHp0RnNWT1NQN01GTlVzQXBCT2xTYm4wdmh4aTVLNXBnaFRFbVNiWCs5dmJDR1hRNHpqQVpqTVNRNTF1QUFoSVdXTy93QTQxQUJNcUZGZWlwcEIxMVFCQUFzT1U3akRCR2FNdE51K05JTjQxZVNJbU9SK01CaEpMWW9TQ1hKTWsvcUFNbi9IdmdESVhjVnJLYzAwcW9SUXFBUVlBdnQ5OU1NaFdEWmRwMWFocEphd0l2Y0dBUkcrK01CQkx1Z3BFTVFJQlVnTWJzTDJQV1A0d2ZRUnB3NnRUeXpMVnFJckxSUXRZV1ppcGorLzB4SDJYaTZUQXNqVGVxMVN1NHVIR3U1RXN4SjlJM3hub2xCYWJadCt3SGFTaHdESTlwODRGSDRzVUZORVZFOExPV0FBSE94RTM4dVdPVHlNVG5KRi9IeWZqaTRzeWxJMVRGTTE1cVZDYWxWank1blZ6TW43QXgxS3FWZWlMZkp0bm5FS3BhbUthTUFpandCMVZTb0lzYmVZQjkvUEJGSlU2ZmMweVdIaENpWWlWbjdCeGpDYk1PdFJyS0ZUVGUwa3IwRWRGa3piWTRJMHpROFR5bzRYMlo0ZlJ6QTBaek9rNWlvbmRnRWJhUWJTTkkyL3pkRkpTZWlqZzRJYWNGMUp3YkpLbE5nS2xiV2RUSG1abjBKSys1d2o3SzQxOFdCVmN5R05DZ2FRYnVxanN4MUdEcWx2cUNKOU1aUmY3QWowVjUwSlJjNjFobE56cTUrdnB6OU1WUVZRRld6QzFhaXF0RmxsV2tPM003RzNxTitjWUVpYyt3dmgyVldyVGd4VVZQRTMvSDczd3JlMEdQVFBxNVQ4ZlZKMFV6VGhhWkRTREFNbjB3NkVmWmRTRkVwVEMxQ2xKeDRaSml3TUQ0bS9XRGdtUEtyZitvZlRVUDVSS0NEK29UWWJ3WUxSODdSZ1ZZWXVtQTVqTU5YcnB3K21meVhQaWxaa3dmMzVEKytNbzdBNTdHT2F6QzVYaHJaanZoVW9LaG9VVklLOTdBRWtlOGI3d09SeFBIMnpPZXFNYzZhQ2l3RzEyZytQbnY4QWZYeXhjNXBGVmRERXhNeVFOTWJiL3dBWXdUeW1vWmZFckVxU1BDUDg0d1JsbW1CemxSQVdGUnFyQ1o1Rmo4V2orK01BalQwdFVMR05LeTk1NUQvSTI4c0d6QnRCbHFVS1prZ2dxU0EvTzQ5TGcvR0FNZ2xkRGswNEJNNmVzQzh4OTlNRkdGR2I4VlpnRWtLVHBrRTJFeDk4OEVWM1o2aTkyMGhkTGd5cG1UcXVkL1Q1OHNZS3YyVk0wVkFxanh5WVlub2Q5ajB3ZlFRajhRM2NWYWxRc2Iza0FHNGszR0pMdGp5Nkx1QjFUVnpOS2dDU0tvTUJSTnhKQkhUMFBuZ3RBajlGVkhNUFQ3K2xQZ0RCbmpscDJQbHYvdmZBcXdQc095TlJhV1hyVnFrcTUvVVNta2dIZjY0SFhReTFGMGVNRFZLSTBoZzJwZ1JNRzhUWXlESDF3clpsMldjVXJwbDBTbnFJVlFKdVpVUVJCbmVldjdZMFczMkdhUzZBZUJjUGJqSEdzbGtGVXMyWnJBSHlTNWIwR2tNZmJEU2tvUXRnakZ6R25icmlRNGwyaHJLcmZrVW1ZVWhwaTF2SUcvSy9MeXZMREJ4alpYTk8ya2h6bDY1cHBrVmxnVXBpWTY2SUg4Umh2N0hXbFNFQ21NM1JDeVdWZFg2ZjZpTmhISStIMG5ueVp0OGFGVGQwWDhWck10Y3RFSVFMWEg5L3YweG85R2sybm9od2ltS3owaFUwTlNJTk45UnZCL2lUTWprZkxBbUwyOWpvR25rTW8rc2dGUXpFSG90dDVucjE1KzBiZGxVa0xLYTB4bEYxQ0ZKTXNlVzIzcmY5N2JZdkVTYVJHcFdHb29raGsxRlJlOXBnZTlzTVRsMEE1ck1KUm91NVZiazNGcE43ZVVYeGtKYkFlR0ZxdVpzbmpxT0ZSWmkwWE1td2kyQkp1blFGdGpMdGJtNlp6bERMNWVGbzBLWTBxRmdTZ2drZXA4dHNMalZiTkxRZ1V0VUtxcWg5SWFKaWJmekErWnhVUmtLeFV3TkoxYzlYemJHRmsyWEQ4UWYwMHd3NnNwWTllUmlMNHd4ZFhnNS9Nd2cvVzRKRWY4aUpuMHhqRTBKQ001TUFLSUpFYXZVRDIrbU1Zdnl0WjBvMUMxd1dQaGlSWmZwY2ZYR0dRWFJxQmMyckxZckJJaWJiMzZXeHJDa1VtaTFNVlVhQzZ3UE9SdjhBdmhrYXZvalRCV3RXcU9IQkNUdEIySm40NWVXTUJpOFNkQWRXdFRLd2dGd1JGdXZyZyttWXZ6ZEdNazdvcFJVcUJYQXZZZ0d3Kzd6aVM3WldyVExPQjFLQ2NUeXpPQXdXb0lHbUNJMmh1bjlzRjlhSjQ3OWttZWxVelZiUUg3b3V4UldHa2tHWSt4MGpDcS9abjJXSVVWZEFCVnRRQmdtVkcwZWQrdHIrV01HL1Fka21wVTJZeVFRQUZneVo5Qnk5YjR6U295N0Z2RWFvcjFrTXN4Z0FrTFpnTFcvazQwRWd6YkhYWXgwNGZsK0s4YXFBVTZsQ2cyWG9qclZxQWhpTjlsbjNPSlo2bStQb3Jna29Sc1c4S3kvL0FIRGkxQ2tDUHptMUhYTitadjB2RnB1UnRpamJTcEU0cE4yeGhuYzRCeFJrRUlDM2hNVFlDeDkvNzRWZElmazA5OUFnZFc0ckFOdElKRzBXRnV2TDYrV0MrZ3AyMnl2aVdsYTZKSkIybGJEOUlzTGZmcmd3NkV5TjhnM2d6TFJBUmhLUFRhbVZLa0NRUTEvWVcrY0NSb3YyRWNXcnFyS0lOUURRdGdmTWszQTZtMkpSU2ZZM0pvZ09KWlV0b3JVL0hxMUFxd2hTTFFSUE9Sc1FOOE8rWDhRdWNhUE9KSmw4dFZmdTNESUYzTmd3M0VlUitodzFzRFNhTXp4Q3MxYXZvcUVGVGNNWmlZdWJmZHNVaXJWa1pkam5zMVRGS25tK0tFMnlxNktJWlRHdGdSZTI4bWZNQTRWOTBORkxzUVprclVxc0NDV1FoZFIraDk0bjN3YnJvbk5zT3lkSFNuZUJWMVFZTURVdmhNOC9QR3RoaXI3QWMwZi9BS0xNQ1EwNmdiVGVZNjJ2OU1NSkpJK1FWUWc3cXJZM09seUJQc2NZSmZXV2N4VmdqUzlWbUFBMzhSR01ZK0FZVW9rK0lSQjJqVlBMckgweGpCZVRJaXF3SGkxYmczSkEzNmRQbkdERjNZYmtpSy9mczNpaVlLRzgyVTI2NHcwZGhUcEdYcW53SFhxZ1FMYmlCeWovQURnVzdvcDBoWXpFUHJwaEVOUzRBQTVzUU51bGo2WW85RW0yeGZyT2tFaFZJQmc3ZytHMC9IcE9ONkFQTWtxMWN2bUtXdEZvdENNcld2TmpQdGlON1owUTlpemlXU3FjTnIweXpPOUpTV1dwcDJNM24zMndiSjIxcEZGTndHRFN6RFR2SU85eVk4emZyYkd1d09xdjJHNWFxSFdzeHFHZTdKTExhQjZjK3NZQVlxMFhaeW9hYU1zQUhRU2RJbVp1ZmtSakI0K3hPemE2Z3FGOVRFaGJwejUrdHNGYTZFYnZzZjVwMXlmQU1oa0FTanNUWGJTSm5Vdk8yd1VBaWVubmlVVmJzcE5KS2dqczRweWVTYmlDUTFZdXlVeEZvSUpueU5wNW5iQWxKOHFHeFJUallIVDdyT0xVcEdhZGRBcEJQckV4enNUYisrS1VqU2Q2Qjh0VXFMeEVxU3JFU25oSE1Hd0h6MTU0MHRJV09uUmJ4Wlp6VlJIMHRUQ3NCYVFzOHo4V242NEVPZzVGN0d2QU1pTXhYeVZHUVZjTzd4S2hnR0lpKzFsd01qcEJqSGRlaVBGODBxY1N6VFpkWFNpRHBSbWlRUnozOGpqUWpTdG1sWFNFR1dxVTh4bmU4Y3NyVExEa2ZubjlNUGZGT2lDaHlra05lS3VLVkRTRHBBQTBJWjhNSFlUYU5oOFlXQzVLMmRVb3FLcG1iaHN6V05OUWhxMVNSQW0zbjZYbkZlamp0dDdIR2Zxakw4RXkyVldzOEZqVnJLeDBnbUlXUi80aHA5V09GU3RsWjNGZkVENGRRL0VaMm1hcHFScVl1NUlNcUxRSStEZ04wNkpwTjlqR3IzZFJEVDhmbVNoQUppNWlQS01FWmFNOVhrcFNrS3F5UU5OT1AyMy9BTTROaVNQdENFelVjZzhvWUczeGdoRFgxRE5WdzRXQTdoZExYdVQvQUx4Z0UyQTBnaEQvQU9WNEFrZ1Q2YmdZeGozaHdVWmR4Qk5waHVrYy9uNWpHTXRCT1NZMDh0VlRVekJtQy9YYnl4aG82RDNmL3dES3FsU1FTRHVJdWVYMzVZRmJzZHkwTE0yeHBzcUZ3K2tYR20zV1QxbmtNUGRra0FWV1ZhQVlMcE56RTNpMXY4K2VHU3NQUTU0RFVGVVBUcWFlNllGVHVJOFArTVJhcG5SaTJyWXl5dFNpck53M2lMaUIrbW9RU1hVaytMYmxmNHdzbTB0QXFub1E4WjRjK1NxanVXUjZURTZIQk5ySG55SUU0S1lrb05iSjVlVXBmbUhUVlFUR3FZRjQ5Y0VhRlVWWjRwVnFBMHl3MVdSVHVPWkZ1ZDcrdU1MS1ZGT1VwbXBtS0ZKcENYSk0vd0JQOXZNY3NZRVkyR2NZekRaak9RdEx3ckZQZTBiQWI3WHdzWTBVeU5PVkljVkhwcGxPRzVKYWpCRm1xOEVmcWcybjBKK3ppUzI3S1Jpb3FnYk1yU3FCVlY0cmlGZGdiNmZzbTIyTENQc1g1SDgzaUtobDNZaFROZ2JqK01DWFFxN0RPTkg4NmtoRWcyRW13TnBXL1QrY2FIUWNuNmozc2pWR1c0THhMUHRvUGRVbHBVOVg5YkdUOFNiZnhpZVJYSXRHa3JNdm1IZGFUZUFzckhXU3AzUElEbkZ0amVKNTRxbnBMNkl0VllGd25VS2xPcFNMYXBHMFd0dnQ1Yll6WG9uR1BKOTFSZnhUTW1yV2NLeWdEVWdubnpuNU8rTkJLT2pTYmI3UHVFWllNU1RUQlp4cU9xMmxRYi9JajJ3em9LanFpeDhzY3htWGRoRk9DQ0NQMVg2Vzl1bStCZEFtN1kzeStXU2hsd3VXQ014SWFRYmxvSTI2anA1WW01ZXlrVXFZdnpBWlhKaW9yaWJYQWliaVpqbFArc01uWk42RWVhWXMyaGxZQlpKQmFEdnkrOXNQUk9SQm0wUURjM20rMXpnbURtQ0xuYXpWRnNLenhJRW01eGhWS3l1dEt5bTZCcEVHK243SDBHTU1FWlNwcFI1VnRVMmE5dHZweUp3YUY1Ym92cEJ2d0ZSVlF6T29DRDhHZm5BSHVqd1ZDZUhkM0pKMXpJL3E1SEJvTjZvRnpiZDVYYW9GTU1BUWRVaVk1K1IvakJXaGFLMDBzQ3FyWnhBSjUrWHdNRk9nMWFvdTRNekxVcW9UQ2tHRDFhTGZjWVJyMld4eTRxaC9uRWZQWmFqcEEvRVVCcFZxZTVCdWQvUUg1R0o4dnNlU2ZhRkMxM3JxYU9aQlpRSXFBRVd1U2RKNjg0eGxIK1ZrK2J2WjQrWFNpRFVVK0d6QXdMaVJNZE9YMXRoZ0xjaW1xekYxWXMycFYvVHk1ZlczSzN4akFtWFpSVkE3NE1QRXQ5RjRuZjI2NHcwRHpKMHpYemVYR2xpdFJ4T3JsZVQ2MkcyRmNxRWd2bWh6eEp0UVdxOU50VHMzamFBWlBJOU9SeEdIWS9JR29kNVd6WTd4Z0lNRWtrellrWDM2L1RGMERrQlVTcVorQ0N0eUNDSU9rbTlqNWZQWEFrR08zWVp4MWlLdEl0cVpHVTJucEVnZFFaM1BuMHRzVzlEWlAxQ2xjLzhBNGJ5Nmg0RlNzejFBSklQSVg5Smo3T0ZiK1ZEZWhGeEJqcGdpU1dpQ0NTRDc4OS9XeHhYdEV1VldWVXFpNlZBc3NHR2R0TmdJSHY4QTJPTlF0a0VWbWNiaGlET3Era0MzdnY4QVU0RGpZdGJIbVFwRmNuVXJWUEFqZ0taMkFKTUFjcE52aWNMMHlxMHJKNUxoOVoySTd4QlVndHZBTnlienRhUHBncVZiQWx5bFE1ZGNwd25JT0lYTVpwcmwwYUFreDlSZjR4S1NjbVUvVlVaM09aMnRVVWFxbE1NUEZwbjlSdnNPWE1tZXA2NG9sUkdURU9iR3B4cU0zSUVOUFFDZnZwaDdKeVpIOE05Y3MxTldjVEJsd3NIcEdDRVlNTldjWU1zVFZZS1ZicXhpY1luQWxtUVNZSzZTN0ZwUXhlWTl1ZStNVUtNc1ZOVlNVQkpOdkR0YTNvWi9mQlRKL3dBbU1XTHBscWlnQVEwc3kyTFhrR2Q1dnZnWHVpakJGcm1OU2plNEF0WWJjenRiNThzTlZCQTlaRlptTEVJcGsrRzRJNSt1Q1ltckZCVFlobEFJREFpKzNwNmZHTVpGandsZW02SUZCaVJFOHZyZ1ZZeWRNMVhEOHkwRU00QWhVYm9DTm05dDU2ZW1PZWNYMGRTMnJJOGI0ZVhZVmFla1ZsTEh4RGUrM24xODhDTXQwSk9HckZDdlVxS1ZaQW1tVk5vaTF1ZitMN25GTEpxTk1xcVVLakpLS1NnRUJ0UFV4NitXTUNVYkp2VUNVQ3FsZThXeENqbmVSMFBRNElJdWlmQjZUdm1qVk5NbWtpa2tydkJzUHJBOThUbUdIN1dNYzR3R1dCQVVoV0pMQWpVUnR2TzBFL0huZ1JnMXNCUTFFcFV5N0h2SFVnZ25TUkpJQWp6K0xSaWdCY29qaUJjL28xWEkzQUpreDdEQWt0V05BTjQ2eTk1bGFzV0tPTGducEFpZHY4NE9KVTJQbDZSN2w2N1BsYVliVU83SklFbGdJQVB3QVRHRTQyMndwOG8yS2Mwd0xLcFVnNmlTV005SjkvdStLUkl5N0I2TlRUbGtZazI4Vjk5b01kY01BUDRhbE5xdzd5bHBRTUxMNGpCSTJGcG1TTnhoSlBROFkrelVVUDBLSytYcE1CNFVXcUE0cDNBSkhVK2NZZ20zSW8ybXFLNjFLbWFUc2RBcTZpTExKbVQvQUNCR0tLL1lpVmJGT1hPV0xsc3d6aFdJbXh1UGJibjdZWlVEdVNJWnlwUUZNVUtGSmlUSmRvNWVjamZlM21jTUdiaUpIY3FLbTM2eUdXZHhITWZJOThHaURWbnFVaTBzVVY1Z3krcWRoMEdDRU1jTXVhcU9WQTBWSG56Z3o4WXdrWXRkbCtmYVFia0tGQjZXUDJQczR3NENsUWlvVDNwRFNOTFRwRzRIMk1ZbXYyWXd6RHNjdFZZSWRKYVZFemNtQUR6TnJZRmJzb0FJMEZqRnBONCtoK21IYk1DaENWVVFzWGthZHpFejlNYTBFdG9xVnEwMGN0dU5WcitucVJqQkx5N000b2szSUYxSGhCQXdSbzE3R1hETTJPOVVrL3JBRmp0djlNU2xGOWxJeTNRK3l4WE41SHVOUUZhbjRpd0pHb0M4N3pJL2JFS2ZJdDJVMDB5NjFtVFBVbE5GaUZxdXFqVWg1T2gzaTl4aHRnYXRBTDVkc3RUclVIQVoxZ0UySWc3RVJzRFk0eXNrMVFwcnlNd1VCMkJBWW5Uc04vajZIMGlwSnFocHdzQ2x3NTZ5TG9OU29GREpJa0RZL3dEMjRqT1E4RXlGUk5OSnU5Qkx0L1NZT3FiY3ZXM3ZpbGc0c2hseUdWQ0ZhR3RNTkpQN2VYeGhoUmRUQlRPa0dUQklZQzVrZzdlMERHZTFRMFhzTjR5N3ZSeUR5RWxaZ25uekk1UmJiNXhvZkY3R3l2NG9weWxjR2t5RWhVaWZDZGhhSkcvbDZucGdKQWpOS05BUEVLdy9FZ01HUUlSSUtpUWQrWFA5OE1oRzluaUZxaVVsU3phNUlCQm1QMnRPTXhXelE4TnlrMGhtcXhTbXF6M1VLVHEwa0N3R3dBdFBVeHlPSnlhUjBLT3JHbE9sVmNoUlRaaVNFVUFreE05T1huaVNkT3pjUzE4am1hbFFlQnFZL29KRnlJMzZqRGMwWnhkQURjSEtzeFJhd01pNEpISXhiMHRIcmc4MEtvUDJESGhyZHpKcHNRS2szM2pwQTUrbUhVcjZGbmpSbTh6SWNxaGM2V2hwc0Q1anpuRHBwOUVpaFZycklvcVhFK0tPUjZmc2ZmQkNORmxNem1WcDJMTTRQbjRyZmZyT01BaG0yN3lrZ3FxU3RTbk1UY2JYQTVHMS9YR01DcktrdDBJTXF3UHg5N2pHRVhiR1ZSU010Vkowc1FzYWlJRy8vd0RvNHc0R29xTGxpRlkzQUZ6SU5qejM1NHhpSVVGRWtxSEJCOE13UVRCKzdjOFlLS3k0TlpkSjA2ZkQ0VHNOdmVjRkJMZE1Ha3hFS0FMSGtRSUk5UDdZSVVmTjNkUE9GNlEvTFlobUViaVlNZE1iWHNaZGovSjFsTDAzcE1kWm1SY3d3TnpHM1Q1T0pTWHRIUXVob25kMTZRMGhTeEdwZEl0STVldlQyR0oycm8xTW9xSXRXaFBkZ1ZLSVZRZ1lhaFR2QWtieGNlaEdHRW1KYzBvcTBBRHBjSkJnUkIya0NPVi91TU9SbHZvSzRUV1FaZEtETkJQaUtIZVJ2NkRuNjRqT0xmUThaSmRocm8xUUl3VjVxQzF3UmZyMS9zY01NNHRkZ0xEOHhtRGFTQkRhT1I1SDAyR0hSSmkzTUdtT0pXRE10OUpuWXR5UDN5d1FMc3M0d2RkUEpLektyNlg4U2NnWU52akdEazNGVUxrcXVYQ3ZCY2hwaTVMU1FQbkdvVlBSWG1kTFY5UUJpYnhmWVFmNWdjc0ZhN013ckpMVFpGTlhXc1JMR2ZYYm5OcHdiTWw3WWUvRSs4cUR1YUljb05JMVRLeDVjOXh5R0oxOWpwdm9Lb2Y5enF5YVRpalNqVU5IZzg5OXhjSHl3clNZeTVQU1F5NGZ3L2kyY2Z1MXIxSDdzYXBOY2lBUVlKQWtteHQ2ZVl3amNZN0cvSEo2WjVVeWVWeWIxS3VacnRVMVJMVktoQUFtOStmUHIwR0NuS1MwaEhHTUh0aXpPY1hEMXY4QTBxTWhEUnJlZFJONFB5ZC9TWnhTS29uS1ZtZHpjR296S1ZsZ3luMXZOc05GVjJBRnFrT1FXMGd4ekJNKzR3OU13ODd4VnpkV0ZrR3EwQTlaTy95Y0FCVlVxYTh2U3FIOVFZR1JiZkdNQ2hrWUJWU3lzQmN4RW5rT25QR0ovd0FtTlhKN3BwdmNLRkprRUc5L0x5eGlnQlVxSTJYcEs0OExNQ3dqMUE1K1gxeGpIMllwaWtUSS9NUVJHNHVBZDdIbmpCUkYxaHFnQ3JFd2ZQeFJIcEFHQ2drNFlJclZBSUpWWURIbU52NG4xc2NFS1BkSkNxMm95S2dtQkVneVRqTTExc0w0WFhkS2E2aVNYVVZBWjJONyt0c0xWbFl5ZERqSVZ6U3pWU2l3dnA3MEVHYndQNzRrNDdHVXJkQnJvV3BoMUtxNm9ET21aWHhMZnp2OFl3SjlDdDFUUXA4VEkwK0UyZ0F6cHR5djhZY2lCRkhTb2cxZU1OcVZ4YXc2ajNQK01ZdzV5N3JuY3RScTBoM1pjSDJJa3p2Yi9PSmpSbTVkZ3RTV290bUZKMUR4T0Nkb0VrcjUzdzZBKzJKYzB3WE5Ga2dsVi9xVVh2djYySHlmTEdBZmNZcmErSDBkS2doR2J4bjlYSzJHUWZRdkZ5V1NkV3BoSjZtK0NJZ25obEZzL1hjaU83QlZtRG01RWVtKytBelBzdlZ6V1ZtSkNVYVFqU28yWHlFNyt1QVA2Q2FlZmFpQ012UnBMNHBEa1N3bUFEKzJNbFlMb3FUaU5kaFNDdUFqTW9BQS9TWW14NllLZ0ZUYUQ2SEdhbVJSMXlWSUpVcUFCM0x0TGVGamlUZ216ZmxZdXpPY3JWOHorY2Raa0VqVllremY2aitNTWx4RmJ2WU4zZ3FVOWFycDBnc2VwOFJBTnVlR0ZLS2hEMWFhbG0xTWJRQUJZNFl3R0txSVdEbGdTU2ZDQWYzdzRULy8yUT09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9OZXd0b24uanBnXG4gKiogbW9kdWxlIGlkID0gMjk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVpBQmtBQUQvL2dCWVJtbHNaU0J6YjNWeVkyVTZJR2gwZEhCek9pOHZZMjl0Ylc5dWN5NTNhV3RwYldWa2FXRXViM0puTDNkcGEya3ZSbWxzWlRwRmNuZHBibDlUWTJoeUpVTXpKVUkyWkdsdVoyVnlYeWd4T1RNektTNXFjR2YvMndCREFBWUVCUVlGQkFZR0JRWUhCd1lJQ2hBS0Nna0pDaFFPRHd3UUZ4UVlHQmNVRmhZYUhTVWZHaHNqSEJZV0lDd2dJeVluS1NvcEdSOHRNQzBvTUNVb0tTai8yd0JEQVFjSEJ3b0lDaE1LQ2hNb0doWWFLQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0NqL3dBQVJDQUUzQU53REFSRUFBaEVCQXhFQi84UUFIQUFBQWdNQkFRRUJBQUFBQUFBQUFBQUFCUVlEQkFjQ0FRQUkvOFFBUGhBQUFRTURBd0lGQVFZRkJBSUJCQU1BQVFJREVRQUVJUVVTTVFaQkV5SlJZWEdCQnhReWthR3hJMExCMGZBVlV1SHhKRE9DQ0JaaWNpV1Mwdi9FQUJRQkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFEL3hBQVVFUUVBQUFBQUFBQUFBQUFBQUFBQUFBQUEvOW9BREFNQkFBSVJBeEVBUHdCUVVrbVNNZWhGQlhXbkpBM0djZk5COGtncVBteDZVRjIyeXVCekgwb0NMSVVvaUVKTFdaUEovTDBvSkhXeW1aQkNoeDNvQjl3bkVHZWZ5b0F0MGlNOXBKeGlhQVU4a2dra0dKeDhVRmZtRWlBUjc4MEZoa0tDUXJPUGI5ZitLQWxia2owSjRqaWd2dERqdEdNbWdzSkVvQWd5Y21UKzFCNlJPQVlQeFFlRTh3bythUklQSjlLRHhNR0RHRkRCQjUvNm9LN2lRVUszQVFVOStmOEFPYUN1dHRVOXlKN0QrbEJBODNJbmllNHlLQ3F0c0FUUGZ0M29JRklnU0p3Ty9OQnlCQXdSSHRRZEpPWlBsOWU4MEVxZkttQno2aWc3VEVFQUNPUFVpZ2tSQVZPY0RrZnZRU2hKSUhQRkFhU2dnbWVUMjlSUVJMUU1rSEhFSDFvSXduak1wbnVCUVdiWUhjQ0lIcFFGYmNKQ1Q4aWdzdU1nZzdZamdRTzlCUnVHK2Q0NG9CRjZ3Y2pFVHp4UUJydG9JQlVvN1ltVkhpZ0RLMUN6OFFEeDBHUFNndE5YdG8yMGY0NllpWVNjL1Qyb0lXdGVaU3ZhMmdyUUIvTnhQelFUdGRWTm9lUUhiZHdBL3dBd3ppZ2xlNnR0bXNOTnFWajRpZzRQVnJEcVREYmdVUmpnajg2Q3phOVIycFI1Z3NFWnlNL1NnbVo2anMzWGcyamNEM1VLQXEwNjI4QnMyd1I2NTk2RGwwRWdRQWR4eHRvS3JxSlRLSVB4ZzBGZGFOb0k0Qno2ajYwRUMwNS9zYUNGWVBlTTlxRHhNZ0E1Qm5qMm9KMHpuSDlxQ1FBa2YxNW9Pazk1R2UwVUVnQkl5aVQ2OFVERnRnOFo0eFFWM1FNRXlUMy9BTFVIQVR1VVRoUmlTTVpvTExJSUdUT01mMm9DZG9FL3pBY2pFeElvQ0NVN2tCS295SUpCNVB2UVVycElRTjY4Smd5b3dQOEFPMUFrOVNkUzJ1bnJVMDMvQUJYT0NsT1FERkJuMnA2Mi9xaXlsMWJnUVA1QmhOQlNXd2xJVHNCVVk1SjR4UVhXR2ZFYlZ1Q3Q2WUlVazU5NkNCOXBld0VxS2dleG9JV1hWQlpTb3BLU0pCSmo4cUQzVUNVb2FXMkFGbzVqdlFjc3Z0ditKS2RzSmsvOFVFN2R5R1R0YzNCQndZUEZCMG9uY0MzSlR5U1Azb0ptZFJ2bUNoeGwxYUl4Qk5BYzB2cXA4T0FYNVNwb25Ld25JUHJRTmpiemI2RXVNa09CUTNZRWlPZUtEeHhzQUtqNW9LNm00amNPM1BGQkNwQmdFSGp2UVJLUUNvWnozN1VFcUV4Z3BuT0JOQklDQUNUejJpZzZDVEhzT0tEMmR1TjBmcFFNeEU1SDA5NkNxOG1WQUNDRDNuOXFEa0ptSU1IakZCWmJCZ0VRcE1jeFFFcllnSlNGam5CN1FlMmFBWDFQMWJhNlN6NGJTZkdmUDhvTUFZNE5CbHVxZFQ2dnFiNno5NFdsQi9sUVlBOWhRUldlbVhGNjB0eGhFa0RQclFUTTZYOTNDZzYzSzRHVDJvQ0owVmxGcXBlVkpBM0t4bEFQZUtEMnoweFNyUU5GS1FwVUZKN2tFLzVpZ3AyK2tPM0tsa3dHR1NwTSs0ekEvS2dwUDZZV3JkYjZXNVFsend5VDYrbEJFL3BxMzlRRnUwQ3JhTjVLUng2LzFvQXpqSGdYUklPNVV5SndKUDhBeFFYRzJDb0lKUXJQNG9IYWdyT2hhTnBUSlNGYllTTS9GQkl0WThBa2ViZ2lUK2xCd0hOdTFKaFJ5U2s5eDZmU2d2YVByajJtWEFFcVV4TUZBeUk5UlFQMmxhcGJYeWR6Ym9uMFBOQmRjU3FWVG52QW9JRkpQcGprVUVVQ1pnNDdqTkI5UGtCSWo1b1BSa0RNamlnbFFuSEdhRHNOak1pYzRrVFFNb0dCR0Q4VUVDMFNmOTFCeHM0QkhINlVGaHJhQ0pJb0JQVSt1RFRMRlcwamVjQUF5VDhDZ3gyK3Y3alVidFR6bTVLQ1lnS0pJb0dIUW1Va0JEcGF1RXhJV1FRb0Q4b1Axb0x6bXVmZGt1TW9RbEpTWlNRT2ZuM29CN0dzT1hTRW9jV1ZMa2tGQkdlOUJjdU5TTnE5NGJMeVZ0M0xZYVVrNEpFZ2o2MEE5elZYVXZpNGE4bmdnREJuYW9FeFFIYlhWVlc2K243VTdqLzdIbmlGY3FXT0pvS21tM1pkc3J4TjBUdEpLb0l5RkpWSFBZekZCZnYwL2NMNURqQ2tlSTgyMnlFeElsWmcvb2MwQVovVGxLdUE2Mmc3WFgxQktvd1FEeVBiRVVFVHpPMWhleVZ1clZBVUFZU1BRZXBvS0M3UHcwbnhFcTNubU1BZk5CUmNCTEtpc1FrUW9Sa24yb0kxcFVMZHRSVDUxYnBnU1kveWFDdW9GUi9DRkVIOGNVRTlrODQwMmZDVnQ5RnBQQm9IUHB2cU0zRVcxNENIWkFTcnNhQm5Xa1RPRFBxYUNKU0NEeG44aFFjZ0tCUG9LRDFPVEpFMEVnUEdlL2FnbEFCNVVmeUZBMGJaQkVIQWt4eFFWbGt6SUlQWUNLQ0xpTmg1N1VIbHc2aTN0WEgzUEtoQ1R6UVpMMWhyNTFTNjhPeUNvU1BPdU9UNkNnSGFUYVhvZFM0Yk1yYWtCU3VhQjcxSFViZlQ3SkRTYkZyWXRJa2ptYUJFMW00UmRyVXRsSUNnWnh6UUM3ZnhFM2FDaE8xVzdnY1VCZTFTdTVkUW5hVkRLaHRHWm9DbHBvZHkrWFF5aHhRZDJuYWN4UVg3blNMMHFaM3RLU3R1VWoyeVAxb1BYdEh2RXZxUmtELzJrQStwbWZmdFFYZFlhZHVOU0RvYmNMVnZzQ0FVNWtJNTk4elFjdmh5MjBkRFN5cHRTMmlzcndEQ3VQMEdLQ3piMktubjdScFRZQ2tvU2xMUkVKUUNNSlByUEpvT2RmMGtOS1dscG9sbE1sUzBpQXFJQmoya3dLQU96cERZczJuSFZ3dFpXNGxJejVSaVk5T2Z5b0JMbGlxNmUyc2tFaFBtUG9CMkh4UVZMaGxMQ1FrZWFjQ0RranVZb0lIUExrNFBZUkpOQjYwcndWdHFRbFpNOWp4UWFSb2w1OSswNXRaSUt4NWZpZ3ZFYnNrRWp1YURoU2ZYTWQ2RG1FZ2hVOCsxQklpWWlJTkJLRlk4eEFQZVJRTXpvT3djR0J4eEZCWFdSZ3lQNzBFRGtpQVNQVEZBaS9hTHJTbTl0aWhRQTVYUVp0dkszZ0Vna1RNQWRxQnowMTVEVmhMcXJ0ckhQYWZnODBBblVOWmZVNEVKdUdybHBCSVQ0cmNGSTlKL3ZRQ0ZYTDdpbEdSSE1KQUEvU2dhZWp1bGJyWExnQUljUTNpVnFFN1JRYlJvM1FGbmIyTGFXd2xEeVFWRmFreVYwRHRvblNWbzJVRHdFRUZCbkdVbnRQNm1SaWdLWDNTVnRlSmNYY0lQakpSSVVFNUJBak5BQ1gwT1VId3d1VkxBVHRSbmNtWk1rOThjVUhGejBKYnQ2V2xaYThTNFVuY3BHVW5lU1lUSDFINVVBVy82TDhCZHFxMFlTOCtsYVFwTGljYmdPODRJeFFMK3M2TGUyZHcrTHR0OWFsQTcxcVA0eXJ6S01qaVovdFFBZGVhdVhXMnd3blloS2RvU0JHNGdSSkhhT0FCN252UUkxN2JYb2NXcGFscHhCVUo0aUFQaUtDdUV1dHRsbEtWVEVUNmpzUGlncFhIaVNWcUFDakdkMDQ5UGFncUlYSVZDU0Q2OS9yUWNsYWdza0FwMjRraWdPOU02a3F6dUNoU3dHM01FR2dmVUtDa0JTU2xRVmtDZzlXWlZ1U1p4UE5CNEV3TXhuTSt0QklsTzRRY2U2dTN4UVN0Sk93UVNuMklKb0dOYVFFeXJCaUJuSm9LNndaeEJ6R1RRVkhqRG1RTWQrMUJpM1dyNWUxMThGVWdVRmpwYTJhRnlIblhraUlKRVpvREd2M1NMdE93dUoyeDVRbVpvRjhhV0N5cDF4S2xKNEIzVUJub3JwYi9YTmFidG1Bdnd3cnpyaUFmanZRZm9mcHpTTGJUYlZERm9ncVR2MkNEK0tPU2ZidFFPdW4yNEtQNHU5S2Nmd3lpQnh3UGVnTXN0RW9Pd1FtTndKejJ5UFNnbFF3KzYyWFZKY0tFd1pFOS9UMC9hZ0lXcUVJYktGVDVSTytKS2lmMy9BT0tDSzZpVWxXMG5nZzV4M0kvenZRVkx0TGJqWTNsUzRBTW5DZ1BURkFJdnJBWEZ1K2hiYmFZbFcwQ2MrLzE3L05BcHY5S1d6enJ3V2c3andSQWc5eVAyOTZBZGQ5Q053NnByTGF3a28zNWp0UHhRSjJ1OURCaEhtMkpVQ1RIQVNhQkoxYnBzc1FFdDVpWmo5NkJPMWpUM2JPVnBDZ2dIMDQ5alFCVzNuQzV0Vms5Z2U5Qll0M3lDSkpTZmYxb0hMUnRYZGFhUzJ0SlVtUFhQeFFOTnMrM2N0aFNSQjQyK2g5YUNlUHd5RDdab1BXMGJjUW5JNW5tZ3NGc1RIY2V4TkF4T0lVV0RJT1NjZW52UVZIUnRqZy9IRkFQdUJ0amFESm1QZWd4enFxM1FOYWRDeXNMSi9Da1pvTFdqV3lHRzl5ME9JSE80L3ZRZHBiWmV1a2hhaVVUZ0h5cEh6UUc3MjJjdkcyYmF6UXBUSU1JYlNPVC9BTGxIOWhRYXo5bkdqTmFSb0MzL0FEQjFYbFV0STJsUmppYURSTkN0ZzRFdWxHeFJJQUJNeDZmRkF5Vzl2OTRoS1JDamxTaVNlRHp4UU1PbmFLRk15NlFwUkdaRS93Q2ZTZ0pDdzJvQUFRREVHUFNlS0N2ZVdKVnRLVkpiQ0IrSGpIdlFCcjFzSlVwQ0R2QUpTUkVuaWUzMW9BdDFkU2gxS2dRNXVFQUhLZ1l3Ui9uRkJKcHpvOEVsUVVTbzd0NGlUbmswSHlpaEc1YTBmelNsSUVBajBuMDcwRlV2cUZ1b2VHRlNBZHhFZ0RKeDdpUlFBTldaUzQwa0tXQzRvenRDaEpIOW9vTSsxZTNiTGlqdWJqZHg2ZWdpZ1I5YnNXWEZxRzNIZWVhRE9OUzAxVm5kS1NNdDdvbjJtZ3JyQ0FvSVdJUHBITkFSc0xnb2JTaVFZT0p6aWdjZE5mQnRrcnhnVGptZ1lHVkJ4Q1ZDZnd5VFFTYlJFRVJQSTlxQ2NRUVAvd0RVVURJRW53aEVtTVR5ZnlvS2R5Qm5IbHhuMTk2Q21vVHVFUXJJQW9NYzY1dDNHZFZVNUJBS3QyNDhuNjBDK0xoOXpIaU9iSkEyaFdLQnI2WXRtbkhFTHV2NGl1QWsvcFFhTDA3cHJkenFqclQxMHExWlFtRktRM3VPT0FuL0FQSW5FMEd0dldqU2JCbHRsSThOS1FpQ2lOeDVKSHI2Zm5RSDlGYjIyMEpBSUJVRlNaN2MvbFFOT2xJU3kyZ0FuOE9TSnpQb1A2MERSWkxVcEVxMmhJd0FPQUJRV0ZyU2xNbkltREhiNW9LTjh0dGR1clpzV0U1Z0NUOFVDYnFTeEtpUXFBUDVsQWtwUGYyakZBQlM4cElDdG9DWEIvOEExN1RqOS9lZ21zSGdBc0JsZTRBSUN5UnQ1SUpOQlp1ZGlpNHRFU05zcUt1NEVmdFFWMzBLRmdWSklLWWhLUWQwQTR6OFVDMXFGeXRLblV2SjJnSENFaVFCRUg0TWNRYUJPMVJZYzNwQUFLb24xVU8yS0JRMU5La3JnQ0NmUXpBb0Y3VTdWRG9JZzdnbWMwQ2Zmc2dLL0RudEZCVWJPeGNtT2NBbVBwUU0zVDdpRkhhcVNqa2JUeFFPK21xSloyREtaeDZVRnhTYzRpRFB0UVM3U3NUUDUwRE1Hd1dvZ2tBOEFZb0tOd2tnRklITWdrSDNvS1pTWk1TRFBOQUE2aTB5eXViUngyOGdKUW1aSTRvTWZ1M0dFM0t2QVNkdVFtTVJRRitubnl5KzBWTGd0amVvbnVSeFFiUDBGYzdrRzVjVHZXa0ZiaXprN2oyL3pOQnBkaThwL1RFZU9sS1VMTXBSdUc2WTVIeDZVREZwRHBXaEtqNVVuY2xTSjVnY2U5QWN0SGxXNURiemhRU2o4ZU9JeEhiMm4yb0xyTDduaWtsMFNvQ1JPUHlIdFFXMVhpbUc0UWhRVkJDU1FBRDdpVFFVZFF1RnFueEZRbHNESVhrL01kK09QV2dCM2xza2hKOE5TU2Z4R1NwU0IyRUgyL2VnQ0xaTzBoYXp0M0VKYlVBY0QzN1NlMUI3YUtBdEVsTGhJQ1BFQVdtZHlTUUpUQnpIcFFkM1FXaFpIaU12b1VoTzBBS1JFRElnakh2UURIN3NDVzNVR0ZKSWxPVW1PLzhBM1FDWDcyM1VGcFNFeXFRbmNOMFFjZlgrdEFsM2wyVlBuR0ZjN3M1OTZBTHFXK2R2bVNRSjRqSHpRQTNnUzV3UjJvRS9XVXBEaW9WQTcrMUFIV3ZlUUN1ZjkzZWdPZFBKUXU0UWplWUtzeDZVR3BXektXMm9RSVJIL2RCNnRBTSs1akJvT2dESDRqK2MwRFV3aVdBb2lTWVVNNG5zWi9PZ3FYS01tY3BFaU8zMG9LS3dFa2lQbitsQXVkZVd6OXhvRHFiVXhQNHozSUZCa0RMS0V0SzhRRHk0K3RCTHBLbEt1UVRFTFVCSGFKNW9OazZUdUVwYWNiWldwZStlTUNCZ21nMWZwMWJhclVLY1EwemxMZmhwVEpUMmordEEwV2ExdFBwOGlscHduYXJFSHRudDhVQlNTcEt3bytLU2tKSUNZQUErZjJtZ24weDFlOUtraExZVjZHQW9jWXhRVExjY1VrK0lGcmNPRnJBS2g3QUdNVUVZdG5YbUVxYmF1RjdUQkNVUUZrL1BiSW9LOTVhWExZUTB1M2RsUk9WRGRpVEJWbjl2U2dwT1c2dzF1VXhjSmRLY3d5U25ua21jemlnSG0zUXo0b0szV3Y1VktLU2xRalB3Y1R4SElvS3QyNGk0YldsTDZOOEJJUkpsSjk1OVk0b0JkOFFpMzhRUEZzS2tiUXJqMmo1OWFCVzFJaHRzcVVFRjRva1R6TTk2QmFjUnRNcFVvNEg0ak0wQXE4ZFc0bzhuSndUZzQ1TkFHdXlVT2lDUGllOUFxYXhDbmxBcG1PMUFEY0NVSGR0QUJWeU1SUVBuUStuTnZJOGQzQ2s4R2dldG9BS1lHUFFSUWNLT1ZSenpOQjZrWThvRkF6V2hVWUJRRDdSeU9lUFdnNXVaRWxKa2preFFDMzF5c2tZSTd6SW9LOTBnTHNuMGtUS1RBaWd4VlNJdnJobDhLMmxSSVNudm1ncjI1VXpja2dKU2xzd2tEaWdmdWt0UmNiU2dKamVwUGhnQXgzbVQ2MEdwOU9YU2dVSVNoenduVmJWcWpKeG40bWcwaXhWdmJiV2lRdlltVDRnVVNRZS9ma2lLQmlzeTQ0RmJmRElTVEJCbWM1L0k4ZldnOGF0VkllQkJEcEJNQldBYy9wSHBtZ1lyRUtuQTJxZ3FuZGo2ZTFCYlN5UERCQ3QrZHgyNW1ncjNOa0R1ZWMyS1VEZ1JQbC9xYUJmdTIwckttMGdwQ01iU3VUOEs3VUZacG9PdU5oWEN1UXBVN1RIWVQrdEJTMU96VTd1UzU0YTlwMmdIZ0RpQlB0OWZlZ1ZyeXdBRFJTb21CQ3o0aEpjQndlUWZhZ1hkVjA3d0NsdmFTcFFsUVVNNFB0amlNMEN6cVZ1NGdBS1FBQ0R3Y2dmWG1LQUh0S25TcFlpSm5PRDcwQy9mcUJXb2lBZlU1elFLV3JFNzFFUjhVRmJUTFg3MWV0c0NCdUVqM29OVDBTelJhV2FFQWtLRXo4MEJJRThHUFF4NjBIQk1UQUdEeU9QbWc1WHlOeWhNZnpjbWdiN1ZLUTRyY1MybVFKT2ZrLzU2VUVkNmlBWk1ZbVFTUjNvQmp5VXJVQnRBSHIvbjdVRVNsK0d5dFNodWhQclFZbnFDWEx6WFgxTmtJVXBaaVRBVC9hZ2llczNtMUhZNDI0a2NxUW9IRkFlNlljS0ZsVFpCMnJFZjAvV2czN3BXei84QTQxaDlRQmNVcmV0ZkhtUGM5dmI2MERyWWJMZ0R3bTB3VzQzRCtWVThIdkdhQm0wdTBBYlNQQ0NrSlQ1a2orWDFISjlxQWd4YmxBR0NoSkJVZDhoUUVSblB2UUY3WnNvVUJpQ0FSSTQvejBvTFlLU0RFR09Zb0tlb1hMVFZzNjQ2cEpRa0hDUkpPS0JPVzRsOVRpVnEyZ3BrOTl4NTdkdjdVQSswdWk1ZHQrT29KWWlVN2hrQVFJajlmeW9MT3J1bGFGUTZrSlY1aVlBZy9UdWFBRGZKUDNkQ2tCZTZJS0VBejhleGlnVjlaZVNoNHBqeVFCQWt4alA1OGZXZ1ZMdVhWRUtTb0VjU1FZSGI2VUZWKzNMYlNpRzRqQlBjMENWcUkyclVCR1NSeFFKMnMvdzNzeWNmblFYdWlyZnhyN3hETUlNSE1tZzA1SkcwWndlQkdLRDRGVytRZURFY1VIaTRrZW56RkI3Q2Y1b24zRkE3TUtVWFNWa2JpQXBKNy9sMm9JN3RrSmhMWVZ0SE9CaVRRQzF0QUt3bE1TVEhHQjYwRkhWVitEWXZMUUpLVWsrdmFneGhsTEZ4cURpcjE4c01sUkoycEsxSDRBNzBITjYwbHU4YkxhVkozQ0lXbU1lcG9HWHBXMUtuN2NtTnF3WUlUR0o1b1AwYjB0WUgvU0xmeDBBYmtFZy9pSE9PZmc1RkEwMnRzNTQyMUNRVjRVSUFJU2VTQjI5YUIwMHkyRFRJV3NaVmtFQVQ3Z1VFemx6Ykl3b29LdVZBaUlId2FENVdvTmJUL0t1QVFOcEp6NjRpZ291ZFJXdjRRNjJNa0Fic2tlMFVBcSsxcTJ1R1hBMHRHMXBPZHNFcFBidmo2MEMyemNCZDZrb1FmQ1VDZHFWUUVTWUVUeWMwQXk2ZlF1OFNHd29SdUJNNWoxK21LQzVlM1NENEpkQUpNSGN2T1JnNCtuenhRVkxoOUxyVDZrcjNvUkpDbXpHMzNNYzBDdnFhMjF2UEFBTGdnT0tqY2UzUHBRTDE1NG05WkRhMEFxSkhINy9YTkJTZFF0TFNreVNPOG44UW9FcldCRHhLakpreE5BbTlSQUpkYkpHQ0pNMEUzU2R5V3JoUVNmeFFPT2FEVUxCS2xNb1VWRXo5QkZCT2NrVDNQekZCOHBNZnJtZys4TW4vQUw1b0hkS0VpRkpXbllyeXpKZyt0QjFkQUVEYUR4Z1RFZTFBTFdnTmtsSUozWmdEOVAyb0I5NkE4aGJhb0lLWUlKL3BRWXhybHViYlUzMEtCQ2ljQkl3QlBOQVBYZEtncGU4NjRnTDRJOXFCKyt6SjFOejFKWTI1VnYzSkNOb21TQVppZy9UbWxzT0taS0Y3VXV0RWxRMjRqME9hQWd5K2l4bFpUdGpuY1lTRXhKK2FDdzkxT3cxYnA4TzViMjVVQVpTY0FrbjhoTkFrZFJkVFg2TDI4dHJBWGwzcWlHUTdjTkI3d0dOUFNRTmh1bmdDVXFWTWhwSG1JR1NrR2d4ZnFXeXZOUWRVL3FuVld0YWxka2VjRzVMYmFTTUVJU0NRRTlxQmFaMC9VclVLTmpxK3AycEk0THhjUitSL3BtZ3Y2VjFmcm1qM3pkdHJDQXZ4Y05PQVMyK0I2VDNIcFFhNzBGcjMrdFhqUzFrSzhCSldVQkpnUisyY3hRRkwyNlc1Y0lRSFljVUZFcktETGVRZXd5S0JJNm82bGN0R2trS1MyVWJzbzl5S0JmYTZxMVhVYks5djdkeGkwMDIyVWx0eThmQmhUaWhLV0drakxqeWdEQ1J3SkpJR2FCWHY3UFhOVWRVOXF0M2R0cWN5aHRLZ2t3ZUFTTWZsajNvUGJQUmI1aHRCWTFUVVdHd0pUc3VUNVJQKzA0TkJZZTFqVzlGQ0ZhazZuVXRPVWtBdm9UdFdqLzhBWWR4eFFjYWpmdFhvU1dDQ0NRWlBKOUlvRTdxUWYrUXluRWNFMEZ2cFcySzdueFlCS1Y4R2cxVnBJRENOZ0FCRUNNWW9Pa2pha3lSbnY2bWc4TXdQNmQ2RG1QY0Q0RkE5MlFscFk4SWJFamFPUDNvUHJ3QUdBTVFQY21hQVJkcklWSkFsT0pQYjBnMEZiVExKelZMNUZzMG56S09WVEh6UG9LQVIxdjBheTIyNHB1NVNIMG1OeVpQMG52UVo1Y2RGM2phUTQ0ODI0dHc0U0RrMEVQVDl5T2x1cVdMOTBPaTJ0MWZ4a284eElPUEw2MEg2aTZNNnI2ZjZtYWFWby9VV25YRjBwSURsbzR2d1hpSUV3bGNFeDdUUU0zVUovd0JPYWNXNjBwYmFZUUdOdVZHUDVmbjA3MEdXOVIzTjVZMnJGMjIrelpPWFQzM094VGNMa2h6Slc2b1ovaHRKQldvUVpJUW52RkFDdHRUTnVsWFNQVCtuTDFOZHVwVHQ1Y1h5eVBFZGt1RjVRUXFYU1JtVlI2UlFJZDcxSTg0K3cxYk8yRFJ1MnlTM1oySWFVaFU4S1VxU1o1eDYwRmZmZXQyN0wvM3AwcGRCSmFkQUlVUVlJQkhBOTZDMDlwNDFlMmNzbGJtdzhrTGFLcC9odUQ4S3g5Y0dPMUExL1lSMWJwYS92bW1YbW5YYit2cmFVbGx0SmJTd3NqQmtrZ2hXZndnR2MwRlg3UXV0dFM2YjErNzBaVmpwbmpNcFNGRzJ1Rk9CTWpBSkdOdzRqdFFaL3FuVXFOZVd3M2NyVnByU25FcGZlZVJ1UzJKeXJ5K1pVRE1BU1lpZ2FXdFowMUxxWHRQdDF1YVRwalJ0TkhZdWxRb3FYLzdMbHdjZUk0cVZIMEd4UEFvQnVyYWhkdXJ2cmk0MUlXMTR5WmRhVWxLVWxKMjdBamtsUmt5RGpBelFmYVk1cWQ1YXV2SVUxY0czS1N2RzFSU3Jnei94UUdHSGJlNFozTnRuOEI4UnRjRkpBL2Yzb0ZlOHRtOUoxWnl5YlhOdTQybCsyS2hrSVZ5ajZFRVVDenJqNGV2RWh0TWhBNTdVQlhvOThDOFMzdWhDc2trVC93QjBHbzI2dDdZSUhsQXdZb0pPY1ovdFFSeFBNUnh6N1VIeE9UZ0gvd0NVVUQ1WVQ0Q2ZLbE1ESVNNVDgvbFFjWFBoa0R1b1lKM1JQK2Ywb0FsOHNxVUVxSUo1SUZCUTFTL2QwenBlL3ViWld5NVgvRFFwSXlDVEdLQUJwVGV0aTJTYmx4eHhsWmtsWm5QZWdyOVFYUjAreldwQ0p4Z25GQVgreVBSbU5hUzgvZk1vZldaQ1cxQ1U1R1RIdFFTOWYvWWRhZUliclNuRldRY1BCVHZRays2ZVFQY2NUeFFKdHphZmFMcG5UN3VuV05ycXR3MExqeEJxRm5kdnZqd3RzQm9BS2hLUVJ1eWtLNDdVQmo3STFLNm0rMTYwdE5YMUcrdWJLeTA5eHUxUmZLU2xTTmlVa3R4d2tFejdrYzVOQitrSDJMVFNyOWQrL3BLSDdoUjNKdk5QWVNIek1CUVVJZ2dnQVFjWW9NNzZyNlUwbDNWWHJxdy8xU3hRNmxhZ3dOUGJVbHNLeERhNTh1Y2Q0N1VDaHJXamFaOTNTMHkzZCtHaEtFcFN2YTBJN251U2NUTkF6ZEVhUFlQSlI0YUE0dHB3bFJXNXVLQVl4SHVaanR6UVpoOW1uUnVxOVRmYkgxRFlkTzNTZFB0YmU0dWszTjRwaExoWnR5NHBPMUtWQWplcmdIa1FUT0tEZTlUK3dYN090TTBkTGY4QXBGeTdjQkptN1hmT0IxUi8zR0R0QitFZ1VINWQrMHpwWkhTK3BGdXllY3VkTWZWL0RVOFFYRUgvQUdxSTV4TUhIQm9DdW5hVzFkV2pRY3VGTWhwU1ZRQUNGRHZOQWZ2ZW5tTGt1dmw0S2RVZkRVcnd0NkNNUVNKNWowTkFYMGJUZE1zTE82dFhMbGNPd0Z1SVJ0TDBBN1VnSEtCQmp2UUQ5WHNtMFBCMjBiOE5rTnFTRXBFQUppQlFMZjJnMlRDZEo2ZDFDK1c2aHBOd3EyZCs3Z0Yzd2lVckpUT0NxQ3FBWUZBazNTU0xxNERTTG43b3BTMHNMdUd3aHhTSjhwV0JnS2lPTzlBUjZTWThYVkdrS1Awb05kUTBsdEVKR0FLRDVYZkJqOWFDTldRVCtSb09BRDIyL1ZOQTgyU0I0WjIvaUp5REk0UGFnNXVTb2VVRDhZbmllYUFEZnBJSlVaekoyOXVjMEhEZGwvcXRzaXl3ZHJtNlBRWS81b05UMHpSTFp4YmRsY05JRm9ob1FWSm1ESFBzT00wR04vYVRwU3I3WGhvZWxGTGppOE50cGtuNjBCWDdHbTM5SWZjc05RYlUwK2x3aFNUN0R0UWJ5TGRpK1lSNGlRdmFpVlQybjFQYy9GQXBhdjA4OWJYcXJxeTNiU3JjU2tZVE9Da3g3ZDVvRXo3VDJ2OEE3YTZoNlkrMFczWlNwN1RYdnVldE50anpydG5KUWx4VWN3RkZFOHlVVUduMy9VS0dMRXZzM0NGV2pqS0hHSFVFRkMwa0FoU1Znd2VhQlkxbnEyenQ3ZGJsbzRYM1ZTQ24rUW5pYyszcFFaazZ6ZjYvcXF3cEFDMXFIa1RQNFJnVDZ3UFdnME5GamFkSGRKMytwWHpxV3JUVFdmSHVYQ1lVODZQL0FGdGlPQ1Y3UUI5S0M1LzlOSFM2OUUrejVlczZraU5WMTk4Mzc1VmhRYkpQaGo5MWYvS2cxVHFDMlRjNmVWS0U3ZVFSTzRIRWZyUWZqLzdVTk9ROXFPcGFlQkNsU3BzazVDaHdmYlA3MEM5MEU0THkyUXRDVW00YkcxWUtaS0ZESDBvSEMzZVhabitMYkIyUWZNRHo3bWdnY3ZXRjNDVStFVXFNRkJnSmd6eVRRZU4zRjFxT29JdDJXeXZ4RkJLaWtoUVNtYzVGQlI2M1pDK3AwMnNKVXpvN0l0NEtZQXVGK1pmL0FNa2dwRStwOXFCTzZnUVZ2c1RKSUJuMU5CMTBXd282N2xKUGJGQnFLZ2tSa0V6R1A2VUVhczhBZW5QTkJ3cElnZ25zVG1nZ1VNenhRTzJtSGFWVC91TWtHU284a25PS0R0K0JBTVpWeWVRVFFBcjlVNzhnQ1k5U2ZUTkI3MHU2VTY3Ym9rQU9FcFBQcFFhdys4V0xIVUhqNWkwMzIvY1VDajluR2hLdnV2RzlZdVVuYXcwcFNOdzVVYUFuMTFZb3M5YnM5VFpTV2xlSXBMcG5LaU1nelFObWozWVcwMitSRzZOOEtrR2Y3bnZRRnZFUzRpVkxUNFp5ZHB6Z2NIOWYxb0F1dG0zZXRYdjRUTDF2Y3RscDIzZFNZY2JPRm9VTzRJOVBZMEdNczZmcjNSRGR5MW9sZzkxQjBvRnJVMVlMMk8zbGdua2xBazcwYzRpZmd5U0ZGM3JMcHJVbHVlTjFBMXB6d2tsbTl0WG1sdHFKNGdBakFrODgwRFowcjF2ME5vN0pWb2J1c2RTM1lBUzUvcG1tT3EyNVBLblFsSUdjMEZDK3V0USsxYnJIUzlEdjJFMkhUbGs3OTdkMDloMFBZU01GNXdZV3RSa1FQS2tFNVVjZ1AwbTB3R215RUlTZy93QzFKd0I2VUhWNG5kcHo2WTN5MnFBZStPS0Q4ZjhBWDdMbi93QnlYRHEwa0FLS1ZFbWNHZ3p0cEYvcE9xL2Y5RUlSY2pEclJQbGQrZm1nYVcrdWJXNEtScXlEcHQwcmJ1UStnN1RBNUNnUDNvSkxucUxwMGdoelZMVWlKL2hJVXBSSjdBQUdhQTlvL1VqK20yRGl1bWRHWHB5M0FFcTFqVWtqeGprNVl0K0I3S1VZNzVJRkF0dkpSYjI2VW9KVkVqektsU2lUa2tua2t5U2U1TkF0YXlRaDl0UjRuRkFkNkdzOTEwNitSOWFCMVdKSkE5YURoUTJudC9hZ2pVQkJrWjQrdEJFVUpKOHlUUHRGQTdhY2hhQVZFRXBVamRoTzNFQS9XZzl1b0NEaUFZMjV3UU80L09LQUZxS2xLQUtzRThqbjFvQjlvNzRHb1d6c2diSEVuZHhIdlFiUTJ5YjdUbm1rNFU2RXJUT0QrUTU3VUIzUnJWdTBaYlFocVZKRUJZVHg3VUMxMWd2NzFiWFNOMHJHZHFVNVNmUW52UUFPbXRTTFZ1aENseW9MZ25nVHhrbmptZ2FYTHNvSzBncHpJQWtSOFQ2VUVMVnlsMS93bkZGYTlvU05tVFBiYjNBOTZDci9BS0dYRmVJMkVraFJPM3pqSTdtSXh6K2xCeSt4Zk1JY1VrTjNUczdadVdrdkNZRS9pRTBBWFdocXVxTk9zL2ZuMHRPaFhrUkxUZTBqL2J3Q0NQVHQ3MERsOW0vVGxucFJlTnMybjd3NDJGS2R5ZTQ0b05GV1MyMm4zNTk2RHkyVUhiWWNrR1JNODBINTArMnV3RnMvY090b1NBbFFrZ1JQOTZESG1XVXZYSTNBZ0tIQTlLQXdtMVd5bHdMQ1ZzcWdBTEFVUHlQRkJiWVVoczcyMldXbDhlSTAwbEczOGhRVnRWdTFLSUtnUHc0ZzdzZkpvQVRyeFVUdTlUTWZwUUJOU2JjdWJoSkFWdFQzbWdmT2lXZHVuU1FRVkR2L0FFb0R4T0o5ZTlCSHdQNWgySWlnNUlrZ2R5WWoxb0lWcGs0Si9PZ2NOSFVxWU1TbWVlZndqOUtDeGNvTUVKVGtxNzl6SGYzb0YrOVVFa0lWRUs0ajh2OEFQaWdFdkNaUDYwR25mWjlydHRmc3MyVis4R2Jsa1FDbzRjSGFEMk5Cb2kxWGxrdFNtWEFwZ2pHNU80VEV4UUlkM2IzTGJWNWZYYmdoOXdoQ1FjUlBOQXY2RzJFT3VxYmpkdW4wUGVjZStNMERYZHNMVmJvVUZiUUViZ1o1Sk9maWdwMkYyNWIzS2xMU1V4K0NIUWVPSlA1WW4yb0hiVFhHME5uZWdtRVNCUG1tZU00b0xkNHhidjI0Q2tsT041MjVVRDZVQ3BxMXd4cHlnR056cjRVUUVRQ3BhandEbjF6RStsQTJkUHJUcDlvdzA2b2VKdERqc2lQTXJuNEE0QTlxQmlkZGJXMFNoYVNPZitLRHZjMnkxdUtnbEp6SjcwR0RmYmxjVzdqYVNWbFRhd1lCN25tUjdVR003MmhhV1RpUVBGU1NPeGxQZWdQMmFDOHhtRE9lTUhIRUgvdWcrdWJkdGhLbEpVVkpJQVVvOC80S0JjdmlqZVFBUVBVaUtBWXBVTnJKSUE3UjZpZzQwOVF1bWR1Q3VZNG9OQjBlMis1NmFsSTVNQ0o3VUVxK1lISEltZzhJRzBDSXhKZzBFWkJIb08wUlFSa2RnUG5uK2xBMzZVMTRRTzRsSzNGSldFUVZUaUNhQ3hkYkFsUlVJekdFNEk5L1U5cUFQZW9sUjQyajhvL3BRQm5XeEpnOS93QXhRUXRTMjRsYlpLRkpNZ2pzYUIxMGZydThac1JaNmdwVHFSK0J3Q1Q5ZjB6UUR0WDZqdXRVZVlEY00yck1yU0NQeEtqbWd0Nlc0bFYwVnBKRTl6QUE0eCtzMER2YVBKY2JhU29CUkp5Q1lDbGRvK09hQ3NsS0hCQVNyeUtLOXFVNElQYVBTWm1nTGFjQzRBb1N0b0s4eHlBVE9TZmNudG52UVhkVHZmdTFtRkJDUW9qY0pUbUJ6UHA5Wm9PZWc5RE4rNG5XOVRCeXJmYk5uai85b09maWdJZmFEb21vM09rWEYzMDR0WCtxSVRJYUtwRGdIWVNZM2VrNE5CaE9qZGMvYUpvdDg0TlQwMjJ1Tk1EZ0NtbHloOUFua0ttQ2VjSG5pZ2FPby90TVUrd3o5MUtpd3RPQ1JCSDY0OXhRWTcxMTFiZDZpcEJlUXBmK3hrUk1ldnhRQnJlOEQ2Ry9EVGhJbFZBMGFaY2xETFU3d0R4bVJIMTcwSGw4KzRsRWpDWXhuSm9BRHJtOFRNeDJKb0tiZ1U2a3RObmM0dnlwRVVEUjBuMCtiZGtQM1F6NlJ4UU5pK0lFRDBFVUZjZ2tZSGw3VUhJeWNuRVRNREZCR29aSTRJNWlnaElKUEt2cFFOMW5FRlFTU1FuYUVuaVNRZjM5S0MwNlNsU1NtRlFJeUk0UFB4UUI3MHlvN1VMVEhjbkordmVnRVBncVVOcEpCL21IZWdxbkJFWjlKb09rWklnejJGQmRiVnRRVktKVW44VUh1QlFGK24xN200U29sZTdidDlaOSsxQTIyejYvQ1dVSmpPSE5zUWY3MEZoU29jSlFVK2NiQ3VTa2ZNejZIODZBN1pKYlFndUZ3RklTQ1NZT09JK2FEN1Q5T1BVRjhFcFQ0V2xzRUI1WkovaXFHU2dldmFUK1ZBK0Y5QVFoTFcwTmpDUW5FUi9TZytkZlVDZG8zUU4xQW05Y3NXVCtsdnB1MGdvY1FvSlR0aFFqT0l6UWZtU3p0RGZhdGRNamZzVFBsN1R6bWdYTlYwOVZuZUwzRlJNd0RFelFRV2pjRWlZRkF4NlU1NGx1RzFlWkhNS09hQ054MVcwTnFFa0psS2xlbVlvQTZuSUJBTWR5RFFYK2xVRnpxRzNLUVlRbFNqRkJvaVFFNDNZam1nNGc3RDVnQWNaZ1VFU2lDVCtpWi90UWNLSklrSGpzZTlCR3NRSlBQYjFvSVNBRDVoOFJRTU9uM0cxcEtsQmU4cWhNazVqdEhwUUUzRjRJZEpTWmpJTWV2SCtjMEErN0NsNEtUekprL3JRQjMwRXdyZDVmVDBvS2pxSUdaNDU5cUQ1SWt5WUhjZDZDMHlKUitBUnpIT0tDOW82dkN2UWdwU1VxRW5IY3lQMG9IMjBaaitMdEVLQVNVazRIcitmNzBCRzBzMU1yQ3hDUWh3T2JnT3dJR2Y4QW1nTE9XeTNFcVEya3VLTUpFQ2NubVNlT1lGQVlTcHV3dFdiZGdOSVF3UE9aNDlTUk01TkFPdmRjVGFCUThSQ1ZCV0NwWFBwOU1tZ2tScURhbVM5ZXJRMHdoSU85MXpiSW5rekJJOXFCZXVlcmVrL3ZTYlM4MUJxNWZkOHFRa2pZY2Z6RVlUSmlnSGRLZEM2VFphemRYMTQ4eWJSenhGTnlvYlVnQVlQdmtuNlVHTGRkUDZVLzFQZGpTTGdQVzVNOFkvUHZRTEpiOEZhUkNRREpPTVQ2MEZpM2RLQUZZSkgwb0k3aGFWdUpXbFVLR0NSNkVmM29LWlNDNm9nZ3hqY2FCZzZFWjM2aGQzQ2dmSWp3eDhtZ2QxRXF5SmppZTlCdzZNZ0dKL01rKzlCRXBQbVVVampzT2FENVE4MERBR0JRUXVKOVpBQW1LQ0JZTTRVQjgwQnV3Z2dBRlNWVEhPRDMvT2dKZUtmTEhQSXpnbm1LQ3JjaElKRUJzSGdabWY2Q2dFWFg0UUFFZzVNVUE5eFdZN1FCL3dBMEhpVlltZmZOQVMwNWd2S21GN1IrUSt0QVkxNnpPbG90TGdmK3QxUVJ1QS9EaWNmbFFNMmo2b0hMRTdZVWxZM1JQQi96TVVCaTF1Q0VxS2twSkFTUWdaTVRNelFNbWxPanhpU1VyU0NSa1pKbmdENDcwQzkxcjFBclNXbkhrcFV2YmtIamNBUHdFbk04ZW5GQmhibXQ5VDZwcUlkMHRvQmFDU0MrVENBYzhEdlFYMGRLZmFKMUs0aHpWYmNYVE1HUjRwS1VnY1NrZXZ4Mm9EckgyYmRlc0lkWFlXT25Ob1cwUVd5OFF0VUVEYkJ3SkI3K2xBcmRTYVIxMW80YjArNTA1NjNaVUZoTzI1SzBFSGtDQkZBb0xaMWhDQzB1eWJTbEpoVzVSSEh6UVViZ1g3QTNMWlJFUUI0aDgzeGlnNXRyeDhxSmVaU0FjZVJVL3ZRRVdXVktiVXBReGdnQXhtYUNvNG90aFpKK2FCODZRdEZXV2h0N3dVcmYvaXE5WVBBb0QrMVFXa0V4OEQ5S0RtU2dHT1Qzak5CR2hQNFJPWmozQW45cUQ1U0J5Y3puMG9LN2lSUGxUMm5qOXFDRlFNalBhS0FuYkwyby9DZGhJSktpT000UGJOQVV3RUpUS2VJeHpIL0UwRUYyQnVVbEtnUk9UNi9sUUJyb1NzaFdPK0JraWdvTEkzWWdHZ2lRQ3RZU2tFazRvTk0wblFsTWRNcmUycEMxb0lreU9lMzYwRHFqcGY4QTFUN04yV0hFSlZmSVFIRTl5Vm83RStwRWo2MEdTbDF6Um5ITFJSQXQxUTQwdjFIY2ZTZ2QrbWJzdldxWEVyU0NFbENncnNJL3o4NkE3YjN5QXlwQi9tQWdSZ2R6SjljOXFBVjFLd05WZUtBRnFZVXFGa0p5b0ErdmFmMm9EZlQrald6TERTbE50TElSQ3dHMGpHWUh4M3ptZ212V0F5eDRqU3dsSTh5VEJUQU1jUm5QNVlvRi9xYnF1N3NrTGNZTjBYRUVncGRTWWppZmY0b005dmZ0QzZ2TENrdHUyYlZzaHdGSURRbEI5dldnU3RSMXJVYjlKVmV1SjNxVVZRbElHU2N6NmZGQXYzRGJqNWxaTzBHQm44NkRwdTBFb1NCanVEUVNQTzdXbE5FZnBuNjBIV2kyQjFUVkcyUi82R2dGdTQvU2cwUktTTjIwRklFREhidFFTaVRFbko5SS93QW1nOUtKU1NCT1lPS0Rrb3orSlJCeUl4OWFDUGtCS2s5cy93QnFDRXBuYVNJanNRYURndGdreVVuM0k1b0xOa05xZ0IvTjV2U2dMcEtsdG5ueWpQZm4xb0tkeW9Sa0RiTW52anRRQzdzK1lra1RFeDZVQTUxUko5b09LQTcwTG82OVcxaEJXRkJsQkhPUlB0UWJhdTFTemFHMlFrbEFUNVovV2djZEpNNmJibUlsQW9NeisxSHBSbzdydENJczNWYmxiUi82WFBYMkIvS2FETjlFMUZ6U2IwdFB1UjRjN1ZKN3pIMG1nZDEzeFg0ZHcybHh4dFNZV0loTTkvajFvT1duM0hybFBpS2EzcVRFSlRFREdKN0U5eG1nYWJXN1EweXRMWG1jSUVnWWc4R2ZYMytLQ3d1MWVlV3BTakNRWVNWQ1pWOGQ4VUE1L3BkT3BPaEx5aHRtVk83WmNJNHgySHh3S0FkcS93Qm5PbGkzbHRieFdsTzFKeDIrTy9IelFaZjFCMGtpMWRTZkZKa0ZSQnhKakorbmVnVnJuU1ZKQ1NFcVNsUTNibDhVQWg0ZUdsWVZreGcrMUFOWHVjSVNrRlN5WVNQV2dmdW5iQnZUckZEYVNsVHlnRnVxUEpWN1VCZENUNGNSZzQrYUR0QVNwSWxXM0JtTSsxQk9sTWhTRkFoQXdNOENnODJEZk1FbnVNQ01mOVVIaVd3RU5nd1NRY1I3NG9JMXRxRG5tSGxudnhQY1VFVGpDNUcxUkFJazVQTkJESm1BUk8zNnpRWDdlUTM1cEJIWSt0QjQrckJPZUR6ek1ab0JWeVNKM2VtY2QvNzBGTkZ1dTZmRExZSlVzNENSUCtZb053NkMwQWFSWUpXcmFIaUpKSmc1NW9HM3dRdEE4WEE0ejJGQVcwY2dXeFp4TFppUGJtZ3RYVnV6ZDJ6dHZjdHBkWWRTVUxRb1NGQThpZy9QZjJrOUdYZlRkeXE2WUMzOUtVcitIY1RLbXY4QThWLzBWMythQmYwblhGRUZsOGt1QVlDanVrZkhmSHJRT1ZscWJSTFliY0tnVWlTbUNRUDZlL05BMzZTNGxUTzZQQy9tQ1NvZWFZN0dnYTdXNGJVUjR4U0pIbFNTRDdVRmx5NmJCS2dxUURPQVA4LzZvRmZYdFVRNjk0YVZsQ1RHVU9RVkNlUUJ5Ukg3MENKMU02d2xRSUtSdUlTUitJYlJHSitZeDgwQ0JyVjYweUhXaDRaQUpoWVBQYjZpZ1F0U2RDMUtWSk9lVDZVRlhweC83MXFxa3NwMm9iTzJlNW9HUldwS3RuZ2hjZ0pWRW1nTFdXcmdqektINTBCeG03WWNqekFrZStJb0xiYWt4S1ZRSWdlczBFZ1FGcEoybkpBRS93Q1lvSlc5cGVDWjhzU1NhRHBMY0tLaWVESUJNQ0Fld2lnNThBbklTUk9UMm9BREhBbUFSM21hQzZ5VHNRVkFKTTR4T0tEMTRoUXdBbjBQclFETGhPOVFiYmJLbGs4RCt0Qm9mMmM5TGJmL0FETG9KSmdjcXlCOU85QnExbzM1ZTBKR0Vqak5CM3NTR1FTb0EvNWlncWk0TnJxQ0hVQStHY0tBT052YWdaRWtLQUl5RGtVSEZ3eTFjTUxadUcwT3RPQXBXaFlrS0I3RVVHQi9hWjlrMTFZZUpxUFNqUnVMRk1yWFlnL3hHdTh0bnVQYmtVR1c2YnJqbHM4a3VCU2twVkc5SmhTVDNDaFFhSDB2MWFBaEJZZThZb1BtVkFLcGs1VUNDUU14Z2U5QXpvMTlMWWNLYmdGS2trRGFjYzk1enlLRHkrNm9TV2kyaDliZ0kzSy9pUmdDSUVjNW9GeldPcEdVUEo4Tk11cUlrcUVsUEl3SmdZejYwQ3AxSDFNMnRvSXQwanlMbHZ2aWUvdnhRSkYvZHJlQlVWd2tEbnVQWTBBRFVMaFJiVW9IeXh6UE5CZCt6OXZlNWNMd1pFOFVCTHFSTVM2bjhKZ3pQRkJWdDNuRklDMmpCQW9MMXRxempKVEpJTkFZdDljQjVVY2NaeFFGN1hYU0FtVlRISHRRRldkWlNkcFV2bnk1SEFvQ0xHb05PcjNLQVBtTW1jKy96UVdOelJ5VGs4NE5Bck1IQTlwUHlhQW15QXRwSUE4eDl2YWc2YlpYY3E4SmhKVXIyei8xUU5YVEhUSis5b2Z1d2trbmdqSCtUUWFYYXNKWlMybTNDUWdqOE1RVEhyL2FnSU5TaFpNaVNaNC9TZzhrcVdwU29VazlpZUtDcGNza3RSaEtWYytzZXMwRjNwNi84VHhMVjFlNVNENUZIRzRVQnVnK29NdisxSDdLclBxZER1bzZONGRqcllFN2dJUS9IWlE5Y2MwSDV3ZnNiaXcxSnl5djJYTExVR1Q1aE8xWHlrK2xCYlZxRi9iaEtYRmZlVzBIQ2xZVitZNStvb0s3dXR1b0psTGc5aFFVSHRYM3lDVkNmU2dvUDNtNFRzSnpNemlncHJkVTVsdzQ5c3pRQzlYZTJ0S0VrVURGMENoVGRuY1BFUWtKT1pvTEd2UE1xMG1WclNGeVJFMEF6Um5nV29KeCt0QmNlUUZLbnYzOXFDQkpLRDVwTWUyS0M2MWNraEtVcUk1eFFXbW4zRXlVcTd3S0M2eHFhMjFKbkFIZisxQVdHc3FBaEprRHZITkJiYUlVcElQckZBVzB4aHk1S1dtNEppSkg4djFvTkQwRFEyN2RrRjFCMzRuRTVvRzl0QWJRQUcxQkp4QkVtZ3Z0a0tibE1UeGovT2FDeW1JODVtZlVUUWVjamRqYkJJbkVVRkJheWsrSnVVcVFVeUJJeG1UUVVOUVMvYk9JdWJSc2tJTzhxQ3ZYdjhVRFJwT29wdldnRmpZOGtlWlA5cUFoUWZVQ1o5b2YyZjZYMW5Zbnh4OTIxRkEvZ1hiWWhTRDZIMUZCK2ErcGVuTmQ2UnVEYjY3YUtMSENicG9ibTNQZkhITkF2dnBRdE81c2dnOFFjVUE5YlFNOGc4VUVDd2tEYVRJNUE5YUNqZHZiRWtpQUI3VUM1Y3VLdWJoRExlNGxaakZCb1Z5NGpwenBaTFRrZU82TWcwR2V1UE9YTGlsT0xPd21kdEFYMHE0Q0NBcVJRTXpaU3RBS1FDRDNvT0hVU1BNQk9lS0NvdFhocU8zMk5CZHMzL0VTTUNaUEh4UVRxN2taOUJRZDdzQ2dkTEczVzhvQkJJU1RCSXhqL085QnAzUitsSXNrZUlVQlJLWjh4L2IyOTZCb2FRbGJ5RkNGTmp6YlJnQS9OQmZXdnczZjRZVEhZZzk4VUJCc3FjU0NOM3FaNUI5L2FnbDg2R1NoVzFhVlRtYURoMUtWSWxhd25jSjJVRUNJU0pPMGlNS21CTS8yb0txMm5BbDFFaFBpWUJTTWMwRlJrdTJ0d0hBWEV1SU1BZXA3L1ErbEEwYUxxYWRSYVVGSkxkdzJZY2JQOHBvQ1ZCOGFDbnFGbmIzZHNwcTVZYmVhVmdvY0VnMEdLZGIvQUdNNmRlRnk0NmVlT25YQm4rSHloWk9lTzFCakd1ZEk5U2FFNGZ2dG1wMXJzNno1Z2NVQ3RkM2NFaFlXaGY4QXRVbURRQTlWdXg0Y0E4MERYOW0vVEc5QjFuVWtFTUovQkk1TkFCNjMxUldxYTA0bE9XR3p0U0RuRkFKYmFDWUErYUNSc0R4RWppRE5BMzZkaGhPQko3azBGeFkzZmhtRFFWMU1Bak1pWm5QRkJ6NFNrRHltQjYwRXlISjUvUTBFdURrRlAxRkJ0L1RHakMzWUR6aUZKVWNUUFBlS0IyMGdoS2RpZTRrcEFKSTkvd0JhRG5VNzFiYWdXRXdDZHBLdUppZ3ZXZDBsZHVsYnFRREVrcEpqNmZXZ0xXVncwdEtZVkc3emZCNGlndEtHeUVDZGg3emdZb0lIQUhTVk53Q0RrZHg3MEVkeTBwVHJha3hCd3FjUnhnZWhvT24vQUF5MDJrbmVVcHdVanVPOUJXZGJXSldBb0p4NVRpSTRvS1Q2YmkwVXEvWmNVWEVHUTJFeHY5aWFCcTBuVkdiKzJDd1FoMU1KY2JKeWxVWkZCYmNPMVlXbUNEam1nOWNVTmtpSVBya0dnQTZ1MzVOeWxwUU13bzk2QkYxZTcwNXAwdFA2dmJCWkk4aW5BWlBlYUJWdk9sOVA2Z2VjQ0JhUE56RzhFRXhRWTM5by9TV2g2RDFPMWFzM0sxbEtncDFDZTFCSjFIMTJselNVNlRwdHI0RnNoSVR1L3dCMERrMEdlQUZVa3FTQ29aUGVna1FtSUdmeW9Jd1ljVDdVRFpwamhVMGtLLzZvQ1NDTVFKSFlpZzZDZStCUHZtZ2pVQWNZeFFSTEJudEU0b08wcU1kZ08wbWcvU2JCMjdnNG1FcDk4ZXgvZWdNNmVFYlZiU1pFRWY1K2RBSzE1THZncmJoU2tyVHVCVDYvOVVGenBOUWUwMUlraDBmaWttSTcwQnEwS2l0QndpREJBemoxb0NidTVDMHBBQzk1Ny92UWZKYmNRcFNaQUJQbEE3MEhkeXRTRklTSENyZGhNai9PYUNBc3FXMCtrTEJrRE1VRURqWVFrK2ZZRUkzRXFHU1o0b0tpcmJ4SFdHR256NGJ5dDViS1pCQTlQUSs5Qk5xVmtxelQvcUZpdi95MEVUT1F0UG9SOFVBdnFQN1N0QTZlWlNtOWNkY3ZYRUJhYlJsRzVYMVBBK2FESitvUHQ2MVZJZFoweG0ydDFUQ0RseHdEdFBhZ3lycUhxZnFuWGo0bXA2amVvWldUdFFWRk0vUVVDN2MyeFRzUjRyamo1RW5jb21LRHkydUw2MldWV2QvZE5sT1ZMU3N4UVVieDI5ZTFGTDdyaTNWcjVVNHFTb1VFM2tmUVd6Z0VZQTdHZ29OYm1sa0dBa25raWd0cUg4eEpJb0toVnRlU0o0b0cvUWdDekpFbUp4M29DY0FsV0FQaWc2UktBUVRqOVRRZktRREJCSDBGQjk0Y3dUMkgxb0JycnFVckkzUkhhZy9UZHNoVzV4MU80eU9BUkJIOUtBbUVoS2lrQUZLaUNJNWowOTZBVnJUNjJtVmxrS1R0VjVnY3pQZWc2Nk12QVBFWmRKUmtDWTQ5NkJqUzFENjBCeEtGVHZRZnhRQ2M1K1JRV25QR1NTNjQ4ZHFaZ2pqNW9PcmQxNXRhVm9Xa2pCVW9nL3BRWDNubTNRMlpBamcraDkvMW9PVzNqNHlZV0Jna2tTUjhmRkJFK2xQakErS1NVbVFyYi9YMG9LTzkzNzZ0eGNvVTJnb1F1SkJLam1mU2d1QjdkdWE4cWxKUUNEeEtpZWFCSCsxUG9HMDZ1MDU0c2JyZlZHRWx4dDVDZ0M0ci9hUjZHZy9OOWl3blNYTGhxOVk4SzlaYzhOVEtoa3E5QlBZK3RCOXE5MjljdmgxNUtUZEZNQnNZUzBQVSs5QUpTMEhRdnpFTnpManZkWjlCUVRPV2dTMGxhMnlsQi84QVUxT1ZlNTlxQ2xkdGxwWjNSNHNTUU9FRDBvRngxeGRzOHJaNWtxazBGMjJVMC9iQUpUQzBuelpuTkJhWEFZU0pJVjZFVUFwMVcyNUdRUDZVRHQwMmpjMk1FZTRGQVdXMkF2QXg3VUhLV3d1Y0QzSW9PMjJ2TnR5UlFkUElBYldmYmlnV24wcUxwZ1Q3MEg2bjB0K2JkZVNsMUtpTnE4aFFKeCsvTkJhWmRPNUNGSjh5UmdBOXY2UlFDZXJHM2d4NHJicFQ1U2twQWdpTzU5cUFMMHhmUEYzYTJrcEtFd1FvejY0K0tEUkdHa2xkcmRMM0xSY003ZGdNcGtIMTlhQzIyc0xRQ1JDUVNsTzR6QkhJb0xmaUxLeXIrRVU0QWpNNG9KYmRDM0J1VWhLa29KQ2h6NzBITjZwTnZha0lEYVdrK1lFS0dTTzBVRVYxcUNFV3lYYmhFRW9La0ZKQlBISjlxQ3BaS1M5WXRQUFBGRDd5U29Ua1J6a2ZGQkpidzI2aHNod0ZBM0JaeVovcUtDKzJGM0pIQ2dESktZZy84SDBGQmozMnpkQUt2bkY2L3BUeUhOVFFsUldraUFwUCswK2hIWTBHQUxjQ2trRGQ0WVBuVWZ4clg2VUJXMXRBVXRxY2JDbkQvd0NxM1R3bjNOQmFjYUtYVm9Da0x1RC9BT3h3L2hhR01DZ1g5U2FRR3lHZ3J3Snl0WEsxVUMxcWFmRGlaVW9qZ1VGV3lRNnlzcVFTRDZVQkg3ejRvQUtvVU8xQlN2UEs0aFJNVUdrOUZOSVhhQXhKaUJITkFXdjdZQkJLY2prQTBGQk1wQmp5azh4Mm9MRFRXNEVUazhudWFENjRRb3NxNUI0aWdDcnRDWEZTa0VneHpRZm9jclUzZE5wVXBLSFZnK0hJTUxJeVV4a1RIQS9LZ0l0ckVia2x3OEJTVkRCUGI0UHZRU2E0MlhtTmpyUWRWc0g4UUhnYy9UdlFaL3A5NHEzMTVMVzhCTzR6UElQdlFhQnB3OFJoRHFOeFEyNUNFQldJOXYyb0RWMFhFdUZNQkRSU1ZvSkg4dzdZK3RCOXBpZDF5ODYyK3RTU25hcE13bmRFN2dQVGtVRnkyRjRsVHFGdWhUU1kzU0lVQ1R5STlxQ1oxVEt0d1Y1a3hBQ1VnNVBlZ0g2Njc0bW5Jc2x0N25YMXBhU0FZaEpPZU9NVUgxeWx0aTJOcTJoTzFLWVFGS2hSRXg1VDYwRXp5bE5JSVh0S3hDUXBmWW1POUJiczJ2dVREN1ljV1pNbENvOHFqMlRGQjQrMmJwUVNBNGxLVXl0YWs3U28wR0UvYTcwR3RpNGU2aTB1d1VzTnFoNXBvQUlVWW5lRTh6RkJtdHJkcFNncFljQ25GSkNuN2pza2Vnb0oxRnAyM0VId3JFWUJqelBHZjJOQlQxRmx3dU5GeHNlTXJEVnVuT3dlcG9GWFdXZ2wxTGNoYWgrSW4xb0lHbWc0aU80N1VFTDl1cHRJV2taSHZRVW55cGFVOWlLRFUvczNRcDIwQ1RBSFB6UU9PdFdDUlpCU0NuY0RtT2MwQ3cweVVsVzRBRUFqelVFcklJWEh4azBFNVNWU0R3YUQ1VERZaVFuSW9OamhKS2krK3BUaVR1QUU0RWp2NnpCb0xWdXR6NzZ5aDRBSmRFS1Vnbm5PUU8xQk5lZmRtbVV0clJHOUNtTjhreklrWm1RZmVnUk9yTGR4THpkNjRHMkhnUWcrR0pCSTcvcFFIT2dieE9wdHYyN3dXcmN3cFpDVEFCSC9BSDJvSEMyZEp0R1hTU1E0Z2ZpT2QzdjdjVUhqTjB5MFcyclpEaWJoSkpWSVRCTXhBb0NkazA5Y09LbFNnMkR0Sk1TSjRtT2ZtZzZOdXdWT0pVNnRxQ1VxU2tTZmdHZ3AyakNVUE9hZ3k0NCtxUERDWGNKOFR1cjJ3WWtVRVRxWVVwOWFpbTVaUjVnRkVwbjFIcHpRV0xZdU5XeEsybWxXdXorSUJ5VmNrai9tZ3RtNEtYR2tvQ0hHTUtrZ2p0SU1VRjlTaXUzVzJ5b05yVEJJeVNBcVlqOGpRUjNkc2xWdWhManBXMDRBbE1wa2ljZC9XZy9OWDJ1ZENMNlh1djhBVkxJSkdpUHVGVHpRZ0Z0d25zTzROQXEyamhiUTI0dEtWM2EvS3lnL2dhQjROQjg4Q0ZQSlFxWEFQL0lmUEtmWlB0UUtGMjYzY1BMS0ViUW44SjdrZXRCSmJzOEtBODNjVUZweTIzSkNvM0U5c1VGZTYwVlRWc1hWSkFCNHpRTm4yUnVCVHpqYTB5VXlZb05Tdk5LS3JWU2trQTdjeWVab0VDOFNwbDZENVQzaWdrUUlBb0paQ2xjZVlkdTFCSzN0MithSitKb1AvOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9TY2hyb2VkaW5nZXIuanBnXG4gKiogbW9kdWxlIGlkID0gMjk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI4MjQ2ZDQ0NTdiM2QzY2ZmZDFkOTBkYmQ5MWVkNWY3Zi5qcGdcIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9kYVZpbmNpLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTWdBQUFGSENBWUFBQURreVFNbkFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBQklBQUFBU0FCR3lXcytBQUNBQUVsRVFWUjQydXo5ZDdTbDJYbmVCLzdldmI5dzhzMzNWczVkMVFFZDBOMW9aQkFnUVpBRUtRSU1Ja1ZSb21SWmx1M2xzVWNhcldWckxNOHN6eCtXeDdhVzE0dzk5dGdlUndYU0lpbFJKQ1dURkVHVG9KQ0lSdWdjcXFzcmg1dnZ5Vi9hZTcvengzZHVWUUdpYU1zU3lXYjFmZGY2VmwwVXV1Njk1NXo5N0RjL2ozQmdEN0xKNy9KM2V2QzIvUE85Z1FmMlIvdXpsTi9sdVI4YzMvNGNnT2Izc09qZ0xYaGd3TEgvMlBzZUkyQkFSRUZCQXhBQWY5OXpBSklERC9MQW01azlGa2lBK0w3SDNIZjRBK0NBQ2lobmYvclozNGVEdC9HZk5IdndGandRbDV5OUR4d3AwRHpkVzF3VXBQZm8vT3J4eCtiWEhvMlR0Qk1abzQwb1NqSlg2WDMvTmh4NGo0TVE2OTBBa2doSW4xazd0clpxbSs5OVpINzUweS92YkhVVzR1YmE2VTd2MUZJMnZXem51TEkxbWt4dlJ0bHYzUEg5ci9lbm83MzdBS0lIUURud0lBOXFlSFhYZS93clQzN2doMVlrL3FzZGlUNlFTUFR3ZHBZZE5VSGJSZUdPZGFQNDhTTDNUemVpMXJOTFM4dlhiNHkzcmhKVTd3dXpEZ0R5dTd5NUIvWmdlQkFEUkF1dGRyY1RKNnVqSXJmemFhcXBqZFFCNDdMVVlaRVRXOUZZT1RuZjZEdzUxNXR2ei9JVWU1Q1BIZ0RrM2ZCWnlzVisvMnJoL2ZiVVZSZ1JhVVdSeE5iUWlDSVpaRG14QWU4Y3NiRVhsdHZ6Y3pQUEUrMy8rNE8zOFFBZ0Q1cnB6SVVvd0pmV3I5MmE3M1J1TjZJSUF4enZkSW1OWWI2UklBaHBaSkhndFpya3Axc21XWjU1a0FPQUhBRGt3UWFKenNxMEYzZldkNTF3ZmJIVllscFZwTllTaTBVQlk0UktsY2hDcU1KeU4ybWR3b2dWa1FPQUhBRGtnYmE3emI4c20wNjNRdm5HUXFNNTl1cnhHb2lqdWhhVGlFVkVKSTRqWEo1M05DOVBSY1phOUZ2eWtBT1FIQURrZ1F1eDlpdFJEaWpmSGc4dkpaRWRvWUdzcW1nWVF6T09pS3pCV0VzamloaVBKN0xRN0oxc3BjMldvbmM3N3djQU9RRElnd3FTSURNdjhzS2RHemVyTkZrM29KdVRpYmJpQkFJa1ZtZ25LUnFDbEdWcEVxTEhsdWVXbDJmZ2lBN093d0ZBSG1pQUtGUWlFbTRNZHRaZm40NiswRW9hMVNEUEdWVVZqVGltQ2xCVUpUNEVyRUEybXB3NGUrakVrNEE1eUVNT0FQSnV5VU1xNTZyeTR0N1dTd3Z0OXFRZHhUSXFDbEpyRVlGcFdlSkN3RnFqNVRSTG1CU254SmhJVmFPRE1Pc0FJQTk4SHFLcUZlQ3Y5TGV1K0daNlk2M1QxSUJYRVpoTEUySWpKRllRRVlvOGk5SVFuVnBhV0pvRHJOUmgxa0dpZmdDUUJ6Zk1taVhxYnFmSTl2WjgrVVkzampVMWhxbDNOS0tZeEZwYXNjV2dJcXBHQzNkMlB1MnVBVVlQOHBBRGdMd2J3aXdSY1R2RDRYUmpPbjUxdnRjcmhrVU9RR1FNSW9JeGdxb1NncEpQcHQzVjd1TGhXWksrWDgwNjhDQUhBSGxnUFlnSFNqUzRYVmUrNWEzc2lDZ2lxRWNSQkJXaG1VUlUzaE1xdjd6VW1IKzIyKzAxNzh0QkR2S1FBNEE4dUY1RVZUM2dMdS91M0ptcTNGNXVkYVNvS2dLS0FabzJvaFZIQkJSZmxiRWZUeDllVzF4ZDVGdkx2UWNBT1FESWc1MkhYT3h2N3UzNThvWDVWak5ZRVVtTkpiYUdYcU5CcTVHUVJJSnpqbkk4WFcxb3RIUmZtSFVBamdPQVBQQmhsc3Vuayt6V1pQUUtOdG81MU8zUmppSVVKWE1Wa1RHa2thWHlqZ2l6ZkxpM2ZCb2o4YmVCUkE0QWNtQVBJa2oyeDA3YzIrUCtGWXk1RlJzaEtDUW1vblNlb0lIWVdwd0d5cktjODVQaWpJbnMvYVB2QjJmajRFMTQ0TU9zNnVMT3htWXBlclZoakhvTkdCRmNVSXdJU1dRd0lqcWRac1lHT1h0czhjajhmWG5JUVpoMUFKQUhIaUIrUEIwTmQxMTVLWTV0a1ZwTFpBeUpOZlRTbUlWbVNqT3lWR1dGT0QzYk52RWkzMXJ1TlFjQU9iQUh5cVMrK1JYd0FnN1Y2czNwK0JVblpqc3lBaUpZSXlRMklyS1dKRElTMU9PeWJMbGxHMGVNdGZmVEJSMTRrSU8zNEFFRGlCZ1ZKRkFQTHpyQS8vYmwxeTd0ZW5kTlJOU0lrTm9JUlRBQ3JTU2l3cXR6dm50b2J2bTV1ZDVjSXNqK2ZvZ1JFVkY5OTNJNUhMQ2FQSEFBRWNTSW9DcFNmNzZ4Qzk2Y1hUNTg4a1NTUHVsQ01JQmtya0lRZ2lxajBwRlhwU3dzTEZZamlpL3NEdmRHSWxJQnJ0UHFoR0szMU05LytmTUhIdVRBL3VoYjBNQml1NGVJcUlJWHhHc0krZVhoeml2ZTJpd3hWaUpqaUswaHNvWmVJNkdYeHVLOGszdzBQZE15NlRHa3BoSVNFVk81U2w1NDVZVjNiY0orQUpBSDBDSWJxWWdFRWZIVTlLSmh0OHl1bDdEWnNvYllSTnFLWWxSQkVDSXhCQldkRGtidGxjN2lXVUVpWnVQdnpqdDUrYldYRG5LUUEzdHdiTDIvalE5aHRrU2xGZUN1NzIzZjNxaktONTFxbVBxSzNIdWNLbFBucURSZ1JjaUxJbzZjbm91aUtGV0lWZFdHRU9US3pTc0hBRG13Qjh1T0h6bUJpS2lJZUJHcGhrVStYYS95RnlXS1Ftb05Ga0VFSW10cHhSRUk1S0d5VVRCbmo2d2VXWmlGV0ZZUUEzRGswSkVEZ0J6WWcySC81ay85UlE2dkhNYUl1WC9Mc0xveUdidzhzZVptMHhqSk5XamhIVTREN1NRbXNVYUNlbkhUNHRoYzJqbk1qTzlYVVdPTk5TSnlBSkFEZXpCc3FkSGsvSkZUV0dOVlZZT3FPc0JmM3JwOWJXTXl2S2pHWUVVd1lpaTlSMVhwSkFrbWlFN0hrOTV5czNjYTRlNGFycUpNcDFNNUFNaUJQUkRXaUdLKy92bzNGWFMvSitLQmFsd1ZXU2J5ZG9tRVRoeExLNDRSaEZZU0UxdkJJT0pjMVd0cjh0NG9TZHFBUWV0K3lONWc3MTM1WGg3MFFSNUErOXp6bjhlS1lUQVpZY1RzNjRkRXBhdWlrM1BMM2FVay9aQU5ORXNmcUlLbkdVVzRvT3dWQmVKVWd1bzRXbWg5YVhldzJ4ZWtNbUxjYk1ma3dJTWMySU5oRzN0Ym5GdzlRaHhGaXR5ZDdxMDJmSG05TXR4SWpOQ0lMRllFSHp5ZDJOS0tMSGx3R0dOWDFuckxoMmZobFEwYWpFaWRyUDk3Zi9IZk93RElnVDBZOXR6RFR6SGY2YW5jSTVWemIyM2QyaHhXNVhVMXdseVNNcGNtcU1Lb3FFakVVT0twaW1JMUxqbTFQLzZ1cWxZUVdWdFpvOWxvSGdEa3dCNE1LNm9TYXd6VWMxa2VjTnZqNFRoTkc1Y2RVa1RHMEl4aVBCQkZsalF5cE1aUStxcVZxajNiNjgwMWdVaEVyS0tTeElsY3VYN2xBQ0FIOXFDWXNqUFlVNzEvaVNxRS9IWXhlV1ZLMkI1VkpZaWhFVWMwbzNvZE44Wm9rWmZHNWVYcGxjN0MzTDRIQVV4LzJPZlZpNjhlQU9UQUhnejdwUy8vQmsrZGVaaEduS2pjMnhFSnYzSDF6ZGZIVlhXeERJRTBpbWpZcUZaaUU0aU5rYW9xUVhsNHRibHdtdnVJSExJc2s2Ky85QTMrNnIvK1Z3NEFjbUFQaGgxWlhLWHlYbWROdzVwVWJyZzNxQ0o3VFlYS2lpTEd6TWJmaFdaa2lEQk1SOU5seW5BMFRwTm9CaENycXRKcU5PbTBPZ2NBT2JBSHc3SXlaMmx1RVFSLzMvQmljVHNidlRMeGZscDVUMEJCOU82U2JXSkU4eXkzYVp3K010ZnFObWRobHBsVnMrUzFTNjhkQU9UQUhnejcxVzk4a2VXNUJheU42aTNER1VpdURMYmVEbkhjVjFXYTF0YjZJYWFXYUV1c3dWVVZVb1lMdldhM3V4OW1xYXJaRyt3eEtySURnQnpZZzJQT09YWGVvYlZWUU5qT3ArdEpFcjB1Um9LQU5xT1lKSXBJWWt0a0RUNlVHR1I1dmp1L0tpSjI5cGpJUm5MOTF2VURnQnpZZzJNaXNpL3llWmU3ZDNzMEdMNmRqYjdneFZReENGclRrdFprV0NvQTArRjR4WGpPR1dNc3FqRjE0MUNLTXBjRGdCellBMk52WEwvRTZ2d1M1cjRscWhCOGRYVnY2K3JBdTRrVkliRVdwQmI2akswaEZxT1Q0U1R1cGQzak5vcVNmZVozVlRVMzEyOGRlSkFEZTdCc2E3QTd5OFR4KzlPOWczeHlXNjI4Z2FDTktOSkdGR0Zuakl1Uk1STFVSZVQrdll2ZHhVWHFLbFlraUJrT0I2d3VyaDRBNU1BZUhQdmhwei9NUXJ1OXIyWG9BTGN4SGU4TWczc2ppbU1zU3NOYTdJeUJVUVJSOWVJTGQrN1k4dEh6ZGFRbTBYNGxTOUVEZ0J6WWcyUG5qNTNpMFdPbmtmdWsyb3F5S0hmTC9QVVNob20xRWtjV2tUckVTb3dCUmF2SnRGRmx4U0VFZzJxa3FsYURtdjZvTDMvc2UzL3dBQ0FIOW1EWVFuZU9uZkZRRlZScmtGUm9xSGF5OFNVbllUT3hscWFONkNZSmFXeHB4QllENU5ta3NkU2FPek0zTjkvV0dWZVd6cEo0NzhNQlFBN3N3YkNpS25udDVsVUFuU1hxSHFnMnZldExGSzhuMXBKYVN6d0xzNXB4Ukd4RWhCQTNnam5mVHB2emdCSEVHbU5NcDkyUmJyZjl3TDl2Qnd0VDd4TDdqVmUrdnYrbEdITjNpU3JwNTFQT3J4NWRuUmZ6bEFzaExyeW45SjRxQk1yS1V6a0lJbFBwSkYvWjNOdmFBSndnbGFJK2ppSzl2WDdud0lNYzJJTmpZczJzWDFpclVHbFZacGNtL1ZjQ2JEZU1wUkZGSk1hUTJIcWhLdmlBZCtISTBjN0tJOVNjdlZaUlU1YWxmTzJiWDJkeGZ2RUFJQWYyNE5oN0huNkNKRWxxWXJsWk5ldmFZT2VXSk5GR0xSRWRhU2ROYU1ReHNUVUVVWW9pYnhYRHlVclVUTDlGUCtUZHdOdDdBSkIzbVQxMitpRTZyZmEzU0NUYzZPOXNUUWx2cVdqWTF4Q0pUTDBuRWhtMHJFcWJpRDEvK3ZESitSbEFJbFUxa1kzRVJ2WUFJTzgyKzRrUC9NdWNQL1RvUHoxTUVhSFhuT09wMDgvd3lTZStsMGVPdlljLytkRS85MGNqeEJKaFoyOFhFYm5ML2w1bDArbG1rVjlQak1rTktzYVlXcUl0cmhOM2NZNUk1WkhqYzZzbm1UVU1WZFg0NEpsa0UvN2F2L3YvUEFESXU4bDhjS2dHb2U2WDdXdjFHVUgySHdrYXhIa25XWmx4ZlBrVXAxZlBjV2poR0tmV0xyeWpYOXZQL1BMUDBtbzBWVlZESFdhSkE2cFhocnN2MkNUZWkyM05tUlZaZ3hpaG0wWmlRaUNmVHRlcVVYNUtyRVRVYTdnR01LZVBuWkVIbVZUdW9JcjF1OWdrSDdNOTJwUXFWQ0lpeG9peFJveEZ4TWdzL2k1OUpUdmpiYm01YzRPeUtpU3lFYU5peE50M1htZStzOHlKNVVkd3JrSGgrdSs0MS9mOUgvNFV0N2J1U09XY21hM1RKZzZObjFvNStpRXBxOE1Cd1FlVjBqczBLS1BDcVhyaXROTzZQdFQ4NjFtZUZTSlNDZUt5SWc5cksydTg4TW8zRHdEeWJyRit0a2ZwUzFGVk0zdEVWUTB3WS9tb0pjb1VGVlROS0J2SXBmVTNtUlpUakJocE4zcjBtc3RNODVLaksvTThjdndSYm16ZGVNZTh2bWNmZVpKYm03Y1paeE1CckVDYVZXVTROciswZURScFBKTTdiMVZWZ2dhcW9HU2xvM1JCT3ZOenc3NGJmMkU0SFUyQUVzR1ZWZW0vK1lDQzR5REUrdDhJMTJjaGxqbC8rT0dsczJ2bjFtWkFTVURiSXJSUmJTbmFDQnBTRjF3eUtVWlI0UXF6Tjk0eU4zZmVrbEYrVTZ5eGZOZVQzL1V0MzFaRW1Hc3Q4dkN4cDNqZnVlLzRROGhESURJR0Vka2ZmNis4OStYdDZmaTFOSTZtVFdPa0VSbkVHQUtCWmh3aHdlT3k0a1MzMFZsQ0pCS1JmUTNEQjNyMC9jQ0QvTk51RGpHaXFBR1JIM3ZmbjNuaWV4Ny93Yi84ek5rUG5oWmpSbGsxOFZrNU5hcmFvTzROM0pVc0F6VWhCQ2xjaGc4RjQyd3N2L1hTYnpFYno1QjY1azhraVJ2U2FmVEVHTXZtK0FheGJlQ0Qrd041YlM5ZGVvM2pLNGZaR2U0SjlRaTdCZEptRkp1SDU1WSswb0JseERCMWxVeXJDdTlWQ3VlMDIrNDBvcm4yRzdmNjYyOW9VS2VxbFlpNHBjVWxQdlRlRDNIbHhwVURnTHlML0lmTWJzam81TktaL2tyMzZQSGwxcUYvN2FIVnh6Lzl6Tm5uSGoyMmRNd2lZWnBYbVJSVllXY2cyVmVJRldhQThNSFhpREN6QkwvT1k2VHlCY05zajYzQmJRSERmR3VKTkdxUVY5TS9rSmVYVndXUmphUnk3bTVYUFlqdzZNcWhzeDNsUFpsemxDRkk2UU5CQTg2ckZxV3pVYXU1dFZVTWY2Y284Z3FoRk1TaEdvNGZQbjRBa0hlTEpWRUtxS2lxQU9iMU95L0xhN2RmZlBQSTNJbGh3L2Erb3huTmZmam8zSW1QbkZsNStKbUhqenh4K3NMUjh6ME1icU4vSjl6M3Z0NE5QWlJaSG9OYUJMdWYxd1QxRXRRallsQU5QSG42L1Z6ZmV2c1A1RFgrcFIvOENRYVRNWnY5dlgyQXhMbDM5cEdGNVNPbm11MFBaV1ZwQUNtRHd3ZVlsQldWY3pLL3ZGTHN1TkVYUnBQUlFKQlNqRGdSRTA0ZE82V1hyMTgrQU1pN3daNDY4VDRteFlUQzVYZnprRWt4a3BkdWZlUFNmR2RsYTZtNy9KRFI2SmdKaldQTDdiVm5qeStkK01qcDVZY2VmKzZoRDU4OHRIRE1YbHAvYXk4RTUrK0cvSFVkTkdHL1hDeVMzQWNnQlNXTm15elBIZUxtOWgvTUxmeWVFeWZaSHV4eGUzZEhWTlZJM2Z5TGo2MnNwcWZhdmZlNXNsb1FFYTFtWHFSd1FUU29KSEhDUUtyZjNoM3RiUXBTQVpVUFB0eloydGJLRlFjQWVUZlkrMDU5a0p0NzF5V3ZNbWFMUVNLSXFYeGgzN2p6eld1OVR1L3k2dHpxMFdhY0hzN0xTZ2pTYU1XOTQwdXR4YWVQTDU5NDMvdlBmM0JwZDlxL3VkRy9OVElpZ3FMLzRaLytqNS8razUvNGt6L1k2WFQyWHJ2NjZuaW12YkdQSUZWVlBicDRraHZiZnpDMzhMUG5MdkNMWC8wQ1JrVENEQ0JBakxFODNGdDR2R1BzbVgzVm5OSjVuUGRrem1NUTAxM29Ycm15YytjMWFncWhTa1NjYXREZi92dC9uTG41RkN0ZGpxMGVZM05uRHgvOEFVQWVORHUzK2pBN2t4MEtsK09ELzVZcVRkQmdYci8xNHAzQ1YyK2RXRG0yMG0zMmptdFFFOVRqblVvaThkeEtiL0h4VTJ1bmt5KysrY1huSzErVUFDZFhUc2JuRGoveTU5NTc5cGsvY1dUNTJQak5tMjljejhxcEFpcGlRZ2hlYjI1Zm03R0UvdjdiMTk5K2t6T3JSNmljbzNKT1pyc2V5YkRNemJPclI0OHZtdWpaeWdYamc1S0pNcmZVbzdNMHAwdEx2WGloMWFpdURiYS9rcFhsV01EVkhmbWdQL3RMRi9uNml4dXl1VFdTbmY1UThxTDhJeityZFFDUTM4WGUybmlkRTR1bkdlWjlndnA5TDdJL3Z4UUF1Yjd6OXVEbTN0VVhqeTRmVFZmblZrNjE0cmdSVVBGZWlheXhqbkx2aTI5Ky9qZnlLc3NCK2VhVmJ3eWZQUHJjb1VRNlAzcDY1ZlIzTEhRWGIvL094UysvSVFnSUFaSFFiblFwL3dERGxKWGVQSnZEUFpoMXhZRTRoQkE5L2RDWkk2ZU9yWDJ3dWR4TFd5dnpMSjg2d3NyUlZYd0lNczBLaVl6NHpjbm9kN1lub3kzcXZaS2dpbFNWTjFVVmJGazVVNVNWaE5rMHd0Mnl4d0ZBSGh5YmF5MHd5b2VvQnJUbXJWV3BTUThDRUFSaFo3eWR2N1grK3F1SEZnOFZhNHRycDl0cDBvbU00RUxncGR1WFgvelNHNy82T2FDYy9UdW0xV1RyNU9LRjh5RTNqemJTdHYvS3BTOSt2cWl5Y2w4RnFuVDVIK2gxdTlEcDBXNm5aSGtoUGdTelg0bjc2SE9Qclg3NFErLzk0T0xoMVo1cE40bmpoTEowVk02UlpRVkpISXRFNW8yTG0zZXUzZ3NUaVVCbUpXL1pyK2JkMzJmVFA0b2dPV2dVL2g1ZVpGS01VSlNnUVlWN2lyRkFydWhZa05IbVlIM3J2LzdjZi9Zelg3LysvSDhieEc5MVdqR2phbHE5ZFB2eUJ2VXdJSXFxZ1AzcVcxL2FlUEhtODM5cldycmQzVUc1bU1UdHp1d3orRU5wdUYxYXY4a2YvKzZQME91MGRFWUo1QUQzdFV0WGJsUysyb2lzd1lyQlJoR05aa3FyMmNBWWlFVG1sNXF0SjRCNUVYb2l6S3ZTVmRYTzdNK3VxbmFBSnBEeUxlWHZQMW9XSFVEaDk3YktWZlZOWW96NkVOU0kxVUF0ZktuVUFYWmVadVovL3NMZitPVllySHp3M0FmK3RSdkQzZmptN3RXM2dXSjJjNnJXMWF6MEgzenQ3M3hqc1gzazE3enBQbHA2YlZKejhSZ1I1TnZUajUvNGw1N2p5bHRiN0d4UHNjYmd2Y2VIQUJwUTlYZS9zWGRLMm9pSllzT2JyMjc5TTcyK3lYaE1NNG5ybHpPVFNIamg3V3U3bFlhYm5VaWVydGxONmwvTVJvWktBNzRxVFNUbTVGSzdlMmhuTXBMRitiUnorRkJycnBGR2FaN1pxV2h6TkpsV2d5dTNiZzZCZlBhVXN3dEQ3L01vQndCNVVFeFZDY0Z6L3ZCVDNOaDlNeFJWVVdsOWNnd1E3WTYyNVc5OTRYLzRoVzVuK2FGWDd0ejZ5R2g4NTJaOUlFUkFEVE9kalJPckp4YzNzdUhpMW1UVWJrU043b2k3RFVrQXZ2T1p2OFR1OEJvdnZQWDMrUDRmZXB5Lys3ZS9SaFJabHBhNm5ENjN4Q3N2MzJUWUgzUDJYQmVQMHQ4cjJiZzlSWXpoaGVkdi94K0tzYmY3SXhRTnN5M0RNQmhOUjVjM3RsNzcwSVhGVDZLaFZaYTVWSzdDR0tIYmJyS3pOOEJFOXNpanA1Y3ZIRHE3ZFA3TWlibG4xNWJtbjU1dm4yaXN6cC9QTzYyMTNaMmQ0bzMvK3FkLzduLzZSMS81N1l2M2V3K1JPa3c5dEx6RzhiVWpmUFdWYnh3QTVFRXdIengvNnFQL1Z4NDdjMEZYbDdxOGZPVWxIVTFIWHRGcWRrTmFIeXB6ZFdmRDdVMkhZeU5oYzNZb1pCYmJwNmRXVHMrZlAvYlJQejNJbysvTWZISEx4cTMwdnZCS0FKcnBIR2VPZm9nWDN2cDcvTi8vOGk5Sk5pMlpUa3JSb1B6NnJ3VEVpQmdETDcrd1BydUZhOW1DcEdFMVNTTXRpM3BjSlVram9xakczWFJTL3RPQkQyUmxxYXA2bDVaVVZhdS8vNFhudjM1bWRlMU81djI1WVpaUjVFV2R5MXRoV3BZa2F0YSsreE9ILyt6SkMvR0sxZVhPeWNOUG1lT3JqOUxwTEpNMjI4ZkhrK3F4d1c2eHVMM1QvMCsvOGRaTGI5KzdaelFZWTFBTklhb0p0UStTOUFmRlhyNytCWjQ2OTE0T3p5OVQrWW83dSt1SWlCWEVBdnJJc1llWFR4MTYraTljM3JxOXN6dTQ5SE5WTlhIVS8xK3kxRjNxUG5QK2UvL0VxR3I4NUtESTI5WkcvZEZrL1hPajhhMDdzOUNqRkRGaFd1enh3bHUvSUNGVXByODdOZU5SWVl2QzJiTDBrWE1ocmlvZjFWOXI1SnhhNTBKVVZjSGttWlBndzR5R0YyeGt4RnBoT2ltNThOZ2htczJJRXljWDJOd1lmOHRyZXY2TnQ5bmY1N0RHbURDYnk3cDhlOE45OU1MNXg3TnBlZmI2K2hiOThWaTJCMk51N2V4eFoyc1hweTQrZGFheDJHNHZwTTg5OFFPY1dIdVVLTzFKMU9oaWtqWTJiWm5CeHZCVVErUGVqYTNici9iSHc1eDduRnlockVvdHE0cjNuSHVVbXh1M0RnRHlvTmdyVjEvaVBTY2ZveHZQYzJuamtna2g3TTloOFYzditlN1RRUlkrZTMzM3hsdWJPNi8rTDZvK0JxSkcwbWcrYys2N1ArWE40bDhZbFc0SkFURlJmM2YzalYrYlpGdTNtUzB0QVdFMDNaU2c1ZDA5RFJFU1ZWS0JWS0V4UzNvYjFKMzVCQ0ZHN3liQmx2MWQ4YUM0S2toM3JrbWpHZE5wcDd6NjhoMCsvQjFudVhIdFd6WFBIejk1akt3c3BmSmUyUCs1RUgzNDBZZU9uMTVhZkNiNFlBMEl3ZU9xa2p5ZjRpcEhvOVhtdWZkL2xKczNKL0xhNVl0eVkvc0tWMjVmNVByR20zTDE2dXV5ZnJzdmFVaFByUzBzeThWYlYxN0ppdHp0QXlUTWtyamwrVVZ1YmQ0NUFNaURaQzlkZVptenF3OXhlZk50NDRPM3M4TXFQL0RzOXovcnBQV3BHenMzLzlldDNUZGVGS0ZoallrKytQQ25QOVpxbi82L2JFOG5oeFJWRVJGcm90MmQzZGQrWlpydjNXRTJza0U5NFdpMVpsSlBSYVNwU25NR2lPYTNQZnRnU2JnM1VmeFBsRmVyMGpQb1o0U2djdlQ0UE11ckhTNWYydjZXMS9Qd3NjUGtsWlBoTkJQQUdwRlVWZU5lTTUxNzM3blRIOHRLMzZ5Y1E0TW4rTUJvbWpHWTVNUzJ3NldOTGI1KzhXdFU2UTZ0SlUrSVJvd250N2g2OVJXZS8rWWIwbXdzeEV1dGhWTnJpeXM3Mzd6MDZrWDJTZXNnK09CMW5FMDFML0tESE9SQnM5ZHV2eW91K05sSWZGMnFYZWoxamxFMnFyTFllZ0VORFVXU0kwdW5sK1o3Wi83NCtqZy9YSmVMdGI3d05ReTlMMGJmMWlPSUZZMUVTRlZwek1aUjJwLyt6Sk1uTHp5NmNrb0Q3VGkxblNqU3RDeW1WYjgvNm05dlpOdFhMdy91WEh4amR5ZWJWc002VktOU0pRY0tWWFdpK0oyZFNSQVJQdmZHRzNyaVRKdnJseWM4Kzc3bitOcnpYK1hTblUzcFQ2YlVBNVgxSkxKQzlNYXQ5VnVqdkxqUmFVUnp1MzJIQ3lvVmhuWjNIa3hDSkpaako4N3lFOS85NXpoNitqUzk5Z0lTWURyWTR1MDNYMkg5eXEvdzZwV3Y4K2p4OXk2ZVhqdjV4ei80MkRNdmZPbVZyNzAwQTNVVlFwQXNtL0taajMwUHYvamJ2M1lBa0FmSjNsNS9xOTRacVRjTkxXQ2Jwclc2T0Qrdjg0bE9nQmFvbmVzZWUyVGk0OGM4ZVMzUm9hcldTSlZOTjc0eG5tNXZNUHZML2R1LzlocmFhRFRqN2svKzJmYy85WUVQbjNsdWRhMzN3VWJMbnZGZVcwRTE5dDZUVGZ0K010M0w4NG5yRC9hcTlhM2Q4dWFOcStPdi9lUGZ1UExGalR1ajIwQXNRcVJLcnFxVkJxcXR6VkZvdGlORVJGZFdsakRHRU1leHJPLzFSY0hvL2p6V2pMa2s3V1l0YWUrbVlXK09ZQXh4Mm1BeGJyQ3lzTURGeTFkNDhpTWY1cy8vMjMrWjNzSUNSREZVRG55QWhhTWNYbjZJOGEySW4vOWYvaWRldmZFVlBiZjZ2dlB2di9EMEg3dStlZlBLemMzMWZQWXozTkxDb3ZBT1pzSStBTWcvajBtOUg2aXFySFJYNTZMUU9MelNYano2c1VjLzlwMHZYZjNHcjFhK0pJazdoOG9RRWxCRkRDRTRJVlMzTjdkZi9VZVZ6d3VRTUNzRFd4RnBBSzN2L09RakovL1ZmK3M3ZnZMUWtkWjN4bWx5V0tVUlY1VlNWWTZ5TEhEVkJJZEVjZExvR0ZOMmtrWjhyRG5YZkxZMzEvNzQvRUxuVTYrL3ZQbXJyNzEwKzdmMmRxZGJzODk0V3M4TVUxVkZDRnNiT2ExbXFtOWRmRk9DOXliVUlJL3VoblhRYWFSMGYvelRLNSthWHg2ZnVyUFhrNlc1ZVVJUWh0TXBnOUdJczQ5YzRIdCsvRWVKcldVNkhPRExFcU9nSmtKQ1FFS2cwK3p5eUpIMzhjcXRMOG1iTjcrZUhsdDg5SDBYamoxMCtPYm0rdTQrK1lVQXZmWTdWeFQwQUNEL1FtQ0NIbDQ0UEM5cWp3ZW55ZE9ubnY2eDk1Mzd5UHFYM3Z4ZjN4QU56Y1ZXVDZiNUNDTkdCT252N2I3MTB4dTdyMSthUlZkMUdWaElWYlg1cC82bER6MzlVLy9LUi8rMWxiWGVCM3psa3FKVTlTNmlLSEs4OStTbEo2dkFtRG1jZVBKUVVualJ6Q3NhbWZtRjVlYkhIbnY4MEpQTHkrMlB2UHJ5bmYvbTBwdWJyOTFYU3NhNVVMbXgraUxyaTZyZUxUSkluWGUwVkxYVGFLU05QL1ZqSDNqOG94OCs5MTJIVnQ2ZkhEcTd6QmUvK0pzTXRqWnh3VE8zTU1lSFAvdERuTHZ3RUZWZW9BRjhQc1dtRGJUTUthWVp3LzZZMjNmdTBJeWFQSFBtbzN6dDBtOXlZK3VOem5SYXRldHpWMnV2VDR0TUZoY1c5ZHl4dzF5NmVlY0FJQStjellLREV5c251b2p0VGljbHpuSHNqejM5MlovcVovMy9ibjN2bG52a1ZGdVB6YTl3YStmNjlaMyt4Yjk3YSt1RjN3enE5NXVNZFVpanBKLzkwYWNmL25QLytpZit6ZTVpNXdOVkpZakdDRUhxa1hGTFRjMWVZQ1doZEJtbEwzQkFvU0taRjZvQUVodWEzYWkzVkxVLzlmampSeFphcmZnL2YrbWJ0NzdCdldGTEJkVVFBbnFmNTFEVkZ0RCtzUi8vMFlkKzVFZCs5SHNlTzNmMGt3MHpQYnErOVFwNzJaZFpmblNiSlRIa0U0WFNZZWQzdUhiOUJmTHBGbG14aDBpVGJuT1ZoYzRLcmVZODZUUm1OQnd3R0EwNXZIYUk5NXg2SDE5NDdRdlhYcnR4YVZqblduWHpzRDhhOGovOWc1L2g1LzgvL3dtZi9EUC8rZ0ZBSGtBTGdFN2RkQ3BHSmxuaHFMem5jUGZ3WTMvNlkzLzJKMy8rcTc5MDdjM2JiOHBEaDg1emJqbS9zcnY3eFJkTGx3Y1JTVlMxTWJ1NTdmZDg1c0xwZi9VdmZmemZYRnp0dlU5OXJZVldPcVVLbHRJcmtLQmFvQ0ZBOEdUbGdNcVZWQjZxTWhDY29xRU81azFrSkc1R3R0bU1QM0R1M0dyYldQTWZ2dkMxRzgvdmwxaUJNR3NNN2dNMCtjaEhQbno0ci95VmYrZDd6NTA5Ky8zekxmZjA3YXRmaU83c2ZsNGsyU1J1eFVTdEZvR1VwQXVsRzNQeHpxOHhlVE13R2c5eDNqSFhiWk9hQ0xSRkl6bE9XMDhnSXFncTIzdDdMQzBlNXNtejc4KysvUEpWdU1zT1Uzc1JWZFcvK1F1Ly9JN01RdzdLdlA5OG9kVitGU3ZhNkc5V2p4MS9UM2VwdmZLVU1kS29uR2UrUFgvbzFOcXBZNWMzTGpjM1JtTjdjdVhDOGxPbm5qaFV1T0hWamY3dG9hckdJdEo4L054alIvNlZIL21wdjNCNjhaSHZyTWFKSlFvaUtWVGVVRG9JQ3NFN3B2bUVySmhRbERtVm05YUxUSVhpaTRCV2lxOFU1eFQxaWlwUzVvNHE5NnVkYnFPYkY5WExnMzQybVlIRTMzZEJ4cC82MUNlUC9NZi84Vi8vUHovM3pETi9icnIxMWJPM3IvMTNwdElYc2VsVVRKd1NtTU9GUUZWbGxLWEhCME5SZVhKWE1wNTYrcnVPNmJpaWNCWERVWjhyMXkvempSZGVJcDhJQzYwRlhPVW9Tc2VSNVVPOWRxZDE2YVZMcjErakhveXNSTVFIVlYzc0xaRTJtbXp2N2h3QTVFR3d5RVQ3QUJIQVZyNlNhenZYcnkzUHIxYnpuWldIcWtvYVJWN1pYdHB1UEhieXRIRWg0L3B3bkNSMjVkaHpENzN2L05IbE5iL2V2OVYvLzhQUG5mbUxuLzFMLzhZeXB6K2EzV3hIK2EydWpHKzB5QXFnVnhFaVQxbFZaTVdVU1RFaHI2WjRMY21MbktJSWFBVmFCbkJLY0tCQkNUTS80WjFLTnFuRUdqbWFOcVAxMjdjR0Y0UFhhZ1lRRmFsWkV2L2tUL3pJbzkvOXllLytDL2xnNi9EMXQvOUxiYzczUld4RDNBeWNMdFRleVR0UFZubktNdUM5WVRqMWxDNWdGSW84TUo0NGlxbVNqenhiNjMxdWJkeWkwMXRnc2JWSU5zM1VtcWk3dXJ6Y3VyNTErMnZiZXp0alp0U25xb1FiRyt0NlpHMk45YTNOQTRBOENQYmtxV2NZWmdOeHZycnJVUWJUdmVxVm15KzlQc29ucnlkUkdocHh1MTE1bWpiRTBZbVZ3OFJSNFBwZ0tIa1dyNXcvZk9HcEo4ODhldVRqajM3NDQ2dWQxV2NHL1R3YTlITXBwcDVpVHlodXROaTlIWEROQ2JSTE1sZFJ1Z0x2QXVyQk80ZXJmTzB4WnFGVkNIV1YxUWNsVXZCZXFhcWdaZTdpdWNYMkNlLzFoZTNOMFlaSUhXck42RVBqelRzM21qL3d5ZmQvcEJIcjhjM05MMkJqTDBHYU9OTWtCSU56QlVWVlVVNFU1d3o5Z1NmTFBTSkNjRkM1Z0hNUWlrQXhMcG1PS3ZMTU1Ca05XTis2VHFlM1REZnV5bVF5WWFIYlc0c2J5Y1ZYTHI5NU9YanZnVXBSTHlLYXhESDk0ZkFBSUErQ25UNzBFTHVqSFlvcXZ6OWQxN0lxd3VXTk4yKytmUE1idjdNNTJYelpXTHRlZVh4WlN1dFFaNkYxcU5PUnFTL0R4dDVlL3A1anA4OHNOcnRIeHNOY3lqS1E1NDdSSktjc3F6cCtHN2JZdXdNdTNZTEdnQkFDUlpVVG5FT2R3NVVPWDlWRDkvdGV3ODBlN3dMZUtWWGhaVG91Tlk1c1I2emN1blY5NytVUTFNMXViNEJrZTNmSTA0OHRuamwrNHNJVHUzc3ZHT2Y3SWdKaUY4QXUxZDhubXpJZGVLb00wbTVLR1J6QkM5NkRxd0xCeC9nU3BxT01iRmhTRmg0Tkh1OEx0dnBiTkpKNUdsRkRzeXlManF3Y1d0NGE3THh3ZTN0ajk1N2FsZnE5NGVBZGw0Y2NBT1Qvb0IxZlBzVzFyY3NFRGN3MkJ1OXRHNHFFeWhmVnJkMnJ0NzU1OVVzdlh0cDY4MnRXek9Xc21HNjZxaHd1dHh0UnAxbGxLOTFPVTlRbVJlSEluR2VjT09ZdkxMSjZZcFhkOVF4ZlZZUkpnOG10RmpCQlc5dFVMcWNvU3NxeXdsY0JEYlhpb0hyRkJ5VW9sRTV4dmc2M3l0d3puWlQ0eXBsMko1V05qZEZ2WjlOcXltemNvOTRFeEpUNWxqMTM0dWlIMUpSZFk3ZnEzcVU2Z2pZSU9vZlhDQk43S2p4QkExclhDaWhkSUhqRlY0NGlyNmdLVDFXQU9rdkFZYXhRRkZQMnhuMWE2YnlrSmlYNHNMaTRzTER6OVlzdnZ4eENxQUJualBHendzRUJRQjRFdTdsOWpSQTh6NTc3b0d3UE4yWmJnek1kY3ZadmFBbUFtK1Q5OFp0M1hyajJ6ZXRmZnYzUzV1dXZMQzYweHQvNTFBZWZ3OWxPNWJ4b2dJbUZwMy8wQ1Q3eG1hYzRjYmJEN2EvOU5wdnJKVFpwWWNzVXY3MkN4NkdOUFNxWFFhVklBTy9yaFNudmxjcERIcUFNNExVT3RmTGNNeDdtVXVhVmROb3BvMUgrbGQyZDZZWUk3cjVrUFY3ZjdHZEhsL1g4OHVyYVdaUHVpTVdJRWZDdVFNMDhVZU1RS2lWT3B3U3Z1RXJyWE1RcDNvSDNuaXAzVkVVZ0x4ek8xZmVGTmJVWWFGYU9HRTRuTExaWEpZbmlxTk5xSjd1VC91K3M3Mnp0Q3VLb3grd0Q3N0JGcWdPQS9IUFl2L1g5L3c1S0lDOXpta21UY1Q3U0dWRDJLMFgzSDBJTEdrK0tVZmpzZDMzZnMwK2RmZkxaUEM5c1ZRVUpDbG9FdW5NdGpwNWU1TVcvOVYveGkvL3c3L0NsMjVkWlNsWnBON29vQnIrOWloOHM0R1dJMmlHSk5SU3VCb1lHQ0VGd0toUU9xaXFRWnhYVGNjbDBsRk1WcGJiYmlUV1JYTHArYmUvVm1iY3JaMTdFbGhXYVdPOU9IdTk5dUxGSTAyV0ZHQlc4T295a1dOdERhQUNDOTQ2OHFBaE9jV1ZkRkFoQjhRR0MxOXFUbENVU3RKNGlFVVdBYVRGaU9uV3N6UjhpalpQZTh1THkrdk52dnZoSzBGQ3BxcHVGVys4b2dCenNwUDl6V0greXl5UWY4MWQvK0QrZzIreHAwRER6SVBqN0puUkxvQlJ3cWxvZFB6N2ZldWk1OVhOaC9qVWJwNHBnNi9GRmdXdGZ1czQvK3M4K3oxZC84d3FmZTN1VDE2OStCUzIvam9nanl4ekRVY253eWpMVkt4K0YyKytqekZvRThSampzT0xSNE5DeWhDd2pUSE9xU1VreENMaHhoSEh6dUdtbnNkQmRmY2dhczc4TEw5VExraVhnWDN4OTgrWExsMi85VGlpRGFDeGFCWTlXRGpmZVJzS0lKTzdRVEhxa1NWUnZ1WmpaZUZuUW1TcVY3TmUrNngxaVUzL3pmY0x1SkRic1RLNXpkZjBhVnFTZDJ1aENzOUZvY204di82QVA4aURaaTFlL3dlV050L2pGci8wYzI2Tjd1K0RmKzRuSG1VeHpwbGtwcWhqcS9ZcEdveEYzL20vLzd2dC85SWtuaSs4UGpUZGphWTdGVCthUnNvVXhRaFJCUG5MRXJkTWNYbnFJUmR2ZzA1LzVDTWVmZlpiTHIyN1dpWGZ3aUUrUXlXRjh0bENmTEkwUTM4RG5NZVU0Smt5YVJOTWxtdGs1eXQxbHNrR2J5QitXZkRSbkpzT3VOYlJlNm85djMvbzJEeGROY3llZEx2ckllN3JQOWhiaWxnVzBVSHhXRW56QW1pYSt5aEFLQ2xkUVZZcjNndTZIZUxPd3E1aFVWSlZIWnVRbXp0ZmV4aGlEOXdWN2c1RWVXVG9oWXVYeUYxLzkybTg3Nzhlem5vaWJlYlozVGpuLzRKai9pN2ZWdFNiVHI1ZFFLNTVGcXNUR1N2SnYvOFVuUC9iTWUrSWZRc3VHeGg2ejloTGRkSVBvNWhueTlUUFlhb0VRaE1vNW5tby95cW41RTJ4c3RERXJIa2xpcWl6RFdzRlhqckp5aE9rS1puTVJhUlI0cVhDVngxWWVrL3ZaenNhSW5mNkF2QWc0TndBYmt6UzZoeHFOeFNQYzI0Vy9YNjh3dkg1NTk4MjkzZXlWdyszb08vd280SXM2UEtxeUxiTE5BYzRIS3U4eGxTT01QVVVBaWN5TXZrS0pESGQxdUl3bVlCU1JnamlKQ0tFaWlpSW14WUE3dStzY1dqbDhmMGoxanV5a0h3RGs5OEgreHYvOFZXYXJyMGJyYmIvNHV6OXg5TWd6ai9kK09JbnRJVzhNWGdOaWxLaTdRWHA2QXhaZnBkbzVpZDE5THpLWnA2dzhhYXRCZjMzTW5hdXZVWGxvSkJaUWlpb3dyVHk1T2lKcnNPT0V5a2VVd1lGNFJ2bVF6ZkVlMDJ5VDZXUVhyNTRvaVNsY2hVSFYzUnZSbC9zZUFPMGxjZEtZYU5OTzZzNjhlc1dGL1R3akoxUUJWd1h3TU56TXVMaytKZW1sZEZaYmdLQmU2KzZpUXRDeWRnZXo3eTdHSU5ZUXB5SzNkNjRGVExSbmpGVHZaSkFjQU9UM3lRU3AyZHdoamlNVGYrQjlKNTliV0QzNWVDRU9yWWEwa2dVd0NTNGFZTXdBc1gxTWU0K3NkeE8zZlk1eSt3amlsbWkzbTlqSWtlVWx6Z2VVV2pYUklBVG5HYnVBaWxCb1JSWnlLcDlUNlpDNGxUSFl2TTZSbnVYSC92eFBrWGNXK1AvOTlmOEdWNVdSR0pQYzUwRm1CTjNZT0RibWsrOWZlKyt4cGRiak4yK1gzTHhUa0JlK3ppZEVhRFFNM1haRXQxMUg1bFlNRVFiWEw5bkpIUEZjZ3lMek9PY0psVWNNaUZGRVFGQUNOWFZRb2lsNWxWWFhOMjZ0T3gvMmQ5WERnUWQ1bHlHRU92K3dLOHVONXNwUzQ1bkVoazUvTWxCakNsRm5zRkVITVIyTWRhUnBob2tDSnRtaFd0akJIbTVTYkIxbWV2MGtabkNjaGFSTlVUa21SVUdDb1FwZ2crSzhVbW1nVUU4VlBNRWFUaDVib1NOdzhjb1lIeXpMeTNPOE5WQ2dpYlUycWx5NEh5QXpPVG5pUTh2TjlxbWozUTlOTTIxTXA2b2lrVmdqVkZYQUJXV1NlVGEzSzVvTmc3WENaRnJUc3ZvUXFBWVY0MzZPcGhGRjZmRGVFeGxiOTJoVUNTSFVGT0RXRUluMVJWbTlmSHY5MW90bFdUckFDeEwwSFVqa2V3Q1EzeS9UZXdldzI0bFNhN0oyV1d5ZzNsTjZ3Ym1NeUFaUU1DWWlUZzZSeERtcXUwUlc2TFF6N0pGTHRJL2VZUHZtQXV0dkh5SjE1K2swRnhtYmdKTUtaNFNxY0FRZjZsaE93S3V3dWU2NGtRdUxjNCt4T2Q3aXIvMUgvek11V0VLbFJJMUkxWmw3TUFZclFxeEtkT3BvYiszWWtkNzU1Y1ZJVmxjYm11ZWV5YlJrZlRQbnptYUJxaENzTUJ3N05uZW1aRmxKcjVXUVJMYk9PWXBBbWVjZ001Y1FQRUhyY0VzOWlBRWJXVFdSblY0Zjd2M1N4WTJ0VjJjRHYwNkVnS0ovODcvNFNmN1V2L0czRHdEeXJ2RWpJTmFZS0tDMmNFcmxJSWdoc2hiMUFlOXpqSUl2YytLa1Eyem1VRElxcHpodmFmYzhjbjRidjdUSjVUZmZ3bTBlbzVxdW9PVUMrQTZSTWJTeG1PQVlhU0NvSTJRZVgzbFNFK0VrSmg5T3dVWVlXN2YvSXB0RTk0VlhFVWdheDVKKzRvUEhQbmhrcmJ2aVE2VWhJTVlxclZiRXNhTXBuWGJNdFZ0VHB0T0FvR1JaeFdDVU01NFVyQzEyU0dLTGpRTFdneXNjUmdTWENOWUkxcHE2VVNOZ28wZ2ltMVJGOEp1Z1JWME9yek9YdWJrbWYvMy8rMXNISHVUZDRVRHUvVEhObkovbW9haTg0QldzVlpJNFJkVGdmRUhoUEJFRlV1WFl1SVdONXpHYWs3c001enplUTY4WmNlcThZM1AxTGJhMjNtRDdqdUFIeTBURk1sSTF5SVBncTdwWjZIM0F1UW0rbUlLcmlFVFFBQ1pLTUlJM3ZxanVnUU9qcXZHNWt3dHJ6ejF4K0R1enZHaDZMeGhUb1ZwdkE0dGF1aDNoN0lrR2IxK2RjdlZtQmtBY1daenpyTytNNmJaUzJvMTROaGNXY001QjViRHRGSXhncllDbzJpZ1dNZW5BT2JkVjV4MWExY09UR3B6ekJ5SFd1OFoxQ1B0OHQ3cXpWNVNqc1J2N01DTm9ReEVjVlZDaXhzTmtic3pPNERKenpZUkd5Q0N2Y0hRSUppVzRqT0E5d1lPVTBDQmlZYzdRYkRpeXlSMnk2VTJ5a2FLVFFOR3ZHTzBWakVjVlZhNzRRZ21WWUxDSU5iU1NOcDF1ZTJOaisvS2wyV2NmNmxZaDZmc2ZYM2x5ZDNkeU5nU0hOVUlVV2VMWWtzYlFUQTFscFV3blFoSkhHQTFNcGdWSkVpRkdjSlZuYnpobE9CS2FhVnp2ampoUEtDb0V4YllhWUdxUWlnU3RndHVaVEtzdGF0a0VMMEpRZldkU054d0E1UGZma1lScDVsemxkTGZ5R2xCalFsQXFWK0ZDUWJ1N3pNa3pmNUt2ZmVQbnViTCtUUlpiQmdrT0RYc1lNWmlvYnMwcjlWSlVQR09QVXd4Umt0Q1FRRUpGTTRaZXh6STNiNWtNU3Fiam5Na3dZem9wY1ZWQVJZbWFUWHFMS3pTMkpyQlZDK2FnY0hTMXMzWjhyZmZwcloxOFBvbUVSbUlJNmtsalE1bFl4bEluNVRzN0pkbkVzYkxVWm05VVVGYWV5QnJpcUM0Lzl3Y1RObmNEOCswR2xvRDNnVElyU1JGTXU0RTFNVVlNbFhPRG9uUmo3akl0aW9McWVGcnl3aXZ2TEpiRmcwNzY3Nk1QVWEzRk1WV0puM2w2OWVUcWN2dERQa2pzOVI3VFRaWk5PSGZ1MDF4NDZPUHNEU3RldTNpUmNWWlJGWUwzU2pFTlpLV1NUUUxGdEM3cGhxcWV2d28rRUVKQVhkMm5FQXdFQTJxd1lrbmlHQ09Dc1VJY1d4cEpTcmZYdGhqeitzMWIvYmRuRjJUOG1lODgrYkgzbkovL2tWYlR0cUxJSUFhOGc2SlVxc3F6dmwxeThjcVl5Y1FSQWxoclNLS0luZjYwTGhDanVDcGdETGpLc2I2YjQxeWdFVXU5Y09VY1ZneHgwc0JFRWtaWitaczNidTE5S1FTZGlwQXpteXgrSjM2S0J3RDVmYkJPSnlZRWxmdElFYUpPTzRtT0hlMDkwMmhHeXpVOVd5MHVPODFIdU5Eay9FTWY1dXlaSjBtU0ZkNTQreUk3Z3o1WkJWVWxPSy8xam9kQ1dTcWhEUGdxMUx2b3M5SGQ0Qld0QXFvQlgzbnlyS1RNSzF6bFFNRWFDd0tOWnVLOThzM3IxL2N1QWRISnc1M1Z6M3puOFo4OHN0WjR4SUQ0QU03VjlRVUY5b2FlRzNjeU5uY3l4dE9LUmhwUlZvRTBzWWpDOXM0WU1XWTJBbCtYN2x6bEdVNDlhU3pFdGdhSmVvK0pSR3hzM2NiVzZHZnZiSXhlQjUxSkk4ajlzZ2dIQUhuUTdjLzg2Y2U0Y1hNczArbGREZko0ZldOYVBmSFUya1BOZHZxb0Q0Z3hnZzlDNWd4M2RtNFJ5d3BySzZjNWUvWVIxbGJQc05NZmNlUDJMYVpGZ1F1R3FxaUpHZTZPbVJjZWx3ZkszSk5OSE5OeHlYaVFNZXhQR1E4eXBwT2NxcWdJUHV4ZjhnaENrc1JWWHJybmI5NGFYQUhpSC9qNHNlY2VPN3Y0SThOeGFQWUh0WWNveTBCUktsa1cyQjFVN1BacldialJ1S1NzQXUxbWpBWm9OUk9jRCt6dVRURFdFSHlnS012Wm5pNE1wbzdZQ2tsazBLQXFJRVIyNjlibStPZjd3K3dta0lsUXdEdHZpdmNBSUw5UDlzaXhSVm9MQ1Z2YlU0YkR1OE9LY2VXQ0hqclU3U3d1dDU5QlRFc1VuSWZTQ3p2VGpKZGZlb0ViYnc0NGN1UTRaODlkNE1KRDc2WFhPY1RsS3plNXZiNU9VUWFjaHp3UDVMbW5LbW9QVWhXZTZhaGtzRGRsWjN0SWYyZkVhRGltekFwYzVRamU0MzNBTzRkM0RoR3Bwcm4vNnNiVytPcVo0KzJsZitsSHp2K3B4Ym5PK2IyOWd1RTRrQmNCVlJpT0hOZHVUN2l6TlVXQVpoTFRTQ04yaHpsUkpMUWJNVDRvYVJJeG1WYmtoU09FZ1BPT2FqWUNyeDZ5cWc2MXJBRlVLWnkrZUdjdis4VnBWZzJBRENqajJMcUhIMTVsYTJ0eUFKQUgyU0tCeldIR3FiVWVkN1p6bWRTNkhQc053MmhyY3pvNGZXYnBmQlRIWit2OUNaRktZWklKVXovbGQ3NzBSWDdsNy80bUd1RFFvY004OGNTelBIeitLVnFOUmE1ZXU4T2RqVzJtZVVsZUJJckNNNTVXREljNXcvNlU0V0RNZEpKUmxXWGR1ZGFBcTdtdjdqNGhCRFRvY0RqMS8zaHZrTi8rOFUrZitzaDNmK1QwWjQySm9tN1B5dkppRzFWbE1ISHM5VXVHbzVLaWNPd09NNkxJMG03R3hOYXd0WnZSYWtiRTF0VGJMd2pEY1RHYjZLMVhjVU1BZ3hLQ2twV2Vkc05pQlNaWjlkcG12L2hIcFF2akdVQXFhMDJ3SW96R3hRRkFIaVI3NHRnOHk5MEd1NVA2VUtZR1Z1ZGI5SGNMV2QrWjNwK0hXQ0NhVGl1UHltaGhvZjBFWWhjcXIxcDZaSnA1bkJPNnEwMXUzcmpLMy9tYmY1OWYvZVZmb1NncUhyN3dDRTg5OVQ0KzhvRlBNaGtFUHZlLy9DWTcyeE0ydDRkc2JQWFoyeHN4R0k2WlpEbFZWYzAwRmJXZWRGRzlONFdvcURVR0V5ZmZ1SFpuL0t0clMybjdUMy9tM0UrdUxQVk9xRHJ5TEpja1ZnNnRHcndMdkgxOVFuK1kwMnJHMUdRS09YbmhhRGNUdkZlMkJ4bTlWa3BRaUszQnVVQmVWSlJsN2RrMEJGQWx0blVPWlMwMEVpdWwwMi91VEt2ZnJGd1lBZm1NYURzMGtvaEpWaDBBNUVHeEl3czk1cG9XWXcwYmd4eFZGYS9JcEhCbWtKV21wdlZVdTUra00xT1p1bk5uMU04eXY5MW9OaDRKd2N6bEZWcVdRVndWOEI0V2p2VG9wakZibDlmNTlYLzRPWDd0MTMrZGF6ZXVNNyt3d1BXcjEvblM1Ny9Dai8zUW4rWE15ZmRRWkZDVzlYQmdIZUh2ajMrWnVnR0RZbzNVemJzUWlOUDB6dTdZLzYyZHZlbTE3Ly9Zc1E4OCtmRFM5MlY1bVJaRktVWHVpYU02Wk92M0EzakROUE1VVmFDUlJuUmJDVHQ3R2YxeHdlSmNnOG0wSWlzY3ZWWU5HR3NNL1dGV0Z3azhWS1hPMXJGcUQrTWNZaU56YzFLRi8yRjlVTHl4SDE2SjRGVFJiaWRsUEMwUEFQSWcyTkdsTnFLRy9yU1F6V0V1cGZkbXBqSmx0YWJWM05mclNBUWFVcmN1R2tDcVNtdGpmYlE3SGhWN3h0cmpZT2FEMW9JMzNpbVZWeHBMS1d2SEZwZzNDVGV2M2VUeUYxN2t0ei8zT2I3NC9KY1o1eVh2ZWZ4SjN2dmtzNXcrL2hDSGwwNHcxMXlpSGMvUmFTelJiaTFnNHdaVnFBaStRaEJDQ0JwSFVWNEUrM2R2ckk5L2EzV3gwZjNoN3o3NVE3MTI4bENSZXhtTkhPTnhZSHZQY1d2VHNiSHRTQ1BEZkRmQnVjQndYR0NOb2R0SkdVNEtCcU9DUm1MWkhSYkVrU0dON1YwV2xiM2hsTWdhdkJPcXU0UHNnaXFUVVJIKzFwMXg4Y3MrNkppWnNLY0l3WWpvYUZLK0l6L3JBNEQ4SDdCMkkyWXd6V1dZVlZLNFlGVTFtb0VpNVo0Q1ZCTm9BYzBvc2xGa2JXb2prOWFhSHhMdjdrNTNkclludDlYckdzZ0tOY1ZnVGJ5UWUxd0V5V3FEcGJVZUZ4WlhPZVJpV2hPbG5CUjg2Wld2ODVWdmZKa1hYMzJKMit1MzJPN3Y0cldDdEdLWTd6S1o3bENWVXlRRWZGQ01zV09uMGMvYzNzNStzU2o5OVBGelMrZmU4OWpLRDBaZE8xZElUR0VTU21PNXRWN3g1cVUrU1dLSVk0dTFobTRyeGp1bFA4d3hScGhycDB5eml1MytsQ2d5N0F4eTVqdHBQUkxqUEZYaG1Fd3I0amdpekNaNVJYQ1Y2dis2VjdxL1ViaXdPZk1lT2VEU3lJYjVWc3kwOU8vTXZQTGd1UCt6MjJZL0UwQm1lbjUzd3lmdWFXc2tpNHZ6VFFOcFpFT3YyMnA5cUNxckZTdVJuVXd6VVlLMVVlSW5tZHNiN1U2ZW4rL1k0MWMzUjczMlhKT2trNEsxcU5TQ0hhWWhyQityMEJXdzB5N0grekh4YU15b21ESXNSa3lxZ0VFUkNiZ3lweW9jVm9CUXI0eEhrZDByZy9uWjIxdlRuNmtxWHdKaU9vM3F5Sk56WVdtbERiS0lKNmJJdTVTZDIxemZmWkZYci9RNXR0em02R29MQXl6TU5ZbXM0ZnFkSVZubG1lczJVSVdkd1pTZ3l0VTdBMWJuV3pnZlNCUEJHTVc1UUtzWk1abUdVSG4vNnNENXY1VTd2MDdkRkN3QUowaElZK3FwNW5kcTRlWGd1UDl2V3lPMnVLQTRYKy9IaFh1SmR6Sjdta0M4MW1zZW1rdk5pYm1WRmJPMHZQYit0Ni9lYmxkaHNsd1d4ZmY0b2t3cUh4TmhNTVpnc1JxRTZmblRpK1gzL2NDUjFqLys0aFl2dkxwRFdYcmlWa0xTU3VwYlhFQkRvQ3dkWlZsUk9VZFFqelVlUXlDVWpyeXNaa3NYZ2pFQ3FxSXFQaUF2ajNOK2VxZWYvK1BLaFV3RXEwcnkzRWZYRHEwYzZuVWJqU1djUzhteWlQRlFxYW9KNXg1YkpXbFpYbmx4blozK2xFZlBMSUpBdTUxdzlzUUNyMXphNHM3V2lNVmVnNVdGSmp0N0dlczd0VEJveTlic0p0Mm1aWklGdlBjc2Q3dkZidTUrS2V2dlhSRndXb09qQXJ3eGFGRUZiU1Z5QUpBL3FuWjR2c0h1WkZaZHViY0VGZDBIakphSXRELyt5TnBUcDVjN1AxR1cxV09WU3NpbnU0ZVRhdUt5ckxUajNEVWpvcm94b0xQaWtuamlocGw3Ly91NlBQWm93dUxjWVk0ZDYvSEN5enU4ZFhHTE8xZDJVZW9OUEd2cWZUeURvbHIzS1pSd3R5RnZqWWhCeEtDcVFRb1h1QXo2bFhFZWZtazA4ZnU2Z0tpU0hEM2Fubi95OGNOUGQxcExjMTRiZUo4dzZBZDJ0dGZ4NVFSWFZSdy9Qa2UzbmZEcWkrdThjSEdiTTBkNnMwbGQ1ZXl4Qlc1c2p0Z2I1c3gxVXBZWFdveHY3WEh0em9BVHk2MWFKMGlFWmdQeXFkR1ZkRDVxeEg3eCtyQmZCY1doNmtVa1JNYm9rZmxGdlRQWVpuM2czckdmLzBFTzhudlk2ZVUyTGloZVZVb1g3amI5WmpsR0MrZ2tzZTMrNEhPbnZ1dDk1NWIrOGx3aitrQXJqaGNhUmhmYU5zUnI4NDIwbDVxNG0xb1JWQ29YeEhtVkVGUmNVUG5naHhiNXNSOWJKWW1GSkxMTTl4TG1Wem9zTHZkb3BqRVNBdm5Fa1k4cnFnSjhKVFdMaUlwYWtXQVFGU1dvbDF3RHQ1M25kNHFLdjVNVjRXZDJoLzVYeWtwdk1xTWRtcjJrK0YvKzgrOS81aU1mZmVRbjRxVGRyVnlMMGJERjdaczN5YVo3dUN5SDBxTkFFbG1XbDFwTUM4ZVZHMzFhYVV3anFlL1R4VjREYTRUYkcyUEtxcUxkc1BWdVNGYVJHTUU1c0NabU1WM1VSRkpCNVBhZHllaUxsWGNaa0lsSUZSa2JsanM5TmtmRGQvUVpPUEFndjRmRlJ0aktIRm5sMFhCUGJHWUdqdlpTTjEzOXhDT0gvdGpEaDdwL09rR09PdEJXeDJwdm9TT3VESXhISmFrWWVtbkVVcXRrWEZUMHA0Nk5QVTl2T2VYSC8vZ2hPcjJZOFNTQ2FCWHNsSVhGS1NhT1dGMXAwTjlaNHM3dE1UZXU3TEN4UHFESVBYRmlDR0l2RGNibDEwUzFVTlgxb0hwTlZiY3FIMjVWWHZ2M2dhS2NlWThJaUZ1dEtMN3c4TkduT3IzZVduOVlhVlVzeVdodlFGbE8wRkNBOHpXbmxTcVZDeVNSNGZ6WkpScHB6SnRYZGprMDMySnRzVVZRWmJIWEpCeFNMdDdZZ1ZEUmExcTIrcDVZUGQxbXpLRzVOU0xYbE1GZ0l1MTI0MHl2MFZ6TXFtSkhaaFFPUVFNaEJIMm5uNEVEZ1B3ZWRtMTdTcElZQ1VIM0JTNzN3NnIyNmVYT2lXZU9MZnpVdWFYMmovUldrczdhK1JhZHRVUVFYNThBaGF4ZnNYTXI1ODdWS1Z1M00xcmppbTdUc2RDcENGSGc0cXQ5ZXZNSlM2dHJxRDFCMHNsbzZEWWg5TkVRNmhKcUV0R0lJMXhaTXRpYk1EL2Z3Sm40cmExQi92Tmw0ZnFLRG9ESkxQSGRaM01zOStQOFdaUVFBZEVUVHg1ZFdUdmNmU29yY2hsUFVoME5keGtWTzBnRWxJRVFTZDBaZDRIVTFDVFlsVmRPSEdyVHNjS0xiMnd4emlxT3JyUXBDMCt6RVhQeTBEd1hyMjdoS3FWbExlTnA0TUt4Tlk3TUhXWm5keUJCQStyRDRjVkc2K2pHcUg5SjY0RURxNHA3QjY2Z0g0UlkveXgyWnJYRjVxZzBZVWIrTmdOSDU2RzE3bE1YbGp0LzhlVHh1VTgvL3FtenJVYy9kWlMxYzRiMkFxUnRhSFFOalo2bHN4S3pjcUxKMFllNkxCMXVFc2VXNEFXWDFUb0ZiN3phNTVWdjdERWFHM3BMUzVnWXltcEVsay94enVOOVRlYzVIQlRjdWJtTmVxL05Wa093MGVYdHZleXJsZk1UWUg5a0l3T20rLzJGR1VBVWlFU2tZYTFwL3ZpZmVPcmpIL3pnOFIrYlRKSW9uNlNTVFljVXhZQXlIMU1WUlMyajRHczVCVkZCWmhkOENFb2pqbGhkYUhKN2M4emVzS0NWUnZXTTEyd1ljalN1Y0VYZzdKRWp2TytoUjlGUWo3bFBzNkptVlV6amk5ZjZPNjl3bDIxUy9LVEsxWVZ3QUpBL3F0YU1JeG5sMWI3M1NJSFdRcU54SXRYazM1WTArc1FuZi9LcDZKbnZmMGhzWEJHOGdJOHh4TWorVEpLcjErUk1KTFFYWXBhT3QxZzQya0ZOUkRad3hHSVlEZ3JlZk9VMmI3MXhqZUZnUUt0bk1XazlzZXRtTE8yalFjbnQ2MXN6K2h5UlRxL3I4eW84UHhwbDJ6TkE3SU5pWDlaZ3Y2bFFzem9LN2JWRDNjV2YrclBQL1puZVhQZkNhSkJLTnM3RWxTTjhPYVVzeHFnTFJGSmY3eUVJZWVZSnBTZEtUQzJyNEFLUk5jeTNVM1lIT1h2amdtWmltV1lsVlZGQ2NCeGJXZFB2ZXVKSlNhT1lvbklVWmNWNE1sVU5SR2tTYjE4ZDduNDVxQlpBaWVDZDk2RVIxUnVJQndENW8xYmFUV0pHV1NXK0x1a21RTXVJdE5wUitza3F5Si82OEE4K0hQL0FUejB0SnFyNXFVU2FDQ2xDQ3RMRXV3cFZ4VVNtMXFIU2dMR0d0Qk94ZUxKRDNHdVFiWmNrR0tMSXNyczk1T3JGMjF5NXVFTlJRbXVoUmZCQ1dRVHlxV2R2ZTRTcm5LZ3FyVmFybDdiU2pZM040U1hWK3hXanZ1VWxHQ0FXSXkxVm10LzM2UXZQZnQvM1BmNVRSZGJybElXaHlFZFNGZ09LYkVEd0hsRWxWSXBvN1RHQzFtUUxRczI5NndLVVZYMlFPNjJFV3hzanl0SmgxRE1aWjFSQjE1ODg5K2pXK1VPSHU4UHB4QXduVTRxeVlwcmxCSTlwTlJyRGZwbC9lVnprZzVrWGNTSVNyQmo5MkVPUGNYVm44d0FnZjFUczMvMHJmNTdmL1B6WHVFOC9QQUU2Q3QyMk5EN3o4T01yVC84YmYvVTdaRzUxWHRSYmpOYUt0T29Gd1lKSk1GRktrclF3VVVJVVdaTEVZbzNEQ0NSVzZTNm5GRkhNZUtjaUNtQ3R4WWd3SGt5NWZuR2J2YTBjazhRb2hpTDNGSmxuTXNyeFBsQ1Z6aDQrMUh0b1lhbTVreFg1UnBiNSswRVJJWGZudjFLVU50RDVDLy9xQno5emFIbitBM2tlbXhCVWduTlU1UVJYVFhHRngrY2VONnB3bFNKR3NMT2wrbjF5YWgrVW9naGs0NUl5ZDB6R1UyNXQxcDdIZTcrM1Y0U2ZPN0Z5N1BhcDVZV0hzN3lJS2gra0xFdU1NYUllSW1QdzZJdDN4b1ByTXk5WGlZZy8zRnZRcFhhWEsrOVFnQndrNmIrTHBXbkM0VVBMc3JHNUt5RUVNMU9rVFk4ZFhsbHFhM0xoeVErZU1LdkhWbkNWZ25PSUM0ajMxTlJPQW1LUXVBZDRSQ2NZU1RIaXNMRWxTaXJLb3I2YWpqelVZYTh3N0Z6Y0piclZwK21WdEJOVFZDVjcxM2Vwc294RFoxZnBMblU0OTlnUzV4N3Q0cjNTNmpSWVBiSTgzK3JHLzdJTDFYdkg0MnI5enUzSmE5Lzg2dlhYdnZIOHJac2hNR0hHZVFXa0gvMk9rMmNmZXVqUUI3MXJKSUlCVjZHdXF2ZHFRNkRLUFg3a2NKbkhOQzNXMUd1N1NFa1ZvUFQxN29xSVVCYU9qZlVCazlGVXgxbEptZmxKbzJsK2NYUG9mdlBLNXViNUQ1NDlOVTZUdUdVbHd3aWtjVVJ1S2tUazBGS3ovWXdSK1oyZ09wMzlicEpFa2JqZzM3SForZ0ZBdnMzK28vL0gvNGxmK0llZlp6aWF5RXpzUGdGTnJUWEpULzJKVDMvMDVWZGVmL2pwanp3a2NTeUVzc0JOeDBSWUlqWDE3SlBFV0JNalVVemxDb3haUVdVRU9pYVdPVXprQ0xIUVNJUmVOdURRY1lqYk1mNmhPWnA0bW1tRHBDbTBGNkE5bHhMSENkMkZPWnF0bERpSk1EWWhpaUpFWW5FK3JCSGsrNXp6akVmNTNvYytkTzdtYXkvZitQTGYrL2xYZnVYdGk5dTNBUnNuTnYzaEgzN3N1enV0NUh3SU5YRkM4QVhHSmdpQlNKUllsYUx3WUFTVEdGUVVsUURXMUI1Q0ZTMDllVlp4WjdOUHZ6OVc1d09xcW9XR2Y3alRyMzYyOHFHOHRMNys1ckFvcjNlYTdaVjIyeE1VR1U5eTlnWlRLdWVqeE5vanpTUnRUb284bWdIRWJJK0g0Y2pjd2dGQS9xalkxZXQzUUZVbWszd2ZJTEVxOFE5OHowZFBsbm4xbWNxUDVvNGNTaWpHRThSQlpGTWlVdUlRVU9PQUZERkozWEEzZ1NBNnU4d1RWQ0t3Q2JFUlZEMk51R1N4VTlCTUU2Sk9nME9IbDFpYVh5T09LNnlwaUV3TEVWdkxDRWlFYzI2bVltdFF0VVExU1MvWWlrN0hMTFFhOFVLbkU4NjNldnJNTC96c1czL2o5UmMzTHoxOFlXWDF4TEdsOTFzVE5iSnNpdExDUkRIV0swbTBRSjczUWFIWmkvQUMza2pkSEwxTGFWMUxBZzFHT1RldWJyRzNOOElBVG1Xbjhud3g5LzV2bGk2c0MwU2J3MUUreVBMWERpMHNQbFU0dGFxMUFsYWprWkJQS3hxTnhwbVRjMHVIWHR1OHRRVllWTTI0ek9VclY5L2ltV05uK1ByTnl3Y0FlYWZici83Nmw5bmEyVU1FbzFvUElUWmJqY2FGTXlmZS80VXZmUDI4WjBlSzBSMTJiKzlBNldra2N6UTc4NGlKTUhFWDU4R0htclF3a000MitSeGdFWTBRU2NHa3FLM29MRFdSdE1zazIwS00wbTJrZEJvUnhxUjREYk5SOFRxdHFEZjNMRDdVRElXUnRVUW1KamcvMjd1QXlvTlltNXc2MDNuNnU3Ly9vVVBkZVA0ckgvN29ZYnR5YU82OGR6VUJ0Y3NjVlZrUkFJbWIrR0NJUkxETmlNelhOQ3hlbFdMcThhVm5QSzY0ZFdPUDlaczdWRVdweG9oNHpNVitVZjBYNHpKOE5hajJnUXFSV0ZYVFMrc2JMNTAvY3VTSDQ4aDJyTEVFQXExR2dqcXd5S0Yybkt3QmI4ek9uZ21xdE9KNFJtSng0RUhlMFpZa0NWZXUzOFphdXorTUdBUEo5Mzd5dzBmNy9jRjNybTlzZGhwTjFjbGdLczFHUmpWeGxPTVJSVFdsMVZtaDBaaW4wcHFZTm9xYldCVkVETWEwcVZ5SlNveVFvajRDTFdrMEt4QWhTWlEwRWRyZEZ0WUtsZ2lYRFFqQkV6ZGFlSjhqdGdsWVltdFJkUmlwUUIzR0pFUllOSlNvVll4Uk1SWk9QTlErT3R3Sm56MTdaQ0ZJUmV4bXhEb1NSZGdRQ01XWXN1aVQ5cHFZeUpOTjYwcVdJcmpjNHlZVi9iMmNxMWQzMmJ6ZHg4YUtzVllDdkQzTTliOVozODAvUCt1N1RHWkpkNktxZW5sejY2MnNLTmVOa2JQR0dOcU5wdVJKd1hZNW9vVzB1NDNtVVd0TTdFT0lGS3lBSk5iS083V3JmZ0NRL2ZLUE1VaE44eThoK0gxZGo2VFZhcVNuamgxNSt2WFgzM3JQY0RoRVExTTJOa1lzclhYeEJzUjU4c2tXWlRrbVNoZXdjWThrbmtkRFJNRGlYTUE3UTFYRk9HK3hWb2ppbURoT1VDWTBvb1JPWTRsV0s4SVlQOU02ZDZBZXdaTVAxaW1MakdidkVDWnVvZXFJb3BoYXlUbkNHb014aXNHQ0NvMW1qR2lLM3hqd2lNUDBybTdiTytzN0pLMDJwdFdnU0R2WXhRVTBGdUs0alFTSGt6RjNqMmRReXN5emZudkUyMjl0TVI2V3hJbkYycUJWMEN1RFhQL3pHeHVUejg4YWxDUHFEcjdPQkRpVG5kRm9jMXlXbHcvMWVtZkhreHlaRVdwSFVhenRSclBac0kzblZqcTlYMTBmOXNmM2hWaytObnJnUWQ3cFZsVlZMYkYzcjNQZWVQYTlqeTI1cXZ6RXRXdlg1cXdScXRLeE55akpjcUZ5UXNKTWhxREl5SXVDU3Jld1VaczRYcWJVbE5JSGpCaGFTWk00NmRIdHJoSEVZWmdnQkx3RXJBbnN5L1NKMXJ2Y1NYTVI3d01ocERRc3hIRUhWWSs2S1NxQXREQlJDMnZxWFJBTkVNVktPZ21VVnd1U055YWNxSUpZcDVRRGo3TkRTcTA3ZEhaK0huTm9IajhIcnN3SlhxaUtnQm9ZVHh4WHIrenc5cHM3VEtjbFNTSkVzZUE4bTRQTS8vYzN0ckxmQ3FwRDduWHc5eGZKQmFodTcrNk8zcng5Kzh1eDJPL0lxaXBGTEoxV2s2SndlT2RwTjVvWGx0dmRRK3ZEL3FaQWhJZ05xazZTVnAzd0hBRGtuV3VoN3VnYTZ2R01CSWlYNW5zbjd0eTYvZGplOWpiV1dNMUtMN3Ziam14VXgvd2hGclRXc3FSQUtFTWdHNDNJc3lFU1JUVGJIUnJOTGxGM2pvV0ZOdDJPa2hjanF1bHQ0amlpMFJRR081dFVTWk4yWndVa0JnSWFiRjBOYThlNFBNTjdKYkwxWW05VmpURlJBNE9yRzN4QlVWOVFYTjltOE5KTjhvMEprZ2VzS0VscWlDUm1PSEZNTWs4Y0cvenVnR0l3WnJlaHRFOTBxWUtpa1REb1Y3ejJ5am8zcjJ3aUtyUmFGb3dTWUc5YzZmOTRhenYvbFJCME5BUEhGS2lrNXJPVFdaaFZsczZWMTNkMlhuLzJvZk9iWjdxZDQzdDdBemE4STJzbWtvMExySEtvWWVPandPdlVVMkRHaHlDMyt6dnZ5SGI2Z2NydHQ0TGpYbGFNSmlzcmk2MExaNDkvL003dDlTTWFncUtJVnNyMVMyT3lxU2ZQWVc4TWc2a3d5V0U4VVNaam1FeVVvcXBwT0VNeHBkMk1hQmhJcEFUWnhPb2RwTm9sRWs4MUdXQ0tPdFF5MUlVemNSN3JIYUtPTXM4cHBoT3Fja1JaanFqY2xPQXIxQmRvbGVORFJUbVpzUHUxTjluN3gyOFRkaWRFcWxoWDc3aVhBZm9qaHkrRnlBdlp5TkdmbEd6MXA4VGJPWEo1U0g1cnl2ck5DUys5ZUp1clZ6YnFzcTZsMWhjMFpqeXQ5RzlmMjV6K1BlZkQ0SDdQSVNLdWtTUkJSR1ljdS9Xb3krMmRuWTFHR3IyMXZEQkh1NWxxTTAxWTZIUXd4dWpPYUpTMlRQeFViR3hjVndqVktNamVlQ2lmZXU1akJ5SFdPejBWQWF6VUZabjQ2U2ZPSDJzM0c5OTErODZHamF6Rk84RW9yTjhhTWR3cWNjWXlLWlE0RnBwcExXM2daMHRNWW9VMFNWbGFPc0xDL0RMTnhLSlNVdVlsdnN4cHRCWVFFeVBHMHVvZEpVbm1acmcwUkVtYnlkNEdrOUlRTlphd1VRTU5HVWhCVUlzeFN4Z3ZHUEZVNHo1Ylg3cksrTW9XeGdxSkZTSmo2bzJWbVZaZ0oyMVFpV2Q3VkxBK0tHZ3R4QncrM01KNDhCTkhLd3JrbzRySjVnZ05ZQ05iTjlCRlhGN3BMMTdmbVA1c1ZmbTlid09IQi9UdzRvTHVqc1lNcHRPZ3FoN3dyMTYvMFgvdDZyVmJldVFvb3l4blZGUU1zaW1EZkVxZUZhYWJ4T2ZiU2RycDU5UEo3QXphU3IyWGQyQWw2d0FnOTJ5LzhtK0JSRVNpUng0NjljeVh2dnpOdzNtZXE4SEkvblQyZUZKUzVMVjJYelowREpVNmxMR0NpWVU0RVpwTllXbSt6Y0xDY3QyY0E2b3FRNnFTVUhsS044VGFwSDZTRmlGRXFBc29TdUVDd3hFNGJ5bkxIR09WTkRWWTR5QTBJUWlvVUUxeSt0Kzh5ZVROVFlJUklnelQzR05zVGE4U25ESWFPaHFSME8wbUJJbm9ORDByaXcwYXFhWHlTbVFqUmlPUGpoeXRQR1l2T0FBMVJyUUtmTzMyVHZZejA3emFuRldyYXFvZXhLV3hEZDFPb3BmWE4xam90UGZ6QnovTFNjckpkSHE3UHhybW95eHZHS0NaSnJTYktlcUNkQnFOYzRlN2M2ZjcrWFJUUkdMQWVCL00yemN1aDNkYUhuSUFrRzhGaUJHUlNGWHR3eGRPTFhSYXJROWR1bnlsWVVRSXMzRW5FY0dYeWpqM05DTkxNWEdVV2srLzJsaUlHeEV0TE0ybUpZNEVyWElLRnlna3g1b3BrUkVNS2Q1N0tpZFk0N0F5Qm1KRXdQbkFjSy9QZURyRm1nVHZTdEoyaTNaekRyemdOVUs4RUptRTNaZmZadnVWTFVvZmFIZDZwSEhLTU52REttUlRwVC95VEljVGppNHBWUktUdGlQbWxpeHgyeEt3alBQQXptN0pyWnNEM3J3eVlLZnZvV1hRcFVEcDlkV05RZm5mRGtibFRlcHA0YnM4VmtZSWpVYWtqVWJNdi8vamY1ei80T2QvUWJrbkorMkJZbU00dVBqbzBhTzdDNTMyRVlOZ2pTVnJObVU4bW1wWmxtMXJ6TnFzaWhVcFdCKzhiT3hzSDNpUWR6aEE5bnNmMGZ1ZmVlTGsxdWJPK1d5YUc1QnZ1ZGVDZzd3S1JERmt1YWQwTllXSXNZYW9VSUtyeTJCYm13UFVCd3dKUnFaRWpackV2SmtlQm9uUlVLRFdFa1JSbjZNaE1Ka015UE1DMU9CY1JtcUVidHFwR2R5RDFrZFFFb3FSNCtZM2JqUGFHS0lOeTF5elpEaWRzam1zYWxhVHl0RnVHazRlN3FHbE1wd01xYUtFU1NsRXpqQXBTdGJYQjl6ZUdMUFo5NHluZFhoamNnTVRPeGpaNGg5dTdXWnZjbytGcEFLOGlJVGx4YVpPTW9mM2dYLy83L3djN3ovL0VDOWN1YUtsOHg3VXFlS3ZiZS9lVnBHTk9MSkhhdmVpV0d1SW80aThxQnBIT3ZPUHY3bTkvbHVWOXprMUFZdU1pdXdBSU8vMDhLcm1yU0krdkxKdzlrdGZlSDQrK0gyMXNudDZ5ZU5weFdqaW1GdTJFQnVjVThxcHd6bVBqU3g1SGxOV0NaVlhSdU9TN2x5TGRsTXhWWW14aHFMYUpyYTFmRUNhZG9odFRIQUZXVDZpS1BJNkZaS1lLTFowdW5XdTR2SVIrQUkxOHhndDZMOTJqYTBiZTRBeTM3YjR3akVZT25xbVhwVnR0Uk9TdEM0YkYwNHhKdUxYdm5FTlZlWEVVb2RRZWE3ZW5EQXBMRFpPVUMwd3RRNE9yazlaV2hsU3k1anNTelFIUUVOUU5yYW5kMFBOL2RpcXFKeGFZelFFOVlDN3RMNitOY3p5aXl1ZDd1TWlHcFZsaVE4ZU1TSUthU2RLbmpuVW0xKzVzYmV6Tnp1SDc4aUMwUUZBdmkxQkI2S0YrVjVyTkJ4ZjJOM3Rkd1hxZlk0NnZxckhOVXJIYUZ3Z3NTVnFSRWlsVFBLSzdmVStaVkdTTmhKNkMyMFdWenYwRjF0MDVwVHVuS1hkRmhvcFdEUEZSdEJPQlpFS0w2QUtSVm1SVjVCRVlQRTA0ZzVDUkZsTXNjSGhxZ2toV0lvM2Q4bGZ2Y214cFFhRlY1ck5tT25Vc1pBb1VXSlJsSGE3bnRmYW5hU1V3Ykk3blhKOWU4d2dMNW5tR2RiQmFCd1RSVEZaWGxGNXhSZ0RLT0w4eWp6Ujk1ZEorNDJkWXRLZnZTLzdvcCswbTIwbTJUMG05cTllZktzR2l1cE0rQURmSDAvR3I5Kys5ZFhWUng3OVpCeW5TeUlUUUVuVG1NazBwM0p1NVhCbjd1U052WjIzZ1VoVnpVeGJYcDg1Zm9hdjM3aDhBSkEvYkV2VGxLSW92ajMvaUw3dlV4OWVVK1dSb3Foc1VNSE9wUHpxUXdCR0RVVVdFQXRweXpLWk9wd3FlNE14MldTS0dHRjlZNXYwY2twdm9jdnE0VGxXam5SWldHN1NhRm9hRFNHSmhid3BxR1pFOWJra3k0UXNWNXBSb0pYQWFIZVhMSnBndENKT2xLcDBoTGQyS0YrdmVhZ0NobEZSY2FrL1pqRzFyTFpTaWhEUmFEWFptd3E1ZzhIVU14enRNWnlNYVJuTHRUeHdzMTl3cEdOcHRpS0tJdUNkbnkxRnlTeWFWSWxjZUc2bDJmcUJxZnJyV1pudnIvSld4aGpwTmp0TXNzbTNKTk1Yamh6V0s1dGJvZkkrb09vVnl1dGIyM2ZNZSt6RVdydVV4aEh0UmxwUEZxZ2lMc3d2TmRyblJPU0xxcG9wOVNoQVlpUGt3SU84Zzl5R01ZUVFoRnJ0TlVLSW5uM3lzVWZlZXVQeTJlbDBpcGd3RTUrc2d3bGpRWUpRVlhVOU4yMWI0bWxFdTl1ZzJXNVE1QVUrZU5RTDQ0bGpZM3VIcTVkMldWeEtXVDIyd05yeFJlYVdXblE2RWEybW9UOHdOQnFRUkVKUmVxcXE3c3czRXhCWG9sclFTQVZybEpCNXhxOFBTQXRGRW91SXNGVXFyOXphWXI2VmNtNXBuamhKYUhySXk0cHBYcElWQmJ1REtUdkRDU1pVOUV6RTl0UmpqTERhS1BBaEVMekZoM293cXZTS1J6V0JXRno0cnJtaytXdFpWUXhRaldjaHFKdm1rMytpMHJUWTduRFQ3bEk1dDEvSkNwZldOMjcxUjhOclNXU09KMGxDV1RteHRwNWtkcFZ2UmxGeXVwbWtyV21SajJmbGRkTk9HM1hINlFBZzc0REVZelo3ZFYrQ2JsZVdGOUx4WVB6dzlXdTNGcHlyaUdNQkNTaGdDS2d4b1BYT2VGNEJrY0UySXJxTERjNDlmSVRCWHIwb3RialFJVWxTcHBPUzRUQm5iMitNR3hlTTNoNXo2ODFOdXF0ZEZ0WTZ6TTJsOUhvUnNSWFUxODA5VklsUnpJd3dybFpRcnRWeGQzeEZjV2RNb3hGaEkwTmVlQ1o1d1kzTkVhWHpIRnZvRWdiMUxWMjV3R2hhTXBwa2xNN1RUZzFyVFNneTVlWklpY1hSYTBCUkdvS0NOUkJGZ2drcXFtaFpWa2M3VWZycHlOaFhuSGQzZHppRzAvRS8wZlcyeGpJcGlydVZMSUZ3WjNkMzU5TDYraXVQSHp2eGZtdE1MTlJTQ2MxR3dtUmNTS1J5OGxCM2J1bHlrZS9zNXlGNVZVcmgzVHNHSU8vcWxkczBUWEhPeVN3eFQ0SG1NMDg5dHR4Skd6L3c4aXR2bkMrS0RHdjJDWmdGa2JyY1lsQVdEblZZUERGUFpHdlpnVGcxek0wM09IeDhqa2Zmczh5akQ1L2kyTEU1VnRjaVZvKzBPWE5tbWU5OTdsRjZ2c3VWMTk1bTY5b2VXOWVIN08xTUdJOHJzaUpRT3VydWR4R1lUanpqc1dNODhSUjVvQ3pyN3J4R2xteG5Tbjl2eW1CY1VMbEFIQnUyQndWNzB3SWIxVE5kV2U0b25HTTZ6UWxCaWFNSU1TQjR5bEtZaEVEdWxOZ29CSVAzTlFyM2I0dWdpS3FZU09pbG5kYnp3M3g2bTNxUDNQRzdDRzVlbjVWb3BiNXhMQ0tSUXJJeU45ODZzYnp5aWNrMGErUmxBU3A0cCtSRmhURW1CQ05mdXozY3V3VlVnbFJCTmZTemlUNSs3QlRyZzcwREQvS0hhYlB4RXJrL1FWK2M3eTBNaCtNVGc4RVFHeGtsT0JHUjJYOVVnOFJhSVRoSFdYamFhVVM3VlNzdFJWSnJpbmZiRWMwR2VGZUFVVnFkaEhPOUpaYnRVU1kzYm5MbThCeWJPeU4yK2huOWkxTzIzeHdRZDJJYWl4RnpxMjJXRDgrVFJKYnBzR0E4bUZLVkZVa2MwV3pFcEkyWXVKTmd4Z1d0eUpLbUVYT1M0Z0pjMmU1emZXL0E0VjZIMUVRNDc4bENMZXlaaXNIN1VKTktHMHZQQ2lOZnNwNEZlcVlrSXNFRWkwUHJSU3dFQVEzT0grMjU2S1BXUnQvdzN1MnZudnhlcGlMaVZkVUI3c3JtNXJVMFRmWTY3WFl2cXp6RGJNelVlYWFWWjdIUlhHNUxzalk3aHpQNUNCVWZBdGErTSs3dWR6VkFqREdvNnQwRTNSaUpsaGZtam1mRHlUSFJRS3NSeXlTcjZ2akwxTVRRSWtvc1FBZzFiNVZDcTJtd0Jwb3h4TEdRUmtyUVBsWHdCR000MVYzQWJJOFpOVHhWa2RGTEk2S2xIczBrWW5jNFpUU3B5RWVlVVIvNjEwWnM5UGFZVyt0Z1UwdFJsRXlHWTdLc0JNemQzK05ra25DODJXQXd5aWxLUjJLRVRoS3hQUzZ3Tm1kdHJnTVluQ2lSTVV6TGtyd3N5VW9vbmRER1VrbGc0ajJGOTdTb1dCU0xCVlRxcFNtdHQrdmZIdVRUYi9qZ2ZWMm8rcWZqNHpNZitBQy8vczF2YWxhVyt3MURQODd6L3Jnb0xyWWJqUk90SkVPNkxRayswSW9TVW1OYnRqS1BkUnVOejQzeWZLcjFJcnlrY1N5bGUyZUVXZS82WWNWWkRtSkVKRnBhV2pBcnl3c1hSc054YjNtdW9aOTYvMm5tTzgyYVJOb0sxaXB4QkhGc2F0VllJL2hadk5Gb0dCb3RRN01wSkNra1RVZ1Q0V2pTWkM3M3FGcVFoT2xvUkNUUWppMkw3U2JMdlRZTDh5a0xDekRmQzNSaklleFZiTDY4emMxdmJySitwYy9lYmtGVUJYcEc2UnFocWNybDNZeU5jVm1QdmllV09JMVpuZThTUnpGYmc1S3QwUVFmQW8wMHdVWVdzVktQdXpoRFdmUFdzV2diZEt3bG9Fenc3SVdTUXNIVmsrOEU5R0pmeTc5K3kwMit5bXpPNnZkeUlMRzE5RnF0L1dLZk15THV6dTV1LzdVYk43NmFwa2tSUlJHeGpWaWJuMk91MDFJUVdsSHluclhPM0d3UXJTNzNUb3BjWHI1eGhaOTQvOGNPQVBLSGFYbWU3NGZjUmxWdHA5V00xZm1qT3p0N0VvTG40OC9OOGFQZjh6QzlkbG9ueTFhSklvTzFwZzdTVWNKczFkVXBWRm9ESnE4OGI3MDFaUHZtaFBaZ1JMRzNRNnZkUU1SU1pwTzdEWVZtR3RGcnBmUmFEYnF0QnQxMlRMY0R2VzZnMDZsM1RYVGd5WGNkazc0akxUeExSamlhSkdTRjh0TFdoRWtaVUNPWVpreHZ2czNocFE2Vmc4dnJVKzRNTWp3dzhSVlpDQlRlVUhpd1lrakVJQUY2SkxRd0dBSmpLa3AxeEFJVzdtVGkvc3NOblg1SjBYMmVYNmV6NWQvZjlmMHNTK0lvVXFtbnhieEM1VVB3bS8zQjYrTXMzNHR0Sk1aWWpMR2tTWUlQZ1ZhY0hGcHNkWThCVnVyeGR5c2ljbUpwUmQ0SjlkNkRSbUZkd1RXcUtrdUxjOTFpT2puVTM5MFZWV1dTRi95eFQ1eW1yQUwvNExkZXBTZ2RjUndSR1l1TnpFeUdRR1lMVERVaGN4U2xyRVFkL3NGdlBzK2dQK0hzWjgvUWJWb2lFMUdWQmw4V2lKbUZTaUVRRzBNblNVaU1wWWhpQ2x0Um1KSTRjalVnYzBPVXgyU1Y1L1plWUpCTkVXTVpsekN1SU4yYWNuNDVKZE9BV0VPcmxiRFlUYmk4T2VIdHJZd2lLQTBiR0k4OFZTRVVYckNpQkdiOUNJUTJxUW9GdWVpdEFkVkZsRjZBbjkzUy9EZW85ejZtTTRBRVFVTGJ4SXhEK2J1K2t6ZTJ0akN6OGZmOVBHUmpPTmpJdmJ2ZGJiY09sNVhYYVRXVnZNekZxOWRHMUZoZWFyVWZzc1o4TGFqR292WFlpUStCdmVrZnZpejB1N3FLWll5cHgwdG0wbWxIMWxaT0pFWi8vTWIxRzR2T1cwNGNhc3BqNTdwY09IdWNSbXk0ZEgyUHlpdHBITk9lYjdONGFwNjBGUkZIZ28yRTVia3VEeldXbVI5bnJNUUZOOWRMSGpxK3dPSmNrKzdTQlhaM0hGZmVmQVdvV1F2VjF3SDlQbUFpWTRpTXdWcExaQTJScFFhSmhWZ2lORmltcGJCWndNVFZvZDJ3OEpSRlNUc0syRGhpbkdVWWF0clNmdUVaNUJWRm9ZVEs0R2ZjVm9qT1dwOHlpNWNFaXdIRGF5UDgvM3VpN3RjR1ZNLzdtaGg3eWwxRktId2tob2F4bXVzL0tabDI4ZGF0T2t1L1c4eXFaOXRLNSt3VHAwNmRuMnUxSDU5a21kVGE3VXJ3aWdhTU1XYjc4dDdXNzVUTzFSU3FJbTVTNUNFS3d2WmtkQUNRUDJTQVJDR0VGRWduay9HeDljMnR6K0pDMTFVaTU0NHQ4ZENwSnUxMml3dG5qM0RpK0NMajBZalJxTUJiUysvRUhHblRrTVRDOFU2UHh6dkx5TzZBSXN0WTdnanp2U2JOVnBkSExseWdOWGVlcjN6bEcyemV1bEVUSTdoQTVRSmVvWFIxbjBVQUg1VFNLN2xUeWxEbkRSaEZMSmpJRUJraFJoajcybnRaQWxubENKV2pZV3NHeE5MNWVyaFJoZExEZEVZd25WaGIvK3dnOVE2NmdJcW9paEliNndUNTRrVGRyenQwblhyM1k4S3NnejdyYmVoaTFHVE9wdlQ5NzY1cC9rTWYvQ0NWY3d5bVU4TnNyaTByUy91ZUV5ZlBMTFM3NzgrTDBuZ2ZzRGJHTzQrcnZMRld3dnBrK1BsQlBoMHlHNmNIUWp0TnRaOU5EMEtzZDBLWUJaamdmY2dLaW54YWNYUyt3WkhGSTFSWkM5ZkpNRWI0cm8rOGgvYy9lNGF2ZnUxdFhyOHhvTG5ZWTM2dHc2M3JPN2hzaWxHTFYwK3IxYUtZZWk2Y21XZHA5UUpIVDUzZ0M4Ky94VS8vbzYrUWhuSkc2d21xQWFkS1hvYTZJVGxqYy9jcWpNcDZ5REMyRm9KQk5XQmpVQ3MwbzhDeUViWUtVQldDQ2x0VHhmc3BpNzFvVm9wV2xwcENMSmE5MGpQMm5xRFFNclplM1ozZDlaRllNV0t5S3VnL0dnWDMwdzdkblFIanJ1Y0FRaUpXV3hKcExYLzRUeTh3S2JBeVA4L1Z6YzJBaUtNT3M2b3JHeHV2SEYxWXVwNG15Um52QWxrK0pSQWtxQ2VSNk5pSmhhVUwxL2Uycjg2VzFReUk3RTBuL3p1cXlnY0ErWDB6VlpYN091bkdXTUVhOFZQbmFIZFRqcTRzMGtqV2lLUlA1Zm9NOTRiTUw4enpQWjk0aGs4RUlkZUlwTlhrNTkvOElxKzhlb1gzZnM5NUpJQXZQVkZqaWFPbm5tVjU2U1JpY3BxOUZSNCtld2czM0NFMUVWWTlWUWhrcGFlb0ZLTjFEYlhWakVoc0hmcTRvSlNWWjVKVk9PY0lJVkJXanNvcDh5VXdoTTNNNEZCRWxWRWVRUWcwMDlyanFFTERDRjJ4RE5VVFJRbEwzVG15ZklKemxUcVY3Y3k3MTBGZUdRVDNpNVBnTG5OdjM3eWdya1JwTkFQSG5FbTRWdjF2SzBKZFdkK29SM2k4RHpPQXVXOWNmdnZLMDZmUHZEMlh0czVZVXl2b2lqRzQ0TlVHMDFwdWRSOHhJcjhaYXE5alZWVUcrZlFQL1l3Y2VKQjdvKzRpSWhnckdHTTRkM3lWdzRmWFdEdCtsampLR1U4dmtlVjlkamNkY1p6V0JVQVZja2w1OHVnQ2JtOEg1eU1NbHFpMXlvbEhQc3BjYnduaUdHTThqNy8vSEorNWNZdFh2dmc1MUZ1S3ZBYUlid1RDVEY1QVE4QllvYXhxSGNKb3hqMWtZMHN1U3VVZ2tnaG5EWkd0T0dVOHBjSmViakFvamtCV0dyeXpzNjU0WFdXTGpYQzgxV1c1MjZQWGJKSlZIZElFcVpEcVNuLzR1V3ZiRy84NHFPN09RSkh0Z3lPMlViREdhRmNTQ2xjUi9uY0kzdno5TDMrWkQ1dy9UK1VxM1p0TTdnSmtaelFhRHFmVHE5Mms2WDF3QmxSaWEwaVRtT0ExV21wMnpyVFN0RGZPNjdtc1dZWDFEMTBiK2wxYjV2M3Naeis3bjRQc2cwU1R5QzVsV2JXMHRqREhkN3p2dlJ3OWRZYnV3anlkaFpNc0gvb29pMHRuaUtPQ0toOVQ1bE9jeS9GdXlud241b21IVmpDMnk5ektZNXgrNm51Wld6cUM2YzVCTStYUzlkdmN1SHFEeUVZMVcvcmRZS1J1b3FpdnFYNkMxaElEKzNzbkJpR3lwbGFhaW1xbHFVWVMwNGhqbWtuS1hDdmwxSHhFS3pZNG9NRGo4UGdndFZDUE4vaGdLSVBTYWJUb05PcE54bVprYURmYWVtaHVlZlh4aytmZTIyeTJBbmVGYldvRzBqUk93c25EeDNqbWtTY29nbU1ZQ202NC8zMEpjNi9aWkpUbGlNaitHcTczSWVRYmcvN2JSVmtNbmZkU1ZoVkJBMXBYQ2t5TW5EL2NuVC9DdmFXMXUrUDFCd0Q1UTdCT3B5TlJGTzJEQTJORXpody9lcHBnRzk0SE5UYWgxVzdpcXlucUo4UkppKzdjRXl3dVBjdmMzR0hpV1M5RWZVVWtTcXUxek9MUnB6ajF4TWZwTGgvQ3RKc01KbjMrM3MvOUEvN2FmL2pUUFAvMXE3V3dUdUZyL1EyQm9IcFhZdUJiYXM2bTNqdVIyWjkzUVJMYkdpZ3pXYlkwaWpqVWpUbTdFR09Od1dISVVTcmNESUt6VGRpZ3JBLzY1R1d0cmVORHVSK3lSUTNDOFVZVU5XY0FVVUdDR0tQemMvT3NyUjNTc3FvWXV2eWY2YjB0cW9wSGpoL1h5QmlkTVo0NHdGM2IzcnBjVk5WZXZYaFl2K3c0aWpER1lJenRuVmhZUHM1OVl5ZnZCSkFjaEZqMUp5QkdqRHo2OElXa0dKWnljMzJkaTI5ZllUeTR3TXJoTll6SjBXb0xaWjVHOXlIbVZoNWxNcmpGZE54SFE0bHB6bkc0ZTRTNTFlUFlKQUUvNGMwWFgrRy8rOXUvd2l1dmJiTzhjSXgyc3dPaldtNGdTQzFVWS9leE1adldyVWZxNndUK3Jtc3pZSUlRRzFNVE13Um1leHMxZUl3WGpzNEp1N2x5WjZoVWVDbzhVVDA1VnErNllzaUtncDNKbUNOelRZSXF6Z2Z4ZGJOelpiazd0N3d6SEx6TmJBQkxSREJpVkZWNS92VVgvNW5mejkxeWcwNjZTaXROdzNBNjlmdExWRy9jdW5YbkEyZk9YMC9FbkE0b0lhZ0VsTW83akpPNWprM09VUlAyN1lQa0Q5MkR2R3NCOGkwQ2tsSWZKREYyY1B6d2l0L2QyV0p2ZDVmUmVNTGh0RXVjZENpSGx5RnFFclVXc1dtTGxvbEkyeXY0Y2tqY1d5WmVPSW9ZbUdZRGZ2bm4vamIvNDg5K21SQ1dPWDMwSEJHQytvellsc1RXNG9LaSsrdmxzMEZJa2JwcEo2cDRGTFBmbzFEQnlENWlCRFVRWWU2U1BlOTdtS005WlhOY29VR284RmlFWkI4bUlpUWFzVHNhczlDME5KTVlId0xPZTlJb1dUNjV1UFNlTjI5ZC8vb3NPVGFxS3V2YkcrSmM4YzlVUVpydk5QQkIrYUdQbitIbmYvMG1XVmtTYWtwU0Q0UnhsZzIyUnNOTHk2M3VoNHFxaW56bFJJTlNCWStXbWlRbU90TnR0dVpHMlhUOGJSNUVEd0R5QjJ3WEwxN1VzaXlaY1RHcEtscFZWZFpxSmFvS08vMGhXVmFoeEVUTkxxN2NSbDJHVFZLSUU0d0dNSXFORElKQmZjNlZOOS9rYi96MDMrY1hmdTBiUEhUeVNZNGVPa3lvSEs2c2NFVkdISUcxQmxlUC9kMnREdFJLaHZ2My9kMkt3ZDFXWHRCNmdCQUZJelc3WWkzdVhLdFNnV0crcFN3a01YdUZVbW1vV1JlQmhzUllJNmdhTWxleE1aNXljbkc1em9COVJkQm1PelgyNFhhcjNaMU1KN1d3VGEyczVkTTBCV0I1cm1hcE44YlVKM2EvVEMyMVVLY1J3MkJhMFIvbkxNMDErZTkvK1EwcUY2VHkvbTUrSnlJaHFCYlh0amR2emgxdFZFVlZSYTZzUzk0dUJQS3lJbTRrWjQvM2xrNjhsazAzdWJlbkxuK1lJSG5YQXVUNTU1L0hHTE5QVjZPcXFydUQwWEF4YlFRQkdXY0ZlUm1vVndnRnNTM0VqZXF2VFlSTm01aEdFL0JVMlloZi93Yy96My82WC8xZFhueHJsMCs4L3hNY1hUbE01V1l5NWFKTXhsT0tYbjN6R3dQQjMzVUtzNDlmN3g2RGZRSzEvUk5oN3Y3di9iNzNyTm9tU21ScXFiUk9BdzUxRzNoVmRndkY0ckVFdkFaaVk3SEJZSUt3UGNsWWFCVXN0Q3pCdTVuY2RISjBzZDFlbkV3bjIwQVVWSTBSTVh2RG9RYzR2TlJrdTU5anJjRklMYysyTnQ5aVhEbjJCbE9zdFl5eUNrQ0drNUs5VVM2cVNOM1BtSTJ4ejdRZWIrM3V2SGxzYm1GYnkzQnltazAxdUNEZUN3YkxYSktjNlVTTlowVjRXWldVZTlMV2VsK2I1UUFnZjlEUjFnd2dZYTgvSEp3OGV6cUw0NlFMVUhuQlJFbDl1OXMySWhWaWt6b2tDd3BKeXNiNlRmNzcvK0duK1psZitCeGlWL25RZTkvRDB2d1N6bGZJM1VVclE1WVY5QTdITkJOTFZicTc0WkdnMkZxKzltNTNtMW40WitwTzk3ZmtKTnk5d2JXZTU1cXhPYmJUaVBtV0l5c1NobFZKQ0JBSU9BSWgxQU5PRVpiTWxleE1KblFhRFNRRVhKVmo0dmpvb2Q3Y2lSdGJtMWRtRmFRb3FQckpkS29BcjF3WllMNXRkUERhNXVSdWdZTVo2WVFJVWptL3YxOXpWMEpDaEFaSUUyaXQ5L3VEdCsrczMwalVuaEFVOWRDTVUxQmxuRTNqZGh3ZFNhT2tsMWZsL1ZMV3NoK20vVUdENWQyK2Nucy80UmttTXRuY2ZHK1FKUEVLcXFpRy9VQWZzUzJ3RTlTWGtLU0VKT0xMdi9OVi92ci82Ny9sR3k5ZTRkRnpUM0h1eEttYXR0TUhjSTZxTEREV0VMekhWeG1OaHFIdTRGVTFPSUppUkFnMXAvek1lOXc3RVhmanF0bHBDL2ZRZkxjVXJGSlRua1lvU1NRc05oSUdaY3hPcnZpN1pWOVBiR3BGcWxndC9lbVU1VzZQSkxKVXJxS2RObGZuMjkxSGpaR3ZocURGdllvV2Z2OFhDZmNpd3Z2N1I3UEVhRCt2dXhzUzJkblppcGdwZEJsREEwZ3E3MlZTRkZmYnJmWUhJaE5ab3dhRGdhQXFHcVFWeFk4dU5kdUhiMVZsUG52Sk12cysrekxYKzBEaER3SW9CeDdrSGtBQ01GMDd0REpNazVTc3FQQUJxakluVGd5dXluQStJbFE1dy81RmZ2bUxiL09mL09jL1RYK3Y0a05QZllUVjVWVlFSYjFIZ2xKWGFTcXFvc0I1ajdDQUJvdklmb0pkWTlQSXZlcFZMUmM5QzdIMFcwL2l2c2F6NkxkbUszZXZheU5VcXNTeDRVaTd4YkNxY0Y0UUFwVUdJaXhXaEVRdEUxZHlaOWlubTY2Z2VLMktJbXBFOXJHVitjWGxqZDBkTi91eHNZSy9HOVh4TFFDUmIydXkzdi8xdmpLd01VWWFhNnZkK2JXMXpoTnBaTTk0cjQyaThoTTNVbGM0NzhyZ28yYWNFa1dHRUR5Vjg4UTJPbnBvY2ZtMGFiV0hlLzFoTk02SCsxSVV4UXdreFQ4RktBY0ErZjJvWkltSXFtb1FFZDNlN1EvSCtmVE93bnhITis3Y2tzM2RJV1ZSMEd3MkNNNGhTUS92Y3Y3SHYvMEwvUFcvOFFVV3VrZjQrUHVlb3R2dDRiVWVGNW1SbjZBYUNMN3VqcXNDWWpFbXFwTnp1VXNZY2ErYXBuWHA5eDVxOXdFZzZLd3NiSmdOTDhxOU1FdDBSa3RvaEY0elpxZHdkSk9ZaFNSbU13c1k2dEp2Z3dnajljUndHaXlENlpSQmxySFlzVko1VDV3a1ozdU41dEVON2lya0p0enJaSDg3UUxpdkRLc3pNTVJTRTdJWWEwaU9ISjQvdnJMU2VWKzNrenpkNmFUdmpVUjZycXh3cXFWZlpMcDdwYkNoVWpUVWowSEVJQ1RRdTNEc3hKOTh1Qk4veDJReTNkdmJtN3o0NWRkZi9xM1NsM3YzVmJidWI4ejh2dkw1dnV0RExLMVBhQkNSc0xHMWs3OTE2ZnFWUmhwcjBFcldOKzdncW5xbkd4VkVJdkxKa0ZldVZsUSs1YjN2ZVpadXE0UDN2czRYUWsxQjZrTXRXNkFvU2F1RDlWQTZ4Y2J4ZlFDNUx3bm5YbUplTjlEdWVZZHYvM3AvV3p6Y1BabXpmb3JDWE1Pd00yczBIbW8xR1pZVmhWZEtBbFh3cE1aaWpkQWdwdkE1NjZNaGM4MEdZcHpHM2g2ZWJ6YWZqcXpkaXlNNUhCdXhJa1JwWXBJa2tqYUlqYU5Ja3NqTVI1R1pSNUhKTkFjanB0MUlralNOMnRaSUZFVldwWkUwRzgzNGtlRDltZUJjT2g2aFpWRWdhbVdoZmFUUmpKUEdGbGNwZlZXL2xsQ1FXb3ZCWUlYRWxhT251ODN1MDBkV2p0RjhxTFA5dmllZmVMZy9tWHo5U3k5OTgrWFhMcjkxOC83Y2NmK3gxdUs5UHdESXYrQnVPcVBSNkM1VlRWR1VJYy9MYmNVNjUwTmE1RVd0ejFIRTlaeFU4Q1N0SG11SDFnQ2xjcTdtd05KQVVLMURLeCtveW9JUUhKR3hPT2RKMG9pRjFTVk1NOEhHNXQ2UTBYMVZLeU4xLytPK0hQMWU4bHZIVnZkaW1YckQ2NzdvWnovNG4wVTRzeVdzMVdiSzlmRUVoMUNveDRaNmQ5NklrSXBsbEdYMHM0S2xxRUZ3VmFOancvZGRPTlo1d2xkNnBQSlZGTWRxSTJ0c1dXbWN4SWxwTlNPTVNFTkVHdU54cVdsc2FMY1RtMFJXckxVbXNoR2tLWTEySktHc0NNNWprMGlEQnJyTkpUazhkNWI1NWhyQks5SHBMcGZlZm9QcGVFd01rQ1FrSm1KY2VQd2dZZlhrWXh4ZU9rV24xVnkyUnY2TXE2b2ZQTDE2OGtzLy9SdS8rSis4K3ZiRmEvZUZ4V0UyY0tvSEh1UmZzRlZWZGJjUEFocktxZ3J0VG5NYytTWC8rdXRLZjVReEdVOXB0UzFKbWdDQnlDYk1kOXRNcGxNMjF1OFFyd1hRUUt2VndUbEhrVThKemhGWllYNnh6YW56eC9qWXg1L2h4Sm5qN0YzK0puRWMxYU1rdGQrNkc1UEpyREltMzFhcE1uSVBNSFd4U3dqN2ZrWHV4VHdxMEVpRWRzTlE1Z1l4eW5LenlVNWVNSEdla2tDaUFhc1dZeUFsUXIxanN6K2syMmhKWkNOYVNYTE9GanlVdVVxc3JhdGtWUlhJTTRodG1QVTg2b3BDVVZZa2labnRzQVNNTVRJb0RMMzVRL2l3QjFWT00wMlFPSkxWK2JNY1c3aEFhdi8vN1AxM3NHMzVkZDhIZnRidnQ5TUpONy9VL2JwZlozUkVUZ1FKa0FDWVFKRVdMZEdpWkpJaml4SWxhMlRKWmJrOGR0a3pHbG5qcVpGZDF0aFROVlV6dHNwUjhsaTJLVnVXaHFJbzBxUklpaVFJRUNSQWhBWTZkNy91RjI4OGFhZGZXUFBIYjUvN2JvTWdKVkVBSkE3ZTdqclY3M1cvY084NWUrM2ZXdXVieGpqdlFKWGRyYWU0LzU3NytOSnpuK2ZxMVpkcHVnNG5BZThjVy9kZVFVekdxemRmWldPMHdZWHRDM21WRnhjbnhmamJ2L21wZDMzOEN5ODlmM3NvRHJkZUF3OExsN3NGOGxWdXNSaGFMSTFSUSt4OTZIMDgzTnphYXZPaUdOL1kzK2ZrK0ppZDdaSTh6NGd4RXIzajR1NDJQa1Q2cnNXM0szUVFNSzJXUit4dWpYam1iZmZ6OUZOWGVQenBoN2x3NVFxNWdqR1JldU04dHBnUTQ0SzFZL3pnUVhWS0hWbDdjTjBCK3VYT0VLK0t5cDBXeThpZFBhc0FtVFVVV2NSYjBKZ0lqdWRISStwbGpkZElJQ2J6Q0JKK010SWMxM3ZtVFVOVmxHU1NtZEFiN1Yya1VLSFhTTmREMUdTZTUwTXFXR3N5cVNvTEFqNEdqRnBXYlUreHU4ZDBlNHByRmxoVFVWU1dDOU1IZWZ5ZTk1RG41WkR4WHA2MmludmIyOXh6N2dLL1hHUjg0WE9mWitrYXBydDdNQTI4Y1BOWEtISWxrNHlieDVmbDBRdHYwMHJLelF0YjU3L3RMUTg4L0N2UHYvYnlHNXh4bmY5YXRGZmY4QVV5SG85cG11Wk5tNnlUK2VJa24yd2NaZGJ1cnBaemxpZUhlSCtlNkNPRUZxK1JqVkhGdUtyd3diR3FXeVpqeThYdGpQdmZjUy9mOVA2MzhmU2pqekNham9rS1VwOUFqUFJSc2NVR3hYZ2JqZGZUdkNsblc2WmtMUlFpZDRaMldkTk4xaWRHT25saW12blBJQUo2Q2lnbVhrY2tNem5HR1BaR0k0NjZ3S0p2Y1FSS01vd21NMkFyUWxUbGNMRmdjenhtTEJtNTVCSWNkRUZQTmZkR0lJVEJndFVJYWdLU2pGMXdUbEdOT0dNNHZ6ZkdNZ01UazlOS01lYmVjMitoTEFyS29rREVFbVBBTzQrcWNqdzc0STM5TDVKdnp0aStXSEw3b0dmallnSDVJVlVlS0xPTUVCeTNaeS9TMWEwOGZ1NmRiSTgzdnVVRFQ3M3J2YysvOXZMdE5XWnpCa3pVdXdYeVZieSt2RGlBNkdOWVpsbCtVT1RsbzdQRlFwdjVzZlJ0UzFrV05Lc0ZiWmF6V2NMV3lMSlJHZDc3ekE3dmYrYzVIbm5vZnM1ZmZwUThMd2pPMGMxbXhPaTVmVHpqNDU5K2dWLzc3TXQ4N0NOdlQ1NjdPZ3pYNjdsY2t0K1dHZERCR1BYT0tuamRTNjFuRHJsRGNGeVBxbWJna2hrUk5rY1o4OXFUbStUN05jb3o3cG1NcUwybmk0NU1QVlZjYzdTVURHSFZOTXlhaGxHK3lVWmVjQ3RhNmo2a3pFU0Vvb0FRVW11WDUybUZMWU91dnE0OVZaVlRiSXdwUjU3TUJNcEpqdXQ3eW15S1lVUVVnODBzVlZrU1k2UnBPbDY5OWp6WGp6NUg2MC9JY3VYK2g4WnNuTE5VbTBwVktrWXlRb2owbmFkdE9sci9LdWZLZTdreWZuajcvT2J1dXk3c252c0h0NDhPbW1HakpXL2FDTjR0a0svT0ZVSTRNNE9rQXJsMWNMQjg0b0VyKzN0N3U5eSsrVHJYYnQ3ZzBlVWpqS2RqRk1OcXVXSnpsUEd2L2N2ZnpsdmY4Z2h2ZmZ3eXBXMndXWW12VzV3L3B1dDdYcjk1ekU5Ly9QUDg0aWRlNE5sWDNzQmtodmMrZllITnpDVWErM0FpMkRYUHlrQWNaaEFqNndYL2dIZXNXekFTUlg3Ti9rMHVicElLYmJnM05pdkw1aWpTTzhGZ1VDUHNUWExtTHVmR01tQkpDSDlPanRXQldxL0s3Zm1NN2ZHWUtzdXdSbWhjWkpKbFJCMmlEbU5hbVdXWkljc3NQa1pNY3ZKbVBDbVFhVUVVeFEyRmsrY1pWVEZDUkdpNjluUjFQYTRxYmg2K3hCdkhuOExtamtJenZQUGttV1ZuczhJTk01ZnJIYTd6aE40UEpuMk8vZVYxUGI5NWoreE90OS8zK0pWSEx0NCtPamdSRVp2Z29hL05wdmN1VVBqbWZYcDQvZHFOSnZzbWJvOG5FMTAwWGw1NFk1OXZxbXRXaXdYR1pqalhVRnI0L2c5L0U5WmF2Qk1JR2RyMTNEaDRpUys4ZkoyLy95dGY0RGUvK0FiNG5HWGJNS21tUEhMNUFjN3YzZ1B4YU9DUW5CSnlNVVAraURXR0VEV0pGZGZGTWd6bENkay9RN3hZRCsrcUJKRWhJUmVLZ1M4VmgzV3lFVXNteXFWSnhVbmIwL3RBVGt6bTJHS1NtUU9XazNySi9uTE9QUnNsbVpYa3JCaUg5SndJMFZ0c250cStvaWd3UGhBMUJaaHVUQ3JhekNaVTMwQWJGQXM0ZFJTNUJZVzJhL0hPOGZ5cnovSGMxVjlpTWxZeVd5QVNocGtyWWxReFBySnErdFRTNmgwYWpsZmxlSFZibHUyY0M1T0xGL1kydGk4RHp3M2Q2ZGVNRnY4Tlh5QWhoRGUxV01jbmkvNW90bmd4aXBtRDNicDI2NUNqbzBPeVVVbVdsN2l1STdpVzRIcEdvNEttZHJ6OCtnMSs3bFBQOGF1ZnY4clJjU0NxNWNMT2ViWkdJMXJYYzI1cm16d3JxR1BGaFhNWHliTm5pUmhzU05xUURIQlI4WEY5T3FTNGd6RFE0dVVPbGpqUTVOUEpFWWNlemR4aHFsQ0tVSldHeGdIUnBGTktNamFyaXN2VHdHdnpHUzRxQlVvK25HS1pXS3FRY1hzMjQvejRBcHZWaURmbVBhc1EwcXFvTjRUZ0tiSjBzeHJyUUpRUW9DalNxU0trWkY4eHlTK3NDM0RTenVsOHd6amZ3SHVIaThxdDR6ZVkxVXNDSmRabTZlNGVsZzB4R2RZUk81ZUtmaWgwSDlJM1YzY3pqbFlIZW43NzRqUVRjOW1rSjh2WGxQRjdkd1k1QXpxSkVMd0wvclZydDY5bUtpZGxVVzdOVmlzT0RnL1kzdG1HS3VKZFQzQU44OFV4bjNueEdyLzgrVmY1NHN1MzZidWN2YTA5M25MZk9jYWpVYUt3dTRiTmNZbUl4ZmM5Yjl4Y1VWM2FvZy9LMG5YVWZhQ3VIWFVYYUYzRUJUM0ZWSkp2MUZwaGFMZ0R1Q3VyRUNtdHBiSm1VSHVsVlpocXlqR2MxNDVWcS9SZTByQmpraGVKRlJqWmpEWjZIQ0hkbkdFd3ZrTlpkQTJ2bjh5b0JuTzhOdmpoSVJKeElWSTVTNVlKTnV1U2dYZFVqTTFTK0k1UEo0SEpMVWFWek9aNDU1ajF4NHpzNU5URnBXNWJXbzFrSWJKc0hST2JUakdiQ1NZWVZJUlJabG41Z0lxa2h3Wmd4QkRVY1d2eE92YzJWOXBWM1M2R0xmaGRxc25YcThYUzFGR0U4K2QzV21sQ2V6WExPWnJYSEozTWFaWW5vQlZpTXZLODVCYys4UnovNzcvMTgwUlg4dmo5ajdKMzd4YWpzZ0pKdnJkb2hPZ0oydUJjaXpXQlgvcTUvNFdmYmxzT2J0MU9HZ2dYOFM3aXZBNTNPY1RCTDBzSFJaWEJFSFZnNzRvaHorRElSMFFNTzRQSmRGRU9LK0tZK256ZkQzNWJRZWtJZEVTTUNEbUdPREFLT3p3OW5uQzYrMGxtY3ErZm5KQVpDekg5T2oxRGZnbEVZbEM4UzR1QjNpbXhENnpxanRwRit1dXB0U29LZ3dsSzEzVzRnMCtqOTFwaWpIUjl5M0syd3JlQkZSM1dDTVc0WUpRWjhNbVpNaXFNeHlYYU9WWXVKSU85bU42UEVDS3I1b2pQdmZxRlR6ejcyb3VmMDVTUUc3K1crZXAzQytUT0NYTEhrYnlwNS9kdTdwMFVWY1Z5ZWNTMTJ3YzhjdVVlaW1wTXBpMjJHRkVXVXpxblBMaDNqblBiMnhocmlkRWplQ1MyZUZmait4b2pQWDNmRFk3cGtlVnFpWXJpUWlUNGlLcGdyYVMxYVRySHlIVDRpUkdpQjRsckV3ZklqTENaQzQwcWhVM0djTUVyUlRYOGdpaW9IVmF6Q2hMV09HaFNHQUs0ZEtzUHB4TzRrRExmemREQytSQ0d3Q0JET09PK0dGWHBleVh2VStmdlBZaFJmQWhFRjloL2JSL2J0OWdzRGY0eEtJZHlpOWVlZTRtbUZ6YTNjaTVlbUhCeGIwTHJBcTBMTkM0bU16eHJVaXVwRWNFd3FRcGNhUEVEYzltNUNEcG1kL3BROEdxZnUzbHlxK0czOHNPKzZwZTlXeHVuZkkwMUM3VjYvZG90bm5qb29hZU85bytlYWRxbDdFd0xIcnYvTXBQcERsVUpaVkVpdHVSWHYvQWl2Zy9zam5OeTA1UDVZMEo3Z08rUGNkMEs3ejBpaHJMTUtYTkxrUXREVnpUY2RwSGNRcDVEa1JseW05cXBQRGNZcy82MVFwNFppdHlRaVRDcVlIT3NqSE5oT2hiS2NtQVdac3E0VW94VmlnektuQ0cxeWlJeGJiVE1ZREc2L25kbURGVm1JQWpqd3BLcG5ITEIxdklQUDNDSE14Ukwrbk9zVFlJdEdZYWZ5YWpBOTRyempxM05rc2w0eEdSYVVWVUZnc0Y3aC9lTzZVYko3czZFekJpS3pLWlRRUlZyREVWbWtxSGRJQ2h6empOYjFDeHJ4M3plNEtsNCsrUGZvazlmZnNidWJHMjZOdzV2ZnZ4d2Rqd0gyaUhVeDkrZFFiNCtKNGsyZGV2UFg5bzl6cjlVZWVjMXY3WS80MlErNTl6NW5oaUYvY001eldMT1V4YzNPRGxlTXJhSDBLZFlOb0M4Z0dxY2syZVdHSldpRU1yYzRtTjZKZ2Nma3BwSURFcWtMREtzRlh4UThrd0g0a3VhUVdJaEdBYlFMc0prSkZSbE1ZQjQ2VlllRlhGb2tWTEI2ZUNXVXBZSmZMVExqTzVNM01ZYTMxQlZDRkNhWkZibmdwNktyQWFWUnJKVlBEMUZJcEVJYXUvUVlLSVNZOUxBUjIvWjJONWtlMXBSRmVuVzhpNndhanFPRDlQSkdVS2t6Q3haYmhBajlEN1F1VUJ1aFkwcXgxamw4TERqK1ZjT09adzNpTFZzN1l3NWYzR0VtSlVZalhwdVkvZnB4KzkvNUtublgzL2xxa0EyZUFHYisrKy9YNjlldmFwM0MrVHJjQjNQWnRlekxGczR6KzVzMlhEajFrM0VaRnk3dWM5THI5MWt2bWp4WGMvZUpFUHdZSVFzTjB3cncrNW1BVFlEWTNDdUp3NVBTZU1NWlo2bEh3dmtGaktia3hmWlFEc0pXSWtKZUpCazBDQzVKcGFxRHZoQ1pqRTJZUlVocElIZUZvSzFGdWM5M250MEVGcjVkWEdXa3FMUEFxZUlmRml2alFPVVJYbzBTRFFVQ0o1SUlHVWlGZ2pOVUNRUnhjZEk3eXcyU3ppMkR1MVBXUlJwb0M5eXpMZ2tNNUpPSjRXeXlOaWNWSVNZSU1hNEJqaUhZcTJibnRtOHdRTGVPVjY3UG1mVkJuYjNKang0WlplOTdSSGRxdVhvK0RadTR3bUszbTljT1gvdk0rT3ErdDlXVFdORjBsbVdZcXp2bmlCZnF4YnJyT0NIVC83RzUxOS9lTy84NHQ2ZDBlN1cyUEs1NTY3ejJTKzl3V3paNHAxaU1rdWUyZFAyU0JWc0xteE9jL0xjZ3NrUW13K05Tbm9HYTdpRFUyVEdraG1iZnUyQWxCTUZOUVpqaFJnaWNSaE8xNndVSTRheUtNaUxESTBSRVNFT25ydURLQU5qN0ozZnA4bGRzU2dzR3FIcklNYUJ0eVdKWTJWTUN1L3NRb3BES0l4bHJEa0w5U2hRWVdnSE4xNGRhQ3lkaXhoanNESE5NRjN2R1pVRlZnMWVoVEFxc0VUR1E5dTBzNVV6M1Nqb25USmY5Q3hXUGE0UFdDT1VtV1d5VVNSU3BBdDBuZUdoUi9ZWWp3ck83VzFRWkpibFNjM2lwQ1kzbGxXM0pEZldYTjY5OFBUdXh2YkdxbWxtNnpsa2lOUzdXeUJmNDBMaDNzM1J2ZWRaZmJqeXN2M1FoWXJlUllKM0ZKbGxXbFdFSWdGN2szSE9aSlRtQStlVTNBcEZKc1FZa1ppWXdxTnFCTkhqZlljdFMwS0VLcmNZelFsUjErNkNhUzZ3aVdBbHc5UFZENDRtR1lrQmpLYWJZSTE1bkxKTmhqYkhETkVKcWQ2U0ZoNTErQmhQeVpDbmlxNzFOeXpKVVQ0R1VnczBNQ2lEUmd3cEZ5SlBaK1RwR3hRMTROd2dhckZDM3llaVlKVkR2K3paTFF3NzFqSWVXNnJTa3VXQ3lReCs3dEFJRytNQ0ptbXBrT2NHWXczV21GTUwxaEFWSHlMRVNMM3NXTTRhZ2dzRW1YTTR2eUViNVpTaXlCNjg3OEk5dTYvZnZ2SDZHWC9sdXdYeU5id0c1YXJKTG83emoxWFIvZkJxZGx4VVJjNzJPTWVTNWdpdGhNNmxKOVYwV2xJVkdXS1VtTVdVTUt0cFgyeXNRYUtISU5nc3g1cUVUSXNHZEhQTXZPbFpOVDF0SDArZEZ2UE1wSmJGZTN5SWlESElXdWd0aGhBRDNudDZrOXplamNpUTg2NFlFbkp1QjJERURDQmlqSkVpUnZwY2NDN3BTQktlSXFmb29rYVNYbjJOT3doVVdNelFicFZEZ2NpWmZ6UXFHcEtldnU4aWZlOFpqU3p6b3hyZmVrSmw2YjFKT2ZOaUtITEk4alR3TzU4ZU1GSEJkV0dnM2d4UzRtSDdscEtnbGI3M05FMUhqSXFLNTliSjYxell1SSt4R2FrVmUrb25rSEFzdVZzZ1grc1RSRlYxY0IzTXBsWEpwTW9aRndrTUszS0xSc1dLUll3d3lqT3F2RXBhY29uREtqVDUrWmdzSDhST0FTTVJpeUVhRDlZd0hSZjBtbTZVcUNrSWRNMjVXdDhvVVdQYVBvbWNVUmtPbmRoQTdVNGhBWUlkd01BUUkwaWl2UThCcFpTRGViYlhpSE5KdDM0Nml3emdzOFE3RWRjSmprbC9yeXFEdTFZNDFhSEk4RHNqQ2VHMkNXV2tianhiR3dXNjdMaDFWTE54ejBZU3RXdkNoYnlMR0NPVWhTRTBJUW5LaDJMTWdLN3ptTXhnTW9zUHc2bXF5VWNzTHd1OGJ5SEM0ZUphdkhyd29vNnF2Vjk1NGZWWFhrL1lxUVlSdVZzZ1g1ODFsb1kyNnE4WG1iMCt5dXg5bzh5K21XVTdNSEZSSlFhZmJrcVVFUDJ3b2pTWXpDRERhV0VGeER2Q2dHdllMS05RcFJqOGRrVUtJa3JiZTlxdXgvdlVLbVVtbWNLZGF0SUZNcHNsbmZ0QWhRZFNLNkk2TEcvWFdlZHlLcTR5eG1CUjhpeVNXWVVzL1hmbmgrLzJEazdJMms5aTNjb25leExCSW1SblRlMkdsNCtSR0EwUldDMERHMU1sRitWZ2Y4WDU4MU95TG1DTWtGa2x1TUdlcExCbzQvRWhBWk5HQkFOTXFneVRHZW91NFB1QVdFRlYwcXhYNXRTcmRqaFJPbm4yNnBldU5xNzRYMjdQRHVmRG9pMklpSDR0b3FQdkZzZ1pKSDE0NmF6MzF3dHIzeWl0dVkrWWR2VWlCak9RQ0hVZ0F2cmdNYjVMUTNHTUZFV0pOUm1aSk1kMkh6eHFEVVpLVkIweXJIWFJ0T0tWZ1d5b01aNGhFdW5wc0xtT1pndERWSnRHSFNJSWRKM1ZQSnc4TWtTMVdZd3hwMjFUMUdRdkdsV3hvbGdMM3QzeFJEazlrUVlCRThOSjRvZUFVaDBXdXdZbFIzRkFLUlpSR1g1SFRETlVFTm8yc3FwNzhrSlluVFFjTER1cXpZcmNSV0kyYk9TczZIaWFVeFNHbzFuSG92YXk5b0QwVWNtQ0lsWW9SaWw5eXZrRXB2YXVwKzM2R0VNOENLRjZjZFc0di9uYTRmWFBEaG1JSFNrUFVlOE82VjlqL0dOQTB1UHRaWGZRK2ZDY01lYTkxaHFiSXNNR09vZFprd2JUa3pxRWdJWklKa0tXMG5NUy9ob0ZqYW5sVW5xS29rQXlTOWQzeVhRdVJMd0w5TTZoUnZBK0RBeGVJYk4yK0lJVTU5TTJ5MlNXVXpNc2dlQlRuK1I5QUZXeUxHV0NaSEtuUlZrWG9BdzRTZ3dRWERLL2pzUTNEL3ByV3IybTBnZ0Q1cUVEdmpMc3laSnZjSHJxcTBFMERNWjBYUWVyVldCbjI2Sk56K3k0cGl3enZBZzdtWkhTR2hGRm5BODByYWZ4Z1huYmQvTjVlNkI5bUtNMkZEYmJ0bkJCTkJZeHB1MVkzM3BpcjdwVDdQVW52di9wTDF5LzhUYzdINjRxc1NacFFmeTZRRjU1NVpXN1FPSFhnV3JpVWVwWjY1KzdEMTFZSTl1R1lmVzZadHNPeWo2RElIRndQWkdCdWFRaGtUU01TZVE3d05xQ2dLVnRXbnJua0JCeE1lSTEwb2VJQnFYdWVvTEcxQjROZHFJeHB0TWx4SWg2VDU3blJJMDRGd2tEemNPNTFJYlptTElLallaaDVaeG9MQVpCak5MM2duTkNONENCa1NUQlBidjhzVU9iNXRlR2M5ekJMVUpxaDF4TWlTWlpKb2JNUUJkT09USXNGNUc4aUZnUlRxN042TnFPYTlZd0tuT2ZGZllnUkYzVnE2NWZ6cHJqdm5XM0l2TENjdFcvdkpxM1Myc3l0cXJ4NHhlcnlZL0ZwcitjVzBzbUdXVmVzYnN4NWRKa0o3KzBFWGMrYy8zNlFvbU9NM0piN3RyK2ZOMktKQXhQSlAvQzRlclREKzZPWHlxc2VaZFl3Vm9qUmhUbncrRENMc1FZMGlvVkJxTzRCQWpHRUFuUjRZSkhyQ0c2anFieExKdWVsSytwTEZZZHk3WW5CRS9iUmVvMlBhV05CVEVlVlNoTUtyamVwWDQ4QkljQ3MxV0s3MHdTM2VTa0FzbC9LM2c5cGFjWXc1QXhBbDBiNlYzeXlPcndwNDV3bkZrREdZUnMyRno1bEdzem5CMm5EcU5YRmYzN2FXT21sVURoVVN1SVZkR3NjMUg2STJKaHBBdXpKZlp3bVJrUkc0WHJyZkFKSC9URWUrK0MwNGFVWkxYT1dNdDk5RVhkOStHK0J4NCtqRzEzK2Vqb2hNTG1hY21naUdxMDA3eDQ0UExtenNZclIvdXZuNEw4RU5lK0FuY0w1T3R6aWpnZzNsaTAxL1pYL2FlM3ErSnRGc2trcE5uRDZEQTByMFZQQnF5MTlDNFE2aTVST0NScHhtTUVyNEUrT0phZG8rN1MvQkZDb09sckZyV2o3aFRuRkQvYzJEYmpWTVdYMEhhREQ0YmVCZFFrQ3NqU0F4TEkxalRDZFFpUEtGSFN5dGM2R1RDTmRMcUZBRTRWSjBKUGRucmJ5NWtDQ2FSNEtjRU9Nc2NCTlpVazIvSWFOenVOWDRUNCtTWlFJeVR6cjVRZllVQ2w3WlBwKzNvcmFCQ0phSzkzRE43Q21kZjZyeTZBOGNwMXI5MXpjZS9YTDA0M25uejU2aHQ1czJxSlBxMnFreW1Eak05dm45dDQ1V2gvdlVOUTdscVBmdDBIZFM5Q3IwcDNYTHRuMmFVV1pjdjFZYmp4MDFwVkFRMks5eEh2QXk1RWZGZ1hoVUptQ0tyVVhhVHJsZDdWcUtidFRlczlxODVSVFhkNTRPS0VacjRZa0hMQnE5TEhpRVNUR0s0TUdwRkJocXN4blVCZFNLdmpJcnRqK2lCbU1LTWZWckF1SkNBU2xNN0QwUUtLbUNVamhtR2R1OWEzbjBZNXlWQVc2MncwVVlTbzF2Unk0dHorOVNZY3UwZ0RyTkQxRFBBbXZldXB2Z3ZRZ0g1NVljUXZld25KZkNHcXFsNDlQUHprMC9mZC8vczJ4cU9MQjBjejVpY3JGdk1WaTBYTmZCV214bFE3M0RISFBnVUlFeDUwZDBqL2Vwd2dVZFBDSmx5ZE5WOTQxMzNiTnd2WVltaTFRNHhwaUI1bzRiMUxJNnp6U3RNbkI4TVFGTFZKZStHOXgzdkhvdTJZOThxaWk2eDhBaEovOUx2ZndYZTk2MzVlK1BYUDBDNmIxTi9GOUFXc1c2Y3dxT21pM0tHL3g1ZzRXSW15cFVrU08vdzhtc0ZHeUEvQ3F4anBoei92MWpqUTFBT2xoVVFyTnNJd2RNdWJQWDl0b3F0clZFVFNpbmdjNWZxUkN6ZGRINWZBZkdpUjNEL0c4dVBzSzM3Wnp4bmFKUVBrbjN6aHBXY2ZudXc5dTFQWTgwM2RTbk95a3NYeGdxTlpRNTVWTzluTzZDMmo4ZmdYbXJwZXg3VEozUlBrNjN1RjRVUDN4MDEvY0ZEM3YvbkExdWd4VGY0M2t2Yi9pWlhhZElHbTgvUWgwbmxQNXh3aHB0SFhZT21pY3JCMExGM0VxZEQwMElia3htNU01RE5mZXBWdmUrY2ozUGZ3Zzd6eHhlZlRRQ3lwbGZOQlV3aG5TTFBGbW0rbFJna3FRN0hlY1dKODB4MG9naGw4ZTZNcVRsSWJWdVdCTjQ0OXNZOEpQekYyQ01WUmpKcWhhSFFZOGdNeENxNUwzNDJ4VVFzanUyWFdzZWpwaHcxU3k1MklndCtwUUU1L2JzOW9UL0FBQUlBQVNVUkJWSXhna25BdzZVMEMrQmpNOE9lNHhuVW5WOSs0ZWEwTkdsZXVONTBMb2tHSklhQVM4a0xONHp1VHJhMm1ydWVjU2FHS01YNU5XcTI3ZXBEMWdIcUhDQ3FBRlNGM1Fka2U1WnNYcHRXM2V0VXNvT0tqY2pEdk9GNzIxTDFMQUovcnFQdVd6bnZtdmVlNENWeGJlRzRzUE10T3lYT1k1akROaEszU01zNmdWT0gxbThlSWhmZSs2MGxpdDZSYkxCTkZ4WnloZFF4bytkb0p4YTZYWlNLbmN0elQwTS9oTkxDU0JGUHBaaFF5U2JUM0loUDZJS0FwQ3NGWU96Q0xrd1ZRYXJjR0YrQ29aTllnZzc5V09qWDcrckJwLys3U3hhTmh5TzRLYTd3eEVvYW90YS8wT3ExZEVkSHBOTmZOVFlzUktMS2NJcDlJNTdvRXhZb1VHdFdjMzlxOWNMR292cGtZQ21ORXJGaDZuekxqSitOcFZreEhuN2wyZk92YXVxajRHcnE4bTd1bE1Rd2Y4ZFI2S3FhOWVvcEV2cjNzbnR0ZnRTODIzc3VzN2ZYMnZPYmwvWVo1azA0TEh5T3JObkN3VWw0K0NieDRDTmZuNEx3d3RyQTdna2tHVmdLYm16a1h6MVU4Y3MrRWgrK3BlR2l2NElVdnZjUkxWMit5OTlBampMYzJzS0xrMXBCWktBemtKakZpalIxQ2RnQnJaZWd0a3NwdmpXZWN0a3VpcDlRUks2bmFEZW5QS3ZNRTh1VzJJRXZNcmROYklYbDFDZFprR01uUWFERmlzVFlueTByeXZQVHI2T3kxYmRIbUtOZit1Yi95ai8wK040MW5Oa3VidTg1NU5rWlRIV2dpVVZYN3FERmVYODArM1JsenpZb2hNMFlqU3BHbGhCVGZkdmNYM2p4bTgyd2czSDl0MjZ5N0xkYVpxd1Q2WWRSWVA1MWVQYTZ2bmh0bEh6ODN5Wi94TWNxcTh4elhnZHdJczBZNHFBT3oxdFA2Rks1WldhZ3lKYmRLOHJkTndxQ3lFRFpHQlNkMTVLR0xJelluSlJzYkV6WTM5bERHbU5FbWV3OCt3TUdMenhQY3dMV3lneDIxcHJBZFZjRVA4bHVydzVMZ2RKaGUyNVhlb2FHc214dzlnNXlQY3VGSWhqbER3S2hKYzR6bzhMeE1mN2NNdUk0QXh1YmttUUhwblh5WjVrSkVXUHo5ei96akRYbWF0blYrdmVQQ1U3ZHZZSTFaditjQjhDZjE0cWpkRGwrY2lEd3FJSmxOYSt2TUdycW1NK1hPK01yMjV2YjQ4UENndmxzZ1g4ZkwzZWxlb2lvZTZGeUlxNk82KzN3dTRVaGozRDJvQTdkcjJLOGpuVTliSjRoVUNHTnJ5VVdUVk5Zb2RxQnhJeEZyTW9vaTQvaW80WVAzWGVHRDc3akN4czRtazJxSG9wd2dtVWQzOTlpOGVJN0ZqVnRvU092azB4dDVuVlBvN2tTcXBWTmhJRE9xM3RsOERqL1dzK1piZXFkQWloeDhkOGVrN3RRY203VGlqVzhpdHl2R1dQSThSeVczd3BlYlJDdlNMMy9YNy9rSDMvSnVucnZ4Q2dmTDR5amdGZnlpYTVZTDE3MTRyaGdSdXdhclVGaEZqR2p2ZWhtNytJNE5XMjBmd3NtWk9lUnVnWHhkWnBHQkpUNDgwWHFnUFdqY1p6TFI1MDVxL2NDdFJyVWFqV1JqTkNZY0haRU5pSFFtZHFDYWd6VktuaVdTbmtoUytPMXRqM2owZ1IxZU9LaTVWVWZlK3JhbnFVWlFGRVd5OTdHVy9YS0N1Z2ZwNnhaM2VJSVZjK29zRXVMQUI0TkVrUi9tcGppWStlcUF6OXdaaVUvNXYwTzlKSFErczRJMWFXbGdaRTE3VDdMZWRhVUlXVnJRbnA0aVNwN2xLRVZoRW85ZXpnNXNsTC83K1hqWnJwS0daVGk1QmZFaEJyY0k3bFdmajJZQ080VTFPQk9wTWtQdmVzMmlYam8zM2IzdjFZTnJyNHVTRFFHaFoxUHE3czRnWHlzUUpFc1loNTdaWnZYTFB0eCtiUlorOFdZanQ3d2FzVmE0Nzk2THVya3hVUmtNRU5ZTTJzeWtFeVRMSXNZRWpJa1V1ZkMydDV6anFjZVQrOGt2ZnU0RlBudmpCcGN1WDJJeUdyR3hVVkRrQmZzSGMxNC9yTm00NTBHeXNrd3pRU2JKaThxa3VTT3BFUWRrZXhqQzErY0ZNZEhMMTlQeCtwNGZLRmxERmlMa0VoTnA4a3huSWlwbldyT0I5ejVBR0tvK0ZaRzFwK250WjF1czZibXQzL1Y3M252SDdkbWhEbkI0Vk5RRDRhaHJYbDBHZDNPZ251bHcyZ2tHK2xXelV3U2V5TFBjRHY1M1g3TlQ1TzRXNjh2ZmtFVGZlRk1XWDRob0gvVmxSVjRHYVp6dno0M0hvOG41blQyT1ppZUVHRko4V0Naa0ZveE41Z3U1TlZSRndkN09sRy8vNXZ1NC82RjcrTGxQWFdmUks4ZDl3T2FBOUVTU1dmT1AvOVN2ODdmK3Q5L2duVTljWVhOalNyT1lJYWVvL1lDSFJBYkh4ZlZwa013V1RwM2l6NXdmWnpVZmNaaEZqRURkQmc1WGtjTFlNNzlIQjJOc3VYUGljQ2NzTk04czFyajlHNHZaVHgzWC9hRkFKeUw5eGlpUGorK04rUnUvK3RydjZ2M2VYeHh6WVd1SFBqaGlqT3RrM0FLYloxZW1XMjhybGNkOERCSVZPaGR3UVhHOTUrS1Z5OWR1dGllLzFqUjF6NTJBejYvNk51dHVpL1hsVDdRUUdXVkcrNkFhRXAxNjdZUjdHOXpmQi9uMUdQbjVtd2Y3SDMzOC9lOTl6Mnc1dSsvMU42NUprQUhjMDBUZXlLeGxPaGt4S2tvdW41L3c2S01YV09xWUM1c0ZqZVM4ZmpEblAvL2JIMmVTQytNaTQ5TFdCcC85L0d0OCt0VjkvdDV2dnN3UGZ2T1RUQzVjWkhYN3hyRE9UUmlKTmNQNk5xYk5sRmloc0FZWGROalFEazZFcDl5T05VVmVUdFcyNDhwZ1RUS05NMitxS2owOWRjN21PMnVNeExEQ1dPOGxzVEhmaEc4RTkwOTNYMjZOcHh5dkZneWJyQUQ0NDNxK2JMMTdlY2ZrMnF1VFNXNnBCODlnWWpEUytLZkh0dHc5Z3BQQjJjVHdOYkFmdlh1Q2ZJWHIvbzJDUGlhcXhobkFhOTNmOXNDMXJ1OCt2Ymt4ZWVueXBZdFA3ZDgrM01HcnFpSjVwa3dtTUJtVlRFY1ZaWkh6d09VcFR6eHhpWi80QnkveDZ1MGxURGVaYmxaVTQ1eVlHYm9JKzZzV3JYSjJ6bTl6NkR4SzVORjd6a1B3dUtZWnpLVFRFLzRVRXh2RVRTcUQ2L3NwWUhnblVwb3p3YUl5dEdhNWdXV3JoR0NHeHYyT0ZDbzFVRWtEY3BwSklnRXJuU0R5NnRWWjgvZG1UVDhUYUJGeG85ekdGdzlyM2ppdUtVdUw5Ly9reGJJOTJlQndPUnNDR2RRQXVXcTBsemJQN2U3bStYc2xoSEZtTEszejFDNUlWQ1JUVTUyN2ZPbExMOSs2K29JZ25xOFJzL2R1Z1h5RjY4SWs1NlFOU1YybmI2SkluUEtKUkNRZUhCN3ZQL25ZVzBaVlZyenQ2UEFvRTVDZ2tmRTRlVmVWZVk2SThNaUQyOXc2N3ZqWlQxeWxyYWFNdDhaTXBqbDViaWdLdzdqS0tNYzV4VGhudEZGUWpYSU91bzZ0SXVQU3pnNTkyMEhzVVVnY0s1OU9Ld1kwUFF3YnJYVUxkamJqOE01MlNrNkRRMVZoVmdlY1h5c1AxNnRoUGYxeEtwU0FJV0RFVVdSUmxpNSsvUG1ENVQvc3ZLL1hiVTBmb3A3VVBYMklaSm5GWm9acWxKOGFPZnpqWE1lck9aZTNMOUM0ZGwwZ0daQkhZK3psY3ZKZUUrT2wxZ2VLUEVNRWVoODBSakhWZFBUNnE0dGJuNG9odU9IcnVWc2dYNC9yc1BGa1JwZ1VCajhFMUVUOXJVVVNZcVIzN3NiRER6eHdvVm10SHFsWHRZbHFjQ0dTNTBuRERzSzUzWW92dkh6RXpaVlM3bTZ4dFZVeXFneFZaU2xMUzFZWnlBVEpEVm1SVklRUjVlYXFZU3UzN0V4R3RGMkhhS0xhT3hkUHBiRnJWTk9lWWg1cmxTQmZobGVrSWxrN3hEY3VzR29oTjhsSkpjbDd6K2plTlNINUNaSHZwTXp6ZnI4T1AvWGl3Y2tYdVlOZ0IxWFZ0ZytvcW9RUXlYSkRXV1ZrMXZ3VEZjbDlPK2RaZG8yNDRHVW9rS0tMd1R3MDNYMTdxZnBZQ2lvVm1UdlByUGRJVkRPZFRPY3o2ejZ4WEMwWGdyZzdtL3F2WHBIY0xaRGY1dkpScVhMREkxdGpHaCswQzNyMkpEbGRGSjNNWnQxb05McTV0N3Z6OUdLNXVCaWN4M25vK3JURkVwU3l6SGpwK2h3bVU3WXViREdkWmxRalN6VzJqRGNzMVhiTzVsN0I5bTdPeGtaR01SVEp5aXZYNXlzSzdSbGx5UkpING5xRm5NaVFxbW51NmZ0SVp1VU9aMnNnTDZxYzhTSVppbW9kdkRtcmswejNUZ0hkT1M2VGhGNHhKcEpiVDdEWjY2OHQzTjgvWE5iN3ZKbENjdWVRU2dzTjZWdFBsaGxNSmx4NWNJdXRyUW4zM0x2TndmNXZqNWRjMmo3SHdlS0VjR1pRanpISy9adm43anVmNSsrS01SWXVodVNNMzN1eGlKUjVHZU1rLzlWYnh3YzNoeUg5cTk1bTNTMlEzK0ZxdmVKVmNjTThjc2J0L093SFlJNW5zOFVEVjY1MFJaYTlZemFiajBXRnppbGRIMUYxVktPY2VSc285M2JZUFRkbVBMRk10M1BPM1ZOeCthRk43bjlvbDNzdmI3TzNXN0cxczhGME02ZmFTUFNLMmltdnpqcVdqV016RjdDR2lGRG1Ka2wzSlcxM1hyeTU0dHhHbWRiVkErb3VaMDRUWGN0dWg2SEVSZVZrbGZBYkVjVU1EdGw2NnJDaUdLTVk2YkFHNm5GbDVxVnFYdGlZNWJacEc5Y05SWkZ4QjgxT0ViaXFlQjhGWUxWMFhMNS9sNWRldU0xOUQreHhjbHgvNWJaMmM0ZWoxWnlnY1kxZjVvcmE3Y25XMXA3TnZqa0VQMDA0bGVHazZ3aGV5Ykk4YkYzYysveEx0NjYrZFBaVXUxc2dYOGVyOFpFKy9JN3Z0NFlRek1sc3Z2LzRvNDlzeFJpZVdpeVdWaEI2cjdoZ21FNXlWblhIYUcvSzQ4K2M1NEhITjNuMDZRczg4dmo5M0hmL2ZlenViRk9WSThwOFFsbU5xQ1pqUnFPY2NpUVlFL0VlcmkwQ2I1ejBqSXd5R1dVRGdUQjVhZTB2ZWw0NHJIbnMvQmdkVnI1eVpnaVJ0ZGN2ZHlJUFE0UmJDMDl1TXF5SkdQRnAyaDlzU3hPZnkySG9vU3c1MEZpSzFiZnM3RTQrc0xNM2VjdjJ6dGlLa1hxMTdFNnA2cnhab3lISjRBTHBXa2VXV2ZiT2IyQ01zRnAyditWTnZEMC9abk04cGVsYlJNVG8wR2FKTWZrRDQrMXZNeUdjajVwU3NXNzNMY0ZIQ3B1UE01UGRmS003K0xYZ1EzZTNRUDY1dUFSSjE5bVRSTnF1Q3k2RU4rNjllT0Z5VTljUHRxMHpTT0pLalV0aGUyL0UrNy85TVQ3NHNiZng4RnNlNU9JOTk3QXgzU1l2eHZoZ0VFcnliSXdZQzhhaU1rSnNTWjZCNG9ndU11c2lYM3oxZ0pPRE9YdGJGVGJQS0hQTEs0YzFMOTFlOFUwUGJkRzVsRzh1ZzNaK0hXaW9aOWEzUWRQcGRGUjdVTWlOdytBQVF4U0RrVUFtUFNLT29paFlsaE5td1NNYWhCREwzSm9yNDFIeDNwM3QwVk1YTG16dWlaRjJzV2liVkNDU25Ta1VWSld1ZFFRZmFlcGV4dU1DN3dLalVVN1grVGZmakdJSk1aeDEyaTljRFBiSzVybDNWQm9mU2Q2K0tuVWY2SHhFRUNtcjZzQlBzaytjTEdiTEw4TkQ5RzZCL0RNcWtMTE0rQXJ5ZzJ3Mm43c3NMNjVmUEgvKzZhWnV6bldkSStiSVI3N3ZTWDd3ejN3TDcveldwNWhzbjhQa0UwbzdocGpSOWtvTWdvb2RhQjhaUG9CM1N2U0s2MXA4MHlJaFlHUGs0UGFjeno1M2kydjdOVHNiRmFOUnlTOSs4WUNEWmMrSDNyS0RjOGswWVQxZzI3WGw2Qm16bjBoQzRBL3JIdTlnbEtWdEZVUVF4VWhJUldLRXRpdzVscEk4SDRQMFl0Y3d2bXFWWitiKzBTaC81Kzd1NUIzbkwweDNvK3F5YVZ5cktZejliTnRGaklyckE4dGxSMmFORkVYR280K2U1L2J0eGVrYjZJSmpVazNFQlNmck9TUm9sQXVUcmZ1M3hMeTdkejZMS3RJTzRhdk9SY2JWMkJTVDZ0UFhqbTlkUHpPSDNDMlFmNWJYUGZmdGNHNW5qMVhkU0l6eHJPbDFjVEtmdFhzN08wMVpGSS9iTVJ0LzVFOTlVUDdRajMyUVN3OWVJaS9PWVV4SlpqSzZFT2ljUzZvOTFVU2RENUcyNjNCZGorOERYZE93bkIzUnJScGlIMmtYTFc3VkU0UG4xUnN6WHJsVll4Q3VIVGFNUndWdmUzajdOSkxBbU1HVWJTaVM0ZXhiTy90Z3JPSGFyR08yREd4V0NRMUpkUG5rQkpsWnNLTUoxM3hQRTFxc1JGU1N2V3FXR1RIR0lHSVFKQy9MN09KNFZMenQza3ViNzk3YUdadStEMGQxM1h2T0NKcE9qMXROa1c1bGxaRmxodG1zT1hXQkJOaW9KdEs2YmwzZnVVSTJLc2VqQy9ub1E4SDEwNGl5OEFtL2pUNVNGdFhJRnZrTFY1ZTN2a0RVci9vY2NyZEFmaGZYZTcvNVVlcW1sY1dpd2Jtd2Z0cmxRQVdNam1Zbnk0OTg3NVBiZi9MZit2Q1QzL1g3MzJiSzBZUVFER0pLTWdNaE9McmVFMFBhTklXUWRPMU4zOUswSytwNlJ0dDJyQmFPZXQ3UTF5M3QwckU0ck9sYmowMVZ3R3dWZWVINmtzNHA3M2xrbDczTkFxeVFGNGF5TUtjZ1lwSnd5QjNMb2lIRjUzZ1pPRmgyYkpjRllpTFdER3RkaEtLcXVCMGpCMTJETmFBU1RnVll4aVNXc2pGQ1h0aGhYc3F6c3NqTzcrNk0zM2ZwM3Ewbko5T3k2MXEvYUZzWHZ2dzBVYUR2dko2Y05JTWJwWkJsZHNnT0tXbGNLeUlpeWRlZXlzZlFYcWcyM3BQNWVGOXVoRG9FT1hFOWViUWFvMlpxNWVxTTlsTmQzN1Y4bFdrbmR3dmtuL0NxcXB5OHNOeThkaXp6V1hQYUs0dklDSmhzYlkrMy8veGYrTjd2K0lFZmVkLzNQUHI0cGUzZVIrYWRRekJrUnZDK28yMXFYTFBDdVo3Z2UxeDdUTmMxTk1zWlRkTlRyK2JNVGc1cGx4MTlwL1NyanZudEpjMmlTNDZKSWRLMVhXcFphbGkyZ2FObFIvQ1JjWmtobVQzZFNJbTVZK1pnQnRWaGFtZVU0N3BuMXJUc1ZEbXFLWm5LR2tPZUZ4eFJjTFByME9Ga3NkWWtNKzBVeFRFa1lBbGxtVk9OY3FwUkp1VTRKeXRzTmhybjkrOXNqOTkvOGVMR2ZWbG1UZzcybDdNQmxEOGxGT3JnRnJFR05ZTVBiRzlPeUxNSzd6MHhiYk15a01KWW0xL2EySHVtOE9IcEdLTUVWRTU2UjZZRzc2UHM3dTZKVnRuSEQrWkh4N3haWmFoM0MrVHJlUDNjci8vNy9BLy83Uzl6NjhaTW1xYVhPOFhCU0pYcDV0Wm8reS8rUnovNC9kLzVmVy8vWTV2YjQwcytRQi9CR291MVdZcEhidnZCYWNUZ295UDRodEN0Nkx1RzFleUl2bldzNnA2bTlyakc0OXRJTzI5WkhhN3dmWnEwKzk3aG5hZHVQTXNtRGVDTHh2UEs3U1h6UlVjcEpLc2ZJNWhNS0F0TG1SdnFOakJiZVdhcndNMlo1OVdEbXMzU1VnM3h6bFdlTVM0TFRsUzQyZ1F3VlRMdGtZQXg5bzcwVjlZRllpakxqS0xLS2NxTVltUWxMNnlZZElxTnA5UHlMVHU3NDdmdW5wdFVpM203M3pUT2ZkazlkM29EMjh4UzVCbWJveTE2NytoOUw1SWNldk9vbW0wVjR3dFRNZDhxTWRoTURFc2ZLSTBSRjVReUsyeXQvUy9zMThjM3o1d2c0ZTRKOG5XOHNzencxTnZ1bDA5OTRtVlpMdHJUSVJJWUF4czd1NVBkdi9nZi91RHYvN2J2Zk9aSGl6Sy8wTHRBVUQwTnl4R1JaQkhrQXM1Nyt1Z0kwZEc3SHRkN3VxNmxiaHhOMjlPME9WM3RjRTFQdDJ4WkhyYTR4cUV4dFdLZDh5bkRiOTdUdEdjTTRCUnM4UFJOdzhGSk54ZzRHSlpkNFBydEpkY09lMTQ5OHJ4NlVuTjF0bVRwZXdwckNTcEVUVVRBV1l5OFZpL3Bvc09JUWRjaGJPdk4yQnBWSk0weFpabFRqSEx5MHBMbkJwc0pOaytTQUpzWnlzS2VtMnhVNzdod2Flc3hFVGs0T2E2UEJ2Mkd2S2xJRkVKSTc5Zng4Z1NUaUdNR1NBVXltazczOHRHSGNQMDBONFpGOE9rRUNWRUxreGVUM2MyWGJ6WEhudzhoK0RORmN2Y0UrWHBkMWdxZitKVVg1Zmh3S1RIcWV1WVlBeHZUaldyclAvaFBmK1FIUHZUdHovenZUVzdPeGFoREtsaUNyZU5nSnQxNWg0dUJ0cTFwbXpuZTlmVGRrcWFiVTNjTlhTT3NWcEcyai9STlIxKzNORE5QTytzSjNvRU9IbHcrME5RZCs0Y2VIKzdjWTRVUkxrOE5wZlUwYmMvSnZHRzU2dGlmT1Y0OGFIaGozbkZqdGVLZ2JXaWpKMGhrRVR5TDRGbEZUeDBEKzc2bGl4NGtFTFZIakpJR2NqanRrSVpDTVZhb3FzUWR5d3FURkpTWlVCU0prNFdJMk54b01jNktvc3dmMk5vY3ZYTThMbU96Nm0rM3JYTkRBYXhuZDQycUttSW84b0xlOTJ0ZWxnWEtVVG5LOXNyeE80enY3NDhhdFZPVjNGcENnQmpVN08zdTlTZmEvdEppdGFoRjVLczJoOXd0a0gvRTlXTi85aU5NTnlxdXZuSkEyenFqZDRwakpNTEdlRkp1L2gvL3J6L3d2ZC95NGFmK1JER3lsN3p2eE1XUTJxaDFQZ1k1em51Y0QybnU2RmJFNkdqN2hyWmQwWFk5VFIyWXoxdWF1aU8wUGNFSjNkelJ6Qnl1NzBFRE1VWjZsMEowWmtjdHh6TjNDZ2NhVWM2UERPZEhtbVlPQVRTeWJCMnZ6ajM3cmFjT1BaRVUrV3lIaUlVMFd5Z2VwWmVFUzlqVE5pb040eW14U2srZFZXVElXRFFpbEZWQk1jb1NVVEczS2ZwQkJMSHJ1UVZKaFdNb3FteDdPcTNlc2JVMXVtS05IQjBkMVVkZmRwS29TKzNWblozNmNGSTN3ZXRlT2IxM0l2SXVDOVpIUmNWZ0l0SjRMOXZqamV3a05MOTB2SnJkUHNQdS9hY3VrTHQ2a04vaGV2ZjdIbHBqQ0RLWTlobFZNcUFVWVFveS9lTi8raU1mK3VqSDN2cW5xMGwrdnd0Qm80cW83MU1JcHMweEprOWJxaGdJb1NlRURteUcrc1FXUm5LNnRtZTFjSFJ0VEo1VmJhQnJvSm4zZEswbmhzVEI4aTZrVEVJZmFCWU9veWxqSXhQbFFtVzR2SUhhd1hORUV5dUZWYkRTTVlUanJFMFoxaUlzQVNzWnhrWVlpSkJyd21MYVVxWGlJQ2F0aWVod21neGhuQnFFNk1QcE5vNkJ6eFdIWFhLZUNjWWFRbEF5azdCVmtYSWp5ODMzbEZWMlg1NWxmL1ZMejkzOHBlRkVIa0IvUGRzZW5kckJPdGQxallhWG8yUzFScjlwZ1Y2VVVXN3BuZEl0NjUwcmwrNTU5S1hiVjU5VjlDeFlxWGNMNUd0MHZmYmFJYk5ady82dE9TTFlHSFZkSEJOVkpuL3lYLy9vQjM3d1gvbmdueXNueGYxTjEydEVKYlFONGh6WmRCTVZROXQxZEQ3Z2c4ZjNEdWVVRUtIdWU2TDNlT2ZvV3FWdG9lOGo2bE9jZERQdjZab1dvbUlsNG56QXV6U0hyQmFPdXZGa0tJVXhlcjZ5Y200c1pCTGlXbHlGU095Q3NTZE9aSTJnaTNBNlpBdUR0N0JtUTNwVWl4SUh2OTg3YVZjNlpKbWMrbWV0dzN0Q1RNbFlJYWJBMFJBVHBwTWx2cFJxcXNxaU1uUmRUSFU1dEYxaVVadE5uOG1NK1hmeTNGeDY5dGtiLzZ0TDNLMnpzdGsxekw0MkZIZXRoaHNtTDI2TGw4MUV1QXhZWXhGQis2NHRwMnc5Z2NqZlF6VWI3dTEvNmxQa2JvdjFPMXozUGJESDhlRlNUbzVyTXp5VlRvdmorLzdnZTU3NEUzLzJPLzdOOHhkMjNxcFJOQklsb21SNVJWR05FV3R3THMwTHJlL29YRU1JaXZNZFhiK2k3VnBXOVpMNXJHTzFDclJ0UUwzU3RZRm03bGdjdDRUZUk1ckNMSFd3RDNYT2MzaTdwVjFGckZneVJESlQxSUg4eFRhR24zTXh2dFJIdm5UY3hsL2NiMnp3bUl1UzNLakJyREdSdFo3ZERKRnJLUVdFSVpmVERCRU1ETHRabTV6c3pzd2ZkNXhXaWpLanJBcnlZaGpTamNIWXROU3d1YUJHaURHZFptYVk4c1dJaURXUzVkbFdWZVp2TDR2TW54elhML2tRQTcvVm52UjBXN2lLbnN2Vnh0dExlSVNvMUNFZ0dQb1FFUlZiVnRWaW5vZGZYdFhMNVZkcm0zVzNRTDdDOWQvOHovOFd5MlhMcXkvZGxKT2pXbFJqTmtTR2oxR20zL205NzNqa3oveWJ2Ky9QWHI1Lzd3TUdFVlVWUkNsc2dSaUx4OU4xUFczdjZic2FGMXFjYXlCYXZIUDBmWWR6TGZXcW8xNHB2azgrdUtHUGRFdlA2cmpGTjMwaUhvWWg1RE1xM2dkT2pwdTRPSTZNelNoYWs5MHl4andialBsYlI2NzlyMjQxN2M4ZXRQR1g5dHZ3eTBkTitHd2Y0dWN6TVNOcnpVT1lkYmVRNHFPTm1GT1IxR2tVbTVyaHh0ZlRWbXVkL1NIckUyVGR0UXdvZlpibjJDTEQ1cGFpc0pnc21kemxtWnlhY1VjZGpDVUdsMGhqSk5Id3JTSExiVlhrMmRQVFVXR1h5KzZWcnZQOWx4VUphNWFDanpHN2IvUDhrM2tJYjQwK3lDSjQ2YUppVmFUWHlPWjRRL3ZLZkhMLzVPQzZTSnBEUkNRZ292LzFYL2x2K2RzLy9iL2ViYkcrR3RkZzV5bXB0UktyT3FEa3l1UytLM3U3UC9KakgvN0JSeDYvNTZPRVlBRkpVaEV6Q0kwQ0lhU0IzUHVVLzVHWmlpNUdmQmpqZzZYckRxaWJobFd0ZEwyaVBra0JZeStFeHVCWFBUcVlUMnVJaUdwYURmZStuaTI2WDZxOTdtK1h4U0k2L2N5eWIxK28yL2IyOE1RY2drS1NZM29mdzJyWjkvL1pWUEpGbnR2dkY2T2J3N29vZGZ2RGtaRWlvem1Oanc3cjZJTkJxYmpPWEZkTlZoQlc4cFN1RlFOOTc2bDhhcSs4aTJSWmNzK09RY256NUEyMlprTkxpdUdGQ0ZtV010dkxhY1ptR0cwYTlJOGFJWDd1Q3pmKytxcnUrWXF0Vmd6MTdYcnh1Y3BrSnpIcXVSZ2luVVIycGNBSDFkVjhzVGs5VjEzQnlLYzEzcGxEM3Y3azIzL1hzOGpkQXZteTZ5Lzg1Ui9rWjMvcTEvbmk1MTVMdE90RXZDdEVtQlJsUHYzVC84YjNmT3dkNzN6dyt6WDRERlhwUStKUW1jRTROemNXTlNVZEVhSlBjV2FocDIzbWhORGdmYUR2RzlvNjBEVVIzeXQ5Rytocmoxc0V1bVUvOVBuSk9USEdWQ1RCUityYS9lYmhjZjFYNjliZm1MZUxKYkRpRHZmSW4xbHRydHVTcWcrK256WGhQOXZROHZXcXpQNmtTRHczaUtuRXNIWnZIMFM1ZzBjdkpJdWdkVGp6MldnQk1aTGFzWmh3RStzQ3dRVmlWTUlRQnlFaUdEdmt2YXVTcFJ6cklUY3huVDVpd1dUSk1xbWM1aENxaVFUOUVXTkVmL1B6MS8vYWF0V3ZUNUh1N0N6U0V2Wk5OcXJWZVNxeE9BMkpJb09LODM1clMwYnZtMDZtUDdkY0xHcEJySWpZTjI2OEViMzNkMXVzZjlyckxVL2Z4NVVIOXZpWm4veE5lZjNWQXdOcTA5d2hVMVZHUC95ajMvcmVIL3JSYi8zejAzRjFqNnFpa3J3UGpZRk1rbGFoZGYyUVFwVUdWKzg3TkFRTWh1aWc2MnJxbGFOZUNsMFg2RHVQYXlPK0MvVExudFh4NnRUS1hXTWNpaVBnWFRpNXRiLzhidytQbTE4REZxVDRnZWJNYTgxRFdsTXQxZ1VURkZ6bi9VdFd6Q3l6NW9vMWJBc2liN1ovazZHRllvaEYwTk9DV01mQ3lkb28reFFySERJVmk0eFJsVk5XR2V1VmJwYW5GczRQQldHdE9RVXo5ZlM0R2dEQ3REVlRVYW9pczA5T3h1WHF4cTM1Q3hyMWJLdVZOQ2ZHbUhzblcrOHkzbDF4UGhCQlNtdFMvbUxBR0dNV2JKWWZQNW9kbmF6Zmg3N3Y0OGMvL1N1NnFsZDNDK1NmNXJwd3p6YWYvT1hudVhuanhJUVExMGo1QkpoOCsvZTg3YkUvOStjLzlxL2RlK25DMnl3R0pVaU1mdGdZNlJEbDNPTmRRSUlTWEdLY2lvSUdJZmlTcnF2bzJzaHFPYWRwQW4wZmNGMGdkSUYrN2xqTld2cW1UMUhQcC9rZ1VUV3FMSmJ0ejErOU52Ly8rQkNQdVpQTjBRQ2RrSUF4K2NvQk5hY3U2NzMzcjZqSzg1a3g1ek1qbHlVOTRBYy9MTzVrcFErVFJ1SnYzWEdQWHpPQmRkRHBDMEtXVzRveXg1cjA0M1JTcE5ZcTVmQU1wbmQydU1zSG83c3d0RjNoVHVTMEdCR2lqK1dvekI0ZmovTWJOMjdPM3pnemp3aVF0NjRMNTZiYnU2V1A3K3FjeitjYXBESVdRakt3R0kzSFZOc2J2L0g2NGZVMzdqd3NOQ3pyV2k5c1RsaDE3bTZCL0c2dWIvclFXN2gyOVlqVnNwVys4MnVGWEFWTUx0Mjd2ZmZ2L3FVLytNZWVlZnJCNzFFMXVkTW9RVDBhUXdxdFFXaGRvRzRhUXRjUFdZTEppajM0UU5mVjlGMUwzM2FzVm5QcXVxSDNxVGhjRzNHMXB6NXU2VmRkd2hpR3hGdFZSYU5LMS9xWGI5eGEvT2ZIcy9hNTRmUllEY1hSV3pHaHlzdVlITklUR3YybVkrSE95d0M1QytFNGhQaHlKaksyeGx5MnhoU0Q1bERXanUzcjMyNU1PaDNUMXNxazRoaXFLWVlBeG1CelMxNWsyTXllbmg3V0NwbE4xV2JPdkdMa2ptbGo0TlJPWCtQWkFGOVIxL3J4eHFSOFpESXRyOTY0TVgvakRKaG9BVk5sK2M2dUtUN3MybjVVYTZRd0JoT0ZUaU41bGhmWnFQcmk5ZmJ3aThINTlZa2E4c3pxb3VsT1p5RVI0ZExGUzd6dmZlL2p3WWNlNU5WWFgvM0s4K2pkMGtqWHgzL3h2NllzcmJTSmhIaVd2ajcrbC8vWUI5LzcrQlAzZjVkaXk5WVBpV05Cc1pJaEdFSVg4SzBqOXFrZGFwb2xiVjFUdHpWdFc5UDNEWFY3Uk4wZTB6WnpKRVpzVUV4UW9vdlV5NTYrZFhkU2NoanNmRklDYm44eWIvNi9OL2RYbnpyVFRuV0FOMkxpSksvaWRqWFY3V3FzOHVaaVdOTTAxcTgxcmNPMFB0dzRyTHUvWG5mK2Iyams5anBoYXIxS1BtWGFSaUdFbUR5NUJJeTFRNHUxRHJSSjJ2YmVCMVFrSFYrYUVQUjQyaHdOQTM2ODQ0T3FNUldlc1pCYlllMzJLOFpnQ3l0NWxRdkt3NWN1YlB6UkJ4L1lmV3o0SElwMW9jeDkvd1pGY1VzRnRZb0dUU3BLajlMMWZVbnJIdCtvcHVQaE04d1VqQTl4dlhNNGxRV3I2dnFGdGZidWtQN2JYWC9wUC83ZnNibjVIZlRPSXlJbXhwaVIwaERHNzM3L0krZS83YU52L3dON096djN0SjNUMGhqcG1pVmRVMk16aXhoRDdEelNPWEpWbklGNlZoTTk2TWdUeGRBN1Q5OUYrczRUZ3RKMGtlZ1VEWXAyZ1ZoN1lqK2NHbkhkZWtTSVN0MzJuejg0YXY1QmpGb1BiVlVIQkNNU2pSRzk1OEtVd2haODhZMGpTUzM3cVZ3MUcyNnE4c3lyeURPVDVaa3RmSWp0Y2RQOVhPUDg3YzFSK1M4V2VmWTRndFVZaVdLVE0yTk1acmhpZEdpUEJ0cUpNVU94R0t5MUtHbGcxeUhSeW50RmpXSmpNZ1NPVVRFeENiZENUSGg1R21Ia3RPMEtNYmxHUmlQa293elhPY0h4M3FlZnVQaXZlaC8rSDI5Y20xMGJCblhiQlhmWUVsK3p4anlHVTNGQkdTZWNSVjNuSkl2bXdRdlR2WE9IUndlejRmc09xbXFNaUs3aFVXTk1QRHc2MUYvNzFLOUZFWkU4enpVRmhkNHRrTjl5YlcxTnVIalB0cno4NHMwMUViRVFZYlN6TzkzNFUzLzIrLzdJMDA4Ly9pRlJKTTk2UXRzZ3NTZXZjcHh6U0FqRUdEQjVSbUVNYmpXbkhCVnBNdFlBRWxoMUt3NW5EVVlOMWxnMEpvMjJieno5MGhFN1A1aGM2ZW5wRVlNU2ZHaFd5LzduRG8vclY0WWh2RnZQR3ROSnpzWTQ1OC84OFB2NTczL3lNNFFRMTZFZTY4SVlEVGRIOWNDbHpYc2V2N0w5cnFyTTdnVzJqTERudk1hbTljMTgxYzJPNXUwbmZhOGxLZzlGTlViRXBOa2hjNms0VkFnK1lLMU5DVmhyRi92TVVoWVorWkFrR29jVHhLVytFeDhVQ1hvSEpEUVFOV0t5aElPRVlUTm1VK2c4VVZOckZ2TmtQbGYzWFQ3SzdIYzk5dERlY3pkdkxmNTc3Nk1UUkJyWDliWEdxOVBNUnROaFY5R3haVElLRWZIUlFRejNaWUhMd0kzaDFMVHBzTlBCMTB4REROR0xTS2pyT2gxOHFucjNCUGx0cm4vd003L0phdFVSWTNMMUU1RktWYXVQZmQvN252eklSOS8xL1ZWdXEraHJOSFRFNE1pS2doQURlVkhnV2s4Z0lGbDZPcXJtaktkVkFnUHJqcVpic2xxMmRQMlFPdTRNRWpKODUybVhucjV4QkJlUXFNUVkxcUNnUmgra2E5MnoxMjh0Zmw2VkZYZnlBSU9DTHBhOWZzdmJIK0xuZisxbFhyMStuRzZ4UkxHb0JFWUs0MHU3NDR2Zjh2WjdQbnh4ZC93ZG0rUGlmU0hxSkVRaHN4bTVOWlM1d1dhMjdid2NSM0s1Y1d1dS8vQlRMMUczUFVXWkV6WERSSSt4YVVBSVE3dVVlRm9XbTJYSU1LaklzSldLVVUvOXVrSlViRWpreVg1d1NsRURXVXdtM3lrN01iVnpHWWt3R1FkeFZsWllFTlhsck0wM1I4Vy8rTVNqNXovLytTL2QrZ0tpK09EejQ3Nzk0a2hNbXd2VDFjQVNzQUlCb1YrMTU2dXQvTEVzeTU3MzN1Y2s2VzV6WnRqdmdWNVZlMVU5QzdyOEZ0TzViK2dDK2IvOUp6L0d2L2R2L2hmODdSLy91QmhyMWsvZkVyVGMzZHZjK2lNLzlOSHZtMVQ1aGVCWEdyU1RwbWtJM2tOUVRKYWhNYU1mRktXQ3dic2V0UldxaHJhZDA5UUxWc3VHMEVZeVZWWk5vR3NqMWd1K2R2U3JIbndZYnFZNEpDOFpZbkFTb3k1bWkrNG5UeGJkbTA4UElScGpram1QS2ovL3FaZmxlSEZHMlppS1kvS1crN2NmK2M3M1hma3p1MXZsUjR6SVp0Y0hxckppTXA1b2tlZFVaU21UeVlpOEtFZUNHVmxyZVB5aGhxMk5pbC80NUl2c0g2K3dHS0phN0pCeXUzN0lydEh3SkRWY2t4cmxsTU9sTVlHUmEzUXVSdTY0MUVlSVhoTjRxT21tVmhMdTQwOEhhT2hiejhuaFNselhxekI2K01IN3RuL2s5UnV6LzJRMmEydlFiTjQzODNQWnhuNUVwMTZqOWlHSUpEZElkVzFuSjV1ajk0L3k2bGNicmJ2N2Q2YjNQYnczdmVmY3VEeFhaQnZuUG4vay84Nm5YMzcyeFNIR21xRmd2cUlqNHpmOENmS09kejNDczErNGl1dmQrdlFvVmJYNEYvN2dCNTU1NG9uN3ZrVmptNFhZMGZXZW9CYXZQWm1rSjZpUE11Z2VFbW5QbWtUMzlwMmg2MWMwYlVlOWl2Z3VwcTFOaUJnSG9YZDB5NTUyMGROMWpyNXp4QUhWOWo1cTczeGMxZjNQWEx1NStDbmVuQ1liUm1XbVc5T1NiMy9QL2Z6c3A5NWcxZlJEcGpPWlFLVXdldktoODFlKys1dnUvOWUzcDluSGlGZ2ZWTGUyZG1SdmU1TVl2T1JseGRiMk9ld0FBSHJ2OE41ampPV3BSeS9TOVEyZi9PenIzRGlvc2JsQnhZSUVNZ2xFWTRoV2g4U3IxRmFkS3MxTm9wbUk2SnV5U2RaNzVLaEQwY1NCZG5JbnMrZlVaVUdHM2ZQc1lFbGJ0MWhqcEY1MWJHVDJ2VTg5ZXY0anYvb2JyLys4SUxtYTBGVWI1bzJ0WXZ4UUhucW1SdkN0b1dzaWFqd2IwajM1TDczN3ZqKzZ0Y0hlSk1zdVpFSDNSRzMxOGsxYjNEc2VQOXc5OUphLzh1ekx6NzkrNXVRNFMyM1J1d1ZDVXNSZGVlaWlmTzQzWDVIaEdDaFV0WGppNlN1WGZ2aVBmZGNmcnNiWmZZdjZDQ05DQ0FXWmlSaWpxSGU0b0VTVHB4TUZnL09Cdkp3Z21qT3JGL1F1MEhZUjUwWjRKN2h1ampoRlhhU1pPNWFMZnFDdks4SEhsSUVlSXIwUEVrSThQanl1ZjdycC9PRndjcHhTd0hzWHRDd01xN1puVkJyeFBxNGpDd3VGYW1kanRQUGRIM2p3aDdjbTV0dGp3bkxZM3R5UzdlMWQrbjdKWkxyTjl2WWV6am04RHdsY3lDeld3UDdCSVNmekE2NWN0Rno2dHZ2NTlXY1ArZHhMeDZkZXdDSmhHTXF6WVRtMXRoRktZR0IyeHZRQklQZzRHRDZrTzk5b3drUVV3VWRGMXFmTUlDb3prdUljNXJWamViSWFxR0RwNUdwWDNlYTVyZEgzUDNqbHdyRUoyeGZlZW5IeW5pZDJ3cE1qOFdoUUtUT0Q2NVZiUjA0Mk5qSjJkL0x6NWFiOUY2SVJXemRlY2lOY3Z4M2o4Y0tKU1B6dXk5WEdqWnRiTzMvMWFIYThEa3RhRjBqZ0RFMytHN3BBWG50MW4wOTk0bmtTblVReVZBdWcrTUVmK3NqYjdyLy8zRHU5YTB6UWlHcUdoajdkcTFHSVhVL25QTkVHVEpZUlFzVDFBZWRhK3RDeFhCMnlxbXZhMWhORFR2UkMxMFdDaTdqZTA2eDY2bFdmakd6VGFna1hBaUdxYWxTV2RmL1RoOGZOYnd5RjBheEpkOWFJK3BBeXpuLzE4emVZTFYxaWM1eHhWUGtESDMza2c3dWJ4ZS9yTzFlRm9Fd25JN1kyeDZ6cUdZYU1JcXRvbW5vQTl2S0J0QWhIeHllNC9waWRxUkJEaGlzTTczdnJlYlkzU3o3NTdEN0xwc2RJd25YRUpsOHFpMGwySlpyQXdSQWlXVFJFMFlSQVN0cE9tWGptb1R3OENOWTc2YldjMEF3RHZnVGxaSCtKWDV2S0RlbSszZ2VhVlhmLzNzYmtqOGRsZFg3WHhpbGRKM1dJU2NWb2hTb1g3am1YTVJwbDVLV1lHRlFJVU9XWnJub2oxMjgzSmxGbk5CdkRIM3JtOG9QWFAxNnZmdHk1L3BSMThHVW55VGN1VVBqd28vZnlzei8xNnl3WHRkR1VjMWNCazhlZnZPL0NqLzdZeDM3b2dmdDMzdDIwTXhFVDBkQVNKWG5vaE01REZGUnlmQlN5YklQZUJicXV3WWVVNVYydlppd1dDOXJHMGZjOWJkL2lYVWdGc2twVTlyNTFaekNQU0F4UmZRalNOTzZGMndlci8zeSs2Rjg5QXdnNkViUXNySG9mRVFOdEg2VnV2U0VKdUNwZzhzeWplL2QrNUQwUC9Ha3I4cmF1YzJSWnh0N09Ma1ZSRXFKaGIyL3YxRDZ1S0VxS29zQ0lzRnF0YUpvWm96SmlUQ3I0azBXUFlMbDBhY3c5ejJ6aGZPVFd0UVl4bWxxb0FXd1RZekEyVVVuTU1JK2s5ZThkQjVYQnpUUlJiOWJtMmxGUGpiVE5vRmN4Um1pWEhiZXVudEMxRHBGa0s1VGwyYURwOTFuZnRydjE4YXljenhjY3IzcXFYR1E2S1NoeWd3S3RDNno2bEVXWGVSVWpJakVpVjk5d0hDOUJqQ1hQTXpTR3Fzckt5K090N1M5ZVA3aDFTKzd3MmRidDFqYzJVUGp5aTljWmpVdEpCZ0pxUlNRSGltLzUxbWNldk8vS3VXOXlzVE5ZSlhoSDF6bUk2YmczUlVZMkhxVmVPNllUSWZyMTA5WFR0ejF0M2VON1QzRFF0VEhSU1hxbFczbm1SdzFkM1NmRzZ6ck1JMkVJRW9MNnBuRS90My9ZZk9uczdDRkNNRWIwSTk5OERvRHZlditWZGRzdm1tYVBVb1R5Ylk5ZGV1ZjJ4dmdkSWFhV2FEcVpzREhkSnFwbE90MWhhM3VYYWp4T2tkRlJBWXNQa2RuaUpDSG1rdU5DWkxIeWlLUVlBOTIxdlBYOWUvekJIMzZjRDN6YkF4QXl1amJndWg3bjNDQWpEamlYbEk5ckRVd0llcHBWRXIzaVEzckZNQVFCeFRTM3JTTWJqQUY4NVBpZ29XMDl4aHJ5SXFlb0NvcHhTVG10S01jbFdRR3oyUExwZzVYOHcrc25jclB1cWRiMEZvRlJibkI5VDFmM2FCUHdLOGZKTEhEN0pPQjhURkVXWVFoa2RQMGpsNnZwanp4NCtjcTU0UlF1emdDSjM5Z3p5SWMrK2xZKy9vdGZRSWNCMXhqSzBiZ3MzL0d1eDc1NWU2TzZwMWtlRUtRalJvTVJTMmFFcUdiWTNhY2RmdTlhZk5lZ2VMd1gyaWF3V2k1bzZtTjg1d2hkSUxhQlVIdUNVNXFUam1iZUVWeEMzQmtrczhOYVZKMlBuejQ0YW41U1ZSZG5Cdk1vSXZyUWxSMnUzNGJ2K1pZcmZQSUx0Nlh1N2hqV0tWUVhkNmRiVHo1MDRUdXFxdHp1K3BsbVdTWTcyM3NKbjRpUnlYU0NpTVhhbktLVTB4WHRiTDZnNzJxeVN2QkJtYzFiZXVmWm5KUjBoYko3cFdDVWp5ajJkdm1PNzcrSGN4ZTIrTVdmZVo3VktuRWpSZTRZMGxrYjBzbGlCR1BqUUUweFNFanpSbFlZeEthVFJOUC9JUTdSY1JLVWR1bHhUU0F2ayt2aWVGd3htaGJZM0tZQmZsZ1ozenFvY1NlZUt6dFRuamkva1RUMklsU1ZSZFV5cngyck9yQ3htZU9EY3ZzazBIUksxSWp6aml6TDhTRmdyQmhwdTIrOU10NysvdGZrOWY5S1ZidmhQVjFINytrM2JJSGN2SDRrSXNhSXBNaXZHTFY0NUxGN3o3LzFuUTk4SUdocmxLQXhHTW1NUld4QWZVL3dpZzhCSHhxNmZ1aVJRNFAzamhnelF0Y2x0NUt1d2ZlUnZsZGlIeEd2ZEl1ZVp0NmlMcVorZTgxb0hWb05GOExoOGF6NThhT1Q1c1ZoTUQ5ZDY2WlpOVkhmczB5NGRWUVRveHFGVElRU3BYam5FeGVmdVh4eDg3M2VxemdmWkhPNlFWR01nSUN4bHFMSUVXUElyTVhZL0xUVjd2dCtPRDJVemlkcWZXWXRJU3JWZWN0MGN3cm1IcUt6OU0wTjduOWd4SWMrOGlDZi84eHRidDZjbzBQeTFkbXc5WFVrYlZRbHl4T0NibUpDMktNR3NzS0FqNUJiTkVhQ1QxRVJyZ3RVbzR6Tk9FYWpNaDRYVk9NY2t4czBwcUVmSm14dGpiaTNqWHpIVy9hNHZGY2xXVENRbWVTb1A2MXl2STJZa1dGVlIyNGRoNkVkdHNreWFaQVJGRVdHUkpmNXR0MFJrYkdxTnJ6Wk11Z2JzMEMrOS9lL2g3LzdkejZGTVVaVTFZcElJVUwydm05NjdNbnpGN1llNjN3dlltMEM3N3hIQmhGVWpBWE9OWVMrUWJzdXRVYSt4c2FNdmwzUXpHZTB5NTZ1RHJnMkZZZXE0cnBBcytqcEd6YzhQZGRldVVvRURScmpzbkVmZi8zYTdCZUh3bGpQSFdGVTVmSGMzcGlYWGowR0lIL3kvTUFZSFBoaVNqa2RGNU4zUFhIeE96TEQrZGx5UWZDQjhYaEtubG1jUzdydHpGclFTQXlCckxDSVpQUjlTNHd0NDFHRkVGblZDeERJak1VWncyalRvdEVTVFViZm5kQ3VUcWhyei9idWlHZmVkUS81c3dXdnYzcElzK2lScy9qSU1IeG9IQXk1YzBQTUJIRUJHdzFpQjgzNm9KUmtvTmhZZ2JLMFdGc2xWV0p1eUhNN2lLN1NxVk5XT2VmT2IvRE8zU21QbjV2UXUwZ3hiTVo2VFdtTDQxR0dsbWt0ZHVNNFVIZkpaZCthdEZLcm14NGpoanpQcUYyLy84cko3ZWVNbURLaUpXZ3p2TGZoRzdiRmlsR1pUQ3FwNjg0QW1hcm11M3ZUemUvODJMdS8wK2JaVkgyZExOZERQNWdTcE0yZmFFZGxGSXFNUlRjbnVBWFdON1M5U1lLbnVzTTNFZDhPS2tFZkNWMmdXWFQwZGY4bVZSNHhFbFRWQjZWejRZMkR3L3AvOFQ2ZXJGbTZ3MU1zNXJsbFBDNU92L1l2dkh4RTU0S29Za1VvVk1rZXVYL3J5dVVMazNlSDJGdGpSS3V5WWpRYXBlMVA4SWd4S0lOMGx6UmtaOVl5YXhvME92SzhZTG5xOGM0UERGNGhsakFhRzBMbzhOMVZtbVZMdDBxdDRtb1Y4QUV1M2I5SlVWbXV2MzVDdldqVGZESDhFeW1UODRra1VxUEJwQXg2a3dpUUpsR3l5QWJ4bEVSRE52Z0tCNituOGx4ckRjWkFMaWt3S1BqSTVlMEpqM2lsYVQwYUlPWXA2VGNWVmFJTEJ4KzVkZXk1TmRQVEU4Nkh0S2JPczBTbGFidWVXOGNIZTFWMC8rcmpPK2NmUFhEZGYzbHJkclRpakpmd04xeUIvT3QvL252NWliL3phL1M5UzB0RWtVSlZ6YmQ5OUptM1BQYlVnKy9KSk5pdWIrbTZaZHF1ckowemhuUlphM0pDQUhVZVh5OXhiVS9kS0NjTFpkbEM2QlhmUlZ5dm1KaEF3cmIycVQySVo2V3J5VTBucXJZbnMrWnYzcnkxK1BTWGc0SlpablUrYi9YU3hlbnAxOTkyUVl4SlNrZFZjbXZONkh1KytaSHZHWS9LQjRNUGFyTmN0cmRMaW1IOTNIWTFrL0gwdEcxQ3dRL0xoTVZpbVZxWHZxZnZCMG9KRUxGSXFkak1FTDBuT0VmZmFZckhEV0hnamlXeTVlWldSWmJ0Y3ZQYW5QbXNKdmc2a1M3WHhnNEQxZDByT0N2a2tsQ1NiTWhoVnl1SUNsbVJnS2dNQ0RZbGU2a3F4b0Fha0dINXFoSE9pVkJwT2hXY1N3QnRWaVlHY2UrVW9oQmNORnc5akt5M3hUR213czBISXp3ZkluWGZVWGVMc1pIdytFWldqdXhvK2pPM1prZTNSQ1FiM0IvRE4rb0pJaUdrTER4VnpZSHlmUjk0L01rc2srMStWV3ZvdlJCQ3N2ZlhpRG9IQVl5VXRHMmdiV1lzajI2eldIU3NWdEExZ2FPRjB2bzdTWjhhRk5mRm9lVktvT0JhMngyVDVGVlJwRzdjTDkrNHRmakpNMnpkSHZEV21yaTdWZW5Kck9XNUZ3N09mdm1DbmtZRDJHY2VPWGYvcGZOYjN5VFl3aGpCb2xSVmhqWFpNQnM1c3J4STd1bHRuN0FHSDBrTml5REcwcnFldGgyc1JpTmtOaWNVSWNsaUFlTVRhU3E1L2FSWkFpQ3owSGNSWXcyN0Y2ZGtwZUg0OW9yRlVVTWNObFRKT1dVUWxjV1VvVmprQmxPc2ZScUZnQkxOMEhhdHlZd3VSVGlrK0dzWmJGUlRqVzRNVzdETUNzVWtJN05DQ0lQT0pBcXU5OXc4amh6TVErTDREeWRSMC9tMTZBUURMTHVHWGdNVExFYXpEZGY3cmVIOS9jYmVZaTBXN1Zwdm5nRTJ6OHowa2NmdmZ5SjI5VGo2dVJnVHlLMUJnZ2VKckc3ZnhIVTk0OTNMckJhSHJFNzJPWmwxMUxYU0Q2ZUY2d0t1ajRSQmFJUVl1dHF6bW5jSk1OUjR1ajlNa1FkQll1VDJmTm4vNUh6UjNlQU9sZDBCTVViVld3ZS9WU0lxZ2tSVkkwTTI0T01QN2oyVUdiblh1dzdWU01RZ1dGendlTjhqQ0Q0RSt0NFJOWkpsR2RZbWVXMVpqa0JiWEcveEVRcWIrQjgyTDFEVEpZSnhTRTlmTkduT0VSQnJDSDFJV25XWFZyb0NqS2NseGdyTDQ0YlZTY0orMGk2NklpOHNHdE5UUGdwRUsvUkFNYlJTbUVIdkhnemVwL2ZSRDBoN0RKRWlSRVlLbzZCTVhLUVBrYTFSUVo3SnNPVFF3YTBGbWs1NWZkL1R1VWlXRFlJdGtpVnFpQkhSeENwZXRUVVNZYkl4b2NqeXZxL1hiaEg2amNuRitvLyt5aDlHeVRrOFdHQ01uQXFLUHZUaHB5NWQyTnQ4ZEZLSXdRcXVkNmdLMWdyN0x4enoyWjk0aldBOTl6N2xtTjdUVVRjdHkrT0lqeVJYd2FDb2owaElqL1lZUWF6U3Q1NXUxV0ZQSTlBR3pVUVNSYmkyOS8vYjY5ZG52OHdkVGJrRFFsbGtPcDNrSE0rNlU3T0Vzd2NJcUZHd0lyYTZjcy91STVtVlRSK1NzalpxUkZXSW9WdXZrd2plRDdRUVExRVVaRFpSZ2treEkya0Q1eFUxUWxHVUdDbm9tdzdmcFRXMDh4QUNlSitLUlFiMHpJZUl6UzFXazdJeXM0YU5hY1c0eXBtZE5NeVBhMXgvVERpM3djYldoS3pJRUp1U29YS1QvTFkwcGxaT1RxVmVnamRDSGdMRnNtY2p0K1F1a0RVcExpNkxpbGhoUENrU3lDNWdNakFoZ1pkUmxlc25nVlUvSkFFUG1GQ0l3MW81UnF5MXpPb1Z6cmNVeHVoa05KVm81R2J0dXRzRGJ2bU55Y1hhM0J6eEgvOUhQOG5RdzY4TEpIdm5leDUrb0RMaG5rd1Vja3NJRmo5dm1lK3YrTnhQWE9YbForZUk3Ymo5eW9KekQ0N1llblNVUEdqYlNPampFS09XSU8yd1JvMWR3SGVlMktkWU0xay9oWWUzM3ZuNDJhdlhaei9ldE82UU15cEJraDVKWmNBdnZzSzEzbUNaeWFnWWJVN0dEK2Q1WHZRdURFLzhMclVtd1pQbkk1elAwbitQYStlUzFGcTV6dUZkVERnTWtvaVcxaUFtSThzSzFBLytQRU03STRPVnFaTGFwUFR6dEdsS05KTkExS1JGejhxTXZYTlRxbEhCeWRHU281c3ordGF6c1RPbEdpZVR1V0FoR0hDa0IxR2FMNFJnaEh6bG1GeWRjUzdQR0k4elJCVWZOVmtLWlNrVW9TZ3NNU1FsWVZTd1ZaSW9MdWVCVzNPMzNvMFAydmYwNEJLVFhPd2IxM1BVekZCVlJtVWx1YTEwMmJlL2Nkak05b2Z0MVpweThvMVZJQysrY0l2cHRCUlZSUFZVVmxzKy9OREZCM2YzcGx0aU9qMTVvNVpidjNIRTZ0b3hyNzI4ejdYck0xUVV3UkpjNVByblRyajE4b0xkeHpZWW55dnhhVTlMTnZUU0VrRjlwRms1VnZNVzUzMUtkR0l3ZjFNbHd1R3R3OVhmdUxtL2ZING9qRlBFWEVSaTAzckdvL3hOWC90ZitsTWY1Uy8rMVo4N0s2YzE0eW92Z0ltcUVJSlRqU0txR1dJc0lYUVlXMkZNbWgyNnRxTW9pN1FPZFpHMlRkMUUyM2hVSTBpQnhwVHlKQVNxUEFkdFdTdFJrODVqY0daTTN3UERhSkU4ZTVIVDVYVTZ4WlRKdEdTeVViS1lOUndkTEtnWERidm5ONWxzalRHa0U4Q0lFSndrUGtDTUZBY040LzBWbThhUTJkUXVtanpscS9ob3FOdVdNdk9VUlVhUm1mUjFJQVE4U3M2Tm81N1pNdEFuSjVpa3REZkQxeWVRNTViRFprN3RHc2JHc2puYUpDSzNGcTc1NVQ3NG1qZEh1SDNqNENCWmJ2aTdmL2ZUdlBMUzRacURsZ0haMWxZMTJUdS8vWEFXeS9MYUoyNXk3ZFA3aEpNVit3Y3p2dlR5Q1dJY0c1UFVObWxVOHBIRk5aNWJuemxpZW5sQ2ZzK1lJRUxmeC9SaG1hUXpuKzJ2T054Zm9FYW9UT0k4dVJnVklTenEvcWV2M1p6L3lwc3dqK1JleTZqS1dkVTloOGZObTcvK3pIQitaOExCU2IwK1JjemxpOXRWVldTalJGa3h4TkJqckJCalFFUEEreWE1Ry9wQUNHSFFuRVM4YzRsNmJqS0NLcG5OaUFRVThBR2Fwa1pINEIza1ZScCtvdzRLUVN2WTNCRGJnTzhEcmc5MG5VLzYrYWpFdGRQbjhCVEtNOHVGaTV0c2JGVWM3UytaM1ZoUUx6dTJ6azB4T3hPTUdIcHJLSDFrdEwraXZMV2l5QTIxVmZZUE94WjlvRTllUVdpTUhDOVdiSThLM3Z2WVpjYmpDU3I1TUpqM3JEckg2N2NibXNhak1peERZdHBhQlRTWjFhRXMyaVdxa1hFeElzK3JXSHYzeVJ2TGt5L3hGYkxXLy8rcVFQN3YvNjgvUlZZS3YvSHhGL2lmLzRkZllibHNULytmS3J6ODBvRzRQdGpCREM0SGl2ZC95ME1YZC9PTmgyLzgvQUhYZnVPMnF1K2thMWZzbjh3UUV4aVZhZDBVWWlCMHlpaFBFV1ZkNXptNVdsUE9ldkp6SStKR2pqRkMzMFdXaTU2VGt4cm5QQ2JMQnM0VkdqVks1L1c1NjdlVy8xUFQrc09Cak5nQ1RpR21SL2xYdmo3MXBSdW52cnJyQXRuZXFNYlR5Y2JZbU9GemxiVmxpSUFFbktzcGk4a0FUcWFXbzFrMUdKc2tKTVpZakMzU3orTUtIeFRWREdNVVYyY3Nac3BtbHF4NWROait1RWp5MndXY1Z6cVhPRTYrZDBra05iakdtOEZGTVE2dDJNYWtaRG91bVhVbkxBNDdUcGJIZE11VzdmT2JYQ295OHBPYTQ1c0w1bTFQMHp0YTU0bDRvcVp0Vm1ZTTQ2cWtkWUdUcG1IMGVzN2U1cGlONllRc241QnB4aHUzVHpoWjlxQnBDUkVHUVVyZkJXeG0wQmc0NlpZcys1WU1RNVdQUU96eHdpMS9jZEUzKzl6eEZZdS9wd3ZrTC96bEgrYlc5V1ArMS8vcFY3aDk2eVFSK0g3ZnUvbUZuLzJzN08vUHVIM2pHT2ZDT3N0Y0FJS1BFa05jeHhkVXd5cTl1bi83M2l1ODBsMDVldjJBamJISThXSEw5VnZIK09qWkhCdjZHR2o3bUJxSUdHbDhaRFF1Y0NvRTljamMwUzA4eGJrUjJibVNlZU00T1c1b3UzWFlwaEpkTWpnTHFqY1BUNXEvdG4rNGVwRTdEaVVPaUprMTZrUGt5MnczNzJ6ZW1wNjZkWEtXU0RjcVREbXFpaEVhME9qRjJDS1pLc1RCQ21zSTNBblJnRWFLTEdmUk5lQVZWVE9rNEZwa2FMdlREVzVvKzBCVmplbm1EYzEwb013TWc0Y09xelJqVTc2Z2M0R3U2L0Z0bjNoVkpxMVV4VnFNVVd4STY5c1FGV01OMDRsaDB3bE5LS2dQSE0zeFBsOWFkalJMUjlNRk1odW9xaFRGWUkya2JlS2c5Zk0ra3VlR1plKzRkcktrOTVGRjA0T2NVTmljL1pPZTNrVkNTTEpnTVVMd2NjQkFMSzN2dWQyY29Cb1oyWklpRzZrblBydmZ6ajg5Rk1kdkNkNzVQVmtnRzVzajJxWW5MMDdaK3ZKelAvMXBFV1BRcUtLcTV0VGI3TGZhNEdRRDcyWmpkMmRuKzRuTlJ6NFFiL1c3bFkwczZvYnJCMGQ0QXRaRWdpVG1hVzZVcEdsS2pvRks4b1hLTWtHakliaElmWDFGdHVocEM1aWQxQWt0SHA2NlBrYkVHcmRxL2Q5NTZlckp6NGFvcXpPWVJ6Q0RwOVh1VnNYUnJQMkszM1B4WmxzYUFTZ0ttK2RaVmtSdjE4NXJnMTJvQWhreDlNVFlFUlZtc3dXanlRWlpsdUY5Uklua1JVRmVqUEYraGNrcWd1K3dVZWxkUktTajhVS3hxN2lRVGdzR2FheXN0ZVNxQkIvb216NUZWN3NBQW5tZVliUGtzaGlqUmFOU1JNVmtCaU5LN0h0S2E1bVVCUXVYY1czbHFGdkZ4cFJLNUh1REdSSjY4MGxTYldZSTR6eVpReXpGTTI4ZEY3WUVGeU1XNFhDMXdNZUEwWXhrZnhYSmgwSGVoWWlnSFBZejJ0Z3pGc3ZXYUlPaUtBOXZ0UE8vZWRLc3JwOHBrUEI3K2dRWmowdis3WC90ditBajMvVjJtYzlxc2RaSWpDcmVSeXVpQnNHUUJuQ2JiUCt4bXZRN2EyK29YRlVueHRqeEQzM2JoNy9qa2EzTmozV3JsYmgyeFN2WGJ6R3JGNVNGZ0NRTXhOcTBtaldEVTBjMFN0Y0hyQjNzYkRURnM0V282TEpud3hxV1ByRU1sZlRrVkVOMExuN3k2czNGVC9nUTUyZTNWaUxFODN0am5Zd0xiaDh1Zjl2dnUyMjdVMHVnTy8vTng5NkhVT1lsRVlOVmk1SVFzMFFNTkFQajFySnNPcHFtVDF1bXpPQjhlaUlYWlVuYnJzaXluTmE1Qk94aENkRmpZOGJ5YU1WNHU4Ujc2RDE0cnppdk9KL1NydUlkYTlSRWErRU80bzAxaUtZOEZLY1JHOU9hVnpTU2hZQnhrWFBqRVJjZlBjZnRXYzFydDQ1WU5KSGVXU1kya3BsSVUzdktTckJGd2JTc21FN0diRy8wck5xZW9zZ29ja3VPb2ZPZThRaktMTktJSFZ4VEJ0WkNnR1dvV1lRbUZacXB0TElqYmRUL3lvMzY1Sk5EYUUvSFY0aHQrejFUSUpOcGxXdzlCYkxNeXMvL3pHZGxiUzQ5QUg0NWtLSGtvSmxxS296MVd0UVl5VWVqWXBRVitkamhxL2MvOXRSajc3bi95citjK2JDM2YzTEVyei83T2NaNXlhZzA5SDBjTmpOcFRkaEhLRFRwTi9yV1VCVEpFZjNVb05rSWVXNXhmWUFZT0NjWlZvUWo5VVNpQnBYWDN0aGYvbmY3Ui9YcncxUHE5TU5RUmJjM0s5M2VySGo1NnZGdisvMEhOYi9GVWFCdW5ldDcxMDlIWTVCU2UrY2xzd0ZWbTNCeWt5SU5GRWRkZTA1bUM3YTJ0dEpKZ0NHcVVoUUZZa3BVSFNFT0J0TVkycnFoTE1Zc2JpZ1VudUFodVBSK0JEZUVrZlllNTlKNlY0Y29EOVZrS3VkVmg0OWpFRXA1ZytsOTRsZU5NbWdkT2VEYkRwTjd6bFZRbnFzNFhuYURBWGFhRy92Qk9WNVZXZFFOM2hoMkp5UHUzOW1tQ1QwOUFTdkNxTWhaK0paeEdWZzJpV29TVk1uempLQTk4MzRGS0lYSm1PWmpRY3pKUWJ2NGU0M3JUN2pqYS94N3MwQTJ0MGJNWncxVlZkQjJiazBGc0RIR2ZMMnFCY28xTTNmdjNOYjR5b043Mi9mZHYzdit3cVh0UytjdVRNOWRlV2p2NHZtTGt3dk1GdFBteGFNeUxpL2ZOMm16QjRnZHIxMS9qWC80aFMreFBaN3k5UDNuMmRrWXBhMVFUTWZ6NlljZkxlUEtRZ2JMbFdOODZ0RTNXRkpKSk1aRW9kZ21NVmtQb0w1eDB2ekUxUnZ6THcxdi91bWVmVzEzR3p6VXE5L1pmZHphNG93dDZLbCtOYWlLTjJMWjJ0am04R2dmd1E2aG9TRXhhY1dpYXJDMjRYaDJ5R1E2Qlkza3VSMkFNeUV2U3BwbWpzWkE1ejBpRnVjZEloMmxHVE8vVlpOdEdseWZwTVZkNytuNk1FVEx4UUVYa2FHbFhEczBCdkNEeUR0S3dvRjhTUFNXTEIzejQ4SFJwRzU3TkNwbFpyaXdXZEY3ejZycnlMS0szcmxURTcwdUJHZ2JEcjNEaE1qbXhuZ0FkR0ZjNVN4V0xlTktxY3FJYjRUY0dJeFJacm9rcUdlRVlTc2ZhMVZXMG9uL3hGRzMrdnh3ZXJTOE9ZM3E5eFpRdUp4MWFURHVnOFNnUmxHRG5yb0dqb0RxYmU5OGNPZERIMzNtN1JjdmJsMTU2TEVMajErK2IrZkp6ZTN5ZkZXWmlkaVl4YWJQVnA5NTNYYlA3WnVtdmlRck44YTNoN3gwL1NXZWZlazV5Z3dPVnd0KzVibUdSeTV0OGNpbFhkQ00zRUNXQ1prSU1WZXlBb3JNa3B1a05wUVVDcGdrdFFyV0pnT0V2dmU2alNYMGV2enFJcjdHSGFYYXFmMmxLbUtNeUJzMzU5bzZ4Mlk1WWQ1OVpRZnlvL2tTRVRsclRhT2tJQnFKQ3FQUlNMYTJkbGtzanRaZUk4UW93N296WXNUUzFNY3M1MXRNTjdZVFNCaDFrR1ZraU9RWWE0bk9vOUZEaE1WeVJWbE9hRHVQUVhBQm1wV25yWk92Y0l3REdURkxzd2FxcDJJb1ZOR1FvckFaTUFoVkJ1MTlwUFVSQ1pGeG5yWjgzZ1V5YTVLdTNSaEdSWUVMZ1hGWjRIM0FhOFFGandtR1JlYzRXUFE4WTRUeHhvUVFIVmxteUsybEZjZTRpblErUTZPd2FHdG1ycVpBMk1wTEtxbWs5N28vay9hbmw2NDk0YzFKVkcvU28vK2VLSkNOblRIOXl1RmNrQkRpYVY0SGd3N2JHSm44Mi8vblAvUk4zL3pCSi8vQXc0OWQvSlpxWkRZVUowUzFQblJFaWJUWEZpeCs2WVoyejUrZzA4dUViRWZiK2V2eS9JdWY0ZFg5UTVZKzZXT3FYR21kNDNOWGp6aGV0VHh5WVlkekd4T3kzTEpjS2F0V3FieGpjNm9KQzlCa2dMWnFrb05KV1ZvR2gzSnNaaVQ2eUxuYzNQdk5sM2QvOVB5NHlqNTViZi9uSWE1dFFGT0FjMVR2Zll5bExmVDhaUE8zTFpBc3k0aDN6UDhVMExydHV4QzBVNDM0RUhROG5vcjNnYnBlZ1FRUWgwYVgyaDVOZ05uaDhURjVNY0ZtYVlNUkJ2RlFuby9wKzJTZzBqdEhESUcyNzFuVWpySWMwL2tlSFVQZnA3a2pwZDBtVGZvYVpnOCtyVlpsYlRFVlU1SElBQ3pHZUlkNHVGUkw5RUhQK1NDVElrT3N3UThuVCs4ODFpUWpiR01OaFVBV2t3UlhCV1oxei9HcTQ5TE9pRTNnK3FMajNyMlN6WUVMbG1lZVpSdXAyOGl5cjhrVmNtUFltVzRUZXFOTC9DZXV0eWVmVlZWL0J2ZjRpaXYyZjY0TEpCdklOajZ1VjdTbnhURUNwcU5Sc2ZtWC9zTS8rbDBmKzc1My82dGIyK09IbllzRTc0Y1BxRmNSZzd2YXl2eG5EM0EzUmVMb2ZvSXRPTHA5aStPVEE2SXBzRFpIUXlEUDAzclREcDN6R3djMUo0dU9SeTl0YzgvT0ZyM0xCbEtjc0dvOGt5RUxvMjQ2VmsweWZUTUNaWkhqTmRMM0VMeVM1Wmp0bktmZmVuN3k1d3BqcWs5Y08vaTdMcnJUREw2VWd4bklqUDF0N1MrSHpTcXJ1anZWSWdGNmNMeG9ldWRxQVlKem1NSlNWU1BhcnFQdi9PQkVtaWdySVNTWVpiRThaanJaWkc5dkwrV1lpSUJFOGp3blVoQkp3M3ZpWHdsMTYrbGRUMTRJYmQ5QklhZVIwT3ZKUTlleTRXRTZqOE15UVJtTUdmUk5na01BRlNLTkVZNDBSRUx3MHp6UGZZamtSU0VXYU5zK3lZSWxVZVVuVlltMUJqWFFCOWdjWjFSRlJtbVU0MlZObnNPVjdSR2IweEhqMG5OMHN1VFd2S2RYaHhWaG1vK0p6bERraFo0ZmJjNWYyajlvZVhOY3hGYzBqdnZuMHRWa2QydEswL1ZZSzdndVNJeS9wVGcycWxHeCtYLzZEMzc0WTkvL0ErLy9jK094ZWJEck94QkRiak14UmlXWUtOM3JyU3ord1NGYUZ6ZzdvUS9LclJ0WHVYYnpSZXJ1Qk5jN3RqZW1HR05UVUNiSklSd2lSWlpvSWZ1TG1sbmRzVDBwMkJ4bllKTkdJYzhpem5tYUx1QTg1Rm42Nk5zK0lobVVPWlNGV1h0SGFaN0o1dDY0ZkdwYWx2VzFSZk5TVEN1cDlUeWlVVlU3NzNEeEs4OGkxMitmckF2bDFFVXhoREQ2d05zZmVQLzJ4dmp4dGxzaEp0bENsMldPZDQ2MmE1Sm9LWVlVeGdPSVJKcmVNWjVzSWNZT1BLcVVEQlZWNkhwUDNYcWFOaEtDSlVaaFVYZEloQXlESXdtZ2VqZHNybHpBZVk5M2Z0Q09CRUlRUXBCQk5aZ1dHc3BwRUk4YUE5WVFRUStXWHYvZXZJNC9hMExjc1lTOUNHUjVKcmF3Q2UyWFpKVTZIVlZNcXBMRnF1ZWtkZHk3TitYOHhwZ2dVRmloR0F5d0YzWFA3WG5Mckc0NHFWc0NTbUVLZGtZYmhBQlp6Q1N6MmZHUzd1T3J2ajArU3hMOTU3NUEvdVFQZml0Rm52SENhN2VZVGtaNEh5V2NLUTRSeHNER2RHTzArZS8rK3ovMCsvN0FEMzdneitXRnZ4eER3SWdScFJmblZqU0hDOW9qUi8vcEJxa3puQlEwVGN1Tk4xN2tqUnN2NGR3Uzd6eE4yMU1ZT0wrM3c0Vno1NGpSNDRLamQ0bDJVVldHb0RDckhZMXIyWmhrN0c1V2pITEI5WkY1SFlnRCtKMW5RcEVMdlNhNlNXN1g5R293UmtSUXJRcVpiaGJGVzZmRnBIMWpzWG8rYXZSM2lrUzFqLzRmSjBkdmplZVV6c2ZzSFkvZisvREZ2ZW03Rkt5cWtTeFoycERaSE8rVEhkR2FTS2lhREtlNzNyRmE5a3pHR3drRjl4SG5JeUVFTkJxNnZtZlZEdHVrNFFTYUx6dUlGaE1FTHdFWFV6UTFJZUtkSi9SRGtRUWhHY1VNcVR5RFNGMVNVV0NOaEtqNld0dkhuemhaK2YvbWNPRi85cWdObjIrOVBsOVlPelhvaGQ2N0FoTHVaRTNTZWh3dVdyQ0c4eHNUem05VjVNWlFadWFVRW0rTllJMFpJdThDeTZiR21JQkV5OWh1VU9RbE11eW9vbXAwMGYvcXNWdmRQQ014OFA5Y0Y4ak81b2p2L3RhMzhzYk5FNjdmT2lHRUtEN0U5UXEzSkNVOWJWU2pZdlBmKzcvODBQZisvaC80cGo5cjdQSmVGNWFxQmxFTmRHNkpjdzF1NVpuL2VvczlFWnBXV2MwWHZQelM1M2o5NWl2MHZoMElkVG9rSjBIbk9qWTN4dXh1NzdKYzFUanZ3YVFOVmdpcGRXcWlaMzllVSthV3JYRkpEQ1E3MGpoUXdBY0hEMUNxVVU1VjVZbHlNZUFsR2xTS29tSmpPaGx0bC9renBkalo5V1h6cGFEeGJEclU3MWdnMWdpRGUrZmF3VDNibXBRWEhyeDM3d1BqTXF1Y0R5SkV2R3RSaGFvYUVkWFM5dDN3QkljWWs5dklZclVpeEl5aXJPaDdSKzhWMXdkQ1RJelhya3UycUtERFRlcVlyMXFDQXh2TjhQNEVtcWFqYnpwQzc0bUIwNEU4cVFuQldCMThzMENFdHV2MXAvWlArdi8wY09GL3V1N2lLMUZaQUcwZDljWnhIei9WOXZHNmllSGVxckI3MDdKS2V6aFJ1dDZ4YkhzbXBXVjNPbUxaZENtR09rdU9KMlZ1eVlkY2twM0ppQ3JMa25LeUt5bnpDVDRFNkNJOVFVZFpVUm5EbDI3MDh5K2VvWmQ4eFRua24zbUJmT1M5VDdDek9XYXhhbm5wNnI1Y3YzVWl5N296M2djN2VCV1ZJaklHTm5iM05uZi80bC8rNFgveHU3NzMzVDlXVmx5T1lha2lRV0xzOFc1RkRJNWlQSUpaU2ZkRmp4R0w4NTZycjM2T0YxNTVEaGZTazdMcEJ0K2xQSDM3UlpsaHM1ek1abHpjMlVOMTBFOUkyZ0toU1FRVmdmMlRobVhiVTFxREVaTTBJY1BiNm4yU2U1WWpReldxTU1iZ25NZmFqR1FVWGRGNXIyMWJqekxNZ3lIa3o5NXVWcStrUnVRclA4SE9YbFdSRVVJVVNjclVITWlucGJseWNXL3pRenRiMVZSOW04eDBqRVV4aEFoNVhwSGxGYjBMTkoxTDlHOFZWQ09ISjB2eWJJUXhGdWZTU1pKbWxYUUNkSzZuNjMwQ0tHTkUxYk9zRzlyYUkzM2E3RG5YMGRSMXlnUlJjK3JVYUF6WW9SMDFZbEJ2bG4yZi9hMzlrLzYvV0hUK1JWWFdJYVNuZkxTZzJpeWlQdTlWWHBrV2RtZFUySHR5YTdQT0IyWjFqMWpENXFSa21tZW9zUnczTGROeGlaV0U2YVFGUWFLNmpLcWNHL3VldXNuVEtybnZNWUNUU0dtTFBLcStmdE12dmh3ay9PZm5CSG53bmgzK203LzhyL0JMdi9FU2JldmwydjZKSEJ3dlpMSHFyS3BtT29TL2lEQlJaWE5uYjJQNzMvNzNmdUFQZnVmM3ZQTlBqNmJsSlEwclFxekY5U3VpN3dqT0pSditZR2srSDlFVHdlU0dHNis5d0plZSt3SjE1MDhacWV0Y0NrbXNPbmEyZDJqYW5sc0grNVJXbUk3S3BJY1dReVFtaHFvSU5rdCtXTGRQZW82V0xhS1JVWjVSalRMeXdsSVdoaUxQeVl0a3E1UGJrc2w0bXl6UFFBSUhSeXR1SHkxbDFYcFdIZDJzRGI5MHUxMDlONXdnLzhnQ3lUUEJCUjAwNmFsSXptMVh1OVBTZm5CYzJkMVJhUWpCZ0F6S3ZaaEVUVmxXWW0xTzJ6bVdUVVBuVXR5emN6MjNEK2NVMllqTVp2Z3dzSDZERytBZFMrOTZWazFEMjZkTWs2aVJ0dTJZSFRkMHE0QU5GbEZ6ZWhvYlNkb0xKQW1pOEJaZlp5ZkxPdjcxZzJYMzEyclhYeHVLWXNFZEZlVlpIaFJOMUZ2TFBqeWJHOG5hM2o4d3EvdHlPaTU0K09JMjkxM1lUS0l6TEZWVnBJSmViOGcwVWQvejNOSTZ6OVhySG8wWmJlenhNWkJqYVZFQ0twWEo2a1hzZnJWVE56dlRZb1YvNWdYeWwvNk5QOHg4MmZERmwyOHdHUlY4NmVWYjhzTFZXK3RaSXhzeXlVdGdERXlCNlZ1ZXZPL1N2L01YL3ZBZi9zN3Zmc2Vmc0VXMnF6aUNYeEI4TTJScUNFRk5Fdi9NRmYrS0pUTUZSN2V2OGZGZi9rVU81c3UwenRUazZwSDI3Y2xMdHNnenNnenFWUU5LY21Sdk9uSnJxUEtNM2tYNkVBaWFRTEcxNGRtaWpSeXVPaktyWE5pYlVCWEo3TXlZOUNHTnFpazJ5Mm03anVCN1ZuWER5YnpCUjlYR20zaDk3bjc2eGZueC8rUTBMSG16RjlOdmUvbHdHajk0T3FndmFxZVBYOWw2My9Hc2VYQnpVaVIrR01NSm9oRlZpdytwV0hLYllXMUIwMFhhTHVFT3pqdU81dzFGWG1Gc01zYUxnOCt1U0NJMHVwQ01yanVYNWd3M3BQTXVUbG9XOHc3ZktqWmtaT1FwNjcwWFFtc0lqU1YwOW1UbHduKzVYOWMvM2tkM3dKMk14UmJvNWM3RFliMnc4SUIya2Zxd0RjLzFQaXd2VGNzbkhqaS9PYnF3TlVGVU1NV3dYUENCNDFWREh3SlZtU2RDWTR3VW1lWHdwT1BhZ1NNUTZLTW53YUlHaTVGV0lwdFpsVGZhLzhJaXRqZS9FczM5bjAyQkNQenc5MytJbDE2N3lhMzlZL25TeXpmbDV1RmNRb2gyWFJpUzhJM3BVQ0RiMy9iaFp4NytQL3pGUC9LakgveldaLzVJWHBhYkVZZnZaN2oybUJBa2VWVUZoNGFVQXh5dVo4aCtnZXNiUHZOckgrZU4yd2UwdmFmdDNPa0tNL2lRRWxtUlFXdWRVR0VVZ2lxOWo2ZjBrWTF4Uldic0tYWGFlYVh1MG9aR0VBNVdqcWJ0cVRKRFZSV01xZ25HRkhSOXo3SmVzRnd1VG5Yb3ZmTzRpQndzNDR2UEhSLy9KOHZRdmNvZGs3aC81QXlTVnQ5bXNFdE5KNGdQc1hqYlErZmVWUlgyeVpObEwxc2JPV1Z1aVdvUXlaUFFLYVJaeVhrd0pxTW9xdlI5TkJGaklJU2VvNU1WUlZHUkQyNG9QZ1Q4a0YwaW1FSHZrYlFmOWNyUk5ZSGcxMm04U3R0NW1zWWxqWDZuRUlTcXpMVWwvSzJiOWVKL0RCcFBnTm1aNHZBZ01SdUFmN25qaWJ0K21hREVJczhXNzc2ODg0R0xHNk56ZVdad1FjbkxiSkRvQ2xHZ3pHektLQXlwVGJSV3VIM1V4ZDZWRGRGblRmQmlCNHVJU2pKYWRSUjVVUmdqbno4S3F5OE14ZkVWSDFKZlV4emt1ejc0TnVhcmhrOS80Vlc2WkxQRGovL2t4K1Uzdi9pcXRKMGZ4R2g2bXFjbklpTlZMVE5ycHQvOXdiZSs3WnMvOHRTSDN2ZlJkNy9yeW1PWG51NTlQNHErd2ZzNW9admorZ2FrU09acnZrdDliaERDQWVRcTNENDQ1QXV2WEdWdEVKdmxLWURTSmVvNTRqeTV0ZFNEVzNxZVdZSW0yb1ROMHRZbGFDcVV5K2MyR1ZVRlIzWEw4V0lKc2FkcDF5d1Q0YlhEaG5uamVPcSt5SVd0MU5hNDZDaHp5M2hVMHRRT043aWtMRm8vdjdhcy85bzhkQzhPSDBnL3pDQmFrTkh4TzFOT0xwM2IxT3Y3czdRaVZvMEtkZTN0NSs3YjN2anVnNlA1eHJNdkhNcmpqMW8yTjNKNjV3bFJDQ0drQjBNTStCQUpIcWFqRVNLRytiTEdXTUUxRGE5Y3ZjcTU3VjAycHVQVEczODlsNGlhWkJYbVUrOW1KYVhmNkZyT2lrbktTeEh5ekZJVVZyZDJLM3dkVjNFZWErNkVBUFdBeTZ5Sm95SmowZlJxNURSZE40UjFnbWhxdjJ4bVRMMHpIYlZsbWFldDJlQ3JoUkdxY1hKeTcvdEFjQUVOU2pCbzEzczVXTG5uWWxtOU1JM0Y5eXhjbjRmQjVkdWlqREM2OEszZG1tdzhVYnJDTkw1N0UwdjZhMW9nNzMzcU1sOThaWi9WSU9sVTFUdC9xU0kvODB1Zk5TS0lxbG9kbm9KRGFNMFlLTi8reEpYTEgzbi9FOS96MXZjLzlQdmYrZUYzUEh6aDBoWFQ5QXRWVm5UZE1SSWJmTC9DdXpreFdzUXAzanRNTlVZN0dNVk5YTk53Y1BNNkwrK2ZFSHprbmtsQlZSYW9hdEl5cXc1UHh5R3dkbERhUlFiZHN3ZzY1UFNsOUZmWW1WWk1KeVc1RWFLZllhV244d0lodFZYTDN2SDVhd2ZjczF4eDc5NG1rNnFrTExOaGtPOW9PcytxMTNocjZYNzJSclA4QjVvYy9FN1ZoQWFqRS9KL1pJRllhekVpNmxXamlIaFUrLzI1ZS9tN0hueHdPWjRjYnI3MDZuVis4OW1iUFBHb1lYdHJBeGxhSmgrU0J0MTduNng3Z3FXd3NMdFowWHZCU001OHNlSzE2OWNvOHpIbmQ3ZkpNa3Z2SEczVHNWbzFyQllkWGUzUmtIUWsyTWdkSThWa0laUlp3VmpMYUpwamN5SFA3RGpMYkhRK25QYjUxaG90YzZzN0c2T2s1d0FtMW1xYnpQVEM4RVR2Qk1yRHByL3h4cno1K0RQajdDbFY4aUdUbXFKSXJHUWkzRHh1ZU8zMlVoOCtQOVZwa2N2ek41Y3Z2YkJjL25jWEo0VTVWNDAvV2pSMTNwRWNYeHlSQ1prZStFNGFsMDhNRW43SEUvdXJYU0RiR3hWRm5yRnNlbjdwMTUrVHRLNE54aHBqb3FvaEdaNVpUWEZodVNhU1liVXhxU1kvK0QwZmVNODczL3JnajF4KzZzSTdIM25YZzVQSjVoNTFYOU9IbFlTd2dsZ1RYRXNNSGFvZHdRZGkzeU94cEhjS3JXSm5DNzcwdWVmNStHOSttaEI3Ymk0Y3M5YngyQjZNUjBWcWRBZnJGOUYxVWxMS243QzVwUStCMHVTSk1qSWtKaW5nZTArV1c4NXRqT25xRHFOSzVpTjFGL0F4SGQ5ZENMeHlXTk9wOHZERmJZcmM0SU5QQlJpVm8yVjQ5dHF5L2h1ZCtvTXpBNm9INGtnc0F6RDlPMTY1elloUk5ZV1o0UUM5ZnZ2NG12TzhjZm5TNVh1bTR3MnUzenFRNTErNnllN3VpbnZPYnliUzRoQ1FtY3lrMDBZcURHSW1heUxUeWpJcXBveXJnc1BqSmE5ZWZZUHhlSXExME5ZZHEyVkR1K3B3WFRMZE5oWXM5dlNaYTBRd1ptQWNHOFhhRkFVaFNtNk5VWmZzS2xSRXRNcHpYYlVkdTlNaGdHZG9iUUdtUmNhcTkxR0hJdkZSVjgvZW12L01sYzNxdThkVi9uQ3drcnJiUWZCanJHaVpHNTY3UGUvZW1MYy9kMkZhWG4zMXNQbk5FK2VlMnlMZUU2eDVLYmYyN1Yxd0drRUNVUXRibUUzSlh6L29aaDl2USsvT3NIaS9ObHVzdmUwS0krQjhwQ3d5MlQrcEpVUzEzZ2NUTldZeGFvRnFpVWlGeUZnVEdqNEdKcU15My82Mjk3N2x5VC8rTDMzNGozemdYWS8vNlBaRE8wOC8vTDZIaTJxOGhjYUFqdzI5WHhEY2toaGFYTmZSOThmRTBLRFJFN3FBR2d0R2FLNDJmT2J2UDgrdmZlNExIQ3hYaUNqUncxR2p6SDJreWhPdko4UzBvVXE4SFR1RVVzb3dvd1R5ekJKamNpZ3hXWElDREM2MUQ2TXFZMXdVNUZrMjJPYkVwQUUzU1R5bHFzeFdudFk1cHFNTUswYWIzc3ZCVW1ldkhmZC8vVnEzK0hrNFhYSDJnTTh3bW90Vmk2SDVSNXdnTzVzVFRwYjErblMySXBJdjZ0YmZlMkZyNDZGN3o3OC95eko3WVc5WE5yYzJ1SFZZMDd0SW5pVjJiNHdlWSsycEJaRVJRZFVsZ3psTjg4UzRzR3h0bEpTRnNtcFczTGcxbzE1MHVDNE42RWswbFRBVlk4M1FaQ2J2S1ZYUzRxTzBnMHc1Z3VIV3JPNStzZmRoQWJRaXVNemErTVNWaTd4dy9ZNGhuaHZXdEx1alhCcVhndDBHODVUc3BQWHpDeHRWdkc5My9QNDhNNW5OalJTWlhYdDFkVzN2bDYvZmJuN2g1VVh6Lzd5NmFINWg0ZjFyUUx2eS9WR2xXY3dENytxaXJ3U0pCakc1MklVVC90cTFzUGdmbllibXk5RDByMTZCZlBCdDk3STFMZkF4Sm5kdUYrVncxb2hQMFYrNXF1YXFWSktLWWp3UURDdGcrOHFsblVzZmVkL2pUMy8vaDkvMkE5LzlyZS84WTI5Lyt0RVBMNkxidXZmdEQ4aDBhMnNJbnU4Sm9lYi8xOTZiQmRtV1huVit2Ky83OW5EMk9YbE9EbmVvdW5WcnJsS3BORXVBU2hOSWpRQVpBNks3QllIRDNYYndRSHNLMjJHSEhlMEhQM1g0MVErbTJ3MTBSSnR1RUFIWVpoYmQ0QTQwZ1dpRUp0QmNrMnE2WStiTjhVeDcrS2JsaDIrZnZGa1hsVlNhR2xWRnJvZ1RlVzlHNXIyWmU1KzExN2ZXK2cvQnpmRyt3N1g3ZE8wQnRwa1R4Q2FsUHE4UUZWazhVL1BsMzduTVkwOWNvWFllcFJWdGE4azBHSWtzTzJHbjhlUWFKb09jTWpOa1dtT1VJc3N6dEVuZ3VMSW9RSU5iZWU3MXNqSlozaWRSVE9mbFVWbFFHSU1MQVpTUUYybTNFRUphaWpXZDU3QnVNVXBVWjdWN2R0LysxclBMMlc4RzRrRmZQWktTQ1VvMkdMQkdTVlNSK3Vza3lPRnN5WU4zM2FhT0ZyWHFDUmdtUnNrSFJjR3JIN2p6QjR6T0p0WUZCb09TMjg2ZEljOEh0SjNRZEFtMG1KdWkvNTNTcEV1dDFCNmo0SHp5KzJpYWpycTJ0SzNGdG83bG9xTnBMYzdINU92UkgwMlRuRkRxMjBLTWlBU3lQQ1dOajZLMFZrcHB1bG5UL1VubndnSFFLWVhMdElwM254dHpaVy8yTjJFQ1N0SDY1L25YS0FHbGxkcS91Rkc5dXNqTitWbm5MM2MrUEx0MzFENys1V3V6Zi9mWXp2ejNyOHpiMzJwanVOb2ZXMnVnaVRIYW1lOHVyNUhIZ0J3R2VFcGdwOEgveGhXWi8zWWQzUkhQMTBMKzlwaDQvdmMvOVVZKzg5Z09yN3B2azcvODRqYTdoNjJLRWNXS3dIU3o2UzZCZ1lqa2E4TnE3WHRlYzkrOXIzM3d3Z01QM0hYbTRjM0o4Q0VEZDI1dXJ0OTk5dHhaTTF1MGtwK3ZtSnpiU0UwWUhzS1M2QnVDN2VqcUE3cDJCKys2OUJUck43NVNhcG9ybGkvODdoV2VmbXlYckRTTVRFRnRIV3ZEaXFacGNabEhLemhzSTAvdU43UmVlR0JyU0NuUWRKSFJTajVHYWJ6MzZVcGxmZkprK3ZoT1JSZlRzczBsL3JiSkRSZTJKa3hheTd5enpFM0hvWGYwdG9Yc0hQbURhVDI5VXBuQnBlY1c3dGN0L2hvM1JlSThFQTFLYXB4VTVPeEo4Nkt1LzhYekcvTHN0VDJKU09pUEl1N0o1M2FlZnZicS9pY2Z1dWYydnhlalFtc1VSQ1pyRlZWWmNEZ3RhZHUycDg2R1k1MG9LVXFDQkhRSXlhblhlNVpOeDJ6UnNsdzZ1amFlY0tNRmtaQmtQbFZmTy9SS2Z6ZjFSNGlpczQ2OE1EMkEweGlsOUFubVRNS0xQWERoQWg5LzdNcmYrTjNPalFvR21XYXZkaElUMnJZRDFGZjJGNWN1WHEvKythUXE3djdpdGRtemU0dDJPdTNjUENDck43ay9NWTFhMlQxbm5majJTVG42QllVYUZKaVJBVm1JMjBHT2lXdmRMVnlRYnkxQnptME0rV2YvNDkvaHgvL3hIL0QrUDNxY1BGUEt1YWdGVmxLZWhZSlNvQktSd1owWHpreCs5SjF2ZXZNanI3bjNSemJIK2F2WEo4T3p6b1UxNzN3UklnelgxbEJLYzdDY3F6dmVjRzgvNysrUTBJRFV4T2pwR2tjNzN3UHRpRDV4RGxBS3JTTjJOL0w0djlubThsY084UktSb0tpcWdpdzNUQmNOYlpJZ1pEVFVGQVhNckhCcDJqRVBrUWZYUzBhWllibnNDQXJLUVo2SS9yM0ZzZW1sWXlRa1RTanZrNmhDVzNka3VXR1lEMWlyU2liREFXdWR4ZTBka2h1TEZtSHV6TjRzcUYvZHFmMi9oOFZlZ0t1M0NEV0VEQzBGdVNnaVY1bTk2SHZ3bjczM1hYejg4MCtKZUlrOWJkZnVIUzNtVDEzZS90aGR0MisrT3krSzlSaWx4MUtsOThwa1BHSzh0a2JiT281bUM2eHQwVnJRT3Zaa3IyU2JWcFk1emhYWUttM0dZMGlZWTljZE8yRWxneHkxMnNpb1l5SlhVbDUwdlVvS0dGMHdHQXc3WStxWWZ1MTBjbEpLTXhpZCsrckg5U3FuTUZxV0xsSmJ2M29BNEtMRUQzN2x4a2Y2WjFYV0o4Q3FGL1B5TnlFanh4WVJFZWxBVEVOVUoxQzc3c1NDOEFYUnZOOVFndHkrTmVLZGIzOHo3L21mZm8rZGc2V3kzaXZyajBYWWpnbE1Bb003Yjl2YytvbDNmKzhiMy95NkIzL2k5cTNSMjRxY3JYSlE2czRHdXM1S0RCR2RaUXdHSlYzYm9rYUs4ZFlRNzF1OFd4SmNnNGdsU3NBNXdma09US1NaUlhEQ1lGT3h2TzU0N0FNN1BQV0ZQVHdSVEpxTGR5NzBmWU9ucWtxS1Fja0tQemZvTEhycTJKOWJQdGM2WG5HbTR1eW9URDU0bVVrRXFMQlNZRmRKZkt4SHZNYVFwalk2MDZoTTkwUWpUYVlVQlpxdFFRWGp5TUd5UTFwOXlSSS9GcERuZ0ZtL0lHdE8zaFNORm9OaW50NERMenIreVMvOVA0UVlwZWNnZVJFNmtQS3pqMTM2cXd0bnRqNTlkbVA5Qjh1eTBJTkJrVHd4RXVjWXBhQVlGMlJaUnRPMGhCaXBtd2JyMGhITWU1TjBjSXNoNDVHbUtuTW00NHJwdEdWMnRLU3RPN3hmYmNxUEI1TjR2MUl3VEgxSmxoZFVWU1ZGa2FPVWNwSkFtY2R2UUswVmoxKysvTldweFJHR3VVS0JhSzFpakxLeU5RejkrM1ZsVGJDaUM1eFVRZ3lwMENraFRVcFhpOGVWSHNFcVZydVdZTFNKS3dKTENPRmJxeUFiNDVJUGYrd1QxSjFYbmZXcUYwUXczRFN3SHdLRGQzN2ZRdy8rZy9mK3dQdGU4OHA3ZjZKWkxMWml0R3BRalhBK3NGelVLSWtxQm8vSkRablIxTjR6T2pPa0tCUmRXeE45aTNNV0VZdEVoNDhOWkFabkJUOUxqazFXRkkvOTRRNlAvdlVPWHAzY2lxY0cwWWZJb0NvcHM0ek9wOTJIalFGclBSdERUV0dFM1ZyNDBvMmFlODhJOTUwZEoyWmJ6MlhRL1hLd3RRSGRONStwTGRGVWc0SkJtYUVrc25jMHg2RG9Pa2N4S05nY3I3SHNJdHI0cFUzbjd2cEV6Mkg3bTdneVFrQytpU1B1U2t4YWFTVVNqOGVpOXFrck4zWSsrUEhQL3NGOXQyKzlkckkydm0yOGxxckdvQ3d3V2M3YVlFQ1dKeENmQ0dTWm9jZ0wyalpnYmNlTnZSbldMcWtHR1UzZEpsaU9oN1oxZE01amcrQmlTSURIL3BtclNFT09QTThZbEFWWm5sTVU1cVlHc2FZUjRXU0NpQkxGYlBiVmlXR2Z1VDdsM28waDUwY0YwOVp4MExpVDlzeit4RkZOVHI1NkhYN0psQ0ZEMCtIRktLMTgwa0FLdCt3NGpySEdJYWJwMm1ReVlUYWJmV3NKMHJsQWEzMWE4dDNzTlVxbDFFaEVxbzIxOHN3Ly9MRkhmdkNIM3ZubW43N3J6dHRlT3oyYWxhM3RaSDE5U0JSUnR1MVFxV1lUWXFBeVNhOHBCRUh3Uk5ja2d6aVhqcEhST1RvN3d3V1hsdXZCb3FzQUdDNTlac2JUWDl6SGEwbCs0MFJzQUJkRDc0TWhsR1dPeVRSNVB5RkJaeFQ5MUtvYVFwWjM3TTBqWDlsdE9HZ0Q5NHh6dGtZRFZHYXcwYU9pUnZ1STZvV1BNNU4wWVNYQ2ROSFN1U1NuWHhaWkVrenI1VVVyazdOV21obHVPVnMxakt2a3lGQlJsQkt0MHMvcUNOOXdnbHk3TWVOMTk1MWhiOXJLOXNGeU5SSnRSU2l1NzA4Lzg4REYwYWNoL3VqKzBhR1p6ak5pMElnWXNpeEg2M1E2TVVZenFreFBkN1dVdWVmTWVpREVETi83ZTh5WEZoczhObmhjU0NvbXRtK2dNNVZjcTRvaW95d3lNcFBjWTVNdVY3cmVxWEhuTU1SNGtwd2tTc0d5ZmVGKzY5bWptZ2MyaHowcm1lZXhLRy81VXRHSmhrd2xHVXNjSzZXbjEyL2V4Wlhsb1J6YW0zN3I2aVlDTHcxZ0pISk5oTFB3VlpQalJTZkkvWGRNZVByYWpKMkRwV3E3b09KTlpjSkJncUhMNlBXdk9IZnYrMzc0KzM3bUxXOTY3WHR2di8zYzJXWGR5bUsrWURLcGxDSWRUN291SFpsV0VQRXNNL2pnOGQ3aFhNU0ZnSFFXYjF1NjJQV0N6MWt2SFpNbmxHbWhFVFRETzB2WU1MUlhhcFFXbG9zV2syVUpRcUxTQlRHWlJuU0dEYUVIc3dsVldTYlBDZDFqRzZSQkxlREd0R1BXV0I3WUZNNlBpMTVWQWJMK2doYkdKSDVDYm5BU2FKeExWRlZqc05aVG1LVGQyell0VFN2N1V5c2Y2Y2U1cXlZd2FGVE0wREtXbkgyNmI0MGVzRFpnWGp2UldrbElWY1FDM2RHaTIzdHVaLzZCNzNuby9KdldodVlPMTcraGk5eVFaem5HWkluM0lRRVJTNWJCb0RTRWtCRmpZRllMYmVlU2hJK0tES29Na3hzbTZ5WGVLdXBGaDIwZFJtbE1QL2xiNlgrRkVER0ZJaHRFOGt4VTUrVEcvbUh6a1dYYk5xc0VFUkh4TVNTOXBLOFJUeDNXejB1RVc4VVUxQzNaSXNDRWtwbWs2N3JYTFk0WmorcDVXU2JIS3NJQWQzdzlhTStMb3I1bW1pTFROSjAvS2ZwY3BRV29IdituUC9yYWQ3enREZmY5M0QxMzN2Zkd6YzJOd2xyUC92NlJRaUtaVVVTZnJJR2RkWW1TdWZvQmxlcmgxZUJ0SkFaRlBWdGlZNHVyRHltR295UThFQkplcUhPQjZCVktoTFhiQnJ6Kzc5N0hYLzNiWjlsNzZpQkJISG8vdXl4TEg0c2lMVjZycWtnalNoOVFtV0haMm5RczBJWkJycGtVQVlMaXlBcWYyNjA1UDdmY3NhWVpEektpa0hZZW1jSDVrSnJQTEQyQlEwaUo3VVBFYW8yUFFab091NzJVMzcvbTJ3K2RRS2tHQlRIcm40Z040U1MvL0p1S0VJVm5kMllZclpKdVE1cjR0RUR4MkhNSG4zend6alAvNXQ0NzFuL1d1bGdra1VGRGtXZEljQVJ0OE5IZ2ZPTEZkTmJqZmFSem5pSXZ5SXNSZFcyWmpBc0c1Wml1ODRsRU5XK0lIblFQbHorMmRDQTE2bVlBZzBsQVp5SW1NMG9GMmJFejkyaUk4WGw4aTZhejhLMzkramVQbS8xMXJHL3A0NjRzRDE3NGU1QVhtRmw5RmVUQzExMENibzZRR0hGQmxQTnlNam5XZ0xXZi9jazMvZUFQdmVXaC8yV3l0dkhxalRQbnNySW9DQ0V3bXk4WUR6Tk12MHRJWUxZdUNRakVpUE9XNFdoRWtlZDByYU9PSGVQYkozaHZDVEdnWXRKbURkNFJmTUM1R2Q1YnJJVm9vYW1GYkpBenVqQ2hYZ1Rjd2gzNzR5V1RHSlBJLzBhenViR0dNUXJyVXc5aU8zZU1UWkplRUM3UElqa0s3eFVITHJLd2tWd3Boa1ZLdUR6UEVwOGdCSHh2UHBuRzBhekFmZUk5NmtiTnA2OWE5ODg5OFFhM21PSVlGSmFJZmJGMzUydkU1ZDA1azJIQnNNeXdMcHg4c0tvWVJUV2QzejIzT1hxNHlQV2QzaWZwelJEQzhSa25TcGJFNWt4Qk5keGdVSzB6SEo3aHpOWWRWT1dFekF3d3VrejZXVEhKSEs3QWlTTDBlNnAwYjAwQmd6RU1Kb0xLUUNtdHROSDRLRS91SDdWL1V0ZDJuK2RyVDNFd1gvQlNpSzliUWFveVovZGdvYXdMeitPRks5VDRINzN2VGU5KzIrdnYrZStNVXZmNm1JQjUyaWhjbTR3dmpja1Q0SzlYK2pzV0ZvdEpNOVpaVHlqU3hWY3VvMnNYS0JWU2s2MEIzNEVrQTVob0xUcm1PTnZoMjRRWTdheWc4NHo3MzNFWFY4Y0ZsejkzRFRwUFZnalJwMlp5MFhUa1pVNm0raVR0YkhxanhKaHNpbzJoS0JJWDBPU3AxeWlzTUhmQ1k0ZVdxWTNjdTlHN0wybURpNUcyYzNTdFJlc2tOWk5sUmhvcjZyQ1c1M2JiK1A0Ty94d24xUk1oNXVodjEwUHpPR2ExNWV4a1FEVW9xWnN1Q3VMU3Rsb1Z6MjFQbjMzMit2elgzLzdHaHg3TTgvS005V25KYVhSR25tY0k2YWlsdFVIcjdOamp3N25rcDZpVkpzc3luUGNVZVlaV2hsQW1weXJ0TEZvZ0d3aFpDVVVGSmsvYVlFazFQaDI3Z28vWGxyV2RyVEJZZmFYanBSUmZ0NExNbDUyS0l1b0U5WFVJak43N3JvZS85d2NmZWZCL1hodG1EemV0WjMzanZGcGZINmVMN0FOdDJ6QWM1SVFRaVJHNnp1RnM4cUx3UG1LdEl5OUxCbVdGRDBKbkxVd2lXV0dJUGpYc01YVFlib0Z0NXpnYmFGcWhhU0p0SXpnYnFWdkI5OExTYTJkSEZKTWh6ZHpTVEJ0OFRQcEx0blBVbmFYdFBMVzFXTjkvUHZqRVo5WUo5S1pVOHFNb0MwVW1TVFVuQ2h6YXlOd0dkQlMwVHpiT3FXRk5vTC9nZ3ppUDJsdHcvVVlydjNnZzdvTnlreW5YOVdCRXFjaWsvU1lhOHE4WGRlYzV0N1dlNFB5SkNIYXNSMnk5T3J6N3dsM2wrdmpNdzRxaVVJbWxTNHdKR3A3V0Y1cllPL2s2NXdpOVRKRDBtRFY2dUx1Tmp0WXRhUHdjbFZueUtsSU1vU2hWZ3B3bzFldGtKUjY1Z0N3Yjl5ZVhyODgrM2xlUFJpbjFnZ3U1bDJ5QzlLT0VsWi9HQUZpNzcrTFc3ZS83b2RmL1YrZTMxdDd1Ykt0aVZPcnMrUXVzamxlQ29tMlR6d1A5SW1tNTdPaHNoekdKN05KMmxoaWhxaXFjODBRZm9CTE1VT0hhQm12bnhOamlYWWR6bnE0UmxtMXljN0tkRUt4ZysvbDdVdnlMcUxMQWpDcVd0V1U1WFdKYm15eTlZcVR6SGh0QzBuenF6ODJ0alRTZElGR25UYkdrVVhGUktNcGNNVENLVEFsekc5bHVrc3E3VVJGSnZTWWhDTE1hMlYvS2N6czIvT0lCL284Rk9jbDVjS3NGOUlDTTdqdVFJT2toMXZEZzNSZlU0V3dwbkhoQ0wrb21YTjNadTNyN3ViUDNEd2FEKzBJSXl2dGtLZUI4U0ZWZTYwUVpXS2toU2xLRmo1S09rQzQ2TEV0YXRTRG9GcFR2cWJRckJxRkNWUHF6dGVHNEYvUlJMdTFOMjk4OG5EWlA5eGdzcTVUeTYrc0RhVnYvc2trUWRXSWpXUUpyV2FiWDN2ZnVoMy9zMWZlZit3ZUtVSWxFUWxSc2J0N0dvQnIwT3F5V3BtbDdoR2NhSzRZUWFWdlh6L0VESVdoYTY0NFRSR1Bvb2tWVmM3eGI0bXhOOEIzQkM4N0NZaWswZGFUdEJPK0VhQVVKTVJHQnJOQTJnYVlKeVRCK3JhSzJRajFyQ2NFaldxRnpRMk9UWUlHWEpFdmpmSUpEdEExWUM3blI1RVVDSnc2cmdyVnhUcDVIY29UZzRNQUorNTM0NEdLblJlWHpWdnRkeTE4Y3hQaFBGNFNQU0ZvSUxrK0EzMktPbGhKRGs5QmQzeUZlLyt0UVNuRjE5MkNGUFYrTlJQV3lhZHNZNDg2NWpmVlhHcTF2aXpGS2lFR2xUYnZIdWFRakZsZHlRejNHeW5xSFZUVnhXS09IZ2J4SVB1WkYzazhLYjVrdGFaMDB0QmExWXp6TS9iSU5mL1RFcy90L0VJSXNWMk51RVdMWEJYazVWWkRqZGIxU3FURi81RFczUGZTZXQ5NzczNDZxN040WWt4aFpqRENabktjY2xEaWZ6ckQxTW9rRloxbE9DSUxXaHE3MU9PdWgzNVF0NnhwdGN2SThTL3BLTGhDeUdTWnJjVGJCU3F5RFpTTXNsMEpqSlFrb3UwaHdFZGRGYkJmcHVvanJBdDVGbXFWbGZ0U3c3RHBxRi9BZGVOdXp6MFRqUS9yb25NWmJDRDVWT0JlZ3RjbXJiekljVUJTR0lzc1k1RG1sVVdRcUNBR2FvUC82S01UZmI1M2FYZ1Q1MUpUd0N5M3hzMzFEdnJnRkdTb0M4akJiYkZOL3gyN2l4Zk5uV0xZdE8vdEhxK0hnU2ZLUDN0ay9PQlNSM2RHZ2ZFV2VaMmVkOXhKQ1VLdGxYakxnTkJUOXZXcmprbGpWbURWTFZtcnlMUEU4c2t4VGxqbTZNRWtUeTRiamQ0bFM2VHJ1VDFzR2hYbHVlNy8rNVlPajVpdmM5SDczTDdYajFkZExrTDlSUGZKTWo5NzdBL2YveklOM24va3hIOUNLb0JTQ3RaN2gyaGJWc01JN2o5YWF4YUlseEVCUkRvNUh1c3Q2MVNBTDFqazZtMUNpazhra0tTaDIwSFJMektqRldtaGJvZTJnYmlQdDFPTmQ4cXJ3YmNTN1NPc2l0bzA0RnhOM3ZISE1EeHNPOTJiTUR4Wko3MGtaWE5DME5iZ09uTlVFbjVMRGVvaWlqcGRMc2E5R1lNaE5zaElvY29OUkNxMmlVakVHNi9WdlRTWDhUazM4ODRiNDBRRFhUaUJJajNjZU9WcEdaR0tKN0h3SGt3UGc4dlllTnc2bUFFeldob1FRVlQvK1BPWTRYTi9idjQ1d2JWU1Y5K1FtUDUrQUtrcEZWZzg1bFk1VGVvN1phS2dtVUpUbUdNNnVwUGNHeVF3dUNyWnp1TmIxY2tkcHFtV01rcTZMYmw3YjM3MjJ1L2kzdlEvS0N0WWZlQWxHOWlJcXlFcURLYi92NHVaZHI3eDM4NGU4RDVuV3FrZEtSMXdRbXJidGhjTWlXVkZRbENWZDExc1N4MEFRaFRLR0tJcmdBNGltekhPTzVpM0x1cVVhbEVsNi8yaklyR3dKWmFCdDAzSEtlK2tmeDBMd1F0ZUdWRUZjNmoyaWo3U2Q1Mmgvd1d4L3pueGFFMXovVkRPQ0RCVWhVN2hhQ0RZa3I0cEU0aGRCbElnaTc1OEVFb1hwdEdXeEFKUEJjR2dZREJKdlpGQklFOXY0TEZGV2ZJN0ZDUnFwWHowbEZVb01TaXF5YnhobjlhM0djRkFRWTVTNmlhRlBrbU5IbnM5LzVlay9XOVR0OUxVUDNQdGZuTjFjZnhkS21SQWpqV3RwWTAybkdvYVRqSE9ERVZscGt2KzVFNVJLMEg5RVAyK2xmYXcyMzZ0SElpSmxxVDkxN2VyOGQ2d0w4NU1JZ2hjQ0E3NlVLNGcra1J3am8vWGFQL3p4Ti8rOWV5Nk0zcU9OTHJTK3FZQWhaQmd6WUR4ZUI2V1JHRk5qM25RSkJ5YlExQTBoUktiekdjNVpzaXhISWxnWG1jNGJ4cU1LN3dQUkc3b0d1cnpEMlVobkJSK1N1YVIxeVpiWXU0aHJRMjlJR1ZndUhVY0hTdzczcHRTekpkNGxXSUZTaVp0aGpHQXlSVEZVNkNKWk1VdFVVWW5Tc1FkK3FuNkJkRkkwdHd1dzN3YVp0MTZGRUVQajlGOGRXdm1kam5pdFQ0NGFhTlV4YlZaRmhlcjlwUlU1K3V2eU83NzlDVkpTRlFWQklpSEcxVUJxSllnZ2gvUDU3bzNEd3k5dFRzWm50ZExyY3pjMXRaNWxqZzdWK3hFMnRhZHBFcWNteTNUdnBaNldjZ3BZMUlrbmdrMEx6eWdpSXFLc2kwL2ZPR3grZnUrby9WTC9BR2xleXRYamF5WElTcVkvVnozNzd6V3Z1T3ZlLy9nZHIvclpRUmJ2UzR5eWxZWjMzNFJIeFdSOUU2VU1JcXRqVnFMSWlpUzhqOGtNcy9tU0dBTGFaTFRXRVNXd3MzZUljekFvQjlTZHhiY2FXM3VzY2dRUm5CTnMvd3BlQ0RZZHA2d04yQzZ3bkxYTWp4WTA4eVhScDdHazBlbkpwMVRpTXF6Y0N0UGMzclErNms4RXl3Mk5PcWZCQ0txblpONUV4WFZFOFVUVnh0aE1yWHprME1WZm1FdDR0RStPazBTYmtFUVhEQU15WE84WnUrUS8vTFJtMlhUOHJ6LzMwMXk5Y2NEKzBieC9QQjIvQWtCcjdXejNjUHFsNnpmMnY5Q3BabTgwTGk0TXFueE5aOG5DcnFzdEJ6c3pqblpudU5ZbmlvSElzUXpRd2VHQ3R2R1lmcC9sRTYxNk9hM3RMMS9hWG54UVJCWW5BSnIrcFZvOXZsYUM2Qk85eHdnWS81Yy84KzRmdWVmQzJmZUdNQjlFU1UrVklMcTMrVkk0NTFnYmI1SVhPU0drQk9rNnorSFJFVnBKd3VwNElVYkYwV0tKa29CZ2tnNXVET3dkTFh2RktRZ0JwRTNDQ1Y0bHNRSG5oT2dsL2JsTG9zbnQwdEV1TzJaSFM1cjVFdWQ4NzdDNjh1dmpwSng0T2lGb1RSVHpsYjNHL3N1WmRYK2VvUThWYXFKUTZ3cWxZb0pONGdnNHZCTFk5L0NyRGZ4ZkRmR3hXNTZNWHFGaS84OWowQW5aMjFzcS8yMkZSS0h1TEd2RENtTU1kZHVkckNJQmlLMjE4M2xUWDk2OU1YOVVvYTZPSjRPN2l5STdHM3lrV2JTMDgxb2QzSml4dHpObmYzZktkRy9PY2xyVE5wYmRuWnAyMmFCaUlQZ2dBdEg2K01GcnU4MnZOYTNiNVhuU1BpL2Q2dkZDQ1hKY1BYcEl5ZkF0cjMvdzd2ZTk1NUdmMjVpc1BUU2RIaEdDSjhhQWp5cytNdFJOUzkxR3RqYlhrUkNUMDZveWJPL3UwellOdzZva2VLRW9jbzRXTlRjT0RzbXpncnBONCtDMjgrd2R6ZG1ZakFraHBtMnVMd2xCNk9pSUxzRWNqckZQWFdBKzc1alBhcGJUSmM2RmhBOWF1VUdoamlrMWNZWGVOSW9ZVEwyYzg0SDllZnRubm5panhuOFcxT2NFZGhXTUZHb1RSQXN4QnRUakh2VkxDK0x2QkdTSG04amM0eWxWeXJ0ZU5CbjV0c0JJdnRWNDV0b05kZzZPZU9Ncjd5T0V5S0p1RUJIcGJhYmxCQzVLQk96QjRmS3lzK0d4NktNWDd5L09wOHRCVTNjcnJKV0tJZUtzbzJzNjluYVh6STQ2aG9VU25manBNVVErdjMzUS9OTzl3K2JKVzY2UnZ4VmsrSEpKa09PdHVURnE3WkZYWC9qaFY5NS84YWZXMXplS2c4T1ppdEpnc2h4VWtReFNTTnBMTi9hbXJFODJFeWVqWjU5NTU3bDI0NGd5ejRuUjBiUU9vd3lYcnUyeFhDNHA4Z3pud1ppTW85bUNvNk1GazlHUWlLSnVPcVFGb3d3T2ovWEp1TjYyZ1hwcFdVd2JsdE1GYmQwUll6eHVKaFVhclJLVE1BbElhNHpSRXNWUUw5Um45aGJ0djdMQlgrK2ZkRXRMM0c2Sm4vWElwdzJxMW1nUjFDZGErRCtXeEQrWG0ycUFkYi84ODBBczBETEFZTDlMSDVJWHoyMHhyMXVLVEZPM2poN25FVTlVa2xXaWgrbXN1YkczdS9qcmV0RTlLaUZzS2lVVFJCVW9wWHZsZExGTzFIUW1zajdPVkRYUVNwUTZXclQrOTY3djFmL3N4bUg3NklucTJyM1VqMVl2bENDM1ZvL1JuZWZIRjEvL3dQcC9iWnZaL1NFYThtSk5FVHNrSnBKV2drMHJpaXlqYVdzYXF6bC9aalBockh5Z0xBcEU1Vnk2dHN0d1VLVG0xOWFVdWVMS2pTa3hKRm44RURYR1pOellQNkJ1VzRaVmhmT2V6anJjSXFKY0RrQUlqbWJaTVR1c1dVNFhkSzA5Rm84MlJwUHBwRlBWZThkZ1RISXBpc0dvZHE0UEZwMy9oV25iL0hYZlJ4ejNFZ0xXSVhzZDhTOWE0b2NiNG9kYXdncFRkWEw1RnpLbFk2R01HSlRrS0xydjB2SCtwZTA5RHFaempOWUppWXlRYWRORHhZK3J5V3I2RmtJVXUyamM1V1VUUHVXRFBBWjZxaURYQ1gyemZ6UUxqMWVsTWFOS2JidkFYeDNNN0wrK3ZMUDh6WG5qcjN5VjVJZ3Y5ZVI0b1RHdjdoZURBNlAxNEYzZjkvQWpiM2oxbmErYno2YzgrZFJqcWhyZXpybXRpa0Z1UVZ6ZmxFT01udkdvNU1yMXk1dy91OFY0TkV4YXNrcHhkbk5DMDFxMjl3NDR0N25XSjVUaGpyT2JYTDV4Ukl5UkxBT1U1c3ptaEdzNys4eVhIZmZkZlFjSTFFMURXUFFlRThPU1VzQTFoOVRMR3UvQ3NXbThXZ2tSQ01leU5ENkNxeFhLWmxHai9uVFd6VDk1eTFJdm5LaWFXVUN5Z0t6WU02dCsvWmdtYTlCeHFIT0dLcE50djN4SjNPVERlZm81dGRhY0hhM0xvcXVsZHAyS01Zbzh2NkpZWU5DNTBIYlRjRmxOdTQrT2g5azk2MVgyeW9ocWp4cjMxR1ltRjYvdWhmMXA3Uzg1THdmOXRUbXBtdWlOMFhFMEtwak4ycGQ2Zmp5dmdxeXFSOWJyNDQ3dXVyQjU5ai8veWJmOG8vdnZ2dU9WVzF0YmpFZEQxVFFMNWt0UGthL2UxRGxDa3NIWEt0SzBEVHY3TmJlZFBkTS94cE5TeHJDcU9KelhQSGYxT21XdTZHenk2RGFtNVBMMVhjcWlTSHlGR0NtS25PbXNadTl3VHBIbkdLMVpMQnZxdW1WKzJOSE1IZUlVZzdLa3FrcGk2UHVQdURLNzEwalF0QTEwYzROeEdYbVdmV25xMi8venFHNHU4M3hkcXVOamhycVpESzRmM1Q1UENDQlRXZ3BseENoRnBqVEw2RjVTTjF0RUdCWEpSVFkzR1VacFFycG84VVJmY3RMUXN1MWMzSjQxL3RGNTQ1LzBJZTR2R3Y5RTNjVXJNVEx2aytLbWhKRlNYaWxpbmhzNXN6VjgyU1pJb1dBb01QeVovK2hONzM3a2RRLzhqQ2c5ekl4UjQrR1FNNXRiRE1vaStkV0pUOXBVU1N5S0VEeFZXWEpsZTRlbTA1emRuUFRRazlTUFZJTWgwM25EbFoyREpLS2NsV2lWbUg1N1J3dVVpbVFtOGZLTFRETmJMcmk4czArWmwrUjV3ZEYwd1d5NlpIOTN4blN2d1MwRjVUUEU1WWpUUktmeGpjYlZDbkVaeW1aa0dQSThxK3ZvM24vMWFQcG5KL3FKNHltVVNaeXprd0lBSjE5UjlWeU9VbWZ5dHEzYnVkYlVISVRtSlhuRGw3YkY5dmkwVW1ka3VUb1dmdjRxL1lrN1VVRlBMa1NQSlhNU0NERmRLMk4wM0Zpdk9MczFKQVJoUHU5ZVZnbXlxaDZsd1BEaStjbUZuL3VwZC93MzYrUFJxMEx2ZWhyN2MvNmd6Qm1QeG1SRmlYUEo1REdHZ0ZJUW9xSEloVXZYOXBtTU55anlwQmFPTWxndmpLc2hMaWlldXJTTlNZS0lESWNWZzBIRndXeEpad05hWnpqbkdSUVpJb0hMMi90TVp6Vk5iZWxxaTdlZTZDSnRhNm1YSFYzakVualJLOFFuL1R5dEU3ak9HSTFYOHFrYnpmSlhXK2R1bkRoYXVjem9tQnNqSmlxU2pBRmY5WldXZm9xSVlydXRtY2VYL28xZnp5dUNSTzY1ZmNLOGNkaWIzZ3BSS1VUMUZWV3RxcWxLRmJWUENOZS8wZ05HcXhDRnFMVmlNaTdKQzhPbHkwZThIT0p2SmtoeWN5ci96dmU5NGcxdmVjTURQNTNuWnIyWGVNUTVpNCt4TjMvMEZFWGljeGdOWGVkeFBpRldpOElRUThmbG5SbGJHMXNNeWh6cjB5aDNVVGVVZWM1b3VNYnV3WXhadlVDaEdJOUdqS29CaTZhaGJscFdBcXlaempGS2NYZzBZL2RvVHR1NUpKY21rS1hwVkM5Y2xwWllScXVrMjZSVjhnQ0pjdFJFOXh0NzlmSVRJc2ZTTzFZcEZZWmx3Ym4xTWRPNlRUVE1yN0UxVFVKS0VTdmhaWEhqMitDdzBlTkNzbExyS3dpRElzZG9MYjNsYnJ4bGYvSzh5cHBuV29hRFRLcEJKbTBYMEZvbHRSY1VzNWRCOVRpWklDdFE0c3BGZHZLemYvOXRQMzczN1dmZUZhUFAwTHF2QW9scGhrcmZsaFova1R4UDlzTmFhMXJiVVRlZU10Y3M2am1YdDZlYzNUaWJVS0tkV3gyR0tZdU1Jc3VKb3BndGF6cmJVbWFHNFdDQUFIWGIwbllPNTJQeXptc2plR2l0b3dtV1RnSStCSHJHTEY0aVFaTGh2SThSNjRKSUZNekFmSEtuWHI3ZmVuL2p4SGs1QU5INklPdWppc1A2YTRNSlYrK1FsMk8wMWg4bkIzQ3NvNVVnUk1lLy9xMnYvbXNWV2YrQWFydmtKVkxYN21XVEhDY1Q1T1RtZkhCdWMzVGJEejN5MEg5U1pPb2hheTFsV1NSTExaT2hkWjdVOWxReXB3emVJdEVqUkFhRGlrRlJFYUxCZW84R0RvK21YTm1lc2JreElUTWEzM3R6Vyt0WU5ndktJbWQ5c2tIbkk0ZXpLVW9KaGRHVVJRWWlXTnR4TkZ0d01LMVJMaG5LbTk0NU5ZcGdZOERGbnQzWHMvMGtDSVV4cWhxVjI3UFEvZnpCY3ZubFBqbHFCZFpvSFVkbElkWUhwblhEYWR5TUVHT1M2M2tSWDV0UTJjbXQ2dVVhSnl2SVNzWm4rSmJYM3Zud3hiUDUzMS9NRHM1TTU0dGtJeFkwV2hteTNDUXFacTlxbmpnaENVTFNhNjZoQ1F5SFEwUXB0TXE0dm5mSXBhdjdiRTdHeWNUR083eXpDZHVqTTZMM0ZDWlZGT3NEblhNZ1Naby9PTmRiRENkbnFOVW8xNmlrblpzclE2bHlNalJHSjl1MHNzaGxPQno0bUt2ZnZYeDQrSUVveCtqYlRrRllxMHE1c0xuTy9ueDVtaEduOGFMMklNY2pYaUM3ODdiSnhUUHJnd3Q1bHVEcXppNjRQbHRRRkVQV056WVlGQ1Zscm5zYnJEU0ZDbEVRSWxxbEhpQzZobUZaY2R2Wm5EeXZlT0taYlQ3eitVZTU1NjZMM0g1MmczWmxwS2tnaEVEVEpIdEZneWFxSElrS284Q1luQmcwSmhoeWZiUEFKeFJwTDVpOEtvTmFrUmVaRkhtbXNqSjdkcmVlL3BFUFlYSHJBcXZwbk54OWJwTW5ydDA0ZlFlY3hvdEtFTDFLa09FZ0g1emJHTHl5TE13d3hoeEZvQm9NeURKTjV4b085NjhqNUF3R0E5YkhFL0lpN1M1V3AxVWZJa1lWa01WZW1sSnhkck5nV0ExNTZ0SjFubmptV2J5N3lKbk5OWHhJS2hrSjErV1RmSTZQT085WkxtM3k0TzQ4MGFkcGxDSlZsZGhyOEN1UlkyK1B6R2hNcmxGS3F5dzNvUTd1M3gwc2xrOXlndEdtbElwVlVlQzg1NE9mZS96MDdwL0dpMHFRazh4QmMyNXpPQnhWMVVORzU5b0hMMW9aRldMeTRNaHpSVzZnZFo3NS9KQ2o2WUpCTldFNEtGa2JGa1FSakU3a0pzU2dUY0NJUWJ6SDZNaDlkNTdqelBxUUt6dTdYTi9kWTJ0OXpHaFlvWFNDcWpnSmhINWtaSzFqdVdpcDUyMENMcEttVmtycnBMQ0lPc1pmS2IyeUlVN0F5YURrQzRkMS9VSG53N0diS3NuVFQ0bzhsN3JyVHUvOGFYeGpDYUlTdlU2ZjM2elcxeXJPQnVtWlpHcGxMQjhnR2tJMFpEcVNWd29mQXRQNUxydDd3bmc4WVd0OVFqWFFTYVFzSnJaaDZQK0xsVkhqZUszaS9seXh2VHZqdVd2WEdGVWp6cXlQMHpSRUtZaVJybk5KYjljbmpWM2Q0OWFqUkxTcytNK1ExS3ppTVI5YUlvaGhmKzdhLzNkdlBuK0tteEFJdnhLTXJvcUNvOVA3ZmhyZlpBL0MrbHArZGxTWk02a1BYM2svcUpRa1NnaVNoRU5GQUtXWmpDdXEwakt2cDN6bGFNYkdaRVExR0RJY0ZDaDFVeGRMZWs5QWlhQlV4bTFuUmxRRHc5VWJNNTU0NWdyVm9HS3lWaEZEeEZxZkZFdGNPRmF4VVNwTnJTU3BtaWZKRHAyU1pHWFBFcU9JQytGek83UHB4MFZrMVhjNElHYkpPSkxyQndlbmQvMDB2dUVFV2ZVaHlqa1pIeDQxNHp6M2lDamxRMENwREpTaHFuTEtQRzI1WTdRWXJZaVNvNVJoZld3b2NzZDhkc1MxblgzR293bTNuZDBnTTRZUU5DRjZsRTVnamdULzBSUlp4bDIzVFpnTUIxeTZkc2hUbDQ0SUlRbEYrNVhRWEpCakpadlZBRUQxV3JEU1oycUlRbXN0U3N1OGsvQ25yZk0zdU9rZTVMVlNzY2dNYTRPQ1JldE83L3BwZkZNVlJBSEsybEJNNTIwMktKTTlydytSRUpQTVorY1V3K0VhNXpZSERFcWRudG8rSkMxZFNSSS9rMGxHVWJRY3pRNzUzR01Ibk4wNncrWjRqRkpKR3hZOFdRWmRsNkdVQTFGVXBlR2VPOWFackxVOGMvbUE3UnN6dXVDVE02dEtJdE82OXhQVVJxRklvMlVrdVNqRkVGRUdxclg4bVZsVC8rV0pvNVVEd25oWXlQbjFrY3lXcDczSGFYenpGUVJBRlpuS2pGWXE5cVl4V21lTXgyUFdKTU41aTNXT1o2OGVVdWFHYzFzVlJTNGNuNE5FaUFFeXJUbS9PYUFhUkM1dlgrT3A1K0RlaXhlWWpNcGV0VThUeGFZcVFFYVVaQ1V3S0RRWHpxNWhHNCtiSnRaaVFBZ2tVenpWZ3o2VVNxSUlXaExFUklFTUs5TjArRDlldHU0YU44RjFRU2tsTVlnVWVjYk85UFI0ZFJyZmZJSUlJQzVFNzJNVVFzYm01bmt1M0hFdncrRTZTR3JLdmV0d3dYSjkrNEJsdmFDc2NwQU9DYXR0ZG9BWWlFb29pd0YzWDh3NE9Genl6SlVyaktzQjU4K3NVVlhyNURrNDcxSEtKdzhRNVRFcTJacHRyVmVFR0RtYXQ1aW9LTkx1L0ZnNElBbEc5RHBOQ2pGR0lZWkhENXYyd3lMU25SenJhb1UwblhzZW5PSTBUdU1iVFpCampFM3I1R0J0Y3U3b25qdnZydFluVytSRlJkTjJ2WTJCQVpVenJJYTg0djR0ckxVb2xaeUVnbmVJV0JiTEpjdkZFWFd6eERxTDliQTJISkJuR1FkSGN4NTlhczdhMm9LN0w1enRaVWtqV3B1a0pPNGtiZCsxWnBUblVFRnRFeDRySnlGMGxlcTlLUUJ0MG5Rc0w3UllpWjl1ck4vaEJDeGJLK0w1OVNIWEQ1YzhmbVh2OUc2ZnhyZVVJQkdRTEJ2dDMzN2J2WHRiVytjdmROWko2RG9WZ3ZEMHM5ZlpueDdodkVNZDAxZ0R5ZUxOa0ttYzlmR1FNNXNiYko3ZFl0Z3VxWnVHNmJ4aHVUeEN4TE81UG1SdG1QUGtwU08yOTJZOGVQZHRyRlVEdE82aFlNcjN0U0dkMmdwanlFcEZyVDNCQ1VZcGVzY3RzcFY0c2xIS0ZPYXlqL0hqUHNTVHZVZk1zMHhHZzF4T2IvTnBmQ3NKa3FwSDBreUxyUXRONTN5VHR1UEMwVkhEWjcvOEJQbm1BUSs5OVJXc1RjNmpqZUNzcFd0cU9wdmV2TE9qS2JzN0J6eit4YWM1T3o3SG5lZlBVdzIyMENaU1ZadlU5WnkyWFlLYThzQmRPZHQ3Y3o3L3hETnNyVSs0OC93WmpCYTAwc21nTXNaanZWZXRGY004STJiUWRxSDM5RWlLNG9oUWxKbGtnK0pUczhQbG95ZXF4N0ZScHBMVG85VnBmQnNxeUlwTnQzYzRteS9xZGovTERFOC9kNE5QZmZGTFBQQ0d3UGQrL3dicm0yZkl6RzM0ME5LMkN4UnJlTitodFViQ0dOZk4yWjg1bm5weWx5ZWUzV1VRdGhnTjFoa09Da2JWaExJYzBYWHJMSmVIWEZBWjQySEcwMWNQdUxFLzUvNkxaeGprV1lLVXBNWTdOZU1tNnhtTGFaUGVkb21oYURKRk9jaFpHMWZiaStnL3RLamJ3NU9UcXl3elVtUVpjNStkM3VYVCtLYmpKTnhkQTlteTZjekQ5OTExNzhIQjRpM1BiRCtwM3ZqOU9kL3o5azJVaW9TZzBOa1czanFDNy9DaHdmdVdHRHhkTTZXdGp4aFVCVnRuTXFwSnBGTUxucjI4emU3T2dtRlZrZmRHSzFsZVVSUnJHRk13cWdycXR1SHk5Z0ZkNTVKc3BrL2I5TFE5VDh0QnJSVEdLUElpQTYwcGk1enhaQmhVWVQ3MDlPN3ViemtmcHZRQzBrcXBNQmxXckE4cnJ1NmRUcTVPNDF0UGtOVWVKQk5GZG5Dd0tQVmc5cG9mL3J1Ylp4NTRlQ05aK29ia0o2RVo5bDdpbnVBYmtCV0pLaUFxNG9NbE9BL1JVRTBLTm03UDhLYmgrdlloWFIwd09zUDBlS3NzS3lpTE1WVTVRSW5seHVHVS9XbERwbnFrY0ZJZ1A4WlppU1Jsamp4UFBaREs5T00zbG90L3NUOWJQRVZDN0I3N2NyVFd5V1EwWkhiSzl6aU5iMk9DYUtVb0RtYUxvN2UrODB6MmZXODUvMFl2NUNHS0NxS3hyY010VzhSa3lZakdlU1RhbnVKcWlDR2lsZERVbm1VZDhCR0tJbVByZkVXMW9aaTdCZGQyRGxoTWJiSWsxZ29saWp3ckdBNUhhQVd6K1lMZDZhSlBwT1IrdEZJUlQvQVdVRXFKTWFxZUIvc3JsL2IyUDhoTlViZE9LUldNMWdMQ2RIbWFIS2Z4N1VrUVRpUklCdWoxemJKNDdhdk92S1VjWkpzK1JrRGpBOFFZMFZsRlZBb2lDQUd0QWtVMnBHMW1YTDB5bzY0VHdEQXRHd1hiUlVScGhtczVtN2RuTE4yY1o1NjVRZlNDTVZtZm5ZWWlyOGkwd1hVZGU3TTVuUXNVMmlUbC9SVUZWQ0ZhRWEyRUQxNmJ6WDdGK25oRUw4U2d3R2ZHeEkxUlJkMmRRa3BPNDl0ZlFaUlN5VkZxdVF6cTdlKzQvZTNWV25hbnRTS2lVRmx1NkdJZ09BRktvbmlJZ1dwd0h0c08rZWhISDJNMjdUaC92a0tiMUdUYk9pVHVHcWFQRUFBQUIxOUpSRUZVdWtBTVFwNFp0czROcWRZMXMyYkIzdjZVNklROHl4SWRWd3plUmFMenpKdU9MbmdLWStpcDBvaWdvdWF4dmJiNStXblRQY05OZFVTbklBUVIrY2MvL2s3KzlMRm5UdS91YVh4Yks4aHhGUUZ5MndYOXhqZWZmM2c0cVY2bEVTMGl5bmZKOFduWk9DUTR4SGZrV3FqcmRUN3crNStoYVdwZTlhcDF0RTdZTGU5QlhDU1M2TGk5M2pvaFJNb3laMjJyUkZkdzlmb3V2b2xrMnJCYzFnUWZDVTRRR3hQYjBEdHluWkZuQmtFdXo1ejdwYjFsL1FtNVNhWHRGNE5LQkU2VDR6UytZMGNzVnNlc0dJWHgrbUR3NnRkdGZYK1dxeXFJeG51d0xoblpCTy9JTXVIeWN6Tis3VmMvU1FpZTczL0hCU0tlemdsZEhRbGR4QlFyT0hyQ2hTQ0pXdUo2MTZpeXpLbldNbWF6aHRDQWM1N2xzaUhHNVBOQmpHaVNSMGhtOUxKVDhUZXV6dWUvRjJKY0dXWjJnTk5LUmFXVUdKMjh1ay9qTkw1VEZXUjF6Q3FjRmYrYU41eDk0Mml0dUJnQ1JGR0tDQnBGMXdZKzlaZmIvUDV2UDg3YWVNQ1B2T2QrOHR6aFlzVDBEWWdHbEVtSkVVbDlSR2RqV3JwNHdVV0lMaVRRWWFacDU0RjYzdEMxRGtUSXNtUURKakdDcU5pRzhPRUQxL3lyem9lVEhoUldRUndQS3piSFErcW1PMDJRMC9pMmhiN2w3MExDQkRxbGxiOXllYmI5MkpjUFBsZ1VKa1JSU2tuRTZPU0gvZEUvZVk0UC9PN2o5UjEzVHRvZi84bjd5TXFPb0NLNVZzbjZRQ3RVbnFpd3hpUUY5OVlLUlpVVFkycmVvNDE0RzJuYmdMT1dyRXFqMytCamIrOFdHRlNsYUpPaGNyNDBDOTB2THp0M2padjZWbFpCTkVxTDhsR00xdmg0dWprL2plOWNnc0N4RHB0MDNzWHVpUzhmL3VWOFpyNVNGZ09VUm1aSGx2L3ZBMC83Zi8reHkwODg4TXJOSjk3OHRqdmRZdW14ZFVTdkFPbTlUSkxwd1lTWmdtYnBDRkh3WGNCMUNjTWxQbGs2ZXh2b0drZmJMaW1HQnBNbGltQTZNaW15d2x5ckNmOXlHZHlqM0RSb3NVRElqSTVyVlNFaXdwWGR3OU03ZWhyZjhRcXljaURxZ082dlBybjk5Qk5mUHZxb01VYjI5NXo4NGU5OVpmcXhqejcza2U5NTgva3YvZkI3SHJ5Z1ZMWTJYd1lPWjU1cGI5VXMwdTh1ZWdmSlp1bTVmR1dKUnRFY2R0aUZ3M2VCMkR0SnVjN1QxUjN6eFF3dkhWbVdRWlEwc1VLc1ZlRzNENXZtWXlMSFhoMHJFZVU0eURNWkR3cG16cDdlemRQNGp2Y2d6K3RGQU9WY2xJMnp4VndoRC83Wmg1OTc1cy8vN1BLdnZma3R0OC9mK3RaN2ZrU2l1U05FVWNiMEh1Tk9jRllJTVVIUkJWQ2llT3pKUThxMWtrSXAydG9uUUNJS0NhbWlOQXRMUFd2d3pxRlZUblNLWnRraEN1OVUrTU9keGV4WFR2UWRxNUZ1TkQzTHNNd3k1dTFwZ3B6R3R6L1UxMGlPbFFYMFlEd3AxOWRHK2F1bjB6WSs4clk3NzMva2tUdi9CNXkrM3lYOWhDUW1iUlRlQzdaTktPQ3NVQXlIR1ZjdVQ3bSsxL0xJMnk0eTNXNTZpRzA2aHZuT3M1dzJITzR1V015V2RJMGoyQUhTYVZ6bll0QjhaS2ViLysrenVubUttNTRlSzU2NUdLM0ZoWEI2RjAvalAyaUNyRDUvMGlkOUNBemUrdjMzdk83ZDc3N25uN2hndmllNFNQU2lZaGNnQ0pKcmZFdzloVVRCQitIRzlSbGZlbXlYTjcvekxvYkF3VzVEYnh1STdUeTJ0alRMRHRzNW5IUE1Ea1ZpazZ0QmtVZEgvTkNSYjMveG9GNTgrVVJ5dElEUHN5em1tUkh2UFBZMFFVN2pPeGd2aEFVLzJZdXNMTGIwWW03M0xqMjNlT0xDeGNscmxVaUJEYUpCZVFYQlI3eVgxSHlMY0xDM2RKLzk3RUc4L1lGSnFXekhaejk1dVIrLzlvMThUREtsV210RW9qUzE0R29qaGRHN1RYQi9mR0RyMzF5NGJnVkNURGdyOEFLeHlESVpGQm43N2FrSXcybjg3ZlFnWHkxWjFJMmRSWFA1MHV4TDFTQ1A0MkZ4dDlGNkpJa0JxR3pyc2JVSHBWak8yK2J6bjl2K1FpZ0crbFd2R2srZSs4SlZ1c2FuY3RYRDE0MU9pRnhCcEdtOXI2ZW1sYWcvWG92OUY3dnQ0cmZhNEs5eEFvUklMLzRHU0o0WmpOYTA5aFJ2ZFJwLyt3bHlNbEZVMnpyN3pETUhYNnhuM2RQRFVYa3VLN1BiRUdXQ2k0U0lMQmV0UFA3bGF4K2Z1dUxwMTcvcHRqY3N0M2VMNmU0eThjZTFKa2xiSlp0bUg5bHJyUC9FNFZRKzNyWHF3N1BZL3VMTWQxK0l5S0pQakpwanE3Umo4WGljRDZmSmNScmZkUWx5bkNnaXlNN3U0dExoVWZNWWNPUnRNTUM0YVZ4NTVibTl2MzdpbWVuN1gvL0lmYThkbWU3MTE3K3lBeWlsbFZLOVNtTVFZYit4NFVPSEMvZnIxL2Z0L3ozdi9JZGFjWi95RW8vNnBEaHB1K3hWd2xpOTVEMjNUK1BsMDZSL3RhOVptZXprUUttVUdvaElBVlJuMW9kMzNYWFh4dXVpYy9kZTNaNStlbmhtZlBpcWg4NzhiL3ZQM1hodHZiQ0hvTFpEbE5aSHVSS0RQRzY5UExzM3M1K3pYZzY1NlNSclQvejUyR2sxTTFweWswWHZQZTUwUzM0YTM0VUp3bVNqcEcyOHNsMjRkYnBWOUFsejhuTjZZN05hTzdkVnZubCtzQ3hEVkFjK3lBMGZZdGY1T0xkT2puc0tianFwV201NmtvZStVa1NsRkVXV3ljVXptenk3czN1S3NUcU43ODRFZWRlUDNNZW4vdUlLOWRMZFdrMU1ueGpteE9kVy9QYlZ2MjlPL0QyZVNBeC9JaUZXdnR6eHhERkt0TlprV3JNK3F0aWR6ay92MW1sOGQvWWd6Z2JxcGNQN2VHdlRmdEw5MU45U0ZWYWZYMVdJbGVKaGM4dHhLcHlvR3R6YVo0UVlxYnZUTGZscGZCZFhrQmZ4L1NjLzN2bzZtVkF2NUpoNmVuWTZqWmRsZ3J6UXY3bXlGbGRmSlFGT2srRTBYakx4L3dPNklHM1huUVd2ZlFBQUFFeDBSVmgwWTI5dGJXVnVkQUJHYVd4bElITnZkWEpqWlRvZ2FIUjBjRG92TDJWdUxuZHBhMmx3WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2xSTlRsUkViMjVoZEdWc2JHOHlNREV5TG5CdVoxSVE1REFBQUFBbGRFVllkR1JoZEdVNlkzSmxZWFJsQURJd01UVXRNRE10TURkVU1qTTZOVEE2TlRrck1EQTZNRENmMUpsRkFBQUFKWFJGV0hSa1lYUmxPbTF2WkdsbWVRQXlNREUxTFRBekxUQTNWREl6T2pVd09qVTVLekF3T2pBdzdva2grUUFBQUVaMFJWaDBjMjltZEhkaGNtVUFTVzFoWjJWTllXZHBZMnNnTmk0Mkxqa3ROeUF5TURFMExUQXpMVEEySUZFeE5pQm9kSFJ3T2k4dmQzZDNMbWx0WVdkbGJXRm5hV05yTG05eVo0SFRzOE1BQUFBWWRFVllkRlJvZFcxaU9qcEViMk4xYldWdWREbzZVR0ZuWlhNQU1hZi91eThBQUFBWWRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNmFHVnBaMmgwQURRd05ERnFyaElBQUFBWGRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNlYybGtkR2dBTWpRM0ZDNFZrd0FBQUJsMFJWaDBWR2gxYldJNk9rMXBiV1YwZVhCbEFHbHRZV2RsTDNCdVp6K3lWazRBQUFBWGRFVllkRlJvZFcxaU9qcE5WR2x0WlFBeE5ESTFOemN5TWpVNVB1ZkRrd0FBQUJKMFJWaDBWR2gxYldJNk9sTnBlbVVBTVRJelMwSkM0ZnV5Y2dBQUFETjBSVmgwVkdoMWJXSTZPbFZTU1FCbWFXeGxPaTh2TDNSdGNDOXNiMk5oYkdOdmNIbGZZamczWXpRMU9XTTBNelExTFRFdWNHNW5FWmFYeUFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL2RvbmF0ZWxsby5wbmdcbiAqKiBtb2R1bGUgaWQgPSAzMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU1nQUFBRTRDQVlBQUFBZXZid3pBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSVdYTUFBQUJJQUFBQVNBQkd5V3MrQUFDQUFFbEVRVlI0MnV6OVo3Q2wxM25mQy81V2VOTk9KNGZPQVVDanU1RURBWUtaVkxJa3l6SmxPY2l5Wk5tVzdaTHZCNnVtUE9VcHUxUlROYXFabWc4T2QrenJLYzlZMStuYWxpMUxsbWxMRmttUkVoTklnZ1FKZ0lnTm9IUDN5V25ITjYwd0g5WjdEcG9VSlpHVXFMR2s4eFFPemtFM3NIdGp2K3UvbnZSLy9vL2cwUDdZV0tmVElZb2lmdlJIZjVTNXVUaysvT0VQODh3enp3Qnc3dHc1N3I3N2J2SHhqMzljVkZWRnE5WHlEei84TUU4Ly9iVC9lcSsxdkx6TVQvM1VUeEZGRVQvMll6L0c5MzNmOTlIdGR2bnNaei83UitvekU0Zkg1bjl1KzhtZi9FbXlMQ05KRXJ3UFo5VTVSNi9Ybzl2dDhuZit6dC81WFYvalozLzJaL2tmLytOL2NPblNKUUJPblRvbHJMWGN2SGxUREFZRGNjYzVFTmJhL1orOWxCSWh4TmNDeEFQRWNleVhsNWM1ZnZ5NHI2cktHMlA0MHBlK3hBYys4QUVlZWVRUi91RS8vSWQvSkQ1L2ZYZ0UvK2Uwdi90My95N1BQZmNjWlZtU0pJbHd6aDBBeEZxTHRaYmhjT2puNXViWTN0Nyt1cStobE9LSGYvaUhzZGJpdlJmOWZoOHBwWGp4eFJlRjkxNTQ3NlgzWGdJS2tBMVFEZ0RTMkFFb211OGU4RVZSdUJzM2J2Z2JOMjQ0SVlTUDQ5aHJyYjF6anZGNDdIL3FwMzZLOCtmUDg3Zi85dDgrOUNDSDl2dHZQL016UDhOSFAvcFJjZm55WmFJb1FnaHh4eGtWSkVsQ1ZWVllhLzNhMnRwditlL241K2NaRG9la2FVcXIxUkw5Zmw4VVJTSDJBZUc5MTRBV29IMEFpTG9ESUhjQzRxdUFjY2VYRlVJWTc3MFZRbGpBU2lsZGtpUysxV3I1dDcvOTdmektyL3lLUC9RZ2gvWnRzVGZmZkZPOCtlYWI5UHQ5bkhNQ1FBZ2g3cmpSdlpTUzJkblpPdzgwQUwxZUR5a2x4aGlHdzZFY0RvZjcza0lCRVJBSlFlTDlBVGcwRUxWaWxaeWM3NlN0T05hRHZITFhOb2RqNDV3QkRFZ05PSEExWUFHUDkwWkE3YjJ2Z05wYVcrZDVicXVxY2gvNzJNZjhYWGZkeGVYTGx3ODl5S0g5L3RyeDQ4ZFpYMThYMXRyOVVFZzBJZEQrN1kwUWVDR2tuNXViODMvLzcvOTkvOU0vL2RNQUhEbHloTWxrZ3JWV0ZFVWhyTFYzQWlNV2tIaElBQlZyMlRtMzJEdjZ0cE96WjA3T2Q4NzJldG14ZGhKTmV5K3lRdmo2RnovMStuOTc5dnIyaXovNjlyUDMzM2Q2L3ZHODl1WHJ0MGF2MzlnY3JEOTdZL1BxcU1pM2dRcW9nUklvZ0ZvSVlhU1VkbXBxeXUvczdQeWg5aUtISHVSL012dDdmKy92OFcvK3piL0JPWGVRSndBeWJYWGxRMi8vODNPdlBmZkpTWC8zalpIM3dvTjNNek16Zmo4LytkbWYvVm4rMlQvN1o1UmxLYXFxRXQ3Ny9WQXFCbElnOHhBZjZXVXozM0h4eU9NUEhadDlhcm1iM1I5cHNaUzE0dGs0UzJLRXdudUgxNEozWFZ6cXZlUEMwcVg3anM5OW9OdE9qa25uL2FsZXVyT3psUTdmZldidXRaV3hlZTM2enZnclg3NisrdEx1cE5odTNtdnV2ZmZPT2IrN3Uyc1BRNnhEKzMyMXhjWEZyOHF6OXhQb1l5Y3ZKQTg5K2wwL3ZuTDE4bS8yZDkvNGtoQW9LYVV2eTVMTGx5K0xPSTc5ei8zY3o3Rzl2WDJRZkh2dm93WWNMU0JyeDZyN2d3OGNmK0xKcy9NL2VIeGg2b2swaldmU1ZxS2M5K1JGU2Vrc1RrR2Nhc1o1eWJrekM0OUdVandjS1Iyck9FWG1sWWk5bit0b01kZWRTVTdkczlSNS85WmlxNitIa3pkZWMvNy9lejB2bnZadjVUQmVTdW1kYzlaN3ozdmYrMTQrK2NsUEhnTGswSDV2OXN3eno2Q1VPamprUWdqdHZlZWQ3L3JPdTZZNjJidVRXSDM4em9SNmIyOVBDQ0hjaFFzWCtQakhQeTRBNFp5VGplZElnQXhvUFg1Njd0U2ZlOXZaSDdod2JQYlBwYTE0YVZJYnFaTFlrMFJVa3hLa0lyYzFUZ21rZGRqU2tFVmFaNjJFV0VVb3E0aG1wK2p2WEVVb1Nhc1ZNUzVzL05rWHJpNnVybTB0VGtrbDVyTDB4bFplM0FDTTk5NDY1NXdRd3A4K2ZkcnRWK0FPQVhKbzM3STk5TkJEL1B6UC8vd0JRQURkZUFFZWZlSUQzN2UxVlhUamlKM200TmZPT2ZyOVByLzRpNzhvaHNPaGVQbmxsM0hPcVRzOVI2emwxTjk0ejdsM3ZPM1V3bytlV0o1NVNyZGJjVkdVS0c4WjcrV2lOaU9TYmdKU0lLWEdPNDhmbERCMGxLYkFUUmwwSzBGblhTYWpFZURKSXMzZXNCUWZmdVl5MTFaM0VIaWNrdzhlYTZmZnMxdlYvOTVhVysrREJIRGVlMUZWMVI5S2hNakRZL2svaC8yamYvU1BtRXdtek16TWlDYi9VQWloQWZuSVkrOWNUcnNMNzFsYlhjblhWNjhWQVRqc0orK3NyNitMeVdRaW5YUDdnRW9GZElEVzk5MS8vSUVuenl6OTlHS3Y5YjdkNFNTK2RYMWQ3S3p2Q2U4RnNwVWlVazFwYWtwckVjYVJHbytaR0dvMGs4b2dyRUZMamFzcmh0dGJkTnNKcGZWODdObXJYRm5aUmtxUUNpU3VvNHJ5ZTQ2MHNyTU5nT1BtQXBhN3U3dDg3L2QrTDRjQU9iUnYyYnozUFBUUVErUjV6a0h6TGh4MjliNC84YU1QNXhYblZtL2Z1TG16ZmNPQ2tPQVB1dC83eWJqM1BtbnlqYmFITGpCMS91ajAyOUk0dW1kblVySTltSWk4cmttbld1alpOclFqb202R1R4SlVxcEZKaEphS0Z0QlREaWNzMHNONHMwL2RINkU4akNjVm4zemhCcGRYdG9samlZNFZTZ3VpeUtOOGZkK0NFdCtmeFZHM0FZa1dRc2pSYUNRKzhwR1BISVpZaC9hdFd4UkZaRmttdlBkQ0NISFF5SnViWDg3aXp0RW5qR0hKdWVxV3A1S2hIeExBY1VjaWYxQ3BhaWZSdEJiTXpMYlQyVzRTUCtBbGNXbXQ5eURpVm9KSU5LTnh5YTN0UHZsNFREdVdaRXFTYUVXczJyUTdYVmEyKzJ6MEJ4U1RJUkVTTFRScEhQUGlqUjFldUx5S2xCNnROVUpKbkFXSDk5TGJPUGJsK3hkaTlaRWJWVDBFWXVkY0xZU3dYL3ppRnc5SzFJY0FPYlJ2Mmo3OTZVL3pwUzk5aWJxdTkzc2VHdEFQUGZuOUo2M3VmbUNjRjZJcUpwdmN3WnU2QXlCeGs0eG43NzU3K2E1SFR5MzhpQmZpWkR1SnV0MHNPVmRiYU1VZHNaZjNjYzZ4TzhqWkhJN3czakFWU3pvNklwS0tWcFl5TzNjRVl6eDZOT0RNc1VYeW5RSEdPamIyUmx4ZEgvREd5cERhT3JKVW9XS0ZsSkxLV1lUd0lrcWt0N1U5UFpOa1QyMFkvMXBSbEJHZ2hCRFNHR09YbHBaWVgxOC9CTWloZlhQMjVKTlBjdlhxVmE1ZXZZb1FRbnJ2bFJBaTh0NUhpOGZ1UHEvVDNxbGlNaXB0UGVyejFad3AzUUFrQXpwdk96bC84bDFubHY5V0V1bnZWMmtVeFVvZ2hHUjZlcDVCN3RERkhrTnlKdEdFMmVtTXVhbFpZcVVvUndXVGNVbFZXa3h0dWIyMlNUV2FvQ1gwcHRvTUo0YVhWelo0OGRvT3dqaGFpVVJIQWluQTFqWE9XclNXSU1CWXA5UElQZG1TNHBjTG1Pem5JVFJFZ01NYzVOQitWL3NyZitXdjhQREREeC93cXg1NzdESHF1aFphYTlGMHZiWEh4OGVPblVqbUZwYWZTckpXdHlvbVpqZ1kxSUM4bzdPdW03Q3FmWHlxTmZjZGR4LzV5WFlVZjkrNHNsRlpHVitVTlNDb2l4SXg2Tk5SZ3FXc3c5MUhqekE3MVNWSlk1SWtKczFTb2tnekhJMjVkZnNhZGJWSGxrbTg4dHpZR3ZFcm43L01pNWMzY0xVREQ4Wjd2UGVZeWxBWGhraEpsSktZMmdubkViNHE3dTFvZVFSUUl2QytoQkJDTk94Z29pamlneC84SVAva24veVRRdzl5YUY5dFI0OGVaWEZ4RWEzMUFUdjNGMzdoRjBSWmxoaGp4QjI5RDNYcTdNWGxoYU4zUHpRYzU2SW9DamNjRDJ6ak9lNWs0R2JUYWRUN3N3K2UvZ3RMczFNL01EWStWbmk4RkNKS1k2d1UzTmpjeEk1eVRuY3paSktpYk14ZXRZdTNCaThqZk8xSWxVUzNFMnJuaUZTRXNQRGM2eHQ4L0xWVmhnSW1XVVErcVVnOHpEbFBXVm9rQWgxSnBGTFVsYVcyQW1NOHNhWTEzMmtkdlRuTVh3U2lKcDh5Mjl2YisvMFEzK2wwV0Z4YzVNaVJJNnl1cmg0QzVORGdneC84SU04ODh3eS8rSXUvS01iak1Vb3BBTEd6czBOREt6a2dEaW9wOVlYNzMzYkJrSnllakNwMnQvYktRWC9YM2hGaUtVQjNFcDMrdFNmdi9wTm41M28vUHJHK0hTVVIxSWFpc2tnTWRWN1NINDhZMUJNV2wwOWp4a01teFlDa0sybGJpYmVPL3Q2QVdFdHdsakt2RVZMd3dodGJmRzQwWXZwUG5HVnBxY05rV0pQdjVyaU5DZTd5RHZXd1FCYzFrUUNuSE01N1BCQnB3UHNJNjQ2RVNwYXZnTmg3YjZ1cVFpbmx2UGYrRTUvNGhMOTgrVEpDQ0gvczJESHF1dWJJa1NORVVjU3p6ejU3Q0pBL2pwYW1LU2RQbmhUUFBmY2N4aGpSc0hUMyt4bjdPWVVHNGlUTmt1T25IM3hxczE5MWhCRGUyR3ExeVB1ak93Q2lFVUw5eEdPbm43ci8yTXhmSzZ5WXFTYldseFl4TG1xc3RTanYyWm5rOVBNaFR6NTZtbWl4aHhzVnBIZ0VEcm52aXFUQ0NDaExnM1B3NHJVdFh1eDZUbi93QWJMWkREeElJVkJTVVJlV3ZiVWg1VTVPK2VZTzlkVmRpbHQ3T0FOYUNZenp2ckpPUmNLZDBGcTE2OW80QWRhSFVyWnlnUjFzYjkrKzdWWlhWNTJVa2xPblR0SHBkUHpTMGhMMzNYZmZJVUQrdU5ySFB2WXhCb01CVlZYdER5cmR5ZEtWaEw1QjVMM1hkOTk5WVZaa0N4ZDJWd3ZWYVNXZ0lxRjBMTytzWU9rb1VpMGRuWjcwUjhlR3RjTWtxYkJPb0tRR0JLWDFyTzMxZWVUY0FxZG1wNmdyZzVZQ3ZLTW9hc1lXcGxKSkZGSm9sTlo4WlhPWDY2Y3pqci96T0hFV1lXb1gva0FQd2pwMElwZzcyVU9jbk1JK3RFaXhYWkMvdWN2azlXM0dsOWFwOTBxOHQwb2JjNndWUlRQOTJsZ1Bwdm4vMjZmR0crOTk3Wnd6UWdoNzVjb1ZueVNKMjl2YjQ0MDMzdkJTU280ZE84YkpreWQ1K3VtbkR3SHl4OEhlK2M1Mzh2VFRUeU5DWnI2ZlE2ZzRqZVhqNy95clo2dXl0czkrNW45Zm9hR2lIemwrOTNFcmtvV3lHcEFtTWNZd0kyWFV1dk0xVFZYNU4vY21yODFGclZ0U3VGTW1Od3hMeDhTQWlqTFd0dmM0ZDZUTGhaT0xlR3VSM2lFOGVDR1JRbUtxR2l0QVNFRWtKYTl1RHJoMUltWDVIVWV4Qm56cGtGS0FBT2RCaXNDWlI0SjNEdWM4MlV4QysyM0wxUGZNTVh6c0NMM1ZJY1gxSFZGdjFvdHUzRisrNTlSaS9JSEg3N24zU3k5Y1hYMzJ6WlZiTkhSNDczMEJWTjU3NDV3elJWSFk2OWV2TzVwSlJxV1ViN1ZhdlB2ZDcrYmVlKy9sNTM3dTV3NEI4a2ZkMnUyMm1Fd20rMFJDRGVnZi9XdC9ieXFLbHYvR2xUY3Vmd1pZYndDaU96UEhUNHdMUDFYWHhrdUJ5TEtrRmFkcDNMelVRZFB0MmRYKzFmdm5XcS9NUmZKVUhDbThyUmlOeDJ6dDlSbU5TNkpqTFY2NmRJczRVU3pOOWVoTmR5aU5wU3dOa2ZmNEtFSnF4ZWJPZ0RjVFQvcmdBczRDdGNQN3QvNGdWMXVzRktoRW9SRnZGWnFsd05RT3A2Rno5elRKUGROQzUwZHA3L2hqUHl3N1AvN1FzWVY0Y1c3MjJPb0g3ci94K1JjdS8rYS8vOGp6bjNuMXh0WnRJQlZDbE9CTDczM3B2YStGRUlZd3FlaTJ0clpjdjkvbi92dnZ4em5uRHozSUgzRjcrZVdYUlZtVys5NGpBcEVJS2VUeWtidmVPek56L0IzUGYrR1RId1ZhM3Zzb2pxUHU4dW1IN2g4VnB1MmN4enBQbkxaVWtuWWkzbW9VV2tEZDNCNzBiL1dudnRScVIrK2Rpa1EyMTAxRUNjaW9SR0s1dWI1SHJBWHRWREdvU3VhR1kzcnREQ1VVaVpURVdVSi9sUFA4YUlKKzZnaTZrNEVRbE00Z25FY3JnWFUyMEVtMFJPREFDNHoxQ0FsQ2hUY1RkU1ZkRlhFNjdYRCs2QXgzM2RlZFRxeDRYejRjTXg3djBjazQ5ZTVIVHo1ODEvSHA3M3orMHZybmZ2a1RMMy8wMHUyZFZjS2dWUW1VM3Z1eUNjUE1lRHkyZ0gzMjJXZjUzT2MrdDM4cEhBTGtqNnJ0N2UwaHBXeG1ORVFFUG5uOHllOWVXRDUyejA4TkIyTzF0bnFqSVBDbzRpUnBkMFV5ZmJheWFDRUVVZ3E4SUZWS1pSeGtCTjRCdFhldWVubG44dHpKenZRdE9TelBKVm1FcUd2eTBRU3NaVkRDM3A1QkwyVWNmL3NDMndKT1hLOVlOaEtkYUtySzhNcGtSUFh1b3lTTDdZQS9MNmlOUThjU0xUMUtDVVNEU3dlNFpxQUtvTENHMlRqbG9mWWNGMXJUSEk5U1hGNHc2SSs0M1ord3V6Y0E1K24xT3N6T0wzWm41aGVmT25mbXhNTVBuRHYydGhjdXJYN201YXRyejMzOGkyOWNMWXdiTk41ekh5dzFZSXFpc00xbHdCM2U4eEFnZjFUczhjY2Y1OWxubjBWS0taeHpLaVRpWkZLcStORzNmKzkzRVU4OXVEdmFmdFBZWW45MkkxbytkcmJuaFd6SGtTSk5OVW9JVkJMSk9OTDdpYjF2RG8wRHpMTTN0cSsrNzlUOGMxMXQ3d0prS29TZ3JrbWx3T0laZTBmci9BeHVQcVZPTkJ0WlRmcmltQ3lIdGQwaFd4YzZwSXNkWEdFd0NrYTVJUktnQXpBUGpxVlNna1FydlBkTUtvUDBrc2Q3U3p6ZW11RmtsRElaam5oOWJaM056UjJzdFN3dXpuRHVuaE9rV1p1cU10UzF4U05JWjlxdGR6NTUvdDFQUG5idkU2dHJ1N2UvODIzM2ZPTHByMXovalE5Ly90THJvNkxxTjBBcDdnUks4K1gvb0VHaURvL3d0OWVPSFR0R1VSUWl6L01tdEFxY3FRY2VmUExrUSsvNmtiKzFsWXV6a2ZKMmUrWHlWMVp1dnJ3RlJQYzkraDFuWm84Ly9CMmowaytYeGpVWnZiY3IxMTc0MVByS2EyK0NxQWl6NEU2QWRONkxYcnRWbityRmowdnBwN1JXdnF5dHFDcERwQlR0KzJZNThzZ1NjYUxRVXFLNktmbTRRcTNuM0Q2Um91NWJ3RThzMW52UWlpaVNSQkZnUE1xR1JOMUwwWVJiSHU4OHkybUw5OCtlNGozVHAwZ3JlUDNLTFY2L2ZKUGQzU0d6TTIzdU9uT0VwU1BMdEtlbXlkcGRCQTVUbG5oblJaSm9wSkRnblc2bmV1YllmUGYrVTR2VER4L3BKaWRNYWFyVnZYSGZCdzdYblVvclgydS8zYThmZXBBL0xQWWJ2L0ViL016UC9NeCt4M3kvY2hVQitqM2YvU1B2NmxmUmcydkRBZmVkbkZxNDYvd2pEejM3MlY5OHczdm5uR2pOVGtyZkdSVTFDRTlSV2ZCZVF6d0hUYlFUK25MV1F5WEFmUGJxMmd2MzlFNTg1bVJML1hCdWpHckZFUnJGc0tlSTdsL0FacHE2OHRqY2dMRG9xWWlKSHBCZE9JYU1OWFZ0d3JpdEZtQWRibUx3ZUxTV3FFaWdJMFZlR1hyRXZHUHhGQmZUSG5GcHVYSDFKbGV1citCTXp0SGxHVTRjWDZMWDY2RjFqSmN4U2tmb1NKT2tDVHFLS2Naanh2MGhrMUV1aHVPQ3phMkJINDZyMk5UMjNGM0w3Yk1MNzduN3FZc25adjdiUjU2Ny9qOVcrcE9WNXZQS204OXVYeUJpMzN2NlE0RDhJYmZsNVdXZWVlYVpnODQzRUIwL2ZucU8xdEczcnczSzdyQTBmbUpFdEh6eTNOdVhqMTE0WnZYV3k2dDFWYXJ4TUNldkZYRXJDUm01ZFhnbjJxRmpFWktRNXFEVUNNcCtYdVhQckEwL2xCN3AzaDJiK25GcEhiVzFUTTdPVVhaU1RBN08rY0Qva21DVENIM1hGSEdpY01ZaVlnSE80ZkJvNVZFZGpkUUM0d0VwY2NKeHBqZk45eXhlNUpoc2NmM3FWVjU4NlUzR2s1eVR4MmU1Njh4cGVsTlRwSzBPUW1pRWxqZ1hRalR2RGQ3WERQZjIyTjdZNGZiS0RqZHViWlBuTldta1JSd3BFQUlwcFpydUpYYzlkZC95M3p4OWZPcngyN3ZqWC92OHErdWYrOHFWalRVZ0VwRDdrS05VVGNqbHZ0MUFPUVRJdDltTU1ZTEFaTjB2NzZyNzN2YjlkeHMxOVdCUk9tcnJHRTlLZi9ib3FidlBYWGppZ2RWYkwyK05KME14R3VWMlVrZFlJTzBrT0FRb3ZkOXd1ek84Y041akFQdk05YzNyQzRuODFjY1hXbWZLYmpTM3RwUXhXZTZnSzFDcFJHa0pIblNrTU41VFRxVm9ZOUUyZUlwSUNXSUZyb1FrVnNoSWdna2gxaG5kNXQzeEF0emM0Sk5YYnpNZTdOSHBkbm4wOFFjNGN2UUkzaFFvclJGU1lhd25pZHRnS2liREhYWTN0MW01dmNIS3lnNGJHMzM2bzVKdUsySjVQbVc2azZJalJacGx4R2xMS0FrNG56MFN5WGVOSi9VRDc3aDQ4dlAvNGFNdi9mdVB2bkQ5S3o3a2I5cDdaSlBNMS91ZndiY0xKSWNBK1RiYmh6NzBJYStVdXBOOUcwMHRuVGxYaTNTaE5FTzhkYUlvS3Ara1UrbVp1eDU0NU9uZmpKOFZJdTU1Uk9ZODFLWEJ0eE5Va29vbzdYU0ZVQktjL0pyNE94d083M2x1bUYvajR1eWFXY2ptNnVtVVJFa2lLWkFJZkpObzc5ZkJTaW1vY2tNYVNSSXZtVTZUMEFqVW5qVFZPQWxLU082eE1RKzZOcU5yYTd6NDZpMmlSUEhJSXhjNGNmWWluWmxGdkNzdzVRUXBKYzVaNGtTREVLeXZyUExtYTVlNWNuMmRmbjlJTjRzNGNYeVdoMmU2ZE5zUmNhUlJVaUdFSUU0em9xeUhNUjVUMTJJMEdQb2tLYWZPMzVYOWliLzRBWGZ5N2lOVHYvUnJYNzcrOGFzYi9iV3Z1U1NxYjJmeWZnaVFiNk45NEFNZitOcUVVa29wZGJmVE82YmpPTFBXZWxNN1VSUzF5Q3ZEOG9sekY2Wm5qaXpYVmEzcnNwSkNSamc4MWxxUFNHajNGbzlHVVJaWDFYaWZSaVh2eUcyVVRuWFVmV1R4SFpzTDZWbHBQVmxoMFZvajJTOFZCNUE0N3ltTUN6cUpFNFB0UkRqcDZUcFBta2hhN1FTcEpNTERBMVhLa1NHc2IrMndzZFhuMU9sRkxqN3dBUFBIN2thb0JPOExYSldqbEVZb2pTMExkaloyZVAzVjExbTd0Y3JPM2dBZEN4NjhlSUxqUiticFRVK2hkSXlwRFVyR0NLbW95eEpuTFZWdEtmSUtIV1hFYVZjNElySld5b1dMeWNXWnFmYnhrd3N6VC96YXM1Zi94U2RmdmZYeW5SNjBBWVk3Qk1nZlh0djNJSEo2ZWk1dXAxbTM5T0JzZUo3ajBySTF5Sm1lWFpvNmV1S2hlL2RHdTV2V21vbkR0ZTNFVXJkaVBFNmd1MGUwYm5lcWFyUjdSMDZ6UDFHb3o3enY1RlBUSjNwLzJ2U3JyTFllcFJTMjVkRmU0TDFBS2hFeW1PWWsxYzRqU28rS0hWWko5aVlHandZcGlDVThwbG9jMzZ1NGNYT1hTVkZ5LzROM2NjL0ZCNG15R1lTS3daVGdIVjVxd0ZBVkZWZmZ1TUxsTjY0eEdnM0pFbmpvL2hQTXpjMlFwVEZLUmFnb3dudUIwaEZLUmxSVmpYR0s4U2dIQ1pGV2FDMm9Ta3VyMnlQSk1vckMwSnVlNlYyOEovcXVXS25GZHBMOHJ4OTU4ZW9YclhWMzVpRDdaV0IvQ0pBL3pFaVJTdWExazg0NmhBaWNwdUdrWkdkWTBFbDcrc1E5ajl4OTh6Zi8zUzFuaTZHejJZSURwSkpZNTRWT3VuTlIzSmxqc242N2FUYjZwc3FUbkhoOCtlN0Y4M00vWm5NM1g1ZkdneERPZVVycndYcThCZUU5VVJST2xCQUNJVHpXZUp3RFQwaklKN1hIWXVsNXdhTDA3R3oyS1lzSjkxNDR3NzBQUGdveUN6emdlb0t2SzNRY1k2MWhiM09WcmJVTmRuWjM2ZllVODB0SE9IbDhtWm5wV1VhakNmbGdGNkVNV2tZb0JmbHdURjROS0V1TGNSSWhJNHl4U0dtcHlweXFDRjdGbG1PY3FYSGVVK1pHUnNnSEh6czI5My95ZGYzLytyV1hienpOYnhYVi9uMzFKSWNBK1lNMnFWRmF5VWdKbEFpSHNxb011Nk9TNlU0dGwwOWVQSXYzWHpMbGNFSXl6VlF2bzlkTlJGazVaTnpweGRuVU5Ic29Rak5OQXBGVW9uWDY3VWMvcUJOOWZyZ3p4bGt2cEpKNEI2WjJTT1BBT0pBZ3BRd05QeUVRVWxCNE1MbkJ0alRPUTIxQ3dqNHRJOUlLZHEybE81Vnc4dTY3MEhFTDV3VkNXSVNPc2E1bWZlVTJtN2V1VXd6MzhBS1dUeHhsYnZrNGFSU2pCT1NqUG5HU0VjK25PT2N3ZFUyUkc2cGFVZGNXNjROVHM2YkFWQlpiZ3hTT01xL1l5MnMyTnZxc3JPMnd0ak5tYUN3RDc2VVQvb0dwaGVTN0l5MWZxbzNicitidGcrSWI4U1MvNWZlT1Q4VWNuNHI1L0kzUklVRCsvMkMrbVNkeTFsYldPMXNMN3hIR0lwekhDK2dQU3phVENlMzIzTnpDOHZtanBoenNwUjNsank5MXhmeE1peXNyZlIrMTJtbDM3dVN4emRVdng4MURWb0ErL3ZqeXVXZ3FlWHZWcjVYSkRiWjJPTmVjQSt2dzFvZWVocEpJSllramhjSGg2c0RJcmNlR3RHTWdWcFRXNDJyTEVaWFJFaEpUMTdSN0dWRVVZZkk5ZE5JR0ZNSk91UG5HYTl5OGNwMGtodTdzQWtmTzNrdDM0UVRLVzhyaE51VmtoSzByVkJSUkd5aUxDbU04eFhnU2NpR25xQ3FMY3pWYWhzNzkzczZRSzlkWHViSGU1K2J1a08yNlpKeEt4SHdiMzh2SWhSQnVVb3RxeTc1dDVzejBnNXR2N2p6clBlN09LK2hyQVBPMXdQQmY3K2ZwVFBOUGZ2QTBUL3pUbHc0QjhnZGxmLzN2L1V2K3hmL2pyeExBNFIzZytqdWIrZDd1enMzWnRxblRST3ZLVkVqbktmT0t3VEFubTIyM1RwMTc4dlNWTjE5Y3orYnVMd1NraVphaXFpMVJIQ2R6Ujg3ZmQrVWwrYkhRUkFjVnlXanB2dmwzS0ttTzI3ckVHWWUzRHFWaytGbUFpaVJhU1pRVVlTMkNEZmxISU1rS2JHWEpSeldkNlFUcndWalBESm82TDZscXkxeWFoQ1RmRzd3cEVFb3oydDFrM045aHVoZVRUTTl3NXI3SFNkSWV5QXhiajFFNklXbEhDS0dvaXB3eXp5bUxrckl3VFdydHFNc0tVOWFNQmdWck8zMHViKzF3YWJmUHByVGs3UWh4YkJxVnhoQXJoQURsSUtzZExvc1FTcDVkVXVLblZLeit4ZHFyVzg5NDUvZDdUU1ZmVFV1NTAvYUJaTCttaCtKdTdwWCtlLy8zMS94aGlQVUg2emc0Ly9CN3hCc3ZQdTJiVzg1NDcrdGIxMTcrU212dTNIcVd4TWVMMGxEV0Z1OWduRmZrWlNhbUZrK2ZzQzkvZGxXNGFqd1lWOW5wRUk0SlFFM1BIVGtUeDUzWnFocDRnT01QTDU3cExyYmZqL0dwTFN6V09aSldqSTRVem5wc2FhbHlnNDRVT3BKNDR6QVRpM1VlcVFWQ0NGU2tLRWVHUEs4UlNoS2g2WGxOZjdpSE1ZNGtTNG1TOXY3aUJVdzVZWE45QTJzcWtuYkcwYnZ1SlVsYmVGYzE5N0pIeGhuU1M0Uk9xZW8xdk05eHhsQk1DcVJTQ0cvWldOM2hqZHViWEhNRnQ2UmhkMXBSTGMvaVk0WHlvU1hxdlVmNmtEODVBVEpXQ0FuSmRJWlE4bEVoeEUvcmR2THZWcDVmL1ppdGJFemdjSm1nb09MdnFKSUlQRGp3MW5zc2IvRzdET0FHaGIyek8rOFBBZklIRWxmRkxKKzh5T3R2QWNRQzVzMlhQbjNsK0wwZnVKUmtpOGV6SktJMmpzb1k4dHlUNXlYZHFhV2xoZVd6czhWa2ZiYzA4M09EY1FVZ2pQTjBwNllYT3QzRll6dmJnd0tCbkQ0NTlaRFUrdHhrdThBV0JxMFVXUzlGWlJFeTBaaktzbldyajdXVzVYUHp6TXkyUUFtVUZzMnVLcEJLVUU0Y3crMlNiRDVCT0ljeXNEY284TjZIRXE2M0NCbmhoYVRzRHhuMTkwaXptS1RUb1RNOUh4eGtuVlBuV3lBMU1wM0NtSnB5UE1RNWozT0NxalJFV2pMc1QzamxqUnU4bUE5WW00dVpUS1dJTENiMkFsRVpiR214bGNGR0N0RVFMbVhEc0hITzR5c0hFaEYzWXJEdDg4N3hVenpnM0szblZqL2huVzhCbFJiWUpGSm9LVVJSTzIrYzkxSUtXeGwvOEJ3Z1RCcDdxUHdkWUxrejBUOEV5TGNWSUpLcXJIeWN0RVNaai9ZNzNtYjkxcVhOd2ZhTkw4NmZYSHlIamxUbXJROUZmZS9KeDRXZmFrMUhDMGZPTEs5c3JPOWE0K3o2WHFHTHlpS1ZJbTIzVzYzTzdOTE9ObXRUeTUycHpsTDdmWG0vVEVkYk9YNWNFMlVKVVNjbG5rclFhWVJRa25TNnhjYnJHN3p4Mldzc25Kbmp6SDNMSkVtRXoydGs1WmprRlhWcEdXMlZ5SjRtaVJRNGlDS0Z0WjZ5S1BHMndsbUxqRkx5d3FDMHdIbEJkM29hcFNUNENLOXFoSy9BRzF3cHFjdWFLczhweG1NbTR6SGpVYzdsYSt0OFpYZUgyM09LeWVucEFBTHJFVDRVRmJSU3FBak11RVpMVHkzbFFlOUdOQzEwR1FkNkRBcFVKeUt6NlRIZ0ordlNLbmR0OThYN0ZyT2pwMmZTYzcxTUg0MlVTTWVsM2FpTjM4dGlvZmNLYzJWMVdOKytQU2czWGwzUE4zMm9BbGFONTlrUHp3NzZLNGNBK1RiYjYxLzVGRUxJL2ZLamFSNUcvWlhQL3NMSDN6bC85cjJTN3RzbEhpa1FFa0ZaV3pFdUttYVAzbk5pNWZhVjU0MHB6TGlJdFBNZVp5eEpuS1F6ODNQSGN0OVdVMGVuSHh2dlZCZTlBVmQ1aE5KRXZReXlDS3ZEN1NzbFpMMkVrdzhlWmYyMWRhNTkrVG8ycnpuLytHbHdZSzNIMW82Nk1oUzVnMjFOTXEvSkRWZ0hRaW1VbE5SRmp0UXhlTWxrTk1LWm1zcEswdDQwcmh3aDRpbGsyaUhTR2x0T0tFZDk2cnhnUEJneEdlWGN1cmJPYTdmWGVVbm5ETytmd21jSjJvQ3lEdU5Ec2NCSkVkNlRGTkNOMGQ3anZhUHdIdWs4emZRdlhncVVWampya0JxUzZSUVo2Yk5PaXA4NFA1dXN2S3VqSHRTUmJFY3lmUERDNDVYSFI3RkVRMVY3TjlndTdLWGJnL0xUWDdneC9PUm5ydzJ2OGRVYWNRZGw0ME82KzdmUm52dk1mNkU3czhUZTFxMDdsbkFpUWVqaDdtclI3c3hYODh2M1BJS1U3Y3E0L1pra3BJUTBiVVY1ZjNOa2lXU2NUWFdzdFRpZ2t5VmlYTHcwcjJmMm5rcG11dzk3SWVNb2loQmFvVm9KMFV5SzdzVG9SS09rUU1ud3ZMMFNwTk10YkdXNS9kb0srYVFtbTJyaGFrdFZXSXFpcHNvTlptS1F2Wmh6N1M3VGxhTW9jN3E5akttcEhuSGFCU2xZdjMyYmNqUWc2VTF4NU9neVFpYUl1QlhDTENIeHRnUVg4cXJCN2g0dnYzaVZqenozTXRmUEpOaUw4d2l0OENhczJoRmU0bnpUbHlGNEN1ZDlVeFJvT2oxNHRBeS9MenpnSGZzalhPRmpEY2dSV3M2S1NKMDY3bXdhV3kvclFCWUlZbllDNVlRUVNvbzRrcUxUaWZYcEk5MzRpZFBkNUo2bGRqUitkVHUvYmQxQmVHVVBBZklIWk9QQjFsdUo0bHNvRVFnUjdXMWQzejU2NmtKbmV1SDR3MlZaeTZxeTRjRUxpT05ZS09FWUQzZEdTZS9JZEZIVlFraEpKSVVhRjVkbVRHZW5FNldKU05JNENFZ2ppR0pOTkpNU3RUU3lPVkNxT1dEZWVid1VkT2M3Mk1weTQ1V2JHT05RT3FhY1ZKU1RpcXFzS0FZRlZubk9INXZuakU3Wkd3eHB0UklXbHhlUU9zSVl4M2l3VFYxTW1GbGNaR2J4R0NLWkFtL3gxUWhzdFQvRXpuZzQ1Sk9mZW9FUFAvOEs3c2xGV2hmbWNjN2hiS2lnT1JzVUdxVVFEWHMvNU5YZWU3UVFCNVJsSlVDS29NcklRZEx1RHBZMWdzZDVVRnBTUmhIOTJ0TXloa1EwY2tyTmgrb2R3Z3VQY1UwdVUzdUY1VlNNdUcrcG8xZGUyU3l1TjduSVFjSitDSkEvSUl2aVRIZzgzcnZtb1FsWmwyT2ZaVW4vMUYwUFBpQkZ1bGhVdGJmV0NlL0N2SGNyYThmai9uYUpicVcxRlVySGlsaDZCdm1MK0hUYngwa3NWS1NvZlZBZGlkb1JlanBCYWdGK253RFd4TzVDb0ZYNHRjNXNoM0tRczNOck8zaVBVVWsxS2hqdGpkaTlzYzNnOXBEamQ4OXpJVzJSand1NjNSWUxpd3NJQlAzK2dMeS9BOTZ3ZUdTUk9Pdmk2d2w0aDZ0SENLbnhwZ1J2ZWVITHIvS2ZQdlVzMlhjZVkvbWhvM2diQk9iTXdiVk80ejM4UWFVSlBMTDVFZ1Q2cnVBdEZSWFhxRkVlS0lrNXYxOWNDNlZnSmRteHNGNVk1dkcwQU9zOVZvVHYrMWVVOTFDVlR1d09hMTlWZHFZZFNUbDI3dk5ybzNyVUFNUUM3aEFnZjBDMmNPUUNkVFVtTEY5NlM1bDljL1hOeWFrejUxbGNQdjFZWVh4U1ZLYkJEN1E3TGVIS2tiTUlLYUlzc3Q2akpCaDVDWkh0Q0ozR29CVmVTbVEzSmwxczBlMmxKRXFFWG9peDdPOUpjS1U5dUkyalJCRkhFY1h1aFA1bW4rSFdnT0hPaVBIR0NMTmJVcTBYR0MxNDZPZzB1bmEwdXlrejh6TW9xUmlQUjFTVEVWVnRXRGl5aUpTQU13aVZJSVRBTzR2SmgyeXZydkdSejc1QS9XQ1BFNDhkcFRJVkRrRmxITUo1bEE5Q2RDQkNoNmp4SEhMZlMrQURSSHpqL1VTRENoRnlFZC9vQTlPVWd4VnZoV21SbGd5UmJCbkxySzFKbk1NMWJPWlFtUW96OThQY01DNnRhR3RGTDQyR0cwWDlpVGQzeWgzZUdzbzY5Q0RmVHJ2cmUwNFJkMkx5bllLc1BVMVI3R0tORVc4RnpranZ2Y3hITzdzbnp6NndtSFJtNzZwcXAyd3pkYTZWRkZrU3FUelBuZGNCSU1KYnJINEQyZXNqWkNBVzZsaVJkbU95YmtLaUZUaUxzdzdxWmx4WENad1A0Z3RJc0Y1Z0MwczlycGdNeGd4M3g1amM0RTF6dzJvWUR5YmNmWFNhbzcwV0RsaFltQTNTcEdXRnJVdWtkQ3djUFlLT00yVFVRZWdFb1FUTzFPQU1uLy9DeTd5aWRqajczaVBnSFhsdG1SU091bmJZTUlWRnBOVkJxT1djYjhiQWdtZkJPUkJ2NVIyaUdSTVRmcC81S1pCQ05zQUpUQUhuSExXM0dHZFFFbXFWVXB1VVNSK0dlVW1tUElxZ3lGTFZqa2xwaVlSZ3FSMGpOSmVmMnhwOTdNWmV2ZGNBeEFEdXNJcjFiYkp6N3o3R3JhZFhPUGErNDJ4ZjJxWFNLM2pxdDY2eHR4aW85dnFiTCt4ODhaUC84Yi9lLys2L2RyR1ZwT2VNY3hqcm1CUVZ2U1RSUW1pVUV0NGFJYnpMSVI2alUwVlZodHMzaWlVcVUwZ05SVmtoclFQcnNRMFpYZ3BCMUhTalVRcGJXQ2JiWTVTU0pLMllWaWZDMUJaalExd2Z4UXBpeHhldXJYUHY0Z3htVkRJY2wweDFVcHl6ZUMrYUcvd2d1VUpFR2E0ZW82S0V3YzR1MSt3ZUo5NDVSeEk1aklFSVNTUWRLRW5wUElOSmpYQVdJUlMrbVhJTW9uWWVJVHhlTmhHVW9LbHU3V2ZzSHV0ZFlCRTdqNVlScmJoRkorN1Fpaks2Y1pkTUpreEhYUmF6T1ZLVHNuTnprMnR2dk1ybm52c2t4NU9jRXpNWjFqaVVnL2wyUkN0V2pBcTNjWFczR3ZFMTVNZERnSHdickxPUTBacEphQzIxMkh4cFc3amFNcnc5RXQ1OTFVYW8vUzhoaE5BdmYrbkR0M29MOS96NnFmdS9aOW5ZcURlcExIbHVrRlpLSFdXYVNJT1VtTWx0NVBRQUtSVTZFZFFXaURVeWtzajlBOVhrcmxJSUZNME5MWUoyTGg2cVFVazlMdkVDSXFWb3RSTHF1c1pZaDFDU0pJNXB0Vk91VDhyaTFjM0I0UDZaMXV6MjdsQlBUL2RDaUtRMVdacUdNeVFrUWltRVNwQW9xTFo0L2ZJVnpDblA5R3hHV2I0VkRpa0JVa3VVZzFJNkN1dndYb1llUjVNamhNUkRJaXlOVndrVkt1c3R0a25NTzNHYmsrMGx6czZmNGVUVWNZNzFsdWdrYlNLZEVDbU5SRklWSlhWVlUxVVYyMm1IVnFUWjNodng5RE9mNHQ1QnlZUExIZVphQ2QxRW9hVXdnOHBldWQydmgzZmtINGNBK2YyMkgvdS9QTW96SDduSjFrN0I3WmUyeFdncnB4aFdJZDhVU1B4YmMra0lZbnhZbVJaMkRGcSsrTEYvOVhTbk8zZDA5dVFUMzE5VWVZd2U0aEtJdkpjcWxaaGNZTVNidEJjc0JvVjBvSTFIcFlJa0Vnam5zZGFISVJFbFFtRy9ZVW42aGczbWpLUFluU0Mwd05jaDVsZGE0d0FWQzVJa0prbGpzazdxWE8yLzhNd1hiM3o1OUx2UC9vV3R6ZDNsbzhjV2lhS0lPQTFIeDFtTGQ2RzBpd2djd2QyTmJXN2tHM1RQWnBqYVk1M0M0U0IwSkRET01iRWhwM0FPbkRjYzRNQWRWUHNRVGRQRFlsRE8wMnQxV1c0dmMySGhIT2NYejNHc3MwUkh0eEJTa2hjVDhza1lhVDFTUzJwVFkxeU5jVlhJK1pweTN2bXpaOWphM3VKTEx6M0xYZE1wOTh5MWZDd0ZnOW8rOXhzM0JwL3cva0FVNHJDVC92dHBjYXFhdURvODM3M2JZNFJBT09QRUFTakN1WTJGRUxIM1BzR2pFU1J4TytyTm5aMDZOWCswZTgvMGtleGtOUGNiTTlIQ2pwMmRtWURzbzVUQjVsQ1hFYXAyeFBFcTlWcE5yUVY2T2lWS05LMU0wMGswVldrcG11UW1pRkVMblBXWS9ZcVJnMnBVWXlZVlVrbVVsRWl0d3E1QktaQmEwVW9USDZjUmtWYlhWOS9jL3VYcnQwWTNMeDd2TGI2OUhmL1E3czRnN2JSaW5LdW95aHBURzNSZG9oSUgzaUJzd2FXcjE5bHNqNWhyVFZGV0JKa2dMNUJlb0VRNGdRNlBJNEJBdWxCbEN6aVRDQW14bG5qbmNjNnkxRm5nd1lVSGVHRHhmbzVQSGFjYnRSRUluSGRVZFlWM2pxcXFNSFdOTlFaakxkWWE2ckppMkIvUTM5dWx2N3ZINXVZbXc4bUlrMGVQc3I1NURDRW5QdEhDajQxNzg3TXJvMy81cWV1RE41dVF0NzdEZ3h3QzVQZHFXU2ZDQkhGL2Z2MC92Q0VHdXlYZWVlbTgzL2NZY2ZPVkVQWmtKSzM1ckhQa2dkbXpSeTdNUHJSNGN1clI2Wm5zYkJ5ckJTVkVLaUF5OW1XVitSQmlWSlhIeUREeTBPbzVsRFRrZTRaNlVGQkdJL1Jzd3RTNWVWcFRNYVl1aUlRSWdtL09JNXVTcXJPZ0dubmJZbWVDc3dhVXdCc0xBcUpZSTUwaVRqUnBGb3NvMGNQKyt1US9iMXpaZThGN3ozLzkxT1gvZkdTaE43T3d0UHZkV3MxS1crVEMyeXBjczg1Z3kzNlE5Qm5zY21WckZYMGhDdlB2c2dGaDA5K1FRb1I4U0VycVVMYkNHb2Uwb2Nxa0lsQlNFRXVMbERWM0w1M2pUMS84U3h4UGptS3JDbXNOeGhqcXVrSUlNTWJnbmFjdUMwYkRFZVBSbUxxdXFhdUtzaWlveXB5NnJpakw4Ty9yU0pHa0tRK2R1OEFKY2MyUFRYSGwxNjhOL3VuUHY3VDFqQWg4cklLMytGaUhBUG05bXRhQ2srZW51ZnBTV0lDemZtc2s4RjU2ZjZCL3RiOTVOZ0hTeFlzeml5Y2ZXM3hvK2Q3cDl5NmNtSHE4azhhTHdvbkVHeWRVQ0l1OHN3QlNPQmU0cDBHUjNTTzFRbHFMaWtHbkhqMVJGTHNUSnR0amJtL2xtQWVYaUdZeWxCUVk2NEtlcjlndnBYcWNjTlJqUXowcFFZbW1KQnRtUkx5VVJFS1FwaEZ4R3RXVFFmbkx0MS9lL0ZYdi9SQncxMWI2ZS8vNnY3LzRMNFRTclhkbDJUdWxRMk10Ulo0amtNaGlURXRLdHRZM1dCbnQwRXZiR091eHphWTRpU1ZSNG1DVlFsQ0tEd21aRHdPUG9YdnVQRXBMa2hnV092UDh5WWYvSEJmbkh5QWZEcGlNaDB5R2c4RHdkWjY2cmhnTmh2UjMrMnh0YkZGWE5YVmRvYlNnMVdwampLR3FEUG1rWURMT0dROUhUQ1k1ZFZrVFJ4a2pNYnYrN0xYWC9vLy84T0xXbHduQUtQaHF6UzBPQWZKN3RLU2Jjdm1GYmZBSTc1QWVydzY4aGdqNUJaNmtOWmZPUHZSRGQ3MTk2ZUxNRDB3dlpJOTJXMUZYMWxJS0pONjdneWsvaFJlaE1oTkdZTjErQjR5bTlrOW9aTVJ0amFsQ0I1elNrZTlNdVBuTVRXYk9MOUJlNm1JYlV0OStlZFExUk85eVdHQ2R4U3VKcnl4U0NyUldPQTg2VnNSSlpLdlNmbmIxMHZZdkZLTnFxemswRmxDdlh0dSs5TjgrOGRyLzJtc25rd3QzSC8yQXEzV3l0VDFpY1E1YTNSNnVITEMxdmtMZkc2WlZXSzlRMUFMdlFqazJkTHREbWRXN1p1Y0l3YXVVRnVySzRLV21oU2FKTk8rODUzdTRzUFFvZUkvU2dyckt5Zk14SGlqemtyV1ZOWGEydHFtcmlqaU5TVnNwa2RXVWVjbk8xaTVGWGxLVkJjN1owTEczZ1c4Q250cFpMdGV0MFhQOTlQWWRZVlg5dFFuNklVQytSV3QxSTF6aHFRdURzMTRHb3FuWGQzaU5ERThtdFdoZmZPK0o4dy8vcWJ2K2JES1h2a2VuYWtGNUQxWjQ1d1ZlK0REWTVCcW1uSlFIbVdwdHdxMGFhVWtxWTNTcTJQVTVnOHFoRkNTSkp0ZUtPZzhOTkZ0YVJwZTM4Y2FUTFBWUWVLeXhHT2VBMFBlb0JqbXk4UjZtSWY3SlNJSHpZWDdFKzB2Yk4vci9hdmYyOEJvd0pteXB0VTIxcmY3TTg3ZGVHK2IxUC83SkgzcGk1NjdqczM5NnR6OXA5enFSVDFwRzFHWE55dW9tSTJ0d0Fvd1RCKzN1ZlE5QlExMDNEcXJTNGNxZ1NXMUtTejZwRVFKS0FiM1pvenh5L0QxRVF1SmNpYU5DU3M5NE1tWjlkWU85blIxTVhkUHRkZWxOZFpoTUN2SnhUbFhVbEVXSk1RWlRHNnF5d3VJWWxoTjI4ajEyeDMxRzFZUnhsV05yYzFLMHhGMWF5T2VOUHhCL09Kd0grYjFhbW1rZWVzY0NYL3o0R3E3aVRuRHM1eGx0SUwzM2JZdW5ILzJCdS83VXNmT3pmMEsxNDFOMTVaU3JReC9BT2k5RW8xVlZHSWRzNnJMV09JUUxMTnA5VG9RMW5ycTJSQTJWWXFhYlVZd3JqSzZKRWtVNWxuaGp3amhHYVpqY0dqQjY4eWpabktaMWNoMXJnNXBpMmMreHhoTFdTVFYrU1Fpa2xtSFdRb24rN3UzaGY3ejk4dWFYRzJDTWVZditMWnZ2L29WTDY5Zi8wYi85elAvbnIvL3dFNU1IenM3K2hZM3RVVGZPTW5RcllYZFlzYkl6NWh3TDRBWGVoeWtPWjMzVFBaZDQ0U21zeFZZaGRLd3RURVlsK1c2SnFqMFI4UGFUNzJHcGN3U0h4WGlQOHdZaXVIM3JGdGV2WEdkK2NaN1pxWGxzYmFnckE4WlJWaFdiK1M1cm93MUd3ekhEblFGOUpsU1JKYThyS2x0aHJFRUtnVWdFdGEwU2wzSXl6aUpsSnVWdkgwWWZIdmx2M0I1K3h4R2VlL3Bma1dUZmovTmVoUFRnQUJ4WkE0N3NmWC8ybm9lZStzR3pQelcxMUhyU09oRlh4dmtvSW9EREM0enpPQlA2RThvSGRaSGFoakJJd01GM0pjTWF0YnlzRVEwYXBSTlk1OEsxSGl1a2twaUtmZWxPYkdXb05scFVPeDFFYncwVkdhejFWSU1jSVVOVlNVclJVRlhGZmpXcm5PemsvM0hsNWMyUEVuUnd4M2ZFNU82T3hpWkM0Sy9lM2wzL0ovLytzLy82Si83a1E2TzMzYi84bDlJc1dXaGxpMHpQOURDWGE0cUpKVzRKbkJQRVFpRmw2SVhnSEpHVHRKUm5KR3VNRGVPOTBubTBDMkdRcnlXam5aS1hyMytGbmNrcTE3ZXVjV3Z6TnFzYmExVGJGVWQ3aTV5ZW5TWVZDZU42Ukw4YWNYMTRtMnVEVzZ5T3R4am1ZL0tkQ2YzYmU3VG1PL1NtcHFoR0JtYzhXcXBRSGJQT2UrZUZUZnlqcllWc2VYSzkzQllDNWYxdkZjUStCTWczWVVMQzJRcy9nck5lK0pDTTc0T2pCYlIxb25vLzhKUDNmZUNSOXgvL2lhbTU3SDY4Si9lZVJBdmh2S0N5b0pDNDJtRU8wT0J4WGhCR0lYeXo3aXpjdXJqdzY3S3BTdFhXNHlxRE5SWXRCYldXQ0NrT2JtbHZMTTZkQkgwY200OFozNWdpV3JxTm5WZ3dCcVZsMDR3VEI2ZGRhV1hNdVByTnRVdmJIeXJIOWFBQlNIRUgzZUxPT1czdlBVNEkzTnJXMFAzai8vQzVmL2NUZi9MaGRhblUzK2gwMm1kUEhwdGg0Ym5JbDdrVkxoTkVLa0o2UmFZVnBYUzR1b1RDb3ZFQm1NYlRsdENhYmxPMkVxcks0UXZQaDUvK0NLKy8rakxLR2paM3Q3aFdyWkcyV2p4NitpSGVmdlp0SEdrdFlrdkQxc1ltYjc1K2srYzNYbU50dElud0F1a2tXc1ZFU1lJcFRXaEFDVUdWVjNqamc1U1FzY0xrdFJkS0hKZlNud1JlYVFvcjhtdWYrU0VYNjVzSnIxb1IyNnRqVVpWV2VJZHVRcW9NNlBSbTA5bS85bjk5KzUrNy81MUgvOWIwYkhwWEZDbzB3cmo5Wm5CejZCRkVTak9wSE9YK0pDRmdTb2UzQVF4NUZjcWVsZlVVZGFCVTRBZ0FxQjNXT2t6bE1JV2hHdGZVaGNFYWc2ZEZGSDBYWm1qeHBzUk5Va3EzaHEwSHFFWWdHcHE1YmlHYXhKWFhWMTdlL09jN04vcFhtdEJxd2xlTFEzK3RyS2VIQUJKanZmM1NxNnZYUUY2WFVsVHRSRTN2VnFNdXAxS1J4aTBTbWFKbFNxSVNuQmVVcGNWN1M1eEswamlzWXFoS3FBdkxZbXVKUnhmdTQ1SGVPUjZhdVljamFwNGxzY0JzUFVYUHRIbi8vZS9odmVmZXdWdzIyeWd4R3J5SGhkWXNwenJIeWVxWWplMXQ5c1lEQkFKYlcweGwwRm1NbWRRVWc1eDZVbEtYaHJxc1ExSEFleWtqOWVKNHIveUtkNzcrZXBmQ0lVQytRVHQ2cHNmTk4vdFVwYjF6alVFS2RIb3o2ZlNmKyttSFAvakFFMHQvWTdvYkxVYWgzaS9xQmhCaEpFUGdnRlRGS0JsUlZJSDdKQnVHNjJSY29aVU1oOWczcW9jZU1DSDB3SHZxeWxJV2xycXl1TXBTREN1S1VZV3BhcHpWdER2dndJMW1xRWRiQ0NHaGpuR1ZSdmYyRU5vZDVEWXFVWUcwV05tTnpTdTcvMzd0MWUwWG0zeGpmK3owcTVwbGQzcVFPNzRPcWowdlg5NVkvY3lYcjcrMHN6Mis2dHUrdFhEdjlKRXNiYWxFdDBsVWhpQUtCRWtLT2xNQ0hVVWtxV2FxSGFNamVPTE1PL21SaC80TTkvUk9Jb2NHYVp1SkFDV1FrU0p4bW5Jbnh6a1g2TWcwZzFVdWhHM3pNL01jeWVhWUVXM2NwR2FydjhOb01LWWFGM2lsUXRnNUxyRzF4VnVMTVFibkRONTduMDFuYnd3Mzh5ODY0L1pYd1gxVm1mY1FJTitnZFdjUzhuRjlaMmlWSU9qb1NMYi8vTjkrK1BzZmVzK3gvNldWcWNWSUtrcmpHMG1xd0J4VkluZ0ZZNkd5bmtGUlUxcUg4eUdmS0V6b1I2U3hScUpDcDltQmRCQkxTUnJGQ09lWlRHcktJb2dhVkJORE5ha3hlWUczTGVhUC9Wbjg1QWlUclZVOE5sREdoWUs2ZzRoQnRmZkNVNWNDbldvZlJScS9PcnBjWFJ1OFVGUnUxeGc3NXExcE92czFYdU1neXZ6NmdCRXlMMnZ4MHRXdHphb3JSdysvNzlUalNxZnRTS1lva1lhcWxkOGpUaXFVMUZpcmlMVW1Wb0x6U3hmNTRHTS93WFRjbzZwS3FycWtLSEpxVTlIdXRDbXJtdExXbEZWQmYyZVBNcytKRWtXcmxaR21ZWXB4WjJ1VHE5ZmY1TWJ0YTl6Y3VNM05qVFh5d1Rnd2ZBU1kybUtMQ21jTXpqcXNEZGhXa1NSdUoxY0c2NU9uclhINTEzak93eHprRzdVZi9wc1grZXhIYmlLVkVOWWNxTFFuZU5MSDMzdjg3Q05QTGYvNWhlbDQwVnZ2alVOb0lmRkNvS1FOOHcwTm5jSTNVcUNWOFUzM1hSSXJCU3FRREpXUTFBMjR2QTBDMDRsUVpJUndLRklDR1VkTXlyQUN6ZFFHVDQvMnpIZGcrbDJHSzlmd1Fka0dzVjh5dGhhM3ZRaWRDYVNyZ2RLaGxZaUdPWjNSK1A3V1lyUTBQeE45ZW50Z2YrM0tqYjBYd08rREk3K2plblduTjdsVE1Mc2g1bnVMd09DeFRrbDJLeWRxVTFFeG9kMkd3bzZ4YWtUa0ZWV3RVRUtoRUxUakxrK2UvaE5NcGRPTXh1dGs3WlNGNVdXVVVnd0hRenllK2NWNWVsTlRsR1ZPTWNyWlhObGdiMnVIaTQvY2g5ZWF6My9oYVo1NzVRV3VydDFrWXpMQVNsQkpCR09CcVdwa0lUSE80NHU2VVE4WFNDMlFTaEdsTVZMS3I1VXVQYXhpZmZQWk9jd3NaR0w5NWxqYzBTVlBlak5KNS92KzBya2ZYMWpLN2hjV1VkdVFFQ29sS0t3TFUzd3lsSEsxa09STlB5QldNakJjWFJnZnpaUUtzMEFpOUVhcU9vUlVrUWRURy9iS0VFWmhQYW1LS1lSRFNvL1V5eVM5OTJCM0phUE5ONXROVmg3dmcxQU9Rb0h5MkVKUTNyNExmY1JBZXpPb3ZHOE5LQVlqcGFKb3VhWDVJZDBUOTgvY3QvUkxOOVpHbjlyYUdkKzZZMVYxY1VkY2Z1ZU9kOTM4dkUrbDBZQXNKc2FNSjhZSlU0V1l6ZWU0dUVJN01IaThFMFJDZ29NemM0OXlySGNYM2hURVNVUzMxMElyUlZua3hHbUtxeTNqd1lpNkxGalpYT09OYTIrd3ZybE8zaC96eXVvbEJwbmgrVmRlWkRJcXlPS0VORW1wZmJqODR5eGx0TmZIR1kycERMYXFhYlVTVkt4UldxSzBRaVhhbWNMY3RMVXJ2MTRQNUJBZzM2RE56bWZrbzVwbXJrMEpRZXc5MFR1LzYrUURSMC8zM2xOYmRHMUNJaDRyTU00VGlkQ1FtM2lIYWRaNWFCeENDQ29Ia1JRNFowUEtJWm9HV2pPU3FrWFlCWWh6elU1QWk3QU9aeXlWQlc4TEVFc0k5WDdxMVlweTl5Yk8yNE9SVllFTUhDa0VNdEVJSWJCNWhGZy9qenhXSXJBTjQxZFJlVTlWRzRtUUY3cVIvT243VDNlL2MzdXU5UzlmdmJMOVRHM3NQaVcvYWc3UW5lQzQ4MnVmVWhQWHhrbGJPcXozT0JWRXB6RWVyMElGVDN1SE1SVkx2Wk04ZlB6OUpETEMxamxhYVdTN1E1UzJTVHRkM25qcFZiNzA0cGQ1NmNvclhOOWRaVHZ2TTZrcnZQVzQydlA2cFMxYXN4bnhkRVpsd2hDV1FsRFZCdXM5YVpaU2xVWElBSDF3ZW5FN1JrY2FLV1VJTlNNOUdteE1YcmZHbWNORzRlL0IvczAvZUo2NmRrR1dLZFRMb3poUjJaUGZjZnlkS3BLejN1SlZVTXhvSEU2WTRLdXNvNm9GV3NpRy9oRldrcWx3ditOazBJSnloUDFpU29UVk9FNEs4b2FqcER4STcvRlNZbkhVZFVsVm42TXVIcWRjR1dQNnEzaHZBNWk4UTRoQTh3aXFoQWFjUXVrSVl5cHNJUkIxQkw1R09FS25XVW1FYzhJTFQxbFZuVGp5VHk1MDQ0WDQ3cGxmdUxvNitlL2IvY2xXQXdDSFFDcWR6QUV6M3RrRUlUTHYzSlIzZGg0ZjZCcDc2NU56dDk3c0owZm1RWGNVVVNIb2RTTlVyUEJPa2tZZ25PTGVJMDh5bTh4aXFzbUJieEk2eHBpSzUxLy9Nci8waGYvS0M2OWVZalFhSDh5RUtLbXd4aUFGR0dQSkJ5V2R1UllxVWhTakhBVjQ0M0FpWEJLdGJndnZMTTRadElZb2laR0JSdTlWcEVSZHVSZUcyNU9YRzBEYzJmTTU5Q0RmakpXRlJVZ2hmR0RvYWtDZE9OTmJtRC9hZmtnSUVjZHlYMmFnVWN2d1VGdVBzU0NjdUVONVEyQ3RhNlJyUVBwQTI5NS9DSlh6Q09NUk5oQU5TeGZVTzF4RC9WWVNTbnNmeGVBeGlxMENxakVlUjFGTW1uNkpCS213M2lHbFFzb296SG5Mc0k5RFJFT2tHaUdzd0NRS1QyRDhldSt4M2hKQTRxbU1PZHRLbzU5NjRHejMzc0U0KzlEemIrNDg3NXczT3M3bXN1N3NUeUhFUTlZYWlmZVI5ejV6dG03amZlV2NyWWJyZGV0ai8veWxYbTgySTI1SnBJTGo5MHpUV2Nob2R5TE8zRFhGeWFYekhHdmZod2h2TjRTQ1VqR2VWSHpzNlYvbFV5c2ZaMjl1UXJLY1VWeXZNWVVOL1l2SzRHdUx0eTZJTGd3TGh0SkQ3VERXSEd6Z0ZSSnNiWWhiTVNoSFZWcDBGSU1VRURTS2hWREttTHArcHB5WVFlTWg3NVFlRllkY3JHL1FubmpmVWI3d2laWDlNeTU5RTJJODhkNWpwNUtXUGhMSlpsbGxNeFdWNmhUcm9EUTVTZ2kwaEdKaThJMk16WDZXS3p3WTY0aWFwMUU1RjFxNTNsTWJGenEvQk5xSngrSjlpNnA0Z04zTmMrUzdCYjR1OGRaaGJjSEMwaFRqa2FNcXl5Wm45bGhiaFpLdVY0RlNMc0dJTlp3ZFlhc09ZcnFOMUtHejdCdVBaNTNGNDRTVWtzcjVxVTdtZjJpbUxSWm5POUUvM0JwVUt6ckpIbFJ4OGgxQ3FrVnByZmQ0c1MrMlFBTTA1d3hWNmRsYThRYzA5eHN2cmVPOUlXNUY5S1lGTTUycmZPcmVWUjU2OEY0V1ptZTQ5L3c1dXAwMlg3ajhPVjRZdlFBemttUWNrL1ZpaGkyTkhWWFlzcG16RDUzd1VDV3Nhc3h1Mk1ZclRQRFFFQnFzaUxCWFJjU1NMSXVDVjVGaDA1WlFFaVhrVFRlMHo5bks1bCtuNzNNWVluMmpacTFEUnpKMHo5L2FNNmlQbk9tZHpaSm9VWGpaREFVRk5RMHRGYU9pQ3FPd1hvUlZCSVdobGdLTElGWXkxTys5Ui92bUFUU3IwV29iNkNmU0NweHplT1B3eGxLWnU5amVlcHpoWnB0aWxJZDVqdHF4T0ovdzEvL21YMFluVS95RC8rY3ZzN3R4TTRSYjNpUDJGVU9FeDltYXN0cGk3RitoVzBYaGRYc1pkUlNoeG1YZ1NEWU1ZT05ETHBSSXgzaFNjMnVyN1BRbnBnUE1KSEYyYnh5bE04NDc3NndObWlQZWkvMTZyNUFpckZYYkY4QlRDb0ZDT3hlMHJpSk5uanZHZzVLYk41L212Ly9hcjZPVm9OTnVreVNhNUxoazd1NFpPdk1kZXZQZG9ETThrMUZzNXFIWEV6YjlCQyt4TC85VFd5WlZTWXdrVWpGUkpNTW1MY0JMVHlmTzBLbG5aTXNnQW1BdDdUUzIwN0w3OUkzYm0yODBvVlgxMi9SOURnSHlPOWxQL3AxSCtkd252b3pTV2xoajdoeVpqWHVkWkxZZEoybGhiSmpZYTlReWRzc3hveUxrczZHYzI1UVdteFE2OWxCV0ZsU29jT0diRzlHQmFDU1ZwWEZvWnlocXoyRHdBSU85eHhsc1NxcDhoS2tNRkJYZTlQbkxQL2w5ZlBDSDNzWC8rK2MremU3MlpwaDhKVUtxc1B0UEtBazZRcmdKdzhscmVEWEM1RjFjWlJGS3NoTjNFYmRITE15cVJqOHIwTStGa3VDRnVMeWEyOTJ4dldLdE4xTHAyU2hPVHl1dEkra2Qzam1NQ2NXdE8xUWp3dzB0QkVLRWhaN0dHZlkxWE9yYW9wUkNSU2t5VXpqYnhwaWE3YnpFOW5OWWM3enh4WFdVRWt3dHRjaDZNZGxzaTJJbmRNRjFGUGFiaERtQU1BS2dJNFUwa2pLdlVZbEVaZ20yVVVjcGplR1k3RkFsRVVXNXkyelNwcU5pc2lTN3ZMTmUvR3AvUEJuYzRUMXNZQWdJNzk4UzFqZ0V5TzlrM3NQeTBiTzg4ZEoxOFRVbHpqaFNJckVFNFlGbWVST2p3alRpRzgwT2pzcGlqUU9oU0hYd0VyWXd4RjZUSkJtamZCeElpejZRRjdFQ2IycTg4UlQ1RVRZMzcySjc4elRGMkZGWE9iYW9rWFdOSDYremxWaHVWUW5QdmJ6T2h6LzhMTTRVeEVtTWpMcklwSTFNRXBBS2dXTnIvVk9NcSt1MHNoaGJtYUI0VWxrNng2ZFp1YlJCT25iRVNaQ2ZGMGkwRjl6ZXJ2eld3RGdQSGU4NXI2WHljWkllaTZLWTJsUjRFVHlDa0FINmdabHJjUzU0c0tCT0lsQlNIaWlnZUIvV1hrTUZWUWgzUUJCRkNWR1U0dkY0RjhEWDM2ellXNStBSCtLc1FRaEhGQWV0WWEwaHlqUkpTOU5KVy9SNmJVYmxFQUVZWjZtY1JRdkZrV1NhWlRGTjFQV2M2YzJTS3UzN1BpL1h0Z2UvOW9VdnYvN1NIZXdCRTJvbThvQndkZ2lRYjhBZWU5OE1yNzI0Sm54UUZaQjRyd0RWNnM3SHFOWjBhYzFCMTl3TGlSSVNoYWR1VkJLeVNHRmtrT2J4bGNYV0ZvUmtyamRQbEtSTVJqa21yM0ZhaFVOcmFpb3p4ZTdlUlc3Zk9NcHdrR0pyZ3lscnFBMnFOdmg4aTUydFo5bnBhbjdsTng3aXVZODh5L1hYTGhFbEtUS2JRYlI2UkswV0tvNlIzck4xKzNOczczMkJLTE5oUXJGcGxBMTNjenFkbUd4NWlzM2JXeHhiMURnY3NaSnM3ZFdzN2RUQ0JmYjV1NENId05mQXJQZU9TR2w4bklVUldobUtFeEtCc2lhRWhzNFN0SVE5Ymova3c0YzhiRDhEM3M5ZDhBYy83NHNUQ3luUmFSWjJlalRleW51SHN4WlRtOERwR3BUb3FHYlVxdWpPdGhCU1VGbURyQ1ZMOFF3bjJ2TXNkYVpKbFdhb3h0eklkL3lPbmRqZFVmN1JhNjl1L0hKdDdRRmpXWUJOMDhTZlhGNzBiOXk0ZlJoaWZhTTJOWDhYUlhFYjc5YkRtbGlFRWxMS2t3Lys0R01qdC9DTzJyNEJTSXlEV0FyYWtXS1VHeEloaVZRWUdKTFc0WHpRdUVKSW9rUlQrNXJSSUhDTGhBUnJMSk04cHQ4L3crN1dnMnl1dHhuMmh6aWY0NTBBWTlITzRDWWI3SzUvbnEyOTU0a1h2cFB0U3pmWTNiNkJUanFJOWdLMDJ1ZzBJbXNsUk1xenZmbzBhMnUvaW94R1NLWFJTcEsxRWtRa21kMHFtQjlQV0pwS3FPUXNVMW5FU0ZodTdQVFpHQmpLdHdxZUxhQWxnTm9aY0JvdE5ZbUs3aWc4aEE2UlZocWhvVFoxOEN4ZVlLd0p2QzlqOE5hRUEwL1RGRzJtRFBlQjRmZFRBQitBSWZ4KzMxNGd2RWJJQ0JrM0Y1S3plTzhaRGNlVWt3R25UODB6bi9VNDJWc21reEhDMnhEV0NzRjJPWEpYeTUxaG5idlBibHplKzZmVmJuMjdZUXJzejd1NGUwNGU5OS94OXNmNHgvLzJGdzRCOG8xYVZmU1lESS9pL1pzaWtOMmRhbmRuVlcveHd1TXIyOW55MHZDcWI3ZXM4SzRSRC9DR1RFc1NJY2lyY0N2R1NpUGptSmxzbHRGa1FHRU1lNk1SdFpIVVZadkJNR05uYjRHZHpTUDA5MmFwY2tkWmpMRStxTlFLNTVBNDZzRnRScVBiREk0dWttUVBzY2hSNHVFMm9yMkE3eXhDa2hCRm5uYW5SUnFWREFlZlpXZndNV1E4Sm80aVZLSnA5VExpVG94V2ttNWVJL2R5SXExSXN4Z0JuSjViWkNqbkdONTZFOStzeVZBSFhVQ1BxeXVNMHBnbWhQRUVZUVlwUXYxSUNSbHlrRWdlS0k3b1NEZVNweXFVV2dGbmJLT0RGYnhxMEN6ZTl5Wmg1Y0VCSmQvdDYvYnUxd21iVGxNVDJra2QwNWFDSjViUE05M3FoQ2FwdDFoYkk0WEFldXUwa1YvWnZUSDZwY0g2NUxQNXNMcE5ZQ3puUUNXRU1ONTc5OXJWNi81UGYrRGRIQ2JwMzRUOWxmZi9BMDdkODhoWEpXMVNLVFU5bFNhandWMDgvUmxIdDczTjdGeWZKS2xJWTBNM3JwQkU1R1ZNVmFVSUZDY1dqcEdJTHE5ZHU4cEtYNUxYTGNveVpqS09tWXhTakduampNUGFtc3BhakErM2FGQ2FjOWp4TGxQcGlQZDh6L3Y0M00wWWUzMkZxQmhnMjIzb3pxTzBKSTRnalFScG5ETXBQOG1nZUFhdEtwSTRRa1dLcEpzUlpYRVFiaE5ncmFWMEVMdFFlVERPVWZZSHZQK0JoMW5wR3k2OS91WUJoeVJxK3ZOMWJhbDlnZmNXSlhVakdCMlVTNFJVWVVsb28yU1NSanB3NHQxQitSalpaT3RlU29RSEpTS2NESXVCWEJPV2VlOE9jZ0JyQTdtUXBrSW1oV3hDcmlBMXFsVG81VVJTRVFtSk1UVmFxVVpBTDRpV0txbUxmR0EvdnY3bTNzZDRhNHg0c2c4T0tZVlBrNVR4Sk9mLzlzLy85U0ZBdmhuN29iLy9hYjc0bi8vUGdSSWFCbzNFcUw5dHRyZFd0NUxaZXhsdm4yS3RPa2JhRXBSMUJiSW1rcE93YnN4RTFKVkNTVUdXUkJURGtsRitCaWNqcEZKQnNOa0VZcUhTRmM0NlRGbUhwTDZaRS9GNFJKa2pKemQ1N3dlZndLWW4wZGUrZ3ZBQ04zTVUxV3FobENCTkZHbWtrSEtMV242YTJyNkdVaHBuSUlvald0TXRWS3FEQXFLV0tPTVFoY0Y0UjhzTDJtRjdEM1l5d2Q2OHduZGVPRW14dWNGNGIzQ3dsd3dWNDRYRW1lQlp2SzFDVlZRSWFzSjZnbHFHQVM3bmc3eWppbFE0c0VxaGxNSTYwM1N5SmRqUXR4TTZURFh1ODRlOWwxaHJpWFNFMHhGMVhZZUdaaU53dHgrRldWT2pkRVE1R1pCb1RhUlZJMm9OUlZnMFJMZlZvdGRKN2FXTmxlMm1XcFh2ZTQ0bTkzQlptdnAybHZyeEpQKzZaK0FRSUwrRFNTVkF4UWYvTER6TzJaciszczZ0YUh0dlltdmJ3VUh0Sk1aNGpGV1l1aDJVQXZFb2dzN3NlRmlIWVNtbG16VUJOdWpRTnRMOVpteHdWYUNMb0lJb3JiY2VhUTFpc2tmYXlYajVUYy9ORzYvZzR3VFptU2FLQS9pVWdGUnJwTDVGcm40RDY5Y3d4akhjR1dLOElla21lQ1ZDMlZlRzBFUVdCcGVicGpIcEFudkxlWVNRYkt5c2NQcWVMai80M2UvaUZ6NzBjV3haQmNwTEhCT25LYWF1d3lxQy9adSt5U0djTjZIdlkrQzd6MG5Pem1pZXZscXlQb0pKS1JuWW9HYWlWUEFFU2ttVTB0QW9yUWZkcWhqckxFcEhlQnMwdThUK3FXK3FTODQ1cEpBSDRSck9Ja1I0blVpbkNLSElVa1d2blpKR21pVFJycXpLRVRBUlVQaW1yQ3VFc0VvTDRrajVzanljU2YvV0tDWjVoWFg3MndQOS9obzFWNDQyYjVscXNvZk1PdFkwMDJrTlEwSEowUDZXVGJWbVA0bVYrd2QvWDRUWkU4aFdUYmRaYU5rMDk0Sm44Y0lpdkVYRmJVcTZYTDA1UWJXRE9FS1NxQ0FUSkFWSjVMSHlFa1h5V1VTMGh4aElSaHNEcW5GTzFzdklPaWxsWllLMHFBek8wQmFHdWpha3pjcXoydTFMOG9TY1l1ZldEVTVlNkhINjVGRmVlLzFhbUttd0ZvRWppcE9tcW1TeGp0QzBkSUVEVnRhT3Q1MlUvTzEzeFN5Mk5OOS9qMmR2NGxnWmVsN2NkRnpkOWx6YU5PeVdua2xCQ01sQy9JUlVDaW5EZDYwRExVU2lTR0tOY3c3ajZrQ2xhZklRcFRSQ1NhU0FORTdwdGFmSVloMG9QYzZBTjFqbmhiSFdqZk5pQ0ZRSVVRV0NHbFpGRXFIdzNlNHk3UmJzWFhyakVDRGZyT1hqRW1PczMxZlgzOTkxUHQ2NXZtbXEwWHJVYWg4WEt1aFgxWlZGS2hsVVFxUkNPaGQwY3B2R21Xc1NUcUhDVWtwdkhQc3JsRlN6emRWWkI4YmdoUU1wOEVwalJBZVVRaVlhbldteUxDYUpRcnl2UkVtVmZZRXFlUUZCeVdpbFlQZnFPbVpTRWJkaWhCSlVkWWhsNUQ3TlFrb1lGbUFNVW9lNDNYaFBMQVVvaFVKUldjdm1heS96L2dmdlpXUXNiMTY1Z2JFVitXUVBMUU1iTmxJcWNLaTBSS013em5Oc3h2Ty92QStPOVNUajBqUGZFeXkwRkhmTndEdE93TER3WE8xN1h0NnlmUGlOaXBXK1kxd0hFVGxuVFZDSmw1S1NISnh2UUtNT3RrVTQ3MEtqVVdtc05Vamh3Vm1PemMweDAyMVJWU1hPZTVJb0JweXY2a0lvRlEwcVUrK3l2OVZXQ09lOTk2YXlQc29VMTIrKzhUdWVnVU9BL0E0bWhHQzQ5aFdFbFBnd1VHNEJWNDNYeDhKVjY5NDRSRlh4RjcvdkFsZlhKM3p5ODI4aVpDczhXQUV5YWxRQWhHaG9IR0dKalhmK2dFUW9tc1V1MXRoQUFUbndVeUMwd2dWaEJhSkVreWFhZGlzbTFSR0NNWlBvMHpEMUd0cFl0aTd0c3Y3YWJZUjNwSjBrS0RFMlZTV2xRKzRobEVRTG1GS2FLRko0VTFNYkc5NlBsa2doTUNLb3JvaTY0cGdiODQ0SDd1YmF5Z2ExOTlqYTRxUUY0U2xGME9OV1VtS2xwamFDZTA4S0hydFBvM2NkSFMyd3RjQ0ZsSXE2RnFSYWNHNUdjclFyT1RPanVMUmgrTVRWaXRlM2JhQUtBOTY2QTIxaDczMllQVCtZNlRjaFdWZGhIRUI2RlRidkNzQ0hIZkhHR3ZDV09GSWdSYjI2dC9mTXl2YnVha01qY1lETHNwaUhIenpENTU2NTlMdWVnY09SMjkvQnJuengzOUU3K2pEbGFBUHY3TUVrWVYyTzlQRjczM1V4N1MwOVhGUldQSEx2SW84OWRveVBmUFEvcy8zNlo1RlJpbFJ0dkJVVWhXa1VCSnZ1bUd0Q0tpRm85SEN3emQ0KzlzdWFQc3hqQ3lYUnNTYk5ZdHFkaUhhV2tNWVM0aHU0emlmUU0xZHhFOFBOcjZ5dzl1cE52TE8wdWhrcUNvbXhrS0pKa2tOMVNhY1JpWWRrcFk4YUYyQkRlVG9jdmxCbDhrM1lFMG5GWkcvQVhDZkZaRDF1YlBhUlNSYjJlQWdWRkVTYVFvTDNEbThxSGowM3hjS3BwN2k2MTZNc0p2VGlPbHdFeWdjNUxnbDFMU2x0SURqUHA1S3pNekkwTkNlZXdyd2x2TDNmVFF3VkxmRlZOQ25mY04vd0RsZE91SEQ4R01mbjVoamxFNncxVk5UY3FuZkVWd1kzWC9uc2k2LzliemR1YjYwMGxhdENDRkZIN2NqNUdjbmV5dWgzUFFPSEh1UjMrNEM4KzYwTUZHZHR6SGkxMTRrS1k5THNsMy96TW0vdlQ1aTkrMEd1dnZKcGRsKzl6dHUrNTZmNXdhZk84L3hyRzd4eWVSdFQyNE5rVTZwUXliSE92N1dJUm9vd1dPUUp0NzhPWGVvMDFiUmFtaXhKaVZTTjZEd0gweStneEpEdDIyTnVQSCtUbmR2YkpKRWlicWZvV0tOMGlPZUZGS0dacHdSS1MyU2s4TnNqN000SVQ2RFJ5eVovY0w3Sk02eWtBbUloOFRqSzlWVis0UEhIMmFyZzVtN2RWS05zV0M5Z2E2dzFXT2M0ZmV3NEM4ZmZ4UnZqczd5MjhnYUwrUzd2TzV1eTVwYkpHRE1qeC9Ua2lDaWFrR2xOS1NSMWJlbkdrdmVlaW1pTGlzL2Z0bXpVeWNGcXRYM3Z1OTl0YnloZFlTY0o0R3gxc0tMTldrUGxhOWFLWGE3VVczNGdDcEdQcXpkdnIrMXMrcEIzQkw2VndIc2xHTGppRzN2K2h4RDQ3ZTBIL3VvLzR2blAvTksrTHNsQjVBV0lUaXJkVkR1eGVXNnBTczl6bDNiSjR0T2NmKy9mb3VodjA1Mlpvek9UY3ZkZGM5emNuakFaVndnWGtuVkhvTG9MMllSZnNuRXVxdEc1YWtaQzAwVFJ5U0t5TEVIckFYcjY4MlR6VjhqSEZkZGUyZUxhYzljcCsyT1NOS0xWVHRGcGpOWWFGWVdOc1B2N3hLV1NxQ2lFVy9GZVFlUUNEVVEwSThCaE01dkEyckMzM0hwQjdTMUNLL0pKZ2IxNWhSOTQyemwrL3BuYkdHT2JybmRvOUZWbFNiZmI0azkrejNld01Edkg1VGRmWjI5cmcyenBBbDkwWGFMdU10aWExVWd5SDQ4NUc2MmdOMTlnVmc1SmxDU2FCSFdTRXhtc3RBVWJlNUk0anNNbUsyY0RkYVhSOG5wckhLM1pMMklEV2RKSXk2dURtMXdacjdNMTNzTm9LZEoyZ3EvY2JqMHhZKzVZcVFaNEtZVGYrZkx1SVVCK3I3WjY0eFdpSkFscjhjSnoyUmNzMEV0TFJ4ZmEzVmE3UDZ4SWxDRE9ZcXh6eExNbnFXZE9NUm9aL3UySFhnTVR4S0pWclBIT0laVU1Bejh1Sk85U0I2S2Y4NEMwelc1elFacG9ldTBVclJ4eDl6S2RwZWZSNlRwYnQwWmMrc0lOMXE1c0lKMmwwMDJKa3RBcDF6cFUwWUxPcndoYVdEcFV2SWdWS3ErUmUrTm1ZNndqaWFLd0FkWTdoRyttS1V4Z0dsdmhzVFlzeDlsYVhhTW9CTFdWbE5ZUmFZM3dJUWRaWGxyaXlVY2ZaS3JiNGNxVk45aFlYK1BvMGVQTUxpeWhPeDBpSFlHT2FIVjd6QncvemtnNjdNeWp4Q3Vmb2JYN01rSlczRmdyS0VyUDFjMEJaVDZDVnBjb2E2UGo1Q0RNOGswdE1heUFjd2lDdHBmQjhVYTVnaDRvYW05Qks2SklJYVMwU0xubnZkK25zbHNoaEkvYWtSOXZUYjd4Q09JUUJyKzlQZmZ4bndPZDRlcEtOQXRQRmFEVG1EVFIrVXlXYWRGcEpkaXFRaXVCVHhLa01tam5VRVpqQlpqSzRQQ2gvb1U2S1BFbVNiT3VVQWZkS3lWQU80R1draXhOYUNXYU5OdWt1L1FDMGRRMUpzTUpsNS9aNVBWbnIxRU1KcVNaSWs3U1VEV0xOTEdNc1dQTHVNcFJMVVhXeTBLcFdRbGtyRkZLNHE5djQwWUZUdG13UDkyN01BL3ZMRkZET2d3andCNHJRa2ZmU3pCV3NMNitSWCtRNElXa1VncnY0Y1RSbzd6bjdZOHgxVzF6L2RwVmRyYTJXRm8reXZ6Q0l0MWVMNVNWZ2FYbEplNjU1MjZHd3pGcmErc2s2WEVtSi84TVNYcUUyODk4aUMrOHRzdHJlNWFWUVlFSGlrRkJXUXlSV1lhVUdxMGl0STVJa3pSUTdFVmdIVmQxU1MyZ2tpWXM2SkdocWlZRTRCamcvRW9ERG9NSUJSWlRHUCsrdi84K1B2Ri8vOFFoUUg0dmRtSzZ5OHB3Z3F2ei9YQjRYODBrdW5oUGRQek03SnVQMnRZNzZiZGlqSVEwaXhDUllsSkhqUElLWlN5MUQzcFhnUzdoRDhaeGpiQUhLd0NjY3pnSlVpcVVFeWlsNkUxUG1KNjlSV3ZtRlp6ZVlPWHFrRGUvZkl1dDZ4dll1cWJWMXVoWUk3U2trL1dZaldhUnVXS3dOMkswdGM2dUdERjl4akZ6YkNxVVNST05XUnVnVjNiUjZxMDk0OFpZYWhyYXVmQW9vWUozT2VCRU5adGphMUE0TURYR1M2eW9PWFprbWNjZnZFaW5sWEg3MWszV1ZsYzVmdUlraTB0TGRMcmRwaHlybUoyWjVlTEY4d2lwbWF4dG9iV2lya3AyZHZiNDZILzdNbGRmdk0ydG5ZcCtaZDhLWkwzRDF5VldLS3h5MUxKRVNvVnpEcTFEbjBSNmdiVVZLb0trRlIrRXJ0NkhTNkVxemZwZ2EzS05yNWtVZExYNzVuTFFReWo4VnJ0L2NaWitWWk1vS1hKbjkrZlFJeUJSU21RUFA3RDh2cWNlS0U5dU1QSERZVnVZVEpQRUt2UVR0Q2VMRlhscEdIcmVTaTRQWnN2RHdhd3FnM09lc25KNDQwa2p6OXpNa0xuRkZYcHpLeGl4eHVicUx0ZGUzK0hXcFZWMlYzZFFBcEpFb1JOTjFtNnowRm5nU0xKTWJHSktTbFJQTXhnTjJPMlBHZThXekoyYVFiVWozS2hpOHZJV00xV055QnI1VWNENUlFMGtmYWhHYVJrS0Ivdk55LzNZM3pwUEtpeXBqSmhVaHRQSGovS2VwNTZnMTJtenNiN0d6dlkyUzh0SG1GOVlaSHA2RnU4Y0FzSHkwaEluVDU1QUNNWHRXeXNZYTJpMTJteHZiL1B6UC85ditjSXpuNmMyOWRkL0NNMVNSZEZNV3pyckdFK0dDT0dKNDRUcHFYbVUwczBrNDF0bFllOGNRbWlFbEtVcGJiNWYyaFVJcnhKRk9wMSt3OTdqRUNCZnh4SUNsMmRTMXFLb3pmNGs2cjRPYjN6cVdIYnlpY2RPZnMvODdHeXl1djNyZm5IeFNVeCtBdWRWaU9lZFkxald4RkxTaWhSbDdacUtpME1wQ1I1R2s3RDlTUGdhcmNlME9oc3NMcS9UbmQ3RytnRXI2M3RjdmJ6RjJodWJyRi9mWkxRM1FncFBuRVZFV2NMQ3pCS25aMDR6Rzg4Z2FvOFJocXFzR1ZjRHR2TStvaVdaWHVvUWQxT2M5ZXk4dElIYW1xQ21ZSCtqNkQ2L1RCNlVVVU5vSlJwQTJFWmNPd2hMQ0dMcFNTVXNMeTd3cmljZnA5ZHBzN3U3dzg3T05yTno4eHc1Y294ZWJ3b3BBM1drMSsxeTdwNjdpWk9FVzdmV3FHdURWSXFxcXZpdi8vVy84TXd6bjhPR3NkM2ZPdWU2RHhEcmtGSG8zd2pCd1FycXVxcm85M2R4VlVtY2hOekpXQnZXT1VqaG5VY0lKWGF0OFdQdWtFa1ZVdmp1c1M2anRkRWhRTDdsNWlCd2JYZUFBK0c4bDl5eEZFZEowWHI4b2RudnZQZjgyZU0zYjFUK3h0NkxZdTdDR3BPZGU3RGxLWlJkUURHSEhrRWRTNFNJcUsxSENJT3hWYUN0dTRwdWI0ODQybUZ1WnNEc3pKRGNiYk16SEhCamRjRHFhcC9OVzN0czM5cGhzTDdMZURoQkswR1VLTnE5Tm5jZHZZZTdadThtSVFxaURWZ0dvd0ZydTdlNHNuNkxPbllzbk9neWUzd0s1MkhsMlJYS3EzMldkQ05yNi9mNVRRMFowb3Nna2RqSURBa3ZrTjVobWh2Y05nczR2YWs0Zitvc1IrNS9uRjQ3WldOampmN2VIdFBUc3l3dUx0UHQ5UkFTcXFwa3FqZkZxZE9uaU9LRWpZMXRpcUtnTEF1VTF2emFyLzUzZnYzWGY2MFoxLzJkeklPcGNJVkNaVzFVRkhJUnBTTzhDRXhmYTBwVVYySjhvTUlUR0F0Q2VyRFdiOWFUZXNMWENERW9KUTlEck4rTE5aK21hRFoyS3lBU2dwYjNwS2RPdHU5Ni8zdFBmV0J1NWtUMG9ZODk0emZMVGJMalhVVHJpeEEvQzc2RHM0dk1UN1daVko2OGpNaGtnaEY5RUgxaUpZaGpSeXQxS0J6anZPYks2b2piVzBPMnQ4YU05d3BHdXhQNmF6djAxM1lvSmtVUWdrZ2szZTRVRjA3ZHo5M3pkNk1Kc3ByYnUzdXNydDVpWTdERjFyaVA3Y0RDYkp1Wkl6MnNrS3gvZVpYKzFWMW1QQ1NxYVZZMnQ3Tm90ai9SckYxUXppTTBvZi9pbWhhZ0YxanZVZDZSTHAzZ2dZY2V4YVJ0ZHJhM0dPenQwcHVhWVdGeGlYYW5nMWFLb2l6b2RMcWNQMzh2OC9QenJLNnVVMVZWbU1XUFl6NzU2VS94b1EvOUZ5YVRiN1NLWlBFMnh4WUM3ek4wRklXUlpDRVF1Q0I4a1VRSFY1dG92S0dRd3JyY2JGZmpLdWNPUVRnVlNSK1VSZzhCOGkzWk94Njh3T2RlZkMxd0RNTjRiUVFrM3BOcEtkdm5qbmVlV0pvK2N2ekc5VjF1M0xndXhLaGs3Zk8zbVhyaU9CcURGYnVnOW9qU0ZCMDc0aVRNSnlUTmZrRnJJUzhGYTl1ZTdlMkM3ZDBKK2JpbXlBMlRjVW5STCtodjdESFkzS1V1YXFKWUVhV2FZMHNudVhEcUFZNU1IY1ZYaHRGd3lJMmJON20rZHBWQzVmak1JeFRNdEJLNmkxMHFLMW45NGdyRjJvaTJoNjZHTkFJdEdrSGRneUdrOERmSi9odDBDS1V4UGt4SVdqeVltdGFaaTBRUHY1Y0N4ZmJHR29OK24xNXZpdVhsWlRxZERrcEt5cXFpMisxeC90NTdtSnFhNHViTjFVWkYzUkpITWM5LzVRWCsweS85TXR2OTBVRjQ5dzJadC9oNmd2VWU3ek9VRGtqM3JzWTVpMnpZMXZ0TWhTRHRnOE9UMzVHZ08rKzljOGFSemFTSEFQbFc3RWUrOTcxODVkSlYwamlpcUtvNzg0NXNzWlBOZitEczBvK2YwY21mZnZYajIrMDZuWkRhS2J3WTBmL1NHcE5PUk90VUQrR2g5cDZ0Zms2a1FoZGJhY2NvTnhTRlp6U29HQTlySnVPZzB1NUtSNVhYbEpPSzhlNkV3WGFmNGU0UVZ4dmlXSksxMnp4NDdtRWVPUHNvbW9qaGNJL2QwUzZibzAyMld0dllveDR6Y2RpOHBqZWJrazUzbU9TVzFWZlhxVFltdEFSMEJMUWlTS0lRWXNrbTVmQjNnRU0xU293SWdaTWNVUEdkczZUTHAwZ2VlQWVGaU5qWjNtQm5hNXVwNmVuZ09kcmRNQTlpYWxwWml3dm43K1gwNlpOY3VYcURxaTRENDlZTFhuNzFWZjdkTC93aU80TVJVYnVIbVl6d3RteTRuOStZWHhmQ2d3Z3JITFNNOEk0bUw5UEJjMWlIYjVxaVdzcUJNKzRXWHkwblNqV3V2WGVISHVSYm81UW94ZXIycmlqcitrNkI2a3dJa1Q1MWV2RmREeXoxL3FKQWRLV0pTR2pSbVQxTlVVeVlUUHI0VndYanFDYnZlYndOV3J0YUJwblJxb2JSc0tZWUdreHB3dUtiMGxBWGhrbS9ZTFEzSmgrTUdlOU9HUGR6ZEtTWm56M0NtUk9uT0hmMlBMUFRjd3lMQWR2akxmYnFYWGJORHFPcXoyaG5nTTBOT3BKMFp0b1FSV3plSHJGMXRZOGJWMlFDT2dUdmtVVmhOZUUrbS81T2dIZ2ZwZ2xsc3cxWE5md3RaMnVtemw1ZzlySHZZR0FGdzkxdGhvM25PSEwwR04xdUR5bUR0SStVa25QMzNzT1pNNmZZMk5pbUxDdTAxa2loV0Z0ZjVmLzRwWi9uNXRwdFloMWhuY0tuQXB2N1JtUDR0OHZTdnpvZjhiWkcrQVFkTmV4ZTUxQ1JJRzVGK05xQ2xHRWdMRlRmUnRXa1hyc0RJQWNnZWYwalZ3OEI4cTNZMXQ0QUljU2Q0bkF4a0o2WWJpL2ZQZFA2Zm9udmlMVHJaWndJVTFWSUVaS1RtYWxabEZBa1YycHUzVlZUNm9iOHB5VkNRajV4akljR1V4aDhaWmlNU2tiRENXWnNjYm5Eaml5eWlwanRMUFBJM1NjNWZ1d1kwL1BUdU5neHFQczh2L01sOXZaMkdRNEdqQWNqaW1HQksycmlXSk5OdGZGU3NUY29HS3p2VXV3RWNlY1U2TWpHZXlRUVJ4RElyVytKSSt4VHlKdS8zdUxRZUk4cERiTW43K0hZdS84VXU2VmxaLzBXbzlHUVZxdk40dEl5M1c0M0pQcE52K1RlYy9kdzd0dzliRy92TVJpR0VNcldsbUhWNTludFQ5Tjd4SEwvaFdYMlZncEdhd1hqdnFBWWRURVRqeTFLdnFFNzNkVzRmSXhGb3BNRTBTZ25nc2NhaDRvbFdJdlFFbTk5UGxnWjdYeFYvcUdsbjEzSzJMdzlQZ1RJdDJLZitPSlhSRzFzbVBrTUN1Nko5MFNQSEpsKzEwSVdQNDRYNkZaYklCU3VMaHVCWkJGVXlTUE5ySW1KVnoyWHVuMkt6Q0hxSUpaVkZSWlRXbXhsbVd3WGRQVVVENXg5aUJNTEp6a3lmd1F0RkVtVWtpWVpHK010WGw5L2pXc2JiM0Q3Mm0yMjFyWVo3NDRwUndXaUtSUEhXVXc4MzhPakdJNUtCbHQ5aWtHSnIwTlpRUXRJZkpBaTZjWVF4d0VjKzhMYStMZUUzcng0cXlKeHNPbWp0c3llT2MvU2s5L0QxcmhrYTNPZHlYaEVtcldZWDFoa2FtcnFRTytxcW1ydVBYK09CeDY0bjgzTmJWWlgxMm0zMjBRNllsUU5lSHIxbzZ6SU41azYzY1pZVCs5TWkyS25JcDhZYXV2SnQ4WU1ydTVRaldxS2NVbXhWN3hGK2Y4dHEzczgrQXBiVEFMangxcVNkalBqUXBqRHdYdVVCS1ZsYlNwVEh2UkFwUEI0ejlLcDNpRkF2aFc3Y05kSlhyMTh3MHNwWkJOZXhkNmpMeTVPblh4a3VmZG5Za0ZtNGpTc0VTdkdlR09JR2txNUwzTzhTSEVxeHEzVmRLL1g1RWNNNWJ3S0t1MkRtdEYyenQ3ck8zei9rOS9Oai8rbHY4cXhJeWVJVklRQVNsTnpmZU1xbjMvOXMzejYwaWQ1N1pYWDJia1pnR0ZyaTRvbFVSS1JkRE4wSEdFdERQWnFSbnNEeWxGMW9NcTQ3d0ZTRDEwSnJVaVFScDVZRVlhMnBHZ2tkdmJielhkb1ZCMHNBblVzWG55Y0krLzRiamI2WTliWFZwaE14blM2UGVibmw1aVpuZ0hDOGhsckxQZmZkNUZISDMyRTNiMCsyOXU3R0dNWURvZDBXbTJlMy93OFY0clhVVW9oUS9vUXBocTdFV21xU0x5bk14TXpjNlJOT2FvWWIwL1l1NzNIY0dNUE03SjQwOHhqcWNBeUVFb1R4UXJ2STd3U3hHbEMydFpCaENKU3pYSWM1YVVRSHV0dXU3QXhhbjhHeEZ2cnZmMG11K2lIQUxuRDRraUwydGo5MHE3dXRMTDA5R3ozdTFiM0p2Y09ZaVc2MHpHVU9kS0hVVkZiMTZIcEZrVlk2OG1MblA2a29CNFg2STJjYWw1Z2o2V1FoY08wZVhXYjE5STMrZks1THpQOWdXbW1abWU0dm5PTkw3eitlWDdqNlkveDNITmZZZWZtRHZXa0RFSU1MWTNRS1VKcWpQR01ScFlpSDFKT2FteGxtNzJGZDF5d09xeHN5eHhNdFNTOUdDTHYwUUtFOEx6VkRueEx2bHdjeEZjQzd3Ukg3bitDNllmZnc4M05QZloydGhpUHg3VGJIUmJtRjVtWm5UbkkxVXhWYy9yTWFlNjcveUk3Tzd1c2IyeUY5eUFFUlZIeHpQcm51RlI4Q1YrQ0V4YTBiTGI0QmthQmNFR0VPZ3p2aDdtWUtJdElPekY1WDJKemk1UUVHa2txaWJPSU5FdUoyd2txVWlncDBaR2lyTTBkbTBYRC9JencySHBTclRqcml6c0JBdkRxRjljUEFmTE4ybzk5MzN2NTBxVnJ6VFk3ZjdBY3B0dEt1MXVWdStpa2JaMmY2ckJkbEd4czdxR0VwSlZFNEJ5dE5LSFg2V0FJYmo4dks0cWl4T1FsWm1PTXVRYitWSWZ1Zk1iUng1ZDU1dVhuZU8xL2U1MkJXcVZ6YXBhUGZmcGpQUC9NVjlpNnRvMHRhblFzU0xJSWhNWVlxRWFlYWp5aHltdHFZMzVyMk5IMHZJUUNHVU5rb0tzZ1ZwNElIMElyMFlSUWpVQ0VhR1pQdkgrTG91RnF6NUVManpMN3R1OWdaWE9IclkxVnlxSmdabmFPK2ZrRnBxWm5tZ2xJaVhHVzAyZE84OVJUVDFLV0ZWdGIyNVJGZ2ZPZVNDdDJkMTdsbFowdlViVTltWlM0U1kyTEhEUks4dnY3M3dQbEpnQkY0Z1BEMmRyOUtXU1VETjRqSUZsQU01SXNoRUJvcUtvd0J5MWxvUGJ2cjhOV3FTNjMxMFp2bXNyVys5SXdFdUV0L2xzNkgzL3NBYUowR05zMHpvWnJxR2tPN2c1RzhpODhjYTY2WjdaTlhWVzhzVDVBQzdET1VCcEJFb2U2YVQvUHFaMExZN21BOTRhaXloa1hZOXpJSXJmSDJLNW1acm5GMUdOTHFIYkVmL3FOWDJUdDlpNjd0L3U0dkc0bzhKSkpEcmF1TVhXSnJVUHkrVldUUW5jdVFRczQ0b0ExQW1RU09oRm81L2NGQ2ZmbmplN0l3dS9ZeE9tRGtzbkN4Y2ZJTGo3SnpkVjErbnM3RkhsQmQ2ckgwdklSZXIwZTNudWlLRWp3TEM4djhkUlRUNEtIbmUzZGc2R3ZxbloweFJhUEwremh6UktmM050a25aSldMS0d3UWRGZWhjTXNtejBRWWVWQzJDbUJkZGphWVBkSGFKdXJYelVKb1JDaEVlaXR3ZWtvREZUSk8wU3poVUFxSVVRa0o2NzJhM2Q0andQWklPZjlJVUMrV2F1S0VoVm1QVUsyMTRoN1BIUnk2Y2hDR3AydHk1S3RRY0hlcEFvUFUwZ2lMWWlsSUdpaU82UVdWTTdpUFdTdENFc2J0R1F5Q2JMOWNsQ1Jid3l4MG1PbFlLdGZzV01zdFJLNFJnN0hOY3RmZnR1THpuL056NzQ1UFRJazVyRVRtTm96dElKSStFYnAvVUFYNHEwODk0NEdvVUN4ZE4vYmljOCt6TnIyTHBQeGlMcXVtSjBMbnFQVDdXS2RDMk83UXJDd01NL2JuM3dTNzJGdGJaMjhLRkJTa3FRWmtWM2haSEtiVkhnK2NPSVlGK2NXK0pYTFY3aFVEeWlWQUF0T2VGVFRZNEVnYU9GRW1HWmkzOHZkc1lUQWV3NG1Jdy9BTFFMSUVISmZTUVB0dzM2UXBMSXNWVkhyV0dmcXJuVzE4MFZqblpOU2VDa2xqNTAveGpNdjNUZ0V5RGRyazhHSTBYaXl2Mzl3ZnlCSzNyVXdmUWJ2VDVURytkSTZrZGNWU25pU09BazZWTUQyWUV4UjVSeWJtNmJLRFVLRmhCb0JXVHZENlJDdjI3S2lNQVpmbFVnSFV6aHFDM3RWT0NpMjJjcXpYNVA4WFZvQ0I0dWFmUjJFSVJKZ1JrTHBCWnNGSkltazR4MVJFK0ovRmNZYWhyR09NN3BuTHBMUG5tWjdZeE5UVnhoam1KcWVDZHlxVGpkSXAwWXhRZ2hhclRaUFB2RTJzaXpqMXMzYjVIblJoSGNSc3RyaVhPOGEycGM0SW02dmJ0TE5Ndjd5aFh0NVk2ZlBGMVp1YzRXQ0xXY3BmVmptZ3hOb0xiRlNZSm93U2lxSlV1S2d1cmJ2WmNLQVdlQ0ZIU3cvMVNIeGo0MWp5aXFtaldCR3hYNGhpVkxmMWFlVFNHRWFhcklBbnlqMUxjVllmK3dCOHZpWjQzenBqZXROb0lzQUw3VlNlcmFkbmtzajFaa1VocksyWkZvM0N5RURUVndnZUhWOW14YVd4YWtlYVJLRnVMb0t1clhPV1NLcGtCcUt2RVJKaGRjUnhqaWs5dlNjSmNJSGNVVVo5QnNLQ3lQMzFpWVhkUWNlOXY5WjhGYjQ0UzA0Ry9RMGErbHBSd0loUEx0V01PVUVxUXZnay9LT0JOMExWTnhpL3NHbkdHWnpUUHBEQkE2cEZMMnBhUllXRnVsMmUrQWhpaUtVVWt4TjlYam93UWZvZEhxc3JXMHdISTZhMlhTUEdhNXh6OVJOWmpxQ3dTRGtQYkZXN1BVSExDL084TUN4UlU2MFUyN3Y3ZkZtZjhRYmt6RjdydWEycWJET1VUbFBKVUxmU0VaQmZjVVNjaEhWdk92YUduQVIyb2RPcHpTV3VIRE1FREZIekh5U2tDV0tTQWxpUmZYcTF1QzFTV2ttZ1gzaW5YZk9yOTllNXhBZzM4b0hNRFZOcTkxQzdBNE9QUHZGdTA1MWRCeWZ1N3krbzErN3ZlWFgrbU9rZ0lrTnl1VFRXY1JzcXRCVU9Ed2ZmdVVLZEdMaUxLR0ZZT2xJbDJTcHcxNXBtZHpjSlk0Rk1TbVpqYWpLQWhNSnRQTEUybEhXUHRBbklrRm1JYWs5YnIreVpJTmZxNW8zcHBvdXBpUG85dWQzZ0tWd1VKV2hBWmdiUitRRkpKQ3BRQzlKVkFpeFpOUm02dndqak5vTGpNZmowRHdVZ3FtcGFlYm01bW0xTzRBblNST01zU1JKd2tNUFBzanM3RFRyNnh1c2Iyd2lnTm80OHNFR3grV3J6S2NwMWtWSUJVVlpNTlZPS0l1Y3F6ZldPWFh5R0oxdW0rUFdNcXNTN20vM3lJM2hlcEZ6ZXp6bVVqRmtXd3BNSEZFa01hMXVpamFTWW1DeHRVY25nbTRyWTZyZElVR1JXRUdTZTJMcm1ZcGplbGxFSzlFTk5kOExaMzEvWTI5eTJYdnZoUWpycXowd3FjMGhRTDRWaTQ2ZkplNThDY1RhdnZxK2MxVTE5YkdYcnM1ZVhkODB4bG5kU3p4VExXaTNJMDdNZEZob0o2UktvSWhaRzVXOG1oaW03NTlqL3Q1WmVqT2E3a3hNNFJYRlNzV21xaGk4dVluWW5wRGxGdWtkdlZpR3lUalhpS1o1ajdVZXFhQVhnWEdpU2JBbFdhengzbU5xaHpFZUtUMTU2Wmw4bmFLV3V5TlhXU2s5MnpWMHd1b1JsalBCK1JOelRKMTltQjNSb2R6cms2WXhPbzZabXBwbWZtNmVPRWx4enBJa0tWSXFabWU3UFBEQS9Td3VMckRYNzNQejVpMnF1aVpOVTF5eFEzZnlQSE1MaHJMVXBFSWM2TzVhWjVpZjZWSGJBYSs4Zm9Oelo0NlF0REx5eXBJSmFQbVk1VjZIeWt6ejd0bUt2Ynhra0Jlc1RNMVNGaFd4bDJ4dWp0amVHeVB3ZEtLSVJDaDg3YWh0alZjZUZRbGFpVUlyVDJscXBCQytwU1U3UmZIeWxaM1IxZUE4c0lRMDU3ZHFCeDBDNUJ1enkyOWNJbFlITFRNSGNHVjFZOU43L3k5MTdQOU1KbmlIRWtSVG5aU0x4NmVaVG1PVWF3UU5yS2VjYnZIQTl4M2p3Z1BUcE8wZ2F1WXFUMy9vR0FwQnRUTmg1L0l1cm0rYlhrSFlrWjVJaUVYWVV4aExTQlhFa1VBclFXMDh0dllJSGJheVNpSElvdER3YzlheVY1ZFV2eHN6QThoZDhDd2VRSGE1KzhURGJQcU11cXBvdHpPeVZvdVptVmw2M2FuQWtnV1NPQUZnZW5xYUo1OTRuS21wSGpzN2U5eTRmb3ZSYUlSVWl2WFYyNXhKcm5LczNXZXc1MGpUTEFpNHlUQVhIc1VKU3FlY1Bqbk44TFVyZlBMenIvSDRRMmVabSswd0daZE04cEtLc0xOeGRpcWxreWp5V0NQM0t0NVkzV05ZV1dSbDZGVU83MEFiaTVmaDlTTWQ1dmJqV0tHQTJscU1jeVJhQ3VQczVPclc0S1ByZzdMUHZwS0p4elhhZk45U0R2TEhYaml1RzNsdXJXMkl3V2dpR3BwSlZGc3JqWFdicDA2MEY0cUpmV1J4S28wZU9ETkxONGx3Sml4MmtVQmRPOXpqUzl6MzNrV20yb0pXckVpVUFLOHB5d2pyRmROemJkSnVodmVlY2xEaWJNZ0xLZ2U1aGZFZDMwc1R3aUZ2UXpWSGlsQ244VXBncGFEMk1La2RPNldsK2lhYXdsTlRVNXk3NXp3aXp2RE9NemMzeS9UMERET3pjMHhOVFIzMEVySXN2TS9wbVdrZWV2QUI1dWZuMk5uWlkzTmppN0tzTU5iUTM5dmk3UFNRODBjRmVWNHdHWTdwZEZ1QjFWdlZnTVI1UVpxMUVVSXcxMHNaakhLZWZmRWFvM0hGN0hRbjZPMmEwTk5RS2lqTDE1WGgwdVVOM25oam5iMytpRHd2eUtzSzR4MUpySW0xSklrMXVpbW5BNHpMbXNwWVhGRDFFbHZEL01XWDFrWS92NXZYbXdTaHVES2tjTUozWThXZ3RJY2gxamRybS8wUmR4QXdEdkpmcGFReWxWeHNwVkY2OGU0NXVwbUd1bWxVQWJaMnRFNTNPZnYrUlZRSGFpdEpJNFdySS9walFWMWFPaTFKZEVTVHpiVTVjdjhTS3krdmMvM1RONWhzVDNEbXJSTmVFN1Q0Y3cvajNKT0ZOZ2VwZzFSNmRMTWpYV2lGRXRDdEJmblloejBpdjRNSkllajFlcHcvZjRGVzFpYUpJeFlXRm1sM09yUmFIZEkwUFFnK3NrWkJaSHA2bWtjZWVaRDV1VG0ydHJaWldWMm5LaXZpSktIZUtqbloyZVd4dXp0NEE1TkJSQlFycXRxd01EVkZWUnVjRjVpaVpqd2FFY2ZoZUQxd3oxRWlZWG4yK2V0Y3VyekN3eGRPY0dTeFJ4cEgxRVdPTlJibkxWSjVhbHNUS1luV1FZamE0cW5xR2kwRk5ZYkttSVBtVGxIVmVPbXdsUkZEWTh2MXNmblVqYjE4aFdhOUFXQ2x3TTIzTmJjRzFiZDBQZzZwSmtMaE1WNUltZ21oVUpIWFd2c0w5eDdOV3FxVVU0bkFWNVpHRUJGZmUwU3FPUGJkeDVnNTNxTElLeUlwTURabVp6ZGlzSmZqZ0ZZU29ZVUU2L0hUS2FlZVBNSE1xUmxXWDF4ajVVc3JGRHRGRUVhUVFBSmVRekdHTWl4WUlyV1FURHhaYmNraVI5WWlyRlN3L21Ebk9sK251ZTZiV0c1NWVablRKODhRUlRGSmtuRHMyQW5hN1RacDFpS0tva1lXVkJMRk1VSklabWVtdVhqeFBMTXpNMnh2NzdDMnZrbGQxUmhqS0lvSlIxbzd2TzNjSEs3S0tjcTgyVHFyNmZjbnpNejkvOWo3NzJmTHovdk9EM3c5NFp0T3Zxbjdka0kzME1pQklNQWdNWWxKRktYSkhubWtDZHF4dlM3WHVzcTc5Z1NQYS8rQnRYZC9jTmphdGNkQjBtaEhNeHFLa2loUmxDaFJGRW1SRUFtS0dRUUlFRUFqZHU2YlR2NkdKKzBQei9mY3ZvQ284bGlqR1JKU1AxV251dEVKOTU3emZMNmY5QTdiYUMzeHpwQm5tcW95TEJaTnRFb3pOV2RQYlpCSXlYTXYzdUJyVDd4SXA5ZmgvTmt0VG01MDZLUWFwYUpLUENHUVowbHJ5Qm0zN05aWmxsVWtRN25nMFNxT0tvdzNMQllsM25xOFVNOWNucHJQV1I4V2JlWXdvaDBBS2lIQ24vWjYvSVV2c2JZM1JpUnBZREt0aFBkK3hVSFA3angvY3YwLyt3L2YrMkhmek8rb1ptVmNScldnTzJjOG8vdlh1TzBEcDFBeThxRzk2N00vVHRpWjFwVE9VYmYwejBURjV0WGE2QUtiOWxLR3A0YjBUL1FKSWxCTnF1ai92Ykp6YW9PRmdjVDNOYWFqYVFyTnNpMnhHdXVabFlIYWZ3L0FhL3RYY3lrNGZ2SVU1OC9malpLUy9tREl1WFBuR0kxR1pIbU8xaHJ2QTFvcnNpd2pUVFBXTnphNC8vNTdHQTZIWExseWxXdlhidUJhWC9LcXJFa1czMkVydWNIWmM3ZmpUSVgzRG85aU1wNnhXTmJValdGamJSRDNGajdnbmFNcWE2cHlTWkttS0Nub2RYS09idzF4MXJHM00rSHk5UVBHMHdwRUlORUp6ejEvblV0WDlxTzNlM0FJS1REV3hTRUdqckt1cVkzQkI4dHNzZVJndHNBWWgxWjZ1dCtFZi9iTTd2SkwzTFJYTXdMY3FOQ2hTQ1NUeXQzS0lIK2E4KzNuWHViTkQ1NXRJZUJDQ0JGRUNJVHpaN2N5SVVTdnFTMjY5VGtQSWZwb0JDVVkzRDBpNnlWNDR6Qmh3SEtSTXBuUENDc3RMT3VwamNYN3FNZ1JGMWVPeWppa2xteWNYMmQ0b3MvNmJXdGMvdFlWcHJ0VHZQQ1FSK0dFYkpTUjlUc2tXcU96Qk45eUxHempFQXREVVZuTXVNWXVvbTMwU3REWlNjbXBZOGM1ZGRzNXZQY01oeVBPM1g0Ny9WNFBwWFhyWHg0WG5ta2EzYTQyMWplNCsrNDc2ZmY3WExwMG1iMjlBdzdHQnhSWmp2R0IvZVlaUG56T1kyZUt2YjA5Tm9ZRldaYVFkUVBYZDZiWTVUNDd1L3QwTThWdzBHOUZzK1AzckVSR25xV0FSMHFIVGxMdU9YOGM2eHpYYmt4b3lvcHZmT2N5WmVYNHpuZGV4Wm9LVkRUbzFDMUsxenFQYzQ2eWNnamhVVUt5ckExWnFrSXZUMzN0d21QUDdWV2ZiWU9qV2pYb1Vnby96RlhZNkNTOE9xNXZCY2lmdXNxUzh2VVBZbGtVYWJKWUxCTHZMQzNrQ1NkaUZaQ09NamJ1R1VVWEtkSEYxSDBPRmxPYzk0ZmJhb25BZUVmcGZBVGxIZUpuQlVGR3BVV2RhMDQvZXBLMTI5YTQrSzFMWEgzcEtzWTEwQVNDaFRSSnlMczVhUzlEcGtuVTBVMFVNb3NlZjY1cWFLWTE1ZDZTeGZVRmR0cHdZbmlTNDhkUDROdmR4dGx6NStqMyt5aXBJbm8zQkxJOEo4OVNwRlFjUDNhTWUrKzlHNlVVTDc3NE1zdEZpVEVOcyttVXNaMXdXVDVQNzQ0YjVQMkgwVEtoV2s2UW0wTUlVQlNhTysrNWh5ZWZlSko2UG1GL09tZHRiVWp3VVVLMUtGS2NUK0xtVzZZSUxNdXlwbHRrUEh6ZmFaSkU4OElyTzVSTHc5TXYzdUQ1cXhNU0FZVnFTRlgwWFBRQmpBRXA0NDRuU1FXMWRTZ3RRNTVxZ1pRWEwwN01MODRidDlNR3g4cTVOb1FRZVBtZ1pxMzQwMS96V3dFQ2pBYjV5amh5TmU5bE9NaHpvS05sTkwrSmJhSEF1MEMybnRGZnkwbVFURXJCbGNtTXBXbGFINUNXWnlFQ1dnaHNDKzAyTGQ0cVdoaTNyRDRpTGlrZlpkeit6dHNwdGpwY2ZlNFMxYVRFVFJvcU5VZHJIYzAzSlNSRlN0THlaNlVVNktTREV1Q3RwNmtkeGZXVTVGb0NJYkIxN0JpblQ1K2hLRG94T0Zwd1ZwWkdnZXMwelRpMnRjWHAweWVaenlQY3hyZDg3YVl4S0ttNU1QODI1cDVMOUhzRmxSRGNlZkkycmw5N2ljVnNUTGM3SkFUQitzWVdaOCtlNDZYbm5xYXBhbVpseGFEYndabFdMem9FdkxXNEVHMnd0Ukl4Q3hLNCs3WU4rbm5LYi8zQjB6eC9jUzg2UDRSSS9XMThvREVCS1NJamtsYjkwWGxJRWtXZWFwRW15ZDY0OGI5MGNkbzgwNVpWaDc3bldhTDhaamNONDBYRE42OHNiZ1hJdjFrS2VZMSt1eUFLZjRqbG9zUmFHMzM4VmxLY1FEckswWW5FT3hndkxmUEtBSUk4MFVpL0FxeUV3d3NuUktTeXloWUg1VjNyZTlFcWNmZ1dpcjUrK3dacEwyUC9wUnZzdjdEUDR2cWl0UzZJRUF5ZFJYaWtsQ3Z6UzRGS0pFV2VNNXhvbWwwREliQjUvRGluVHAybTZIU1FoMlBSUUtmb2tMWUJzbjA4Wm83WmRNN3U3Z0ZTUnZOTXJSWGVCUzR1bnNmZmVabitXc0xTR1c1UWNZL0tTWktDNWV5QUJBOHF3M3ZZM09nejNsem4rYWN2c0xTQ0IrNDlSeWZMV1M0cnJLMXhUU1IyU1NXeHJwWG1FWkt5ZEZ5Nk1tWHY2cGp0WEtLN0VxMDB6amtXdFltYVlnaFVLeHduQktRNm1naXRkWXRtYnNPdlBILzk0RGZheG53MTFyVlNDbitzbC9HbTB5Tis2OGtyLzJaSWkxdlJBZmcvRGtQSXMwdzU1N1V6VWVqWmk0amNEVDZnYzAyU3BWUzFaOUdFVnZ6QUk2UW1TVk44TUZnWHNETENyRmZjdmVBajZDNjAxc2FoSFJjN0Z6VndBVHBiUFpKT1NsS2tYSHY2S3VWQlNWb3NVS25DWlJxVitCZ2NXaUlVNUNJbGZUbGg5dHdDcFRYSFQ1N2crUEhqRkoxT2hPQ0hRSkxFakpGbEdVVlJzRFlhY3U3c2JTeVhGYlA1Z3FJb01NYmduTU1heHpNWG51VDYxak9jTzlFaGVFRVZIQmZtVjdsUGJyRzVmUnZqM1ZkNDVaV1hHZlNHQ0ozZ3ZlWFlacCtMZ3hFdnZySkhtbWdlZk9CdWhFcVIwcEFVT2JZeFZIV0RkUUdsTk1ZWXZ2WFVKVDczaDgrd1hKYU11am02aGNQN29DZ3lGUzNYaEVCcmhSSWlPdGxLRlhwRjVob3ZQdlBNenZoajQ5S01qL1FldHBYNUNtVnR3cC9GMWJnVklJQktzaitXVTd4M3d2c29GV3BEKzY2SFZ1UkFRa0JoYkpTODhUNWdyTVBZa29Da3NnN1hUckhpM0RobUNXdDlkSk5hR2NSNHdNYmdjRWNrY0pKdXdzWmR4M0dOWTNMNWdIcGVvck9FckpNaENvLzBDa1dnNzd0d0FhYXZ4RkpzKytRSnRyZFBrT2NGTW42UnBFbEtwMU1RRUhRNkhiWTJOemgzN2l5VHlaVEZZaG1Ed2ptVVVsUlZ6ZS84NW0veWtuNkMrOTl5RXVWRGk3eVZYR3oyZUdGNWxXT2pOWHI5SWEvYXExeS9zY1BHeGhCclBFcHB6dDkrZ3N2WERyaHc0UXFiNndORy9SNUtDcVJRYU8yUUJrTHQyVCtZOHFXdnZjaVh2bktCcG03b0ZobFNLbEl0VzQ1SElOR3U3VjBpbFUxTFNab2tJVThTRVFSUGZlUFMvdi95eXNIeVlycytLbGVOdVpMQyt4Q0NFT0xmT0h2Y0NwRDJuTC85QkYvNDRqT3Y2VUhTUktWYXlnd0JKdHljaDBzcENJM0hHcytpOFRUV0k0a2ZwSFVlNTJOOWJiMGplSWx4Z2JvTkRHakxLOS9hSWJTMm9NclRpa1I3L0lyNm9DV2oyN2ZRV2xPT0Z3VHI4TXNHbHlsMEpoZ3hKTDJRc2ZmS0FVVzN3NGtUSjluYzNLSW9pa09NdTlhS0xNOVJTdFBwZHRuYzJPRHN1ZHM0T0JoemNEQkdhMDFWVllRQVNacnk3UzgvemhQUGZZRzcvazluNmVXNnZkeHhNbUh3Zkt1NXl1MlRQdXRTY052SlRXN3M3bUdNb2QvdmszV0hiQ3FKRDRFdi9PR1RQUEhrQ3p6eTRHMTA4Z0puRGFhdXNiWG55dFV4bi8vUzgzenJxVmNBajlZUmF5YmFjbE9KdUNRVVRyUVcweXRXcmd5WlZpTEE1V2QzNS8vYlMvdkxDOFRnV0xhTFFTY0U0Y3d3NTl4Nnp1ZGVPT0JXQnZtenlpRHlqK20xaWtRblVrbWhEcjNBZzJqcE9iQzRQS2VaR1ZBYTAzaWM4UWdYRG1IcGtkVXFxTDNqSmdLeVJYcTFVQkp2ajdDQzJnOWlCUmlTSW5JaXNsNkdHeGFJRURDbElWaVBLQzJqZkFPMWs3Qi9lVXluMzR2QnNiRkpsdWV0NFdVZ3ozS0VsQ1JKUW44dzROU3BrNXc2c2MxOHZvUWc4TjdUTkFaakRiWnhmUDBMWCtDN24vdE5UcjEveFBxWlBoMFZQZGg5aVA2Q3pncWVYKzd4bUh5VnY5UTdoWll3N09STUYzSFAwU2xTaE02NDk3NjdXSlFOMy9qbTh6ejc0aFZ1UDdWQk1JR3liTGg0OFlEUFBQWXN6Nzk0SGZCUkJkRUY4aXhxNW1vVktRWE8rVU55MTBxcVNBc3BrT0xLaS92TC8vR2JseWRmYU11cStkSEdYRUI0K2FBTTY1M2t6K3h1M0FxUTFmcjVkV2UrbUxyRlV0djJ3WS8xTjcwRXE1MlN4YXRMdXZjY3gvdVNhbTdpbENWUjBYd21CTHlMdUtyb3hCVHhwQzc0bTd6d0VJMXpWZzI2YkQzVVl6TWFNVXJJU0NLS2phcEFwWXJOOUJqaWN0eTU5SWNEdGsrY1pHMXRuU3hMWTNZRGV0MWV0R0tUa2w2L3o0a1QyOXgyK2pSMUhlRVdTbXV5TEtjc2wxamplT0w1Si9qRXAzK04vcmJrN0p1T1J4TVVKV2xjWkVrbUlpb3VoQ0I0WXJIRGJXU2NwNE5yRE1JYTluZXVFNXhsdUhrYTAxVGNlOWNwZW9YbTg0ODl5ZTdlZ2pNYlBiNzU1RFcrK2NTclhMMDJCaG5RV3BJa0dxVkUxQ3h1elhZQ1lGM2NQWVdXcHF1MUJDRXVYOWhiL24rK2VYWHlLUmZDS2pqcXR1OXdRb2lncFFqV2U3NStlWG9yUVA0c1Q3REx3eWY5NnZSNjNVUW5KTTRITElKMFJjUVFBVmRaZHA2NndkcnBJVjZCazlBc0RhSVQ4RHBPYWx4cmMyWmRpQk9jTmpCQ0swQWdSS3l0aFkvMFdHYzlRVVNSaGRCNkdjWitSeEI4SkJCdDZnM0Vmc0ppdG1Rd0duTGl4RW5XTnpaSVd0WWZDRHA1VHBhbTVFVkJVUlRjZHR0cE5qYzJtTThYZUI5b2pLVnBHa0x3ZU9mNTBqZSt4Tzk5NDNmd3B5VFp1ODZnT3ByZ0E1V0pycmRhQ2lKd09hQVFWTmJ5eWZGbGZpSTd6am1Sa1NnTlVyQ1l6WUFiSkttbW5rN1lHQ1NjTzdYQmIzMzJPL3pHdFdlWlRFcnFnd1Y1SzBPVWEwV1JhVklkNmJ4U1JxRnNLV2lOZXdLcVpSZ0N1NWRtOWM5KzVkTDRkME1JODlkbkRpbEZFQ0h1UFh6NHM3MGJ0d0lFd0srQWJEYzlqcklzMVlSYU5kYWpZbkxBT1lGdG4zTTNudDZodW5zRGsyVHhOOU9BTVE0RXVNWmlmYUR4NEp6SHVKdVRLOUZhUVFjZk1WV0phcjA1MmtEQlJ3RmRaNktrcHdpZWJ0SmhJenVHM1lmS1ZZdzIxaml4ZllMUjJocHBrc2FzSkFTRFFSK3ROVVhSSWM5eXp0NTJodE9uVGpHZHprQUlyRFdZcHNFNVM1YmtQSEh0Mnp6Mjh1ZTV2bk9OUkdwdTc5Nk94T044OUVwUFZXekxsSWp3Rlh5c1krWVl2bWozU09RR215cWhHQXdRSVRBYjc2Q1V3amFXeTVmM21ld3R5THhnc2pPbnFpMk5FQ3dhajVhQlRyQjRHWkFpSVUralYySmpMU0V1aVdMWmF3UkxVMTNmcjh6UHZ6QTF2eDFDV0xUQlViWjloeFZDK0xVaVpYZFIveWtCN2JjQzVILzNYTHRoT0NLakJzQjB1bWhTMjVpVkVZTDE4UW5uMjhWR3RiZWsrZXlMaERlZmdVNE9TdUpDWE5wNUgzREc0MFBzOEdVUUdOK1dVS3ZwbG8rTmU5VHlCVzhqWVlva2xtUWlSRHhUUjJZVWRMQmpnZk9XOVkyTmFGWXpIS0IxQkJ5bVdVYW5VOUR0OUVqVGxLSlRjUExFTmllMnQ1bTNrNnFtYWFpYkd1Y2QzZ2FldmZZZEhyLzJlWXJ0blBYNUZ2TWJZeElaU0ZWY2RybzJHS0tLaFVRaDQ4OWIyTTFPYVBoOWM0TWYwZXZjcTljUlFwRGxHYnM3KzR3UEtwNSsvanBmZi9JUzEyNk1PZGJOTUluRVdFdGpIRTBJTk5Zekx4MU40OGtTUXhNRXBYRjRIM3VvRUt1N2d5WGhaNi9VNFdNQnBzQ01teE1yRjU4cmdkMUZIZTdZNlBIaTN2eFdnUHpiT0FmemFrWGFYdlhZd1RsdnRWWk9TNFYxaGlyT2VuRStvQ1ZJSjVoOFo0Zlp1S0gzam5QSU5FSGtHaS9BQzBtUVVXa2ovbU8rOWZPT1hQYW9EOVhDS0p4dlpYc0NabUZRbVVaMUVwU0UzQmI0YVU0MU5namgyTmpjWlB2RVNRYURHQndDeVBLTVR0RWh5L05EQ01tWjB5ZnBGQjNLc3FLcWFxcTZ3clY0cHVEZ3d0WHY4dlh4NTJGUVU5aVUzbnFYNEN4Rm9kcHBYUXdRRXdKQ3hiR2FFcEpNeGVsYkNKSCt1NGZqVSthQTJUVGw0WFRBWWxxeHQxUHk0c3U3dlBqcVBvdktFS1JrYmhxcXNtbDdyRUFxNHNPZ01aNmxpVDg2b0RraWhwZG9OWEZTL3N2OXh2MVdJTXlPWkk0VmxNUWZUZnYvTm9MalZvQzB4N2xXWmZCbzN5NlZUVFIyQlFxeElTNzVqUGRjMjZ1NXNsZFMxNDdpNHBTVHk0cXRkNTFIaEE0aTE2MU5zV2dOTUZjcWlGSGtUQXVCcVF4dTJSQmtuSXpaSnVCRVFMY3FiMExDd1BVeEwzZ1cxMmFrV2NiV3NXTWNXL2x4cVBpeDZTU2gzK3VUSkVsY0F1WTU2K3NqbXNiZzNaSXN6eWlyS2daR2lKT3pGM2FmNVk4bWY4QmN6ZWwzYy9DQytYNkc5d1dkYm9KQ3RMNkFBby9BQlFGQnhCNnR2Yit4UjRqbDRKNDEvUGJ5RXM4dWN6WnZORng3ZFkvOS9TWFRneEpiTmJpcUFXdElsY0MxSTNNdkJBNUhVSUk4VVJTSkJ1RndiWStuRXoydGd2ekZDK1A2STZYMSsyMXdMSThFUjNoOVRmeHY2OXdLRUdBK1d5SmVtMEg4bFd2ajZYcVdqVmVoNDBMZ1lHRjQ0ZktDOGRKeWFpdm5qa3pRRTRIbHhYMzJIZzkwM25ZSCtuZ2Y2NkkwU1hBaGNocGE4WmxnZlZ6MXR0bUVGaUZjZXhmMWNSTkptbWQweXc3MmxjRDB4cHk4VTdCMTdEakhqeCtuMCswaVpmVHk2QlFGYVpxU3BuRTdQaGoyT1gzcUpNNTZsbVVaRjVpbHAyNGRua1NRZlBmNlUzeHQvSG1XYW9GM0VxOEYzVjVHWjVCU3ppRkxKSm1VcmJHblFJbUlQZlBCNDRWb1RXcEVWRW9SWUYyZ25odXVYVjd5NVFzdlVsK2VzTjU0Umw2alRGUk9kTmJoRzR2emdTU1JkRlBkM3Vwb1k1QW1zVkgzM3VGQ0NGTElxa0orL01XZDVjZm10UnNUUlZzT2R4MnZ6eHkzQXVUZndhbnFaclZjaTBSL0NOLzZ6cXZUZTA2ZDM5R3RVUE5rWWZuV0MxT21pNFlQdm5tVFJ4N2FvS2t0TzVmbk5GY2R5eGR1c0ZON2l2ZmRUVDdNY2RZZndrZGlyeEZYOHNaNXZQVTRKYkhHUldYQ3RubFBsYWF6WDdCNHNhU3BETDErbiszdEU2eHRyRWZHWDlRS3BjaHp1dDF1eStWSVdWc2JjdHVaTTdnUWtjTkNDT2J6T1VvcnROSTAxdkxTK0x0OFkvcUgxSEtKOHBMV3FJbWdvTGRXSUJpUUoxRWUxTGRHT2xJSWdtL2g1dTFPUW9sQVFGSWJ4L2lnNXVyTFUvWmVuVEhmbWJLL1ArYWxnd3E1aEM2YVZFQWhBNFdNMzJPbUZZbU9vMTJKaU5BU0tWQVNyQmRCQmhpWDdzSjNENWEvT3EzdHdaSGdxTnUrSS95N0RJNWJBZEtlOTczbklXNzgraGVwSTM0bkFQNWd2S2pYMWtkVnZad3hYVlI4NTZVSk81T2F1MDhXYlBZU2pnMFZKODUyV042WDhhbmZxcGxkcnVERkhmYWJRUEd1TytodWRoRXVnUFVZNndpMVF6YnhTV3ljdjJrN0VDR3M1RG9qdjU0eHZ4eFYzWHVEQWRzblRyQzVzVVdhUmNhZmxKSmV2MGVTcEhTS0FtTXN4NDl2Y2R1Wk01akdZaHBEVlpYTVc0OE9pTnBaTCt3L3pUY21mMGdsU2tLSS9tU0prbEhLTTBDbm01RVZvd2pyQ0FMVnZndk9SbWxRNStKK3hyZjFqYkdXR3pjcWRsNmFjSEJsU2oydEtHZEw3S3pCTHp5bWd0bzNvQ0ROSVVrZ1NRUUxZZWhKNkNTS3JrZ0lTUlRnRTk0VG5CQ0wybk4xMXJ3OHErMGVONVdObXUvVmM5d0trSCtINTczdmVvQ2YveGVmQ1MybzE0ZUFuODhXdFZCcURESTgvY0pZWEx4ZWNudzk1ZFJtZ1hXZTZaN2x0anNLM3ZSUUZ5V084WnNmdDd4eWFZNTYrUWJWc21iNTBDbUc1emFpamJLTnV4Q3pyQW1wSmtoSmFDSkFVaXRKYm5MVUs1TEZmb2xVa3ZYTlRiYTNUekljRGtuU0pDNEtwYVRUN2NTc2thVE1Gd3UydGpZNGMrbzA1YkxDT2tkVDEzRzVKZ1ZOM2VCS3o0Njd3amNtWDZTaEpCSFJFVmJKMkZPMGZ4U2xCVVdheElGZGl6dXpOa1N6ekRhQWZldUt1Nnc5KzlkS2RsNGFNOTlkVWkxcTZubEpOUytwWnhiWGFxcEhROUM0aERWRWRQTlllMHB0MFJwMElra3pCVk9MdnI1RU5wNUpoT1UraHhRTGZLaSszOEZ4SzBEYWMrWGFBWFZ0Z3BReXhFRTh6dnRncHJQbGl4ZGVIZTg4K2NMa1dKWUt6cC9vME0wMFBzQ3lkSHpycTNPT2J4L243VytWcEJvKzhpc1h1ZkRTZ214M3l2NWpKZFh1Z28wSFQwYTByZ3VFVklNWEJPdHdQa0l0dWxXQnVDUllUa3JTUEdOelk1UGoyeWZvOWZ0b3JSQkNrTGFjOGl6THlkS2NwbWs0ZVhLYnUrKzZpLzM5QTRSY29XQWo0MUZKaFphYWIxOStuQmQ0QnFzcXRJZys3aXYvek5WUU80cFFCR1FpSXhTbTlTMlVnUFVjUXZTZGgrWENjdjNLa3ZIVkdmVzB4anFQTlphNnJLam1OZTVJRVNTT2VDMG9FZTNmZEl0Qzl1MG9yTnFycWErVjZOcVJBazZJdVJOYzlENlVSM3FPb3dpZWYrZEgzUW9QK05SbnZ0bCtxR0xsYnF1QWJIZC9NZCtkTFk1TjU4M2RaN1lLY1c2N0sxSVZtL2FOWVVxNU1IalI0WTY3dHptOTdUbTJsZkhzaFNVSEU0c09nZDJMTStabFEyZXJFejFGR2srd0xtck5Ha2ltQ1Z3R016ZDB1aDIyVDV6ZytQWTJ2WDZFaWdnRW5XNlhMTThwaWdLbEZQUGxuUHZ2djVmNzdyMkhjbGtqcEVSSmlmTytkWlgxQkFMUGpwL2ttZkxyTkpSSW9WcVA5TkNpZkZlQkVzZFN4bnFranNMYlNzVEZvR3d2dHc5UTFwN3hmczN1eFRtekcwdHNhVEMxcFZuV1ZMTUZpOG1TWnVianZ2V0lTV2dJTVl2b0ZOSk1rdVFKV2lkb0tYRXp6L0phaFcvOHplMlRrcThHclQ1Uk9YK1IxN0lEL2ZmcmJ0d0trUGFzRFF1czg2SUZrR29nMzkxZk5Eb0pEK2FKZk9UZXN3UFJ6YlZJcFVBRTZHU0tmai9GR3dOQk1senJjY2U1bFB2djZWS2F3TzYrNGVFSCtyejN3WVFmdmpQaCtRdExaZzNSU3ExUkZBY0Y0Vm9nbUhDSXFUcDJiRFdwaXBrakx3cVNSR090b2FwcWhJQTN2L2xObkRsOW10a3NMZ0RqRU1CaHJVV0syS0RRMmU0QUFJQUFTVVJCVlBnL2NmM0xmRzNuTVJhMlFzallqYS9ReEpMb3Zudm9YeE1DVmVOSkUwR3ZvMXRUejV1QnMxaGE5cStYVEs0dEthYzF6YUxHbEFaYkd1clprdVZrVHJPdytBckNpbGJUVWdLa2hpU0xMNTFLa2pSQnE0UnF4MUx2TmpGRnJjQU1BRkk4VVFsKzAvZ3diZ09rT1pKQnZpL25Wb25WbnBNbmhqejk3TFZWNit3QUk2V3dSWmFGRThPRVVTOFZBdEFpYnNHTjlhMGtxR1AvMmc2WHN3M3VmWGlUTnorcWVlTEZKZWtvNWIvNkw4NGlPNUwvNlo5ZTR1c2ZmNVd6ZHc3b25ObkdqQlZtWVJCS01oeU4yRDV4Z3RGb2pTelBrQzBDVit1RU5JMGU0UFA1bkxXMU5UNzR3ZmVSWnprN08vc29wVnFjVnF2eUdBUlZYZkgxeTEvbVd3ZGZ4bG1EYkJ4QlNZS0wzNUNRNFBIUmRRckFSN0pXczJpZ2t5SkZMS1VBcXNZeG54bG1lelhWdU1Fc0RhNjIyTVpSbHczTnZLU2FMV2dXRmx1Qk4zRFV4a3FxbURsMEFqSlY2Q3hGQ1VWNXJhYmNyMWs5aVlodmRrQmdkT0NaeXZvRFZxcUlyVWFaL0Q2bWtGc0IwcDdwckNKUEZWWGpmQ3lIc1NGZzc3bmorUFhqWGU5c1kvVE51aDJhT25MTnh4UExzVTNGZUdlUFo1K29HWnhaNXpjL2U4Q2piK254cmFjTUY1NWI4c1hQVHppL21hS3FISDhsYWZrWENhTzFkYlpQYk5QdkQwaDBFdnVOTktYYjZlS2NRMG5GZUhMQTJ0cUlEMzdnZmZTN2ZmYjJ4d2dCZFZXUnB0bmg0bTczWUpldlhQMGkzNTArU2ZBdVdnbGtDdWQ5M1A1cmdXcGh5d0VaOXpBQkd1T29Ta1B3MFVyT2VhaHF4M3phc0J3M21Ga3NwMnh0Y2JVRjY2Sll4S0trWERUVWkwQ29YM3VEaFlpMkREb0hsVXQwcWxGZVVWNnZxU2ZtME1qbWNHUVlLZnhYYmZCLzVPUGt5dEt5QXdPd0NkeTRWV0o5L3dQaytMR2VXQ3lOQ0VGSUlZUUdrdHRPcllsVFc5MTNtcXBlRTFLc1BHdHdMdEF0Rk5hQnRZSDE5UVJ2R3VaN0MzcVo0T1VYRjN6N2lRWFhMaTdKdE1BbG0xaTlpUXVTTE0vWTJqckdpUk1uNkErR0pHMjIwRWxDbm1ka2VXekV4K01EYnIvOUhPOTczNCtRWlRrSCsrTkRGTzRLTFN5RllGSE9lZXpsei9Ma3dSUFl5bUJ0M0dXMGpVZHJCU2hhRjl3V2RPaGk1cWtyUjdWWG9ZTWpIMlhNRjViWjFGQk9MV1poY1kzREdSOUxxOHJFdm1OZVVpOUxUT053VmZRcHVSa2RJQkpRV1ZRZ1VWcWlha0YxdmNITzdkR2dPQVJVQlZnSStJaUYzd3V2QlNQNnJDMnY2bHNaNVB0L25JdURUaUdDRHlGWXdIMzNoYjFYN2o4My9HcWFxYlBHdEQyS2pGdnkrZHd5NktmczdsdTJwd21kZ2Flc0RJL2UxZVBCczExODhGd2ZTejc3YmNsNE4vSTZ1dDJDWThlMzJkamNwRk4wVUZxanRVWW5DVm9waG9NaDArbU04V1RNdmZmZXpidmY5VTdLc3VGZ01uNU5TZVY5M0ZJdldmQ1ZxMS9rK2VxN0VUbThqSmRRZUE5U29YVkVCQnNMUGtpRURNZ1FyWmE5amYvV3FQWXNuOXBuY3FxSHJYenNLUnBIc0I1alBOYTQ2R1hvQTdheDBTck4rTmh6aE9pUkdGcGROcUhqeTY5U3d4S2FzY0diY09oMTRtKyt3akJWWVpqcHoxNWJOQjg3TXIyeWdKZFNSRlZFOTMzcjBXOEZ5TkVqcFl6dzBDTTdzV3M3czhYdTFIeHhzOXY1WUhNdzIxQXlYZ1lwb2F3ZGcwN2NqRis1WmxpM2d2L3AxeTl4YWl2anZ0czY5SG9qSG44KzVmcUJJMDFWNjk1MG5OSGFHbGtXK3cwbFpmUS9UeE9Lb21CM2J3OWpHdDcxem5md3dBUDNjK1BHRG90bEdjR09JU29RbXJZaFg5b2xuN3Y0dTd3d2VZYkZ3bEhPRytweGliZU9ZcXRIVW1pOEM4Z1FDTTRkYW5hcGxxeGxqU2MwamtiRHlmMmF2UzlmUTkyMWp2TXRLdGw1dlBINHh0RXNHa3h0TWNiaFFwU0w5cTdsNTdmTmhKQ3g5d0RvRlNsWkEvWEVSQlJCR3h5V1ErYzRPaEx4NkNpdEJtdWRQL3JrQ3djSE1sRDdFQXd0alAzNElBdDNIdXZ5eEhON3R3TGtCK0dFRU9VNHJYV0hBZUtkTTgrL012bE83NjcrZDlORXZjc2JGMlJBQ0NHd0xyQ3NISW1XWE4rcE9iN1pZM3N0NWROZm0vREVpd21ibXhLaEE1MU96dHJhQnNlT0g2ZmY3MGVDazR3U1BrSUtpcUpEbHFYczdjV0w4Tjczdm9kNzdyNkhxMWV1c3JkM2dERU5hWnFobEl4QzBqcmwydklxZjdUN1JWNnNuNmVlTk94ZDJPWGcrb1RGL3BMZTlwRGl4Q0NXTTlaajI0V2dGQjRyNC9ZODJJQnRITTU2Rk5EVmdzNlRlK3p1VmRSM0RQRkZHc2xkYlNubVcwU3lXS20wdERiTnZybVpQVkNRRnBLTmZvL2JoMXZzWFp0d3llMGVsbFJIRnhvYkNkeWVDVTRXZXZaSzVWNDJMaGhCT0JTZEpnUi9iVktGZDkrMXptUGZ4enR4cXdjNWN1YUxtcUpJc2RZSmdaQ3RySFF5V3pUK2p0UEQ5U0xsTGRZNnZYSjZJclR3ZHkyWkxnMnBscVJGd2JWNWo0M05MWFNTME92MzJONCt5ZkUyT0hTU0hOb05kRG9kZXIwK1pibGtQQjZ6dHJiR0I5Ny9QdTY0L1J4WHIxNWpkMitmTkkxTnZkWWFLU1JhSjF6Y3U4UW52L3NKbnIveU5OTVhEN2o2ekRVbTE4WVFvRHZzc0huM01ZcTFRekc4bTR2QlFCVFM5aUdXVDlZeE1uRFBnZUhWQ3pzbzV6bmxJRnlaWVpZR2F4MEdhRXBETURhcXQ5UUcwMFN2ZGxjRmZOMW0xQlNHNnhsM2JHNXkxL0FFZlZVUUJPek01NWdXeTdXS28yMEZkeFd3bFNuV1J2M0xGMHYzNjFlbTFRNndGRkJMS2V6SlVSR21wZVhwSzdQdjY1MjRsVUZlZDM3OGcyL21jNDg5RmNhVGhTZGdnSG8rTDh2OXVmdkc2SGg2VVVoeko5NjNxdXhSbExxdUxDRUV2djZDNDRZWk1CcEdCNmwrZjhEVzhlT3NyYTJSNXpsU0taU0lRbTVGbmxOMENwWmx5V1F5NGZiYnovR2pIL3dBYTZNUnU3djdHR1BwZGpwQWxPNXBtZ2JyUEM5OTl6djgraS8vUEZmM1hrR1VEcmRvME1IVDZ5ZUVzMnNVV3dOMHFxTUJTZXVETHRvTnV4RUNIV0l2WUgxZzFBVHV1RjR5ZjJXUDZiSmliQVJuTi91Y2JBelpxeE9tMXJDYmFKb2lwYzRWaGtEVEdLcGxRN1B3dURLS2VSZER5Y1phbDFQNUJrUFZJVmM1V2lzMlIwUDYrd2ZNOXcvd2JWbDFYTUFaQlprZzVGa3Frank1TU4rdkRrZTdJV2FQTU1oMXVQd0RjQjl1QmNqclRwcEsxdGQ2akNjTEx5S0owQUwyOFc5ZWV2bnNqOS8xakZEcURtT2N0QzZRU2tnRnpDckJqYnJMdGJMQUJVR1d4Ukh1OGVQSEdRd0dwR2tXamU1YjdyWFNVVFI2Zi8rQXBxa1BnMlBRNzNQeDBoWHF1c1lhRytWQzI5RlFrdVY4NWJPZjRiZCs0V2VaWDcrR2JxVkxrM1pZSmZaclJIbURjSFdDTzdkT2Zkc2FjcEFqTTAxd0FTMERTc1RBRUFGTzFvRmpWNWZNcjAxWUdzT3dTRmtHZzBYUTdXYVVlSHpwU1d2RCtySmgzOEtlQ293WE5WWGw4Q1plK0dKTjB1OFVuRXpXa1pXblNwdDJqeU1wc296and5RlhKMU15N3pnbFlCMGlrbGdLTWVnVjVjVHhsZWQzNXBQVmFKZm9GaDJldVRyN2diZ1B0MHFzMTUyWFhyN0M5UnV6UTBtbTlqM0s2dHB3NXVUYW9GZUl0MVMxeVFTSVZBcW1UY2FMc3g3N2RZNlVtbTZ2eTdGang5c1I3b0FrVFpGU0lvVkVTWVZTR3VjOWk4V2NOTkc4N1MyUDh1NTN2Wk0wVGJsOCtTclQ2WXpnbzJtTTk3RW9LY3VTTC96T0ovbnRYL3dGbHJzM1NGUWNFbWdkTDV2V2tLWlFKSUcrdGZTbUM0b2JFK1N5aWFXUWlsbkxlOUNsNVo2RGhoT1haeHhjbjBhZmNTbFJDRElsVUVJeUd2VFFVaUtrUXFuNHltV2dhQXpkeGlFYThFNGdXcDkzTlFzYzd3MlJTckZZTEtJN3JvaWFXa29wcHVNSjI5YXlMa0FweUJJb1VrMnZsMSs4YnZtMTUzWVhGOXZSYmkwRUpwTWlETFNpOU9GV2dQeWduRGU5NmMxeGcxd3RrUkhFdXZKTlQ0UWdCWElYZ2poM3N2K290L2FZbG9KSmxmUEtyRXZsRTlJc1lUUWFjZUxrS1RZM055bUtBcTMwb1RxSmxBb3BKY1lhNnJvaVNSSisrSWQvaUxlLy9XMkVFTGgyN1FiajhhUlZWNG5RRUdNYVp2TTV2L1BSai9BSHYvb1J6R3hNb2tESk5qQVVKRHFLTzJjcDVDbGtxYVRRa242QS9yd20yMXZTbXplSTBxSnM0UDY1STdzNDVmS05NVktyQ0V6MGtDZWFQRW5KbEVKS2daZUNSZFhRT0U5akxkUGxFbU1jdlVMVDE3Q2VTZnBDSUpvQWpTTVlTNy9maTVkS1NicWRiclN1RnBETjUraXFndmJyVGxQb0Z4bEZyL2phbDIvTVB6RmVtakZRQ2tHTkVONzY0QXNsZnlBQzVDOThpZld1ZC84SUJ3Zjd2UHZkNytPVG4vdzR1N3NoMnFHSHcreWhRa0FLSVpKWExvMzNwdmR0Zmx1TC9KN0xrMFJQeWhTUHBOc3RXRnRmWjMxamszNnZUNXFtaUphWkYwTEFPWWNRRGlFRVRkT3dzYkhPZTMva1BaeS80dzZxcW1iL1lNeDhOc2M2UnlvVHlxcWsxK3V4UDUveHFZOStoSy8vM2lmQjFLUTZaZzRsNGtWVGJSYkpFbEJTa0dsSm9qV0pWRkVWUkFseXBlaVVEYWtUaklKaU9hKzVPRmtpbFVTdW5wQWhTdXhvclZIZTB4aUh6aE9rVG1pcWhyS3FTWkRSVkpSb09wcklRS0ZobEN2bVpXQlJMNWpzM1NEdmpYRE8weGhEcjlzbENacitvTWZ1Wkl5VVVjbzAwU29NdW5udGxQcjJsWEUxWGcyNVFvaDAvaVRYN0ZmMkIrSisvSVVQa0MvKzRSZDQwOE52NXFNZi9SZWlhUnFjRHlzelQwM3JOZ1VVSVlRa1NmUCtxN3RGa01pd0tBVmFTL3E5THB0Ylc2eXZiOFNzb2VPVUNxSlEzR3Avc1hxZFBuMmFELzNvQnpoeFlwdkplTXJCZUJ6OXlQTU1CS1JwUnBybFhIcmxGVDczc1YvbXFjYytpMnJKUjBvZXlSNjZWUnZTa0dpSmxwSkVhVktsVUZKRjUxNHBZcFpRa3MxZVJsMDFYSm1VcEltSzRoTEdFUkpCWXl6R1F6ZUxEckpKcWdsZTBDOHloUGRJSDVndGx2UVNqWE9CaGJGb3JjanpoTEt4ZEhJNGU3eEhKMHU1dW1od1h0TTBEUXVpL0tsSVV3UUNMUUo1SnVoa3FSaXVkeTkvK3VyczY0MzFxL1dJRTBLRXpub1JUank2ellWUHZYZ3JRTDdmWjIxdGplUEh0N2x4NDdvNE9EakFleStKY0hlOUNnd2hSQytFVUp3N2Qvczl3OEh3Sit0R3Z6OEVuK1JGeW1Bd1lHUHJHS1BSaURUTFVES1dKeUdBc3lZcUprcDVDT0M3KzY2N2VPK1B2SWRlcjh2ZTNnR3oyWnltTVhFTUt4U2RvZ3RDOHN5VFQvTHhuLzJuWEwvd0pGTDR3MEpZdHNHUktFaVVJRThqNFNwUkNpMFZxVklFQkZtaW9tZWlEK3d2REVKS1R2UURyK3pOYVV5ME5oTktZYTJOWktiZ1djc1RWS3VUR3h2NXVMWG9Gem5kTEdXOVUyQTlUS3VHeHNUZnEycEhraWFjM3U3VHlUUEt5ckNXMWh3czlqR01TTk1FNnh4SlhwQW1ta3daa2tReDZHUTBwL3Z1MWZHeVBySWk4WUJYbVdvRnJMa1ZJTitQOC9ERGovRHFxeTh6bVV6dzNuUGx5bVV4bTgwRUlFTUlSN05HQitnTUJvUFIyZHZPZlRqUnlVOFR1QXVCN25SNnJHOXNzTEd4UWJmYkkwbVQ2R0dCUkNxSk1lWndNKzljdkpCdmZjdWovTkRiM2thZUYrenM3TEMzUHlaSkl1ZkRXUnZIc0NGdzhjVVgrZFMvL0hsMlhuZ1NyY1BoWnEwVlpFUzFmVWVlQ0ZJZGd5TlJpa1NxeUxOb2pUU3V6QnB1TEEzanh2SEFWcCtyQjNObTg1SWlUZUttSE05b09HQ3QzNldwRzB5SVkyRmpBazFqMGUzL1ZFcElwU0RQY3E0dkdpb1hTSktjRytNNW5Vd3dHT1FFQjR2YVJRa2pBbDFsS2VjN1RLb2wrWEF0cWowV0NTbU9icGFUanpxOHNwYmwrU2p2OFJxWVkyQnhmUkY0aUZzQjh2MDQ1OC9mU2FmVFFTbUY5NTdwZExvS2pKVjVad3JrUUFFVXg0NGRQM1gyek5tZkN0Ny8rODc1a1U0MHZWNmZ6YzFOUm10cmREcGRsTllvcFZyMm4yd0ppZEhXelRsTHY5Zm5iVzkvSzI5NjZDR2tsT3p1N3JKL01NWjdoN1d4cEhJdWF2WSs4NjJ2ODN1LzlQUHN2UG84S3ZVRXp4RjFjOUFDTWcxWklraTBKRTBTMGpaQUpJSzU4Y3lzWlc5aFdCaFBnNlJJY2daNVFXVWFUR1dwNW9hc2s5QWJkTmpvRlF4N1BjckVVVllMSEk2NmNSSEU2Qnl0MWpaMmFjaXpsRUpLbEJUNExLVXBVb0p3ekJjMUxrZzYvUWkvdDg1aG5ZK3FqTTJFK2JVRlRkRW54WkNsbXExK2grVW81NXJ4WksxUXhzM3dpS3Iyei8zT0M3Y0M1Ti9sK1ptZitRKzRjZU02bHk5ZjVzYU42eUtTajRRTUlheklVZnBJMXNnSC9jSGFxZE9uMzk3cmRQODk3OXc3dlE5NW51ZGh1TFltTmpjM0dReUhoMDVOV1pZaEVCSEhGWHhrK1ltWUZVNmVPTUg3UC9BK1RteHYwelNHMld6T2VES0ZBSWxPUVVEZE5BVGdHMTk4akUvK3kvK0Z4ZDdWcUVmYmJyK2xYTUZFMnRJcWlVWXllWktRNnJnTkdWZVdTVzJabUlCWEdxOHlHbXVaTHcwOURjZjZQWnFxSVR1V3NHd2MxbHM2aVFidkNWV0ZxU3pMcXNIaFNGcWpvRVhkVUZ2SHNyYlVwYUZJVTI0L3RzWm8xRC9VemIwMkhpTlU1Sy9nbzVwSzNza0pDSFFRT0Y4UmxqVjJVWkozQklPaVIzZTk0SnM0bkF1WkxwTGUwYzlKRUwvUEg2VHo1enBBM3YydTkvRDhoZWZvZEFxRUVGeStmRW5NNTNQaG5CVWhzT28xVWlBWFFuUkNDUG1KRXlmUG50dysrZE1oaEI5MzFoOFhVb1RCY01EbTFwWllXMXVqNkhRaTdFTkswalJ5eFUxaktPdUswREw4NnFybXpKblQvTmlQL1NoYlcxdk01M01ta3lueitSSm5IYzQ3Y0pFRmFJemxzZC85Skk5OTRwZXBGL3NvRlRGaGNzWEtXd1dIaERScCt3dVZVRG5ZcXhybUpsQUZ3ZElHREFwckJIWGRZS3FHVk1EcGZrR1JLTHdSalBLQ1ZEdXlJbUd0M3lGSkZONFlaS2JZbjFzcTN5Q3lES1VqVE4wMWhqelJkSklVRlR6enNxTEkrbFJhTTBjeDZ2WndPa3FxYXFrSUlucWtKSGxDTUlIRjBvSng5RHFDWVNmbDJLakxwU1N3WXp4cmtrN1NUZFk1UW84UElQd1B3R2ozTDBTQXZQbk5qM0JpK3dUWHJsM2xsMy81WHdtdEU2YlRxUXpCaTdiWE9HekVnWTdTdW5QWCtic2U3blY3LzdGejlvZTlEMG1XNTJFNEhJbXRyVTBHZzJFRURPcTR6OGp6bk9GZ1NGbVdWSFgwT3ZjK0dzSzg2ZUdIZU90YkhtVmpmWjJ5TEJsUHBzeG44ME5IcHhBQ1VtcHUzTGpPNDcvL08zenREMzRIVTgyajdtMkl5b3BxRlNDQWJwdHpoK0NnRGxUV01HOENCNVduRHBBa21ya05HR3NwdkNjWE1SVjIwNFF6YXgycTJxS0VJc3NWd1VUcGxtVmpLRUxBV2xqV0JpVWsyK3ZycUFDTnNYUmtTcTZUeUkxdmhhdUY5MHlXUzlLaW9KT0FWd2xGb3FKTkFoemFaTS9uRGJPOUVsc1plamtVdVdhcjN5TVpabnlucVhCYTBUNEQ5TkVBRWExMzRVM1UxcTBBK1RNLy8rQWYvQ05lZU9FRit2MCszMzNtR2VienVaaE5wNjBFTmFvTmpxTzlScjY1dFhYeXhQRVRIOGl6N0tlc01lZUZFS0xmNzhlc3NiNUI1MGpXa0VKUzVBVnJhMnNzRmd0bXMybmtPVGhIbnVlOC8zM3Y1WUVIN3NON3ozZzhZYkZZVWxVMTg5bWNxcTd4M3RQcmo5QjJ6S1VuUDhIamYvQTdCRlBqV28yc3BBMEsxZjRZaEtBT2dya1IxRjVTQjZnY3pKckEzSUltTURVR0NmU0FUbXQyS1FPY1dlOXdZdGhsT2lreDF0SXAraFNwcG1xaWJaeFFraHBCYlN5NWxJVFNNbk54UXBVbW1tRy9nM1VSNFJ3RTBlVXF3R3l4b0hHZU5ORjBpcFRFV1JaVmd4ZUMyYVJpOS9vY2pLT1RRU2VYRERzNVcrc2R2bWxyOXEwajB4b0VVaVV5UFJJZ1NDbEZwakpoTU9GV2dQeGJPdi9ELy9EZjhiZisxay94KzcvL2FZeHB4R1F5RWY2bVVzblJDVlZXZERxRDg3ZmY4WTVFSjM5VEtmMURUV09LTEVzWmp0YlozTmhrTUJxUzV4bEs2Y00rbzl2ck1SZ01tRTJuek9hemR2dGUwKy8zZU45N2Y0UUhIN3dmWXd4bFdURWVUMm1hQmdLVVZRVkFyejlpdm4rWk0rTHptTWxUTE9zR1lXSjlrYVdnVmV1VklTVU5DaXMxSmdnV3hyTzBubGx0cUcyVUE4MmtJRVdnQ2ZHYkVuSENKWWprcUR0UHJLT2xaRkZWTEJxTHloSThVRllOdlU3R1RJRkdNTktTcFV0WWxEVk9lTklzUVJMd1RhdFVqU0JSa2tWdG1TMld6T3NhcVJTemVjblY2MU9LSWtXbml2R2tZbnl3Qk90Sk5IUXlRU2ROMkI1MDJWV2VyeDhzRUVWRzhEN2dnMG9MM2VHbWZaR0Fsdmw0cThUNnN6MXZmL3NQOC9MTEw3Szd1OHV4WThmNTVqZS9LZmIyZG9YM2ZpWGpzNXBReGVBUUl0L2EzTnErN2N4dGYwVUorZE5OMDV4MHVORHI5VVFjMzI3UjdYVkpWdEIwb2hWenQ5c2xUVklPRGc2b3FqTEN4a1Bndm52djRTMXZmWlJUSjA5UTF6V3oyWno1Zk5rNngzcE0wekFhclFId3pTOCt4czZyZjhDWkQvVDUwbE1UYk8zcGFFVXYwMmdWTThiTVEya0ZYaXJLeWxNYVMyVWNqYld2QVlpbEFaSVFEcWNNc3MwZVFrQS9VUXhUeFdKUmtXdk5vRnVnRTgxa0ViUEpLN3NMUnYwdXFkS3hYMUdLZmlmRmlqaUpValpnakVVbGlrUkU3L1Rsc29JQXZUUkRLc20xeVp6OS9STEVBbHJwSWRIcVlCVVo5QXZOMXFDTDdpWDgvczQrbFpSMFYvcGRMaEJXVHFjZ2ZsRHYxcCtMQVBuS1Y3N01iYmVkUlNuRjd1Nk91SEhqdXZUZXkrODFvZXAwdW9QYmI3L2pIWjI4K0VudjNGdU1ONzBrVGNOd09CUWJtMXNNaDBQeVZvTnE5VFJMVy90a1l4cktaUmx4VXRaQ2dFY2ZlWmozdlB0ZFpIbEdYVGZNWmd2bTh5V05hZG9sWUNETEM1SWs1WXUvODNFZSs0MWZZbXNEUHUzV2NSUExtZlUrYU1uU2VuWkx3N3h4TkNhYTduaDREZWFsNENZYlR3R0pqNU1HSmVKL2h4QUJpUUNOY0h6MnFVdjBNOFh4ZnNGeExWbkxFN1JXakZKTjFtZ3VIWlRNcW9ZN052dkkxdVlnVjVMS082UVFqTG9GUXNZU3JMYU90QldldHM0elh6VE01MUdLS0xJTDIvRzJpSml3WHFFWWRBdU9yWFg1d3NHTWk4dWEvakRpczFyNnJtOUtVL0Y5MUx6NmN4MGc3M3puTzluYjIrUENoUXNNQmtObXM2bHd6b2tRZ2d3M3QrR0h2WVlRb25QbTlKbXpHeHViZjFNci9kZWF1dDVRU29taTAyVmpjME5zYm03UjZhNnlSbHhkSzZYb2Rqcm9KS0ZjTGx2cnNvQjFsclgxTmQ3K3RyZHl6OTEzeDNKak5tYzJXN0JZTE9JbTNUZ0lrT2NkbkxWOCtqYyt3aDk4L0pjSTFqQmVLSjUrWmNIY09nNHF3N0p4VkkzRGlRQlNJaE9KN2lXa0lhQk1lL0Y4SUxFZTZVSUxEbXUzNjhUbG9TUUd4NnBDS1d0UFdWVWNMT0hWY1VsNjVZQ3RYa2FSS2paN0hhYVY0Y0wxTWJVTGFLVzRmYTJncVJ0c2lJTFczU3dsQ05CQjRxeW5MaHYyNWlYVGVVVlZSejkxYjhPaDhTaHRCa3MxZEhKQlA5T01pcFRIeHpNZTM1dVNkUFZyeHJsQ29MSk8wdVVJWURZT0wyUzRGU0QvaG1kclk0djE5WFVta3dtQUdJOFBWbnVObzl2d3d5YThLSXIrL2ZjOThNT3BUdjUrMHpTUEdHTlVuaGNNaGtQV056Y1lEVWV0WGJKcXZRTUZXc1dTQ2lHWXoyZHh1aUlFcHFtNTdiWXpmUENESDJCcmM1UEpkSXF4bHVXaVpENWZSR0tUdFhFL0loVlhYbjJKTDN6OEYvbk8xNy9JdktxWVZwNkRDbWF1WlNNV0NmbXhndUZhVHJaUmtLM2xpRTZLS2xKQ2JXbkdGYzVCcUF4dXY4VHNMTENUSmRuY3h2UW80NjZFOW5JS0dkMTBwYURWMDRtT1RjNTdMaDlFbTRjTDEyZUhKaHROZ0svZm1QTFN2R0lqVlNRaDBGV0NqVUVleVdERzBqU1daVlhUTk5FQnlyZXRpUThjTGhOWE5uWGRGQWFaWXF1YmMwTjZ2clkzeDh1b0I3enlZQWt4S3dxZDZhemxjOTNLSUg4V0owMHpmdTduZm9GLzhsLytRNzc4K0plRmRYYjFFRjJWVkFtUUNTSHlFRUpIS1pYZGMvZTk5NHlHbzcvc25QdFFYZGVuaFpSaE9CeUt0ZlYxMXRjM2IwNm9WRFNUcEhXWkZVSzJMTDRvNStsY2hJL2NjKzg5dk8rOTcySFFIN0IvY01EQmVCS2RhbjNBV3RPaWR6MWxWWFAxNVF0ODgvYyt3bzJYbjJhOWx5S2xaVkhWZ0dTd1hiQjIvd1pyOTIwd3VLMkw2bVU0SWJGQlVEY0JYM3RzNWFqbmxtYmVVTTFxYktHcE1xaVNHbVV0dW9UY1Flb2hiOFVUVlB1RUR1S0kyb2lJMGo4dURzcG9WaThpalEvcktlY1Y0d0NiQWlvdHFKbzYyc1laRzZkcC90Q3htcGE1ZXppTVhTMHhPeG4wQzhsV1ArZGFMdmxpdVdTWkNWSjArNENKRmdveXVtd0ZVN3M2Qk1JUDhwMTdRd1RJai8vNFgrTDY5ZXRjdVBBQ1AvZHoveHRwbG9tZDNSMFJRaEFoQkJWQ1NJNU9xRUlJK2ZiMmliVjc3cjduUTk3NWYzKzVXTndESkZtV2gvNXdLRFkzNGpZOHk3SjJ6aTl2NW40ZkNFUU5hOVA2RFZwcldGOWY0NGQvNk8yY1AzOEhJTmpkMjJkbmR4ZnZBbHJydVBtV0Nwd1BhWkx5N0xlL0xKNzgzSzlUNzErbGt4ZlV0VUVGU1dlN3h3TnZQOG5HVzQrVEhpc0lXbUY5b0tvQ3R2YlJDOTNIWnNMN3FFZ2lHNGVZMWJCb2NNc0szNWlvS3hXaVBxY01rUGtXSCtNakpFVnk4eWx2UTd6UW9SWEJYVkgzMG5ZMFhJaUlEbFlPK2tLZ2RaUVh5clNrYk9MZnN5dExoRGFEK0hCejgzMHpPQVREZnM2bFFjNVhuYUhPTXpwWndOY0cyWXBrSHpwQitpQklpTkwxdHpMSW4vNDg5TkJEL083dmZwTDN2LytEVk5XQ3h4Ly9vckRXQ3VmY1VVaDYzcjZ5ZnIvZlAzUDZ0anVQSDkvK0tXZmRqeTNtODRGU21tNnZ4OXI2dWxoYlg2ZmI5aHBDQ0pSVUxkdk8zeFIzSmtyOXUxYTkvTVQyY1Q3ODR4L2k1SWtUSEJ5TVdTNlgwU0RIdVFnVk53WXBWWlR5RWJMNTFtT2ZkazkrOWxjN3dTNEFpYmVPYkMzbitOdTJPUFdPWTZUYlhSb0hWZU9wYTBkbGFCWGdpZnBWTG1wVzJjcmhTMHRvTE5LSEtKelFOSkZ2M3RJbGdnQ25ZQm1nZFBHU3ArM2xkOXkwSmZWRVg4SHNTTE4vOU5VRVFTb0NvbFU5OGExUGlKY1NhNklLNHlvd2pvSW5Fd1Y1QnNOYzBsL3Y4dUphajFlVVFKSFFhWFcwN0NxcUVLK0YvNjgyakVlbVdMZkd2UDhIajFLSzdlMXRubnJxU2VHY0U5WmEyWlpWUjhHRkhRVFpndzg4ZE9mVzV0YVBXMk0vTUovTzduVE95VTZ2eDJnNFpHMTlrLzRna3Bsa1N5V05TaUdDeHJRMlpXMG1FVUxnbktQYjdYRC8vZmZ4OEp2ZVJML2ZaMy8vZ0xJc3FldUdnRUNwaEdvNlJ3akJjTFRHWWpHLzhmblBmLzZ6di9lcnZ6QmZWL1dIUnAzc3RxSlFZdmoyNCtpM2JXS1BGUmdmYUV6QWVIQkJSR1ZHRjNBdUJvbHBQSzUyQk9QeGxjWE1HOHlzcHA1WG1Qa3lSdENxZ1ZCdHpzemI1bndCdG9xL3ZUeHk2OFNSSlpBODhzRW5SNXI4bFZlSUQyQ2JhQkZYMlJBMytDS0tVNndDUThpYmJNYXVobDZ1NkI3cjgvS0pFVmRTUlZLN1ZvdXI1Y1BVOGpYZHVWUVNLVVR3WGdRaFJRaXRGcWtRQXUvOVRhdmhXd0h5SjUrLzkzZCtobWVlZVpwWExyNGlsc3NsZFYwZkhkMG1SUHhVRVVJb2VyMSs3eDN2ZU9mN2k3ejRxZjNkdlRkVmRaVnFyUm10cjdHMnRzNXdPS1FvNGpSS0N0RWljQ1ZLcVFoTlgwbHpCZzlDWW94bE5CcnlveDk4UCtmdlBFOWQxVXdtVStxNnh2bW83T0djWjdrczBVa1N0TkxpNnRYTEwzM3Fkei81U3gvOWxWOSt3aGlqTjd2SnhidHVWMy9qM2crZGVqaDl4N1pjQ0JBdVlOdUh2L01CYjJKZ0JCOXdUYUJaMVVKTndDMHNmbUdnY2ZqYTRxb0d1Nnl4MHlZMkRqSStIa1FCTWhmb1JFSlgwT3c2d3ZLbTlpMUU5ZWNnQldIbHV0dmVWZDJPWldNR2plb1VkZnNsdUdqTWlHa0NpUlpJTFFndUNqOGtLV1FLaWtUUVhlOVNuUnh4ZWF2SE5OVjBmTUJsRG1jZHRySjRZOXZJdXlsL3VzS1ZxRVNzN2w4NE9zbTZsVUgraEhQbm5YZXh0N2ZIaWUxdFhuN2xKZkg4Qzg4em44K1BjalZXTzQzRHZjYjU4M2VldlBlZSsvNldiY3pmMk52ZDNiVEcwdTEwdzNCdFRheXRyZEhycjdLR0pORkpxM3RidDBEQkprSXUyc2tWUVdDdDVkaXhMVDcwb3gvZytQSHR1QlFzNnhaRHhlR1V5amxQcDlQQk8rOWZlUEhDTTcvNmE3Lzh2MzdtTTcvL2JKdlZrdEZEYTR0Ny8vN2R5ZkRzUUpRZW5GbXh6YU9wWjNEUjRpdzRrRDdhRUdBQ3B2YTRPaW9lc3VwSG5NZlZCdHUwS29XQnd6cEs1UUtkYWJSV1pHbENuVG9XMXlyQ3d0K2NBK2VTa0NqY3dxSk1PSlQrZEcwZkl4MUlKYWhkVzE0UnM1bHEreHRDYTMydDQ2U3NTS0hUVDZuT2JYTDF0blhtZVlvWE1aVUw1d21OeE5RU2IwTTdWanVTUUloSUFhR1VNOFl0Z2orVW5mdUI3RVIrb0FKa2JXMmR5V1RNOHhlZUYwUjhrM3dkZm1wVlFtZW5UNS9aUG4zcTlBK05obXQvWlRhZHZhMWNMdk1zeTFqYldHZHRiVjBNUnlPeUxJK1pRbXZTSkNWTkUrcTZvV21hdHRZVkxkY2lFcHVTSk9YUnR6ekMyOTc2Vm9RUUhCd2MwRFFHWXlMcnp4aURzeDRoRkVtaXFjcHE4c3gzdi9PNWYvN1AvOWxIdi9YRXR5NGlTQWo0ZTk1NS9QVDcvcFA3L2s3M1JQZitzdkZDU1VHbVlxWXdQcjdwemdlc0VDUWlFdUIxaUJUZHhucUVjZEh0eVFkY2JhSkxiR1B4dHIxTDdaWkhacEFraWl4TjBXblU5dFZKYkV3V04wcEM3U01NdUJOdEZPaEt4TnlnV2wrT1ZhQUVZc2F3b1YwNDBrSnIyeDVqeFVmSlVoajFOY2xHaCtXRHA1aHVENmlKZFZuV1pramhQRUZHSjF3cUVkMmsydklwdEg3d1BpQ0VFaUhVd1J6NUVnZ2hoQ3pMd213MnV4VWdSMCtTSkJoamVPYVpwNFZ6Rm12dGlzUjBGRDlWQUVXMzIrMzkwQSsvNHkxNVd2ek5wcTUvYUQ2YmpwejNETmRHakVackRFZWpkblNiSEtKdWU3MHVCQmhQSnRSTmhXekYyMlNiT1pyR01CajBlTmM3MzhGOTk5MUhWVlhNWm5PVVVvZGI4K0JodVN3cGlrNFFRb2k5dmQxcm4vLzg1LzdGUC8vRlgvamt3Y0hCUWdpaFFnamgvRnMyejN6d1A3bnY3M1ZQZGgrcGJSQko2MGlsbGNBU2JaVnRTNUFTclZGTjBnYU1jcEMwZ1JGY3pCN0JPRnh0Y1kySkdVWEVkMFNuQXAycjFnbzZSYlNiY0tVazNVR09jNEZ5MG9EUzhRVUVMZkJDRVl4enVqS045aUh6SUwySUtOeFNRRmZHWmw0Qm1ZUlV4WkpLWnBLa2x5SlBqTmc3ZjR6eVpCOFZQRWtBNFFWYWdBOGU1Nk5CajVEaVVBdnM2QWtodEo3cm9US2wzVDhTSUI0SUsyZmd2OUFCOGgvK1IvOEIrL3NIdlBmZGovRGYvNzkvanV2WHJ5T0VFSXZGWVRuMXh6YmhRTGE5ZmVMWWd3Kys2YS9uYWZxVFpWbmRWcGJMa0tZWkc2T1JHSTNXNlBhNlpLMmlTSkttRFBvRHBKUTBUYzFpc2JpWk9WYTdqamF4bnp0N0cyOTcrMXZaM05oZ01wbFNWZFZoWGI1Y0xOdkNDQUtFNVhMcExsMjY5STNISHZ2Y1J6NzZLNy84NWJxdXk5YTZMUXcyOHY2UC9aL3YvZXZidHcvZVVUZE9KSWtVZUU4VElyWUtBb2tTV0N0Uk1tQ0RJN2pvek9TYmdHMUJyRUtJUStpSWF4eW1ickF0QWhjWlRUZXpQQ0ZKVm5DWUVKZURPb3BoeTBReUdIWVJNcU9zM2MzaVJRaHNUMVBDYnBpVVh5bDZveDhxNityWWVEeEd0Q1BqUkVMZU51dWxnbTVIa3F4bHlLMEI2c3c2MDBHQjZhV29FRURKYU1iakF0SUhoSmF4dDJvRFJFcHhPR3NPN2ZjVlpWY2hDTEZzU25Od05EaHVsVmp0ZWZLSnAzbm80UWY0Yi8vNy80M0paQ0tjYzVFd2N6TXdrcHZ6R2ZMQllEQTRkKzcyQjArZE9QWHZXZXQrOUdEL29LTzBabTE5WFF5SEkvcjlQbmxldEZ3TlJWN2s5TG85NnFabVBwNWhXdGJlU3Rsd05hWEtpb0pISDMyRWh4OStDTk1ZRGc3R2JVQ1o2TDNSVHJXc2N4aGpHZStQbStlZS8rN3YvZlluUC9GelgvM3FWMTV1MXdraGhLQjFLdk8vK1E4ZS9DdTNQN0QrRXo0RUZhVEFBM1dRN1lJdFVOcUFkVkZvUWZ2NGhEYkJzelFlMTNpRTh4U3BwSzZndEI1Zlc3eHhtRG9PQlNDcXA2ZTVKczBTbElyY2xCVzdTcmhBOEJhWnBoUzlES0VEN3FERXRJNjZLN05QNmYxTFJpWGYyYjduN2g4TyszdmNtTTJnaWVYYlR0dFRod3lTVWNMZzVJais5cEI4VUpBT01uUlhJM1RFdHFTWndnVVEzb0VTU0JrUTltYmpIMXpNaEQ3RTV2NW0veUVSc0pqZFdPNi9Qa0Qrd21lUU5FMDVkdndZenozM25KZ3ZGcFJsS1kvZ3B4SWdiYWRUZVo3bjNYUG43amkvZlh6N3g0czgveXZ6K2Z3WUNOWHQ5eGtPQnd3R1E0cE9oelJKby9wZm5rZjE5RFJsUEQ1Z1BwL2pXN2VsK0FDTlAzb2YyTnpZNEozdmZBZTNuenZIYkRhTFhJMFFNSFZEVlZVc0ZzdW9jWlZsR0ZOeTdlcVZuVC82bzhjLzl0dS8vWWxmdm5UNTBvMTJDZTFYNytHUC9wMDdIN3I3N2NkK3NuWmgyRmlQZFZBUmhaNVNKU2hyejZ5SkhiQjFsbVVWa0o3NDVQVWdiVURXRHVNZHRuYUVaWVBaWDBUcmFPY2grS2lGcFZYclJoVTFnRUpybnlDbFJMWjJ0RW9wWkpxZ3ZVTkxzTVFuT2tLZ3BGaFMyVzlMb2VpdnJmV3NNK3htQ2I0TmtCVjhST1NDWktNZ0czWEp1amxKcXFLRlcyd2sydkswWFJZbUV1SGpvbE1FVUVSbGxCQkNhL2Jqa0RvR2NsUndrWUNZejY3TlZ5V1dGMEswbkt1L2dGT3NEMzNveHpnWUgvRDAwMC9qck9YYjMzNUM3T3pjRU1hWTE1UlRRb2ljcUVHVmJtOXZiOTUvL3dNL0xwRi8wemwvOTN3K2wybWEwdXYzR1F5R2RIdTlRMEZvclRTajBZaTEwWWltYWRqZDM2TmNMdU1UdHdVZXRqTjJ0Rlk4K09BRFBQTG1oK2tVM1lpbGFneDEwN0MvdDQ4UThoQXoxRmdiZHZmMjJObTU4ZTNISC8vaXYvaVh2L1NMZndETWhCQjFDTUd0c3QxZGoyd2NlL2pIVHYya1RlU1pSZTJwS29jTUFwRkpsSXg3RGx4c1pFM3JxNUhaZ0hTQzJrUWJBaHRDdk1pdERsVm9PMk5oUFZnWEZSQzFJazJqV21OUUVxbFVXL2ZINzB0TGpTZ1VXaVVSQmhJQ0F0OW1UVW1JRy9aTDFPNUMwdXVmbDBJb0pTV3ExY202T1JlR1VBZE1aYkcxd1JwSFVrUk9qSGR4d3krOHdIQnpOeElnOWxmR0kzMDdOcTROenJxVzZORmFWYmRFTFE4elc3c28reVB3U3FsZ3JRMS9vVXFzZSsrN2o4bDR6S2MvL1h1ODVhMXZBeERHR0s1Y3VTejU0ekk3UlFnaDcvZjcvZnZ1dmY4dC9YNy9yeEY0ZDFYWFE2MDF3OUZhR0E2SG90UHRVT1J4cDZHVXBOUHBzTGEyVHBabFRDZFR4cE9vR0hKemRCc3hFZDRIK3IwZTczNzNPN252dm51Wnp5SlBQQWd3N2RpMjF4dkVHajV5RzBKVDErN1paNS81L08vOHptLy9yNDkvK1V2UENGZ2lSTlc2VHlrQldWcW83TDEvNjQ0UGJaenB2WHRaZTZGRUlFOGtTU0x3TGRHcGJsV2ZaUHZLaGNCSWdUR3g3M0EyWGl4alBNckhmaUs0MEVxV1JqU2Zrb0pVcXlpUTBBYUlrQUl0TkJCSDFTaUpTdVA2ejFVT2F3STZUWEhlNFFKQlFxT2MrM281cjY2dW54NytxTkphNnlRSlVzalh3ajBFVUVNenJsaDJGeVJGZ3RCUmYxWG1VZk0wU0lsdFBLcXlpRlRobElpREJSZmF2c2xpVjVNM1FWd09SbzJ3b0hQdGhlS3FxMjJFdTRlYkpWWUxRUDN6SHlDRHdaQi8rRS8rTWYrdi84ZC9neENDN3p6MXBMRFdIbTNDVjV2d0FzaVZWcDJISG56VG5jZTNqdjgxYTkyUG1ibzVJWlVTL1VFLzlQdDkwUjhNUktmVGpmS1lLazV2dXQwZXcrRUlwU1RUeVlUSmRISzRCaFB0Q05lM2RlM1c1aWJ2ZmU5N09IM3FGTlBwak9XeWJQV3I0bE14MVFsb2dYVXVTQ0ZGV1ZVSDMvNzJ0ejc1ci83VnYvakZaNzc3ekt0QUZhQWtPaUJKUk9RcVBmcStVN2MvK1BaamYxMHIwVUdMSUVHa21jWUVPQ2lqWXFGekFlc0N4a0ZqSTZURXVyaVEwenJTWG9PUFQzeG5QZDQ0WEdrUVRVQWpvbmU1MWxGL1M2c1lIRnJGd0EreFFTWVI3YS9GaGFDMThkK1NRaUZWd0ZvblpPQmxNeW4veVB2Z09zUEJ3QWN2cXVVaWptTEZrUTFpTzNqeUM4OWliOUY2bWlnSWdzUUhaQjUxUW9NUUpDNGduWTlJZ01waUt4Y05QeHNIeHFGQ1FDaUZiR203UWdoVW9hdkoxZmxUM29YeWRkUG1QLzlOK3MvOHZiL1A4eGVlNTQvKzZISCs3Ly80djhKN0o0UVFvcXFxRlVUazZIUnFoWjhhL2ZBUHZlTkhlcjMrZnpDZnplNjExcXBPcnhkNnZSNzlmbDhVbmM0aFJDVDZidlJaWDk5QVNVbFYxU3lYRFkxcDBGcmpuTU03RjRQRGV6cmRMdmZkZXc4UFBIQWZXWmF6dDdlUDg1Nm1hZUlGYXJGWUlRUzg5eXlYUzcrM3UvdjBZNDk5L2w5OTlGYys4cG05L2IyeEVHSVpRaWpidmdNZ0paQ2t1Y3JmODVkdisvSGhNTHVqYkZ5UVNnZ1pGRWlGdHk3V0R1Mm4zMFpxMjczR21zUzdnS2tkMW5oRUVDZ0V0ckxVa3lyK3VLd3hpeks2MzJaUk1FS3M4TzB5TmdDdU1kaTZKaTB5ZEtJSlBnSUtuZk9INkZzUmxkYkhZVmIrcTJaYXZhano5SGpXNjQ2OGM4STBWUWl1blhUSjF3WUlEdHpNc0VobmJXUGVscWsrOWgxSkluRlMwTXhNKzM2dlBBd2RwbW93amNFSFNMT0V2TWphMFRwQ3Azbyt1N1o0bVdpMTV0b2V4Syt0clhGd2NQRG5NMERlLzRFUDhPWEhIeWRKNHRaYWF5Mm0wNGxvc1RXdjBicHRtL0JNS2RWOTRJRUg3ejUxOHZSUEpFbnlsMmZUMmFaVWlvM05JYjFlVHhSRmh6d3YwSW1LVExXOFlEUmFwOVBKOGM0emJadndMTXRaTGoxTjNVUU1neFJZNHhtTmh2ekllOTdGSGVmdllMRlljbkF3amppcXNQSVdoNEJGQ0JIU0pCR05NZFhMTDczNCtmL2ZQLy81bi8zUzQxOTZWZ2l4Qkk0R1J5QWF4U1lob043NTRUUDMzUFBtalI4aitDUklBVmJRVFJRbXhQTEtCMEZ0bzNKSThBTG5WU3o1UWpna05obmpDVDdFVWFrRFd6bk1vc0ZVQmxNM05NYkdxVmVpRVRxV1ZVckpRNG9yV3NjU3JCV3VzemFXVnNIRkMrdENDRUxpdFBlZnFTYmxOME1JZGRvdE9ubXZPN1Ntd1pwR3ZHWnlKRjhMNGdvRzZsbU55aGZvRldnckJIU1dZQm9JaVlvTnZ2ZklWQk44d0Z2ZlRyRGlRd2NoMjcvbWd5NHk0WHk0MFN6TmpaZ3pnMVZTK1U2bkUzNzZwMzg2L00vLzgvLzg1eTlBN3JycmJvNGRQNFpTbWsvODFtK0lka3k2d2s2cDF3RUxDeWxsZnNmdDU4K2RQMy9uaDVNay9WRm43Zm1tYVpKZXZ4KzYzYTdvZHJ0a2VSN1pmU0xXcnAxdWg0MzFEZElzWjdHWXh5WmNDSW84SjJLMXFrTTZuWkNDKys2L2owY2ZmVE5yb3lINysyT3Fxc2JaNkF6cm5DTk5VeGJMa3JxcFE1N2xUQ2JqSzA4OTllVEhQdm9ySC9uNGswOSsreEpRaFJBV3NSby9uRmkxbTMyU3JORDlkLy9Wc3gvV3VUemxRd2dDSVpSVTVEckIxTkhlek5vUW5XU3RPQVFqRWlTU0FDS1FKUkFLamZSUmFNN1UvdEFUTUZpSENJRTBUZW5rR1VGRVp4blZMZ09WVmxnbmNGcWl1amxTcThoL056NzJOUzR1LzlxRjVKTitVdjY2TTI0R2hPN2FvQytsekUxVlllcUtRd25IbzhIQlRTaHdLQVAxZElsdXA0RytCU0pLTFNQL3hIdE1hUkZSb3oyT200M0RtemdaaTFZT0pnSkVpOFEzUzNOeHVWZnVJSENFU0ZOWlpmOC9OeVhXUC94SC94aXROZi9ULy9qL1pYdjdCSys4L0lxUVVyQzN0N2ZhYWVqdlVVN2x4NDRkVzN2NDRVZmVzNzYyOFhlV2k4Vzl6cmtzU2ROUWRBbzZuWTRvaXNqZjFsb2poQ0JKb2tqMGFEakUrOEI0ZkVDU0pIUTZIY3FxWkRLZDBEUW1RaGxDSU05ekhuM2tZZDcydHJmZ25PZnk1YXN0ZzAxRTNvWVExSFhOWWxuU05FMVFTdnRyMTY0KzhmSGYvTmcvL2RTbmZ2Y2J5K1Z5MW9KaFY1YkVLenR2Y1NRTEptZk9EN2FQbmU0K0lxUk1SSWhxaEM3QTNBUnFMN0JlRUcxcDRpV0x3ZWxSN1MyVWJlT3FwY2RuS2o1eDZ5aktFRXpzUXlTeHJ3Z2l4QXdpQlI2UFVMR2VUL0lFNFR3aTBRamtZYVB2ak1lMmRGaEN1TzRYOWIrcXhzdVhWemxpZUdKNHJPajNzL2w0SEt3eklxeE1ETDlYZ0xUTVJMdHdsTWt5dnMvZWcwdkpzb1RHK1ppOWxNQTNGdHVDSzVzeVl0WkVLd2tucFVRb0tWU20zV0svK25JOXJTdUJNSUZndmZlK0xNc2Z1Qkh2djFHQS9QZi8zWC9MZi8zZi9EL3BkcnM4OWRTVG9peVhvbW1hMWJKdmxUVldXL0EwVGRQKy9mYy9lTy90NTI3LzYxbWEvZGl5WEk2a1VxSFQ3VkowQ2xIa0JWbVdvNU9vSmFaMTVGZDB1MTN5cktBeGh1bGtnbFF5Q3FVdElrZmNPUmVGbzRWZ1kyUEUyOS8yRnU2OTUyNW04d1c3TzN2VVZVM1ROSFI3MFRYSldZZHBERFpDV3BhdnZ2RDhGejcyNjcvMjg0Lzk0UmVlSVM2VEYwZUN3eDVwSVBYUk12SERQMzNuV3dkcjJSMVNTQVJndmFCMjBXMkhPRnpGaGRoYlNCOWlxRGpBT1VqVW9WS0JsSUlrRlFTbmNKbWlUaVZLZ0dsOUVJV01HQ1pQaUVoa3FRNUxMWjFwY0tFVlRZaVRNTy9hN0JIM0VCYm4vckRhbVgwbEJHb0FvU2g2eDN2SEVTRTFUUzFzWFJLOCsrUDl4MUg1Rk9JN1llYVdTaTZqbjRpSXFkUTFFcWtqZ3N2WjZLbnV5b2FtclBET3RZRWROLzR5bG9iWDYxbnpZdkJoeGR0eVFPaTBmb3h2NkFCNTRJRUhHSS9IWkZuVWl2cVZYL21vMk52Ym8xMzBIWjFPWlNCeUNMbFVxdlBvSTQvZWUrZjV1ejRrbFhxdk1lYU9zcXBrWG5SQ1VSUWl6M095TENYUktiTGxoQjhHUnA2VHBpbnorWXpGWW9HVUVSdFZWZU5EV1BSS0F2U2VlKzdpVFc5NmtQVzFFZFBablAzOU1RZVRTV3Q3cHFpcW1ycXFhSm9tTk1hRTNkMmRsMTk0NGZuZitNUnYvZVludi92ZFp5NjNqZml5TGFtYVZmUFlQdGFPOWxIcHZROXZidDc1NFBxUDVFVXlNTWJqZ2lCNGhRaiswSXRjQm5GWXVialFUcHVVUUdwSkVCRTY3b1JBSlFyaHdDbFBraW1LUVU1ZHBOU3pFcVdqV255V1pZY1hXQ2NxS3BDc2xvTUVYT1BiVVhIQVdvOWQ3U3FFdU9LbjVTZHM0eWFyV2NId1pIZGpkTHh6dHR3ZjYrVjhpbW1hN3kyOHM4cVhra09GK1dBQ1ptbGkyU3NrNFRCN3FFT2NsYmV4UWJlTmlTUHFkcGdBaEtSSVJETnZ2cnIzd3Y2Rk5qaU1FTUszci9DelAvdXpiOXdBRVVMd25lOThoL1BuenhOQzRNYU42K0xGRjE4UTN2dlZQa090bG4waGhBNkU3T3paczhmZi92WjMvS1ZCZi9CWGxGTG5sOHRsSXFVS3c5RklaRmxHbnVXSCs0elYzcUxYNnpJY2p1S3lUc0JpTVdleFhKSmxHYzY1UXhqSUtrQzAxano2eUp0NTI5c2V4VG5IalJ0N2xHVkZWVlp4U2FXanExTmQxd2doT1RqWXQ5OTk1cG12ZlBYcmYvUnpuLzNzWjc0SnpJVVFaUnNjVGZ1aE9hV1VIdzNYbUMvbVZGVVpleWtoRWtKSTczdkxzZHU2YStsOVZXMFJTRHdDS1FKYUNtcm5xUTBZNTJPSjFJWlhBSVFTaENDZ2RzaEVvWldrc2c2Q1J5bUJUaFJwSnlGZjYxQWVMQWpXa2VRSm5WNkdDNTVBVkRsRXRQVFpGVjdMeGdCeE5tQ014MXNmaEpSR0dQdkphbS81ekpFeVVXK2ZYMXZ2YjZUcnkwbkpjanFtcWNyWE51ZnlqNWRYaDhIalc4eVlhcWhqSFUyYXBVZ2RTN1RnUE01NW5MSHRValpwVldJaUdWMG1lbEV2N0xlcmcycTJ5dEJDQ0Erd3M3UHp4czRnSVFRMk56ZVp6K2RpYjI5UGVPK0Y5LzRvZGlvSDhoQkNYaFJGLzVGSDNuTC92ZmZjOHpOU0p1K3F5bVhIaDRCT0VvYWRya2pTQ0QyUEhuNnFKZEFJdXIwZTYrdnJLS21ZTDJZc0Zrc0VnanlOSEk2NnFRL2Y5Q1JKV0J1TmVQQ2grN250dGpPVVpjbitmcHhTU1JFelVhSVN2QTlVVlkzV09sUlZkZTNwcDUvNm5WLzd0Vi81MklzdnZmaFNXMG90UXdqVjZnT1RVdnArZitEUDNuNG4xNis4R3BxbWxxMWlpaGFDVkNxWm5MeXovOWE4cjdmcnlnV2RDR0c5YnlFYWtYVzlHdTJhNEhFdFdFK0lDQ0VQSVdBUVpLSlZXVmp0UU5ycHI5U1N6cWhnMmN0cDVpVnBuaEJraU1HR1FNbG9heHYxcVFMT2VIeTdXNG0wM1JCblpNWTkxZXpOUCs2c1c3YWxvd1RVMnNuK3NiUW5Ock9SUU9VckdOU1JvRGo2bzMzZDZEZkVmdDVXSG1oYTgwOXdSaDdLc2p2VGtxUldja0NScW9sS0U0U1NsNWE3eXllUFpHa3JoUEQrQncyQTlhY3RzZmIyOW9TVVVuanYxWkV0K0FvN2xRR2RONy81a1R2UG5qMzNvZVBIVC95RVZ1ck1iRFlUU211S1ZjYlEraEFidFFLbnBVbENwOXRsT0JpZ2xhSnVHclJVYkt6SERYbTMxNlhYN2NTeXF5aklzcFRCb0UrdjI2VnBHc3F5NHVBZ051dGFLWUtNZXdDRXdEa1RoRUJjdlhMbHljOSs3dmQvOWpjKy9yRXYxWFU5V3dWSCsyRlpCRlpKNlpWVTRmeWQ1L2tmdnZiVjhNRlV0c0lRc2FjS1BpU256dzlIWis4ZVBDUUpza2dWallmU0Jtclg4cmlGSklRSUhRa3VaamtsQVM4T2pmaFFnaVplWnF5TFVKR29OQmd4VGtraVNiSUVYeldrYVd5QVYwTUkwY3E5Qng5d2JYZmtYYUNwWFpUbENVRklSRVZ0UGwxUHF5dEhwbkFKSUlwQk9rb3lPa2t2TURyZFl6WXBxS3Z5NXBwdU5hdVQzK01DeUJaVzRzSFhIa05GY0Q0dUV0dlB0S2tiZk5QRW5Zd1NlQkg5RTNXdWpUUCtLM3ZQNzcvVWZqMHhxd1Y4K0FIVy9mblhEWkRWWkVwNDcvV0t3TFNpdklZUTB2dnV1Ly9zbTkvOHlGL3VGTjMzSmtseWp6RTJqVk1pSlhRU3MwVm94NDVwbWtiMHJaSjB1MTFPYkcrenNiSEJjRGc0blBNUCtrT1NSSk1rQ1ZtZWtiWXlvQVF3MW1Dc1pkNDI0c1pZdkhPVVpZbTFqcUlvcU1veStJQXd4cFJQUGZudHh6L3ptVS8vd3VjZis0TW5nRklJc1doM0c2c3BsUi9rcVYvcjV0VG9VSlVWLzltcGRRcWRNTE5HUUpEdDdrUGY4K2FOMjdkUDl4NlNTSUdTV0JkNUVKNkFRR0phY0o3d0VjVWFXbVcxUk1ZbXZqVUlwYmFPWUVNcktSVFZUUEJ0MEZnZllSdmlKZ0k1aElCU0l2TG1WeEtqSVRia3hnYWF4cS9VRFlOdy9rdG1XdjErOEtGcXMwY0FraVJYMmVoWWNUcnBrSW5jMHp2UlpUZ2VzcmMwdUptOVdXcUYxMldTdGt4Y3lacXVOTGVzOFNETW9YNnZEMUhrSXZaYUtrb3B5ZGpFaTBSZm43dzYvWXdwemJSOXp5M2d2UWlCdlAwcTM0QUJjclI5YXgxZnc2SEdiUWdoSDYydHJiLzU0VWQrNU94dDUvNjZVdnBSMDVpc2FacVFaUm5IdHJiRTJscGs5bVZaUnA1bmpOWkdIRDkrbkkyTmRSS2RrT2M1ZVo2MkFncVNscjkvcUh6aGZjQlp4N3hwc0szV2JRaXhyM0RlazZRcHprWHJBV01NaThXeVJmRUdqR2xlZk9xcGIzLzBWMy8xbzU5KzZlVVhyNng2alJCQ2ZWZ0RnNWRTaENMVm5PZ2xJWkdDYjczd0xFdmpaQWdjMGZZVmFaTEo5Tkgzbm54UFZ1aTE0QWdtQ09IYkViSWlMcmlkNUtaY3FKU1VWVlFnVkFTOGo2V1JzWTZtOWl1SzBFcW5ObXI5K29DckxLNHlhSzFRN2NRcUJIOUlRb0oya1I1YTlaTjIyVWdReUJDdVV6WWZxNmZsNWZiYXJSanNZbkNzS0dTdXpnV0ZTQXNSMG40cSt0dER5a1hKL05LVVVJV2JRZks5YnNBS3lOajJQc0pGdm9yd0VlamxXZ0tZVEdOd3RIcGpRZVdKczAxNGZQZTd1MCszZ1ZISG5paDRoSWpLMjIvQUFCRkgyamI1dW5LcUFJb1AvOWlIejk5My93Ti9aMk5qODhOWm1nMlZGS0pwR200N2U1czRmLzRPTnJlMnlOSXNscThCZ29pWHliVnFMNElJWFZpV05jR1hKTW1xWjZqaWsvY0kyREMwVDhzVlE4MjJCalJwbXVKdDNLSTc1NE5PRXJGY0xPcUxyNzd5NVU5OStuZC83dkhILy9CSlkrd2NPTnFJcjhhTFBrQndQckF6TGRtWmxuTGxrUjRJb3RXRlRvU2dDQ0ZrSjgvMnQwNmRIendjRUxwMlBpeU5iek5JcTE3bzRtV3ZyY1BZK1BWSzBmSkNYQXY5YnFKUVZSb0VuZ0JleEFhNzVVNkV4bEdPSzJ4dDZmYlRsc2V5TWdNVmgyK0pYUUVjbTdoZmFmc1lMMFA0dXBrc3Y5MStuMjBqVEJvQ1l1djJ3U2pwNmhQT2UxUW1TWHNKdldQOTZIYnJITXU5QmI0S2g1SkNOMmZSTjRNbWNEUERlQitEMUFVZlI5RUJsSTVpR0tGZEFBa3RSZExKOWc1ZUd2K3VyZXdVUVUySTVWV0FvR3hMejMyRGxWaEhBME8xeTc1czVjTDB3QU1QYlAybi81Zi85QVAzM0hQdjN4Z01CZzlsYWFyU05NTmExL0l2SW1iS0dJczE4ZDBPTGxDM2VLbVZhbnFhSkZoam9tNlNBR3RkNjdIZHNMb1pVcTdVd0gwNzVuVjQ1OG55REswVFFpQUlwVWl5VEl4R2EySjNkK2Znd29YbmZ2T1hmdWtYLzhXRkZ5NWNPYkxiV0RYaWJqVjdQL3E5aGhBa0F1bkM0Ylo4TmRiTmFQWFZUdDdlUHpjY1pTZWREMVF1SEhIWTgrZzJFR2FOcFRTZXVtbUR4NEpySWovQ05BSGJlS1NMQ0YxUDFQRDFKc3JqK01yUkxLTE1qNHlzTzFac1FWU3IwZG1PWEkwTlZFMjdHSFF4MnlwNHhjL0tqMVdMNXFETkhNMVJDR0ozTGR0S2NyVldPVWNEaUZ5VERqeGQwOGVVRFFEVnZNUXRIYUU1c2dGcXBYNVdVN09WTWtsWThVZnNheCtuUW9DSU80K1E5bk5NWmY5Zy9OTEJrMEJEb0ZwaHNBNDNnOU0zVm9DSUk0Rnh0TmZvQ0NIeUQzemdBMmYvOC8vYmYvNzNUNTgrOCtOVldROU5ZME5WTm1JMnZZSktOSG1lMDVpb1JOaGlzbHBrclVDcUZtM2FYazNySFZYZHRJMnN4RFFXWTF1RXJYZXh2SElPWjEyUVV1SUpGRVVIcFpTUVFpSmtpRFY1YlpoTnA5T0xGMS85eHJlZitOYnZmZVNYZitsejEyOWMzeE1SbWw2dXBpWkhBaU84N2lHZ1c1NlBGdEV5UXg5WkRLWWgwQVU2YjNySGlZZDBJdGNiNDRJQWtTY0tJVHpPeE9iYkVaK2tzcFgzTjRZSU0vRUJWMGZGa3VEaXJzRGJWc0hSdGsySkIxdFp6TFRHTFp2b050V3k3NlNLVFRuRVNaWHpzVTh4amNNWVI0amJtanFVelNlWHU0dm4ycXZkM0J6U3hwRlpVdWdUTXBWYnpkTGhQQUlsWWpuVVNjalh1blRMcUlEWTZJcG1hZkQxVFhqbVlaUzFYNjZRYllsM05OSHJGdGJlNHNKVW5ncWgxSXZqbHc0KzNzeWE2WkdTendvcFFqN01LUGNyZnBDUC9oTktxdGRZbElVUWlydnV2SFB0cDM3NmI3L256UTgvOHBONTNuM3J6czVlSWhBaFNSSmhyU1hOTThxeXBOL3ZSMktNaS9ld2FjR0I3VEtGSkUwSUFjclN0Q0lEbWpSTlc5VjBGN09FZFJBRXhqUklxVllaeERkTkU2UlV2c2h6djFnc3pXdzJtMXk5ZXZuVjU1OS8vc2tYbm4vKzZhOSs3WSsrOWZRelQxOEg2alk0cXRlVlZPRjdQQUJXT0xFRVNFSTBiVktETEVuWHV1bXdTT1RJUVZIVnJudjJkUDlSSVNtUWdsd0lNaWxaR245b08rRGJYVVZ3VWRwSFFTUkMxWTVtWnFNZ25JM2FXTFJaVVlTQUVncmx3UzBzOWJqQ0dVZVNxd2phWFYxS0FZSFlyRnNiRytSWVdvWGdQR3pteVY1WTF0K2VPYitxZGc1RjE5dnNxRVdlREsxSE5aWlFtWmlmRWkxd2hjWjBVdEp1am5jdXd1NmRKL2hXWGFVVnFsdnAvY3JYOVNJcjVkYlZJbFRxQkpWcXNuNXU3TkorZXZ6aXdYUHQ1M0FUMXlZSStTZ1BiNVFBRVVlcVRSWHJicEhGaFIvWlQvMnR2M1hYWC8ycmYrUHZGVVhuTHhsamhrM1RpT0ZvUktjb1JGTTN6QmR6dE5MMGVqMlVqa0xGZFYxRmNvK0lXbE9KVGtLU2FoS2RpS3AxV3pMR2t1ZXIySW5jYmVjY3dYdmJHTk0walYyVTVXVHgvSFBQWDdwNjdlcmwyV3kyR0k4UEpzWTA0K1Y4c1hOamQvZlN6bzNyNDFkZWZYbHNyUzNiajdJQjZoRENhdWxudjhkR1BINlBrSWViU3AzRm5jZjdhN2R2ZEkrZldldThhUzFQN3Rqb3BDYzdpYm90SkVwVnRRdko1OGNuYmx3b1JYcGJCeTlndVpGU0ZZcGFSNWZOMHNQU2VieVVLTkVLMmRwQXNDSktpRTRxbXRwVHJXaXRQZ2FTVmhMcEJNMjRwSnBFQlhhVnhDVmpNQTdTdU5keFBzU0E4K0ZRVTh0N1JDOVY0YWZmY201TEcvZXUvL1VUMzN4dWYxSytYbGxVcDRYT2kxRzJhVnRlZkdqN0I5ckdQd2dSbFZHa2JPZlM3U1BGSGtHaXladEx6eFU4WHJUb2U5L2VucmhabDJTRERrbVd2TEQveXQ3blhPTm1SK0E3VGtnUk9odkZvYWZJR3lXRHJGWkNXZ2lSaEJBU3FhVDZMLy9SUC9uaHQ3NzFiZi9YTE04ZkxjdEtEUVlEUnFOUk96MXlsRlVWZEpJUWdrY0tTVjNWS0tXRTFwbzB6YUkxY0phanRCS2hmYTVOeGhPbmxHcnFwbWwyYmxUTDhXUjhZSXk5YXEyWnpXYXpaamFkVFBZUERzYlhybDE5NWZubm43LzJ5c3N2N2MzbTh3a0U0NzEzTGQxMXRlVnlnQk5DbUJESlRPYkk1dGdsU1JLeUxBdnorWnpXOWxtdUFKUUI4dTErdXZtT083YnV1bU9qOCtiMUluMjRTSk43MTNycENTbGw2a01RQ0NuSzJxQzFwSmxZN0w2RjU2b29oTkJSdUVSZ3VncXpsVkpuQWpuSUtaS0V2ZUNwdGNSNjBmWUpVRmVPZXRsUUcwOVRXN3oxcEZwSERWem5zV1ZEOEI2VktaU1M3Vmc4RXFaY2lLUXI1NlBnbkcvaEs4NEgzbnhtSk83ZkhxU0pWai94VSsrLzc4SS8vWTF2Zkx6Ti9pdUIwaVFmcEwxOGxKNDNrZlRYb29ZanNhcHVJb2JLR29kcEdxcHhoZGx6cnkxS2orS3k1YzBNRWt2bCtPdHBvcEJhbzdLRXJKY3Q2djN5RTd2UDdINjN6UngxL0p6d090Y0JSSmk4TW4xREJZaG9OOFpLS1NYZSt0YTNyZjJsdi9SWC92Sjk5OTcvSDlkMWZZOFBsVnRmV3d1ZGJsZWthUnFVMHFJMkZaMmlFRUdzY05XUzREMUprdmk2cnB1ZG5aMkZsTkpiWStxcXJxY0grL3MzeHBQeDdyVnIxL2FhcHRtcjYrcmc2dFdyKzYrKytzcitVOTk1Y3RkYVczRlRmTndlYWFocFNmMHJnbis3Y3d1SHo3Z1FnbHY5ZW91akNrbVNoTUZnZ0ZZNkxCYUxvelRmRE9qK3d4OTk2RDF2T3J2MWs2R3U3cytrT05OVUpqTzFvWjQyUVVpeFduNEY2WW5CN1h3VUszQVJHa0lkRUtWSEhqUWtsMHB5SlhIZGtnWkJFSUhwUnNaY1NHYWFDRUVKTVVqTW9zYVdjVGpobFVLMTJ6ZnZQQ3FKWUV5dEZDSVZyU0NEd0xzVytlRTkxc1JYWXoxM0hSL3gvcnRPWUkwaFQvWFdXKzdlL21zLy9NQ3BiMzc1TzVjdkhIbm9aZGtnRzZsT2VyNjIwV3BadFAyTXFUMjJzUkVtWWh6VnBLVFphZUx6L3VocGFjUEJIZTNjV2xuVEVFR1hLbEVrV1JxS1VWY29yWjY5K3V6ZTU0SVBpNk85UjRpWXJEQThPMlIrZmY2R0NSRFI3aDdFZTkvN1B2bDMvKzdmZTllSkU2ZitpeVJKSHlXRVlhL2ZjMXBwbHlTSjg4NkZ1cTRoMUJocnF1bDB1bmRqWjJjNkhoOVVUZE0wOC9sc3p4ajd5dTdPenFVYk42N1BFY0kxVmQzTTVyUDU5UnZYeHhjdnZicHcxcG5YQllFLzBqejcxd1dDYjB1a28zL09BMEVJNFVNSWh6OXZmd3hyYTJ1aDNUeUhjK2ZPOHJXdmZtMGxHNzZheUtWM0hSdHRQSHp1ek45ZTczZCtZalpka09vRTI4enhiaEVFUVNnaHdUaXNpYjJTYnl3WTMvNlBhUjFqSW1BdytIWTJiQU15ZURLbEdOUU9mWDFLM2hqU1JERFBOVHZPc0ZoVUdPZnd3VWNKMHNiZzVjMUZnNUN4S1VmRzBhNXNsVUJXT2wzZXRwdHNGOFVZSGp5N3diM25Ubkt3djAvZEdBYmQ5SUVQUEhydVI3NzhuY3RYMmtzcHRCUlpYaVFESTFVbTNLcEhpc1NtcHJLWWhjRldjZUpvWitaUDNrbUVJNDhzMFg1NkNZZzB5aEhwUkpNUE9pTHJaY3Y1NWRuSEZ6dkxpMGQ2RDl1aWNNSnliOG53M0pBM3d0RkhFVGo5ZmorODczM3Z2M2ZRSC96VnZkM2RNSjFPUHorYlRwdXFydnhpc2JoeDdkcTFuZmxpWnB4MUFZU3I2MnA4L2NiMTY1UEplRnpYdFhIT3VlVnlhY3V5TkVjdS9tc3U5WkczMmY4SnIzQWtLQUlRcEpTSHNqRHRyNi8ySWVISWl4QVBKMDZjb0NnS25udnVPZnJDazJrcEt1dVBpcHhuN3p4LzZ2NUVKRzlhTGh3MjZDQ0RFa0ducUtLbE1MUWpWcDE2aExPNFVKTUkxMjZSQXo0NG10SmlYSVB4SVhwd2VQQ3FKdVFwVmlvcVkrT09aKzdZU0RQNlBqQ3VMQWNxTU5kUWE0bVRnU0JEcXpvU1lyQzB6MzIxZ3M2THVJU0xmVWM0SEFwMFJ5bTJjQmhyMmRqYzRNYlZhNFRNRnljM3UrOS8yMzBudnZyVlo2NWVBdnhkdy96ZUJ4TDFINWtYcDZQNVZnY3ZKSTBOTkF1RG54dnNyS0daVjlUTEVsZTZmejEyZUxoWmZxMjQ1bGszRDhWYXg3dmFQYmIzN043bmd2TlYyM3NZaExBNlU3N1lLTUxzeW95clg3LzZoZ21RdzIrNTMrL3poY2UrY1BFWGZ1RVgvdXNiTjY0RmExM2l2VlBlZTBVSWpqaTdQdm9XSGVHZHhjdmJRcGZkaW5nV1RVM0QwY3dRam1TR2xSYlNZUWI0WHBmZSsraEtvWlVtTDNLa2lJdzZBSzEwMk5uZGVZM0U1WGc4Wmo2Zk01bE1xS2I3QkNFUitOVmdLZEZLNW1jMlJ2ZG5XcDh3MFZsR0NLVklpeHlkcDdqR1VsVU56dmtJa1JHeHBkZEpEQTZsTlNFNGZGVWhyRU5ZUXpBV0s5dGF2bHBnaGFCcUdoWlZUWkZsMk1hZ2xHUzd5TmtPTUtscXhrdkxUSGdXaFVJbG9GT05UeVJlU1lTU3VIWkw3ME9JZFBaRHZua2d5UlREelp4R1FOblU1RmxDcDlkbFdTNDROc3JmOVA1SGJ2dlFreS9zL0dyVldEZk1lR2hRTm04SmoxOUtKanB3WTlSSG5CcEduL1I1alNtYktJNWRtMFA4MkwvMjhURS9TS0VvQmgxQkVDOGZ2TGovTDh2OWNxOE5qaG93QW56U1MrbWZIakM3UE9PTmN2U1JpeDZ1WExrU3JseTVzbnRrL0huVFlWZ0lLZUlKUnk2MmoxckU0ZkRDcjBxZVZibHo5TWZWYnJaVjZneENpS08vRjBzS0lVTGROSzhQd244dHRQSHFYTHAwNmVZM21HWlJoN2xGNUFMcDJmWCs2T1JhL3lHRWxNWTJMVXpGb3JVaVZTa0dnNnNhSEpBcVJlTWNRVWhXekx1dzB0Wk5VcVR3SkNvQmFkQUV0SXBOdGZXZXFqRk1sMVdzMHhFME51NTJiSURjdzhoQ2JqemRwVU1ua3JWK3p0ZzBUSzJCazMzOGV0Rml1K0xFYXJYLzhDN1FYOWZrSFJVUnc5TFQxRFZGcDZCY3pFUFQyUFRPazhQM1BYajcxamUrOXV6VnF5NzQyNjh2eTI1V0M4U3N3ajI3aDkvc29XNGJSV3MyNzNFcmFkTS94VlpiSklMT1dwZXNXelROdFBxOThZc0gzMm1ESS9ZZWJXbGxGaWJ3Qmp2NmRVbHpoZVgwUnlaQnpWRnMxR3NDaFBhU0V5ODhyNUVlNDJnSlJGc3FrYVpwS0lvQzA1aERvV2xyYlpqUFp4QUNkOTkxRjMvNHBTOGRjbENPWG56ckxQUDUvN0hHN3NWcnV6am5aU0NvZGpxbkg3bHQrL2IxSW4ra3JtM3dQbUNkRmE2dFcrcW1SQ1ZwSE1NcTFZNUJpU2pkVmdXeGFScUNDTGdRWWVoS0NsU2VIcnBVYWEzSnBTUlBIY051RnlFRnBySFUxakNyRzJaVnc5SjdsbVdGYmVIdWRlM1lXeGdtMHlXcE5haEpTZmloTTFncENTMGcwYlM3ajd5bjZBeVNLS2p0SEtWMWRMRW9yY215VERSMUZRWkZkdmJkYnpyNTdtKzljUDFUalErOWVkV0l5N1ZuVWdlVUQ4aHJVOEwxQlVvSU1pbElBSVNuc3EwdEF2K2FXandLMHEyRS9sWS9pTUJUQnk4Y2ZNcVdFZHB6T05aRmVGVkVDdldWUDdyOGhnMFFYdGNMdko0ZEVGYWtwdGM5OVkrYW43ekdDTVc1MStacnBSUmxXVktXY1VUeWxyZStsZk8zMzg1SFB2ckxoOXYwNXk5YytKNVo0VTl6N2p0OW5POWV2bzRVUW9TQWxJSlVTcUUyOHZUKzZjRnNzeEdDd2FBbk1BSnJEUFY4aVZhS1hwNlJTQlUzL1ZWRGxpU0lFQjFwaFlRd2l6RDFQRW53M3FHRndIbkhZbG5GMmI1d0pGS2dFNDBQbnJ6SU1MVkJWVkVlZGRTemRLY3BCTUhWMlpMZ0RJbHpDR2NSeHJKMDRLNHY2VnlidzZsaDNKcTNaanRDQ3ZvYkdTcVJPT2VaTEd1dUhjdzVmbXdkWnkxSmxsSXRsOEphbTk1emV1MkhidDhlUGJPL1ArNHNaR0JuR1Jjd3VSUW9BZ0lYbmFXaUpuWTBYR2svZk5zR1NYM2tTUm0rQi94ZHJVbjZ4L3RrbmV4Z2RubjZhK05YSmk4Zmdia1lCQzdMMDZEekpNejM1N3hSTTBqNEhrTzkxNzRYVWpJYXJaRmxHWjJpUTExWGgvUllwVlM0OE1JRlZ2akNQK2x5ZSs4NWNlSUVnLzRBNXh4WHIxNWxPcG13V0N3Ty84ejB6OUFiUWdqUVVnblhPbFA1RU5UV2NOQTVlMnpqZkZsV01oME1naEJTaEhaU2hCQ29KSWxTb2EycVlkU0lpMUFTTFRYV05pcy9iNVJTZUdkcHZLZXFHK3JHa0tiNkVFNGpSSWhLalVLU2RYSlVua1V3WmxuUnp5MW5Ob1pNNW5PTU53UnJJd0xaQnVZdStuV0lTUTFiRG1kV1FuQXVCa2NtQ1M2S3pwWHpobWRmM09IQnpSRmdJejVOUkVtZ1VTL2R2di9jeHQyZnZyd3ZWM2lhTEdLSGNCNmtVb1FRcUowN3JMVlhFOXljbTRZc3BxMlZYak55RkNCNmtHMWtJZXZtd2RidWlmMFhEcjdaL2pPSHlBV0JDR3ZERWNQaGdPL3VQLytHQ3hENXVoTHJmK2NWdnNlSm5nN09SYUNpYzY3OStSL2ZrbHBydVhyMUtzOCs5eXdYWHJqQXM4OStsMjk4OHh2L1ZyNnh2Lzh6ZjRkTGV4T2M5OEpIcnhFTnFJMXV2bkg3OXVZRFdhY3JzeVFWODBXSk1aYXFiRUFwWktJUGJkbTBTdEE2aVV1NldJcGhqY1czaGp0MVZlRnM3Ri9LcXFJb1VuU2lzTTRSUXN2ek1CWmIxM1JHSS9wclF6eUIyWExKd2xvbVZVVmRWU2doOENJNlBMbHdjeWZueTNZRTJ6aWEycEhta21LZ295QURFVTJaWm9yTCszTVd5eG9oSWtSRTZ3UmpiRWlreU84N1BibzNhRFd3Ujl4dEsrK3BnU1JKeVpXS2phWTR3cm9WTi9VYVZtOWNwMzFsUjNhRm1SRDBSQ0xTTE4yZnZqcjl2V3BhVjBjZ1M0Y2Nvb1B4aEpkZXVTZ2s4TGYveGw5OVE1ZFlmL0t3d252MjkvZmZNTjlZbWhmVUxnZ2Z0K2VIc0l0N1QyNmR5bld5M1hTNklraHdqU2ZST3FLT0E5aXFKc2dvc214TmpkU2F0RlhsQ041aG5TV0VRSnBuU0NGWnpwZWtpYUpmRk9TZGxNWTZyUE9vTEFGcjhjNlNGSDJjOTF5L2ZKM3h3UUcxYzNnQkI1TTVkV1B4U21Dc1kxV1JKakw2bU1mUmNjQllVSWxrZEx3NDdNdVVpbjdqYVpGUWlnWFRhY1Zna0dPY0kwa1Rwb3U1c002cDQrdkYyVUV2RTlPREtPWnRXMnlYSk5JS0JDRlNEY1BSbm1NbHRIRFRodTJvcjZHU0VSNHpFQVdEcWt0M1dxaW1LTzU0Zm9ObnJ1L3R6YmdKMzdHQXI2b0tKV1hZV0Y5YnNmVC8vQVhJRyszc1g3dkN4dHFJcTlkdmlIQWtnN3pwOUxFN3MyNnZrOWxBdFhLM0JSSWxjWlZoWVMweVVTUkZSbFUxRkZJaTB4U0JvSzRhWnBNNTFuczZSV1JFR3U5UWFHUVM5V2NUQVVybkVXeHBIVHJOS1BvOWRuZDJ1WEh0Umx3ZlNKaldOVmNQWmtCZ1dYc2tnYVpkUVRRclNvYU1qbERPTzRhYkNUcVJrUlBUNnMvSDFhY2s3YWVVVmRWYUpFaThremdQZGQySTJhTGFjdTNVYlZYM3JOQ1pQbmdNTjIyaE9WeDNoOWZVM3JJRnJpVWgwbWZ6VkpGbUdmM1JrTUZvU0U0MmtqMzFNeWNmdm4vN3lWY3Uvck5uWG5pNUVrTFlJeE5OQXRqUmFNUWJiWXoxNXpaQUZsY3ZzcGhOaFZpcElZSmFIL1I2Sjd2RmZjR0hIS21pYkUwckplU1B5SUZxcGVoMk8yaVZnTE00WjBuVGhNclp5RlZCWU9xS3lqcENvaEVLRkJHU0xxVWkwWkttckVrNkJZT05FY2JVek1iVENJeFNDbzludW14WWxJWkNSZjZxMG9LcUNaU3R5NndRWUtYRTJVQi9xT24wZEJTMmJvMW9iaUo4UVJVSnhrYklpRXBTa2pSQlNNbGlhZmp1cXdleVhEWi9US1JFY2ROTnVscVZkRWQ2RU05clBkWlhwWjhMVU5tQXdjQjBHUmVXQXlkVW9vb3Uvc1AzYm05MVZPQ2ZQdlhTSzg4Y0hmcUVFUHoxM1YzMzFIUFAzd3FRSDRUejBzdVhLS3VHQUJJaEZDSEloMDV2SFQ5NTh2ZzlPa3RsNmgzbE11ck5MbHBJdmlZZ0F1U2RnalJKeUxzOXFzV0N1cXl3eGxMWHpXc29kVkpHMlo2ODJ5SE5rbWlzR1NjVUlBU0RyWFdrZ1BuZU5BYWppdEI5QkV6bUZjSTdYRnV5TkM1dzRHT2dxVmFQTTZTYVh2Q00rZ2xXQ2xiVXV4WVhSR2dWN012S3NFeWlXRFJTUmUwc0NTOWVtdkNGSnk2RDlZY1hYN3dXV29VNE1xVlNSNkFWUndQcXNJZHNoeS9LT29TTkU3N0p3WVJPbnFHeWxEeFBrOEd3Lzk0NzFnZWpjNmZmK2MrKzhNMG5mbjg2bTBkWVVRaCtzVmo2cDU1KzVsYUo5WU53bnQrYm9MUnFkWFdDQkRneDZtNElIMFkrQkV3VnJTbWNzUVRqc0NMU1k5TWlReWhGWFZXa0FYU1c0S3hoT1oyeEtDdWNjK1N0YkpFbnhML3ZER2xla09WNUs0M2o2RzUyOFFnVys3dlV0Y0cyK0hKckxEVWhCbStJcUZ3cEJkY00wUTJxOWZPVGVVS3FKTnZ6a25vN3gvcWJ3SVVWR3pHVlVXYkkxQTVYT0V4alNiS0E5eEhQL3V5bE1mc0hTekwrT0JuRzhsckhnOVZtZVBWcituVzRvTlhmVDlyWGFrRVdRbUJXVnZpeVFra2hKbnNUbmFYNkxhUDFqV052MmpvMit2Smk4VXZXaHhvaERLOFJFSHJqVGJIK1hKMXdPT2lOanNhQXV2ZTJrOGVhcHU1VXkyZ3BvRVIwVjdMTzRZMGw2K1FrcVdhNVdGQ1dOVlZaWXVzR3FTVGUyVWlWVUJKakxaNllFVllaeGRxR1pybWtXU3pRU2xQMGVsVExKU3BKMFoyQ3RNaEpzaFNaS0NiTGlyS0syVWhyY0ZyU0JJR1drWDBhQUpWcDF2ZG1aTUVUa2xZMEdvRU1BUlY4cSswYk9mM1NleElWbGQyajV3bFVqZWZaaStORDR0WXFPNmdqQzY5VmNDUkhmbDBjQ1k0VmNEZndXdTFWZVhOSGlCUUNyVFM2Vlp4eHpqRmJsRnk5Zk9YTTNzV0w3OHlWTEZiSlM3emU4dlpXQnZuK25pT2ZSd0RrVnBiY0VZd2RWSTBMMWpuaGd3Zm5DTTZUcGdtcDBzekxKZVBwbkNSUHlKcUdmcTlBRURBK3lubXU1RzJjaDdKY1JqZW9QTUZaeUhzcG9UR29OT1g2eFZlWjdCMlFKd2xWYmRBaTh2eWE0TGt4WFZJM2ppS0JQRlBNZ3FBZ01JbUwrRWhXS1JzNnRxRzhZNGpYaXREWVZscElST25QMWdMQlZvWThDSXBVNGIybnJpTHYvOG1YOXJpNE16OE1oS1BHTEJ4WkJNb2o0OXlqQmk2cnY2ZU9sRnJaa1ordnlqTVpZY1lBRkVsRzhJN0dCM3p3empxL3N3aUgxWnQ0STk2aFA5Y0JjaVE0L0IzYld5cHQ2aTJYS0dtOEVMNFZmekNOSWRPYUlrdnh6ckpjUnRNajJZSUZoQTgwVlVYVGdoZWR0UWdwV1M0cnZQZmtlWWJTT2o1cEcwUFNLWERlc3B6UFVFclF0QXZFbFdpMmN4NVRHeklGZVNyUlNqSmZSQisvS2tBWDZBbm9Cb2ZxNU5RYm5XamlLU0pSWHJRMnkxcEhiRmhUV2RZQ2RJc2swbjZ0NDhhTkE3N3kzV3VVTmw3YzVzamxUM2t0aFB0b1k3N0tHdnBJdG5GSEFrdStibUcyU2ptSjFtUnBnU1N3S09kSUFnS21Ub3FuZ2czMnNHMjZGU0EvWUpGeEJFVzhLRXZ6cVc4Ky9mbjFMRnMvTmh6Y3Q3N1dXOHUwekJLZEVGUlVIVkE2NnVVcW1aS2xDU3FOeGoxYUt3U1JReEdFd0RpTEZwb3NTMGdTSFYxZHF6STY3Q1FKczJzM3dIbXlMS1dSQWJPc2FKb0dhd05WWlZvRnlBaHhyNTFuYmx2TnJCQVlDc2hsSEtuNnRRTFh5K09PaEdocmhRc0lyVkZLUktXVXBhSHJJR21KNGNGN2J1d3YyWjlXcjRGWnIvb0l3K3ZVS3RwQVdGbG5kWWdPUWJRY09IT2tGTFB0bncxSCtoZ3JKQ2xRTmN0WTZrVmNwcENDMlkwUVh1R1BVeDF1QmNnUFVJbDFpQ0srUHBuWHZ6NmQvNEZHWERpL05YcnJUOXkxOVI5WHM4bloyaXR5cVZnZkRKRkpBdDR6N0hVUkJEcDVocGFLMnZ2WWV4eTZ1WHAwUjlQdGRVaFRqZk1PcFhOMHA4Tms3NENtcXVua0dVVzNnNS9OMFZJUUVzM1NWT3pNRnN5cWhod3d3bE01Y0JZV0lhQURkQ1JvRlRWNjNZbCsvUEo5RzV3K0lMUWswVEx5UTV4SExDM25CaDJFZ01aWXNrVHg0clVKaTBWejJKd2Z6UTcrZXdSTWRhUVhNVUFUQWprcnZOYk52dU43TWNoalNSWHhhRWtMWFpFSWtGenpzTi9HUklRVytCQ0dFQ2EzQXVRSDQ3U2FBSWRaeElQd1VwWnZPOUZiNzRWcVkrNU11RHJlRjh2U29yaU9EWUlpVFZqdmQ5Z2E5VGkrdFU2dnlPT0hMd1NWaTdUWVRsSFE3VVJYcDJYZGtCYzVTVjR3M1o5UTF4VTZWY2hVMHpTUjFCMEVCQ2t4SVRCZVZQR3l0ZE9yZWVOcGZDUW9ubERRVmUySDBzOW8raG5CT0ZUcmJTaUVpQnYwZHRwVlY0NjhkcXh0eEEwK3dQVkZ3MWVmMzhFYkY1ZUIzNk4zV1BVZlhrYk95Y3FKYWtVY254T2xYWklqVTZ1VTF5cVIrdmJYVXFsSVpPeXZWaGxMQ3VIS0VGNWQrckMzV3FNZ0NEb0VOb0ZiQWZJRGNKU0tPbHF2TGJsdzl4M3JiZDR6MGo4eG5pNTYxcmhRU0luWGtpRGlzbkJTMWt5cU9aZkhlNFFYcjVBa0NadmRuRXlyS0dHZnBQUkVJSGNhS2hkZG80b2NVeTZweXlWQnR2cTV3VkdYOWFyVW8zR09SZFd3TEUzc0JWSkJrZ2dteTZqYmUxc09tVi90T1FUbWVBK1RLRVRqNHVKUXh1QklFb1VQVWZhbktnMW52R1RZU2FrYlM2b1YzN3l3dzhWcjB3aGZQOUtFcjA3UlRwNE1VU081Y1k2Rk1ZZEI0NDY4YWw3cm83T1MxOHphbnpjSUtnSjlCQ25oVU85TUNweFM0cUoxaDk2T2pvQVhTZ2IzQmxBeStRc1JJQStkUDhkenIxNmhyTjNxeVNheUxGZC85NGZ1KzNDL21kMHhYOVk0dXhTOU5HV1FaNkFWczdwbUtocHNLeGticE1IYWhpdVRKZGEzbkJndmNGNHk2T1YwT3ptWjFxejM5aU84WFFyeWJrWlA1VWp2WWlOdFk4bGhuV05hTmpTTm81TkVxWno1MGxON09KbkNRTFV3RHdPaG4xSWU2MFlPZXNzOUY2dXhidXNIVWxzUE95VjNydzF3UUZVNzVwWGxHeGQyRUcyZ2hTTVhlOVYzRkVrU0E5QWFrdGFRay9iaUJ5S0pZNlU4dW9LN2h5TTlTazJVcVd3OWNSQStVSG5QU0xiNnBvSGdDWTBUOGhWdUNnZDVJR2d0RVk1YkFmS0RjRWFqRWZMUzFmYUJMQlFoaUx1M0JxUHRQTGxmRmh2SmliUWZrdDVVSUFKTlhURmZMaWpybWw2aHlKS2N5cmhvbnhBOGpiVnhJZWM5amZFSTY3bThQNk84TVk5eWpFcmdwQ1RYa2xFdkk4OVNUZ3dMdGtZZFZCQW9EMDFqbVN3cmxQRHhxZXdEU3g5aDdZVzZTYWtWVWxLZTZ0TVVDYUd4c1o0WE4xWGRyZlVSK1R0dnVGTW1uTnJvc3F3TldncXU3Q3pZbjFTSE05VVZKWFIxSnhNUkE2enlFWERabUlZbWhNTkdmR1h5Y25RWFVuTElwYVpleVErdFpGUGJmM2NLekgyZ1VDcXM1Y2tyb1RGZkhCdjNuUmIvYUVWVW12R1oxcnhVTjdjQzVBZmhwTlVpcWdSR2txd0M1RWl4VnM2bW00M3hMSm9ndHRaR2pMWTJxVjNEWXJGZ2NIMlh2ZjE5bEdoOU8wSmcwUmlNZGZnUWZRYmpsQ3V3UVd5dXZZK1BhUnNjeGpyMng0Ykd3NnZYWkN5SHBHU1FLRUtBL1dWTjVrRlo2T1NTSk1Dd0xRUHRxb1lmcE5ULy8vYmVMTmpTOUNyUGZOYjMvY09lenBSelZtWFdsRktwSnRXZ0VRbHJRQlN0bG0zQWdEdWdqZDFob3NNZEFVUVFCQkcrc2kvY2dkdDM3YjRnMmgxdGR3ZHlnMFE0RUxJeE5rWXlRb0FrYkZrRG1tcWVzbkxPazJmYzB6OTh3K3FMNzk4blR4VzRveTFWWWFseXI0aGRlU3J6WkdWRzdmL2RhM3JYK3g0WjROdmtHaXRaVWpiSkZyWnRtcFRVQjlzMUQ1NDRTdU1EM2tlS1hzNkwxOGJwa092UXJsb09OK3FxMU40ZGpKUGFoVXNYTjQ4NEZxUGN0Z05NZi9HZ0pLLzFsQklFbkVMTUM0SUlUZkRNdmFkV2xUWXZuQ25MejB4Mzk3Y09WV3NSMER6RzVSVHJ1eVdlZStvNVl1Z3FpMDZRZWlpNldzK2JnWXZLYkZJVG1wcjVaTXBvZGNqRzBTTWNXVHRDTloxeTQ4WW0rOU1KODdvaHhvajBlM2pWNU1zbjBJU0Fhd0tOYTJuZHpYMkFONmxYa0V3SVVXaGFoNCt3UDAxTk9jQmVUR3pkUVlDaEtwTEJiakNNTWtGTVpISnlTRzJGekNzbVM3cFkxZ2doUnJ3bXdNUzlob2VISTlaSEpUdnpDaU5RdFo3dC9lWmc4clJvcEIydlBPckpEcFZjaHpkNGgva2ZpeC90b1JySnhYZ2dDWk5MNG93TnJhWElTeFRZcVdiTVhjdWdhZTR1QnIyM2JHWDJTODZIQTYyQ3hTQmdDWkR2a3JqZ0lpYkxoQkFPMkJhclJUWnFHbGNnUWxIa0tFcDBEZlVjV3UrWXoydjZaUS8xTUNxR0RNb0J4OWFGcUo3ZDZSeVZkSjg2blRmTXFSSHZHUFR6enRFcTBFaWs4VXFSR1d4dUdQWU5NVVNhT25aTVgySFNLRlVEemtjeUkreDVLREpETHhQMlYzS21HNzBrTFc5VHRzcU1wQVZsMS8zT2R5dnVHQXR2ZmRNR005Y2tzMDZiU3AvU3BnY1l2Zm5BTDBBUUQwMnlEdmNrbGxlS0VaaERlNDl3cUk4SmgzNE8waTFLM1RTRUVNanpjckZNVk5PMmR1WmNIbUwwdkZMS1NhOVg5UklnM3pValhsN05iWkRzN05yZ0xLcWprQnhnazdlM1JxSkdpSkhKWkVZMW5sRzdnR1NXb3BlQk1mVExndFBIK29tM0ZWdjI5MmRzZWNoSlhLN2FlMXJ2RUJQSkZZYWp0SmRvbkdNK3Jja0V5cjRsb3JSZU1YYnhzQW1Wd3ZIY0VncllPemJBR3RQSnlORHA4U2F4dWl5M3pDcEhiOXZ4Nk8wbmlFVG1qY1BIaUJqTGFwa3hHaFpVU0ZMZmZoVUk3Q3NlOEZkdXhUbTA0N0FIRGJzYy9OUHpTazVXVUtVMFNjZlhSMFdEVDhvdklFRzFWV0V2S3FIakgzOVBMZ2h2aFQzSWdod24zZVRVR3ZSWUNGck9YU0Fhb2QvTGFkcUlMWVdWNFlEOXJiMERxMldiV3pRcTg3cW1hUjI5TWtlck5HcnRsVDJPSGNsUzM2Qks0eDNqNll6R09mSWlveWh6R3U5eGJVdVJHVXFiNk9kVm15UkQrcGxnTlMzbytrWEdXbUhZV2JIRVVaa1dndDNqRkh5eVU3Q1paVFp1MEtzVlAzRG5iUnhmNjdFN25kTzRwRWRhNUpiTnZUbFBYdHJEcWI2Q1dySzQrMWljeVI1bThSNWUvdVd2QUUzblMzTG92eEY1cGFBaVVTbEZLWXloOVo0bUJqVWdYdGx1b2w3c1ZqMkwvb05NMG9Ya0VpRGZSZEVKUnh6c3Q1eEs0MVZqak5IVUxrcmpBcmsxMk1KUlRXWVlJd1NmbUxKNW5sRjFFeGVSNUFibEc4ZXNjUlNqTXVsa29Za1JIQTBicTZ0RVlHVTBCQUpiK3hQVUJUVFBxWDN5UVdsYnhhaFFacExPYTBWWnpTME1NclpIQnRQVitVWU5TT3pVMGczei9acHNzK1dEWjA5eTV0aUF2Vm5GckVtU3FFV1dnUHpGWnpiWm1qU3Z5QWlMcGVCaHdKaERaVk54Q0NUKzBMNGtIQUpIOGFxTUV3OUFweEFEMlVJM3JCT0xkM0NoVWw0NmhDa1YwQk1aY3NVdHFTYmZWZmc0TEU4RWtHY2l2ZzBTT3hIL0dBTjFDRENaRTlvV1kwemFQUWlKTmk0a3pwTkdySnJrZmVHVEgySGpIYW93bmMybzIwQnZwVWZaS3hDZ2tJd3lXckxla0VZajFkNFlvcUFtdzVKR3JOaGsrbG1LY3FOVTJ0d3dpTWxuT1VDUytBbVI4WldLNFZoNS9JR3ozSDU4eU02NG9uS3B0REpHNkpjWkY2N3VjdUhLUGozOTh5VjZEbE5MT0FTWXc4WW9oeHZ6UlVaNU5hSHg4RU9UeHNpSmJ1ODBMaXlmdlFwLzZwVGR6bWJOQTlISTkyNlpkU3Rra05qVkN5R0kzUmRqbXRENkxBbENKL3E0RDVHcWRoMmRQRTJpVExUSjlTb0VvdEhrd3dlWVhwWXloOEo4WGpNZXoxQnI4TFVoaWlFemp1bThZbWM4eHVUcFZsMVJuSS9zVjRFVlNTTFVXWjY4Q1QyUlhYVkVaMmhKNVJRaHd0ekRUc3NaMitkZDk1MW1ZN1hreHY2TXhpWGFlMVJsYlZCaUpiQzVOU1Z2QXh2Y3RKWlNJeWw3eEp0N0R2aXo1TVdhUCt1MWx4MEN6dUhMUTN1NHhDTFJZM3dNZE1mbkFyd2M0WTlhWmNwTjg0Um9nZVo3dEF0NXd3SmtZUng2YzBpajd2SzR1WEpYRnVjK2hrRWJvZ1FmRUpPMHZVS0UyamtLYThtTXdXWVIzMFkwQkdKdWFKMG56NUp2QjVvZVFLY3g3VCtjb3g5eStubk9aRFpQcmxwZDZlUGJnRWhpM3RadFpMVVVva2xtT0M0S1YyS2dxU05yV2Nhd0tJa1REL3VlbzdiazNKblRuRDZ4aXNsZ1p6ckhHaUV2TEM1RTFvY2xSaUpYTmlmczcxYVVVWW1kTGRvcTZZeDNzUW1mNk0xNlp5SCtxWWQ2aXNVT1pHRS9hdzR0R2c5YmNmVVBaUnREVWx4cHU5d2hNQlA0MTJQbFc5eTAxL1pkTDZKK0NaRHZybmowNUJwUGJVOWprNWJBWHBYMjJxeTZldnQ2TWEwYWY5eUZRSlpadkk4RVd2cjlIc1lhZkVnOUNOMjIyR1NHUUNTcVNTZXVtaktBRHdIVENlZEpqQXlMZ3ZsMHhyUnhaSVZOQnFWMWl6WGdXMGZicG5iWVdpSFBCQjhVaCtGOWo3NkZqZlVCcy9HYytiaWhDUTBiSnd0T0hCMVNscFpBb0tvQzFocUt3cUJBdjVmRXM2OXVUNWhNYTR4Nk5vWUc3OUpHWGpweHE4SWFwSTJJaTJRR2NpdW9NVFFSNnFpMG1uU0MyMjVIOFdyL2lmclFodzJramZtQjRRaVFvZk1JVnhYNnVmQ2xDbjdMS3hNT1c2MkJ0bnB6NGJnRXlIZEpyUGNzbmUzR1lsL205MHg1SlMrTFo4cXF1VHRxeEJxVG5KeFEydFpoTXBNK1YyMnF4SHRsamc4T3ZCS00wb1pJSm9iZ1BDNm16SkJuV2RvbCtNQzhhWEdhUE5zUmNHMDZzbXA5b0k3U2ZXSXJtYlhVTGpBUHl2VEtIdFcxTVQ0azd0YkdhbzkrTDhQRmdLczlJU2k5TXBWMUN6WnZWVGVNcHhYenhuTjVjMDVmTEwxUndYeWVURGl6M05MNGlJdENKZ0dUd2JBdzVCMlJNdS8xY0ZHcFhhQ0o0RlNvbXBZbVJwb1FiOXAySGRxSjZLRm1udTdIUVdZMmpaai9jK3I4eTFhNTV1QmFoNnVhVHRGOWtUajJ3L2ZtYzJUZnFBQzU4K1FSdHFhMU5ENklkbWNObTN0aloyTGNMSVFpeHJpZWlRd3hJdHI1S0lLa01hMjFaRm1TS0ttYU5sSEpjOU5KQTZVczRud2srQVNTekJnaWtXbGI0MExFSWpqbjB1OXRIYWl3MnlSSDIxRXVhZlB0SWhPVFlVUnB2YU1OanRDUkpHTUhCdWNUVlQ0dkxHVXZ3MXBsZnpwbmJ6cEhGWjY0UEthWmUrNWVINUZuR1VVbURQc2xlV2FKVWRtZHVhUWtud3VqMGxMMnk2VGRsV1VFMXhLZFk5VEwyUmowV0NreTFubzllbG5Ha2VHUWZwYVRpZEN6RnVsT2FnODd2QnJBR0RNZDlZclBUbHIvUklSZEVvOXg0VVVmcmFBckZtMzBlL2M1ZXNNQzVOeXhkUzd2enhaM0VnY21wUzlQNnQxbjkrcy92Zi9zU2J2Ums3Zk42c1oyMmc1WVl4QWxQZVNaVUxXZUVCWEpUV2RTbWJ3NmdsZEM2enZBSkpjcDZhNFNRNGlFR1BDSkI1WjhCVldaMUVxdTBMZlNqWWVGbFZHSktYSlVBNkd6WFV3TmVBUWo1SG5HeXFpa0tBd3V0T3hONWt5ckJsVjQ0ZnFVcHkrUHVlL29DcmV2OUlpYTlMeDZaWTQxaGlJekRITkxQNGRCWVNtTG5NektnUzUvMUFSdzUwSnlKOUNBYUxvaFdTbHlWakxMUnIvSEhVZVBzdGJyMDh0elZzb0NEUjRibFJLd3h1U2xOVTlQbmY5YUI0NkYzVm93RUVjV0hRaE00L2Z1Yy9TR0xiRVVtTHQ0ZUdqalNPUlVXNnZlbURYTlV6UHJybFMrUGlQQldDT1dHSE9pU1NURG5aMHgySXhzVUZCa0Z1OUNzbUMyZ01aTzJVUVJqUlRXWWpORGtlVWdsdFk1Z25Oa0pvUFNVcnVJaXpXRERCcXZTQkJXQjRhc1g3Qm5ETkdsY2crUnptclprT1dHc21md29XWGVwUEpOT2tmY0t6dHp2bmxobjdrR25yV09ZVy9Bc2F6SEtvTDZRQnNpMDZwQ1E2QmY5QklUMktRcnhObThRakQwaXp4dCsxdVBjdzdYUkRESjZXVTJxY2h6SWNzc21jQ0p0U01jWDFsaGQ3eFA0UncxRFVhaGliR01yVnZCU0V2VUF5SDRoUTExbHB3ZHZxZmpEWnRCem0rUEtiS00wc3BDZitwZzBpbGd6dS9QcjEyYit5K2VHSmJyL2R6Y2lSRzdONWxwQUd5ZUVWWEZXRU92TEJCcjhERjVjNFNvaEJoeElkSTJMbGs1RzBOZEpSRUhIeU5WM1NZQXhWU0tqZXZJWmgwWlN0ci81VFp0djR1ajZ3UmowdDE3bmllRnhrSW9Td3NTbU5jTjQzbUQ2OHhEWFVoVStZdmJGZGVqNS9oYmpyTCtsaFBVdDY4d3YyMUVIQlZrM2FkN29SQmRRQ0prV1ViWks3RWkzWFJQeWEzRkdBTXhaUkpkS0V0Mmw0NUMrcnNEOVBvbHJXdTVjdTA2M25rMGF1ZkF5OVZHOVRkbWtlZTQ2U2JsUzlBK3FEV3c1WmNBK2E0Tll3eG5WdE50aDFlVlE3d2c5VkhqWGh2MllsWThkYVRmYXlBYmlKZ05KZHJHdDlqQ3lzTFVOVWFWdW5iRWtNYSs4N3FoYlYzS0t0M3V3cGlrNVZHN2xycHVhTnJrUWx0WGdkMHFVbldLSlpta0djQm9yVTl4ZElYR083eDYydGppUWtOUVQrc2N0Zk9wYk1vdDJua1VHb1FiTzNNdXg4RFJ0NTNtdHZ0UHNYWnl4R0N0aDEzdjBaN29NNzk5aERzeG9EMCtvTWd0dGdsRUY4aVMwMXlTUWxKRlE2STZGM21XMk1LK08rdTFZTE4wMWd2Q2FEaWlMUE1rdWwwblprRUE5UkNEOExrOStFUklBNjU2c2ZzSWdxNEFPL0Y3L3hsNlF3TWt4TWphb0VpbW15U3ZhSDNscmt5MzUrM2toWEh6RFJmMG13RnpmdXJqZFNOMnd4aFRJa2pUTnFacUcyMjgxN3AxVE9ldFZGV0xDNkVqRk41c2NUUXFUZDJpSXJRdTRqelVEbTZrMnl0V0phV3Z3c0pEYnp2SDI5NTFIK3RyUTRvOFdScllic3k4T0VpcWcyZmVlcXFtWlRLcnViWTU1Znptbk41OVJ6bjdqck9NanZUb2ozSjZ3NXhlTDhPV2xqak1pVWY2MUtlR3VMTnJoRHZXOEJzbDBRQ3pGait0aWNHbmJCY0NXWkV4R1BTVFpVTlViSmF5aDdGUUZEbkRRUi92VzNiM0ovalFzYlFFYVdCckR2OTBCczkwNEtnQTF5dHRQSEYwd09iTXZTR2VvVGU4TGxZWkl5L05XKzVaSCtqbXJHSHVRenkwWEk2QWIzeHdUK3pPdmdvODBiTm1kS3lYblN1Tm5ENCtLTjZ4V3RqN2g3bmM1VncxOENHVTgzbHEzRjFJc3AvV0dvMnhZZFN6a29uZ25NZFl3U3U0b0RUZDNmWlFZRXRoWGFBb2MvcHJJMFlyQTBaVncrMzJHS2RPSFdGbmI4TDE3VEUzOXFiTTZwYW9NT29YaEJpUzBWOFI2YThweCs1WVozQzBwTXdOZzl5Q3lNRk10U0J4eDNJVjRvb1FWbGJnN0Fyek9oQXY3eEZlM2tldVQrRENIdFlMVGRYZ0drOXVCWG9XNXdKcU9tRUk3OWphMnFIeTBIckZDdW1rTnBtVGZIa2ErU1kzVlVnRFFzeEdCY00zYjhEMTJSSWczd3Z4OU82Y002dEQzbmV5NUxOWG85cEc0clFOMmxudkh1YnpGUWhOSFdKMWFkYnVBdm41YWZ2WnZqVWJ4MHI3eUVqMHpSTDh2Vlk0SlNLblk5U05URlRhTm9vUFVMZUIwQ2tqTG9aRlFhSFMxQk0wM1kxR0R6aHo1amkzbnozSzNzNGViVjNUVkEyWk5hd1BlL1NMbkxNbk5oQnJEaHlucnUyT0VSSG1UY3ZtZk03d1pKLytJQ00zUXBuYlpCUGR5UVl0Q013aXN0QlZKd3JZZ2REZWZRUjMyeXB1N2dpWHg4aWtSYStPYWJibW1MMkt2QTZZM0NBeG9pcTRPdEw0Wk5OV21MU2Rqd3A1UC9lelRMNFk5dHNwZXRQdlhrUndUVkJaSzk4d3o4K3RvS3pJcGZHTWZ6NmVjZmRhanlPOVhOZkxqS3V6TnJvUUQzWmlDZzZsNXViUlhCWlY4NmtQMDZrUGwwaDZibXNGckEzRTNGc0tkK2RDVCtGMFZEMWp3V1NGSGE3ZVBycWpYNW84TkpGNnYwR2JRSyt3VEwxaWZDUWI1Tno1amp1NDc4SGIwU2JRK2tEVkpOdnB0ZzFNcXhyVFRiTW1zNFpaN1JnTUNseU1qQ2NWOXRpQTdQU0lMRXU5UXA0bGhaTGtNNWdPbVRyM0VMS3NzNDRPaVR1VzVzNEd6UzN4ekJxK0RzanBWWmkxdUJ0ejJxMHA4KzBaTXA1VEFDRlhUQjNwaVlMelJLZEVSWHAzcit1Z3RIUDU2dlVXY0tvYUVLSXhFb2RySmMvKzJ4ZVdBUGxlakpmMkUzbmk4YnVPNkxqMXVoK2pXSkVRMHdsRzUweW9UdFB6ZE9CSzFZR21qakN1NFVxdDhkbE9OcW9RR0ZoWUEzcWpZWDc4MGI5MTM4K2R2R1BsNGZuTTBldzFNcDA2YkdscG1zaDg3Q2l5aktkTzloaFBybkdNSE50RWprckdZR2pKQnNMUnRSV01OY3ptTFVWaFdIRUZVV0JTTzBhRGttazlTWDlpYnNpdHdXVEpLeVRUNUxZcmlhaWNIQmhVaUpKdTJMMVB5cEcyVkRJZjBPUmxnQmlRd3RJT0Mrb3dvQXFlMWdRS2ErajNTd3BNOGt0MEVkdEc4dHd3ZXVoNG5EMi8wNnFxRXlRZ3ljazIrRy9UUjNvSmtPK2UrTEY3ajNOajdnZ1JjbXQwdmN3NDBzdmo5Vm5MYnUwV1IzY0xxejZqcnp6S2UvWExLT3g3dUFIMDkvZWFLNWVmM2Z2b2tUdFhmbjUwY25CdTlYUlB5NGpNR3NYdnRLemVab2x0Wk45Rjl1b3B2b2w0RHoxcnNKMnR3UkJEVUpqTkd6YThZUlNnRE1xcVdNWlZUVjBLZ3lJZFlCa3JxQWpXcEhuTHdxbzdONEpxVWpBeEpNY29NY2xHcjdDQ3p3eWFSU1NYSkhrYTAwZEQxR1FSbll0Sms3bk1FRTIzRHpsZUl0Wm8wY3VJeGx5cngrMmxqZzd0UlNRdVRGdDNMay9mVU0rTHZkVUE4dlQybkF2am1xYmJLVXphd0UrODVTUTNLc2RXNVJSajFGaUxHQk1WaWNiWWFLMEpJaEpVMVhYTE1DY2lyWWkwWGYrUzZuQWxYUG5XemhXYjIydWpFLzJIVVZaTlZOMjhQTmZKalFhYlpSSkNjcXcxeVM0RWE0VmFoQjBYY0VhWUV0bHBQVk1YdU9JREw5WTFMODVxWGhqUGVPTFNKdG14Z2xOdjJTRFBvSmRaK29WQlRIb2JFeVZkc0owOHo4S0UyeC9vWDJtbmdLakVvSVNnZUJkUnI2aUwrTG5EelZza1JvdzFHR3V4SkRVVHNXbVJtUmVXK2JqNXl1VW50bjdiemQwVXFBVDV6enBGTHdIeVBSd0xKdDFYcm8zWnJycXhwRTNNaytnOVJsV2pSbzB4YXBabDBSZ1RZN0x2RGNZWUx5S0xEZjFCb3dybzllZjNydytPRHVxVkUvMjNWQk0zdVBqMTdhdTlFNk9ZRjFrL2RzcUNZcURWNUc0YmZLU2RPMnh1c1VhSWJTUjIvbXJkV0pYdHZUblQvU2wzdmUwRXgrOFlVVmdZRkFiVFVlbU5BVVFYUmh6NHFJU09TT0E3QXFXaEU0QUlpdmN4YVd4NVJYMEVIL0MxdzgwZDZnTTJNOWpNa0pVRnRzakFDR0tOaURWeHZOLzg5dVl6MjEvV3FIT2dGaEhYNy9mQ20rNDd4OWJtOWh0cmw4WXlYaG5lRTkzTjllL0M5djJSUng3UmZyOGZSU1NjTzNjdXZQV3RidzNIang5M1pWa3V6aTRxRWhkcEV0cXc5NVhmZlBhVEwzNTkremVlK1B6MVA0cVJyeFdEZkVCTUZtK0xrc1lZU1Y3czNTTHZvSzZ6Z3JGQ2tSdXl6QkliQitPWjMxanBiWjQ4TTZ6S1Fsa3JoWDZ1R0t1VWhhSE1EZFlLTmhPeVRKQnU2aFEwYmZlbG8vQUxpZjhoY0tEWWVKT3BKbWlNZU9mUzN6SGM5TDFWUUt5Z1JtWnUycjRVWFdnaGxWY2lFbzhmUDhGUC9lUlBzc3dndDFDODRteFZsYXFxY002eHU3dkx6Lzdzei9Md3d3OXo4ZUpGQmJScG1sZWNWQVFYNCthemU4KzErL1hYVHoxMC9EMWk3SDNxTmZYT1NDZnluQjdTYXR3UzIwamVzK0FqY1ZHcytFaTFNMk4yZVcrdnZqcjdneE1uKzA4Kyt2anBCd2E1WktQQ1lpUXBpd1M1NlkxWUdJUHYrb0VZbGJicm16VXFJWFRmRnlFR2lDRjVUY2MyRXR0QVBXMXA1NG56VlpZNUdwVzh5RERXb01hUTkzUEVtaGUzTDQ3LzlYUnpkaFdvUktRV2tiQzJ2cWJWck9hRkYxNTRRejBEMlJJRy8vL2k2dFdyQjEvLzBpLzlFbC85NmxlNWVQRWl2L0FMdjhCWHZ2SVZmdS8zZmk5dWJXMzVWSUVsYkxXVFZxdE0vTTdGNlpmTFBYY3U3MmQzWjRNOE41bGdpd3c3eURTem9MVUhheVZHSVZaZTIza3JibHd4MzVsWHM2MzVNL1YyL2RucVd2WDFVeDg0OVlHakt5WVRGUzJOU08zVE5WalJYWVI1NzhtekhDdUNHc2d5d1lTYjJycHRqQlNhUnNqR3B1bFhqSnJ1a2J0MGFhekJKQzRhTnJlSU5lbGx1aXZLMmorMzgvTGVWUTZkaktpcVhyNTBXYytjUGZPR2U5K1hBUGsyNGgvLzQzOTg4UFhmK0J0L2cwY2ZmVlMvOHBXdnlNN09UdnJjdnlteHFkVmVFMS82M01YZlhEazErc2J3V1AvOS9mWHljYU42ZDNBdWx3SWpSb2lTaC9MWXl0WFoxdVJJdXpjZitGazdic2JOTit0eCt5ZlZkdk5WUC9XVG9tZFh6ajI4ZnVjZ0YyTTBOZUtSbEFWRWhFd01NYVQrU1RYbEtJMnBKNGtCMHU5Snk4Zk9hUGRtWXkvcHYyY1cvVmVNK0lOanNnN3R4cWhSNm5iZVB0T00yd2xwTVJpNkNaWjY3L25DNTc2d0JNZ3lYaGwvOSsvK1hmN2hQL3lIUFBIRUUvcTJ0NzJOcDU5K1dxdXFRbFZiT3JFSU4yNzh6cmlaN0R6SDAydG4xejVkOU13NTM5WVBSL3o5M29VOEd3NTJlcGVtditObnMvdGQwTnUxNVhQTlh2dTFkdUwydS9lb3YzYTh0M2JIM2FNN2MyT01LRmhSQ3B0S3RTb0VFRXVSbTBTbkY0Z29Lb0FJMFNnYUVsWEVHS0VOU3RzR1FuY2hxWGtHcFZKTE4yN3UvQTlGSkUyOFlpVExNakdHY2JWVm5lZW1JRU13eG1nNk5udGp4aElncjBIOC9iLy85N0hXOHVpamorcnU3aTdqOFRqdTd1NXlxTnlLM1JqWTdWL1lud0xQU0NhZk1ibU1WS1BseHN6dnQ5TTZMOHdmUnlHRUppNGswRE1SK3FydzZBZE8zYkcyVmg1ZFhQVUZCV3VFRXFFeGlvYUlHaUczSFlYZHBQMklTRVFNcWRUcTlMMFdqRTNUN1ZDaUNHMW54cG5uR1NwQzZHeXhOVVJzYnNtc0lNS2tucmtiaDZaMlVVUml2OS9YcXFyZWtPL3Rjb3IxR2tVSWdjdVhML05Mdi9STFBQNzQ0NmhxTk1aNFk0d1RrWnAwaWpydFhoUDF1aGVxZURuV1hJeXRYaFZoeDdWeEp6UnhyL3VlT1ZDcjR2S2V6UjU3NzhsSEJyMWlKUWJVbXJTYk1FQm1oQ0l6U1pCQmt3KzdvQ1R4RlUxS0tCM05YUklHVUYyQUk1VlJJU3JSSlhFZmtTVHVZeVg5bWhoRGxsczFpUnQyYWJ3NXZRWTNGNFNEd1VCLzlFZC85QTM3dmk0QjhockdwejcxS1VJNnRWVlYxZnZ2djErSHcyRVFFUzhpalloVUlqSVRrWW1JN0l2SWVQRlNaVXk2cTVoMEkrTjJrWDN1ZnN2UlkyZnVPbkovWm5PYkd5TWdaRWgzdkpVbzZGVkl2aDNxQWdURlNPb3RjdWxHeVdsVm5vN0h1dXdoQ25YajhUNTBsN2lLOHg0ZjB3R1ZzWWE4ekRBaVlxMzR0dll2VFc5VSszU09VVUFzaWtLbjAra2I5ajFkbGxpdmNmemlMLzdpd2RmdmZ2ZTd0YW9xblV3bVl0SUYwbUx5YzNqN2NPQThvS3FMbjE4NE1ac3pKMDRPZi9wdnZ1dng5ZFgrbTZMR3RDTWg3Vk9zZEFjcG9SUEpVeWdHT1JyQXgxU0NoYzRaRjFWOFFnWkdrdHlQRDVvdUpUdEQwT0NTMTZZZzZjNmV0SFEwMWlDWm1jMzI2aWM1NU5TbXFuRThIbFBYOVJJZ3kvZ3ZqKzN0YmFxcTR1elpzM3J4NGtXR3d5RnJhMnR4T0J3U1FsSkVpVEdpcWx5L2ZwMnFxZzVNWlVVa0Z6SDV6L3owNDQ4OTl1akdUMHlLN1dFYmsrRm56M1MzNnlLSUdESURQUXZ6N21HUENCRkJOZUtpNGtMcU80d1JZdUJBMjh1RnBDVzV5Q2E2NEJvZStFVExnU0NGR0tuM3Iwd3ZId0o1VkZXYXB0RU8vRXVBTE9PL0xINzd0My83NEdzUllUYWJNWnZOL2d4ZjZXZCs1bWY0M2QvOVhla0EwaW5yYU8rZWUrNGNmZUFENy9sUVByeHljaWR1cWhnaytNUVF0Q0xrUm1nanVLaFlWVW9SMm81aHVWQ1dEQkZzcHpuY1J1M0d2TjNWMDhMTDhCQ3RoYzR3MUpBeWtHVGR6a1RZbSsvVnV3dUFkT1BkQ1BEcFQzOTYyWU1zNHp1TEJkdjF6NHZOemMzRWxVck5RaVlpcFNyNXU5OXgvejN2Zk5mYnZ1L1V5cHRFS3NSSFQybFNhWlVaU3k3Mm9QRVdFbUR5anFqWWRtZkdxb0xUSkQyRXBwRXRzYnY5N1VBVVE4UzVsRnJTWDBFUDlIZ1JVYXlKcnZZWFFodkdRRVFJeHBqWWlZTy9vV01Ka08rQytPeG5QOHYyOXJaUjFZVU1idG52OTNvZmVmeTlieCt1REU3ZGMrWXh2WGZ0blRTTmcwVkoxTFV2b3BhZXNRenpuTkptRk1aaWpTV3FIbWh5K1pqRXJyc25uc09YK1lzdkYxWTMwbTNUTTV2VTdLMDFtaFZXNS92TmhXYm1KcVFWeXh1U3Vic0V5SGRaZk9BREh3Qlk5QjZpcWwzMjBPenhENzc3bnNjLzlIMC9Za0lvTW12a3dkdS9uNGVHYjBOaTk0VHFUVFp5YVUyaWx5aUlkc3UrbUN5WEpTalNPZWd1NWdMZUo0RTZZMHlTVFkxSlNFNUR5akRTMGR2Rkd0U0lpQkZYVGRyenZnM3U4UFo4WTJOakNaQmx2TDV4NzczM0lpSVNZMXlvZWhaQStkZis4dnNmRzYwT3o2cEdDSjZWc3M5Nzd2aHZlV2psbmVBTVFWTVJGR0tTTVFYQlI2aDlvR3FUcW1OSXY1VWM2VUNUSExFT3pIQmlJaXRTZWRRRnZQZkV6a3RSVERyR01rWkVZeHkzOC9aU2x6T0NpRVJycmI3OTdXOWZBbVFacnk4NDV2TzVxT29DSExtcTV2ZTkrYTdqNzM3dlc3Ky9iMlZnRnA1UTBkSExlN3pqN0lkNTk0bS9UTDhaRVVJZ3FoQXgrRUJTY0F6YUthb2tzVGxqT3M1V1ZLS1BFTkx5VURUWi8ycU1xRWFJSUpxVTdWV1ZMTE1ZSTJveVVlL0N0TnB2dGxJcmxUUlNiNFgrWXpuRitxOGM2K3Zyc3J1N2UxZ1R1Z1RLLy9GLytOR0hianR4NUVHeitBQ0xybHQvUTJGTDdqditHS2NHWjNobSswOTVidklVSVRaVXFoVFdFZ0pZMGpoWUZBcEpza09wZHpFb2tSZ0RNY1NiWHVxWlFXTUVsUVU5Sm1rTmQ0MU9ETHJWenYyTWhhVno5ejN6K1h6WnBDL2o5WW5UcDAvejY3Lys2OVIxdlRCdnlvRGlMVysrYS8wRDczL3NoOVpYK2lkWk9DbXJUeWVJSm9mb01OcHlaSGlVZDUzOUlYN3c3Ri9uWkRoTmZXTkcyN2xQNVViSUpFMjMwbVZpbHpHa2EvQ2pwbDhNTVczWFhVeFhoYXBrV1liTmJOZkRxMWhyeUtKY0QzVlkrSDNFUlFiNSt0ZS92aXl4bHZIYXg4Lys3TThDQitOZG82cFdSSHBBOFpNLzhaSDczbnozSGU4aUlpcFo0cXBqSUN0U3FSV1NuUUxCWXpWdzIvcWRmT0N1RDNObSt3N2FKNmNVVlVSRjhOMm52REdkUDNyVXBFRFI5U0NtV3d6R21KcnowSGIwa3F6ell1eXVIY1VLWjlmWFQ5eDU3TWhoSzBOVlZVNmNPTEVzc1pieHVwUldpNUhTb3J6S1ZiVVlEUWY5Ung2NTl4MXJHK3ZIOFY1Rk80bXJyQTlpMEhhS2FBVEpPbDBmQTY3aTlNWlJmdktILzN1ZWZlSnJ2SGp4Vy9oVnVONXJlY2J2NG1MaVZva2hYUTc2UVBSSkdBN1NaajFaTnNRRDRXcHJra0tjQ0pxSjRWUmVibHpwRlpiT3NmWjczZnQ4Q1pEdjhyaHk1UXBGVVFBWVZWMU1yb3Azdit2UjI3Ny9YWTk4aU9BeU1UbVlMb09vZ3E4T3lGc0xVd0VOYlVjUFVVWmx4bU9QdnAyN3o1emxtVzk4bmRQdGpFZU9uT1ZxblBQODdqVXVqUGZZOG5WM1FaakVzSk9sUTFvVUpoS2pwdEd1UU96UWVXODJrbnV5L3ZRL2VkOXlhRzBDOE9LTEx5NEJzb3pYTm80Y09jSW5QL2xKcXFvNkdPMTJ1NC9pSi83NlgzM3Z4dkZqZDlHT08wdFpteHIwNENINnBNb2VBeG9EeG1SbzhGMlpsT2duaW1FNFd1SCtSeDdsMG9VTHZQak1DeHd0TFErZmZZajVVY2V6VzllNU50M253djRlZTBYTHZMVnNWek5FTERiUGtTeWpLSEo2V2NaYWtYR3VOK0xSd1NwMUNPTnhWWHQ0aFpVaDczakhPL2p5bDcrOEJNZ3lYcHY0dVovN09UNys4WTh6bjgrbDZ6MHlFU2xVTlh2b0xYZmQ5cUh2Zit3am1jMUt4R2k2V25MZ0QxdHBCbUpJRXkzRkpDT2Z0a1lrV1M4RTUxRk5Va0MzM1g0RzFQRGNjeS95amErL3hLa1RHenk0Y3BUN2kzVzJ6UWFUcHFZWmVXNzBwL2cxaHp0YTAxWU56anNLZ2JYY01ySkdySGRjdWpGNTlxV3JlOVZoY0NRcnVqZCtsYlZzMHY4Q295eEwzdi8rOTRza2hlazAybFV0Z09Ldi81WDNQSEx5MlBvOUpxcUlLUVN4b0JFTkRnMSs0Yk9BU0RxRjFlanhyaVdHMEVuMU5MaTJJZmlXMWpWVTh6bHJHMnU4OVpFSE9YWGJHUzVmM2VXUC84T1RQUHZDWlh6aldjOTdITWw3M0Y0T09FcEJQZy9rTThlb1ZVWVJKRVFhNzRuQXJIYTc0MW5USHA1Z3JhK3Y4L2YrM3Q5YmxsakxlTzNpNnRXclhMOStmWkVPTEpBckZNZVByYTIvODYxM3ZEZjZkazJOU1ZkOUhibFFiQy9aK0VRUEpIQUU3L0J0aTNjT01SYm5QSzVKRHVjeGVyeFh2SFA0RUFodDRNVEpEVlpXKzl5NHRzWHpMMXpndWVldnNiRTJZRFFzSVVhbXM0cXFUb2FqL2NJUU5WMFpGbUl4eHRRdTZwaU80bTZNVVJIUitYeXVQL1pqUDdZRXlESmVtL2piZi90djg5R1BmcFR1ZGlJMTUwS0pVdjdDLy9Tajk5MStZdlRZNWZNdnljcXhFMlJwdnBTYWNURnBEMEphYkVSWEo0ZGFEY1FZME9BSlBtbjd4Tmg1bDdoQU5aOG5ycFlLcnFtSnZtVnRmY2k1YzJlNE51aHgrZklXbDY3c1lrVXBEZVRTcVROQ3AvRXJSQldxWU1ZelozYTV1UU9KSXFLVHlZUkxseTR0UzZ4bHZIWngrKzIzaTZxYUdHTUc1Q2psNmVQcm8zZSsrNEVmdlBQZU84NXN2dnlNTnZOWm1sYkZ6bFU5TktuTTZzYTZxa0lNQVZIQm1PNStQTXVSanNIcjJwYTZxbWliaHJhcWFKcUtHRHh0MjFCVkZkNjFiS3dQT1hmM0tlNDRlNHBlcjA4SWlSWmZsQVdTV2FMSmNHcG9vNldOWmpLcDIzME9qWGdYdmNmWnMyZVhBRm5HYXhNWExseVEvZjM5Zzk1RFJFcWcvUENIM243SGczZWVlTWZhK3JwZEhRZ1hudm9HYW16YWRaZzg3VDI2VjF5TWQ1T0I1b0hBQXBwRUk3eHJhZHVXdG0wSTN1Tzl3N1VOUHZnMHhnMGVjL1BBbDZLd0RJZDlJb2E2Q1RnUFVTMUdMR1ZSTU9vWDVFYnJ5YnlhazhqREVWVVZFYXk5TlVRNWx3RDVDNHJQZi83enpPZnpnOTRENkJWRjN2dkxIMzdQKzA2ZlhIOFR3ZkRtUng2U2IzM3hQM0wxeWlYSVRIcDdiSWxrSlppQzJOYkVtSmk2TVhoVVU0TWVRa2hmQThGN2drKy9GcnZsbjNjdHdUbWM4emVQcHJyeXk3ZStVM3puWnQ4amloQXhvc3dhdC8vODVaMXhWMXBGRWRFalI0N294ei8rOFNWQWx2R2R4dy8vOEE4RDRMMlhSZS9SN1QzeXYvbmZmZWlCOS8rbFIvNktVYkZJem1qakdFZU85UGlUVC84K1RUMU5mYkVkZ3VTb3IxSVdDU0haSFJpYmdCQWp4dGh1dXBXc0VEUkdOQ28rZEZuRU9WemI0bHVIOTRGRXhBMW9kTjMxZWhLcHRrWVcrbGNzNUJkYjcyOWMzWjdNdTd3VGpURjY3Tmd4dmZmZWU1Y0FXY1ozRmxldVhHRTRISExiYmJlSnFrcU0wWksyNXIzUmNERDRxUi8vMEE4ZVBiSnlOK1NJV0xJWWVlenRiMkg3MG5uKzlFKytTTFNLU25wNHhWZ2tLeFlWRmRFSFF2RGRXanZSUm96WTVNM3VRcnFvVmNVNVJ3aWhvNU1FbXJxaGJWcXFxcVZ0UFRHRU5FNG1IVTFsbWRBckxJTitybGxtWXV2RHVHcjlncWlvZ09aNWZrdHMwWmNBZVoyanFpcmUrOTczdnFyM29GRFY3Q2QvL0ljZWVQalJlOTl2ZlpPSnpaT0dhSEFjMlZqalBlOTVNMy93Yno3TnQ3Nzhwd2dPRFltd0tOYW1SajBxTVFhc3piRlpqaTU2RTBrcUpNWVl2UE40NTNITzBkUXR6aVdmOXhCakFrWlU2c1l4bVZhMHp1TjhvR2s5ODdxbGRTa3pCUTJ1YXQxMjIvcjIwQlJMTnpjM2x6M0lNcjd6bU0vbmZPbExYNkpwbXB0N0Q2VWNEbnFEdi9WVEgzNy9rWlhoblpLTU54S2x4TTFBRFE4KzlHYnV2bXVOZi9IL2ZKSWIxMjhnZVprbVdwM3dkSkx3eWNqeUhsbGVZbXhHQ0pHbXJxbXJLZ2tDKzlDZHp4cEFpRkdUUUZ4TTRuQXhScHE2SmNhUVRIZEltcjQrUkJvWGFGMFFqWGluY2FxcUJ6UVRWZVgrKys4L3VCdFpBbVFaMzNZOC9QRERmT3hqSHlQR3VCQlJMNERpYi83VWYzUHZQZWZPdkQ4M051K0lHeEJhb2tzUHJHckdEMzd3VVc0L0JyL3ppWC9EZURaTm0zU1ZCSXlzSUM5S3hONzBKUVJEY0NreldKT1I1VGsyc3dTZlRtbWQ4NTBRWE9jVjRzS0JLMjZNRVdzTjFpU3BIMnM2QjkzQ3V2MVpVbkpmQU1RWW81Y3ZYOVpiNVQxY0F1UjFqS0lvVUZWUlZhT3FtU3BGbVpuZUQzMzRQWC9wK1BIVmN6RjBhbFNoVFNSRWxPaGJndmNNaGl2ODFZKzhuZDByTC9BN3YvRXZxZW9LaytYWXJDQXIrNWlzUk1TbWpibHppZkRyQThGSGZKYzl2QXNnY3ZEdmduUzZ2S2JMUmhIblUzOGlRSllsR2FITUp2LzFQTGVFdUJDcDdsU0VWTFhYNi9IalAvN2pTNEFzNDl1UFgvM1ZYMlZsWldYQnUxcU1kdk8vOUgwUG5YemczSm52SzhRVTNaRUdoQnBpSUlaQWNDM2UxWUJsZFcyZEgzai9XL2phbDc3RUgvMytGOUNGN0tFS3h1YUl6VEUyVDlraktvakZCMGRkVjdnMmpYVTFLcGsxWkZraVRhaHE2akZRMnRaMW9scXB2TXB0RXF6T3MyU2xNRy84N3FXdHljSTU2SUNvNkp5N1pkN0hKVUJleCt4Umx1VWlnMWdSeWF3MStZY2ZmOWQ5NSs0NC9ZQUdUMXBPZCtXVlQrVlY3SUNTdUltVzA2ZVA4S0gzdlpuZi85Um4rUEovK21xUzR1MjI3REZFdEx1Y2JkdTJFODQyblVPdHdYdFAwN1RFcUlRWTAvUXJScXdScXFvbGhKanF2c3gyd0RDVUN5UFJxTFErenJmRzFaaWJGZzRxSXRvSmROOFNzZVJpdlU3eDBrc3ZFVUlRRVZtYzFCWWJheXZGQXcrKzZiMVp2emVJVmF1aG1VZ3VGbUtEeGpTdDBzNEZOM2IzSDlZV1BQeld1OWpkbS9JYkgvMEVQV3Q1NE9FSENDSGRoa1JOeE1RRWxxUjFsVTdPVTRNZU5TUzkzdENKVW92Qis0QjNQbzJLWXlDektVRTRIN0UyT2VIR3FCaWJ0ZE9xYlE1bEQxM29DUzh6eURLK1k0RE01M05FeEFoa3FwcWZQcjYyY3ZiMDBic1FFV09FME13NnhVTkw5RDRkUUhXV3pZbU42OUo0MXhTODQ3RTNjZHVKakgveVR6N0dFMTk3c3BPRVQ5djJHQ0ZHUWRVY2JNbURUd0p3UnRMUEZVV2VCS3VkVDJOZDUzR3RQN2o3RFNFNTRZYWdWSzJuRFVxSXNkM2VtN2l1TWxNUndYdFAyN1pMZ0N6ak80dFBmT0lUTXB2TkpNWm94RWltL1lnbXdRQUFFL2RKUkVGVXF2TFdCKzQ0ZTlmWkkyZWtiY1FrVlFTbSs5dEVreEZqSUxpYXRwa1JYSTBZa0E0QVlPa05CenorQTI5bFl5WHlQLzh2L3dkLzhQdGZRTHRQZXNVUVZZbEV4QWlaelJDeEI1NkRlWmFsNyt1WXZzRWx6U3k2MFc2aWwwaDNUNnVFb0drcmp4SVRBVXhGNUNCN2lNZ1NJTXY0OW1NMEdyRy92OCtpdk9vYWRIUGl4TVlwMisrdGFlZURWZzdYQ0w1aFB0a2w2dzNBbU82aE5wMnVxR0t0b1NoN1pGbVAxZFZWZnV5dnZKMTNQM0tTLyt1ZmZaemYrSTNmWVRhYms1Y2wxdWFBUlNRNTFCcHJzRGJER0V2VW00ZFdhQ3FoNmpyUlR0S1dmcUdaeFFJMGFrU1l6T2JOcEdvZHNKZ2xLOEQ1OCtlWFBjZ3l2c05QSG1NSUlRaGdZMVFyUXUvN3YrK1JlN0pzVUthaGxtS3lrdFhqdHpQZHZrWlRRMjkwOU9BcU1IcVBjM05DVkV6M0xoa3hySzJ2OFVNZmZKRFZsUUdmK3RSbmVmNzVsL25nQjcrUGU5OThCLzErbnhBQ3huaVFDQ0xZVHN6YUJZOFBFUjhpTVNpK2t5ZTF4aVpwb003Z1V4V0t6TEk3bWVMdzBjZWtwS2l2dWtkZlpwQmxmRnZ4OHovLzg0c3ZSVldOQ0JZd2Q5OTVhdjN0NzNqb25ZWFlJa2xWSmZaSjFsdG5lT1FVZFZNeDZ4YUNOaXVSeFE1UnRUdXQ5Y2xCcWhoUWxFTWVlL2h1L3RxSDM4cnUxaFgrOTMveWEvenFSei9KazA4K1Q5YU5hbE9qMzRrNXFIUjlTbW9tNnNyaGZEZ1FrclBHSkMrUkVDbnluRm5qR005bXJuTGhmT3VDT3pUbXZlVmltVUZlNC9EZXM3S3l3bXcyNi9oWGtvR2FILzNJZSs5Y1hkODRJeGhCRDdrSFNFYmVXMlh0OURtbTI1ZHBXb2MxRnU5OVJ5R3AweFdpR2t4ZUpMdm5za2ZSUnM2ZU9jNkhmNkRrOHRVOXZ2bjBKZjdaUjUvbGdmdnU1dHhkdDNISG1aTmt4bUtNeGRvTVNCSS8za1ZhbDRRZmNtc3hKbzE1UTR6TTZvYnQ4UmpuV3M2ZVhQSFhhNzlKY3JPOUpiUEhFaUN2VS8reHZyNHVtNXViQzFrZkM5aUg3Ny9uenJ3bzFoZGFjR21sYlJNUHk1UmtaY25hcVpKcS93WnVQc2FXQTdKeVNHQ1hwcHAzM0tya2I5NDBqaEFpeHVhc3JxMnhzcjdCbSsrOW01MjlLZHM3Kzh5bXUzempXenYwZWdPS0xFK2F1eUV3bTFUczc4L1luMVJJOExnbUVEUVFvbWM4bjlMNmh2VmhqL1ZSU2ErWEsyMVkrQkhHV3hVa1M0Qzh4dkhnZ3cveVc3LzFXd3YycmxWVnV6cnFEKzY1NTh6ZC9Ud2ZvQ2dhNWFZWllNYytCRVF5Qmh1M0UxYU80NnNKb1o2eGtwZmt4WlRRTnBpc1NFMTUwNkpxR0hvSW5TVm9OWnN5SEJhY09EcGtaM3ZNOWMxZDluZHVzTE0vby9YS2ZONXc1ZG91ZTN0ejFJZTA3OUJFZGUvbGh0Vmh4dTNIMWxnZGxBektqRjZaKzgzZG5XMGdDRVJFMUJqRHVYUG5lUGJaWjVjQVdjYTNGNWN2WDJZK255OGNheTFnN3pwN2NtWDk1TkUzNVptMTJsYWRHTFZOZCtleXNIcGFWUG9SbXhYWTBUb2hMd24xbEZJRFdwYmtSWStpTEduYWhtcnVvSGFJOTlSVnpYdytvNXJQYVJ1SHNiQ3hQaUMzUXIrMHRLM254bmFrV2lsUjc2Z3FqMmhnclZld01pZ29Nc3VvbHpQc0ZlU1pvVi9tVXVRMjdreWJkTFVsUkdOTWpESHFBdzg4c0FUSU1yNzkrT1ZmL3VVRk9CWWpYblBuMmRPanZCeXM2VUtobmZ3UUtQVGcxUFhnNjg1NDBBcEkwVXNqcHFqcDRLbHRtVS9uTkkxbk5xOEl6bEhYRGZQWm5MWnBpREhpV2svYmVvd3g5TXVjR0NMRFhzbjZhRUIwQWF1QlhtNHBpeXlSRWpPaHlHMmlucGljb3JRWWErcnh2TjJuY3c0aDJSNW8welRMSG1RWjMzNjBiYnM0SmpvUXAzN3ptKy9hV0IyTlZwQU1rYTRtMHE0SWk3N0xLS1RkaC9vRDlmWkZNeThpWU1CWEZmVjhrcjVOQTAxZDRWMmdtbGZNcDlPT1JDaTByZXVrZ0JZM0lPbnZGbnc2b2pKaWt2T3RSbFFOZzZKSWhFWXJGSm5WWVM5bmY5WmUyQjdYbTZRZHlLSlI1OS85dTMrM0JNZ3l2clBvWkRrWERicDU3Tkg3MzNUcTZOSGJVUU8ybjZSRE5TQ3h1MlR0ekRYVHNZYnBRSk1NYlE0MGVVTWdCaytXRmFqNkpONmdFZThkVFYwbjRZYW9pYkRZdWQ2RzdqWmRPNkNFcE5pT0VTR3poaUpQcFZXL3lEQld5RE5MbGhuS0l0UHptNU52bnIrK2Y4T0l4SmhjcGVLdE9NVmE3a0ZlWjZ3QWt1Vmx6MlpGamtpblBoSlEwVlM1YUx5cDRIN284Vk9OQk4vaVhVUHdEVzFUSVVZb3loNGlhU3AxYzdrZEtjc01hK3lCSzRMTnVvMjhTT0prV1VOWlpQVEtnclZSbjlHZ3gvcW96K3F3cEN4eWVrVk9ubVVZWTZSdVEzVjVlL0tOdWcxZXdVbEtlL0cyMjI2NzVkN0FaUVo1ZmNFQllDVFBpcWFabVoyWG5pS1RHaDhDM2puNmd4SEc1aFJsajd3L3d1UTlEQkZ0SzRnZTM5Wm9CR1BUM2JreEdhaERFTEtzSUxPV3Vyc2c5S3BrZVZvTU91Y3hJbmdmeVhPTGlOQTJIbDNwVTFwRDlBRmlaRlJhK3IzMDY4Wkl5aDY1WmRhNDg4OWQyWHMycHRMS0wrUitqaDA3eHVYTGw1Y0FXY1pyRzlYMWwrTHpYOWpYWm5wTlR0OStKR2xYaGNEK3ZqS3ZXakFaZVo2dUJLMHQ4RDZRNXptajBZZzh6OG1MRXB0bEJKOGFkVVhKOGdKck0vSThwekVPeVFMOXNvL1VMZDRIc3N3U1FwWUd5ZEdUNTRaQkw4ZUswRlFOL1V6b1pkS0owS1VzazJlaXczN21ucjY2OTdrbkwrNWVCMXozQ3NZWWZkT2IzblJMMks0dEFmSVhHenE5L3B3Tzczc0xkOTUvanJMZng3ZE51dFB3SGxWd3ZxV2VWYmgyU3JWZk1aM1h6T1lPc1gxQ01LeHRySEwwMkhIVzFvK1JGME9pV2x5bzZRMkh0QzVnYmN0Z1lERldjSzBqenl3Mnl6cWRyRVJPN1BkeWNtdlJXRU53RkFaY1NEZUt2ZElpb21UV2lBdng4aE9YZGo4L3FkeXNBNGNIb25OT1AvR0pUOXhTVE40bFFGNHZSS1F4NzBHRFlBeCs5Y2hHTEFjclZvTURFVFFvMFFmYU5qS3ZIYlVIWndVL0toZ04rcXkwTGVPZE1XMzA3TjNZNStyRkN4UzlJVVU1WkxTNndlcmFDdFlXNUZsQmx1Y1lNWVRnc1ZsR1Z1aEJReDU5SlBoSXJ5eHc0cEZCVHFPT3liUkJGUWE5akR3VEpFMjI0dlZ4OVpVdlBIUHQrUTRjclloNEVZbmFTWTR1ZTVCbHZDWVk0ZWFaYXR3ZU45ZThGTHMyczhlaVFGMVZiTjNZNDhaOHdzeTIxSDBJbzR6V2trUVdLbysxa2NHUmpLTU1XUE5LTzZ1cDZ4cm5haTYvdk1rTGpaQVZpUUp2QklvOHc1b01STWp5bkhaYUk2SVlLNWlzNDF3Vmx0Q0M4Mm1MbjJXZFVTZENrUmtFZHArN3R2OG4wOHJ0QVczM0NubWU2OXJhR3B1Ym0wdUFMT00xaXlpUzdwaWV2akMrdU4vcTVyRXNQNFpZTG03ZTRMeHVVWjJJU045UTJCNnFCaHNGRnlKdEdXbHM0SW8wUEZWTldZK1dZMFhHa2F6SHNiTFBjRkN6czFzeHEyZGN2ckJENDRYQllNamF5b2pNSnRtZW9zeUp3WlBuR2JhNWVldnV2WkpsbHJLSUIwSU54b0F4NkxUMXovL2hFMWUrdnNnZVFCQVJ2ZTIyMi9TOTczMHZIL3ZZeDVZQVdjWjNGaXNySzlSMXJkNzdxRW9Bd3BlK2VmSEdmTzR1aWNnRCsxdDdYSmh2TTc4ekVOV1F4NHhBc2xDekdHSjN0NUZPWUlVMlY2NWF6L1hnc1ZYTnluek9zY2F5WGxwV2pTVkRtRldPemEwdGJteHUwKy8zV1ZrWk11Z1ZTWG5SZ3BpVzRCWHZrdjVWa1djWVRUc1Nhd1FSMGN5YTV2bnJlNS9iM0s5dWlPQlZFMEJVTlpabGVjdHQwQmV4M0lPOHh2R0x2L2lMbkQ1OWVuR2k2b0h3NG9XdHZjM04vV2NhSDkzMi9wN3U5aXJtSVduak5oSDJKeTExRlFrS1RRek12R1BxUFBPUWRLMHNCcS9LT1BNOG04MzVYREhtTTR4NU9sUk1MWXhHUGM2Y1dHVjlsT0hhT2VjdlhPYUpaeTV3Yld1ZldaVTIrMFZSa0JkSlRDNWRHeVlsRXpHaTFnanoxbDM0OGt0Ym53dFJteTU3ZUdOTVVGVjkrdW1udVJYN2oyVUdlUjFpZDNlWHdXQkExMzhFRVh5SVdqLzcwdVlMYjN1NEdsK3RkbzY2bzRIS1JYSXJaQ0pvQ0hoUm91YjRXS1d4cXhVMnQrZHNESHZFa09nbXg0ZERmSmd4TTU0YnVlZHliREZST2U0c1ovT0NVOE1lL1Y1T1dXVHM3TTY1Y1BrYVdaYXpNaHF5T2lncGlvemcwcEJBakVIUzhsNnNSUzlzemYvVDgxZkhsd0NuU2lzaXdSaWpKMDZjNFByMTYvem1iLzdtTW9NczR6dVA3ZTF0enA4L3IxMUVOSTFLUC92Rlo1NTU0Ym56TCs4VVk2Sk50S3U1ZHlqUVh4bEFiZ2d4a3RtTVhsNVFWVjNmb0VuVHlzZklwRTNmbjF0RGFaS2JiVVhrYVdxK3dKU25CcDR3eUZsZjZYSDZ4QXAzMzdiT3FHZTVjV09iNTErK3hzdlhkM0dCZEVHNDBJVlBwN2JUeS92ei96aXAycmxBUTdjOTM5alkwQTkvK01PM2hKdnRmeTdzOHBGK2JlTmIzL29XL1g0Zjc3MHNXTDFBL3VLRkc3NC9VdGUvdjNqWUZReGRVSFZSUlZYb1ozMkNScHJnT29FRjRmS05NU3FSTENzSVBoSWlWQzUwUEs3a0graUQwcnBJamhBVnJ2aVdMUTJjSEEwNDFpc284b3dpTitTZGlOelc3b1N0M1JuVHFpVXpsakl6T2lpTlRKMzc2aDg5ZGZVVFYzZm0yOEI4VVdJTmgwTjkzL3ZlcDEvNHdoZHUyZmR6bVVGZWgwaCtIRUdOTVpHMGFHdWJ4dGYvOTcvODhoKzlkR252aTJKRVhWUjhGTVp0eGR4VkZMWThFRkR3SWJBM3JyRFc0cngyb0FHellBRURwUlZzbG9wa05ZSVZRVDFjYkd2K1lMYkhYaTlqZGRUaitMRVJHeXNsRzZNZXB6YUdqSHFHNnp1Ny9JZHZ2c0R1ZENaNWJxWXYzWmo4KzIrYzM3NjZBRWJIdmRLdHJhMWJTa1Z4bVVIK2dxSW9DbFpXVnZESlppQmxFY0UyODhEUk02UHluZ2VQdmk5QzdsVndRYWxjUXo4dkdHUjlyRlUydDhZODg4SU5OazcwaWRGZzVDYVIwWFNOUXdoS3lDS05WNklUYkJUYXlpR1paZHc2cnJjTmQ0eUc5SHhFUXpoUWNUY2lxZkZVejNUZVVCVDVrMTk4Y2ZQWFg3dzJ2dFpsajlvWTQxWldWdUtwVTZmNDNkLzkzVnY2dlZ4bWtOY2hack1aZitmdi9CMU9uRGlSdk03QW9UUkE4L3pYdHI2MWZXMytkRzRGMGFnaHd0d0hMbzYzdVRHZmtObVNpeGYzbVV3YnN0d20zNDZEcTF4QlNRb2xMaXF6SnVCVmlWN3hQb25HcVlJRzVmeGt4dWZHdTh5dHhTdU1Wa3FHdll5NmF2SE9jL3JJa0xLWFY5KzZ0UE1IbjMvcTJzdGQ5ampZblAvSWovd0kvK0FmL0lOYi9yMWNBdVIxaW5lKzg1MnNyNjhqSWdkbEZ0QTg5OVd0UytlZjIvL2oxc2ZtWUhBcXdxVDFYSnJzc0QzWjQvejVYVDEyWWtpV0d4cGltbW9oV0FFMGVRaEdvUFpLYm9VUU5jbGc1d1pRb2tCaERTOU5KbnhwUG1hd1BzSjdaVEt1Y0hWREpxcTlJdVBZMnZDWkp5N3QvbEVJY1U3WG5LdHFLSXBDejU0OXF3ODk5TkFTSU10SCtmV0pwbW00ZXZXcXhoalZHQk1XQUhHMW4vL3h2M3J4VXp0WDVsOHVyRWhwd0VneXJ1bVg4TXpsSzgyTEwyenZIRG5XaTRxUXg2UVNKTWJRZXZBeFlra0k4U0ZTWm9iQ21PNG90bE5pdElLUjlMM2YzTnJtQm9ISmZzMzIxZ1FyU3IvTVpEQW85NSs1TnY3MUp5L3RQaTgzYVNWZVJQVDA2ZE04Kyt5enQ1VE53UklnZjhIeDB6LzkwM3o5NjEvbkl4LzVpSklzbEVQM0tkMjg4TVhyNTUvOTJ0YnZ6ZXV3MTZyU0JpVVR4ZWFxRjg1UGR2TENidlVHR2RPOVFKZ3JFaUtaTWZnQUdoT3hNQ2k0TmlLaVNVK1hCS0pNaE1KYUNpUDRjY09ORjdkNDh0a3JYTi9jUjVLVXFRNzZ1ZCtmdTg5OC9wbXJuNCtxdFVMVmxWZEJST0sxYTlmMG9ZY2U0ajN2ZWM4U0lNdEgrZldMNTU5L25zY2VlNHpSYUtTYXpsWWRVQVBOdi8rMVp6NTc4Zm45enlEcVZhTVdoVkExMFgzejg5ZWVPSDZxMytaNVp1b3FNQXVSaVlQOW1hZXRJMFJEakVsYkt6aGw1cFUycHR2MUxEY1FsTm5tbUswWHR0aDZmcE5tWExGemJaL3BaRTZXRysyWGx0cUhMLzdCRTVkLzlmcmVmS2RyekJ2QVcydGpVUlRVZGMzT3pzN3lEVndDNVBXUGYvU1AvaEZsV2I1aTVDdEN2WDlsZHVQenYvM1N4Nlo3elZQRFhMQVdibXpXODUyWHgwK3ZuK2dYeGxqeUxMazl0VUhaMzZ1Wjd0WE1LcyswOWt5YUpOK2pkWURkaG5hdlllZnltSmUvZEo0TFgzeUp2WmUyOExValJtVTJhYkFDUldhWTF2NUxYM2oyK3E5ODZZVWJ6eTJtVm9EcnlrRHQ5L3NhWStSWGZ1VlhsbS9lRWlDdmIzendneC9rNFljZjV0NTc3K1hvMGFNTGtEaFZLb1RxaWM5Y2ZPcTVMMjMrYWc0N1Znd1hudGg3ZW5XOW1KeTZZN1JCU0lyckN6cTZXQXRGeHR3RnBrMWdiOWJpS285dkF2c1g5cm4rNUNZWHYzeVJ5OSs2UkQxckVDdW9FVXhFalF0WUk3Rng0VS8vOE9sci8rc2ZQbm50YTZTeWFyNllYRmxyNDF2Zit0WmJ5aHhuQ1pEdmd2akdONzdCOGVQSGFacUc3clk3VGJTVU9VRm5mL2hyei96N2k4L3MvZHJ1VHJ0MTVhbWRMeHcvMWZPRGxkNmdhb05pOUVEMzAxaURGNUpGc3c5TU5pdWlRdDFFbWpiUXpCcmNwS0xzRlpUREhvaW9FVUZCb3d1N3U3UDYwLy8yNjVkKytZc3YzUGhHQjQ3Wm9qRUhZcFpsVEtkVDNkL2ZYNzVwaDJLNUtQd0xpS2VmZnBxelo4OHltVXdXbjlBSE9vck54TFdYTDAyZjM1djZhMWUrdGZYbGV4NDZjdmZ4YzBmZlA1MUZvNGc0YjJoRFRLUGNoVE90YzJ4ZEhHTldDb3FnVEsvT21lM044TE9hc2l6bzlRdk55Z3dmOUZLOVcvL2IyWTM1SjcveTB2YkhuNzh4ZVVGdWdxUHBza2ZzSmxjNkhBNXZ5YU9vLzY5WXNubi9na0pWYWR0MmNXVkkxN0FyRUs1OFkvdmFsVzlzZnhJbzMvbjRtWWVzU0p0WkdUU3Rhb2hSUXFkdGxWc0RNZEs2Nkh3YkpyMWV2dHJjcUxMWjFwUjJYS2tnWW5KRE5QaHE3cjQwdVZGOWJPZmw4VmRpMUwzRmNFRFRqMjMzNTBkVmpSMng4cFltSlM0enlIL2wyTjNkWFh5NTJBOGVQc3M5VUU1dkEvdjlqWDVaOW9zVFltUVl2Sm9ZWWtkWWpFU1VhdDd1WFg5NjZ3dkgzbkwwOVB6eXVMZnp3ZzJpZDVLWFdTMlpmWG15My95THJaY24vM1I4YmZZdFZjWmRyN0ZveUJkbFZUajA1ekllajdseDQ4YnlqVm9DNUxzcTRxdUFFdmV1VE9mUC84Y3JYNTNPM0ZNbXM5TVFWVUxVdk5YWWQ1a2lHZFRielpWTFg3NzZyNCtjMjdoci80V2RFOU9yNDAyTVBPbWIrSzkycjFYL2RPL3kvUGQ5NVRlN1VtckdUWWJ1Z1VvSnQ2amZ4MzlweVBKL3dYLzEvLzhIVmdra1Zlc1M2QU1GTURyMTRJbTdqci81eUp2eTQvMzc4clhpcmxHZUhaOWZtVzgvK2Vubi83ZVRqNXg0cE42Y25Oczl2L3VWdHRHbm1wbS8zdlVXZmxGU2NWUGJLdkpLK2RBbE9KWUErWjRKY3dna3RnTkgyUUdtSTdWVERFNE9WMWVQRFFmNGFHKzh1SE1OUldOVXIxR3JRd0J3aDhxb1A4OEFaeGxMZ0h6UGdrUmVCWlRzRUVqa1ZmMkxIQUpGN0lDd2VMMjZ4MWlDWXdtUU45UjdzUUNMUFpSZHpLdEE4bWY2bDBNL0YxODFDRmpHRWlCdnlQZEYvcHdYZjg3RHI0ZEF3N0xIV0FMa1ZtN29YLzN3TDRId09zYi9DNnlQUlNER3ZNWTdBQUFBUm5SRldIUmpiMjF0Wlc1MEFFWnBiR1VnYzI5MWNtTmxPaUJvZEhSd09pOHZaVzR1ZDJscmFYQmxaR2xoTG05eVp5OTNhV3RwTDBacGJHVTZWRTFPVkV4bGJ6SXdNVEl1Y0c1bkpYSEdGZ0FBQUNWMFJWaDBaR0YwWlRwamNtVmhkR1VBTWpBeE15MHdPUzB4TmxReU16b3lOem8wTVNzd01Eb3dNSTFjd21BQUFBQWxkRVZZZEdSaGRHVTZiVzlrYVdaNUFESXdNVE10TURrdE1UWlVNak02TWpjNk5ERXJNREE2TUREOEFYcmNBQUFBUm5SRldIUnpiMlowZDJGeVpRQkpiV0ZuWlUxaFoybGpheUEyTGpZdU9TMDNJREl3TVRJdE1EZ3RNVGNnVVRFMklHaDBkSEE2THk5M2QzY3VhVzFoWjJWdFlXZHBZMnN1YjNKbm5MMjVTQUFBQUJoMFJWaDBWR2gxYldJNk9rUnZZM1Z0Wlc1ME9qcFFZV2RsY3dBeHAvKzdMd0FBQUJoMFJWaDBWR2gxYldJNk9rbHRZV2RsT2pwb1pXbG5hSFFBTXpremU0T1dmUUFBQUJkMFJWaDBWR2gxYldJNk9rbHRZV2RsT2pwWGFXUjBhQUF5TlRKOVg5QmRBQUFBR1hSRldIUlVhSFZ0WWpvNlRXbHRaWFI1Y0dVQWFXMWhaMlV2Y0c1blA3SldUZ0FBQUJkMFJWaDBWR2gxYldJNk9rMVVhVzFsQURFek56a3pOelF3TmpGTlR0Z2ZBQUFBRW5SRldIUlVhSFZ0WWpvNlUybDZaUUF4TXpKTFFrSmtKL3luQUFBQU0zUkZXSFJVYUhWdFlqbzZWVkpKQUdacGJHVTZMeTh2ZEcxd0wyeHZZMkZzWTI5d2VWODJZV0l6WVdNeE1UaGhZekF0TVM1d2JtZitjdWJqQUFBQUFFbEZUa1N1UW1DQ1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvbGVvbmFyZG8ucG5nXG4gKiogbW9kdWxlIGlkID0gMzAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI5YzRkNzc0ZjY5MzI2ZGEwNmZlOGFlYTYwMzBkZTM3My5wbmdcIjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9taWNoYWVsYW5nZWxvLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDMwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTWdBQUFEOENBWUFBQUF5cytzbEFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBQklBQUFBU0FCR3lXcytBQUNBQUVsRVFWUjQydXo5ZDVSbDJYWGVDZjdPT2RjOEY5NWxSUHJNeXF6Szh0NERCVnNBQ0U4UUFraVJva2hKTkZLTGxFU05YR3UxdXFkSDZxWFY2dWxlcTJlNjFUTVN1M3RFMlNZcGdSSkJJOElRQlZzR2hTcVV6Y3pLckhUaHpmUFhuWFAyL0hIdmk0d3FvSTBraXN3cTVLbjFWa2FhaUlxNDczNTM3LzN0YjM4YnJwOC82cVBlOUxGNjA1OWRQOWZJbTNQOS9PRmY5KzhIQ0tsZWIvNzQrcmtPa0IrWTY2MnJqODNvWTZYVTZPK2NpRGpBVnkrdWcrU1A3dWpybCtBUDdodzhlUEQvQ0JpNkFrUll2V3JWcXc3VVJTUVNFU1VpbzM5M1BkVzZCbzY1ZmduK0FDNWlhRkFvVHB3NHdjYy85bkZtcG1mVWhRc1hsUGRlZng5Z1JFQmN2VUlnT0hueVpQelRmK3BQTDN6MjAzLzgvVWNQSDY4OTljeTNWcTZuV05mR0NhNWZnbi8vTXo0K3p1VGtKTXVyeXdqQzZkT24xVXN2dllTMVZsdHI5NElqVUVvWklCU1JBTkQxZWkzOHdPTWZtSDczdTk5L2U3M1d1Sy9JM0R0MnR0dnpXV0wvQytEcDZuUGQ5YXQ4SFNCdjZacENSQkF2QUtyWDYrMEZoYW11YndnRVZlcWtqeDQ5MnZ6Z0J6NTQ2S0dIM3ZtaDFaV04rd2JkN05UWmw4L3J5NWN2UDd1eHR2ckxhMXVydjExOURYdjk4bDR2MHQvUzEwNXJyWlJTU2tSMGxVNFpJRlJLalVBUkFIcHFlckwyeDMvc0p3NGVPWHpzdHFuSm1jZDYzZUc5Rnk5Y25MdDg4Vkt2czdQOXJlWFZ5Nyt5MWQ1NllYbnQ4aXFRVitBb3FnaHlQYzI2RHBDMzNQVWFGZDI2aWhMQm0rb01FNFpoZVBqUW9mRS84NmQvOXM2NXVjVjNEZ2JKdmUzdHpyR3paMTh6cXl2TDV3ZTl6aGZiM1oydlhGbTk5TkpPWjJlekFrT3hCeUNXNnl6V2RZQzhoYTZUNG8xc1ZGRFZGcUdJaEtNL3UrbW1HNXNQUGZqSS92dnZlK0RSWm4zOHdZMk43ZHV2WEZtZVAzdm1UTnBwYjcvYzYzZC9QYzBHVDU5NS9jeVpJcytUQ2dTamlESDZkVVR4WG84ZTF3SHlsZ0pGQlF3VkFCRklBSmdvanVzUFBmakE5SWMvOU5IN3hpZW1IMWFZZTY1Y1hqbHcvdHo1YUhuNThuWTZIRHc3VFBxL3RiRzEvdFNWMVVzWFJYYlRKN3NuWW94Nkg0NDNOZ3F2bitzQXVhWlRLTE1ualJyUnRBRmdicjNsMXNtSEhucm84RU1QUHZ5WTkrYmVOTWx1UFhmdXd2aHJaOC9LenZiRzluRFkvNTBzUzcrOHViUHgzTXJhOHNhZUtMRTNqWEo3d01IMXFIRWRJRy9WRkNvRXdrYWpYdnZoVC83dzRidnZ1dmZleWNuWlJ4VG05Z3NYTGs5ZnVuZ3hYTDV5T2UxMGRpNWtXZnJWWHIvenBTdXJsNThkRFB1RFBXQVkxUmhPS2VVb3UrWnlQV0pjQjhoLzBQbk1IL3NzMjl2Ym5IM3RET2ZQbi8vZmUrTHZQWHR2TlBuQTR4L2dpYTgrUVpJa2xQZmo5NEJDOGIzVTdHNjBDSUlnT25ueTVPd25QL0hEcDI0OGVlcGhXL2g3bkpXYlhuN2xUSGpwNGdVMjE5ZlN3YUQzblNRZGZHRjdaK3RyVzUydDE5TTBHVmFSSWQ4Yk1aUlNUaW5sdGRLQ1FyejNvcFRDdWVzdGoydnhYTk45a0dhalNWRVVIRHh3aUNOSGpuRG8wRUgrNGZsLytQMXVia1dwWjZKNkludEFsRkl5TmpiRzNOd2NRUkM4R1JodjdsbUVTcW1vaWhZQkVCMCtmTGp4L3ZlOS80WmJiN250a2FXbGcrL2MydW9zWGJtMHNmRDY2NityMVpVVnQ3Mjl1VFVjOWw1STArUUxXKzNOTDYrdXI2d0IyWnVBTVVxcnZGTEtHMjFrWm5wV25QZml2YVBkMmVHcURPdjZ1UTZRNzNOKzlzLzhHQysrZEpxenIxM2swWGU4aTZlZWZKSXJWeTdUcURmbzJBNWYrTkx2cWMyTkRiYTJ0OVQzdWNGSEx5VWl0b29ldWt4ZjhGRVk4Y3kzbnlGSkVpVWkzNCtlamFwWEtDSW1qdVBtWSs5OGJOKzdIbnZYclhPeit4NXRqVTNjdjdteE0vZmt0NTZMbGk5ZlptdGozWFc2TzVleUl2dm05czdtNzdhNzJ5OTF1cDNOTjlVWGV5T0cxMXI3ZXEwdWVaNmp0WktUTjV6aWlXOThpZkd4Q2J6M2VPK3YzNG5YVTZ6dlBaLzl6S2Y1L09kL20yNnZoNGl3dm5hZXYvU1gvM09lZXZLYm5EOS9Yam5ucUc1cXBaVFNJcUpISGVrOVQzNEQwR2cwMUgvNk4vN1dMZC80K2pjdS9wdlAvNnZsS29wNHBaUW9wZFRlUmg0UUtGUWtTRFJLcDI2NStlYXA5NzczL2JmZmRzdnQ5elhxclhzR3cvVEkxdGJPNU1XTGwyVnRaVVYxT3p2NWNOQTczeHYwdnpaSWVyKzl1YlZ4cnR2djdIeWZhRkdNNmd0QVJFVEd4eVprYm5hQnFhbHBubnYrR1E0Zk9zcms1RFJQZi91YjErL0FIL1FJY3ZzZGR4REhNVkZvZVBIRmwraDB1cnQxd04vOXIvNUx2dmlsTHpOTWhodzh1S1IyZHJxSWlNcXlUSTNBVUFIRWlJaFdTaG1sbEtsQXNodE43cjNuN3ZDbmYvcG43MXhjUFBoWGg0UDA3L3liei8rcjFRb01ybExJanZSUWtVZ0pDa0hDZ3djUFR0eDc3MzJMOTk5Ny85MkhEaDU1T0FwcjkxMitzdFk2ZmZybFlIVmxoYzJOVlFiOVhqZEprOVBEZFBDbFRtZm5pYzJkelF0cG1nejJGTnpGbnBkVFN2azRya2tjeFZLcjFXWC93anhuenA5SHhKTWtRd3BiY1BiYzZldDMzZzhxUUQ3NzZjZElYSWNuZnY4MWRyYjdqSStQVXhRRmUrWWRkblB1VysrNFR5VkpvcndYcmx4WjFYdFpwRDJ5NzkxWEJTeUphM0Z3OE1EQnhxYys5ZW5qYzdPTHQ0cklUUnRyMjQrOCt0S1o1RHZQZi9zS3BZeDhWS3liVVJwVlNUOXE3My9mNDRjZmVlU1JXNDhjUHZhUUVuMlQ5L3JJaFF0cjhlWExsOW5jMkpET3pwYjBCOTN0SkJtK01FeUh2N201dmY3MDF2Ym1pb2lNUUpIdHJTK1VVaDd3Umh0eDNzbkQ5NzlUdlBmODFJLzlMRC81WjM4RWdGNi9lLzF1KzBFSFNEMk91Zi8razd4MitRejFSc1QybHFodmZmTWJtQ0JVNHIzeTNtbGo5TzZUZnpnY0t1ZmNYaFpKVnhGaUJBb05vRFRCbmJmZkdkMXh4MTBMVTFNenh3NGZQbnF6Q0hjTkI4bko4K2RlYjJ4dGJ1eHNySzk5Zm0xOTdTdXZuSG1wRFRTcmduMzBkZUtqeDQ2TlBmcndveWZ2dnV2dWV3NGRPdnJ1TkNtT3JhMXRORmRYMTFsYlhXTm5lNE51cDEwa3lmQktrZzZleVlyOGllM08xdk1iRzJ2cmU2SkZXb0ZqYjhTUWVyM2hqVGFFUVNEYjdXM0sxTkR2Z3VQNitaNTBYcjJaYVh6YjFpQi8vYS8vZFliREFhKysrZ3BQL1A0VEhEZzRxNVN4WEx5d3JaSWszOXRYMEh0U25hdERRU0phM2xoVEtFREZjUlFmUDM3RDJEc2VmZGZTemFkdWVialQ3WitNd3ZCRXQ5dGYybGhmczJ1cks2LzN1dDB6RzF2clg5M1lXRHU5dHJsMmNVL0VVSUJxTkpxTmozemtJNGZ2dWZ1K2UrZG01eDVvTnNadVNwSnM5dUtsNVdCdGRZMk5qWFhwdG5mbzl6cUZMWXJYTTV0OVlYMXo5WW4xemJVelJWSHNUWjlHVVNQYlU0eGJwYlJ2TnByTVRNM0lvNDg4em0vODVqK2pXVyt5dXJIeUE0K0dHOGRiYkdVNW0xbStkL0JyTDhraWIzcGRrMEQ1RHdKSUZFVTgrZVMzK0kzZitCeFBQLzJNK3UzZittMmNkMG9RTGY0cUlMamFmUjY5OXZZZE5LREh4cWVpZ3djT3RBNGVQREIvN09nTng1ZjJIem9WbU9CVXY5ZGZ6TFA4NE1yS2NyRzJ1cnk2dGJYNWIvdjl6bk5iTzVzdjdYUTcyOTY1Z3F2OUMxRktCYmZlZXR2a2d3OCtkT0tCK3g5OFlOKyt4WWQ2bmNHaHpZMmQrTUxseTdLeHRrNTdaMHYxT20wcGlxeWZadW1yV1o1OXJUZm9mdjNpbGRmUE8rdnlxcmd2OXFSVWUwRXlrb080TUFoOXN6a21jUlNoVGNESzZ1WHJjYUk2dDB5TTBTNEtyZ3pUNzhjNDdsVU5lTjQ0WHZ6V0JzaXYvL3F2ODVXdmZJVi84QS8rQVFEdmU5LzcxRFBQUE1QbTVxYktza3g3NzNlYmJYdUs0Z2dJNStabVd4LzV5RWYySFQyNE9EY3pQVGE5c0hSZyt0VVhYOGkvL3BXdkpVZFAzSFRUMk1UQnU2eVltU0pQWjlzNzIzR252VjFzYlcyc2R6cmJMMi92YkgrdFAraTkzaC8wTGhUV0ptLzYvdFdCQXdjbjMvT2U5eHkrL2JZNzdqaDU0c1lIZ3lBK3NyNitOYjY4dkJxc3JLeXl0YmtoN2UxTjFldDJ2UGQyS3kveXJ3K1N3ZGMzTnRlZjNkcloydkxlRlJVd2ZBVU1lL0RnQWZPKzkzMmc1cjM0eGFVbEZ1WVd4NzcweFMrYy80MS84K3NkcFpRM0puQmpyWEhaYVc5ZFI4VGVmT2wvK05zYytzdi9KVDNyVkNjdmxMeng0Y2hmT1g3azBIZTNPOWx2N2V4YzVxcFkwMStMRWVUZnFRYjUrMy8vNzFPdjEzZkJOUmdNK0kzZitBMDFTcCtxSWppa0dpa1ZrYkRWYW82ZE9uWFQ3Qy8rNGkvY2QrclV5WWZtcDV2SHBzYmllUTlqcDE4K0g2OWVLZHc5NzU3eXJhbDFrL1M3Wm0xRmNlSHNXcmEyM1BsT3U5ZCt1dFBwbmVzbjNTdk8rYUhOWFNhZTJ1Z3BGTmNhd1gzM1A3RHY0WWNldnVHZWUrNTk0UERCUS9lc1hGbWJ2bmh4TmJ4NDhSSmJXOXZTM3Q2azA5a2h6MUpYNU5scVh1VGY3Zzk3WDdsNDVjS3pTWkowZUtPMDNBUHVZeC85Mk94NzMvUDR3OTFPLzBIcjNGeTMyNU5CWjZndkR5OFBBeFA5SGVCYmdCTHg2di9xbXhvR2htUHpVOVFDdzNNWDE5N2V4Y2FmL1U5NTkveU0rdHJtdHRwRHJVZEE4RXMzSGovY3lvcS9XdlArbndMTGI2c2kvZURCZy96U0wvMFM3WFpiWlZtbWxGSzdFVU9wM1laYkRZanV2Ly9lK1k5KzVHTzNmL0NIUHZTdXBjVjlwMW8xZlNoU3lVUmNEK2tQQ243cjg3L0dDNWVlWU94d0hpeWMwQ2dERStTeWVMdFN0N3d6MXNOa2NzWXo4YkJZZWRBS2FLV2N5MTI3dloydFhEemZ1UlRZS2ZmNEk1KzZJM0tOazFNekMwdWJXOXVOTDcvNG9sNWUzYURURzlEdDlXanZiQ3ViNTJsV1pCZUg2ZkRiN2M3T1V4dGJHK2V5TEcxWDZSS2dCTVFEL3RGSDM5SDQxQTkvK2wyNDRJOWZ1Yml5Y1BIQytkV2Q5dlkzMFBxbExFbTZ2Vjd2ZkcvWVAxTkZMZzlLOGp6YnZUNjFLRkRPeVc2R1haVHlFUUV3Q2lZYU5lcWhZYklSQTlBZVptOUxnUHpjRFVmNDljc3IyTEsrREJSRUF2R0hsL1l0akJYeU55NTArcmVlSGd6L213bzRCZGV3NU9uL0VrQWV1T2NPdnZ2eWFmN0pQL2tuNnRLbFMvVDcvVkY5c2V2UUlWSzVkR2lhZi80WGYvN21QL05UUC9PakoyODQvbzRnME0ya3M2VzZ5Njh3dFcrZmJLNzMxRy8rN3Iva2N2WXRqajBZbzNRZGhhZGljSlVYSWF6cnNFNTB4RGtoUkZFb1JXaktPMjAvNG83Y09PMVhuMHg0NFl1ZkQ5ekFLdXM5Um1uU1BBZWxxZXNBN2FCV1UvUlV2ckxXM2ZocVozdm4xZlh0N3FZdHU5YWpRajRBNGZiYmI1Lzh4TWMvZGVmMDFQeEhPanZkTzE1NTZaWDE1ZVZMLy8xekx6N3pyOXZkbmZhZTRueWt1aFVSRWVjc3crRmdaTm1qMHR4K2o4ZVZVa29Rb1hBaVoxYTNwQkVHS0tXa0Zob0tyMmpFTVJ1ZHp0c0dISC90aHFOOHRkMm1XeFRLQzdwNmFOWm40cWh4VXhSK2RyM1QrY2hXa241eHc3djJIb0M4dFNQSVQvekVSL2pMZiszdjhVLy82VCtsYXQ0RmU2SkZUUkhXVHh6ZlB6MngyRi84NUdjZWV2elRILzdwOXg1ZE9uWUROc0Zub3Jycmw1Qml5UGFscytyM3Z2MDAzOW42R2pmZTNDUkdVQXJDVUtGVW1hblVBb1hXRUdpRlZob3Ztc0lKM1ZRWU9zL202VlNmLzFKSEQ5Y3lGU3BERUFWRVlVQ2dvUm1IZU84cFhJNjJGa2tTeHBDbDVuVDBxY1htNUk1ZEd0OUtjcnUrM2UyZjMrd096K2RpbGovOUV6OTcrTlNOdDd5NzIrbmQvZUx6TC9uenI1LzdqY3VYei8vejF5NmNlYTBvaXBUdm5lemJPOGlrQk5ISUcxZzR2UWNrWHFTTVR0NTcxeDZrdmdPaXRmTHRnWmVKVm91TlRvZjVlcDMxSkhsYkFLU3BOYWU3ZlpVN3IvWVFOT0ZuNXVmdUsvckpqM2JTTE13Q2ZXNHI5U2x2QVZlZC8wc0ErZHBYdjBPcjBWRGJlV2NFamxncDZpSTA3ci9yemdNUFBuTDAzWWR1TXUrVDVzYkNYVGMvZU9Ud3ZzT1J6M3NvcFVnR0NjbWd4OEsrQTN6bmhXZDVvZmNzdGRrSTd6V0RWQWdDanpnSUtwQWtvZ2hVUUJRSEtQeHU1N0FWS1RhZUhYRGhkOXJLRDJCbVlneXRGVmxtRVMva3JpQXJMUDBrWTNPclRWR2tLRHhSRU1RZ3NlQW5sTkpIWXBUc0c0K0srWlpKVFZqYmpnWWJrNjg4OTUzSjg1ZXZQSFg2N0t2LzY1V1ZpODhteVhDYk53NDB2U0Y2VkwrKzJlc3E1dXJvN2Q0bzRnQXJVQ0JTQ0RqdnhBSSt6WE1acjlWRTZqRzhUUUN5WGhSTVJ4RWJlVEhTdTRXbldxM0pJQzArdnRvZkhNcTlIK3dnNTl4dW1ucHR6Ny84bndMa1l4LzdKRi8rNmxkVnU5dFZWYjBSQVEwUldoOTUvSjBuSDNyMDZKOXQ3Tys5TjU1TVkwOUw3WnU2RFlQQk9rR1VzTEY4bVRpTzZQVjZmUDNGSjRoYmpqQUlLS3lubnpqaVVGR0xOTm9JeG9EU2lqaUF2TEFFV3JBaUtLMjQ4dFNBVi85dG15aUlhRTJFaUlDMWpzQm9jdXZZM09teXNibU45d1dCaHNnbzRpakdPVSthNTVqQTBHaTBDSU9JM0xvUUlRcE1NSDc2TzkrZzhFWld0bnJteXNxR1NjUUgxYzJlN2dHRGV4TkFSdUFZRlo5MUJiWHBzY2JrWkNPZXJrZG1ISlJhN3c1WDF6dURuVDBwMnQ1K2lzM3kzSXN4UG5hUjdCdXZzOXA5NjROa1BjdFp6M09sbE5LSUJBTEJyYzNHL242YTNkMjNoUktsT2gwdkYvZEVaUGsraktxOEpRRHk1LzdVcC9uQzExNWlhN3VEYzI3MHBLd0R6VTkrOUVOSC84eWYvdGhmdkRoNDR0MWQ2WnNzRGFSWnF6RlJuOFhsR2VJZGc4R0F6dFlheDQ4ZjVqc3ZQb1d0YnpEV0NMSGFrUmVBYU5KY1NIS0hNZ3BSaWlBUUF1MHdDSEdvTUZyUlBqUGc5UysyTWNvUVJRRktxYktSWWd6T08xWTJ0dWwydWtUYW9RTmQzdFhPWTRzQ3RHRmlZb29vcnBQbWpwWE9VQTExUVZRekJBcDZ5bUphUmswZnJOK3RGdWZNOG9YZTM5dmFITDVTcFkranB1Q2J4MkJIVDhjYTBEQmF0OTU5eStGM0g1NGIvNHg0bWROYWpWdVBmdkwwNVROVGpmajNKbHUxN2ZYMjhQVDVqZllGWUZoRm1WU2d5SjJUM25CSWFKUk0xbXEwMC9RdERaQzVNS0R3WHUzMnBwUXlNMEZ3V3lySmZ1K0ZJRENEUXJuQi8wN2tVSHNlUVBJV2lDREN6dmFxc3JiUUlydWFwdm9EOTkrOTcyLzhsWi8vc3djT0w3Nzd3dGVmMUZucUNRSlIzbXBja3BMcEx0NWJycngrSG8xalkzV1ZwMTk5Z3VZK0lRd0M0c1lNM2FKRGJndXkzT1BFWTd3aENoU0ZGWHlnTVVwaEMraWY3clA4bFRiYUdjSW93SG5RUnBkQWNaN3Q5UzVTcERRaWhYWFZWYTJpVGhEWFdKaWZ4M25GbGUwZC9MVGp0dmZQc25Cc2pDaldHQ1hrVHNoVVFLRU4zYTY5YmYxaS8rZlBQTFgyajc3NzVjdlBlYmRiMEFlanAvNGVnTVJBS3pSNjdPR1RCeDQ3UGovNTEycWhPVGpJY3RJaXAzQXcxWXFYRHN4TVBCaUd4aDJZSGo5N2FHN2kxNTYvdVA3NW5YNnlPWHBpQ2toV1dHZWRaandPM3ZJVGhmOWlaWjNFK1pFS08yZ0dKZ3hGRGcwOTlVQnJueXUxa2UweWlMdGdNSHRvZHZXV2lTQmhjNFphclE0b0RSSUN0VEFJR24veDUzNzhmVGNlUC95K0lHeWF4ZkZqN09SWDhBV3NkWHRzYksxVHkyTzhVcHc3L1JLSDlzL3h6UE12MG5YTDdHK09ZN1FtQ0gzVlR0VUVTdEZRZ3RFQlZnU3ZJTkNhTVBCMHp3MDU4M3RycUR3a0NBMjVMNmpYRkZtUkU4ZkM5bmFiZm1jYnZNUDVrZ2tyTGR3ME05T3p0TWJHNlBaVDFvY2RibmkweFYzdm1TZHF4UXh6SVMzQU8yRThMMURpNlRraE1hTEg5NDg5ZU90VTdkRHgrL1k5ZWZtRnpkOTYva3VYbmtrSFJaZXJBa1ZYdmFFTm9IbnY4Y1VIYjFxYS9rV3QxTUcwc0RnUlNsMlc1cWFEODFqcll3K01OV3EzVDdicVJ4dHhQUHU3ejUzNVplZDNSMjI5Z0RnUjE4M3l0MzZLbGVjWXBWUWxIOUtIbzdneHI0UDlxOVlwajlvK2E0dC9zZXpjZGdVRTlhN3BLWFAvek5RdEhmRVgvcWV6cjI5ZWF6L1AveUdMY1BuU0N1c2JtOW81RnlpbGFrRGo1My9teDIvN2ljOSs4aGNiY2JSa1RJakM4T3o1WjFuZDd0UHBGeHdaTzh4c2M0YmNXZFpYcjZDODQ4dlBmb245TnhrYXpRZ2ZLTHkyTkdKREdDaVVnbVpzTUVZakNxSlFFeHJZdmpqZytjOWQ1TXJyTzRnT1FBZUVnYUVvUEZsdVFXbTJ0cllaSkgwR2FZNFR3WW1uWHFzek43OUFyVlpudXpOa3ViL04zUitkNFIwZjNvK0pERm5tMFZvUkJxQ1Vwc0NBS09vMXpYaGRVek1vRStueHNkbjZUUWR1bW5ub3lLblpxWFJnTjdkWCt1a2U1cTRKTkk3T1Q5eDA2OEc1dnpCV2oyL0xiSUVUeit6RU9Ha2hpQWhCR09BRXZBZ0N4SEVVYThXcE9BaUc2OTNoR1Y4eVhIWVBkZnkyS05TTlVrWXErdjlFdlQ1elcxVDc5SmwrYjc4Z05sUHFxUlh2endDRmd2VFRjN01uNXVQd2h0L2MySDV4TFUydk9SK3cvOE1Jc3J5Nk9wckxDSlFpanFNd2Z2KzczL0dPMmZuRmszbS9KM20vcTZhQ0dhYURRMXdZUElmTkhKMStGeE5FcksydmtPVVphMW5DMEd6VEdGK2dVSnBHUFNReUdxMFU5Y0FRWVBIaTBlSXhwa3g1T20zSHM1Kzd3TVdYdGpDaEpzb0tXZzFGYmozT09aUlNSTTR6VEJPU3RLQndwVXVuMFlxbHhXbUNJR0tyUGVCeWY0ZmJQNzdJaVlmbXlDdzBJMDFrTkxtQWMwSXpVZ3dNZEZWQTdpRld3cjRwelZUaFNaeFNuWUs1K3MxVFB6RTJWNzl0K2tEclYxNzQ4cVhuQnAwc0FZTGoreVlQbk53MytXUE91VHU3YVVab0RGcmcwa1libEtJZUIrVFdreFVXcFJTQ3NOTWJvb1h4QXpOalA3blc3cDI3dU5YOXloNkdiQlFBSlRhRzdDMDRvMzY4SG5NdXlVYkZSVFhvcGdNUGpUTEN5L2lVMHZjcStLSkFzaEJGWmlvTTcxdE5zdGVlMzJsbjEyTEQ4UHNCWkhlSHhaNmVSMDJFMnMwM25waS83ZVR4aDdKZVd3ODZiYnhYWkduQlBmdnY1L1RsMTdtVXJMSFMzU0hOVXJxZER0WTZsamZXbVZxSzBMV1FXbVNJUThBSFdPZkxta0UwQ2lIUW10UjZocm5pd3VrZExyeXlnZEthTUFncHJDT3pGaThhNXp6R2FMTENVbGlIZGE1c01vcWdURUJtUGIya3g2WE5IVTU4YUpIOXQ4M1JHMnJ5SExJWUdwR2dsS2NXYUxUU0JOb1RHa2l0b2pzVWhzNFFCWnBtNktsSG5sNG1nZGxYdi9mK1R4dy9jdmp1dVNkZi9OTGwzMnV1K1BwdEIyWS9BOXhrdEFrVWl0NGdaWG1uUXhTSHpFK000eng0UEVvcG5QY1UxaUlDc1FtNHN0Rlo3UFNTbjZ3RndldXB0YS90QVluVDVUamlXektVdkpaa1JGcXBvdklxQm5TdUlXakVXUndFRElxQ1VLdkpNZEZqWGUrNzkwNk1Iem93MXByNS9VdkxuNnNJSUhzdEErUjdIRDcyOUR5YXdQaE9wOU84c0h4Qk5Xc1JSWlpURElmb0s1dk12dlFDbjN5aHoydmRJYkc3d002UkRaSThwN0E1NFhTWCtjVXhUQkRUcUlQeUVZTk1jQzdBaVNZcEJvUmFrNHVuMnhmV0I1N2xsOXZZekZPcmhZRENPa2VTNVJUR0VKaXlnTSt0SlM4c1hnVG5IZDU3eHNZbkNZS1FkaTlCaldsdXUvOEE5VkNqbFNjclBHbWh5R1BEWkxPc2dLSWdBSnZSaXFFUmF3U2g3elY5QzFacnhrTmgyamhxdWNQVTFXeDRiUHhEcytuUiszbCtTSjdhV1JGRmtoVm9wVWtLeTc2WlNaSWlZNnZYSXc0Q0JMRE9vUVMwQW9VbWw0SmVtcW5weWRZdG9URVBuRjdaWEdYUGZJbUlTR3lNMkxkWUJQbVhEOTdOLy96YUJYNXpjM3UzL2dETVNwbzZaOVRhWkQyV3hGbzAzRFN2MVBFdXJOelRhdDNhRWFtdml1c3BNSElOdXRrSGJ3TEhibk5IS1dLUk11Y1dvUjVvMVdxRW05TlB2ZkQvU1ErTjN5eExVVmU1YkIxL2VvZjZGeEpxMnpEbmhFdkxMM0NwTlU5eDhqaERzOEhrOFp4RU4wbXRJc3BqY0pyQ09uSUh1YlZvWlhEVzB4bDZPaDNMVHFlZ3U5cEhTVGw1S09MSjBvSkd2UUVvdE5ia2hTUFE1ZDhwRk40TFNobkNxRVkvU1VuU25IZ3BZcGc1Z3NBdzFtZ1FSNUFWR1VrdTVONmpsV095cnFqSG1paUFLR2lpdEJCbENVbWhLUnlrWGxBbzRzaXhZQnhicjZRcStXNHlPK2hsZUMvVTR5cTZGUmxoWU1qekhPYzhlVkhRRzZTTU4yS2FjVXlyM21DWXBBeXpESzAxdHgvWlIyak14R1ozOE5NN25mN0d4akQ5QWxmbjJsMW1yWXFEUURMNzFqSjQzN0ZXcVQwTlZBWEJWbDY0VGVzdXhtR0FCeUpoZGtIcGh5OHAvOXkrdUhacWJaaXR2TnJwR2E3UlZROTdBYUwzZElScklzUkE4NGJGWU9iUGZLUit4dzJIZzN0T0hBenVPTFR2M0kzMTdJelNRMUNGcHJncElyTXhWMzVUY1dZall6VWRzdkZQUDhmc1p4NWs1Z0hRdFJwejBUaVR6U1hTUEdOMXNNNGc4d2dlNXdUckhQMWhRYmVmMCt2a3ROZUdkRmU2ZVBGbCt1U0ZVb2xlRnI1NVhxQzFodEJnZmZuNUhxaEZFVTRnUzFKeTZ3akRpR0ZteVhOTFVYaW14c2FvbTVERVplUlpoaGZJQ2tzdDBrdzFRM0xuS0p3blVnWk1HV0dzQTd3bTgwTDZTc3I2MHdPRzNZSmhsaE1hUTFwWXROSFVnNGdzdHppQk9Jb1lyOWZKclFVdmFLWFpiSGZwRGhMR1d6V01OaVdURnhnMTFhZ2ZYUmh2UHI0eFRKK3F3SkVLV091OWFLM2ZVbWxXcEJXYnp1RXFEd0VnbkkzQytrZG5aajZjNWZsOVJ1bkNpa1FXSDlTMXZ2RlFIQitxYVhWakw4MmZTNTBMOTFDODF5eEFScnFaK2sxSGdya0hiZzFPL3ZoNzZvOGVXSXp1V0p4VXR6Vmlwc1doWEdwSXM0ZzBEUmwwRGNPK1poaHBMaDNNK002NURtY0hROXdONHp5MGZ4TnB6aUZhTVZZZm94Rk8wQjRzZ3loYzRjbTl3MWxIZDVqVDdtWU1Pam1EWGs1M3RVZmFUVkFDMWxyRUdCU1FKa1BpV3AzQUdMejNaSGxGNjRxVUVVUUhwVmdSUlpaYkFxTXFBSG1DSkNOTjg3SUwzNm9UbXhaZVczS1hzOU4yZUN2b3NBU2FOaHFqRlZvMERYRTREYjBybHMwbmUzUjNNa3F4bzhLS1VCU2xFRlVwVUxxa3JBT3RxVVVCL1NSanF6Y2t0WTVHcUFpTkJsV21pN1V3Ukx3b296VVRqZmllZXFCdlNLenZjRlc4NTkxYnlBcm9GdzdzNTFQZmZKWjhEemlBOEhpak1iTm96SWRmMnRpK2UyQUxzZUpKQll4U016TkJzQ1RXelE3eklxa2V5aU5HejE1ckFDblpCZ2dFNG9mdmpHZi9uMzlwNHM4ZE9SeDhkTXJMakhFcVNvcUFYbHRKbm1pU0pDQVphQVlEelRCUkpFTllhMXVlN3laOE9SbFFPem5KUi83OGJTd2RtY1U1dzJTdFJhQWlOcnVYR2FSRHNxS3NGeWc4dzZTZzF5L283MlFNMmltRFRrYm5Tb2RrbUZPUFE2eTFLQlJHUVphbTFPcU5NcSszRHEwVktFMVJPSlJXb0F6T2xmVklJWTVhS3dRQjZ5RE5oVkFFVy9UcDlCTWFqWEdhalJyTlJvMkc5aVRaa0RRckNDTk5xeDRoVG9Gem9BeCtZR2wvczh2cXBSNjVzeWl0eXJsZVVjUlJpTllLbzhFV3Z0eGY0Q3pyN1pROEwyaEVBVW9KazYwNjRvVElsTkZEdktDTlFzY2g0ODNhZ2JsNi9OakZYdkxpbmk2N2N0NHoxNGpadU1ZbDhiZE5qdk5ha2pBZmhlcFNtaW5aTS85eGE2dDE0L29nT2RqUE1ncEU1U0lvcFFpVWlodGFUMDhZTTNlcTJieDNKZ2pPYkZtNzErSCttaG1lQ25iVEswV0FFSHptL1JQM3pLdnh6Mng4VjAvWU1jdGtNMmVuSDlIdUJTb2J3aURSWkJrTUJtWGRzTGxUOE9KeWwrOWU3S0NPamZQNHo5M0c3TUZwUWhVeVVROHhZaGdtT2NPOElNOHNhWmFUVzBlV1c1TEVNdGhKNlc0TTZHME4yZG5vTVZqdTRxMm5NTFpNcFFCUm9KUmdiVUVZeGhYVmE5QW14SW1ndlVMckVFRlJPRWRoSGJXV3dYdEhtbGQxaWxaNEp4VFdzVFBjUVJ2TjlNUVlSK1lXQ1JGUWpyb3hZSE8ya3h5TklnNDB5ZW1VL3FVVUoyQzlweDZHaEpFaENneTFPQ3pwWGFYd3pwSG5aVXBJWFNpOGtCZVd6akJGS1VXakhxTlFSRUZRcHBWWlFWcFlobmtSeEtGNU1EYnExekludlJGQUFxMnVxWTd5Lzk0NTFLanoxRmFiN1R6Zkd6MXFEYU9iWTByZHZlSHNyUFdlQXNFRFNabTdqMGRLelVTSzJxMjErR2ZlTnpYMXlqL2YyUGhTOWJuNXRaUnE3VTJ4REJERVJYaDBheVdxcHlrTWRnelpnc0o1emZxYXBqOFV1Z05QWitqbzlTeHA2dWdNYzdvcHZQT0RINkoxdDJkOGYxbHVCYUhIQUVtV2s5cU12UEFrYVU2UmU5TGNzcjB6cEx1VDBWNGZzSFdsdy9acWgrNU9IMmxiaWtKUTJoR0dVQlFXMGFWbU1NOHl3akRHZTQrMWtHVUZ6bnFDT01CNndSaGRhamNVUkxXUXdqdXM4K1JXNGJUQ0N4U0ZCd1hlQ3h2YkhZYjloTW5BVUorY0l0UjFob1ZGeEtCRHpiQlRzUDVTbjg0d3gzdFBJNDZZbnFoVGowTVVaVGs2R0taMGh6bFpZZG5wRENpc0s1dWVnTE1PdEtaWmo2bEhOYnFEbExYT0p0MUJSaS9KeUt6RGxiS01SYVAwQXJqempBd3VRQlZ5N1FQazM2NXVvRUQ1cThOUnNVRDgrTnpjTVlyaXdlMGtVVTZWY2dGVmhZaWhzMm9lbWo1M1JvVjY4dEg1bVVkL2RYUHpTVmVPT2dkY0hhS1Nhd1VndTFUdjFwYnJxMzE0b3dHbjJGeU8wSkhRN2pqT3JCUU1FMGNBdUVKSWM4dkt4b0FIUC9nSi9zeGYvSXVjNjd6Q04xLy9OV0pUdnZHSldNUkJXbmlHV1VFL3RmU1NnbDQzWldkdFFIc3JZZjMxTFhaV3l4dTF5Q3crVXpndjFDaWJpVmx1c2FxY0cwbVNBV0ZjcDdCbGRERkJnQmV3SG9MQTRMekhhSTFTR210TEVrQnJRWlFudDFXbzFLWXMvTDBuU3h6S2d0UUMxdGZYMFZyVGFFVFU2eEhhR0hwbmUyeGU3S08xcHRXSXFFZUdMQzNZN1BUWjZ2Ykp0YWN3anFIMXBGYklDMCtXT3RKK1R0NHZVQ0tnTmEwNElEVHJETEtjekZhMDcxN0ZtMkpjVUV0Y2xjOHJrZkttdWhiUFVpMW1PUzFUdjl4N3BVcEE3MnIxeG9PZ2VYTWN2Ky84OXZhTmliVmx2VmJsVGFiOEhLKzBSb01CTVF0aGVQdXBpZkc1RjlxZFBsZG5hdHkxRkVFWTVYMDdIYjhwWG5JajFBU0Y5akJvSzlvZHkwNDdwMllVS01Vd0xiaXlNMlJEajNIbmc0OGkxbkZ5NmphNmcyVmUyWGdDcnkzZWdSZUxkY0l3Yy9TU2dvMnRoTjVXd3ZibExodVh0dGxhYTJOemk3anloazRMd1hqSU1vZUk0RHdvTFRqclNDV0ZYcDhnQ05BaUdCT0EwdVdOV1JSbHMxQlJOaEJ6UzgyVU5ZZzJnbE1LN3lrRHZRS3hVaGJ5MXRFZENvV1VUVDNySEdsaGlic0JHeTl1azJTV1Jxelo2ZlE1UFJ3d3ZtUzQrWkVaYmwxWUlweXNNVFlWaytkQ21zRXdGZHFkZ3JYTEExYk9kYm40OGhhYnkzMDZ5VldObGQ1ekIxVHFQUEZDUTVDWlBXeWlFaEdzdmZhWXp4dnFkYzRtQ1ExalNKMVRVczRzNzRKRG9INnFYaiswMlIrODQ4cGdHQWhYQjJzODBGTGdSUTFXYmJFK0VKOFdSVUV0RGc3Y096YTI3NFYyNXhKdjNCRi9UVVNRVWpBblpTZjM2YlBKYSs4KzVWN2JOeEhjbFl0SWJwUktuSkJrUWlBaVNlWlVMN0g1bFY2NnRqRlduNWhvN1J0djFPc2thWUVKWW80MjdtUTF1TWhHZHE2NklSVjVMdlNUZ3AyZGxLMHJYUzZmM21CN2VadGhMeWs3NDZYSkcrSUVmSm1FaWdXbHFwdldDNFgyS0Mrb0xNV0VMWEpyYWRack5KcE51djBFNzBzWlNxQTFJTlFpVGFRVmdTN3JGd2tVMW9QekhtVkt4c21xRVJ0bEdlWU9FNWl5MnkzUTN4aXllYkZObmxuT3IzUnBMTUxqUDNxQWV4NmVaMkcyUmlkWGRCT1Bjb1lrSzNBV2treVltWTg1Y0dTTTltMXpyTnkveE5sbjFubjVHNWNaYkEvUnZIRWtzUUtJa2xJSW1mREdhVVJLcWRhMWRmN2FnUVA4MVF1djA3ZE95WnNpQjlDNnFkV2F1N3ZaK01UTDJ6c25ySlRVL09ndUR4VVNLVTFQOGNwbVVaemZkcmJYVUlvbHo5U2h1SFlNK0haMVQrcHJwUTRKOW9qREhGQjgrYVhlbGNkdm1mamN6QzFqSjBKRHl5clk3QlNzYnFhMCs1bGY2MlduTDdiemI1enUyTzgyeC9RUG5Wb3MzbStkNEwxaTBPc1FxWUFiSnU1amZYbVpRZ3BjWVVoVHo5Wm13dm1YMXJuNDhpbzc2eDE4MVNuV1NpSGVsMnBjWDg1NTJPcVNKaFlDSlJnRlBoWGlTSEJGanJNT3BjQjV3WmdRVFlvdmMvbFNpNjdWeUw4VU5JUWFSQWthQWFPeFhoQXRHRjErRGEwZzFLcVV2eWdGbVNXNzNHVnpzMHZiSjl6OTJEU2YvUEZESERyY3dGbklDNkUvOUJTNVVGaVBzeDd4RUJpb2kwSWorREdGVW5YR21nZG9Ua1E4ODd1djBkOU1kdmM3cTZzWFhpcUQ3ZklpN3BIN1hDdXU3MUt4VHdCLzdyWFhBRkc1TDJzT0lGSmw1SmlZaStPSkQ4OU8vL0JyTysxUGRmTThydThKQWJwU0Exa2wvWjVTenlRaWJZRjhRZ2ZVb0w1UWoyK05qZm4xekxsckJoeHZpQ0RWKzVZQndhOThkZXZmSURUdU90cjg0NzJCbmZ2Q00rdXkyYzJYTzRYNnZkTmIyVmZXQnJMZXJNZjFXZFgweHBmMGFwSG5ZQlJCRkhObzZpU25OMi9pbGExbkVldlpXTzN6MHRNWHVmalNLbGxhRnJ4S1Zlbzg3L0VpZUNkNFVUaTUrZzBsMVNPcUJ0Uk0rZS96TEVjSEtYRzlaTE1jR3FFVUE0NDY3ODRKL1VGQmxwUlFFOUc3enlTUkVvaWpOMTBFY3VjcHZPQkV3Q21VVmJTdmRCaEVHWi85bVpPODgxM3pUSTJWUUJZRmhTdUgwTDJVQUJHbk1NYWdjZFNDY2k1NzNBdGpkYUZkQTMzSEhHazc1Wmt2bk1kbWJuZld0RUtDVWhYejh5WXQzRFZ4bXNiQS8rUFA4OW5GV2ZYYkcyMjYxbzRpeDJqeXNpSFFIQStDaVUvTnpuN2djcmYveDgvMSt1TkJGUktEcW9kZ0JDelludkNWRmVRcDdTVkQ2ZlprR0NMV1VmZ2lDSXpXMTVwSTg4MFJKQWZNU3l2SjZ0Lzh0U3UvZk0raCtqZkozRDNkWVZiMEhNOHVEN2hRdmJmeHhIaHQ3SVpqODZaSUEvSTB4ZGtDN3pRNmlFREJnZmdFVCswOHg0Vnp5NXg5NWhLYnl6dlZVNzU4SXVrcXhmUWl1M0p3cndSYkRkRzRxOS9YN2tWMmdyS0ZKKzhQR2RkVmQ5TVlhclc0akVUVlRlc1JVZ2Z0bmtPTEVOVU0yaWhFbDdlajk3NnFBRFZLU29wRktRaFZ5WUw1MUJIVTRETi85aVR2ZU04U0laWWk4eWhkS29ZREFja2N6cFlWZGhDQU5vNlEwb1VsRERXaWhIb2d4TEVpcmh0TWVKQkJQK1BGcjExQnlrR3MzU1RiZ3pmcVRVV3BVb1NSSWN2K2FQcG1ONCtQYzJVNHdLT0kvOWIvZ0FKbFJaVGZNNE92b0NuUXZHOXlZdDk5amViSHovZDZuN25ZNzgrSjkxZXRMa2Z2bzBJVndqY3Vpdnh5VDFpdks2KzlzSVZXYUJTRDNHNE1DMXVvcTl6RU5UZFJPSW9pS2VDOWlIM3F3dkJKNENtKzEzZzQybTRQOGpEV3o4WW1mbXhqYlROY1hOeEhyZEVrVFZQeU5LWGhJdnk1aUNkLzYyV0tZWXFvY25qTWVVRzhJRnFoa0hKYXFBS0FycXBYZWVPdDRqTlFrVWZIRHB3SDhRNXJIWVV1OE5xamphYXdkdmVPODk1UnBKNUI3cEhDbzRlT01OVG9RSmRkNzBEalVIZzhPR0hReTVCYVFLZzF4aGpFZXg3ODBEN3VlWEFHbXdzT3dTaWhGaWx3WmNTS281aStjMWlmSUNoYWtjYUk0SjNEdWxKMlZ3TjhDTG9ab2c4Wkh2cmtjWVlEeTdsblZ4bDU0dXhlVk5tOUthUnEvYUF4ZnlTTjVUdW5KbG1LYXF5bFEvcldLeWN5b25IMzFoc05wVlRqL2JQVE44eEg0Wjg2M2VtKy8rSmdVQmVSM1p2S1Z6ZFRJS2dDWGx1SC83a0w1d0JTNzdrazl2bGJRL05Eem9xMHJYMnBXb0MwZDZIcE5SVkI0T3JzOVFnc3V3dHFydGFVYUtDV1p0WmYzbXgvNitCRTlQcjY2c2FKTkUweFFZQXRjcm83TzN6M084L1RQcjFPa0JtR28wSmNsZUNnaWlJaUNnL2xFeGU2b2xtTGFseEpDbmV3K24rZVViQmlvVG4wSEVJNHJCVFQ0bjJjSmdWaEdJZ1NVVnByYkpIdkFxM0lIVnVyZmNiMk5SRXZHSUVnSytsVkUyaDhvTXRhQlBBZWhnT0xwSTVhUGNRRXdzSk15TTEzTkJIdnNiWVNwb2FRV1kvM2psNG1lRUxFbHhTejA1QTZUMDBIWkdJUjZ4Q3JpWlFtVTQ1SUs1cWhaM1l1NG9HUDNVQTZ0Rng1ZVdNWElJbzNQSERsS3YxYlBwZmkyR0N0eCsvaGZaVldqRTlHdExmK1lEdnREOC9Nb2JUbjlLRFAwSWtxdkZkU1prZ2pnNG9HMERoUXEwMCtPRDcyR001OSt2bU43WHQ2ZVI2RWUraW5qRjBxMjZidzdTMzQvMjdDMDFXV2dvaW9wNGVEYjM5b2ZLTGRGOW41ZXJmN0NtOTB1ZVJhaXlCdkJvbmRRenZ1ZmJxWjBhL2ZQbjNwdFlXN0o1L3N0bmVPSmNORUs1VHFkanE4K054M2VlcWJUNUlYQmFjV0RuQm1hNVdkWVUrOHR4NkZWd3JsQkN0ZU5wVFdsNTNYVjd4VFQ2Y0RkN2JJWlJOb1ZSZHBSOHFIVUpSQnF4QU9CSEI3SUR4QVZ0eFl0L0dzRGhVNkNERUVaWDFpeWlnMTdCY2tnNkxVWFJ0RmdTSlFvRHk0M0NNVnBXU3JpVDg3c0NoUjZGQTR2RlJqdktuSjgvS1NGTDVNQTRuSzRoL3J5YVNQVnhyUmtLV2VaQ2cwYXdxbHBVd2pIUXk5TDU4b3FnUnZNNEM1K1ppNzNuK010SnV4ZmFVNzRuUnpCVDIreHdaSENFTkRFSVE0bDc4aDYxQ1VFdm93MXJ0LzdMM2c3TlYvVTI4RUJLRkNHMFZuKy85OG5QZFVvMEV6Tkp6dko2eW1xVXFkRzlVYW94cXBFV2pkL09EYzdBMEh0Zjc0eFY3dms2OG55VlRxdkFyM2ZGOTdWSWY5Qkg1ekhmNS8vVEp5Wkh2YUlVRk5LWnM2c1M4UEJ0OStzdE5aNW8wR0dkZWthY05la0x4NWc2enNpU1FheUpPMDZMMXlhZVZmSFR4dzVPR2RyWjJqZVpiejNMZWY1YmxubmlYUGM2STRwQlhVM0dHMThFS3hwbC9kNkd4ZlZrZ21Dc1F6OUo3WDhHckZPOSszdVJ1dFM1YXFrN3JYWGtjQld4NHU1OEt6T2Z4bTd1U0VHcVR2YThYbTBhYklmQlJHUmhzdlhxeFNJcmpNWWpOYk5nNjlKaThUS2hRT0s0SW9oVTh0MW5sMHZiUVJTcE9jaVREaTJQNFFMNURiY3RKUnZLSVFoVElsSTJhQ3NqK2tBa0VWaWxCQXBLU2pqVklvUWh4QzVvVGNLbXpoaVFKRnBEVmpkVmpZMytUR0J3L3luWDk3bHJTYkNVcTF2ZUpTZFlVZFZTM1Z6M0lGZ25OT2VjOGJYQnVkRTlyYk9XVWNWa0pGVWh3ODJwU3h5UWhiQ0hIZFNHY3JKUWdWbloyY0tOTGMvZGdCdEZGOC9iY3V2T0dOZjgvME5PTmE4OUtneStVazAxblo0d2oycEZUTmhqR3RqeS9NUFRBRlAvZnlkdnZXelRTTmM1Q1JHZGllZWRuTXdrczkrTndHZkNHRERhNzZpNVhQTEszMVloVFAvZjdPZHZyTm5aMXZGQ0lEdnRkZTZab0R5UGNEeSs0M2VuaW1xYTdzSkdLOUh6RmU2VXVYVnI1N1pQSEtQemwrY2ZrWGQ3WTJXNisrOUJJb2o2NEZzdTRIYWlWdHY3aXgzUCt2TzV2cCtUUm55TlVGbDlXRmNIN1A3OTJlVk83Tm5rbTdzeXBBMzRvc2J3L3paN3VKK2x3cnR1K2ZiTHFIQThVUjU0clFJT1REbkNMSlVYSDViRE1Lc2RhanBLeUdyQzliMWQ0NjdLQ2NhUElleGhjaW1zMmdqQmdLaGxsWm9JZGh3RVJnRUZkSzZJM1JORU9OV1BCR285QTRMMWdQbWRkazFwY09MUjZDVUVpTFVzbnFQZFJxbXNWREUyeWRuT2UxWjY4b3ZLeDdZZU5OUDdzcTE4NjlZVldFZW1PZlJBUUZVbmtMaXdoWExneTl1amdzMDJTRmFLMm8rQXRCS1JyanBZaXpOUmxUcEk0c3RYenpuUS96WDcxOGxxZTZIYlZURkNvdjA2cWdLc1FiQXMxSHBxY1g3eHR2ZmZ4c3Avdlo1N3E5QTg2NVVjbW5TZ1lYWldEbzRidEQrUDFOK09JUUx1MEJocThFc2RGNEVFUS9zclIwcThyU3YvVHQ3WGIvMWFKNGxxditZOWVVeS91L2szbjFzZjJ6MHM3VzZmU1RFZU0xQlBRM1gzcnBYemJyOGFMMnlTZDMwbTU5SngrR20yblBEMnorU3A3Si85QmVTYitMeU40Rk5JNDNHckx0QmNiM2M5dFQzd2NrRVpCYWtYWTdMVjRjWlBZM0k2MGVESTA4SUo2Yms2MjBkZUg1OWY3a1hLUGRISTluYTdXd3JyUXlDaWtMRmNvV3RvamdDNHZ6bmp6M0JOUnhVa2FGS0tRVUtSWVFCQ0ZKcmlueWhNQUtjUU5Db3dpcTUyYm1CRmVsWW9GeTZGQ2g4U2dIUWFCUUtQcUp4M3FOR0lpYkFmTkhKbGkvdEUxbmZYZ0d4VTZsNTl0cmhST0lsQy9ldUZ0RlZlMko4cis5TjVlU2tzaXJmdTlkQ1I2dGxOamMrMi8remtXcE5VSkVSQjVLOTdGeGQ4R0RYL2s2dDQrUDBiYVc1Q280YWhXRjIzaG9jbnovSFkzYXo3L1E3bno4WXJkWFowODRDNjVHak84VzhKVXQrTjBlckZiMWViRW5WUThGb29PMVd1dVRNN01mWE9zUC92aEd2M2M4OGY1LzNWS3NsZzdHMytOQjl0WUN5QzBIeHZuVzZSVXhSb3R6dTFGRWIvZDdhNy96elNmLys5bnA1bS92Rk1PbHBFaVBtbER0K0VKL05lMjRpeURwbXk2WXI2Zy92K2NOL3A1TlEyL1NHb3plazVFZGFGWjl6UWhJQzVGdTRlUzdPSDVkd3lGQmpxeGZHcXp0ckExMzZzMXdYNjJoYjZvMXdodmplbkFzQ3ZVVVdrMHBwWXlvaXVQMklsbGFxSUFKdk1BZzk5UkRUUzFRNUtFaXN4bktxZEp2cTJIS0ZDck4wVjZURklwQ1BIRXNUTlFWdFZDUldjOHdvL3p4UkxBT2JGT3oxZmRzZTBISGl2cFl5TDdqMDhtd2w3K1dEZ3Y3cG9mQXlQZzVIdFVBQjQ2MFd0T3p0VGhKbkt3dEQ3THVUcDd1ZWFnNHF0WFhnRmRxVitGaFJiQWpoaWdaV0pjTXJGZkFOK3FyM0Z5YmwzMVJqYk9Eb1VxdTFoeHhWWXczZjJUZndvbDlnZm5KSjdmYkgxOFpEbXR4MVU0S1MrS3RuOE9MUS9pZExueDFBR3Q3M3VmUmpiN3J6L3V4bWRsYkZvUHc0MmM2blErc0RBZlRVNmp0Vk91djVTTHVUUTlPM3BJQStkelRWeml5T01YYWRsOTJ1a1B2Uy9VbGdPdG1hZEZkU1RkSHJGZlppdk52WHBGc0tZa3JVUXBSU2lHbFB4UktLNmxQQnd3Mml1L0o4ZmI4ZG04Tk9McW9vOTJCbzZneThIQVorQVlRRkxtWUlzOWY2ZTd3QktUTklHQytWdGY3NDVxK05ZajBRVzNVWVZFeUo4aTRLM3hkckZXRkYrMnNFQnRmRG5oNWh4ZE5aQUpFS1ZJckdLMVF4cUNVd2x0TEdFS3JwbWpXaEdaWXBsaVpnMDVhenJORUFVUWFwc2VnRlVNa21tUTdZdUhBcE10VG01Lzk5c3JlM1NxamFGR2JuSXJHLzhUUDN2amd3ZVBqOTVuUUxFV0JtczZzejVQVWJiUzNrOVVzODhNa3NmMWtVTFN2bk91dnZ2WktaN1BiTGpxZG5YekFWUit2M1UxWjRpV241Q2FjdGQ1ZlB0ZGg0SXFScm1xdmUyYmpzYW1wSTR2Ry9JVnY3M1Rlc3pJY0JvMnJHcktpZ05jSDhLdGI4S1cwQkViMkptQ016UFdpazQzRzFBT04xaVBldTU5OHBiMXowM3FlcVFtQlFxdG5MM243d2g3VzlKb3EwUCtkQVhKcGZadmJqaS91R2ppVnZiczMwTUs3NXMzeXhoOTZ0K1pRQ2pFUllvd21NQUYvODcvN05IL2pULzFqQkVnNy82ZWN2N3lKVWZQZkJ5am0rK1RzbzkvM3JHVzkzL092OUh2K0swQTlDSmsxQWZQR3NOOTdsclkyaXh2VDFML2JLQjhXdGt5TklsTlN2SVd6cFlWZVpjQ2dLL01JNjRVSVJUOFRJbE15RUlLbkdZRVR4VENIWWFGUXFteFFPcU9Zbk5LY3VLbEdvS1U1SEl6ZDlKcGEvVDBSMlRzTEVkN3owT3pTeHo1NzdJZjNIUjM3cERKbVg2UUR3TkxFSThEQ1Vvd3ZJMFB1dk0rTTkzM3h2dFByRmErdlhCcStkdmxDOHRybEM0UHpyNS9wclM1ZkhIYTR1b1EwQTNKWGVMdTVOblNxRER0NkQxdFYvOGpTdmtPUGpJLy9oWC81K3NWM2I2U3BHUytmUGxMQXhoQSt0MU9tVXVla1RMT0xQY1RLNk91RSs4S29kZTlZNjlTU0NYN2szSEQ0eUpWa09LTzhsenBnbE5yc3dHOXVldG5tR2h5VTRqOUUxakE5M2dDdjhDS3FtNlJLeEt1eVhFUy9TWW5wcVJyY1ZhR0lNbFVUekdpTUxsc3M2YkQ0Zy9nWjN2ei8xOStuZmhrQkpYalR4eU4rdjM3ZmV3NDgvUEdmUFBHZlRVM3E4ZkZhcWV0U29rZ0t3U3BWY2thcVhOSGdQZlF6aTdZT1pYUTFrYWdZcTBFekxPMkVDZ2U5SE5ZSEpWQzBDR0toOE9DdHA5L3p2UFpLLy9rdi9lclp2N3Qrb1hNUktKUlM4b2tmTzN6cmV6OTg0R2RxWS9FOXVaZkEybEpRRTRlNmxNdW8wbXBWbGVwWUZFSVVRQndJb1JZUndWa3ZXYmRqMTdZMjg5UG56eWZmK3YzUFgvblM2NiswbHl1Z0RQWTg5YW11UlExb0hXMjFabjVrWWY1blg5emErdWt6N1U1VUswT0JzL0N0VGZobnkvQXRYMzUrL2liR01RQ0M4U0JvUERvNWVmUndFSHhzWlppODUrSndzTlJ6VHNlbGY2MDBJTTIwK1Y5ZUVmbWZodUkzZ2Y2ZTFPeWFTckgrdmZZekpGbkJPMjY1RVkyaDNSK0k5UjdVbTU3cVpiOWpWR05JRUVJY2c4MHBaZkJXc0lYSEZ2NFBCT1hxalZIRmZ4OFNZRzhrMjd1WU05L3o5Tkp4TGRDSGJwcCtkSHc4bUtvRlphL0JHRlhSdnVWckxKckdBWjFoUnBxNGt0b05OR0ZRMnBubWJqUjdVaFlGaFJXMFVpUldrZVhsenc1Q1BTd0wvZVpZT05XWXJEVXV2dFk1cjcxRWYvSS9PZm11ZDN4dzZXZWJFL0Z0Um1rVGFnaTFveDZVKzFNaVUrcHNQSnJDS1RLcnNOVTJiZVhMZm9oNE5LSWlZOHlVcVljM05DZnI5eThjbkRqYWJSZVh0bGFIM1RjOVFIUWxPbXdFV2pkKzdNRCs5MTNwZEgvK3pFNTdMQWFwZzAzZ2R5N0IvN2dPejh0VkcxYS9KMkpFMDNIY2V2Zk05TTJQVDA1OXNzanpQM211MzMvMzVXUTRtVHVIQmxVOWliSUM5YXNYRkwvY0ZiOVZFVDNadGRZZy9BOENDTURoK2RuS21LQ1BFdzgxVU9XRFRZelJvbzBTcFZYWk9hOXVGcVZLUnVnUEtReUtNa2lnRURTaWRObjYyQU1ldXljOUd3RklKWU1pTzNoeSt0amtYUDJXS1BCbHRXd1VhUTc5ekNOb2pBcEwxeElSOHJSVUp6WHFpa1pGNmFTNTdMclFsNnNZU2k4djU2RTNGREtoa3RxVXdJdU1Ncld4Nk1oOHZUN3oyTU16aHgvODhOS1BFNFFIMDBLVTBaWGVTNWRxWVcwTWNXQUlxeVZENHN2K2kwSkdCcVlvUVhsUlNwekNPWEJXVVZnVnFpZzRObmQ0NHM2cGZVMjVmS1o5MFpmcjRrWlJOQVlhajgzTkhBeXQvY1ZYdHJadkRMd25oTTB1L01wNStNZDlXRlhnMU5WaHBnQ0lieHByVFg5Z2Z1NmVPOGRhUDZxZCs5a1h0cmJmZVhrNDNEY3NDcTFGMEtXNU13cldVL2lWQzZqL3BTMnlYRVd4dlVVOWJ4dUFuRi9iWUtQYkxjRlJWUVZLOWhRSmNsVVNJUlgvNy80d1pVVlZraWZWNjhqTnNMTmVmbXZHN05FOHFkMm9BNkNkOVdwc3BxNm5GNXNQbVZEWG8ycjFXK1pBU1lCemltNmFZQlJvcnhtbUJZMmFZclpsYU1ZbHBWdXZLYUxBRUJpRFVoQUhoa0FyUWlVWVU2WnB6bXN5cHlpOHdualA0cm5DM0xKUVA3TDA4T1F0UmFCYVJpREpJWGNLcFRWT05QbElvVlhSMUlGU2FHWFF5aE1nYUR4YWxVMUxxWGpnVWZhanFtWm1FQWN6RTdQMXU2ZjNOV1ZuZmJnODdCVnUxQXhzQm1ic00zTUxuMzF4WitjaldaWUZFUXphOEk5ZmczOWRsRGV6QnlSVVN1MkxvdkU3VzYyamo4OU12M05mRVB6WUlNOS85TFYyNTZIejNlNTRacTNSVmM1ZHZUSUh6L2ZnLzMwZWZqV0ZVZVJJOXhBSjErUWluVCs0RlZqeXBvLzMzSnpYd21sdnZFRW91M3UwWWVRWnZVdXhKdjJpbUQ4OGNYdllDQStGa2NKb2pmT0t3a0tCSWd3Q21uR05KSEY0NzVpZDBEVGljcnkzSGtJalZnUzZyRlZ5cHdoVVZQWklmR214R3BwU09helFlQS83djUweGc1QS9YTmV1cG93U1JhZ2dGNDFIa3pyQmlzS2p5VjNwZ0MraVM2Qkp5WlJvVlVZUkoyVUtXM28rNkYxbkYxZFY0WlZnTFI2YnJ0KytjR0JzYm5ONWNIN1F6VkZRKy9FREIrL1FSZkd6WjNmYTB4RU0ra3I5eG1uNExRK1pSc25oZWoyK1oycHkvNzJONW51T2g5R1BpSE9mdlREb2YrRHlNTGxsdVQ4WXk2eFZZWFVScGN5N3hFQzdELzlpRGY1ZmEvQnRLU1UxZlVvMWZMNUhQWEZORGhnSC9BQ2UwUnhTR0VPUmdWSks1Q29YbjIrdEREWXVuZWwrWVdLNmRrYzlpbHA0d1NJVVVxcUFveEFTVjVDTHcxUWp5RW5oYVNxb2haclE2TW9DeUpGWlRYdVk0OFZqdE1JNUlhRHN3TWRTWi82N1hjYXY1R3grb29VS2RlbldvRFdaRTVRRzd4UjVWYUNIcHF5SEJ0VWdXVUJKQWdSS2xYUTBaYlN4WGlnc2lKTnl1TDFLUXBVcU4yLzVBTVRUMkhkbzdLT1BmdlI0NHl1Zk8vc3JiajF2anl2MWdaZmI3ZjNldTd5ajFHOWVVZnEzajhWaDYyaXRkblJjNjRNQ04xbnhKNjRrNmVKcWtrWmVST25xNmFMM0FLT0Nacy9DMTdiaGMydndsSVYyQllwa1JBNG84S2FVclYyenZ2YUdIK0RqcTZ4M1lxNmhpdFN5aDRrTHVwdHBlK0hneE8yMVpuUkFxcWUwS3dTdk5Fb3JRaDJpZllDdDFrREhzYVlSYXNMQUVPcUFRSmV1aW5taEdXYVd0QkN5VEdoM1lHTlQyR2dMVXk4bUhQdEtoNDEzMTFISGE4VEc0RVF6eklYQ1V4WGc1VnkrVUJvK0dsMjZHSWJWS0xHdk5vajZvaVFDUk1BNlJlN0t5SUVJcWEyaVNOV0dHeGxkV0NlNk5SWWZiazQzNWxwYkxoMGJ1TWZQOWJvenhwaFhKNXF0WjAvVjYvZk9hZk9odnJXUGIrYjVZOHZKOE1UbC9uQ3lXeFRHbEl5VXFxaEJVVmZyakVFT1R3L2hIMStCZjdRRkwzam83b2thdStCUUlIV1V2SWVJczlkbUNmS0REWkJkMm5xeFJWTDY3ZTdTd1ZsUzJPWjRISTFQMSs4M1JvVmxUYTNKL1dpa1Y2T3RRcnpGQkREWjFOUWpqVWpwR2w5Tys0WW9Jam9EeDA1YjJGaUhuYmJRNnp1V1hrMTQ4T3REaWdsTisvRVc5VlpBYWcyRFRDRVNJQ3BnV0RqU290UnhLQUZGdVE0N3FNenJ0Q3JuN2lORDVkcFlqZ09MS0F5Nm5QVDBpcXlBckNqSmc5eUMzUU1ZOGFLYkU5R0I4ZkhheWZUMTd1S1lNbVp1ckNWSlVkeTFuQ1IzWGM3U3BVNmV0NGJXYXVjRkF6NG9JMjFBUlY4RlplRytidUU3ZmZoSHEvRExtL0JrVWRZYWd6M0ZlQTVZRGI2SllnRXRDYkNLNTFyZHpoaGNoMGNaU1NxWnVLL1NyQlNJVHorNzlxV3ArY1o3VVJQdkxJcUFxQ2FvVUpOcmpYY1pLbkdZQ09wUkdWV3NveG9kOWdSYUkrSW9DazgrckxPeTNpZlBISTBNN244bDQ0WlhFcHFaSnAwdG0rYTVyWkhsNVQ2Uk1DaHZiaVdhV0N0aUpRU3F0RGd0bk9COFdZeHJYZjY1Rm8xMXZodzlWcFg4VXlpTndRVVFUMkU5YVQ2YXh5bUZUMW9wQXFOUjRvMDYwamhRUERqRDhwY3VzYlc1dFpDWGVpc0p5anBDeWRVbTArc3AvSmFDeFJpT2UrZ1c4RUlibnVuQ3E4bFY1ZTZvS2JtN0pYZ1VOV0tRQ09FNGhvdGMyd2JkMXlNSVVBdzlRYXhLRHg3WnM5c2l0VFlJVFJJM29qdEY2WEVSUVZXbWNNcDVYT0hRa1dKNlhOT3FkaVI2RVl3cWkyL3JoRFNOdUxUdXNjNFRhczI5VHcrNTZidERnbHh3U29pRGtNNWlRSGN5Sk0wODFwY3NsNGdpVW9aUWxWSVZWV1YvdVpWeVloRklDa1ZhUUpKWGZ5WWxaelFTVGVMTDc2bHdZQXVOZHdyckJHZEJmUGx2ZFZVMEtBRTFHVE1Rb1gyNVcrYVVJQjRTVmRvRHJDczRuY0N2WElMZjZNTFhIWHlsRFo5Zmh0OGZ3RmtMTzFVYU5kaWJUbzNBTVZHbFk2T2hvbGU0OXYySHJ3TUVjTTZ4Y0dRQ1o3MnkyUnZlTkwyOU5salhSaGR4STd6RGFCTXJyWlN1R25VYXhYalRNRDhWVURNbGN6VmlyN3dIcldMYTNaQnUzMkdCVTJkVGJuMm1EOVpYWFV6QllJaFhIYjA1aFp1TWlGUlFXaE5SUnFNUnNJeldwYXlsV2p6a2ZVVUQyOUx3UW54cGR5cStxaldrR2srV3NoZFNGRkttWElYSDVsSld4aFY1cHlodGxyeUZ4blNkTlBmRHJiWCtNMDc0MWhCK0k0SFBEK0JYTy9Eck8vQmRLZXVKWGdwcmVRbUtFV1U3M0FNTXE4Q1pQUlR1ZmtyUjFtaXUrNjF3cmdPa09tUFRkYnFiQ2ZKR3F4MEYwTmtjWGdwQ0hVVzE4RVlUNk5qb2N0Rm9wRFVUWTRiWkNWTjF4U3ZiSVZPcVdISWIwZTRxVXErWTN5eTQ1NGsyUlRmSHEwb3Q2RHhKVm1CNmpsWVcwcDhOc0ExRFZEbEd4a0VMTllvSW50SThXd21CcmlLQks3M0VqQW9JVkVCaHkvMml2bW9ZbG1sV2FVeFJBa3R3UlduYkdPU3EycDlZMGtoS1JnVytJSkVaN3FUMmY3dThsZnhHQWkrazhFb0dsd3JZcnNBeEFzUWJ0RjI4YWRaSGdkUkFKcmpxY0hLWU1nZmpPa0RlV3FlM25XSUNqYk5YUGFCRzNMejM0bmZXaG1mRXVXRllDMDRHb1drWVkyaEVocW1wa0ltR0xqVlFvYXAwVVliQ2FmckRnR0Z1Q0V6Q3pkL3RNblV1SjNPT2JwNnpjbWlKK2Z2dklsdGV4ZWNGTTZwSnVBUDV5UW5xWXpOWUM0TXNKUzBLckhNVXpwYXBtd1RrdVMxZFlhU1NsVWdaYWF5VjBxT3JvckpWdFk0Qk5MN3F3M2dQUm11c2xNVjZPVFFHbW9EY09mbzdHYjN0SkE1QzNkN2VUTDVoQzkrcEdLaTl3TWlBVEpWc1ZLSEx3dHZxa3JiMXVrek5kc1ZaVko4d2VJdUI0enBBdnFkWUY2b0p2RGUzUGhFdnNyTSt2SkFQOHlTc0JUZWJPS3czV3dFSEZwbzBHNHJJK0lwbU5XUUY5Rk5EYmhXbWxqSXVPY2Ura1JOMVBjNTUrbG5LNWczSHVQLy8vcmVRemc3ZDc3eklJTTB4V3lsNUw2TjNxQVZLa2VZT1ExU09DVHVIRTEzdWxjOGRvVGJWMkdFNUdweG12a3lwbEFJcGF4V0RwaVllVzFtNFN0Vk5GeXRrMVZKNThRcG55eDBweWREU1hVL0lobFlGY2VEeTNEM1IzVWxIa3BBaGtDcWxDcVhLbWdMd1VSa2hmRmw0STQwS1NhTXpHaHA2cTU3ckFIblRVVXB4NzkwbmFYY0cyS3NyMEVaSzRMRFh6alo2N2FTZFovYmc3TDc2K0xIRFkycXNvZENxN0hZN3IwZ0xUWlliSk1oUWdhVzI2Vmg4TW9lMHZORUhlVTV4NmladS85U1BFTmZyckh6aHl3eVRCSEdleVE0TWpkQ2JxMlBRS0ZYMlU3eFhGRmFRd3BiejhMN1VkaFZlU1BMU0xHOWs5VnBHRmFxMERKd3ZheUp2WlJkVTFwZHo3YjVLMC9LMFlOak82TGRUUUlocVVaWVgvb25ObGQ1RlZKbE9hYTNzeEV4ZEdsNncxb3ZqNm5qblhzT0M5RzEwUDF5bmVkOGNSYnp3L0F2bnliSTNPUER2alNaMnFqNzE2b0g2M01XZFM4bkJjdFJiVjd0SlNqR21JY0lFWmRHczBLaEFVZURSZVdtd0hhQVlIeDhqaUVJMkQ0elJXWWhvZE10OWlBYkYwdGMzS1FKTjk3WXBBaDJWWTdwMmdQS09XSWZsa2lEcnliMVFJQlNGVUJQQktZMjNwVU9rcGt5bGt0SGdaaVhSMUtLd1VwSUFXb1FrZDRnVmtrNUJmeXZGRlE2bElZeWlPSXlpUnRsaEtkZG9lUzlNVE5lbEpVSTN0Y1I3Q3BDMzY3a09rRGVkL2Z0bldWN2VRa1QyRGxzRlFHaU1Oai81WSsrLzQrNDdqdjVFbGd4dVd1OHRxeWdJS3NPR0FrU2h4S0F3SkQ2bkZta0NJK1RqaHY2VW9ublo0VFdNUnhIcXlqTGI2NnY4cjRPdk0zM1hCTGVjNitDOUo4OXlJaCt3LzhrZDhsalR2V0VjWDNoVXRTaklXaUYzSGwvMU1iU0hRR21zZUp4MWpGd2VuQmRzb0NtOHgvdXlMNk5RaUN2blBBdFhtZmI1MGppdnR6RWtTNHJ5YXlxTlJzZmErbnFGSTYwVTJnUWFVWWF0MUY1N3U5S3VwMWovY2MvZGR4NmdYZ3U1ZUdtTEtBcHh6dS9kMjlnNGRmTEEzTS85OUFjL2NzdXBnejhuUHIvSnVpS1lYZ3lZUFJpaGxjZjZIR3MxaXJBY3RjMEtvckJNYlRJVXJYTUZ6U3NaVmp4b2plcjB1RHhwK1BYb1ZYcFByTFB2d2c0dHJhdDZ3Qk1WQ3RPMzdNeUh1RmlCOStSWlFaNTdVdXNwQ2wvTzFSU3k2M0dzVUxocWpVUlFPYmFVSysvSzZHR2RsTkhJYVpLa0lNOGNOdkZzci9ZWmRKT3JZd05HVVkraU1Gb1pYcnF5Mlh2YVhRMFVidGhOcFp2YUg1ajc0anBBZ0NpS1dObzN4aUFwNlBkejViM1hJakt5Mld6Y2U5ZUovWC82VDd6dkZ4YjNUZjNFWU5oYmJMZTNLSXFjaVNYRjJGU0FzMzJzRlpLODdING5oYkNUT0JxeEpzMkVRaUN5aXRuekhwZlp5djZ4WVB2bGwzbDVLZWNiejV4bTluTEtqWEc5R2hFc25SYkdKSVNOaE01Q1NCRUllZVlvcXJHaUloZUszSmJqdlZLNkxzcklmYkZTVVplMWlNRlZESmV0Nm8yaThCUzVvOWZPMkZrYmtIUlN2Qis1WDRJS0RYRVVxM0M1UDl4b0Q3K1lJRDBnMXlqcm5KY2ZwSHZqT2tDQWd3ZkdPUFBhRnYxK3BxejF5bnNabVJjMGdQcFlLN3J2MFA3Slh3Z0RtZTUxTzlqQzRpaVlQMXJEUkJieFdWbC8yTEtlNzJYQzlyQ2dXZE1ZQmFGWDVDMUZhOWtTYmxreUJLdWdPU3hZdWp3a09UYk9sYnNtdU9sS1Jpc3ZuVk9zMFhnUm1nbTRYczdtWkNseEtYSlh1c3c3ai9hK0dnbXVPbkc2N0dlb2F2N0RPY0hvRUZHQ3N4YURCaEd5M05Gdlo3UlgraVRkbEtJb2tHb252RFlhRXdib3JTRnM1ZCsrbUdSZnlzVVBnVXdwWmVVdHNEZnhPa0QrQU0rakQ5MU1wOXVsMDhsVVViaGR0b3BxSVF3dzJlNE00a3VYMW02eFJYcGdmQ3dHb0RsdW1ENFVJR1FnSHVzVTNpbVUwblJ6enlDenRHcUtlbFNDaEhyQU1MWFVYeDZXUzRQS3hTRFVObk9PYkZ2TzNqUk9ITFk0ZExtUEdFVWhaYkZ0cmFPK2xlT0dscTJHSnRWU3lWdzhWTVcySFMycDBhV216RmxmV1ExNUNsc2d2dEtiT2NIbWpteFkwRjRmME5zZVlxM0RGNVpBNjFJWmJCUnFhNGc1c3lYZGZ2YTdsN3g5UmtUU1BRRHhEelJhWENueTZ3RDVRVGkzM255WVYwOHZxOEo2SlNKN3JUWWJZV0RHd2xEUDF1SmdYc1Fldm54NTY2UjFUdTJiYjNIOHhrbjBXRUhwZkNRNFg4NkZPNlhvSk9XK0VhMDlZVkNDSmkrRVFRak55em5OUWJsZ0kzT2VYTU5ZcnJqbDlZTHRnV1hRNlZFekJxOFZ1aEluRnM3UmFGdG10d3NDSTJRYU1oRUtFYXgzZUZXQktmZWxJN3lVYStqRVFldzllZUhJbmVBS2o4OGN3MDVLWjcxUGx1U01oZzZOTWVqRU10N09tVnhOVWNPQ0ZKNWNFZitkYWdZOUV5Z0NwV1ErQ0ZuNWp6RTdmWjNGdXJiT0xhZVd1SEJ4SGVmWW0xYlZnTmJCcFltampTWS9rcVhaSGJWYWJWOW9aR21RcE9xNUZ5N3owQU1uT0hMREdKZTY2emp2Q0lPeVQrR3ExTWI2Y203RGUraWxsbWFreVFxaEdETnNQakxCekwvdVVQUnpVSXBJU3NPSHB2VWMyZTV6UVVGTHlyM3VvMDBaaFFoNVZtQXVGOXk0bFhQejBoakpXRUFuY093WVI2OEd3NlloRHhTaUxKRUZyTWRKNmZodExiU3hESDFWdEhjeXdvRmx5bW1VMXJRa1lxd0hkbU9JVHkyWnM0UUt4azB3YmJ5TFBMSnJwYVRBRnlJY3c4aTVhM1NHNHpwQS9vRE9xWk5ML1A3WFhsVkptcXU5UmZtTk55ek8vZkNIYi91Wks2dHJQL0xhK2RXZzNVbFViZ3RVb0xqejlqays4VU9IMldGWVByMjlvTHluc0FycnphNFJnMWFsVmlxemduaGJqZHBxZXFmcVhMbVFzZkNrcHg2WVhRZUp3bnNtZ3hyanRSck9PYnpTSks3MDNLcW15ckVhdXM0VHJ3NEpOZzNUWHBqSUxVTnZrVmFNcndlb1VCTm1Ickd1Tk5OMjVmZXpsU1cwWFVaWExMUGVnMWU0UWtoOGp2RlFwQVc5SktHVXVRdE5iVlN6RnUyTGxXc1dXZDZ0N2hWdFJkU0ZMSlVaRkxVb0pNMkw2d0I1dTU0akIvZngyK2tMYW0vZEVSamQrUEQ3YjM3M3duempnODNtZkhody82UnNiSFE0ZjJtVFlacno1My8rWVk2Zm5PQ2JaeFBDMHNJRmp5OVRHTzhKZGJtU1Roc3BiVjY4MEU4c1kvV1FlbFRxb3Jydm1tQzZEYlZYaHRBTXFkVmo4aVFqendwMFlWR2h3UXJnRkxrdnphOWtaQkh0UEtuTFVDZ0s1OGdyUTErM2tWMWRHMTA1VVZnbFpONlRPMGVXRi9TTG5QVXNwZTBzdVZLbEpGNThPUzRyWlpHdUtCdU1Da1Z0ckg3M3FVT3pkejMxd210YlZXVE5CRnhQdkdSS1MwdnB0MVhYL0hvTlVwMm52L0IzZU9YTU1sLzg2c3VxMXgxcTd5VlVxclQ0ZitjakoyOTQ4TDZEdjVUbnhaRlNHVnVvUmlOa1lXR1NqMy93Tmo3MFE4ZXB4WTZaaVpqREN6TWNYcGhqMy9RVVkzRWRyY3IxMWUyaEJlMW9CTlhXWGlzNEZQVzRqREE2VlBUR05jMFZSOXkxR0YwS0Q4V1dIbHNtTE5XOGFlSElmR21zYlN2cXR4QW9SbHIxMG5TWHpIc1NheG02Z2x6SytmbE1DUU5yU2F3dFRlWVFjdS9ZempONjN1SEY3NjYrTTN1OC9xUUNTR2dNcjl1aVhsdVluaHB2MWwvWTJPN3VNUEwvQmU4MVlyVWlNQ1dOZkQyQ3ZJM080WU96Ykc3MTJOenFLTys5QVVJUmF2VmExSHozTys1NGY3MWV2OUc1dmtTeFVkYm1GS2xuYVdHS3g5NXhnbHFRZ0dSTXhkWG9uZzRoYkhKMGJvWkJMcXh0N1BDVmw2OXdmbWVIdkdwQnh4cThjeVJKd2ZSNEE2TVUzU053L2lQVDNQeUZJWEt4aDZjMFlYQkN5VUtoQ0pWQ2k2S2FEaWs3N2Q3UkxTd2VtQXFqa2hLMmptR2VWZnNPUEpFT3kzNkk4MUE0WE9CUjFwRVhCWVBSVWgvMm1oeVh3L2hoNVNhT1VuZ0ZLOE9FZUczcjdpTkw4eCtxMWFLTGFabFBXY0NKRnltczg5NTdPWFZpaVpmUExGK1BJRytYYzl2TmgzbnFPNitwbGJXMkZybTZJT2FENzczdGxqdHZXZnpaSkIzdUd3NEdLa3VIV0Z2UWFOVDU0QWZ1NU9oU2hocXNRSzhIM1RiMDJqRG9nMWdVbGlnd1RFK05NeXpnektWTm5LMGNTUVIwSllZUzhZU0JRU3RvTnp6ZE9ZUHVlR3I5Y2wraTliNGFmdklVbE0wOUw2T3R1bVhVNkR2TDY4bUFsU3psaWkrWVBIVWplbW1PaTJaQTJteHd0cGZ3YXIvTHprMFRiTDNuQ0IvNTBUL05EWGZjeTdtZExhNXNiRERheGpPeVZyUVZPS3BBaGdFNndPdmVzek5JOWVSWTQ4REJmVE92WFY3ZHVzSWI5bmlJakxYcWpJL1YyZHp1WFFmSTIrVzhjbmFaOHhmV2RWRzRFYTNick5maThVLzgwSjBmaXlQNVFKS2t4bnRCOEJSRndkMzMzc0pEOTAralY1NUJ0cmZ3L1FUSlV2QzJ0TlloUWpJTGFRZWxDbnFwNWVsWHR4ajBQRmttNVpvM1Y1YmFXZTVJQzBlekZoSW9UN2Z1V1Y0eUZCWmFsMU93SHFYTCtpQ3hqbHdKWHBYUzlReGZybGxRaHZFNEpqQWFyelhISDN5QUczN3FVL3phUTBQc2JmdDQ0ZmsxenNjRnF6OTJsTWI3N3VRdmYrUVh1UE05SCtEbXh4N0REd2FjZitrbGJMVUE1ODFteWhhSVdqVzJGeWRZN1piNzU5TXNieTdPVFV4cnBaOXQ5NGE5VWFxbHdFZFJJR1BOR3BzNy9lc0FlVHVjNDBmbmFMZFQxZWtPdEloRVZlM1Irc2pqZDkxNjY2bkZueHNNKy9QT2xjczZyYlZNVFl6ejN2ZmR5bFQyTW03dEVqWXI4TDQwU0xDaThkYVZ2RzVlUURxRUlpTXZFcDYvbUxHeG1yRzVQQ0JOaFZ3MHVTL253WWVKcFQrMFJFWVRoeEEwRFozOUFkdmpoc0Jxd2s2Qnp4eWl5bzU3NmJ0dzFZMVBLYzFZRURBVGhrenJnT1RNYTJ3Lzh6eHFzMHQzSWtOdUdVTzkveUR4c1VQOCtScyt5VHZuYnFYb2RwR3RUVjc4L0cveC9LdXZRbW5iczV0cVVRRkVBa1B0dG9NTXgycXNMMjlYVnFxRjhpS0xOeHhlcEQ5TVh4Z21XVnFCeEZycnBEL014TnEzSitYN0ExZURLS1hZYnZlUWt0c1BSS2hGVWRpNDk4N2o3M0hPSGk5eWk2ZVVjM2pudU9QZUV5eE9iR1BQWFNCUFNnTTNGWlE3UTF5VnphdXNTeGlGYUJTU1pzd0dpdjBOT0pkNk5sL3YwT2tNbUQ0OHdkU0JDY2FhSWJWWU1UQ2VUcnRnZnE3R3Z0a2F3YmhsODU0YXk4Y2k1bDRLV1hpbXovaDZqczV6Tk9CVWFlWGp0U0RlVXpoUFZEVVV2UmZjbFRXT25MY2NlQ0prY0tpSlcyaHlZbkdXVzE5N2thZmNpN3owOUZNODgreDNlUEgxQzNqbmRwK01WODFKUVVLTld4cURBMU5rNXphcXFGZWUxYzFPTUQ4OThjbFR4L2UvdXRQcC81cDFQZ2R5NzhVbmFTNk5aaXpEUVhZZElHL2w4MS84OVkveHIzLzd1VXFNdUx2ek83cmoxa09MWTJQNkhjUEIwT2lxb0xhMllIeXN4YW5EQVdyNU9mTCtFTy9LaVR5Y3g2b3lCVU1NU212RU9yUXhhSzBJVk1CU0hjS2FabnQ3d01hbG5LbXhGc3Y5TFNiMnRaaWFxZE9zYTZ5Qks4c0p3NzR3TnFGcDFoVFJsR2J6N2hvYit3Tm1YeHd5ZFRxbHRtMUpCaWs1WUl5bXdPTzhRMm1GMWhwbERGNkQwd0VxYzB5ODBpVTQzYWZMR3Avelg2Ulg1S3drQTdhZEs5MFZLVjNyMmJPanZvZzF3NFVHek5TWUZDRWRsamU3Vm1WMzBGckhtZGVYeHhkbm14K0tRdjBGNi94b0p0MXFyZnhFb3k1b3o3RDM5dXFML01Da1dQZmVjWXpUWnk5eityVU5uZVhXVUxtWk54clJ4RS85NkNNLzBxaWJ4L3Y5WVdoZGdTMHlraVRqcHB0bXVYdDJDN3UxaHBkU2ErV3JTYnlSMXk3VjVnZXhvMVVPWlRkQmE4MUxiYytsQzExcXdTUi8vWmYrSmd0VEIzanl5YWV4V0tJb1JGRWF2ZlVHQmQyZUpTK0V5R2hxa1NJY04zUVBSbXdkak9oUGhQaW9XamFTT3F6MUtGODZLMnFqTVhHQUZVOXVMY3BvbkJHc0VnYmljRURYRmd5ZHc2dVMwalhWZDRsV0ZMR21QeG5TbmEzQldJMW1xMGxqck1ISzVTMTZuYVFFa3FyVXdjN2hYZEVwbkh6Tk91a3hjbVVYZkpvWFlpSk5jNnpHbHpmL0N2L2diejl4UFlLOFZjNzg3QmdYTHErenNkVkhhNldxNkJFQzBmMTNIZDAvTXozMm5qVE42b1cxMkNLbnlETENRSFA3MFFqZHYwemh5elVEZWVHcXNWV0ZJT2hBSWNwWE4wODF3dXJMTWRhRk9PVGtiTUR5WFV1OCt1UXkzM3o2YWY3U1gvcS9NZGFhNHBmLzJmOUlOdGhtYm5FTUUyclFHbGRvdlBVTXVnV05wbUZpd2pCZU14U0xFZDJaZ08xYmFyRGFoT1dFMm9XVTJtYk8yTUF4WmlKUTVjQ1dRMlBDc0dTK3ZNUDVjZ2R0M1FTTTZZQlFDVU10REpSajJBaklhNFpocEFqcU5RSU5ZYWpSV3BObk9iV21ZWGFwaGJkQ05zeXhtVVVoREROM0lnaUM5MnJ0VjcyWEJDZ0VySFhlRzZlWm5LMi9yZFMrYjJ1QXZQT09nN3g2Y1p0YXJWd0ZIWWFCc3RhT2xtUkdZUmpVSDc3LzFLUE8yUnM3M1Ixc2tlRXFsZXFEOXgvZ2FLdEhzWjFCMVIzM3J1d2hlQ2xCb0N1UlgrazZXTTJDNXc0bFVBODFKMnFPVnhjYkZMZlBrc3NBdlBEVFAvMnpUSXhQODNmKzYvK0Mzdm9LQzRlbkNac2hlYUJKSTBNVUtubzlhRzlybW8yQWVsMFQxQXhCWFZNY2lVa1BSR3plT29Za25uZ3JaNnduaEZ1V1lBdGs2TWg5R2NWczVhYTRrNmQwb3pxNWorZ1pJYTFwQ2dXRUFRWkZ2WktLZVBGWTc4bXlqTUZxZ2piQzR1Rko2bzJvOHY2MStHRkdiM3RZMzlsSlB1REZQREZJN01paHZSQVJLVEpuNDFxZ0htejhiYmtPa0d2OC9KT2ZmNXphZEowLyt6LytIdXViUFNXQ3N0YnBhcVZ5RE5RUEg1aVptWnFNM2pzWTltdldGbGliNDYzbDJMRTVIcjJsQnB0WDhPV3VnWElxenlpcXBUT2xqeFJseERDTWV0QlZzV3NkK1NEalJNMHpNY3c1Y3NNa2dWdGpkZnQxWm1hbStlRlBmWXFGK1FYKzIvL3U3L0w4TTg4d2QyaU01bVNESURZWVU4NWsxR05EdjF1T3dFYVJKcW9ab3JwQjF3eWhVYmltcG1qV1dMY2VsNFg0SkNZYk9tem04TU9DSW5NUUdmQk5uQ3E5dWhvZTRzSlI1QVVVcGJvMzZZRXRITTU2ckhYa2FaOWVQNk0xMFFCUmVBZTFWa1JqdG9VSkZJMzFMdWxMYXllOHl6OHdUTGdpZXpaME9ldmx6UE5yYmtTR2lMejFjZksyclVGZVdkbmhIMy81WmRVWlpEcTNYanZualloRVZHcGRvUFh1ZDl4MDMveGMvWThsYVZMUDhneHhEdTg5NzNubkFZN0UyK1RkZnJtV3hrSGhLbWxHUmZzb0JlWDZwekt2bDNKblk3bVhvK3A3TkVLRjd5Zjgva3Q5NWc0YkxxMi9TS0NiekU0dWNlTEVTZTY1ODE1ZVAzMkpiMy9yUlhiVzI2VDlsR0UvSngwVURQc1p3MzVPTXJTa1EwdXZtOVByRktSOVM5S3pKSDJMNUI2S2NzV0JydlkrKzBxM1ZUbVBFc1FCWWFnSkFsUFpFa2s1bG1zZCtiREE1WTZpc09SNXdXQ1FzcjJlTUJnV1JJMlE1a1NkMWxTRDhla2FyZWthamVtWXNZVVc0d3Zqd2N4MDg5QlV2Ym04c3Q2OXlOV05YZFZTb3BJQldEdzJ4YzBQSHVUSzJlM3JBTG1XemszN3BuaDF0YTJ5d2ludlJjdlY5Y29qY0l6WDYrSFU0Kzg5OVluQXFIdlRKTlBPT214aE9YeWd4ZnZ2Q3REOW5YTDRTQVNIWFBXVTh1WE5xRlM1UFV1Wk1wcDRYNW9ncU1vaVZ5aHRldlpQQmx4K3ZjdVh2NzNENUp4bmVlczVYcjkwRnVVaWJqaDJFKzk0NkdIRzZ1TnNYTmxtWTduRDl0bzJuYzBlM2UwaDdjMEJ2ZTBCM1haQ3Y1T1E5RElHdmF3MGQ5dEs2VzRrdE5jR2RGWUhkRGFHOUxhSEpQME1hMHZYRTV0N2lzeVM5RE9TZmthL25iQzkwYU83UFdEWVNjbUdPYjFlbjI0L29kdE42RzRYcEVNaHJJY2N2bldSbzNmc1krYlFPR01MRGNhbTZ0VEdRb0pRMFpxS21kNC8zcHFkSGx0cWJ3K2Y2K3drUGZidWhsU0lFcWkxWXFiM3RZakhhdXlzOUs0RDVGbzVXaW1HdVZXK2xMRHZwbFJBUXlzMWJyU2VYWndmUDNidlhZYytnY2hpbm1kQWxVWVZBeDQ4bklNdDdYQzhMNEZnQW9PdkZ0bm9hdTREcW1VODFSSTNyUlRWVk91bzZZTFNpcHYyMS9qNlUxdjg3cGRYbUJnUGFVd05lZlgxNzdDMTJXYmYvRkZ1di9WMmJqcCtncm1KS1NJaWxOV2t3NXhzV05Eclp2UTdHY1Aya0g1N1FIZG53S0F6M1BOSzZPME02TzhNNlcwTzZHd1A2RzhQNkczMjZXNzEyVm5yc0wzV29iM1pZMmV6UjJlblI3OC9KRTB5MGpSam1HWU1VMHVhQ0RZQkUycU9QM0NBTzk5MUEvTUhtOFN0QUJOcmRGQXljeGFGS3h4T1F6aWhKNmRtYXEyZDllRXIvVzZXVkZlaTlPSlZTQkFZak5Hc3ZycEtVY2gxZ0Z3ckozZGVlUytqWXJ3R05JelM0NHRUWTNjdVRyWCsyRXl0OXFsRCs2Y2VYem80ZmRKN0czaFh6blhjZEhLR2MrZTNXQnh6TEUxSDVMbEhCd0ZCRk9Lck1WZWxLbkJVeGdoS3dJamF0Y3NSeWprUXBjRG9jbXRvTGRMY2Ziekp5K2Q2L1A0M3JxQ1Y0Y1JOYzJ4MHp2SDFwNTRnU1FxT0hEN0owdElTKzJibVdKaVk1dERzUHBhbTU1a2ZuMmFpUGthb0lvcGNVV1NlSk1uSWtwd3N6WEhXNG0yWkdscFh6YXRMYWM0Z3p1T2NLMDBibk1OVnZzT3FTc0dzOXhTRlVHVGdraExrczhjbXVlUHg0OHdkYUtCTjZXYXZmTmtQOFFLaU5Db3c1Y3lMMW1aaU1qNCt0OUFjMzF3WnZEcm81ZW5lU0pLblZ2TE1NYms0VG5kcmVCMGcxOEk1UER2RjlpQlJTcWxScjZNZUIyYnE1TkxNSDV0b1JIK2pXWS9lRlVmbTJJRkQwL016QzYzQTJnS1BaMmF5enFmZU04a05zMFBPWFVvNXVpOEFyNGhhTWQ1RGtSUjRXMUs2WlEraFhLbWtLd1pMZVZXeFFWTFJxK3JxTGtTbG1Ca0x1TzF3bmJOWE1yNzZ6U3VzcjNRNWZIUWZ6UWw0N3VWbldOdllaSEo4Z1RDcW96VFVveHJqalFZTGt6TWNuRnZnNk9KK2ppL3Q1OERjUExQalV6VGlGb2pCRlo2aXNMaEt2dTY4cnpyZzVRbzNWYzE5aUhxais2RnpnclVlbTRHdGxqQ2JXSFBIdXc5eDhzNEZ3a0FqSW9TQnhtaFZlZ0VqRk5aalRGblRpQk1FTWEySitJYVorVVpyYzNudzhyQ2ZaK3lLR1pFaXM2SVZwR25CMUw0V2FUKy9EcEEveW1PZHgzbXZLZWZMWTZDK09EbDIyMWdjL1dVdEhOTmFxV0ZobVZzYVYxTlRUV3hSSUFyZS84QWtON1kybWRJWll3Mk5xZVRpempxc2RiaWlXbEFqNEJGTVVONXhDb1VheVpCMCtYZG8wRnJ2dHFsSG0zNm54d3ozM2pqRzVmV0NKNTliNTlMckc4ek1Uckt3T01iS3hubGV2M3lXUVpLVDU0NWhNc1NMSXdnTm9RbW9SUkhOZW9QcGlYRVdaK2M0TkwrUEkvc1dtWnVjcGg0MTZQY3owaXhENmRJMGJqU3hLeUs3dExUM0pjQUxWKzZvZHpubExzTktuOXVjcW5Ibll3ZVptVzhnSGlKdE1FcFJpOHBJYUpSbVpGdnNTOCtJc3ZaQ3pOaFlkR3hzc3FhdW5HdS9YT1J1MStFZHdlZVpvekVXUzNkenlBZi8zTDJjZldyNU9rRCtLTTdNUkl2dUlCbnRoUW1CaHRHNmRYQjY3S09CMFI4VXdUZ3JhcjA3VVBzT3pEQTNONGJTRVFzemRkNTFza09ZOXJDNW9tRkF1WExYaGkwRWpHRmt2WWtxdStmYTZITGZud05WRFRPNWl0NVNxTXJoVUtFcXEzTVRHRVJnb21GNDlOWnhCaWw4L2R0YnZQVGNGVVNFNlprV2hmUzVjUGtWbHRldjRKd21HU1QwZWp0a1JjSXd5OGp6dkRLR2M0Z1hnakNnMWF3VEJSSGI3WVQxelI3ZU9yUzZ1alMySEVJczB6N25ITTZYdXhadERqYXY2cVdLZjVyYTMrTG92ZnZSWVZET3NSQ1dSbmZWbnZjNERJaUM4bkxFa1NvZFVDb3FXSkN3MlFoUDFacHg1OUxaN1RNaXU3dm5xNjBsY09TT0JlWU9UWERteWVzQStTTTU5VGdpeVhLbDFLN09xbEdQd3VtRnFkWVBoMkZ3QzBxUldjdE9rck4vYVlySnlRYU4xaGczN0RPY211bVZwbXFwTDVmSlZCMXhqOExFUVVuTFNFbFJxV3BKam93MnlWWTdBLzJldGRkS0tYUzV0THgwT294QzRucElrVHZHNmdGM0htdVFGb3JURndlY2UzV1Q1WXR0eE1Qa2RCMVJHWjNoTm9Na1lkQWZNaHdNS1Z4QzdsTjJlaDFXTnRhNXNyN0dkcWREdTlmbmhUUG5PWDlsbFRTektDQ0tLc0pBbFFOUXpwY0xkcHdEVjVUQXNHbTVGMlJVVnV0QWNlVDJlUlp2bU1JRVphUlF1bm9nUUxuRUIwOHRnSHFraUVPRE1vb3dLQWU4dEZJWVExaXJoNGVzNTdXTnk5MVY5c3lPZU9mRkZaNmo5KzdqOU5ldlhBZklIOFZwMUNKeWEwY09KVEhRYU5haXhhbG03Y2UwMFF2T2UvcEpUaWZKaUNPRk1SN3ZFNWFYMnh4ZmltajRGS21jQzhVTDFpdjg2Q1lyUlZmVlFodXE2RkUrRzNWVmsxUmtGb0ZSdXp0R25DdFJveFZFWTNWODRiQ0ZJdzdnb2J1bWVIWFpjZWJTZ0Y1M3lNcUZObHRyQTJxdG1OWlVoSTh5RWpVa1NSUHlwQ2cxV0FwTWFBaENnL1dPelU2SDE1Zlg2U2NwU2tHOUJrRllVczFlS0QxN1hRa09XNVF2bDRFVVZ3dVNvR1k0Y3ZjQ2R6NThnTlo0RENZQTc0a0RYZlpYdkNjMm1yb0JKNTU2VkRZeTR3anFzVUtaYWk3ZUMwR2d4dU5HdU5qWnlaN3Y3NlNkUFNDUmJGakkyVzh1eTlLSkdYcGJ5WFdBL0dHZlZqMG15WXFSYldnZGFNeU5OMC9VVFBBajF0cW1FdWdPYzdwSml0aVM1cHlmYWZEc1MxMjJ0Z1k4ZW5NZGR2ZVRlendLVncwdmFWTlJNMEpsSkQyS0ZvTFIxUjVrU3JaSDZXcXRXYlZ5V1ZFcWdGVVlZbG90OHAwQnRYckFLK3M1Ly93TFczem1zWDBzTkNPMmVqbGJPME5XTDNWSkJobU5zUnBqTTNYaTZSQnBDSm5MNkNjcHZkNlFUcmZQZHIvUDZ0WU9UaGMweHlLaUNJTFE3OTZSenBjMHRMTlFWQ21WejhwMWE3czNRR3c0OFk2RDNQNitvOHd1Tmdnamd4S0lsTUtVNVJTaExwRmt0RERSTU5SalJSd3FhZ0VFUnBpb0diUVdqQUVRaGRiN2dqZ0tOeTczbmk4eXU5dHBCeVJ1Uk5LWWlLOEQ1SStFd1pxZlliUFQxd0toS2dFU0wwMlB2N05aQ3grM1RveFdxSjFCd2lBck84anRic1lQdmZjZ2Q5NDZ4VC81M0dzY1BERE9pYVVHVWkzNTh5SjRYUmJhUVJBUUdJMzRja2xuRUpyZFBCOWRkZGNCWTlUVkFwblIwcHJxbnpnZ0NQQnBSdEEwL0xmLzJ5cExNelYrNHRFWjl0VWlGc2RxaEFwNnc1VHRyUklvMjJ0OWJPRUk2NGJtWEV4akxpS2VNMFJUbXJBSjQ5TXhrOU1OWENXVnNWSTJMSjFjQllkTnE2Z3h1azFINUpwVzNQRGdFbmUrN3dpdHNhajhIQ2VFQ0pFUjRrQm8xSVJXcmR6YzY3elFpQ3EzU0ExaFVHcTQ2Z0dJS2szeXdxQ0twOW9jOHVpMWpZdWQxMFFxMVMrNFNyTWxSZmJXR0xCNlcybXhuSE9qNlZFdFlMUldZVDAwaTFwakFnM1dldEpxOHEyd01ETWU4OGhORTl4Lzd3SVh6MjN5SzE5bzg5Q3RNN1FrQnkwbzV6QWV4Q2lpS0VCVmQ1N3lWMGRvbGFwU0xSR00wYnRyenZ5STcvRmxUOFFpdUNSSDhqWnhxUGlYWCszeDh1c0ZmK3RINTNDSnBkWFUzTERZSUVBUmU4LzV0UjZESWlkWnpibXcwdVgxVUJPUDFXaE0xR2xNeEhqcjZlMGtKTU9jTExNVWVZRWd1emFqSTNCSXhUYnRQU09kMU9UK0pyZTk4d0NUelJBcUtqZUtJTktPOFlaQkcyakdRajJDWHFicHAwSS9kd2pRak12MWJ2V2cvRGxEby9BR2ducTVveVNma2ZIRHh5ZC9vck0yKzhxRmx6ZWVvWlRHRjk2SkczWXp4VnZFNC9mdGxXTFZJdFVkcHBySzQ2b1dSUk1IWjhmZjc4VGZpcUFLNTlWbVA4R0xSeFI4NEYzNytha1BUaERtS1hlZG11QmJ6Mjl5OWxLZkIyNmR4T2JsRHZUQW1GM0hkSnpnTTQvTlhkbU1xeFp4VXJGV0FoV2pVN2FTeTdtUkVrVEdhSnlVeGdnclhlSHYvZm82bjNwc2dWdjNSZVJWQTdKdzdLNkI3ZzR5aXN4UjAyVW9qS3dnZzRKMGMwaDNwVWU2MmNkMVUwZ0xWTzVJTThneWR0a3BQNkp2UjZSQjlRSXcybEJyUnB4NCtBRDdicGpDZVl0UmpsWk5VYXZCV0ZNejF0U29BRkl2WkZMV1hWa2htS0NzY2J5RkpQZFlXNlp5RGtWV1VDNFlGVVdXZVd6R3VIV1NiU3ozbm5XRnI3b3R1ejJTNnhIa0QvdHM5UWRJRlQwb2labVdob05lUkN0QlJoMW5BYUlvNEpHN1ptaWFnbVF3WkZ3Ri9NTEhGL2h2L3VVNm4zdXF5NGZ2YWxBTUM0TFFvYjFDa25MNGlLcSs4SzVzRkk1dXdISnhabG5ZYTZVd1d2QlNQcW05QndLRmlDZXVCZnpxNzI1d2FEYmlvU01CYVZJUVJ1V2QwMnhwcG91QU5LK3pNeHdudFcwNnZhSzA1TkhsRDFXcmFoMEVBblBWdXFjbXNKWkJ2anMvKzhacm80MG1yZ2ZNVEkzejhZOThsUGUrN3pGbURrNHg4SDI2dlRXeVpBdW50N0RCRHBsckV3U1dwaklNQ2tPZ3dGYnIyL3BEWDduR2wyc2FRbDJTRktKS2UxVk1LZld2MXdPQ01BK25aaG8vdFAvbzlHK2ZlM0d0U3ptQm1DdUZHNStPNWVaNzUvbkc3MXk2RHBBL3JETkk4OTBVQzlCanRYQlNpZDlIV2F5cTNGRmFlUW9jT3p6T0kzZE1ZWWQ5eEJaa3RtQmZTL1B6SDVqaVY3NDZaSFkyNXBFak1ma2dKekNsVURFdlBCNWYxUnV5Uyt2cVNzem9xbmExbHpLYWFGMnBmMVc1dGpuVThGcmI4TklseDEvOHhCd0dLVTJxTmRRaXNKSFFyQ21tV2dHSDUxdmsxdkdhNnpCTUhGN0swZGRxdTNPWlJrbEo2U29GMDJGcE1icVNRMVF6MUpzaCsvYTNtRjZvVWFzRnpNdzNtSnF2Yy9qZ0V2ZmRkWlNEK3lZNU1uc3ZZVkREcFFuaUhVaytJQ2wyMkI1ZVppZDltZFMrektEWUlTczBnd3hhTlVWa0xHdWJCYm1VdGNoNFhhRzBrT1VXNXhTNWFKUUlVYVNwTlFPQzBFeU9UOWR2Qjc1VE1Zc1pLS3VVRXEyVlhJOGdmMGpub1ZNSCtlYkxsMER0THR6VUMrUE5mVVpKUzFVRDJJVjNlQ25YUEQ5dzZ6VEhwelI1eitKOStWVE1jc2ZCY2Mxbkh4M243MzkrbmZwSDVybDlVcE1OSFVvN3JDMmYyRnBWTTkwanBrcXoyMlduaWlUaUlUUVZnNlZBZTQrSkRmLzY5OVo1K001cEZxZEN1dTJjUmoxQUcwV1JPdW94NUhVWXl3MExOc0s1TWNUQnhiVXVnOFR1enBBTDRMVENGb0pTRFlJd3hCWURicjlubWtkUFRISGd4aWtXbG1yTXpzYkVOYlBMckdWV3lJdUNWMWFlNEpXVmIzTC9EVHZjZGVoZENCclJpbnB0ak1qVW1henR4N3JieVB3SzI4bXpMUGVlWnRPMEtRcU5WeUZXb0RjUWxDKzM1NXBBMDJ5VXlvTis0aGhrZ3ZLYVdpT1FNTlpCb3huZUhqZWl5V3lZWjBBa0lyYTduY216VDZ6NElOUlNqaXBmQjhoLzFLT1VLdk44NzBjUkpLaUhaaitpV29xUzE4cDlXYUF2TG96eG94ODhoTWtUMHN5WDlqb2VuQ3ZwMkVOTng1OTR4d1JmZkxKTjg4RUpEamZMcHBnV1I1RzZzdWVoeWwwYTVleUgycDNiSHBrY0ZMN3N2Q3NsaUN1N3o1ZXpnTmMzSFgvaHNTYTlib0lXS1BwRnlYOHFCVXFJSXhocmxFb1o1MnZsbTJRVXk1dDl1djJzTExwVitiMGVQWEdTei96VVR6RjNZSjZuWC82SDNQRGdCUE96TlFMbEVPL3dWZjhqdHlVcFVUakI1UTRsbXR3VlBIZit0ems0ZllLRnFSdkpreDdPSnFCaWlrcjZYNHVQY0hqaUJpYmlXM2h4K1Yrd0pldW9RbWpVRkxWUTA5MHFLSWFlVUN0VTlXZU4yTk5Mb2QzM2hFMmxtaE1oWVMyOGRYWmY2L2lWYzl1N2MremVDOE5CWWF0MTBuS3RGdTF2bXlJOUxTekR0TmgxU2xSS05ZOU90OTRycUFjS1VONExtNzJFeERvKytiR2IrZW1QTFdDMzI3aWlWT2w2cjNDVnNXYVd3WFFqWUhJaTVuZWVHM0JzSVNSd1VoWGtnb2xDTUthTUdvNDl1cWZ5U1kwQzY4QTVqVFpsMzZUVkN2aFgzK3hnUlBIQThRYkR4Q0lDUmltVVVWZy91bE5VdGM2NUJIMmdOTFVveEJoTmJoMVphakZCaS9kLzdCUDgwbi81dDNuUGh6L0V5ZHR1WitGWW0zcjRPbzFBeXRSdDVPZnI5TzRxNk14Nk1pc1VEa1EwdzZ4TFhKdmk4TUxkR0cwSTR6R0NxSTZnTUZxampjSzVnb2dwMHMwYS9XU0ZUUGRJczlMd09xb1pyQzFyc1Zxc0NReEVnYUlaSzJweCthUm90QUxpU0VWRjdpOWRPcnR6aHFzbDIvY0RoYm9Pa1A5SUo4a0s5cGd4MUNkYjlhbGpzK01mc2M3Zm1PY2ViejJyM1FGemN5MytzLy9rRm80Myt5UzlGSEVlc1ZJeFAxV1hYQlI1SVV6WEZLMVk4K3ZmMk9ISVlvMVdGT0FLd1FrRW9TR3FoYnMzczZBUVgwNForc3JFd2JzeTdZb0MyUElCLy9Eelc3em41anJqZFlPZ0NjSUFnakpWY2dLaTkzZ2M3ZzVsbGJMNUtBb3dDTE9MQi9tSlAvOVgrWk8vK0JjNGN1SW9SZ3RhR1NJMXpuRDRERTRTY3FmSUxHUU9VaXRrZVdsaFdsUWJidFhJOTdjTVdweFllb2pBeEx0cG90YW1sUFhyb0hMdGhWbzR3V0MxUUdyclNKQmh0TVpFbXFnV2tEbE5VakZZVVZCS2NXcWhVSXNVSmpJMHArSndmcWsyMnh3TDI1dXJ3KzBzY1NON1lIV3QzMWR2RzRCVU5LdXVDc0g2VkxNK3ZUUmUvNkhjMmlQV0t4ekNXcnZQQno1NG5KLzU2QnpGeW5ycFJGS1U4eE41b2JDakJsdlo0YUFvaEgyVEVhclY0TGVlN2JKL01tQ3FGWlQxU3VySVV3ZGFFMFFHRStncWdwVDZMTzlsbCtVS0FzWC84cnZyZFB1ZVR6ODJpNlpzcUFIa3FjTlh3MFJ1ajR4K1YvUm9ORHJRQkFxTzNIUUhmK3dYL2pNZSs4aEhxZGMwVXVTbC9FVkJGRXl4TTFoanMzZVdRYWJwWmtJdkxSZUw1bFpoYllENFdxbklGWS9SVjcyeERpM2VUN014eTJpeXZpUWRSdEthOHVzSHRSckZRT09LUG5waUV3TEZlTjFnak1FcmcwZVhhVzZGT2l0bERSWlVINXNvbU5sL3VIWG5IZmZQSHB1ZHJ4WG5YdTF1ZUNlYXF4YkI2dnRGa25velptWmhuRUUzdlE2UWY5OXorK0Y1MWpyRDBaNlBDS2pQampWbTk0M1ZQNXdXZnNrSG1rSTh2YXpneHo5MWxIZmRQY1ZncTArUkZsaGJQbFU5dW15dWpTUWtVaGFmZWVxNFlhbUphdFQ0MTkvWTROaStHdFBOQUd0SEN0bEtXbTQ5ZWViM3lNRExhTktvR2RhN0JmL3czMjd5SjM1b1AwdVRBZG1nUUp5VUFITmxPamJhTWFnQXJRRlRLb0hMdm9YaTBLMlA4TTRmKzRzY09Ya0tYSW9TaDFJR0ZUWVFGRm84Vy8xdFhsdC9qalFQR0tTYUlndkowaGlidGpCdW1zbjZmcUs2WjJoN3BZdDhsZU1jbkx1TGlkbzhJcnZ0VFlvOEszVzQ0aEJYeW4xTkdMRitzVTAvdkVJWWw3bFZLVkpVUkdHSjdOUkNISXk2N09YWENvS1NGcFpBTityanRSTkhqbzNkZStqNHVGbTVORmpwZC9LaWV0L1VtOEFoVUVicW1mbHgyanVEUDVJcTVXMEJrSVhKSnR1OVZQczlNeUJUelhoK3JsSDdjT2I4dkRXS05DOFlud3I1eGM4Y1lyRUpKbzVJK3lrMkxTWGdoVmRsNTdtU2FQaXFDKzQ5SlAyTW8zTVJSNDVOOGkrZTJLQVdLZzR0TkVwQVZUVk02WWxWZHRXZDdBNm1NelllOHMyTGxvdHJLWjk1WkpyT2RvWXZoRHdiOVU0cU1PbFNObzhySXhDNmJPUm9JeXdjdlplN1B2eHpUTXp1UTV3dGIrU29WWW9LQmNUbG9Bd3JxeXU4dXZJaXZhRmhxNjBaOUVLOHI3NXcyTVBxRFlaRnR3UzJWTjErRlhMRDBpTk1OdVp3MlFCVWFSRG5yQzBicENpVU50Z3NSU3RQcnoza3ViT1hXRTgzbVo4TXkxbVJpcDB3U3VPbExOYW5tNVNnb1JSdWpwaTBYZ0VGcGprMVY3dmoyS25wZy9WV25LeGQ2bmNySmt0L3YvZDNPTWhVWVIwUG5Uaks1YTMyZFJicjMvV1VPd0ZWMVlVdXczWTlDcHBLMDdKYXhCaXRDZ2QzSG05eFpFb1liUGN3VVlBeEJ2eG9zNUpVKzVYSy9zYXVBVVBGVFBXMkJoeVlhdkQrMnliNEYxOWFKU0hnb1dOTmJGR3VXSE91SEU0cTZWOVZpYStFUVNaODRabHRibDZNeUxwNTJXR1hVcHFDTGYrdFNLbXUxVnFxVFZMbC9MZUpMQk1IVG5IOEhUOUpyVFZkUmpZVG9reFUxajNPby9ENG9zQzdETlhYcks0RWJPWGJMRXdGakUxcG1nMVBIRlFkZndGZmpJYW95blF5Y3dWSjFpOGpsd213YVlMZ3NYazV6bXZDQ0swTk9xemh2VERXbW1SYWx2akNTeGZZNlE2NSsyU051Y21BdGI1aktCQUVtdHdydXFsaHZPN0x1UkZ0Z0hMaWNhYWgyQmdJZldkcWpZV3hEOXozZ2ZvZFIyNmQrZEszZnVmQ1AzdjV5YlhUMVQwWkFBbVEyOEpaNTd4dmhFWTU1K1I2QlBuM09QdW14OW5zRHBRVEdhMXZycDNhUDN2M2RDUDZvVjZTeDZLVlNuTEx4eDhaNCs0bFJUck1RVFJaVXVBeVc5cUtpcjdLUkZWU2Rha204aENGVVpBTkMyWnFpcU9MTlQ3M3pTMFM2N241NkRoRjduYW45UlJYUHo4TUZPdlc4TSsvc000UDNUdEZYSm5NaVNvdnZJaENLY0VidFF0S2NZckFhRXdnTk1ibnVlR2RQME56NmhES1JLaWdoZ29pbEtxZXpHaHNPaURwZGVoMCtrU05LYzZ1ZlpNREI0ZnNudzlvTlJSeE5ld1VHVVdreXlFdm9XU1lDa3BieE9Qejl6RFhYTUxhSEhGRlZaaHI4aVRCMlJ5YnBYanJVQ29nUzFMV0xsMWcwN2RaNlE3WTZKVXA2bFE5Wkt4bWlBTk43aUYzaWtGV3VsQkdwcXdSclMrLzY4aUFRNnZVZ3RhMDZtUHh6Wk1ISjI2YzJkZklPdXZEbldSUUZIdjFBRXFRV2hUSy91bEpMbTd1WEFmSXYrdFpuQnBqb3pQUTVScG5WUU5xeHhlbUhocVBndmYwMDF3N3JaVUpIVC8ybmlsbTY2VnNBbVVRVWJoY3F0cERWVUNwRXVHS2ljS3JYYld1VU80aEg2OXJqczJHL041ekhUcVo1NGJGQm1LbEFsZlpNMUZLVVk4MXYvZmRJU3ZyQXo1dzUzUWxHcFJkUnhTaktZZVlLcmJMaXNJRTFZaXJFNEpvbkgzM2ZCSVRqVldoTEN4am5TdEtnKzJrVDdmZHhxdUE4Ym1EOVBvRE52dGZaSEs2WEJvYW0xRlRzeHplS2tTd0tMeldXQ2sxVTZHSk9EWC9JT1BSTlBsd1FCRFgwZHFVN3ZhaTBRcHNVWkFuUTV5MUZGbEdiNmZOVVBWb0p6c29IYkRldGJTN2x0aG9ac2FqVXV5ak5ZVXZGd2o5LzluN3J5RExzenUvRC93Yzh6ZlhwcTNNOGxWZDFkNmcwUmg0ak1FTWg5VFFEWmRreUFRVmpGMXBTVzNFMnRqWW9LZ0hCaDhZZXBFZU54VDdRR2xsZGtWUjFHb3BSOHFNSXdmQXdCQVlBTjFvZ3pibFhmcTg5dStPMjRmenZ6ZXpDNDJad1hCbWhXNzFqY2pvcXVxcW0zbnZQYi96YzErVEtJSFdFWUt6Z1Arbklyb0NsemFnUlpCWnFzOXZuQnQ4OXZMMTFhMnFNUGNPZCtZTG5hQkl1UEloRkhYRHZEN2h0RzhPdWx6YlhtZHZNdis0eFBvOVI3ekdSaVJyQ0tLOW5LVWtyQW9ScFBBT25PVHEyUzduQnREVUZ1Y0ZwaW5SZVlvVk1tcGYrWmFhYXNOeWVvTm9PZVplTExGV0FONEVObnFhdi9LbERmNytONDU0dEYveHIzNTVDNm9HYStPWU5Fa0ZKczM1emQ5OXlOUGJPYWtTTkcxcHN4am1MaXcvRnIvV1dwS2tBdHVxdnMzQ2xFZmpkM21pKzBXY05RaHZvdTJDTVZTekdjWVl1bXRiNUwwVnBOUllXNklUUXorTnlpdU5qWFcvUlZDYVFPMWpZRGpmYmxLbHA1dXMwQmM5VEZsUnpZc1c2aTl3eG1DTVEwclJVbzlkcEJhYnFENjVucXhFK0g3dElKTWNqQnpUb3VCZ1lyaXdsYUV6UlpvcHFncWFWdVhGQm9mUUVpMGpFbUJGQlFJQjA4QkFlUm9oVnBOei9iLzgrVDl6L2Ftc2svMTdyMy9qL2xkQ2lKQkw2ejM3MDdtVllpbU9FYzZ0RGJtMHNjTHVhRW8vUzdoMU1QNDRnM3pRWTF6VXVCT2Y4NjZTc3ZmOGhZMWZ5Slg0NUdoYUN1KzlLSXhBZW5qeWJJcHhzU0d2UzdlRWhUc1hhM0xqNCtFNkdhbTBpdTV0YmVSRFBON1dRVWNKWHI0MjRNYVI0ZFZiYzU3Y3pvaEd0b0kwVGZuNkhjdXZmV2VmLzgydm5HT2xJMmxNV0dLb2xuMTgyd2pMVkpMRW5odmpvSk1wamphN3lNMkxYRng3QVlTTWtqNUFOUzlCS3ZvYjIrVGR6ckxrS3FzcGsvcXJwSWtoQk1oYXFNdWtqUDQrZUVsVkMyb2pxR3ZCYk80WnVyTThrVDVKTVoxaHFwcGlQR1UrbVRBZGoybkttbW8yd3hyRGJEeU91bGpXOCtqdVhYcXJQZDQ2dW9jTkllNUVSQ3dacTlwemVHd29La2VhU0pKTWNlS2ZDN043bHZuZHdQaFJnNVN3c3BxUUtvbEhrQ25RQk5IVW5ITk9yby8yeXU4VXMvcjBmRmNzU01CQ0NIazBLOWtaVFlXV2dvdnJBL1ltQlp2RExwYzJWam1ZRmg5bmtHV1RidDNwUFloUVNpWlpvbnBDUkJWTVg5YzAxdk9QdngxWUgyaSsrR3plSHN4NDhFT2JQWWpUMVZqR0xHUkdPZms5dEdOZ0VUY0dqUk1JYS9uVmx3Yjh4ZzluZk9YZGdqLzVmQzh5OEhUQ1YzLzNQaXVwNEV3bW1SeGFsRzZ6Ull1dkVMWmQybW1CWGhDdGZLRFQwVmdDb3lSajNaVkxvNTdnWVh5NFQ5THAwbHZmUkNYNVlndTAxTkVkajJFamMzU1VvbXdVazBMampNUTJVSm5BcERCVXRhYzJnY3A0WHRxK3lNNjlCeWlkME9uMWtDb09MOHJaSEtVMEVKQmE0eHBMT1prU2hFVHJIT3ZxMkJ3RWtNaEl0eFd4TEsxZDRORk96ZkhJY0dZclo3aWFVaHhhOWw4NzRzSDN4aVErcDl2Tk9WS08vRXJDNExrY3RacmljWFNIaUV1cFlEN09uMTdkN2o1NXNETWV0K2MwSWFLQkRXQkRDTTU2N3labDdaVVFZWDlXaEZUTDBFazE5NDdHSDJlUUR3QmpMWGpvZVM5TE5sNit2UFVYQmY3SzhXUk9ZK0tLM0FiQnU3dWVYaTY1dUpFUUZqM0hNa01zU3F0Mm10VkNOQlpUZWIrWXpyZEJ0RFNTYlR6UFh1Z3kzT3p5ajc1OXpOWjZodGVhLy9CL3VNK1hYMXpobWEwTVl5TUVKSlpUQXRmVzR6cVZwRHFPUWFXVXBLbEVoc0RZSzBhYlE5Sk93dm4rVXlpUk16aytwaWdyVnMrZUo4bjZMQ2NKT0JBQmdlYTl1OS9CcVNuemFzRFJwTU5vS3BuUEpaT3BveWdkODhMUzFGRVpKUXNacjV6OU5OcHJuSzFSU2xPWEpjRjdtcXBrT2hwVGxYTzhzMWhyRVNIdzFodHYwZFFsS2xQY21ONUdKb3R4dE1BQ0prU0JpSTZFdXZGTUo0YnBvV0gvdXpPbWJ6YjRPbEJXSlhWZElaekVId3YyYjgxUkhlaHZkSEJ6eUgxZ2JhaHlMYVhadVRPN1g1WjJBVXRaZUVycVU3c1Q0VTlFc29Wdk05cXdsek92bW84ekNDZFRvMFZwTDFJdGN5WFlkRWdTclVRa05qbjh2T0RZZWY2L1g0dVlsTTg5blVlZVE0aGd3ZUJQMVZiK1pHMFZUdE5uMnlCeExWTVE0aDVnUEdvWWRqVS9jMzNBZDNZOU4zOTNoNnJ4ZlA2Rk5heU4yOGZROGtOb00xQ2F5YmI1ajhzMkllUDIzcFNXYWkzREs4bWsybVYzOUI0YlNqQ1pUdGw2NGluU3ZOdVM0T01DTHpnWHhlYTZLV3ZES3p5Y0hPTnR6bmhhTXA5WEdHTXd4dUtsb0lhb3hCZ2M1d2JuR1NZRFVCTG5NcXl4V0dNb1puT2tFcFRGTExwbkFYVlpzYjk3eUhnMjVva3JGN2szZVlnelBqYmY3ZlpkQzJnUUdBSmVTSUx6VkxXbkNCNTFYdER2ZGVqdmRpaVBhcXF5WWp5WjBPMTJHY2crNDI4VXpOK3EyTzUyMkowME9PSDBzTlMvK3VYbkxsMHZDL3RPNDl5Ymg3UDZuWGNmSHQ2YWx2V0VxQ3BmdDFtbEJvenp3VTNMeHFkYTBjblM4SEVHYVIvOVRpYU1YVHJXNW11OS9NSlQyeXYvb3ZQMEsrTXcxc2FEN1FPK2FUQWk0ZmFCbzkrUm5GM1Y3WWoxRkVnUUNENDJzNkhGei90MmdSamFLQW1uLzI1N3Z6V05aNnV2dUhwdGhiLzNQejVnT3FuNTVaZlg2RW1vbTBBUWNWd3MyeXlsVlN5dmtoYS9WWmFlK2N5QWg4bGFUclhTd1lXR2QzZHU4K2orbUxQYlY5bStjQW04YS9zT1dIQnNnM2U0c21BOEd2UGE3VGVabHpYelNVbFRHUnBqQ1ZLUXBEbVpUaERXNFozanFjM25PTmU5VEYyYm1DRjlkUFVOd1NPa1JLY3BTbW04czl4ODd3YnYzcmpCRTljdWtTY1pyKzI4dzE1NVRGZko5b0tLZnUxU1FaSUlCQW9sSk5ZNGpQRVlHMmc2QXIwdEdmWlRlcTVMbnFWTUpoTnE1K2pvbk5sK3pkN09GS3ltbVlNdGcrN2syYms4VWM4UHU5bm5MbTZ1L3NLMXN5dWY2U1ZxUlFoWnpPcW1DZUY5anRZdDhUTUVId0w5UEtGcTdQdndLNnI5OHY5TENoQWZFTUg3cGRUbzVxQno2ZnJXeXAvMWlGNWpQUzU0RUZHRVFVaUpFSUhLQ0g3NHNHRjdQZUg4aHNZc3hyU2NOTkcrRFFSYU9tM3NFY1J5TEJ1V2dJZ1RyNytpZEt4bzJKODdSS0xvOXhRNkVTUnRZTGdRRUNIeXZ4ZEFKQ25qNXp1Zm1xaEVJbUM4MmNkMFV5cnJlZWZCSVVVVitQS25mNGxPMW10eFd1M1A1UzJ1YVNnbTR5aTJiUUp2M0h1VGcrSTRDc3lwZ0VnbFNpc0VzZEczb1VicmpCYzJYcUVydWkzTE10QlVCYzQ1MGl5UGtxVSswTlFWMWhyZWZlOG0vVUdIODl0YjdJLzIrYzZqdDZtRkpjK1NpRjRtaXNoRlhhN29uWUwzQ09OYlIzVm9Day9SZU9vK3BDYlFEeDNTTkdGdi94QVFEQWRkaklQajJSeEJRQ3RObm1Vb3JUSFdKZDZIb1VCYzBVSjhicjNmK1puejY0T3RWS3ZwMGF3c0h0dkNCMnVkcUl3N0hSdENuQ296Z2hCYzNscmxsZXZudWIxNy9ORU9rQkNDREtkVTNMZUh2V3ZYdDFmL3RCQjBxOGFCRUxFa2tqS0NDWVBIVzRjVGlqc0hsclZod3RaUVJyaElPTkhZWFFiTWdpdXlDSVcyZndndGMzQVJQSXRzMHUwb2JoNDJmT25aRlo3YnpxaFZ3bzBqaS9DT3pXR0tYVW9HQ1pKVUVYeGdQalB0MkRkZ2xPUm9xMC9JRTJhVjVkN0RrZ3NyVC9MbFQvNTgvSUJWQ3M1RUZ1QmtURk1VZU9zd1RVT3FjbmFPOTdsOStCNVN0ZnBZUG1DZHBXa2FqRzJvaldXWWJ2RE15blA0eGxQTVp4aFR4YjZBcU9WbFRJTnNzOE9OOTI0Umd1WGkrUzBTbmJCZmpyZzV2UitiZEMxYXdZZjRlbVFRWkVJU1d6ZEpraWhVaXpGenp0TlVqcUx4RVhweVlBa2k3bHhHa3dsNWx0SEpNcXJHTWpIektML1VPSVFJUWdSRUlFU2pIK2NWUG14cktUKzUxc3VmeTFKOXNEOHA5azZkNStYZEk0U1FVZ3FobEpZSUlRSkNDQ25aWGgrdzJzdjRaLy9CLzQxLzkrLzlCdmJITE9rL0VnSFNyaTBXU3U2ZDdaWHVVeGRYZTMvS09KOVh4aTJoSFZKS2hGU0VFTERHNG1wTDVSVHZQbXdZNUlydHR0eGFITjVZNXkvVVNVNldpSnhxMWdsaUtlMGpSRUFvTUFMKzJidFRydll6S0IxZDZWa2RKcnl6WDNIdm9LR1RSVnF0ZFJIcE81L1pWdU0yZmkrakphUFZEajVUVEdhTzNaMlNpeXVYK01LTFg0aXdEVy94cHFhWXpHbUtFbWM5M2pSNDcyanFDbVVFdC9iZW9iQjFWRlQwclJhdmNaakdVOWVXcmZROGw3b1hLZVlGUWdnVzN2REdORGhuWTNBUStPR2JiM053dU0rVnkrY1o5UHQ0QnovWWVZZkRab1JTa2lDamFKeG9GU1NERC9RU1JTWUUxbnE4aU10UExXZ25neUpxam1ubzFKSmkzQ0NWb2loS3B2TUNJU1NKVGhuUGE4UjVSVmRyZkdHalJaeDFyUStMRjFJS1FnaEtDWGwra0tjdmRySmtQQzdxZlJjcmlhVDkwa0FTQXRwN3Ixb0pieEZDRUVYVjRGemcvLzVmZm9XaldmWFJ6aUNQQlVoK2RXUDRxYk9ydlY4MDFxVlZZN0hPdDJKdW9sVTJqeFdvTlJadlBVNXBidXdhOGtSeWZsMGphSmNVdEI4cWNjb1VpS0lNaFBlVHBKWlUyd0JTU0k1THd4dVBBcDk3ZWtoVkdLb21RT001dDU3Uzd5bGVmMUR5K3IwU3JXQ1lLWXoxbEJIWWk3SHh5WXBoanVsb2pzYU8wWkdoTGcyZi9zVFBNdWdPOE00eG41WE1qZytKL2xaeG9lbU1wYTVLK2xtZmU0L3VjMi95Z0dBRHBuTFVsYU1xSFZVVnAxblhWcTR6cElzeERkN0ZMRHMrUGtZbENtOGRUVlZ4Ny81RDd0Ni94OWFaTmJwNWhwU1JOdkM3TzI5UzBKQjFFNFNXTFErZlV4S25rVkFsak1mWTlrSVhFVUlqMjRXckRZSEVTSmc2NmxZRVlqcWRZYjBueXpOVWtOd2J6ZWc4M1NjWVQyb2tuU3lOL0JnbFNaU09uQlVoa0VLc3JYVHpsL3VkckRxWWxnL2FJRmthdFo0YUV5OG5YNEZJc3B0VkRTSDhlRjdLUnlsQWtrVUdlWHA3OVV0cjNmeUxSZU9VYlQ4d0lhSzNoWlFTS1dRVWhRc09ZdzNlT0lKTWVHK3Z3ZGpBNWMwVXJWcVVhZ3RrWEFaQ2VQOEdQTFFsVnhDQ0xOZjBCd21QSm81N1I0YWZlYUpMT1RkTFVKRjFrQW5CbVY0Q1d2TE45NmJjMmkyNWRDYW4xMVY0QjdhRnp4ZkRqS3FiTWo1MlRFY05SVFhuVTg5L2d1MlY4OHpIWTRycEhPOGN4dFN0ZXJ1bnJrcktvbVEybjZHczVMMzc3MUdVSmRYY1VzNE04N21sS0N6U2ExN2N1SWFkTlJFV0l5VkthZEkwSTBrelROTnc0OFl0YnQ2K3c4YmFnTFhWSVZwcWhKQThtdTN4dytPN0NCVkl1anBLcWxZdUN1YTFxaEl0R0JrdEJJMEIyNHBqU3lYUk91SjJsQVFyUFoxS1VjNE5JY3BaVXRjVlNaS1NwZ25UNDRxNkowbk81ZFRqRWxFSHNrU2pwWXgrOUZyaFEwQnJSWmJvWHA2bzU1ODh1M2I1MnZiNnBlMjEvdGE1OWNINXJaWGUyVFBEN3JiempyS3h2ZzJXSlZuck1SdEY4WkVjODU0ZThRSkNTOWsxMXFteU5nRWxoVlFTNjF6cklTaFJXcE8yWGhwQ1NPcXFvWnJPOGYwT3YvbjZuS29KL1BsUDkybVZiVTZDb2ZVbXhKK01hM1dpU0JLSlVoSnJJbEhxaDNmbnlLcG1mbHpqV2pXU3VNR000TUNtOFZ6SUZadlBybkl3Tjd5eEd5VkhuejNYNWZ4cVJ0MEVtRFVVcTU2cWRwR0E1V3J1N0g2WEs3M3pqUGFPV21oS1FwS21WTVVNNTMwc2s0TEQyb2FWYk1BRmZaRnYzdjl1NjBVWVM2MGsxNXkvZkpaQk9xQ3VTd2dDNXl4bDZlbjErbmpudUhuckRqZnYzdVB5eFMwMlYxZWlnMjhJV0d1NWNmQUFHd0twakwxVEVJS2dZcW5vUklUSktDQ1ZBdWtEdVJCTWphZHBvcDZXU2tCcVNTckJyUVY4QlN0Vnl0R3NKczA3TkthaGFXcTZlYzdabFFIM0h4UlVneHgxSnVYd2ZzVmFBNE04alhNb0g5QktZS3hIS2ttYXFQVlV5VDg3Nk9RQktaMlVvZ3hRV2UrYTBiejYzbHYzOXYrejErL3N2UUVVTFZwNDZkTExpY2ZpUnpLRHlOTVo1TkphLzdPZFJIMjZicHp3UGl5MVpVS0l1d3V0Vk91aElkb0pVcUNwb3hkNDBrbllIVHZHWmVEc1drSTNqYkFTWUJrd1Fzam9ScHNJa2tSaUdrOVJXb3p6Q085NSsxSEZtYlVPNXdlYTRBTkpPd1d6SVRiL3FCT0pvTlZjMGRld2UxVHo5WGNtUEJ4YnJtNmtKQjNOYnBaeGZHeXA1b2JnSUIyT0tNY2xtL2w1RUZCVlZld2I2b3JaZElwekR0czB6Q1lUSnBNeG9mUjgvL1VmY3UvT0kyWkhNNHBaUldVZG43ejJQQmY2bTFqdnNlMFNVRXFKYzQ2SER4L3kxcnZ2Y1daamxhdVhMMElJS0tWSTA1UnhQZWVObzF0WURGa2U3ZFdrakVhaFVwM29yM29YQVprU2ozV2V4Z1dheG1PTVgyWlRMeUJMQkNFSE1YTFkwaUdreGpsRFdjWXMwczF6aWxsTkl3S3FuOUFrVUk4cWZPT2p6YlZ6N1U3S0w4dXRPbmd4cjR5WXptdmx2YzhTSlh0cG9vZURUdmJVMWtydlU5dHJnMkVnVEVmenF1RDk1S3p3VVE4UURXUkNpTjdGWWVjWHRPQ1QxZ2RoZlJEZSsrVWt5M20vSEt1NjFxNU1TSVdVQ2xNM2xMTWFrU2JzVGdJUGp3MVBuTS9wNTJvcE5jb3A3dzlySS9YV3RJaGdxUVFpVGZqT1E4TzFqWVNWbGxYWGFqOUhrdEtwbmlYZ2FVaFIzUzJ1bk52a3FmUHJOR2plZWxCZ25XWGF5em1jTkZTekJ1RTlhNXVhbS9zUG1NOHRXNzJ6cEdsQ1VSUnhkK0VkbzZNalp0TXBrOUdJbzhORGp2YjJtUi9PdVhudlBvMnBNYzZ4dnJISlo1OThDZVVDMCttSXBxbEowZzdPR2Q1NDR5MXUzTDdObGN2bk9YOTJteXlMMEhyWFd0UTluTzF5dDNpSWtISEpxUk9Ga21KcE5lZGFQb3ozZ2NwNmJBQlQyY2ljYkhzKzJ6Z0k4ZEt4RHRKK3ZHakNrYVZwUEVwcFRGUGp2S1BYN1NJOTdCMk9FVjFGT3NnbzZnWmR0Z1MxRnVDcEZnTGpVclpNeWRaOE5RU0t5akNmbHpqcmhHbk1lcitUL016WnRjSFBwRXBWKytOaXo0ZHd5bVh5SXhvZ2JVMnBnRlJKMlRuYlQzOUJFRDVobk1lRHNHNHg2dlhSRXNERklGRktMdThQbFdpY3Q0UVFtQmNOdlZ3ekt1SFdic05hWDdNNTBFdG9oMnVYSHU1OWU1RFlDYWx1eHB2M0M1NFlDRktoOE8zaGthSU5rZ1dLMTN2azZuVzZULzlad3ZtZnBYZmw4M1MzbnVmaUU2OXc3dHJMeVA1VjhzNFpoRSt4TlRocldkL1NUT2VHRy90M0dJOG5iT2JyQ0FSVk9hZVlGMHpHWTZhVENVZjcrK3p0N1BEby9pT0NzVXpLaXVQWkZKRW92dnlGTC9EVTVrWHFxaVpKTkxVeFdFdE5Hd2NBQUc0U1NVUkJWR2U0LzJDSHV3OGZjdUhjRmhmT2JyVWxwYWV1NG1IMXdmUHU4UjBtOVlRczB5UWRIVzBlWkt0UDNQWnBVaERCaTFMR2NYWnA4WlhGS3JIMFRmUXV0SFoyRWZ3cHU1SzBFcFNqSmxya2VrOWQxNmdrSWM4eXhwT1NtYW5JQmhrK1Z6VFRocDVNTWRiUldJY1NDaDBsbjVZM1pwcHFkS0t4QVlLTTNQYW9mRk5McmVWbU4wMC9wWVJZbVZYTlc4YjU1bFNRTEw3RVJ5bEFGa3ZTSklTZzEzUDlDc0g5akhGZVNLbUVrTEtGZHl3NEhYR3NtaVFKUXNRTmNGajJKOUY5cHl4S3BGUlVYdkhEQnpWS3d0WlFvM1VrL21ndDhDSk9iaGE2dkFHd0N0NTZXUFBzK1M3QnhNQU1MV1JjaG9BTUFoRUNYbVYwbnZtTFpPZGU0V2h1V0YzZFlES3UrT0d0UFhZT0NocWYwUW1iWEY1OW1pZlB2OERUVnovQjV2QUtpUmhpak9mTzhRUGVlZlF1UlRGSEdTaW1jMGJIUnp5NGU1OEhkKzl6dEg5SVhVU1lpWkNLQjBkVHpteWY1MWQvNGN2SXhtR2RJMGs3S0tsNStHaVhPL2Z2YzJaempjMzF0YVVJZDFsVlNCbm9kVHJjSCszenh1Rk5KSUdzbzBseWhaU3lMVnZiekNvakdrRUtnWmJ4ZFlxSXEwY0lTUzV5SkFMakxHVnBzTVpoVFpRbkNrb1FEaHZHc3dxdE5VVlp4QU12TmM0R0RrZFRrbjVLZHpXbmRwNjBCQzBrVldPd0xxQzBKZ1NQYVJ5ZE5DWFZVVEN2c2hhVktNNXVySUFQeU5hQVZDZXFzN0hTZjNwOTBHVThxMjVYeGxhYzZBWXZzOGxIU1hwMFlXWnZEdWYxdDRUWGYxbktjTlk2UjVaM0VGNXlDdFFXSFdIckNOQ1RTa1VZcWs1d2pVTnBpZmVTMldnYWI3dCt6di93M1FrUERneS84dWtoZzc1cWI4RW96QmJOTW1QcGxPUVphWjZoUW9UUUN4OTlNMElJclRqRFNZM2x2VWZpVVFLS0txSmpiOTI0eVhRK282a0xxckpFSlFrWExsN2czTGx6bkQ5L2dhdHJWM24rVE1xOEhuRXczV0gvNEFIMzc3MUJXam5Ddk9Kd2I1OXlOc2RaUzlVWVVtdTU2QUtoMCtjVG4vZ1VhVWlZelkvSThnNlR5WlR2dmZvRHlxYm1tV3VYRWQ0eEdZOG81ak95UEd1blJSbmpZczQ3NDdzMEdIcFppa3pqYUZlMHhxRWl5Rll4UGxLZmwvcXZBcnlLN2xUT2dwWVMzOGpvUDIraUNMZ3pIbHQ3YWdmQkdBNlBwM1E2T1UwVG1FeVA2Tll0MHJvTVRQZG1kQWNwZWpXbExoMlpWZmlxcGpJV3FUVERib0tXa3FwcFVGYVNhb2wyQVMwRHRqSG9Gb0hnZzBjS1JaS283dmI2NEY5N1dRajd0ZGR2L2Z2VythVk53NkluK2RCbmtGNnFGbHZRQlNZbktheWJKSUpVaWZDU3RUWjFOcDVpNjJLbVVGSXRleEFoSXV4ajRTZm9YTHhkUll0enFzc2FaeDFKbHJFenNleFBMUnNEelVvL0twdFlFeGx6V1JwbGZ3cHJlZTlSd1pNckdtZml4bGd1YktNSnJXcUtBRnRqeVVpM24wTUt3ZEcwNE96V09vZDdlOXk3YzRlcUxPSTJXMGlLcW1iLzRKQTc5KzV3NTg0OTl2YVBzSTNnL1BwbHJwNTdscXRYbnFNNzJDVHJydEhwRGdsU01TOUxyaFlGdjFRWWZzWUVYaENhN25STzVSeGo3NWpNQzM3NDlqdFVwdUhpdVMxNjNRNHVlUEk4Unl1RmtncGphcFJVL09EUkRXNk1INUlvUlpwclpIVFVRWW1vaGFWVjdBT2NqenVLV0dJSmxJejlTTFNEQStNTWpUWFV4c1gzVk1xbzdsSWFtdEpTN1ZjY0hveVlGeFZGVlZHV05VRW9xcnFtS2h0cVora01VbFN1YWJ3blRBeUppcVBldW1sb2ZPd244MFRUeVJMdUhreW9tb1pVYTRxaVFVdEYwOWpvMUN0bHUzajB1cE1sRjVORTM5azdudDFwbFFLV1Rpb2YrZ0RaN0tYVU5naDNDdkljUU15dHY5M1JNa3NFenh2cnRCRGdmRHo4V2ljdFF6RFdyRkVvTFg2WW9xM1lBbkY1SlJYWUpxSmhkYUk0bkFkdVBLaklVOGxHUjdiTk94R2tweFU3eHpYdjNadnp6R2FHYzlDYTRVYmVTUXVJWENDUW0va3hmbkNWL3ZvVzAxbEptbWFzOUhMZWVmdHRpaUlTZnBUV3BIbStMQWVOdFl6SEV4N3Q3dkxPZXplNTkvQWhaVmt4R0t4eStZbnJuTDl5blN0UFBjK1ZwMTdrNHBWcmRDOC9nVmpwby9zcG9wbmpiOXlpZVBDSTcrL3M0cktFODJmUGtDVUoxanF5TEVVbktXbWFZcTJsMSs5eWI3TFA2M3MzNDZVaFFHY0s2MXVXakd3VkdJVllJSENXeENnaDRscFd0ajJLYm5ja29YVVRVakw2SURyamFXcUxMUnptb0dKMFBLVnBETTVhcEJTb0pLV3BHOHJhNEJMSmNMTWJTN01FOWljVDNOeVNLWVh6RVNGUTFBYXBFNHJhY0RpZWNQbmNLb05PamxJSzQydzBRRkt5TlNSVkpFcWhsUmlDV04wYkYxOXRqSjF6RWlRZmpRd3lqNkMwMDdwS0tvQmNHMmI3bjc2KzhzeGtaaTdNeWlZcWx3Z1JnWHRDdEVJTEp6ZmNZaTI0WEE2MkVwNVNpY2dCYnh5SlZ0aWdlRytucG00OEc0T0VQSk5ZRjROclZudXNFMXpieXBBNmVuMDRGMW96elRqbUZRaUVrSWpRMEpRejBqTlBvN09jYWRsdytmdzJSN3VQdUhmL0FZRjJJWllrYUtWYm9LVkFLclUwNlN6TGtrZVBkcmwzN3dHMzc5eGpWaFQwK2owMnpweEJiNTJsMk54bWZ1VTY1cW5uOE5lZndaNi9nS2hLWmc4ZUlNOXNrSFZ6Q0dDZEpjOXlUTk8wYmxxS1VUbm5kMjY4enJpWUlvanYyd0tmdGVDNSt4QzFoNzJQQ0dEWjBnWVcwNnhBN05jV3pyOVNuS1Q2c05pOHR5V1VPV3FZellwV2dTWEVVYnBLYUdwRFVSdDBONkcvMXFFMmxzWllpcWJtd2NNUm9RbGtVcmFVNkhnREdldlJJdEROY2pwcGlpUStYNUlrUzlFKzFTNk5HK000bmxScWJ6VC9qZHJhdzFON0VmK2hENUI1NDdoNFpkQ1dPMzRaSUVLUVRVcnJ2dkQ4cW5qNTh1QXpqdzdyWkRJejdhdytvTFZHdGJnc0NFdjR1RlJ5aWRKZHJGcTEwaTF5MWxNVk5WcEswSm9iZXpYM2p3eG5WMU9HWGMxZ29EbWNHWDduclFsU3hLQkpzMmpBczBBTCszQ3krMWRLRXViNzFDR2hmL1k2eDlPUy9xREhSaThoUGY0QnJxa29yY1FUMGJoS3RaS2dTMUpYcTkrck5DSEVwbnB2LzREYmQrNnpmM2lNVW9wTVIraU1USFBrY0EyMWRSR2VlQVl4WEtlc0c2cW1SR3VCRW9xcWFtTGdDc0c5dzExKys2M3ZNaTVuS0NIUVdwSm1DYkk5aU00RmJJeDRRbU1SSnFLVVhXc2NGTGZsc2kyeFR2QzA3YndrQnNjU0ZCcFFjNWdkekNuS011NVJBS1ZVSE5zNlIyRWRPdGZrL1JUblk5WnBpb3JKcU9Kb1ZGTTFacGtWeXJLbXJodThoelNKa3FyenNpSUkyVUtIRm5ZVmdkckdrcXVzbXVKZ1Z2N2pzakVIcDVhSC9pTXh4ZnJpbjdyRU96ODR3a2NvN2dMbGtJVkFwM3UrMS8rem56dnpwYWZXODk3dHZZcmpTWTJVQ3p0bnVWd2FXbXRCQ0pUV1MwOTAxZnFqUnh5UmlqZW1jOVJWSFJkM1djS2s4cnh6djhTNndOYUtacS8wM0RzeUpDSXdLanlsaWQ3b3E4T2tSZnd1bG9aeFhDd0kxS05IaU40NWt1RVo1bVhEaFlzWFVNVXVXK2FIZEpTbGNvS2FGS1VTZEpJZ3BFQUt1U1JzaFZaL2RLRndqNERKZE1iOUI0L1lPeHFSNTEwNldZWnVwVUcxVnVUcloraHZua2RsUTV4elZPVWNnc2Y3d083NGlLKzg5VDNHeFJRdEZaNFFEWGp5Sk81NlBLMWxSRHVxYmR4eU9lamtpWFJydE1EMnl3TzVvQlF2bG5xQzl1ZjFFSTQ4bzcwSlRSUFY3cjN6VVYxRlJPeGNhUU5wUjlOYnlYRE9ZNHlMUkxEU1VOZUJlVzBabHpXZFUzc1JyU1JhNi9qM2JIeHRqZlVZNTFGS0xiUGMwV1RPZzcyeDl6TDUrcXlzYnJVQjBueGtBdVRTazZ2VWxSUFRjYjFZR0taQzBKTks5UDdjdi83eW56bi83TWJuejh4SytlVDVyaGpQSGJ0SE5kN2JCVUM3ZFlIeVNLVmFsa2JFYVVYRUtNdGJlL0hCT21jcDV3MjJkdVI1U2hNRXQvZHJSbE5MRWVEcVZzYm5yd3pZNkdsV3U2cDl4a2hMWFd6MExYRk1qQmY0cHFTY0hUTzQrQW1tbFdPNE1rVHFMcU83cnpNVVk5WTdGYU91cFJJZXJFSUpmVkxQYy9MekJlS3lMTFMzcjlJSlVpcUdneUhyWnpaSWs0U0ZLZ2pCa3lRSmcrRWF1ck9PUTJPYWt0dVA3dkhOZDk3Z3VKakc5eUlFaEZhb1ZKTjNkT3dwVG1QOFd5ZGZSR3VhSW1XN0RXMHQ2SnhmL3B6Qit5andIVVJiYXNaL0VwcUEyWE1jSFl5eDFrYVVnd3ZJMXY3T1drZnRBNzErU204MXcxcUhhUWN1eGxoc0UvMVlsQkFNODRSVWE3UnVmOVkyMi9vV3hXRHR5UzRNWUR3dHVIRm5sL21zRXM3NzN5MnNmZlVqRlNEUHZYS0dkMTQ5WkhKY0MrLzhRcHUzQy9UKy9GOTU5dE9mK2ZLbHZ6NXliazBmbGVKOEpuam02b0RqcWVYZWZoa0ZtdHNTSzdSdm9QTnhndVVXckwwMkpjZnQrNktzQVdOZE5NK3NJelJjYWNXamtlTzkyM015QkZvSXRHeUpRaWJRbU9oQklxWEEyTWhyQ0Q2MFVxVUNWeHpqU2VsdVA4SGhhTTdscTFjWWo2WVV1KytnUThDSW1vZk1HSmU3V085SVpJNFNFZEVhRmx1WTl2QkxJWkZLbzVPRTliVjFucmh5aWY2Z0R5cjJFRklJZ3ZNNDY1QUNldDJjd2NvR3FydkJ1QW5zSEI1UUZoUEFJNVJBSjVva1dWd2U4VFVRb2lscWxHY05OQzdDOVgwcjF5SmJDSDFqMjhISHd2alUweHFkaGpiREJFSUo1c0J3ZURTS1czampFWXVkUlZ1ZVdpbFlXYy9KdTNyWk94STh0ckUwVFJRYVh1dG8xcnVkNWRBbFRSS1VqQTI4c2FiZDJjVHJ5bHBQMWNTeDh0SHhETy85dkhUdXYyb0NONGtVM285R2dEei9NMXZjZU9OUVdCdGtDRXZJZSsvaUV5dmJmK0d2UHZPL1ZSbWZPaTZkSU5Wc2xJWnVJcmk4bVdNZDNOdHJGMm1pRFFJUnl3K0lTNmhVYTRTQUpFblFLaUVzK3BFUThENU9kV3pqS09ZMXhycTRZZGFLbmYyRzl4NFZqSXVJY2sxMXUyME9vYjBSUGJZOU9JdXlBd0xWZUlmdXhsVk1za0xleWVnTjFuajB6dmZ3elF6Vk9FWkJVbmNFZFpoaS9CUm5ta2h0VmVseUR5RmF4TExTaXJ6VDQ5ejJPYmEyTnBGSjdGOFE3ZmFiZ0drTVZWMVRGQlZOWXhnTytsdzhmNFZ6VzVmQkM2YnpNY1kzMFpleEZhcEdSZ1prOUdsY0tNTUVqSEh4cm1uVkcyMFQ0U2tpUkFLV2lGUU12QXV0ZDBvTUx1czhidUtaN1paTVp5WE9leXJqRnRvK3NZa240SlZpODB3WGxZbWx3MWZUbVBhU0NtZ0U2M2xDb2lNdUxFdDB2TlJDdkQ0aTM2VmRCcmU5bkpTQ3NqWWNqd3Q4NEU0WitIc09qbG9Rb3dIY2h6cEEvc1JmZnBKaTByRC9jQzZ0OWRIalV0QlhXZ3oreGIvK3dwL1p1anI4Sy9QQzVWcEtYSzVaRTRGc1ZwTnF3VlBuZXlSYWMzdTNvaWdOQW9mM2p0WjVZT2xNR3crRFdKWUtVa2tXbG00UjBoVnZ1TEt4VWRKVVJFK014c1BENDRZYit6V2ptVzNoM3ZIZlJRMnVzTlRZaWpnbWdiY1YxZVNRd1lWbk9ab1pMbDI2eUdSU2Nuei9iYkFXVXhrT0hmSDVUY25vNkJHanlRN3pZb1JFa2FZNVdxY1JWcDRrREFlcmJKL1paakRzeFlGQVd5NkdkZ3JscldVK0w3bDE1eDd2dlh1RGc4TURyRE9zcjYxejdlcXpYTHI0REhuV1kxNk1LYW81aU1pNnhCT1pmVGJxZENrbm9EUUlHNzNVblFzMDFrVVJ2aEJvMm8zNVlrZHRiWndJdW5hUFpBOHN4dzhubEhVZCs0MFcxR2hEWExSYVFDU0s5YTFPOVBOdXNWWk5ZMmdhUzlOQTZxRFhYZ3hTcVJnb0l1NjZ2QThZWjF2VVJLd2FGdjNid1dqS3ZLd1JVbnkxaEY4TE1PTkVYdWpEblVHdXY3RE8yNjhlaU9tNGtZUW9HZ2YwUHZlTGw1Nzl3cCs2L0grZDFWd3dOcENvZ0ZhZXFaZXNUaXEwOXlndHVIYTJ3N20xblBzSE5ZZVRDQWlNd1NHWDhQRTBUZHZKalk5OXltTHkxWUxqVHFOWHJRczBWVU5aTmdUbjRxSDBrdDJ4NGVham1rZEhEVVh0Q1MwVVE0cG9LcXBVTktQeFFkQk1EaENxUTM3bUdoN0IrVXRYdVBmT2E1VFRBN3BDVWs4cjlxdkluN0RHVWMxbVRNYjdIQjNlcDVpUGtUSWhTenQwdW4zVzFqWllYMXVsMjgrV3QzNGtTVVpuSGhFOFpWSHk4TkV1UjRjSDdPL3RNQnBQbU03bk5OYXd1ckxHdFN2UHNyMXhtYUtjTVowZnhiSkxxT1VrU2dDK2R2aktZQnNiRVFhME43K0owQTl2L1ZMMXdqWHh6NXhic0J3OTdzZ3kycDlTVncyRmNUVFd4MWhxN1lwcklPdG9odXZaVWh6Y0dOdG1FSWVwUVJuUUlhQmI2b0ZTQ3AzbzVlY1cya3dTNVpwOGk4c0w3QjFPOE00MVhzci91dkRoZDl2c3NRaVFEKzhlSk84bGpBNUtSb2VWOUhZcDJOQlhpVno1Qy8vcjUvL2x6bHIreTBWbFZhWUZXanNrZ1ZrajBiVmx6ZG9JRHdHMjExSXVuK2x3TkxjY1RnekJ0K1l5VXNTTmV6c2FsSzFycDJ1bE9ZV1U2SFlqSDBMVXBRb0wyNFFRYUJwSFdSdWEya2FCYWcrVHVlUEJzZUgyWWNYT3VHSGVCTFNFUEkyVGw3cUtCMmQrdk12Z3pGWG1QbWQ5YzUwUUZBZTNYaWNFUnc3TUp4WFR4a1ZjVFdQeGRkVE1IWStPT0RoOHlHU3lUL0NlMWRVdFZvWXJEQWFkNWZoNjhUb1dsZ1Ntcm5tMHU4Zk9nd2ZVZFVXV1J3dTIyV3pPYUhSTVZSYWMyejdQaTg5OW1uNitSakdmVVpSVHJEVW9JZkRXWTUyTEpZenp1TFlSZGszTUVyYUpDRjVUVzJ6dEtJdUl3WEltVUZVR1UxbzQ5b3lPeGhoaktJM0h0QnBrQy9xZkFmb3JLYjJWTkU3UHZNYzBEWFZqcVp0QVUwYmRnRlJDcjVQUnlUc2tTVlFoTTlaR1ZROGgzN2ZFbEtJdHIwWXo4T0ZoSS9qL05DSGNhYmtpellkK1VhaFRGUnR6NjJVNGxUMCsrK1dMeno3em1hMi9GcVRZVmtLUXB3RXRQYmFKQi9UWUJiWURKSzJNWndEV0JwcVhyZ3p3WG5CN3I2SnVMSWc0NWwyUVNVS0lQSkxGZ3RHMUNHSHZQUzY0SmFwVmlYWU9KdUtIWnJ5bmJpeFZZNWNrS3c5TTZzRERvNFo3UnczN2t3YnJQRmtTUjg1Vk1hTXBKcXhlZklIS0NxNWNmNHBIZDk1aGV2QUFId1NyV2pCMG5ucFNNaStiZU9PMk5OY1FMRVU1Wm1mbkRyczdkMWxaT2NQRmkrZFFTWVRkSlVrUzl3c3V3bXp3bnRGNHlzTUg5ekZOaldqTE02M2picVVvU2c0T0R3Z0JMcHg3Z2d0YlQ5SHZyRE9iVDVoT2p5SXExM2xzdS9EejFtUHFTQkd1cXhyZk9HeHRxYXVHdW9xUWtybzBsR1ZEMHhpU1d1SW5scVBqTWNaNFNoK1dVTnBrQVFBVnNMcVpvNVBJWnpmR0xQdWVxdkNZMW1zbEVkRE4xRko3WU1FRTlZU2w0cjRQN1NZOXpUZ2N6WmpOUzRMZ3JUS0UvOHJESVNjNlcrNUREVFhSaVNTNElMeG5rVDE2M1o0ZS9zcS84dFMvTk5qcS9wSUlhS2tDUWdhTUNkUjFvQ29ETStPUkRqYXNXMmo2NEd3Z1VaTExaM0k2bllSSEJ6VkZhZkhPc1pCU0VJQ3hacmtic2NZdUoxNkxzbXh4TzRmV2V5TkxFNVJXZUJHRnF4dm5LQnRMWXh5KzdXbXNoYjJKNGMySE04YUZwNmc5c29XaEpIa1h2WHFCWHI5UGt1YmNmL3Y3TFZmQ2swckJVQW5XdEtTTElKZVNUQWthSDFwdWZHQXlQZWJnY0k4bnJseG5ZL05NaTh3WGREb1p4cGpZTHdtb3k1bzdkKzh5blUxaTZTZ2tPbzFMd1VYelB4cVAyTnZieFZuSDVZdFA4c3lUcjJBYXgvSFJIbVV4d3pVRzI1akkrYWpOai96ZU5oWlRHM3dyVG1jYVExblZETW1aandvbWt6bkdCNnBUa0FqVm5sS1pTRlkzVzA2ODgvaDJYMVBYam1JZWNQYms3MmV5SGFjdmxPVGIzWkJvaVc2SlZnZ1JTK2Fkb3pIV091Y0Z2MUVGL2lteC8xZzA2T0ZESFNEYkYvdE1qcHZJSkJSeGN2V1pYN3J3L0l1ZlAvZC9Va3B0UkVld1dHY0dIL0JXVUZjZVUzdDJDMC9mQnJxdGErMkN5eUVUeWFVek9VK2M3WEkwcyt3YzFWSFFJTGhJa0hMeDhDWkpndFl0M0p0QW1xVHROTXBISUppTUNpYytSUFBOYmhyQmMwcEtQR0Njb3pLT2VXT3BHa2ZWYm5Qckd2Wm5sb2NqeDk2a1p2L0JiYzVkZnBxUTlybDQ1U3FIdXp2czMzOEg0eUtNMnpxUENKNnVFcXdvd1hxaTZLcjRQV3hicG96R1Iwd21ZMTU0OWtYeWJvK2lxdWwyY3FRVVdHdmpvczQ1SHU3c3NiKzcwOWJyc2RkU1dpOE5QYVdVVVFqT0dvNlBEbkhXOGNTVjU3bHc3aW1jOVR4NjlKQzZLbU5HTlJacmJEUklkUjV2TGNGN25EMzU4NlkyS0MvWlNBZnM3QjVSVmdiYlh0M3FGTUhIQXAyQnBqZlViWG5sMmhHeVkxWllxdUtFa3hPelRpQk4yaWE5eFE4bFNkeUx4TUdMSWswMDg2TGgrSGlHQ0dGbWhmalBHM2l6TGEvcWp3UlljVzB6RjlOUnJRZ2tDTHBDaXQ3UC92a24vc0taOC8wL21hc2cwdFFMRytLRXlabUFyUU5WRmFIVm83bGwzampPZUk4bW9IV2M3Q3dzbk5lSEtkZk85VEFPZG80YjZ0b1JXdjFidVdqZzJ5MnhkNEVzUy9IRWhWWk03L0c1ckk4YjNycXhnQ0RYaW1HV01PaGtTS1VJQVNybmFkcmF2Ykt1cGFoNnFnYjJqd3Vta3pGUFB2c0MzY0dRTk8venp1dmZwcXBtcmRhVmI1ZHhibG1XOUpSZ0xkWGtXbUphZHQzaDBSSEQvaXJYcnoxRFpSek9CMWFIUGNxcWp2QVBBcFBwbkFmMzdtT3RhUzBRT0FrUUtkOW5EQlJDWURhYk1SNGRrK1U5cmw5N2lmUG5yaktkVEptT2ovRE9SbkxVUWlEYys2V1QxMUpnb25ac0R6WndkZURSL25GYytyVW5VNTdpWVRnQnZZRW15VTVHdGNFSHl0b3ltNFpvM1gyS05aY3JTYmVUUmNFNTFjTHlXOGRnS1FSSml6UGJPUm96TFNxazROMHE4Sjg1MkcrelIzMEs3czZIdVFjUjFkekd4V0NnczdIZDNmN3NuN3p5Vnp1ZDVJazhDd1NjbUZRQmE4QTJBVk5CVmJtSTJhb2RveVl3VklLZTlValpHbkxhTnRzRUdQWTAxODkxNldhYWg2T0c4ZHppVGVUVGhCQWllTEdGeFVmRWFydnJXSTRWSXdaSnQ2U3EyamlxeGthSWRZQitsbkIyMktmZnlhT0NDdEZIbzdTT3lqcEthMm1zNDJCdmo3Tm50M25xMldmUk91ZTlPenU4YytNOW1pQ2lWMGhMSTQ1bW9xM1lYWWpXREdmeWhOVXNKVldCK2VTSXk5ZWVaMzFqazlHMFlIMTFzQXd5S1FYT090NTgrMDFHeDBmTFBZRnU4Vit4MURxaFR3cG9OWHNEeFh6T2RESmhhK3NDTDcvOEJaVEsyTmw5Z0xWTmRMeHRWYjlGMUxIQ3U4aFRUMlRLK2VFR2ovYU9tY3lqWUYxMTZxREx0bE5XaWFBN2lOejNCZml4YWh5VHFhZDV6T0ZBQXgwTmVaNlM1eG1KMW0ySkZlSDdFYjBkQ1hLN2g1TmdyUXRlaVArdWhGOXZzMGV4R085KzZDbTNkV0ZsQ0VHSEVJVWFyankxZXUycFQyMzl5MmtxMTVYeW9yRlFteFpPM2NRZ3NYWFVoL0ltVURhZUl4dllEcDZrM1hCSHRtSDA1ekEyWnBaemF4bFh0N29JQkFjVFExSFoxbm9xamppek5PNGRhSVhSSUM0RG5mZjB1ajE2dlI3ZVI0S1dEVkg5dkxaeHdqVXBhMVFJYkhRN25GMFpzTnJKU0pURStrRHRQRmV1UGNubnZ2VHpiR3h1c2JxeXd0dHYzK0RXN2R2Y3ZYZVB5Z2ptVnRLSUZCTmtGRVl3bmlZcUQrSkRiTTYyZWgxZU9yZEdEOE9EVXZQY2N5OVJWTkhoYk5ETHFlb21Jb1lGM0xoMWl4Kzg5U3F6K1pTcXJxSU1xVXBRV3FOMTBtWVM4YjRnVVNwbW1QbHNCZ2llZWVZbE5qZk9jWEI0eUhSNnZFVHdodEJPdVZ3Z2VNblp3UnBGMGZEZ1lCUXZwVFo3TE1CMEMwcGZyeS9vZENQZXpQbUlvNm9iVHpWdlA0YkhlTmVaRkdScFhCZ21pWTd3R2ltWEVCd0NUT1lGaDZPWlVQRElJUDZqQm02Y0d1L2FqMFNBOEg0dHJPN0xQM2ZoNVkyTGcxL0pVdEdMS256UkxzMllLTFBqMnRtaE16NHVycXhuWmdLTmhXMjUwTWhkd0RhaTFLaHhvRVJncGFPNHNKbVRKcEtEbWFVbzQ1Ukx0RHVGaFNqRUF0TmxYVnlDYVoyeXRibk94dHFBWWI5TGtxWTAxdUpDQkN0YUg2Z2F5N1NvbUZVTmtzQktOd2FKRVpvLzljdC9odTB6RjluZDJlZlY3NzNLM1R0M3VIWDdQUjd0N1ZJMWpzWUZqQk5ZbVdCUTFDU1VWbEEyQXVOYlFLVDNwRnFTSkpwWDcrenp6UE9mb0Q5Y1lWWlViRzJzVXRkMXl3UUVZeXp2dlBzMlIrTkQ1c1dVOGZpWW82TURpdG1ZNEgyVUdjcGllVWliTVJlQ0Yxb25XR3NweTRydDdZczgvL3dyekl1YVIzdVBDTzB3STRSNEFYVmtCeGtVOS9lTzR3YitWRmU4RU5nTlFKYkJjRTIxMnNpaDdkODg1VHhnYW41RVlrRUNIUmt0cVJkWlE3WHcvT1VVeXdlT1JqT3F5b1FnNUQ4dTRMOXBsNFB6QmJ6azlETi9LQVBrQzMvNkN2ZmZHd3NFQ1RHRGRGLzYvUG1mNjI5MmZpSExaR0t0ajNBR0M4WkVGMlRud052SVhURFdVNVlXN3p6SE50QVZzQ1lDaVk0M2xmZEVMdy9SV2hOb1FTZFRiSzluYlBSU2JJQlo0V2dhMTVZMTdTS3EvWXFMcUVCUkd3NUdVeWJUQWlVay9UeGpmZEJqcFplaFpRd3VGd0sxRDVUT1VWUU40NkttcUJ1c2N4enNIZkR3M2gzMmR4K3l1L2VRaDQvdWN2L1JmV3ByYWJ5bnNySFJuNVkxODlwR3BHcVFHQ2VwbmFiMGlya1RUQnJQcUhUY2VIVEVZR1dONTU1N2dlbThZdENQNHRGbFhhTmEwdE9OR3pmWTI5dUpjb1RlNDV1S1lqSmlmL2NoQnpzUG1VM0dPR3RJZEVLU3BHMmZJcEZTaGlSSlJaYm1FQVFiRzJkNDRmbFBNcHVXUE5xNWovY0c3MEJZaWZLYW5kR2NwaFdYWGdUSEluc0lJTlV3V0pQb1ZDNVB2M1dlcWdpVXMzWUF5UWNFaUpMa2VVTGFqcXFWaWtjODlvZXh1ZDg5bXVLOXYrZVUvTHVWOCsrMndmRWoyZU5ER3lBWHJxK3djMmNxUXdqcElrQmUrZEw1WDk3ZXlqK3JkQkRCQmJ5WEdCUE5iWUlIWTJLekhqT0lweXFqMXBUek1Hbzg1N1NncnlPOE5EYUM3WTNYcXJzTEtlaDJOUDFNc2RaTDZHYVNhZVdZbFhFQ0ZVRjdEbXZkc2grZ3hTR1Z4aklwU282bU02Wmx4RzExdEdiWVNWbnQ1dVJKckpWTkNKZ1dyeVZDb0ppTk9SNGRjbkM0eDlIb2tNbDBFakZndkYvUXlZZTRrYTlNSENNWDFsRTZUMlU5bFlWcEE2TzV3MGRTUEMrLzhqTUluVkFVTldjMlZpaUthdm1jUjBjajd0eDhCK25zKzdRNnBmZll1bUowZk1qK3puMzJkaDR3bTAzS05PL2N6ZkpjNnlUTnRGSWlTVks2blM2cnd5Rm50emU0Y1A0S28vR1Vldy91RUdxUGIyQlNSdzJ4c0ZnMlBOWjc1Qks2SzVJa0YxRXFTWUJ4Z1hMbUtXY3NXWm1QbHhNUnhoM0lVa1dhWmt1MXY3QVlNUGpBMFhqR2RGNlZVcXYvYk9yOHI0WEE5TlJ5MEQyZWx6NlVBVEk5cnFsTHE0S1BKVmJhMFN1Zit2bnp2enhjeTE2d0xqTDNyQU5uQXFhSndFQm5JclRCKzRqL01kYTNHMTNQdUhLUmVKV3A5bVkvMGEreXJUMmJYenJUUmwrUFlTZWhueXVNY3hTTml4dmR4bU5hTUo1eEM1cHRmTmN0OGZlTmM4d2J3N1NzS2FwSUxVMmtaSkFsOUZOTkoxSFk0R2w4aUxkcEN3dGZITlJ3NmlDZERwVFRwVW5ya2JITU1xV3hsTVpST2MvaGVNeVZ5MWU0ZlBVYW8xbkIyYzIxMk5NMWNUTWVQTng0NTIycTZmaDlGTTNUQjlGNXo3eXU2djNEL1Y4N09Oejl1MlZWZlUvcnBNN3pUamZMOG02bjA1Rm5OdGZvRFRwc3JLL2dqT0xXelRzY0h4NVR1WlAzMG45QWNLUUNzcjRnNjB1TWp4ZEdiVHp6U1loOXg0OEpqcVVZcjJpVkxGdGFyMVF5bGxwU01wdVg3QnhPZ2tmK2VvWDQ5eHZuRGpqQlhuMTBsQlhyMGk2eWNRcDB1c04wOWFYUGJmL0o0V3J5VkdORE5LdngwUUtzYmp4eGxSRlZTRVNBdXZMWUZndGtqYU9wTER1VEN1VURaM09OMUF2K05FdnVnL1VoQmxvSUNCa1J1cjFPUXIrajZhUWdoY2NCcFJOVTdtUmt1WGpYRjRXdE8vVjcxemJzczlvd3FSb2E0NUN0V0hiWjNyQ2MrdFRFQi96MzhTLzVZLzU4Z1Ircm13YXRGWi85ekdkcGxWa1pEcnJNaTNxcGFYWDc5bTBlUHJpN0RMclRwbHMyWHJYN0Z2NExELzlKV1pYMzluWWYzcmg3NThZM0R3NTJ2OTN2OWMxd3VIcHBZMk10ei9LVVhyL0xiREpqOTlFKzl4L2RqOHJ4cDRKaklZa3BpUWM3NjRQcVJRblQyZ2VhQnFvcG1HcFpoWDFnYWJXOEtBSWtJcEFraWs2ZW94TzluSjd0aldmTXF1WmhFUEwvTWJmMnpiYTArcEhKMVljK1FOcU11VFRNT1h0NWNPYXBsemQvdFQvUUY2Mk5ON2czMGRYSnR2TjRGY0NiS0g5WlZiWkZrdnFXRnhGTHJydUhjMWEwWkx1YkxFK21iMHNsMzJhU0pYVzJkWmpLVTAybU5WSUUrcW5DU1VrMzhTUTZMTE9IYStmNXB3V1hsa0d5eUM0dHkzQ3hGMWxraXRQQkpUN2dOditnZy9KNHdQRFlkcnFZei9uRVM1OWd1THJKdENnNWUyYWRxcTd4TFN4aE5KNXk4NzIzOGRhMHl2R3RuaElVRnI3aDREOE04RjhEdThBVUtKMno1V2gwZEhEbnpvMjNsRlFIbXh2cmx6Zk9iS3htYVVJNW4vSGVlN2U0ZCs4bXpwcjM5UnVMTWc0QmFUY0doeWM0RzlpdkszNjNub0czZFBsOUpLb1d6NWtDaVJTa1dVS1N0Z1N4RUpoWEZmdmplZUc4LzN1Rjk3OFdZTklHeU9tOVIvaW9CVWdLNU9ldXJweDc0dm4xdjVobWNxTXhjWi9oVFNRcXRlWlNlQnZ3TnNLdW5mVlk0MXVMNTBCZFc1cXFZVGFyK09HaktSZFhPcHpwSlcwdjBmSTFGdEk5cmN5L2NaRUE1VU9jOFV1cDZIVlNhdVBwYThjd2c5Vk8vQnJtMEUwZzBUSDF0LzB3aTZjOS9TRy9UOWJ2c2Y4WFB1REc1TEhBRWFkS01mRUJaWWdtYXZxbWFjTExuL3dVMDNuTjJrcVBUcDR6TDZzbzFlUGd4czMzbUkwT0lXWU0yOEI3RHY0akIvOEI4RjFnMUpZbnhTbjhramZHMkZ1MzNyMXo1c3lHZSthWjV6L1Q2WFowc0pZYk4yN3p6bzBmWW15eitIbEN1ekVYWHVCRnlrajJPSGFCVzdiaHYyMHEvdE5temovQzgzWGczZmI3eVBhLytlTm5WNXdhYTZZNkJvaHNRWWtCT0JqTm1OZm1xelg4WFJjRGUvWllZLzZCRGpvZkJlRTRrZVlxVjByMGJjdHNNNjBmdVY2T1hsc2dYU3Q5NmF4Zm5yaW1qdUM1cGpiNGRqL3hQNzU5eUVxMnpXYm5CS3pvRnY0WHhQL2Excytqc1o3S2VMd2tDczRSNVgrQ0RXZ1JFTUtUNlJna1BrUi9FZU1EcFlIU25uelZsbVZ0SGg3ckswNEhpT1JIZzByeXdmL3VkS0NjTHRlRTk3engrZytZSE8yVDk5YloyVC9taWN2blVFb1JnbVo3ZTR1TGw2OXk5KzVOYjUzZHMvQlBIZnczd0Z1UEJjWHB4bGEyaHcxQTNidDM1L1dpbUk5WFZsZTNkSktRcG5vdWhIZ253THFBTGRYYXVIdW9nK0MzaGVEWHF6bTd6ckRuTFkvYXNrY0E5NEFmQVA4WXVBRDBnVDh2NEU4SDZIN2dSZUxCV1lmVE1ST1hWY09rYU40emdmL0V3c05Ua0pJZlcxcDlWQUlrSWlDOER6STQ3MXZGQU9kaUtTUmRKUDhIMzhxSkNKWVFDQ1VDNWJ6R1ZpMndyalk0NjFBQ2JoM1ArWDkvZjRkLythVXR6dldTNVVUTGhraDJXdEJNalF0dDJSVTVEeTRJamt2SFJoWmFZV3hPS0xFaExzeTBqQ1ZBUjhkbTFRWXdIaG9IOHpvR1NtMmhhY1d1M1dOWlpwRmg1SThwczhLcFR6dzhWbjZkRHFqZFI0OTQ3ZFh2OHZsZitCYzRITTI0Y3NuVDczVVlUd3o5UVkrbm5uaytmTy8xNzMvdDhIRHZINFFZR0x0dFNUSS94WmR3UXNRdUxZUWdUcDJwZEc5dmQyYzhQcjU3N3Z5RnJjRndRSy9YbTNmeTduOCtMNlpId0Jid3JJTlZEKzhGenoveUZidW5EdTJpTXZXbmt0K1VDQWZwQUhjREhBajRpOEJtU3pBOEtUR2xhTTFOSS96bmVGcE1qUTkvejhEM09MRSthQUF2MysrQjlJSDl6WWM1T05ybGo3Y3VoS1pwUjduUlQ2UE5HcDZvMjJROTNvWldiaWNLS1p2R1lwb0l5MjdxcGkyN0lKR0IrK001Zi8rMVhkNDdxcGExbFdyM3lDN0VzV1BUT01yU1J0Sk80NmdyczhSSGVVSXI2Qnd4U0JIbUhyRkl4Z2RNcTI3dTIzNUptQmFTckdBbGdZR092ODVWYkY0Znp5VHVWQS9qVG8xTFQvY3NwL3VkeHh2OXVxcjRuYTkvRFZ2UGtWSndlRFJoT09nanBFSW5DZGV1UGhGZS9zVFB2TjRHeDdnOVdJdVJhQzJFc0ZJcTErMzIvTXB3MVFzaFRyVXFtQnMzYis0ZkhSMisxalExVWlvNm5VN2U3L1lOOEc2QVh6Znc3eGo0bXc3K1BSODMyV05pWHpBNTlldnBxZDh2L213RTNBZitud0grVm9EdnRDM2g4dkpZdk5JUUFrVlorcW8yWDJuZ044Tko5bXNBS3lOak1JU1BjQWFKTDBKTDVUM1NOZ0hiZUt4cHVkQXRQMEVHbHFVVzdlalVHb2QxSWJMYm1vZ3diVjBmNDhUSHc2MkRnbjlRNy9HbnJxL3ppWE05Rmp1cmhRdVViT1dCckhGTVM0dnhnVTRpRWJTSTA3RFl5NGZsSEo0RjI4NUIxY0E0U09pbGRGYzdrQ2k2dllRMDE2MW9TTURaYUp0bVRmeFpUV1d3amFjdUcyd1p5MFhYY3NQOWo3bEJ4QWVVWGtvSWJ0Kzh5YTBiNzNMMW1VK3dmemptN0prMU9ubEdhUzFyYTZ2eStoTlB2dkxkNzYzL2Q4ZWpvNFVuZVhQcWhnOUprZ1JhNStBUVFoQkMrQkNDQTB3SW9TNW0weDFyYkUwbnovSnVGNTFtL2xTSlZweHFrTzNwV2NVSDlBVGlGRHlyT2ZWemZBMFlCL2pyd00rS2FPQWxGa29tTG5qS3lyeFp1dkFmT3RnNUJVWTBSTkYzTWlDVE1QTWZ2UUJabHRYT2htQnR2RE9yeHNmbFhvdjNqcVBUTm9PWXFPUlJscGI1M0ZLVmhxWnFzTzNTUXJYdWRXRWhQQzFnZDE3eDkxL2I1ZVpvbFQveDVDb3JxYUlJanJxSmNCWGo0dTZqTXA3ZG1hVzBudldleERWUjYxY0tFZW14THVCQ0ZHa3Vxb0R4QW5tbXp4T2ZPc3ZHaFFHRDFRNUpKa2xUdWRRTGhrZ1FhcG9ZekkzeDFJMGpHRTlkR0twcHpleWc0SGluWUhKUU1wL1UxS1Zkb21oNXJGbGZzUFFDVVdtK21zM2MxNy8rdGVMYVU4OTNSL05HemVZbGF5dERxcktpMSt0dytkS2xaNTU1K29VcjMveG5YNzJ6ZURvcFpWZzhBTEs4dzlIUndmTGJDU0ZjR3lUMmVIUjgxeGd6VHBKa2EzTjlMU2dsRitYTnZBMlUrbFF5REk4bGdjY0Q1SFN5dEtleTFlOENqNEF2QjNnWitFd2dYSGJXMFJoL2YxcTdmNytDMTl2dnVlQjZlQzBJN1VDU3VmL29acEFBaE1aNDZ4eEd0ZFlFenJSOVI4c1Y5eTNqcmpFT1V6dnFNbEpBNjZxaHFwcmxocmxsMEVZbGs1UldJQTBDanEvZlB1TFJwT2FYbjFwak5aSE1heGVPcHRWb1Z0bFIyZGhRT2Q4a1VzMHFHNTU5TUF2OVNSbDdET01EdFhQWVZtSFFlcWdkbkwyMndvdS9kSVZMVDYvUjZTcHNnRVRKcFpJSG9YVnBFb29RMGhiQ0VpM2NuUE90Q0lKRE9JK3RMT1A5a3NPOWt2MUhNdzd1VHhqdkY3Z3Faa1hIeWV1S20ybUJncWtqZlBPdHQ5KzZOVDdlLzlOWmYvUFMvdEdFNjFmUG83UWlaRm5ZV0ZzYlhMbDg5YVh2ZlBjYjM3RFdxbFA3eWxpbTFkRTYrdlRuMGVaSkM5aTMzMzdyMFpkKzloZEhTcC9mNm5RN1NacW12Vk1IZTVHVkhnK0lINmw0cmtHNHRjUUZ2MjlLdm5pdXU4Qi80ZUMvcXdLdktCditWUk9jYlFML2NPTERWMC90TzJvaVFkSG5Xb2JDZU9hL1gzWHlFY2dnSUtUd0ZvRnNPUkkyWm9NUVFQb1ExOXJFaHIycWJMejlUU3l0bkRVdGl5NSs5TXVOdVlnUWg5RGFWNkVDdDBZei91SGJocTMxSG9sS2JoODhMUC9qeWF6WkNRRnBmSkFPK2FuR3VCZHNPSUZtZjlBanlSVFhYem5MaFdzcmRIT0pWQUlsSkZuclhlRjhET1lURFZ3SklzSm4raWtrMmpPWkcrcGEwWkVaUGpIa1dyQjJ2c2ZsNTllWkh0ZnMzcDN3OE4wakRoL01LT2NSWEpsbEFtcElwYUtUcDgyOE1kOS90TFB6OXYwN3Q1NTQ5dVd0QzBmSFUzbjVncVhYNnpKdWpPZ1Blc21GY3hlL2NQbnlFLy9vNXMxM3B4R2U1UmRFdi9DWC90SmY0aC8rdzMrNGZGMXJxNnVNeG1NZkZZNUNlT3V0TjNlS1luNHpTWktuKzRPK1ROTlVudzRFSVVSSTA4elhkZjNqcHF3QTNQN1J6L3p4RnN5MGg3ODA4RThubmxlRER6WkVDWi9GLzZ0UDdXM0R6UGcvV1BuK1lZdUt5eGRXdWZ0ZzlMNC9LNlpOV1pWK25Bb1puV0xiRFoxb3NTS2h0TEZ6YkJ6emVVTXhyV2lLQnRjWXZJbmpvaWpoRXlkTkorNjJweTBMSU1za0lkVWNDWVd0M0xmdUhkVGZ4bmtIcUc0bnV6TE0xQmNiVTNhY0Q3L25hK2l2NXB4OVlvaVdDeU1lUVJEUStFQWlGWW1LNm9XNkZhN3pCTFFHNFNMeFBsR2dCNHFwaW1Vak1tb0FheTNwRFdCdE5XVjFvOFA1cXlzOHVqdmx3YnRIakhkbU5NYWdjd0ZWUUVtNW1xZjY2bXhhdnZvYi8rUTN2dmJFVTgrOVpFVG43Tkh4aEszTk5TYVRHVmtuNDl5NTdXdWZlUEdUTDl5OCtlN054VjVQQ0NIVzE5ZUZ0VGFjR09oQW51Y3dIb2UyeEhMajhXUmVGUFBkc2loOUo4LzE2c3JxWm16emhBb2h5QkNDY002SjM2ZFBmcnkzQ28vTks4TEpnaDhOYUIrYitkUC9iOUUzZVJWbk51L2I1djllancvVkZLdmZUM24xMS83UEM3bjlaYXJmdVRzcHBwUG1UdDIwdTQ1MjYrMXNvTEd4UHpDMXBTd01WZEZRRlUzc1BScXo5TG9UQ05SQ09iRGxNQ3dGR05yeUs4MFVTWmFnRTNWc1N2dGRuSjhCZGFJMVcrdURYMVJLUHVsL24rQUFXRDNUSmU5R3hiL0doUmFqNWJFdGpFVVFGVldrRkdTcFpwZ25ERkpOSnhFZ0F2TXFNQytqbllLUUlET0p5aVZKSXBFaVFyd0hnNFQxTTEzT1A3bk85VTlmNElVdlhlYkNFK3RrZ3dRdkE4NTVsV3IxWEtwbC91b1BmdkR1N3FQNzczVHloUDNETVZJS3V0ME9VbXRXaDRPVmM5dm5YaG9NaHIxMk1hc2lkakdJSzFldXZ2OHdxY1c3aFJkQ1dPZDl0YisvZDJpOWMydnJhM0o5YlgyYjkzdVhLMnVOK0hFUWt0K3Z0RDQxMEZ0bWtGUGxWSGxxWDJPa2xFNEtFWFFjUytQL2dOL29ReEVnV2FxNXVENUExWEQxQy84dVNzdlRDVm1HSm9qNjJBaGJ4d1doQ0N5WGdvMzFWRUJSTzZiamtuSmU0eHNETGdvbnlDZ1JoU09TbEt4dlllcytZTDFmZ3VPU1JOTHBaS2hVKzJEOTl5ZDd4WnVMRDJaclkrWHFvTnY1K2VCRDhudXYvK1BBdnJlYVI3Y2x3TkhhR2JUV0FyVU4yQ0JKRWtVMzAvUlNUU2VOcXVWU3gyRFFtVVFyU1NMamY5TkVrYVhSWFVraVNHU0NWb284VFZnWlpwelo2ck42WVlWTHoyMXo4Wmt0T21zNWRkMEVRamlYYXJWbXJaMTg0NXUvOHpYaG10bGtYaktaemxsYkdTQ1VwdGZ2aTYweld6Lzc3RFBQWHdWU0lVUWFRbEN6Mll6QllQaitURjRXd2NmMHUyeWtIejY0ZjZPdTYzTGp6THA0NXBtbjFwVlVuVFpBc2xPQjhvY0pFajRBNXJiSUpMV0lYMGFBVlVyNTFlRXdiSzZ0aFovMEcvelVRMDB1YkE2cEcwdVdLR3JueEt4c2hITitBZVBwQU4zdDFlNlZEWm44WlFQYklWTnhoRnJIMGEyckhmTlpUVEd0bVU5THlxTEcxVEZBRm5UWlZoejlaRmZRTnJPdHl6QkNRcmVUa0hVenBOYlQyVkg5OTQ1M2l4OENRUW9oTHAzZCtITmF5Uy9ONXdWbFpZVDdjY0hScnNFdlByUEI5dVUrUWdxU1R1UXNlQlEyU0h5SW0vaCtxdWhvalZZc0ZRSURVWVp6SVZ6dENLMVdmUHdobFZRb0laY2NjdWVqN3ErU09zcmdLRW1hcDNnWG1PeE1VVUlrTm9Udk5OYmZMb3I1OUJNdnZmUmMybDNkeG51eHViSEt2S2p3M2djOHZkRm85TzZiUDN6OXJaTkRHUHhYdi9xVjhIZi83bi9BZERvQm9DeXIweGV2QWhMdlhQV0pGMS8rMHVyNnh0bEU2b0cxOXRZNzc3NTlQMFIzV2ZkN3dUeitzRU1iQ1NHSlVKYWdXdlBXcXE0cHFpcVczeCtGQVBuVkx6emY4b2tGczdKaFdqV2lOazc0RUZRYkhMbUlzSVAraGZYK0o5ZlQ5SC9GMkdTeldTMGFHZE45MHpoTVl5bW5GYk5KUlRtdmNZMGgyTGdRVkZJc2U0MFRhWmdGODZ6OTFDU2txYVRYeVpDSnhsUmgvL2pCL0w4MjFoOEFEQWZkelV2bnp2d1ZZK3o1dXE0cHFrYll4ejRESVNIdENKU0NYai9qeVZlMkdHeDJTRElGaWFSeUVGUnJsaU1GbVpJa1FwQ295UFFMcmFpMjlTNEtiaU9XcFdDc05RV3lsVGdMN1JMWnVNV2lVa1RwL3hEd1VvS0lsZzlIRDZaNFk1RkszcXlNZTMxZUZNVlQxNjUxTDF5OC9NbDViZFgybVRXRUVCSEVhSzFxakoyLzlmYnIvNnlxcXNVVzJna2h2TmFhc2l6YkpuMERhNjN3M2kvMkZtb3lHVGRibTF1cmdlUlRHMmZPckYwNmQrR2xLNWN1ajc3MzZuZmZjd3RSNHZkUHAvNW80QldMZDBtSWY2NEkvS2tOa0ovL3hCUGMyeC94OEdBaWFtT2xjMTZHRnNiUVpvNCtNQVE2RjljR256d3o2UDVDS21XU040R2RCeU9tUlhUMkxhdllsRmZ6R3RzWWhJdVFjaW5GOG9EUjZscUZjR0xCdGlpdElwc3dJVTBUUktJNTNpbWFhbUsrNHVQc1hWNDV2L1hwOVpYQnIxYU55YTB4b3B4WDJIQnloU0poc0pvd0hDWmtQY1ZuL3NSVnpsOWZBeVhRdWNJcEJUSWFUa284ZVJJUGVMQXVidU9EaXlhZ0luYVhpeUFPQkJJcENGNjBaV0VyRmxGWmZCTUlyYWpDWXVnZ1pKUWhjaUdLVHhkSGxTaEhoWlJDRnFYMXZ4MUNxQVZoOXNJTEw3NXMwQnZkTEdWamZZWHhaQ3FVUU14bjgyNVJWZCs5YytmV28wWDVKSVR3V1phSHYvRTMvZ1pmK2NwdnM3YXl3WFEyUml4dUdSRE9PZkhlamZkdUJpOWRZOEt6NjVzYjI1Y3ZYSHJoaWF2WEp1L2VlT2ZtdkpnYmZoVG8vTStkUnZ4akNBTStTZ0Z5YVhPRjMzbnpMck95Rm1WdHBQTW5XWU00eU9rRHZRc2JnMHVmdUxMMUp6YUhuUy8xTzhrMXJiWE1zd1JsQSsrOHM4L3VveW5Wdk1ZWmd6VVJheFZjcE5LcVZoUk55Q2o1RXdpdDY5SENTeUxlL0VtaW9ubE9xakVOalBiTFI5NzUvemJBVkN2VmVmcmFoVCtubFhyRkdDTzlOYmk2UklaQTJscU45Ylk2bkgxaXlNcHFqMmMvdGMyMWw4NWdna0FsRWhKSjBsVU1zZ1FSQWxKTE9qcVN0clNTSkVxU0tCM05MZ1BMcVZvZ0xKMlpuQS9ZMmtaREdSY0l0U2NZRzFISUFvTDFKQ29Lcm1tcGtVTEdpZG5jTXJvL0FpSHVsTmIvRnRBOGVQUm8rc2tYWHp5N2NlYmNDOFpZdVgxbWxicXhXR3NKeHVmVDJmeitHMisrOWxvSW9Xa0R4SjQvZnk0a1NjcWJiNzdCYkQ3aDB0bkxWRTBsdlBQTG5xS3FxK2JPN1J0dnpTZkZ2YnB4Rjg5c2IxMi9lUEhpcDU5NytybHVNWis5ZXYvaC9lS1BJNVA4VVR4K0tnTmtwWnN6cnhwUk5WYWN5aG81MEFQNncyNjI5WVZuTHZ6U2N4YzIvbmZicTcyLzFNblNKNVZXV2lmUkhVcHJoYmVlMGFoZ1BHcW81elp5UDFyMWpJWGhmZHdPTGd4bFdpWmlPOUlOeE9CUWtVV0VSekhhcmF3dDdLOEYrTzBBZm50ejdmekZzMmYrSlFIYlBuaUNNeEFNZVFKWktnaDV3dlV2WG1MNzZqcmJsMVk0Lzh3YVRxc28rSkJJc280aXpUVGRUSk9tRXEyaUttQS9WZlFTSGZjVldwTW92U1F6ZVJFMzhqR0R4TjdFRlE3UkFHM1EwY0pjSEFJUllwa3FpWDZKbWdUckhFMXBPYjR6SW9Td1d6bi82eUhFTGJNMXpleTU1MTc4ckFscXVEcm9NUmowbU00S0pDaGpqTjNaZmZpdHc2UERHU2MrZm1GbFpTVnNiVzN4NE1FRHRqZTJNZFpRTi9VQ2FCT0FZS3l4RHg3ZGVXOXlkUFRHZEZwMWZSQVh6Mnh1ZlhGajQyenYvb043M3h5Tmo4dkhNc25IQWZMakF5U2ppSmxEbnNvY1BTRVlmUEtKc3k5KzV0clp2N2E5MHZ2WGxCVFBHT3VTaGZobjlQR1Q3YmhSa2lvWjNhQXFoMmtpTUhCeCtGdFlWTVJUdFl6QkJYcFdDRWgwVkFuM0l0YnhzMk5ETlRXdmljaUpPQVRDbFF2YkwyeXVEZitjOTY0akJBaG5FQUk2blJTdEZMMHJRNTc4NGdWVzF6TzZxd21pcTNHdDRMTktCV2lGeWhScEtza1R3U0RUWkZxd2tpVU1zNXlrTmNYTWRiYkVpV25abGt3Q1V0bGE1MGlKU0dKbWNHM1FTOVdXWGtTclpSb0lGbW9mSjMydXRoemNHZUVhYzc5eC9Mb1BZUzZFOEllSGg1TlBmdUlUVHcvWHpqd05JV3lkV1JmemVZbDNscnBzOHFQeDZQczNicjU3WHdoaFF3aTJhUnAzKy9hdGNQMzZkZTdjdWNQRzZnYlcyUWp0ajVxZ3B6TUR4K1BEM2R1MzN2bnFkRHgvZlQ0djBxWnEranU3RC83cHdlSCs2UEcvKzFPQjgvdHBESkJIeDdNRnNIQkJpdXBjUDdkKzhlV3JXNys2bXFmL29qWHVDV09zWERncUw4enJnNDF6SFNHZ2x5V3NEM3BvS2VnbWMvWW1KVlVUaGVTVUJxZEI1Q0RieVZDcnp0L0svNENRc1RGdUdxam1ubURZazBMOGZSUEMzUVdjcVpPbmw1V1NRNlhqQkNra0N0bk5TYlJtVXRXYysreFpWczlteU5wamhFUWtLa0o0bGNDS1NDc2RLRUVuRWF5bUNWMnRzTjZRaE9pOW5xb001MlBYN1VQOFNaV1FhQ3VSd1pPbkFoOGtUa2RSSE8xQldORk93Z0pDQktZemk2OENNZ2hjRFFFWnpUWjlpR1Vlb3ZLeFpESWhCRjlXbFh2bm5UZC82K3pGSjc0NG51aTF1cTdwOTd2VVpSbFdWMWMydDg5c3Y1SWt5YmVNTVFtZ3ZQZXkyKzM2bzZPakFQRHVuWGZZV0ZtbjErbUhFSUt2Nm5LQjIxcTBCVW5WVlBWM1gvMzZmLy9ldTY5L2JYMTFJM2wwOFBEUmo0T1ovTS85K0tuYmcveXJQLzhTMW5rUlRoUW8wMjZxaDg5ZFdQL1h6NjRQL3k4cVRhOExLV1ZBTHQxUW8rSzNwYXFhMkdlMHVDY3RCWjFPem9XdGRhNXRyM0ttbDVFS2dUTlFsekNmd213V3FPc1dldDZDZmF5RG9vVHBLREFiQlh3ZEdPcmtJTXZ5bTRzUFVTc2xVNjB1S3ltVWtoTGRtbU4yT3pscGtqQzgyT1hzMDBNNlNSd2xKNWxHNnpoRmtpMEJPMGtFeUlEU2tHcUxFazFzdk52emxDU1NOSWs3a1N4TmtFb3V4U1NFaDZJU2VDZGIxeVNKRkxIQ1VpRmc2bmJMSGdKTmFTa2J6enpBdkRFWWEzSEdvV001MXB6U2xhaUIrcC8rOWovNTl0SEI3cXZ6c3VaNE5HVmwyRWVsaWVqM3UrcnFsU2QrYm1QanpFWjdjU1VoQkZuWHRWakk2d0FNQnV2TWlpbDVuZ1d0OWVsbFh0VXU4RXFnbVJTVC9kc1BiOTJybTdvNU5mTDlPRUIrcjhmR3NMc1l0UzZVWEpKK25wN2YyeC85NHJ0M2Rqb3FTVUtuMTFreXg3eHRZZUFtTGkxRXUvbnpRSllxZW5sS0o4OVlIZmE1dkxYSzVmVWVxNmxFQTlaQ1dVSXhnM0lXZzZZcW9KaENPUTAwRlNnZkc1OWNzTmxOOUxuMlF4UlpxanVkUEQwbnBRcUpWa0VKMEVxUVpRbldPRmF1RCtpdkpHQ2lOMFhTZWdPbVNxQzFJTkZSSFVYcGFCWWpvck0waVc1MW5WS0ZrdEJKRlVtN1JFelRCS2wwOUN5SkppYnRKa1NjYk5uYXhXY0ViVUt1SloxQkFncThqR0oxVFcxcDVrMTdrWWhZbVoxYXN1M3RIeHcvdW4vN1d6SzQ0dkJvaWxLS1BNL1JlY2JxeXNyVlZ6NzU2WmNYbDVjQUZVSVFCd2NIeXgvaDl2MzNLS3VDRUFLRC9pQW9xYnlTeXAvK0htMncxQUp4R3VvZWZ0cXl5RTlkZ0h6NzNRZW9pQ1ZaTHB2NmVYcTJNWDdqNXQwZFhudnJscGdXTllsV3FOYlNMTFI2dU5aNVp2T0syYXpBR29zU2dsNnF5YlZDUzBtYUpHeXM5TGwwWnNqNVljYUtsdWdReDZldUFWUEdMOWZFUDFORVRtY2lJQVEzMU1KZkVDS2l0dnJkL0Z3M3p5NURFRklpdkxOUnBEbUFTNkIzTmtNUjhDYTZIdVdwSUZPQ1hFZEpVOSt5SGlzcktLeG5hZ05LSjJTSklFMmlYWFBBdFJ6MmdBdVd4bm1rbE5FblVTWlVWbElZUWRVeUVLV00yVVRJNkZnbGs0ZzQwRWtNU09takowaGROcGpTWWhvWEVCU250dEJMeU1iWHYvNjFyNXRxZHZkNE9tYzBuakljOUpGS2hkV1ZZZi9KYTA5OWZqZ2M5b0drSGFLb2h3OGYvc2huT1JxUE9Ebys0di93bWI5S0luVUF2QlRTU1NHdEVNSUlJWXlRd2lpbG5GTEtLNlVXR2VmakFQbHhqMis4Zlg5QlYxMEVpTTVUZlJaQkpxVGc0ZTQrMzMzOVhlN3RIaUcwSk05VGtsU1JwaEdzQjFGQzAxamJHa1Y2WlBCa0tqclBLaUVaZExxYzNWamx5cGtobDFZN2JQY3locGttYVRWcUUzRXlOdE1ueUI4dENTdENSaXhTbmlaYlNvbzFTZnhCZlNzZ1hWVU5NaE5zYjJZa3hxT2tRTW5JVDFmQ2s0aEFxbHNnWlZ2VEtjQUV5Y2c0NmhEd3dxTzBKOUZFd1UwUnM0enp4SjVFcGxSQk0zZVNpUVZEN0VXVTFDQVVQa1N3WTdSYWk2bFdLNEgwMGZNdkJvY053VGp2UFhmQ0NTOWpBVU0zcjc3K2c5dTNicno5MWVDOTJ6c1kwZTkxU05KTWRIczl1YlY1NW9YTEY2K2ViUWNvaWZkK3FTUHh3Z3N2L01obituZC85KyszbUU3STB5eWtPdkdwVHJ4QWVPKzlkODU1NTF4d3ppMW9KaDhIeU8rekMxMHNRaFdnTXlVdlNTRVMxZDZRVlYxeisvNE9QN3oxaUlQeERJRWdVUXFsWXgrUXBnbkpRbkxTV0pRSWRCSkZxdVd5RkVtMHB0K0xnWEx0M0FiUFhOamt5Yk9yYlBZeWNpV1dJS0ZGd3ZjK1NHdGNaeEc0dlc1blBRUmtuSEZGZUxzZ3ltUEtORERJSk5yRlBpaFJBaVVDQ1FFbEJEb1JaTGxxSFpNaVgxMGhJVVFzbGhBU2o0Y1dZaElWVk9MR2ZXNEY0eVl3ZDJDRkJCWGZrK0FsWlJPNTdjWkJZeUllemJlN0hRRUlIWTFqYkdXQUlFS2dhYnk3RlVJd2oyV1JDaWhmZi8zN1h3MjJHaCtONTBzWFhKMmxyQXlIVHp6MTFMTXZuK3BEVkFoQjVubk9HMis4d2VPSHZMSTFwdldsRHlIOG5qV1VjKzdqQVBtRDdVS1hORXRaTm5icVFuQ3lGU01PTFdmaThIak0yN2NmOGRhZEhRN0dCYzdGUU1rVDNZTDFOSjA4WGNxLzVJa2kwUklSYUVsSjBaSXN5eklHL1I3YjY2djBlbDFxOXlNaXJTR0VZSzExNC9hS2s2bFdBeCs4OUMxR2FnRXY5ajZnMHppT2xTNGcyd1Zmb2dSaExtbkc4ZjhwRlh1SHBsVnlGMEtRcW9ST2twR3FGQzBVQkkrU0d1ZGhXalZNQ3NmK3BPRndWbE5WRG1HaEV5UXFTRndWbUUwOTR4b21CZ29ycUt6QVdVRndBdTlqTURyVE51OCtCTy84YmdqYzU0UjhkTG9YYVg3d2cxZmZmWFQvenRlYXhuQTBudEx2ZDVGYU0xd1pEcDY0Y3UwWHpwelpYbWxCaHpxRUlJVVE4dC84Ry8vbTcvbkpsazFGYldwcTArQ0Q1NmY5OGRPTTVoVXQza2dOZS9sR3Y1c3JpQVkyY3NHOEN3RnJMVWVqQ2UvZWZjaUR2V09NOTVnb0o0S1dpbFRycFpHS0ZKQXBSWnJFY2l3R1cyUWIwdkxXdFJBNFlyT3Z4YkpyRkFGcTQvMWVDNFlLMWpyanZRL09PdUc5Yi9XWDRyZzQ2MmxFaUdqaVJJU2xjdnpSalpyREJ4TmM2NDZyWmNTRDFjN1RPSWNMbmt5bjlMTWhpcFRnVTlhNno5TlVYWGIyeCt3ZlRObmJuM0owV0RBZlYxUXpRekd6ekdhTzBnbHFCUE02TUM4QzVkd3hxNkV1QTFVVEozTUlpU2tzTW9DcnJmQSszRGMrN1BGK091c3lTQTZQUjhmMzd0ejRhbDBWazczREVWbVcwdXQyNlhRN2JHNXV2bkQxNnJYelFDS0VTSVFRMGxvcmJ0MitKZmdJUGZSUGIyekVMZXhLSit1YXVuNVI1Nm5PT3duSG8zbHNBa1JjaEFrZm9SZDE3Ym43Y0orRG93bURRWStOMVI2cW04ZGF2ejN3Q2tXZUs1UjExTVlTaEl5YVdTR205Z0NVZFlNZ0d0TVRUbjRTRDd0TldKTGJ2TEcyRGlFRVkyendRWWlXUm9kV2txeWpFUjZFalR3U2xZS1pldzV2VEJtK29BaENrTFJMU2hzbnZWU054U1FwdFlDZDZZUnhVVEtkMXpqL1ZlcmFSQ1NBOWNnUUVFNWdnbzlVNGpiaFJsL0VXRko1NS9FbVlCUjRvUW5HZ2cxNEwyaG1CdXM5OWJ6eHp2bTNqQThqVGpqZWl5WGRjdVQ3OVc5KzdYdlB2ZmpLbTZOSjcvUFRlY0hLeW9EcFpCSTJOOWEzbjdyKzlHZS8rOTEvOXJaekxnTXE1NXo5amQvNERWNTU1WldQQStUL1h3OFBwbTVzUFp2Tm8xbUwwaFIxUTlJcWQvdFRWWmx6bnZHazRIaFNzcnMvWm4yMXo3bXRWWHFkaER5UEhJbXlObmp2U0xXS0FTWWxXa2Z5VWxGV2xHV05Xc2p6dEYwb1VwQVA4L0cwc3FPb0NFRUkzbWx2blpBNldxa1JGb0xYMFE4eHVGYVJVVWU4Y0hYSFU0OHJrczRhZUpaYjhpQmlRMTAzZ1dQcm1MZzVWVlcxcnJVUzY0dW9GR2tEMGtNaUJGNUdJNTdHK1ZOKzVlMnkxSGs4QVJLSjhKRVQ3eDI0eHVGcVJ6T3Q4SGlhd295Y0MyOTY3eGNhVjZlRkU1YTg4VnUzNyt3OHZIZnJuL2JYdGovNWFPY3dmL3I2SlpJMHBkUHA2Q2V2UGZYRjFkWDFmM3g0dUQ5ZmxGbWowY2pQWnJQd1VRa1ErZE1kRy9oSldjOGM0UWZPT2pNWkZkamEwZTEwcUpHVUx2YnpzbFVqVVFxa0VnZ0NSZGx3ZStlSTc3NTluN2Z2N0hNNEthaU1KZEdSU0tSMUpCc3BkWUtRcmFyb3l3SFFJSkE2TnZwS1N6YXZyQTdXdDN1OXhieGVFRnhSUkUycExOR2NIRkhCZkd5aVYzZ3J4NE1SVEI4NGxKUWthUjZoSDBvUUpQUVNnZkRRVklIalNjMjB0RFJPWUszQVdaQStNbElYeVBDRndTWE9JMzJVSGZJdHljdTNNa2UrY1VqblVkNUhIL1VRQ0VKUUhNeGJtckhETmY1aEUvamhLVXpWYWVuLzB6VFcrcXRmKyszZktXYmpPL3ZIRTBLQTRjcEE1SjFjcksrdVhYL2xrNSs2c3BobXRjMjZjTTd4aTcvNFN4OEh5Qjl6bDk0S29BYzdhK3hyUXNwNkFWK2ZUVW9TQkdtYVVBZEI3VnIvanhab1NJdkVEUUhtZGNQTlIwZDg2ODI3ZlBQTk83ejc0SURLZW9iOUhtdXJRL0lzUXhBOUI0dXFqdktpTFpBeFhYQ3RPd245emJ5YjVhcTNDRnpydzl3WTQyMXJwNHlRTGZaSUlJU2tpbG9RTVJQTkZlV29abld0ajhna1FRcVU5WFMxSkpVeVN2YkxxT05VV3hQMXZBZ0VFZnVTRUNMOFJVcFFLcUNGSTVXZ1pJUzg2OVllMlpwb1hTMGg2bVZaai9mUkY4U1dodmxSZ1ZjQ1o3d3psWHVqOW43M1ZMYndRRkJTQnZFK0lYZWE5MjY4ZSsvUi9WdGZyK3ZHN1IwZWg3VzFGV1NTMEIvMHoxeTcrdVRuMGpUdHRoTXRMWVFRbTV1YjR1TU04c2NaSFNmWUhRdTRVV0Z1TlM1ODI0TWxSTCsvcW16QU9GS2xzRkpTSXFOY1o4c0pYK3BOaDhXbzBiRXptdlBhblYxKzU4Mjd2SGJ6RVVmVEFxMGpuZFU3UjFVM05DRjY3eVh0aUZoS3dlclpQaktSenRaMllZYmtsSlMybTJlaEttdU1zVXRic2hBODlkeFNsTkZJeDN2d0U4bTZsS3owTlRJTHBJbGtRUm8yTGxvcUtCbm81VG82N2dKQ1NVTEwwVTFTVFpKRjlHKzNvK2wzTlN2OWxGUUxNaG43bWFUbHorUGJDVjBMMnc4K1lLMm5HbFZNSnlXMXNaaktGYlZ6dnhOQ1dLQnlsOHkrSnk5ZElNOHlUcjMvVlZuVnhadXZmLzgzNTlQUnpxUGRJNkdWb3RQdDBPMTIwdTB6MjErNmV2WDZtY1hJRjFDajBVaTg5dHFyL00yLytUYy83a0grdUdLa1Zla3pnSm5YNWlCVjJYL2E2M1N1MmFLNnNuQ2lyUnVIc0o0azA2U2RsTkk0akxIb1ZrUHFOTE4vb1E4VmZHQlcxcnoxWUorYk8wZXNyL1JZNzNkd3hsRFZiVG5pUEhrN0t1aXQ1S3llRzZDRVFFWEN2d09vclJ2bFdkSVVWZE10cTVvOFQwRkk2c2JnNTRKaTVwQTlSZW9GZW00UnBhR1dnbzdNVUZvaEVuWGlrV0VEblZUU3lWb2RZQ2ZvSnhuV04yUmEwYy83VE1vamFtTXdWdUN0cHFjM2VUamVZMTdNY1I1OGlKNG4wZXdubk94QXZNZFZqdEgrRkdNTUtsZVl4cjFXTnU3MVUxbkNDU0ZDbERkSzZIUTZWRTBUUWdqTE11czczL2xuTno3emhWOTQ5WGk0ZHFGcURCc2JhOHdtVTdhM3Q2OCsvZVF6VDcvenpsdjNoQkJKQ0VGWmE5MWtNZ2w1bm9lUE04Z2Y4ZU5YUC9NTVQ1M2JXTmhTK0FYOFlkanJOR2MzQjZyYnkyaE8rVzVZSHloS1Exa2FPbHFTcElwQ0NzcFRZeG5QKzRFK1VWa1FhdXQ0Y0RqaGpidDczTndiNFp5bkk2SWVyaFRScXFoL3BvdktGTjc1dXFuc2ZISGJsclhaTXk0Y1pvbG1QaStwalVPcUJHc054YVJrOUtpSVM4RFNVZHdmVTVSMWhMbDdnVXdrc3UyQnRKSjBPaW1EVGtJL2xheDBVamFIWFRaWGVweGI3N014MUdSSlJUOFhERHVhYmdaSzE4enNFUTZMbFNLcXk3Y3dmZHZDU1hTMGxzVTFucVA3eDh5T1psRXhSWWlpdHY1L3FwM2JhdysvalJBUVFpOUxnRURaMkFnRlBubi9tL0YwT3JyejNnKy9WbGZsK05IT0FiMWVoeVRMUXIvZlg3dDg4Y3JQOTNxOWZnaWh0VGIwTW9SQTA5aVBTNncvcmhKTFMvbStpVXJkTkVlalVURlJDUEpFWXNTSldHd0RGTlp4UEc5b3JFZkxxRE5seGZzNzBNZTkvUllEWlI4Q3J0WG1UWWpxOEFnWW5zbEpoeHJuSGQ3Nm5lbWtYZ2lSMmNhNFVXUGRDQ0dDRklUeGVBNGlBZ2x0WXpsNlVGRFhIdi9JTUhrNHA3S1d1akRVOTByTVRvV2IyMGpHVVlJMFYrU0pwSk5BUHhPc2RoWHJneTVQYkQzRFNyZERvbXJ5eExQV0czQis1UnpkRkJ3VGdxaElGU1JkRmJVMFd6ZFhiMzNFbHhuUFpIZks2TUVvTnU1Q0VCRDNTMlBlNHVUdGkrNXdJWUxLM3I1NUN5RUVpZEtoRmFSMmk3ZjVLMS85SjkrWWpRN2ZmTGg3aFBlQlhyOG5zandUbHk5ZCtmVFdtYk1MU1ovV01FckliMzd6RytMakFQbGplRHl4dllLSjA2U2xDZE84Y2Z0RjFkd2V6V3VrRVBTVXdJdFRuekJ4OURrM25zSkVYd2pOaVZibWFZN3k0eUt3cDIzS1FvQWdCTDIxbE01YUNsS0U0SU9aelpydnp3c3pYZ1JJVWRYanVqRzdVZ2lSYWdYZTBWaFBFQnJySFVjUFoweU9HcW9EZzJzaUM3Q2NGeHgrOVlCNy8rQWhkLzdMQjl6L0gzWTQvdjRJZTlDUUtFbXFCWU1NVnZLRVRpTHBacHBCcDBlZWFRS2VjWG5JcE5xTElFWVJZbkRJUUtKREZIZndjUnlzSWpZR00yOG85dWY0eHFHa1FDcEpnQWVUL1dMaHYyRUFKNVVrNjZmTGhxMllUN2w4K1RKWm1yRjRhNFVROWNPZFIzc1A3OTM4UmxtVTltZzBZWHRyZ3lUUFdWMFpibi95NVU4OWY3b1BjYzZLYjM3ekcveGIvOWFIdXcvNXFXTVV2djN3a0p1N280VXowQUtQbFRUV3liVkJaMlZXbTg4V3pxZU9hQm92eFNrOXlWTXJ4dFBtRW85YmtYaytXQWcyeWdaQzBrOVlPWk9qdENiSkVxRVNPZDdmbWYrbjQ2UHFWbnZ6T2grQ1dCLzJ0b2ZkL0RQT0IrMjlwNm9iZ3BDVVJZbHpualRSZEJxRktSMk5zeFMxaWVOZ0MvVzRvZDV2bU4rY003azlZK1ZLbjVYMWxFUUt1bG1IRUdxTUhkUFlnc3FVV0dld3ptS2N3ZGdUZ1R6VHRHYWx0Y2Mwbmd6b3B3TGJPTVo3QmJQOU9kNDZBcDZzbXhvWCtKOTJiNCsrUml2bUxBUkdhZW1INngyT2o0cmxlL0hjczg4eEdvMklzcURMdDFBclFYbnR5V2QrUnVwczgrTDVNMHhtYzF4ajBxYTI3dWJ0OTc0OW44K0tOcUJjbnVlK2FXcnUzcjMzY1FiNUk5K2xDeEJDaEJiNVlRRXpxWnEzRU9MSUJXZ0NGQzZpb1BveWFnQ2RQdnlQKy9zOWJpWnpPbWdXbVVTMTIrMUJWNk5hcUhnUWdhcXlieDhkbE8rZUxqZENDRTFSbXpkODREQlIwVVZWaVFoYjBUcWxLbXFPNzgwSkJqeXRabkNyUG9LTUw4cTBFUDNwbzRMM2Z2TVIwM2xEaldWbUp0aFFVOXVHMnRuWWhMZEN3Y0ZIeFJVWklxY2xZQW5PSWF4RCtvQXhqcWJ4bExPR3llRU1VeldFRVBzU3BOZ2JINVJmSnl3TmNLeVEwZzgyT2p5dUNHbXRwU2lMY0VxL3lnRE5xNjk5Ly9hakIzZS92bjg0Y3ZPaVltMXRoYXpURVJ0cjY4OXNibXhkT0xVVGtmUDVYSDdqRzk5a1pianljWUQ4VVQvaXVIYmgxQkVUd3J5MkQ5T3UvdlgrYXRZZ285NVI3VnY1ZWhGUmMrcXhnSGhjUXgvZUx3LysvcUNNZUNxVlJNVVRIenhCaXRBWS84Tmkxa3hPbFNVR01FZVRZa2ZvOUVHU3h1WTIwVHJhU012bzBUNDlMcUlwajRBczBTMW9NaXJCYWFWYVlwaEFLY1hrVnNHTnJ4NnljMlBDMGNHTXNxcHhRaUJVaWxleDUycDhkTVUxSnFCRG4xVG1LTmtLeWJtQXJRekZ6SEJ3V0hHMFA2ZVlGRmhuNkNaZDhyeERZL3lyQnc4bTc1M3E3UUloaEdyV2hLTkgwL2U5RjkvNjlyZVdxRnh4YWxqU1dGZmN1ZlhPTitmVHlkN3UzakhyYTZ1a2VjYkc1dnI1cDY0LzlZbTJ6Rm8wNjBJZ1JLS1RqOGU4Znp6TitzblNVQWlDOGI3ODFKZlB2ZnZzeXh2MmplOGZwcTk5WTVmeFFZa0RxbkFTQU1salpkYmpEckhpc1F5ek1KOW9mQ0NWQXFtakFJTFFFcUZWWTBwencxbC9PamdFWUE1SDA0TjUxYnkzT3VoOFNtdXRwSW9iOWNZWXBOWlVqYU5wWWpPZWFrMHZENlJ0dHZGQ1VCdURKMFFlaHd2Yy9xMGQ3bjlkMEZ2SkdHeG05Rlk2U0NYdzBrUHFVUU9KNkVwQ3BnbGFFRWlRVWlDQ3d6Y2VWM3RzNVNqbUZkT2pBbE1hdkE4a09zTXFPNStNNWw4M2xUMU5idzNlQjhwcDg0SHZmOU0waTQvaGZZdkRyM3psdDE1OTdzVlBmZWZ1b3pOLzd2TEZMZEh0OWVnUGg1MXJWNi8vM05yYSt2OTBIR3MxRFVqbm5UOGFIWVdQQStTUHFkSTYzVVlJZ2RqYzdsdzlkN21mYjE3cWgydlByb252ZlhXSGQxNC9wSnlkZk1qdUEwcW9EM0o5UFIwb2dWaTJaVklnMjRtUVREVkpOekdpdE9XcFE3VjRPZ1BNSCs0ZGZTVkx6djZLME5tYWRKWkVKeVJKU3EvcndGcTg5NUg5S0FTOUxNVTZ0NFN6S0NteDFtS0NKVThTc2tTamhjU01QWHVIYzNEVE9KcVZBcTBsTGdSSVFLOW84dlU1NlhxRzdWbHFDMVhwS09hRytheGhjbHd3UFppUk50RkhhRnFNOEtuNjRlU2dmUE1ERUFzL0NiTEJBczFrTmgrLzg5WVB2ckp4N3ZJdkhvMm0vZTJ0RGFiak1aY3ZYWDdoMG9YTGw0K1BqL1lXTFYycjlDNzRLUlJrK0ZBMjZZK2Q0ZE1hdlAzQlNyYisyUytmLzlWOGtGNFBRakJjU2NXbGF5dXNiL1ZvYWs5ZE81ejF5eXVQRHlpdk9QVnBoY2VhZXcxMGM4bGdvMGRRRXRGSjZLMTJ5L21rK2MzRGg5TWJuTEk3WHZ3VEpXUllYeGw4UHNEWnFDYWk4ZDYxRXArQ1FiNFFhNHNTb01zOWpKQ2tiZG0xRUFjV1JNblVKRkdrV2VTbDZ6UnU2RVcwdjhJMkhqTjFGTHNscy9zemlnY1Y5cURCVEN6VGNjbGtVbkowTUNhckJKZnlJVDJaa25pSmFxZ3pMNXNRdUZkWmQ4U0pYNGIvQ1Q4VEJTUjFYVFRQUGZ2Q3AvTHU0TnpWeTJjNUhrMkM4Q0lkajZjUFgzL3oxZThMSVJiOW12dXdCc2RQZTRBc1ZFMFdnbkc5NTUvZC9NU0xuOS82VjN3cUIwSUlZVzBVbU82dFpKeTd1c0wybFRXU1hHTnR3RFlSNmlGK1RKQndhZ1M4YU5vem9OZFBHVzZzMEFoSE5zenBEdkppZWxUOWs2T0gwOXVjV0I4dk5tQzZia3l6dHRJL2x5WEpaNHkxQ0NtRlZoRzZFcnduT01mZTRaU2phY254dEdSY05CU2xvV2djUmRXMDRHQ3hGTTlXVWlCbGhLeTRFQ2RWMW5sc2k5d1ZMV1pMcXFoMDB0VXBmdVpRYzB2ZkNIcE9Na1J6YVRoa3BadlR5Uko2YVVvdlNWY0huZlNWYnBhYXZVbnhyUkRDVHhvZzRxUlZFOGw0TkdvdVhib3lHSzV0ZmZiTTVycFNTb3BpWGloblhmamhPMjkrYXo2ZlRmbFJHUDNIQWZKSG1EMFdpb3Bkb1BmVSthMXJQLzl6bC8rTi9zWGtlU2VGcEZWZnR6WXFtN2dBS3RjTU43dXNuT21TcFFwaG9nbG1hSG15UVh4d2ZTRVhYd0k2UTQzUEF6TFRkSWRkMGs0aWl1UHkrd2NQcHo4OHRWeGJlb08zVExwSm5xWFBTeW5QZU8rbER5Q2xRaXVCcld1c2lTQkdheDJOdGRUR1VsUU4wN0ptV2pZVXRZMCtKbzNGK1doSUU5cmdRQWlVa2lndEVlTEV6RGxKb2lvOHhLd2xwQVFmeUtWbWtHVExWNmVFSU5FcUlwZWwwRlZqN3o4Y3piOGFRaWc0WmNqNWg4a2lxOE5CT0h2aDZ1Y0dnK0hhcFl2YmpNWVRndldkbmQyZE4rN2V1MzM3OUs3bDR3RDU0eW10Y21Dd3VUYlkrdklyMS82TmM4LzAvb3phRU5vNGxud0xaeU13MFFVd0ZxckdnNUFrV3BKcGdaYVdMQTkwT3BvOGtVZ1pENkJvUjhtY2F1NlZGdlRYRXRJOEljbFNkRGNselpRZTNaODBvLzNpbXlIdUR0NW41UVdJYVZIT0p2UGlWWEF1U2VWVEFwR0dGaE5ycXdydkl4TnljYmlYQnowc2xwTUM2d0x6cW1aV05veG5NWENxeGxMVk1hQXE0NWFLOUZGb0c0eTExSFVUUmF0dFZILzNlSXlQRjdhV0o4eExZNTI0dFhPMGQvdGcvUCthRzN1SHh4eHIvNEFIK0xSaHJ0N1plVlEvOSt4elczbHY5YVVyRjdkbFl3eW1hVHJ6V1hIOHZWZC85enU4My9mOFF4a2crcWMwUUJaaTFWMmcrN092WFArVmxXSHlLL1NEUXNybHh0aTdRUFRmakUyMXAwWEJCbytVQ3RzcU4ybGlrMHdJNURZU2lMd0ZZMzMwQUFsUlppZkpGRHBYQ0JVYlkwbkVOQ1Y1OHFsVXl5Y3E2eCtjcXN4T2k2M05aMFYxMDlqbVAxN2RraGRsNW41NU5yRW9FNkpaVDVSMVlHRlg1cnpEQjQ5b1BUMWkzK0tYUXdVWEFtVnRtSmNOM3JmS0tGcEdreHdWSll5aW1tUkFpa0FuUzFzSjFiQXMxYnozN1dSRExZMkN0bFo3NXFBMGhyTEoyc3ZuTkZucUQ5Skl2NjlacjV0bTlzWVB2dmM3NXk0OStXZjNEa1pidytHQTQyNUhYTHh3NFpVbnJqNTU3dWF0ZHlmdDUxaC9XQnQxOVZNYUhNdlM2c1duTGo3OS9OVXovMGVkK011OTZ3bFdnVGNpaWcrNGdMRXhRSXdMMUUwRTdWa1h2Y3ZMMGtRN0FPdFFRa1NlZUd0eElGUlVOTXh6UlpKRDFwV2tIWTNTR3AwbzBBcWRLUHE5TkFUdnhlSEQ2YmNhNDkvbFJCckhQYmFIRk00RmwzZVQ0L1d6M2VkSXc0YVpON2pLeHBLcFJSTXVMTmFrVUVpaWhtNk0zWllVSllqTXlaYUxFa0pjMnJuZ2FheGxWbFNNaXpuVGVjbnh2R0JlTjh3clMxSGJaYS9pUTBETE9FNk9KcUFSbzlYTmsvNmdrMjZVdFgxdlZwc2pmcnd2K1I5MHNwaE1KNlA2bWFkZmVHNjR0bkg5NnVXellUeWVDaEZDNytEdzRNMzNicnp6bmhEaWZYeVRqd1BrajZZeHo0RGUxc2J3ek05LytxbS9xcno3c3M2RHpwOUlNQjVjSFoxc3ZZOW8zdWpuRWIwSUd4T3dMbUxkdmZGSUQ5NDZaRXZlWHZCRnBJaDJaUXVBbjJnRjE3SWtSV2dWL1R1MG90dk5tRTlxdjM5djhtMWovWnVjNENQdFl3RVNBREU2cmtaU3kySjFvL3VpbW9WK1BUY0lFWmFzeFlWbXBHeUZHMFJMV2hGdHZTZVZPckUzOEI0cEYyV1liMHV6RUtWN1hJUDNqaEFrem5pcXhqQXJHeVpGemFTc21GZVdzckhMOXlkK2Z5azZpYnE0MnNzdlZOYi9ZRnJXazhlQzVDZWRhT215cXNMNjJwbytjL2JpejEyNmVDNXBlZnI2OE9CZzh2M1h2dnV0VSsvWFQ2VzA2SWNwUUpiWlF3aDZRUGRmK0xtWC9zeUZ6ZUZmSzZlemZwSUpzZ3NhaThEYlFHZ0R4UHNvOFk4VW1OclROQzcrUG9Cc0Q0YVBUS3FvWGtLSUpZczQ4UVVSTWlxY0tDWFJhWXB1dVJwWmxqTG9kOFhoemtTVVIvV2QydnB2aHhBV28xNjdmSXJIWHNONFZCM2tYc3FPazU4VUhyVW9yWHlJMHAraHRZZ08vdFRZVjZrb0xLRlVMQ0dkZjkreld1Y1JJc1RBQ3RIZVFBbE5vcExvczlpS3hJWDJFb2lEZ0pwNTFWQTJsdHFHR0RET2kxVEpjeXVkN0tMei91MXgyUnc4RmlEaEo3ak1GSkFFNzh5bEswLyt6TWJtNXZiWjdRMXhmRHdXdU5ENTRUcy8vTlo0TWpvODFheC82TEtJK21uTkh0dWJLMmUvOU1wVC8zdHI3RE5WV1FXdHBFZzJORDREVjBjSFcrZmpvWXVUVWtsVk82cW1oYnNUVUxTQ0NMWEJXWThJVWQ1bmFiTzJjSldWRXEwMVNpdWtqcG5FQTNtV2ttako0YjJSZEhNenE1ei9KOTZIR2RBSWdkMWNIWHBBMkpQREhGOURRUFdGM2t5MS9oeEM1TUY3c2NnUXJqVSs5TjdIYmIyVXkvTGN0MXdPUWRzRFNSbWRiTnNTVFN3TVAxdUI2NFdQZWdpUkpxeUVqQmJXYlN1dDI2Q1RRdUk5MU1ZeEsydkdzMG9hWTY5NDYvTnBiYjdoNHNqM0oyMm1GMldXSGsvRzl2ejV5MnRuenB4NzVmcTFTM3BXbEhocnU1UEo5TjdiNzd6MTVvZDVtaVYveWpMSVlucVZ2UERrK1JjNldmSmNXZFhValJWMTRiRFRzRFQ0Y0cydjRYemJjempmK21kSU1pVVk1dEYzUTZlS3RKT1NaZ2xhcStWTkhoRHRaQ2tlTXFsa0ZMNG1zdlBpcHg4WUgwK1pIQlpJSVZLQjBLZldKbUplMW1KN2JSaWtGS2ZoWFI0SU85UGk3ZU9pK3RiT2VCWjI1elY3MDVKNTdSQlNSYmFFYUF1ZmxrUWZ4OUUrZnNIaUwrQzl4WG5iVHI5aW9JVGdZMCtGd0RzWFN5MGZsdHJBVVE4c052U0pUbHFZZTBESWVEbDQ3Nm1hUnRSTmMxVkxNVGoxbW42U3g2SlpyNTF6MVd2Zi85Wlg3OTY3ZC9kNE5HRmpmWlZ1djU4OWVlMnB6NjBNVnpjNDRZa28vbkJ1dHYvTERaQTBUZDkzR3kwMjU5Y3VibjFlQ3RhcXFxYXhGbXNjOVo3RjI4WFpDVFRXMHhpLzVIN3JKTjZ1MWthdFd5c2lyaXJMTlhtbWwyVk1OSFpzaFJIYTNtQ2hIT0phbFJDRndCckx3YU1aOWF4QktwVW5XaTJZdURJRVJGSFZISTFuN2UzKy9nYjI4cG5obWF0bkJwY0htWkx6ZWNYK3ZPYnV1T0RtOFp6NzA1ckQyakp0NHZpMk1WSDRXclJCZTdwcEQ0QXhaam41YWt6VHFxVklsRkl4bzdUK2loSENFdG9wMWdtY1pRSEM5SzJHbUZBeFNJeDEwOFo1ODRjNHVEL2lVWDdqdlhkdVA3aDM5OXYzSHV6NmJyZERwOWZsOHFWTHp6Nzd6UFBYT09HSkxNOWJ2OS8vT0VEK3dLa2oxaC9MbXZiSytZMHpLLzN1OHdHaG1zWVNmTUI0VC9Hb3dlODVYRGlSOUxRdUJzb0NyWjIwdGdER3hjbWxVQkhTa2VVWmVaYTNCNnFGZHJUalVpbmpxakJSU1d1eEhKKzdtRlljUDV6R1VrM0tWRXJST2JWWEZBQzFzU0lRUkdoMWhJRmtwWmYzcjI2dS9HV3Q1SE5yTFhWMkxkZGtDcHgxekNyRC9yVGkvcVRnOXZHY3UrT0NuWG5OWVZGelBDdW9Hck1RY0d3SENQRm5YRTYyZkloSTR4WWpzeENuQ042L0x5R0x0a0h5L2dTSkZnUFA0NXdMQ1BISW5hQUNmdExINlFCcGpEV3oxMS83emo5NThHRG5PQ0FZREFlc3JxOXZQZnZVczU4VFFpeTgwVFVnaFJBaXZ1Y2Y3MEgrTUQySWZ2cksyU3Q1bGx3MzFvRVFWSTFGYThWa1dwUGUwZWhuTk83VWFzc2FqM05SZ1VTMHMxRmpQS0VWZ3RaWkVwR0l1YUJ1bWxnODJUaCtGU0ZXUlVvbTVEcW45bFUweDdTT3c1MDU5Y3pRVFJPVWtzTnVsbTVPaTBxZURwS3FNZUdVcVcwS3BKZldCNitZeG55bU5vMGd3TnBLajE0dnAyb2FxdHBpWEtBeGpzWTRhdTh4MWxQWmhsSFZicjVWVFNkUmRIUjB2MVVoUkRGdUVXSVQzd2F4OTY2ZGFMbldSS2ZOS0RKbUZFNWxEaUVXLzhhMy96NDRGL3h1Q0g5b0tNanBMTklBelp0dnZ2YjZyWnMzZnZmNEU4Lzl5WTJOVlk0T0R0WDE2MC8rd3ZsekYvL2hnNGYzcG0wV2FZUVFmamFiOFdIb1IvNW5EK1AySmhHMFpENGgwT3ZEL2pPcDFxdldlZElzd3pnZmlVRFdjdmhnanJudGNFM3NSWUtOWElqR1JOY2taejNXUjNLU2MzSE1HMFRBYXdnNmtHVUpTc2Vza2laUkRGdEpRUWlXeHBXdFZxL2pjSGZPYUs5Q1NZbE9OQUt4bWliSnBUWVFsbjFJZUgvdmxHNnY5TFp5R2Y3QzRmRjBvNndpMlNuNGdKYWFicGF4TnVoeWRtM0FwVE9yWE5sZTVlcm1nRXRyUGM0TmNsWXpUU0lFeGxwR1JjMmpTY21kNDRMYm81TGJ4M01lakVzT0NzT29hR0pwWmwwY1c1K1NWNFYyanlKbE5QaTBEdWRzRkpVTGNUcm1yTVA2WUdvYjlpSDg4MHlYbGxsRUNOSE01OVBSemZmZS9zcXQyL2ZLYnJjaitzTUJXMXZibDY1ZmUrclpEK3BEL3ZiZi90c2ZaNURmNzJHTVdTTFBBK2dzMFdtZUo5ZUZFdG82RjZRVVFnaEIyVmlVRkpUVEN2dU9aN1BwSXpZVmRtSGY3QUtOZE9EYmtpSUV0QkpvS3hIRWZpU29nRTRWbVU5YUlHSEFCR0o5NzJNV01qNHdPYTZaSDF1UzBCS2RKQ0JFb29VOHM1QzI0ZjBzM3NYbVAxbnJKQytWWmZYcHNxaUVsSW8wU3hkcUlqR3FWTHVwYjkxNGhZeW1uNkxWQ2E0YlEyTU14anBxNDJJZ3VHaUJVRG5QY1dYaWhrNks1Ymc2RVlGTU9US242S1JwTytHSzN1KytMYWxDcTBKdm5ZVWdhTytRK2dQMk9UL3B3d08yQlQvV3I3NzZuVzkvK2pPZmUrT3BwNjUrWm1WMUdJYXJLOTJucmovMTJhOTg3YmQrbTJpOXBnR2psUHBRN0VSK1drcXNwZFhCbWZYaDZ1cEs5NUwzSHFVVVdacWhrNFRaZEU0M1R6SGVjVEFwS04rMnJCLzM2RzRxeWl6Z2hNY0ZFUWtRSHJ5eGNSRkl0QnFRU3FCVGlVQWhRNEkxbGlZNGtLTGRZQXZLc21GOGJLbG5EdTJqSW51RWlFaUVFSWxVNnBKV0tqWFdubWJ0aGtXQURMcFpUeEcrVkpmMWluTStDcmJWRFVyRlpqbDRvdEo4VkJkcEE2UUZJeXFOa2hHaDI4bmlJZmV0ZXYwSnlORlJObzdLZWF3UDFEYWNFcDd3eU1xU1NrTXFvOVZibG1pNldVcWFhSUozV0d1UlVzWU00cHh4SVN4a2pOdy9SNW5GNlY3azd0MmJEMjdkZVBkM2RsNTg3cFBYbnJpY2RIcGQ4ZVQxSno5MStkTFZDM2Z2M1I0dHN1LzYrdnJIUGNnZnNFRS9mUXVMbFVGM0k4L1NDODRGb2FRa3pWSjZ2UzZIeHhPb1RieXlQQnhOQzhhemd2V0REcDJWbEhTWVVQZkF5ZEI2aWd1b0EwNDVORkhjUVNsSlVBTFhMdFI4Ni9EbmpLZWFPWXFwd3pidEFFQzBTNklXbmhMTFFiR21sY3lNZlgranZnanVZWlpzbXNhK09DOXQyeDZmRElaOHE0dHFGNXlRRUZBdHpFVEp1SDlaMktkRlRraUtsUEdDU0pOQUh1SUVLamhQYlV5YzdGbFA3VHlWZFhIVTdXT1dLZHZqS2lxTG5qZVJkeEtYTDNReTVYVmd2N0grb1lkOS9qbTl5U053MGk4cHVVRDExYS85NW05OTZZdGYvTk1YTDV4OUpsR1NMT3RlZk9uRlR6NS85OTd0TnhmdlZldHBHRDRPa0o5czZVU2E2SjVXcWgvOVBBUktTckk4Sjg4elpyT0NUcFpHa0tIMzFOWXkzYTFJOWlWNWxpQTdLZWtnSlJ0cWtrUmdiY3dzV2t0MEVISHA1dHV4anhXRU1qQWZXK1l6UzFXNnBjdHRxNks0L1B5OGo5QVVKZVhaYnA2dGwzWHpnQjlsOEdLTTNSeGJkMzdlU3UrSTFwNU51dE12TXB4Q0VzZm5kOEtodkk4TFFPTGlUMnREa21wMGtrVEFvb3J3ZHBrb2trUmpYYnN6YWYzSVE0aDJFRTFibHRVMndreU1ENVJOczV6eXpZd1RXYUpmQzE3OEErUGNmZjQ1dmNtbGxNRTV2d1F3Q2lIcWUvZnUzTHgxODkydm45dmVlbW84blhIdndjNVF5ZXpKMDk4amhNRGYrVHQvNStNTThnZHAwcDF6eXo1RUs1a3FJVlhjY3F1bythUTFxeXNyekdZbHMzbEYzc254emxOSHBDSmVPT1pWalR1R1RPdDR3QktKMGd1SFdKWU5yVzBjZGQxUVZKYTZjcFNOUFJId1hjNmFXN1YwSUxoQXI1dWl0WTc3YlNFVTd3ZnNMUit6eWdoQ1VNM2pxU1djTkN5bnUzc1ZCVTRRaFBiWHNYY0FjTlpnakNHRWtoQmk5bHVNZTVXS3ZZV1VFcDBtQ0IvNUlaa1FETHVkT0dpSVBvODAxbEZiUTludVhJd0xLQ21mOVZxRnVpekx4MHFsbi9nUnA0Y0tIN0V4aGtEVk5JMzgxamUvOGQ4RXA3NVlOdWFaQjNmdlZhUERnM3Z0dEdzWmpIL3JiLzB0L3UxLys5LytPRUIra2t6U05OYjZFSHhvTjh3QjBFcVNaQ2tiRzJzOGVMaExNeTNJMGxpekx4eWlwRlFJSEM0NHJERlVUWVRETyt2YVd0NUhwcUVMaXpibFIwNUdOT1pwRWJSeFlFK1dwV2pkTHVNSXRZdUxOZkVCNDA0ODRUREFMUTh2dDRaVzcrUEhodzlJTzR2Z0VhNDFQeFNMWUFwSWUvTHZUQ3VHUjF2K0xjbGVyVGFZbEpHcW02UXR4VGY0bG15bEdXUVpLNTA4eWcvRjZkZjVvckYvb2tSODM1KzYxUDh3Z2ZLbEwvMFMzLzcyMTBMVHVBQzRRS2dCK1Z0ZitjM3Y3KzBkL1R2OWJ2L1BlV3R1N2gzdS92ZjgvOW83MHg3SnJyT08vNTV6N3IyMTlUTGRNNTZ4VFNZNG1UZ2tJZ3NRQ1JFSnhBZmdPL0FsK0JyQU96WkZTRWpoRlJCRmtWaGVJQkdFa3hqaUVEQ1R4SW9keCtQSmJEM1RleTIzN3RrZVhweGIzYmRyZXBMWURuWVByak1xMWUycWJ2V2Q2dk0vei83L2R5WU1MMTI2OUZTMG5IemdBT2tJUGtyZUp4b1ZTY1lJdEtkZ3I5ZWpiQUs5d1pEdEs1ZlplYmlIT2s5bExRbEJUU3ZPYVMyeHJXL1FjVUcwMWM5WTZIV2M1L3llNUc1YjhHVDZUVXRoN1VtR3l4YmxTZi90T2JXQTFJVDA0TXJtNkMrMit1VWZQRG9ZdnpoMjhjdzAwdkx2alR3K0szOENtS1ZyUGZPWmRlNDU1WmdMelZyeHR2SHRhTzVwZ1ZESTF0Ull5YlhId3RnVTlGZkt3bzZhRUpUMzFQNmhtZjBrRjFvV05SRlVOZDU4N2J2L1dHSy83b2tMYmZRRkUyeHFDZWxXQVBrNUFITG1qOU1yeTZLcVN1TmNwcXhaNVBaN1pVSG9WZlQ3UTU1NVJ0amIzYU51UEZYWkNvRzBZWEZvd1lESWlkOGRrdEwyQ0Q3MldJNjJFN21Cc0RKQ1lTVzNiRVFoeGtpRTJrYy9YL0xiRjBGdXNOYlVONjV1UHQ4elBHZVNVN2RmeXpUcVl5a2ZXZHIwWjNpQ2w5NlhjMzVta1RaTFM4VVlFdGlVTFpHWTludFRpMThmendCVGpSRlRGc0o3NUpmKzVqZS96a2x2ekdsLzF1S2p0SjQ0N3h3aWk5WjZuVTZuSzRDOHU2d0lSa1JNVVpTNWhhUnRRclRXMHV0VkRBZVJFQk1ibTVlbzUvTWNRZnY1YVNlczVKUFRtT3l1aEZiQUx6ZnJDU0dyTHVkbUtqMUxKaWNpbE1aZ0YvSnVLZVdnUGlXOEQ1QTREaUhWNTdnakNRaEdwTG05YzNDdE1LcWlxbTJTYWlFaEtPY0JaZmxhbHNDN0RLTEY5M1NISy9TY2xGcEtwK0RuUEdDcXhoQ2lmdy8xajhkTjJ1bnRoQTUrdTYrZjFGdU1NWHJSNDQrTG1NVVNZOFJXaFNHSVV1VVdEMXpqY1Q0ZlRFV3JiMTZXSlZYZHd6bFBqRDNjdk1ZM1RXc3BGdUtjZ29yRkZwbjl2RFFGNGh4aFVZSHVBTU1DaFlBaFplVnoxVFp6WlZzUm1wQ0FlejZjNGNnNlVjSUNuQS9SUGppdXZ5VEN0dzM4RHNxbkRId1UyRkpZaUdYSWVheVBYYUJ3enZ1eXRObVgwWm5PQWR5eTlaRU9tQ3drVGNueGk1M1JlSkkzZWVhMk5hK1ZCWGszTWNqNmFMQlpXR3Z6ekhiTzNsUzlIbXNpR0dQeFBqS3JIZDdIbGx1cUpCaERTbG1idHFnVWF3M3pwZ0VYc0VWQk0zY2s1L0NOdy9sd0ltWnZXMkNZN2trb2VkWjdNWStCUUlwSlNkSUVIOTZJS1RVOFhubE9nRy9sb20rajdFUjRHYmdzOERHQmp3dDhCdmhsNEVVRGE5cjU3RlBIbTlLZkFoQTl4L1U2enhyeEJLdHpTaHRCaUtvM0F4enpmMFBMOHpPdFVyL2ZaejZmcndEeWp0Tyt3cnFtWkdEUlFpNklKS3F5cENySy9GelZqQ2Mxem1lV3dwUWlhOE1oYytlejRwSVBWTDArVlpXeWhMSXF0aWlKS2xsM01HYmR2Z1hWenpuM2dMVGRzNEpnYlNIRzJvbEw2VUhIbDA0Q2FxMGw1T2gvVVUybTQ0dFBGZTRydkFKOERkZ1d1QTdjRVBpc3dNY1Zuak93SmpBNHg3Sm8xK3JvejFOSVduTFQ1TlIzVFFrbWttWFgvajNBWHdQdmx2cm5QUitLVHdNNExtU2ExL3ZBZU5iUTYxY1pIS2JkSGUybUhmUXJGS1VzTEVmakdZMXJGV0Zqd2hyRCttaUVNWmFxeW9USjg4WXhuYzZZVGFZY0hZMXhJUTlibVRienBlMk9NaTE1VzA0dFoyc2x4cEw1ZGhWanpWSElxa3dManlhSkVSMzFlOHptallZWWs1NmV4b0ZPK3p1bnZWcEhDcmNWdmcxOEZialN1bUNmVVBpazVPdVBDRndSS0ZxMzZZelgxWEdsNUowYzJSYVNpUHhkVVAxWDRJMEU5emtsd251cTJROC9UQURSYWQwYzdSOU40MVlibUllWVFBMWlUb25VcXFKQSt5QU1tTmFldXZFNUZra1JIeUx6cG1ZMm14SkNEcTVkNC9ET0lTbFJ5S0tPa0Z2aHBjME1MRVpUQWNTMkxPeENPNWNCeHRqRHVac2RkR0lPVFVrSk1XaFpXSEptT2NXWVR1UUNwSk1rczUxSDBRSE9ZWUszeU83WVVHQWJlRjdnb3dxZkJGNEFMZ09id0VqQTJIWXMrVHdyMGYxNmtSdzRpWTVWYlNGU0IzaTE1ZmVhdFFCNXAvU2pLNEI4a0N2NGtIYjNEbmp3NklEbnIxMWhjMk9Fc2Zub1RHMkZXOGtGc2w1Vm9waVd4ZEJTRkpiRzVXdE5lZjY3Y1o2cUt2R3VvcW9xbkhOb1RJVGcybU00VDljdGd2VkZhMWp1aURWdHM2TlZVNWhkNS96a3hMMXFKM2QvNDhVYmZPZjFOL20xNjlmMDV0MkhXZC92MU5QcEtyOTFHeHk3Z0ZsWW1HT0ZYZUJOUFcwTjc1TkJzeWx3U1ROSXJpcmNNUEJzKzk1VnpkekZCV0FOclFKRGEyMDY5N0tqcW0rMzRKaHl5b24xVG9qalZnQjUvOU82WjdLZmFrbVYrcmxVeG5EMzlsMzJOOWI0eVBOWDZWY1ZFaU9lSEhka2FmSzhrYTNKbXVtTDBWTnA1WmhKQlZWVlpiNm9FTExpYTNzZFFpQ0d6RmFvS2VGYkx0MlVFdDdsOTF0S2ViWFd4S1M4MWJaMHR4a3NVVkJldXZrYUFLL2QzeVhFTXdleHRyV0tSUnl4clBobWxoNWRDOU45ZnNScHpkQzA0T25GYkhFMmdlZkk0QmtJckN0Y1ZuZzI1ZGQ2d0Z6Z2JZR1hndXEvY0dvOUZ0UkZLM0E4QlJia2hQVEFoVEFUVlIyV2htRXBUS2JIM0xrMXgvU0diS3l2c2I0MnlQb2FMVEI2VllGSWhKQm5IcXF5eUFXM2xFZ21ZZElwKzRjeE9WWkpNUkpUd25sUERCRnJEQ01SZk14VW5qSFZXRFN6RlNZVlk2MmJodkNtdHZKcjdlTk01bWc4ZHovUC81R2x6QmRQc0RCZDBKeDMzZTFTZVczeC9tTHN0d1ZSMWY3TW5KeXRxbW03YlZuUUZ1V1NrSzc4cTR0dFFicU1JSG84YWZaVW1Tc3lTa2twck1Gb1pIYXd4OEhlUHFic3NiR3h6dVh0RGNyS1lxeWhzSmFtclJRcm1nR1VZbXNWRkdQMXBIa1BJakZGaWpMVC9OVDFuS0t3REhwOUp0TXBQa1I2Z3g3QjVia0pnMklMdTkvVXpkdDBTTmFNaUE3N1BjYjFrN014OGIwQlp2bGhPdGYySEFza1M5ZXlWS2RaTUVLZXRIc3Nab1JuS3h4Y1hJQ2tsT2o4SVZOSU9sSDB3SVY0T2FhczNncmtKcnlrN0I4Zk1wMGNNemsrcHV6MTJkeFlwOS92WlV0aUJHc3l5VnBLQldYTVk2bWxhbTVsYjhWc3lzS2M2QVVhNmVORHdBV0hzWWJSYU1pOG5sTzNvNm5HR3B3UGI4MmI1bjY3c1lJSXlWcWpXeHVqbndxUWQyRkZ6eXQvUENtVGV4NXdsaDkwczI3ZEJFTWJJT25LdDNwNlhLd0U2TGh1ZG1lTnYxMlZ4UTFqaEtJb0pNWjRRdHU1UGh4U1NLS1FnSytQMlcrbWxMMCtaZGtETWFTVzY2cXdCcXpGRmtyd250QzJvbVNRRkVoTWhLZ25UQ0RHV1ByOWd1QkRTK2JXN2tTRHExM3o4cXh4KzkzVFYwUVl6NXIzNDNONTdQcWNOSytjQTZJblpZRzFrOTJtWG1IZ3FRRklCR0k5OTlOcDdYWkh2UXByYmN0WTNrNEVsZ1ZpbGFvd2pJYjlscDFROEQ1U054T2NDN2k0SUpJREVadHJJcjJTc2l3d2JURHZuS051NXNRWXNkWXc3UGN3WW1qYUJrblQzcEdxRW9KL3UvWitRZVh2eU9UcjZuelFZYS8zUVg5bTUxMmZkV0dYcnJ2eHhpcjJlQW9BWW96UmxQdXlFK0JkaUs0SjZUL0xYdlY3MXRqUm9GKzI5WW9za2hOanl0YUJQTzdwZmViTnFvb3NDMkJjSU5uTWxkVTBEZlU4TUJsbkxZMmdyV0NtUUZsYVJzUGhDU0cwZDRIZ0F6RkdwcE1waytsVU5mcUFrWDg3cnYyYmRPZ3pSVkFqd3NGNDhvRWo0NTB1eTZvcStEU21lYlVUQVB1am1iczE5M0czVjhob01Va1gyd25DMHRyc0ZyVU1pVEcxTE9qU0VqcGJpNGhTU3VhMUxhb0M1eHpTQ0RZcEticE0xNmtsMCtEenBHSElxZCtVSWlGNDZsbE5uRHV4cGQyYkJQMUdTanFtbyttbmVrcXhjOUdYL29LQTlXRmRIemg1dGJVMkV6cWZabWVLOFd5dTE2OXVmVWFFR3lMSXNOY2poTWg4N2pFaWpHYzF4MDJOVmhGSHBJbUJ1Z2xNRzRkMzRZVDEzZmx3SW4vV0t5eWxOUlNtWlJOcHd4NGhZU1FuQXdRbGVJZDNIazJSSlBMU3NVdC9rMVNQMjJSUFkwVFM5cWl2MDhhdmRzL0tncnp2aDEwQS9MengrL2NlSGYzekM4OXRmM0h2WUxKUis0Yitoa1cyQXJJWldTK0Y5ZTBSL1dGQjlJbTZqa3dua2JGTEJJUithV0Fhc2Z2QzRaN0RlVVdzSWNXRXppT3V6bXp2Vlo0emJ3ZDdJY1RXbXZpSXd0NDhwSC93TVIxMjRvOWtSTFFvWkxWelZnQjVmOVpDcko2ell2WE4yenY3LzNGcGZmRDlSMGZIWC96NEwxM2ljNy85TExab3B3TVRGTWJnWFVJTjlFckQ5dFlhWTJPb2kwQ2xpbTBDY1ZaeExZendZcGtGWlR4MWxQUEkvTERoNk5HTTZhTWFkeHlvVEN1SXFZcjNnUmhTRTBXK01vbnBaWEpocmRPenBMcHp0TXI5ckZ5c0R6QXNBY3k4OFdFOHFmMzZML1UvY2Uyam0xdVhOZ3BaV3k5eXpHSUVGU2dsVHcxYXdCUVZjNFM1RHhSUktYekNCaUVseWZNaUlsU2xaZGdyR0l4S05pNFB1SFIxeUdpenhJZkEwVkdObXdlYXV0R28rcTFwNHM5ZDRoNjVOYU51QWFKSllWRFlWcmxwdFZZQWVYK0IwWDAyTStmdlhYMXViWGJweXVnTDAxa2NiRzZXbEpVbFNyN3RGQkxxY3h4ejdCd1BEeHNHQTVzNy9ieFNwaXJ6YTJwa2Y3Zk9EQ0F0YllrZ1ZLVmhmYTFpc0ZadzU4NCtPenN6ak9yTnVmS0hkZFFmZHNEaEJWSmhSSk95QXNjS0lCY2k4WkxsekE3bXU5dlBESzRGTVorZVRvSnNidmRRMjhxd05UR3IzWXJoZTkvYjAwYmg4bFpmREFrYkVzbEhFa3FUWU9mdWhHcFUwQjhXa0RKUGJsbFltdHJ6OXVzNzdEMGM3ODFtZWl2Q1g4NFNMN1ZCK2F5TlA2SUkybXRuMmxkckJaQ0xZRWtBaUNIRlp1YnZiMThiL2Zxc2pzOU02OEJ3VkdGRElqUzVWMm95ai9FNzMzN3c2SmtYTm0yL1owdVpSMmdpTVFmYkJEVzZjMythMXJiNlpqZ29LY1FnQ3RQalJ0LzYvbjE1ZE9kZ2I5N29uMHhxL1ZPdnZBcU02V2lpQzJoaFJLV2wvbDJ0RlVBdTBqS3ppWnYyZTBXOXRsNTlibmJZakE0ZnpyQUordTNrdzczNzA0ZTNmakwrOFkxUGJ6L2ZFeW1NUzBTZmlBRlVEU0VsLzZQWDltWmIxMFpWV1ZocEpnMzNmclRIN2UvZGs4T0h4NGVONTYvMmo5TFhZbUtIM1BrNjY0QWpXY210NjgycTlMd0N5QVYwdHhTUWc5M1ozYlcxTXE2TnFzL014MDF2ZjJjcXZrbXExdXFyLzdYenl0clZ0Zkw2OWZXUDlaT1NYQ0lscGFSSG9RTmM3Y2V2L1dEbndaWG4xemNQN3gvYkgzLzNObnUzZC9GTnZEZjNmT25SWHZ5S0Q3cmJXbzRUdHdxSWhVRFA1REhkdU5vdks0QmN3RmdFV3ZLVGc5MzYxbWk5MHRHbC9xOGFvVGNaTi9MZzNtVHYxbHRITDExNWR2UjVEWEZyL0dqRzRhTUpldy9HSE83TzJMbHp3TzBmUDl5OWMyZjhocHZVMS9kdlBTekQxS0hLblptWFAzdTRINzhhZ2g0Q2t5NDRqRUVIQTBPL2IvU3psWEtyV1cyV0QrTXFMdmo5TFdqMUJURE9SWDd3UHcrLy9LblBYNXM5Kzh6ZzkxRjk3c0ZQRGw0T1BoMGUzTnE3c3Z1R2E1dFdFdEdITEJVZEVvM1R5WFRDcTBjUHdoYzIrbElGbFc4ZTErbkxCOGYrbFpRNGJzRlJ0NzhyR0NOcUJCME5MWU9CNFZzL1dkbU9sUVc1YUpHNlBHWkpGRWd4cXR1NU83NVpsZVlPcExXSE8vWGZibTMxWHl3SVgvUXVTRXFxSVNhSklaRmlacW9TYTE2Zk9mNStVUEJwTWZLTnZiSCs4ZUU0L2JjcWt5VndSQUcxeHFnQ3ZWNU9DNDhuSzRDc0xNaEY4NjhVck0wa2hERnE2SUlFOEsvL2NQK2ZSc1BpcGd2YWJHLzNmOU83dUE4NkVLVWthZjZYS2M2bktabnZ4QkIvTkczNG8rTjVlcjJlNnc2bmdpK0xKc1FvZ29wQlUweHNYRmxqYjNleTJpRWY4bldobTRwKzYzYy93aXZmdUV1TTJoMDFQZEVEQkVvUjZhK3RGWmN0NlFWcjlibzFQQnVqTmpISEZmT1UySmtIZWN0NVBlS1V5U04wbmhjc0pkcnlYNU5XMmFyVmVob0FNaGlXeEpCdzdxVGJ0enRpMnVXWDZpcW9MdWF5bHhuRnU4Qll2TDZ3U0FBcXNwcEJYYTJuQ0NBLzQ1NjdUQjlGNTJHVzNMSFlzUlFMMHVuRStUUGdxN1ZhVHoxQXV2ZTlURjdRbFdidXlvQ2twYTlYd0ZpdC85Y0FlUkpZbmhqenIwQ3hXdTltL1M5WmhaWklDVmZrUXdBQUFFcDBSVmgwWTI5dGJXVnVkQUJHYVd4bElITnZkWEpqWlRvZ2FIUjBjRG92TDJWdUxuZHBhMmx3WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2xSTlRsUlNZWEJvWVdWc01qQXhNaTV3Ym1la2JYL0hBQUFBSlhSRldIUmtZWFJsT21OeVpXRjBaUUF5TURFMUxUQXpMVEEzVkRJek9qVXdPalEyS3pBd09qQXdwVGJwTWdBQUFDVjBSVmgwWkdGMFpUcHRiMlJwWm5rQU1qQXhOUzB3TXkwd04xUXlNem8xTURvME5pc3dNRG93TU5SclVZNEFBQUJHZEVWWWRITnZablIzWVhKbEFFbHRZV2RsVFdGbmFXTnJJRFl1Tmk0NUxUY2dNakF4TkMwd015MHdOaUJSTVRZZ2FIUjBjRG92TDNkM2R5NXBiV0ZuWlcxaFoybGpheTV2Y21lQjA3UERBQUFBR0hSRldIUlVhSFZ0WWpvNlJHOWpkVzFsYm5RNk9sQmhaMlZ6QURHbi83c3ZBQUFBR0hSRldIUlVhSFZ0WWpvNlNXMWhaMlU2T21obGFXZG9kQUF6TlRSSlVrelNBQUFBRjNSRldIUlVhSFZ0WWpvNlNXMWhaMlU2T2xkcFpIUm9BREk0TVZINC82b0FBQUFaZEVWWWRGUm9kVzFpT2pwTmFXMWxkSGx3WlFCcGJXRm5aUzl3Ym1jL3NsWk9BQUFBRjNSRldIUlVhSFZ0WWpvNlRWUnBiV1VBTVRReU5UYzNNakkwTnJkRDcwTUFBQUFTZEVWWWRGUm9kVzFpT2pwVGFYcGxBREUxTkV0Q1FzNE1WdHNBQUFBemRFVllkRlJvZFcxaU9qcFZVa2tBWm1sc1pUb3ZMeTkwYlhBdmJHOWpZV3hqYjNCNVgyUm1aalV3WkRFME9UTmtaaTB4TG5CdVovWlhFbzBBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvcmFwaGFlbC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAzMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXG4gKiogbW9kdWxlIGlkID0gMjg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9