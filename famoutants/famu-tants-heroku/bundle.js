/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(152);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactRedux = __webpack_require__(30);
	
	var _app = __webpack_require__(146);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_reactDom2.default.render(_react2.default.createElement(
	  _reactRedux.Provider,
	  { store: _store2.default },
	  _react2.default.createElement(_app2.default, null)
	), document.getElementById('root'));

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule reactProdInvariant
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(207);


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentTree
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentFlags = __webpack_require__(103);
	
	var invariant = __webpack_require__(2);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(197);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstrumentation
	 */
	
	'use strict';
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(228);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentTreeHook
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var itemMap;
	var rootIDSet;
	
	var itemByKey;
	var rootByKey;
	
	if (canUseCollections) {
	  itemMap = new Map();
	  rootIDSet = new Set();
	} else {
	  itemByKey = {};
	  rootByKey = {};
	}
	
	var unmountedIDs = [];
	
	// Use non-numeric keys to prevent V8 performance issues:
	// https://github.com/facebook/react/pull/7232
	function getKeyFromID(id) {
	  return '.' + id;
	}
	function getIDFromKey(key) {
	  return parseInt(key.substr(1), 10);
	}
	
	function get(id) {
	  if (canUseCollections) {
	    return itemMap.get(id);
	  } else {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  }
	}
	
	function remove(id) {
	  if (canUseCollections) {
	    itemMap['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  }
	}
	
	function create(id, element, parentID) {
	  var item = {
	    element: element,
	    parentID: parentID,
	    text: null,
	    childIDs: [],
	    isMounted: false,
	    updateCount: 0
	  };
	
	  if (canUseCollections) {
	    itemMap.set(id, item);
	  } else {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  }
	}
	
	function addRoot(id) {
	  if (canUseCollections) {
	    rootIDSet.add(id);
	  } else {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  }
	}
	
	function removeRoot(id) {
	  if (canUseCollections) {
	    rootIDSet['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  }
	}
	
	function getRegisteredIDs() {
	  if (canUseCollections) {
	    return Array.from(itemMap.keys());
	  } else {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  }
	}
	
	function getRootIDs() {
	  if (canUseCollections) {
	    return Array.from(rootIDSet.keys());
	  } else {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  }
	}
	
	function purgeDeep(id) {
	  var item = get(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    remove(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = get(id);
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = get(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent ID is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    create(id, element, parentID);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = get(id);
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = get(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = get(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var type = topElement.type;
	      var name = typeof type === 'function' ? type.displayName || type.name : type;
	      var owner = topElement._owner;
	      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = get(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = get(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = get(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = get(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = get(id);
	    return item ? item.updateCount : 0;
	  },
	
	
	  getRegisteredIDs: getRegisteredIDs,
	
	  getRootIDs: getRootIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var warning = __webpack_require__(3);
	var canDefineProperty = __webpack_require__(68);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      Object.defineProperty(element, '_shadowChildren', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: shadowChildren
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._shadowChildren = shadowChildren;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactReconciler = __webpack_require__(29);
	var Transaction = __webpack_require__(35);
	
	var invariant = __webpack_require__(2);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.props === component._renderedComponent._currentElement) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topAnimationEnd: null,
	  topAnimationIteration: null,
	  topAnimationStart: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topInvalid: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topTransitionEnd: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(5);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMLazyTree
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(57);
	var setInnerHTML = __webpack_require__(48);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setTextContent = __webpack_require__(123);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(241);
	var ReactInstrumentation = __webpack_require__(11);
	
	var warning = __webpack_require__(3);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(153);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(154);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventPluginRegistry = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(58);
	var ReactErrorUtils = __webpack_require__(63);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var invariant = __webpack_require__(2);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var warning = __webpack_require__(3);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 33 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(128);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(287);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(286);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(285);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(180);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(194);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(24);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && typeof object[p] === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DisabledInputUtils
	 */
	
	'use strict';
	
	var disableableMouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var DisabledInputUtils = {
	  getHostProps: function (inst, props) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var hostProps = {};
	    for (var key in props) {
	      if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
	        hostProps[key] = props[key];
	      }
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = DisabledInputUtils;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventConstants = __webpack_require__(17);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactEventEmitterMixin = __webpack_require__(231);
	var ViewportMetrics = __webpack_require__(115);
	
	var getVendorPrefixedEventName = __webpack_require__(263);
	var isEventSupported = __webpack_require__(74);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	var ViewportMetrics = __webpack_require__(115);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var DOMNamespaces = __webpack_require__(57);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var newNodes = reusableSVGContainer.firstChild.childNodes;
	    for (var i = 0; i < newNodes.length; i++) {
	      node.appendChild(newNodes[i]);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(5);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _Actions = __webpack_require__(27);
	
	var _computeChangedRoutes2 = __webpack_require__(178);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(175);
	
	var _isActive2 = __webpack_require__(182);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(179);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(184);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  function createLocationFromRedirectInfo(location) {
	    return history.createLocation(location, _Actions.REPLACE);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, createLocationFromRedirectInfo(redirectInfo));
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.transitionTo(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(28);
	var Danger = __webpack_require__(202);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setInnerHTML = __webpack_require__(48);
	var setTextContent = __webpack_require__(123);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMNamespaces
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(63);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 59 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule KeyEscapeUtils
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypes = __webpack_require__(113);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var canDefineProperty = __webpack_require__(68);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 66 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypesSecret
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 69 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createMicrosoftUnsafeLocalFunction
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 71 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 75 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	
	var getIteratorFn = __webpack_require__(73);
	var invariant = __webpack_require__(2);
	var KeyEscapeUtils = __webpack_require__(59);
	var warning = __webpack_require__(3);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      if (childTag !== '#text') {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reduxLogger = __webpack_require__(281);
	
	var _reduxLogger2 = _interopRequireDefault(_reduxLogger);
	
	var _reduxThunk = __webpack_require__(284);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _reduxPromiseMiddleware = __webpack_require__(282);
	
	var _reduxPromiseMiddleware2 = _interopRequireDefault(_reduxPromiseMiddleware);
	
	var _reducers = __webpack_require__(141);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var middleware = (0, _redux.applyMiddleware)((0, _reduxPromiseMiddleware2.default)(), _reduxThunk2.default, (0, _reduxLogger2.default)());
	
	exports.default = (0, _redux.createStore)(_reducers2.default);
	//export default createStore(reducer, middleware)

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * This action type will be dispatched by the history actions below.
	 * If you're writing a middleware to watch for navigation events, be sure to
	 * look for actions of this type.
	 */
	var CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';
	
	function updateLocation(method) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return {
	      type: CALL_HISTORY_METHOD,
	      payload: { method: method, args: args }
	    };
	  };
	}
	
	/**
	 * These actions correspond to the history API.
	 * The associated routerMiddleware will capture these events before they get to
	 * your reducer and reissue them as the matching function on your history.
	 */
	var push = exports.push = updateLocation('push');
	var replace = exports.replace = updateLocation('replace');
	var go = exports.go = updateLocation('go');
	var goBack = exports.goBack = updateLocation('goBack');
	var goForward = exports.goForward = updateLocation('goForward');
	
	var routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;
	
	var _reducer = __webpack_require__(84);
	
	Object.defineProperty(exports, 'LOCATION_CHANGE', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.LOCATION_CHANGE;
	  }
	});
	Object.defineProperty(exports, 'routerReducer', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.routerReducer;
	  }
	});
	
	var _actions = __webpack_require__(82);
	
	Object.defineProperty(exports, 'CALL_HISTORY_METHOD', {
	  enumerable: true,
	  get: function get() {
	    return _actions.CALL_HISTORY_METHOD;
	  }
	});
	Object.defineProperty(exports, 'push', {
	  enumerable: true,
	  get: function get() {
	    return _actions.push;
	  }
	});
	Object.defineProperty(exports, 'replace', {
	  enumerable: true,
	  get: function get() {
	    return _actions.replace;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _actions.go;
	  }
	});
	Object.defineProperty(exports, 'goBack', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goBack;
	  }
	});
	Object.defineProperty(exports, 'goForward', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goForward;
	  }
	});
	Object.defineProperty(exports, 'routerActions', {
	  enumerable: true,
	  get: function get() {
	    return _actions.routerActions;
	  }
	});
	
	var _sync = __webpack_require__(165);
	
	var _sync2 = _interopRequireDefault(_sync);
	
	var _middleware = __webpack_require__(164);
	
	var _middleware2 = _interopRequireDefault(_middleware);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	exports.syncHistoryWithStore = _sync2['default'];
	exports.routerMiddleware = _middleware2['default'];

/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.routerReducer = routerReducer;
	/**
	 * This action type will be dispatched when your history
	 * receives a location change.
	 */
	var LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';
	
	var initialState = {
	  locationBeforeTransitions: null
	};
	
	/**
	 * This reducer will update the state with the most recent location history
	 * has transitioned to. This may not be in sync with the router, particularly
	 * if you have asynchronously-loaded routes, so reading from and relying on
	 * this state is discouraged.
	 */
	function routerReducer() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
	
	  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  var type = _ref.type;
	  var payload = _ref.payload;
	
	  if (type === LOCATION_CHANGE) {
	    return _extends({}, state, { locationBeforeTransitions: payload });
	  }
	
	  return state;
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]).isRequired,
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	
	    if (router) {
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(190);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(92);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(20);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(51);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(26);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(173);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(85);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(167);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(186);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(168);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(169);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(86);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(171);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(166);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(170);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(172);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(185);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(38);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(174);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(183);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(92);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(176);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(177);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(181);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(88);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(191);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(24);
	
	var _AsyncUtils = __webpack_require__(187);
	
	var _Actions = __webpack_require__(27);
	
	var _createLocation2 = __webpack_require__(189);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if (typeof action === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _PathUtils = __webpack_require__(24);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	_assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  checkpoint: function () {
	    return this._callbacks ? this._callbacks.length : 0;
	  },
	
	  rollback: function (len) {
	    if (this._callbacks) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var quoteAttributeValueForBrowser = __webpack_require__(265);
	var warning = __webpack_require__(3);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(21);
	var ReactElement = __webpack_require__(13);
	
	var emptyFunction = __webpack_require__(14);
	var traverseAllChildren = __webpack_require__(76);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var keyMirror = __webpack_require__(49);
	var keyOf = __webpack_require__(22);
	var warning = __webpack_require__(3);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec;
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function () {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentFlags
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	
	var checkReactTypeSpec = __webpack_require__(117);
	
	var canDefineProperty = __webpack_require__(68);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 107 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactFeatureFlags
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var invariant = __webpack_require__(2);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(223);
	
	var containsNode = __webpack_require__(269);
	var focusNode = __webpack_require__(125);
	var getActiveElement = __webpack_require__(126);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var DOMProperty = __webpack_require__(25);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMContainerInfo = __webpack_require__(215);
	var ReactDOMFeatureFlags = __webpack_require__(218);
	var ReactElement = __webpack_require__(13);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMarkupChecksum = __webpack_require__(236);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdateQueue = __webpack_require__(67);
	var ReactUpdates = __webpack_require__(16);
	
	var emptyObject = __webpack_require__(36);
	var instantiateReactComponent = __webpack_require__(121);
	var invariant = __webpack_require__(2);
	var setInnerHTML = __webpack_require__(48);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNodeTypes
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (ReactElement.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var emptyFunction = __webpack_require__(14);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '15.3.1';

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule checkReactTypeSpec
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(12);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getHostComponentFromComposite
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(112);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactCompositeComponent = __webpack_require__(211);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactHostComponent = __webpack_require__(108);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	var nextDebugID = 1;
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 122 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var setInnerHTML = __webpack_require__(48);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 127 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(292);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing “what changed”. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 130 */
[306, 288, 289, 291],
/* 131 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectTurtle = exports.selectTurtle = function selectTurtle(turtle) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "TURTLE_SELECTED",
	    payload: turtle
	  };
	};

/***/ },
/* 133 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectUser = exports.selectUser = function selectUser(user) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "USER_SELECTED",
	    payload: user
	  };
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _turtleList = __webpack_require__(137);
	
	var _turtleList2 = _interopRequireDefault(_turtleList);
	
	var _turtleDetail = __webpack_require__(136);
	
	var _turtleDetail2 = _interopRequireDefault(_turtleDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompTurtle = function CompTurtle() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Ninja Turtles List:'
	    ),
	    _react2.default.createElement(_turtleList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_turtleDetail2.default, null)
	  );
	};
	exports.default = CompTurtle;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _userList = __webpack_require__(139);
	
	var _userList2 = _interopRequireDefault(_userList);
	
	var _userDetail = __webpack_require__(138);
	
	var _userDetail2 = _interopRequireDefault(_userDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompUser = function CompUser() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Influential Persons List:'
	    ),
	    _react2.default.createElement(_userList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_userDetail2.default, null)
	  );
	};
	exports.default = CompUser;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var TurtleDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    turtle: state.activeTurtle
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(TurtleDetail, _React$Component);
	
	  function TurtleDetail() {
	    _classCallCheck(this, TurtleDetail);
	
	    return _possibleConstructorReturn(this, (TurtleDetail.__proto__ || Object.getPrototypeOf(TurtleDetail)).apply(this, arguments));
	  }
	
	  _createClass(TurtleDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.turtle) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite Ninja and click...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.turtle.image, width: '250', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.turtle.name,
	            ' aka "',
	            this.props.turtle.aka,
	            '"'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Age:   ',
	            this.props.turtle.age
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description:   ',
	            this.props.turtle.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Images and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return TurtleDetail;
	}(_react2.default.Component)) || _class);
	exports.default = TurtleDetail;
	// function mapStateToProps(state) {
	//   return {
	//     turtle: state.activeTurtle
	//   };
	// }
	// export default connect(mapStateToProps)(TurtleDetail);

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _turtle = __webpack_require__(132);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TurtleList = function (_React$Component) {
	  _inherits(TurtleList, _React$Component);
	
	  function TurtleList() {
	    _classCallCheck(this, TurtleList);
	
	    return _possibleConstructorReturn(this, (TurtleList.__proto__ || Object.getPrototypeOf(TurtleList)).apply(this, arguments));
	  }
	
	  _createClass(TurtleList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.turtles.map(function (turtle) {
	        return _react2.default.createElement(
	          'li',
	          { key: turtle.id, onClick: function onClick() {
	              return _this2.props.selectTurtle(turtle);
	            } },
	          turtle.name
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return TurtleList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    turtles: state.turtles
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectTurtle: _turtle.selectTurtle }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(TurtleList);

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var UserDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    user: state.activeUser
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(UserDetail, _React$Component);
	
	  function UserDetail() {
	    _classCallCheck(this, UserDetail);
	
	    return _possibleConstructorReturn(this, (UserDetail.__proto__ || Object.getPrototypeOf(UserDetail)).apply(this, arguments));
	  }
	
	  _createClass(UserDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.user) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite famous person and select...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.user.image, width: '300', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.user.name,
	            ' ',
	            this.props.user.last
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Born:   ',
	            this.props.user.bornMonth,
	            ' ',
	            this.props.user.bornDay,
	            ', ',
	            this.props.user.bornYear,
	            this.props.user.age[2]
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Would have been around ',
	            this.props.user.age[0],
	            ' years and ',
	            this.props.user.age[1],
	            ' months old now, if were still alive.'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description:   ',
	            this.props.user.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Photos and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return UserDetail;
	}(_react2.default.Component)) || _class);
	exports.default = UserDetail;
	
	// function mapStateToProps(state) {
	//   return {
	//     user: state.activeUser
	//   };
	// }
	// export default connect(mapStateToProps)(UserDetail);

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _user = __webpack_require__(133);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import store from '../store'
	
	// store.subscribe( () => {
	// console.log("Store changed", store.getState())
	// });
	// //below snippet is a sample of how to add a state into the code
	// //but should be matched by a corresponding reducer function to record and update this new state
	// store.dispatch({type: "ADD_USER_NAME", payload: "Rod"})
	// store.dispatch({type: "ADD_USER_AGE", payload: 23})
	
	var UserList = function (_React$Component) {
	  _inherits(UserList, _React$Component);
	
	  function UserList() {
	    _classCallCheck(this, UserList);
	
	    return _possibleConstructorReturn(this, (UserList.__proto__ || Object.getPrototypeOf(UserList)).apply(this, arguments));
	  }
	
	  _createClass(UserList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.users.map(function (user) {
	        return _react2.default.createElement(
	          'li',
	          { key: user.id, onClick: function onClick() {
	              return _this2.props.selectUser(user);
	            } },
	          user.name,
	          ' ',
	          user.last
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return UserList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    users: state.users
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectUser: _user.selectUser }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(UserList);

/***/ },
/* 140 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = function (_ref) {
	  var _ref2 = _slicedToArray(_ref, 3);
	
	  var a = _ref2[0];
	  var b = _ref2[1];
	  var c = _ref2[2];
	
	  //This calculation is roughly accurate to months,as you can see...
	  var d = "";
	
	  if (b < 0) {
	    a = a - 1, b = 12 - Math.abs(b);
	  }
	  if (c < 0) {
	    b = b - 1;
	  }
	  if (b === 0 && c === 0) {
	    d = ": Hey, Happy Birthday!!!";
	  } else {
	    d = ".";
	  }
	  return [a, b, d];
	};
	
	;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _reducerUsers = __webpack_require__(145);
	
	var _reducerUsers2 = _interopRequireDefault(_reducerUsers);
	
	var _reducerTurtles = __webpack_require__(144);
	
	var _reducerTurtles2 = _interopRequireDefault(_reducerTurtles);
	
	var _reducerActiveUser = __webpack_require__(143);
	
	var _reducerActiveUser2 = _interopRequireDefault(_reducerActiveUser);
	
	var _reducerActiveTurtle = __webpack_require__(142);
	
	var _reducerActiveTurtle2 = _interopRequireDefault(_reducerActiveTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var allReducers = (0, _redux.combineReducers)({
	  users: _reducerUsers2.default,
	  turtles: _reducerTurtles2.default,
	  activeUser: _reducerActiveUser2.default,
	  activeTurtle: _reducerActiveTurtle2.default,
	  routing: _reactRouterRedux.routerReducer
	});
	
	exports.default = allReducers;

/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "TURTLE_SELECTED":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 143 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "USER_SELECTED":
	      return action.payload;
	      break;
	    case "ADD_USER_NAME":
	      return action.payload;
	      break;
	    case "ADD_USER_AGE":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    id: 1,
	    name: "Leonardo",
	    aka: "Leo",
	    age: "< 20",
	    image: _leonardo2.default,
	    description: "Leonardo is the cool, courageous leader of the Ninja Turtles and a devoted student of Ninjutsu, usually wearing a blue mask and wielding two katanas. Leader in blue."
	  }, {
	    id: 2,
	    name: "Michaelangelo",
	    aka: "Mickey",
	    age: "eternally < 20",
	    image: _michaelangelo2.default,
	    description: "Michelangelo is the most comical of the Ninja Turtles, usually wearing an orange mask and wielding a pair of nunchucks."
	  }, {
	    id: 3,
	    name: "Donatello",
	    aka: "Donnie",
	    age: "eternally < 20",
	    image: _donatello2.default,
	    description: "Donatello is the scientist, inventor, engineer and technological genius of the Ninja Turtles, usually wearing a purple mask and wielding a bo-staff."
	  }, {
	    id: 4,
	    name: "Raphael",
	    aka: "Raph",
	    age: "eternally < 20",
	    image: _raphael2.default,
	    description: "Raphael is the bad boy of the Ninja Turtles, wearing a red mask and wielding a pair of sais."
	  }];
	};
	
	var _leonardo = __webpack_require__(302);
	
	var _leonardo2 = _interopRequireDefault(_leonardo);
	
	var _michaelangelo = __webpack_require__(303);
	
	var _michaelangelo2 = _interopRequireDefault(_michaelangelo);
	
	var _donatello = __webpack_require__(301);
	
	var _donatello2 = _interopRequireDefault(_donatello);
	
	var _raphael = __webpack_require__(304);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	
	  var today = new Date(),
	      dd = today.getDate(),
	      mm = today.getMonth() + 1,
	      yyyy = today.getFullYear();
	
	  return [{
	    id: 1,
	    name: "Leonardo",
	    last: "Da Vinci",
	    bornMonth: "April",
	    bornDay: 15,
	    bornYear: 1452,
	    age: (0, _ageCalculator2.default)([yyyy - 1452, mm - 4, dd - 15]),
	    image: _daVinci2.default,
	    description: "Leonardo di ser Piero da Vinci, more commonly Leonardo a Vinci or simply Leonardo, was an Italian polymath whose areas of interest included invention, painting, sculpting, architecture, science, music, mathematics, engineering, literature, anatomy, geology, astronomy, botany, writing, history, and cartography. He has been variously called the father of palaeontology, ichnology, and architecture, and is widely considered one of the greatest painters of all time. Sometimes credited with the inventions of the parachute, helicopter and tank, he epitomised the Renaissance humanist ideal."
	  }, {
	    id: 2,
	    name: "Isaac",
	    last: "Newton",
	    bornMonth: "January",
	    bornDay: 4,
	    bornYear: 1643,
	    age: (0, _ageCalculator2.default)([yyyy - 1643, mm - 1, dd - 4]),
	    image: _Newton2.default,
	    description: "Sir Isaac Newton was an English physicist and mathematician (described in his own day as a \"natural philosopher\") who is widely recognised as one of the most influential scientists of all time and a key figure in the scientific revolution. His book Philosophiæ Naturalis Principia Mathematica (\"Mathematical Principles of Natural Philosophy\"), first published in 1687, laid the foundations for classical mechanics. Newton made seminal contributions to optics, and he shares credit with Gottfried Wilhelm Leibniz for the development of calculus."
	  }, {
	    id: 3,
	    name: "Leonhard",
	    last: "Euler",
	    bornMonth: "April",
	    bornDay: 15,
	    bornYear: 1707,
	    age: (0, _ageCalculator2.default)([yyyy - 1707, mm - 4, dd - 15]),
	    image: _Euler2.default,
	    description: "Leonhard Euler was a Swiss mathematician, physicist, astronomer, logician and engineer who made important and influential discoveries in many branches of mathematics like infinitesimal calculus and graph theory while also making pioneering contributions to several branches such as topology and analytic number theory. He also introduced much of the modern mathematical terminology and notation, particularly for mathematical analysis, such as the notion of a mathematical function.  He is also known for his work in mechanics, fluid dynamics, optics, astronomy, and music theory."
	  }, {
	    id: 4,
	    name: "Albert",
	    last: "Einstein",
	    bornMonth: "March",
	    bornDay: 14,
	    bornYear: 1879,
	    age: (0, _ageCalculator2.default)([yyyy - 1879, mm - 3, dd - 14]),
	    image: _Einstein2.default,
	    description: "Albert Einstein was a German-born theoretical physicist. He developed the general theory of relativity, one of the two pillars of modern physics (alongside quantum mechanics).  Einstein's work is also known for its influence on the philosophy of science.  Einstein is best known in popular culture for his mass–energy equivalence formula E = mc2 (which has been dubbed \"the world's most famous equation\").  He received the 1921 Nobel Prize in Physics for his \"services to theoretical physics\", in particular his discovery of the law of the photoelectric effect, a pivotal step in the evolution of quantum theory."
	  }, {
	    id: 5,
	    name: "Erwin",
	    last: "Schroedinger",
	    bornMonth: "August",
	    bornDay: 12,
	    bornYear: 1887,
	    age: (0, _ageCalculator2.default)([yyyy - 1887, mm - 8, dd - 12]),
	    image: _Schroedinger2.default,
	    description: "Erwin Rudolf Josef Alexander Schrödinger, sometimes written as Erwin Schrodinger or Erwin Schroedinger, was a Nobel Prize-winning Austrian physicist who developed a number of fundamental results in the field of quantum theory, which formed the basis of wave mechanics: he formulated the wave equation (stationary and time-dependent Schrödinger equation) and revealed the identity of his development of the formalism and matrix mechanics. Schrödinger proposed an original interpretation of the physical meaning of the wave function."
	  }, {
	    id: 6,
	    name: "Georges",
	    last: "Lemaitre",
	    bornMonth: "July",
	    bornDay: 17,
	    bornYear: 1894,
	    age: (0, _ageCalculator2.default)([yyyy - 1894, mm - 7, dd - 17]),
	    image: _Lemaitre2.default,
	    description: "Georges Henri Joseph Édouard Lemaître was a Belgian priest, astronomer and professor of physics at the Catholic University of Leuven.  He proposed the theory of the expansion of the universe, widely misattributed to Edwin Hubble.  He was the first to derive what is now known as Hubble's law and made the first estimation of what is now called the Hubble constant, which he published in 1927, two years before Hubble's article.  Lemaître also proposed what became known as the Big Bang theory of the origin of the universe, which he called his \"hypothesis of the primeval atom\" or the \"Cosmic Egg\"."
	  }, {
	    id: 7,
	    name: "Mother",
	    last: "Teresa",
	    bornMonth: "August",
	    bornDay: 26,
	    bornYear: 1910,
	    age: (0, _ageCalculator2.default)([yyyy - 1910, mm - 8, dd - 26]),
	    image: _MTeresa2.default,
	    description: "Mother Teresa MC, known in the Catholic Church as Saint Teresa of Calcutta was an Albanian-Indian Roman Catholic nun and missionary.  She was born in Skopje (now capital of the Republic of Macedonia), then part of the Kosovo Vilayet in the Ottoman Empire. After having lived in Macedonia for eighteen years, she moved to Ireland and then to India, where she lived for most of her life.  In 1950, Teresa founded the Missionaries of Charity, a Roman Catholic religious congregation, which in 2012 consisted of over 4,500 sisters and was active in 133 countries. They run homes for people dying of HIV/AIDS, leprosy and tuberculosis; soup kitchens; dispensaries and mobile clinics; children's and family counselling programmes; orphanages; and schools. Members must adhere to the vows of chastity, poverty, and obedience, as well as a fourth vow, to give \"wholehearted free service to the poorest of the poor.\""
	  }];
	};
	
	var _daVinci = __webpack_require__(300);
	
	var _daVinci2 = _interopRequireDefault(_daVinci);
	
	var _Einstein = __webpack_require__(294);
	
	var _Einstein2 = _interopRequireDefault(_Einstein);
	
	var _Euler = __webpack_require__(295);
	
	var _Euler2 = _interopRequireDefault(_Euler);
	
	var _Lemaitre = __webpack_require__(296);
	
	var _Lemaitre2 = _interopRequireDefault(_Lemaitre);
	
	var _MTeresa = __webpack_require__(297);
	
	var _MTeresa2 = _interopRequireDefault(_MTeresa);
	
	var _Newton = __webpack_require__(298);
	
	var _Newton2 = _interopRequireDefault(_Newton);
	
	var _Schroedinger = __webpack_require__(299);
	
	var _Schroedinger2 = _interopRequireDefault(_Schroedinger);
	
	var _ageCalculator = __webpack_require__(140);
	
	var _ageCalculator2 = _interopRequireDefault(_ageCalculator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _container = __webpack_require__(147);
	
	var _home = __webpack_require__(148);
	
	var _user = __webpack_require__(151);
	
	var _turtles = __webpack_require__(150);
	
	var _notfound = __webpack_require__(149);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var history = (0, _reactRouterRedux.syncHistoryWithStore)(_reactRouter.browserHistory, _store2.default);
	
	var App = function (_React$Component) {
	  _inherits(App, _React$Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        _reactRouter.Router,
	        { history: history },
	        _react2.default.createElement(
	          _reactRouter.Route,
	          { path: '/', component: _container.Container },
	          _react2.default.createElement(_reactRouter.IndexRoute, { component: _home.Home }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'user', component: _user.User }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'turtles(/:name)', component: _turtles.Turtles }),
	          _react2.default.createElement(_reactRouter.Route, { path: '*', component: _notfound.NotFound })
	        )
	      );
	    }
	  }]);
	
	  return App;
	}(_react2.default.Component);
	
	exports.default = App;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Container = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  fontFamily: 'Dosis'
	};
	
	var Container = exports.Container = function Container(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement(Nav, null),
	    props.children
	  );
	};
	var Nav = function Nav() {
	  return _react2.default.createElement(
	    'nav',
	    { className: 'navbar navbar-inverse' },
	    _react2.default.createElement(
	      'div',
	      { className: 'container-fluid' },
	      _react2.default.createElement(
	        'div',
	        { className: 'navbar-header' },
	        _react2.default.createElement(
	          'button',
	          { type: 'button', className: 'navbar-toggle', 'data-toggle': 'collapse', 'data-target': '#myNavbar' },
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' })
	        )
	      )
	    ),
	    _react2.default.createElement(
	      'div',
	      { className: 'collapse navbar-collapse', id: 'myNavbar' },
	      _react2.default.createElement(
	        'ul',
	        { className: 'nav navbar-nav' },
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/' },
	            'Home'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/user' },
	            'Famous People'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/turtles' },
	            'Mutant Turtles'
	          )
	        )
	      )
	    )
	  );
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Home = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Home = exports.Home = function Home() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'Welcome to the World of famE and muTAatIoNs!'
	    ),
	    _react2.default.createElement(
	      'h4',
	      null,
	      '> click on navigation to see more...'
	    )
	  );
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NotFound = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NotFound = exports.NotFound = function NotFound() {
	  return _react2.default.createElement(
	    'h2',
	    null,
	    '404: This page is not found!'
	  );
	};

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Turtles = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compTurtle = __webpack_require__(134);
	
	var _compTurtle2 = _interopRequireDefault(_compTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Turtles = exports.Turtles = function Turtles(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Turtles Page'
	    ),
	    _react2.default.createElement(_compTurtle2.default, null)
	  );
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.User = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compUser = __webpack_require__(135);
	
	var _compUser2 = _interopRequireDefault(_compUser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var User = exports.User = function User() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Famous People Page'
	    ),
	    _react2.default.createElement(_compUser2.default, null)
	  );
	};

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(212);


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (process.env.NODE_ENV !== 'production') {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(155);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(156);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(163);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(157);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(158);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (process.env.NODE_ENV !== 'production') {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 155 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(37);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {
	
	                }
	            }
	        }
	    }
	
	    return targetComponent;
	};


/***/ },
/* 158 */
10,
/* 159 */
[305, 161],
/* 160 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 161 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 163 */
[306, 159, 160, 162],
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports['default'] = routerMiddleware;
	
	var _actions = __webpack_require__(82);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	/**
	 * This middleware captures CALL_HISTORY_METHOD actions to redirect to the
	 * provided history object. This will prevent these actions from reaching your
	 * reducer or any middleware that comes after this one.
	 */
	function routerMiddleware(history) {
	  return function () {
	    return function (next) {
	      return function (action) {
	        if (action.type !== _actions.CALL_HISTORY_METHOD) {
	          return next(action);
	        }
	
	        var _action$payload = action.payload;
	        var method = _action$payload.method;
	        var args = _action$payload.args;
	
	        history[method].apply(history, _toConsumableArray(args));
	      };
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = syncHistoryWithStore;
	
	var _reducer = __webpack_require__(84);
	
	var defaultSelectLocationState = function defaultSelectLocationState(state) {
	  return state.routing;
	};
	
	/**
	 * This function synchronizes your history state with the Redux store.
	 * Location changes flow from history to the store. An enhanced history is
	 * returned with a listen method that responds to store updates for location.
	 *
	 * When this history is provided to the router, this means the location data
	 * will flow like this:
	 * history.push -> store.dispatch -> enhancedHistory.listen -> router
	 * This ensures that when the store state changes due to a replay or other
	 * event, the router will be updated appropriately and can transition to the
	 * correct router state.
	 */
	function syncHistoryWithStore(history, store) {
	  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	  var _ref$selectLocationSt = _ref.selectLocationState;
	  var selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt;
	  var _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay;
	  var adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;
	
	  // Ensure that the reducer is mounted on the store and functioning properly.
	  if (typeof selectLocationState(store.getState()) === 'undefined') {
	    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');
	  }
	
	  var initialLocation = void 0;
	  var isTimeTraveling = void 0;
	  var unsubscribeFromStore = void 0;
	  var unsubscribeFromHistory = void 0;
	
	  // What does the store say about current location?
	  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {
	    var locationState = selectLocationState(store.getState());
	    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);
	  };
	
	  // Init currentLocation with potential location in store
	  var currentLocation = getLocationInStore();
	
	  // If the store is replayed, update the URL in the browser to match.
	  if (adjustUrlOnReplay) {
	    var handleStoreChange = function handleStoreChange() {
	      var locationInStore = getLocationInStore(true);
	      if (currentLocation === locationInStore) {
	        return;
	      }
	
	      // Update address bar to reflect store state
	      isTimeTraveling = true;
	      currentLocation = locationInStore;
	      history.transitionTo(_extends({}, locationInStore, {
	        action: 'PUSH'
	      }));
	      isTimeTraveling = false;
	    };
	
	    unsubscribeFromStore = store.subscribe(handleStoreChange);
	    handleStoreChange();
	  }
	
	  // Whenever location changes, dispatch an action to get it in the store
	  var handleLocationChange = function handleLocationChange(location) {
	    // ... unless we just caused that location change
	    if (isTimeTraveling) {
	      return;
	    }
	
	    // Remember where we are
	    currentLocation = location;
	
	    // Are we being called for the first time?
	    if (!initialLocation) {
	      // Remember as a fallback in case state is reset
	      initialLocation = location;
	
	      // Respect persisted location, if any
	      if (getLocationInStore()) {
	        return;
	      }
	    }
	
	    // Tell the store to update by dispatching an action
	    store.dispatch({
	      type: _reducer.LOCATION_CHANGE,
	      payload: location
	    });
	  };
	  unsubscribeFromHistory = history.listen(handleLocationChange);
	
	  // The enhanced history uses store as source of truth
	  return _extends({}, history, {
	    // The listeners are subscribed to the store instead of history
	
	    listen: function listen(listener) {
	      // Copy of last location.
	      var lastPublishedLocation = getLocationInStore(true);
	
	      // Keep track of whether we unsubscribed, as Redux store
	      // only applies changes in subscriptions on next dispatch
	      var unsubscribed = false;
	      var unsubscribeFromStore = store.subscribe(function () {
	        var currentLocation = getLocationInStore(true);
	        if (currentLocation === lastPublishedLocation) {
	          return;
	        }
	        lastPublishedLocation = currentLocation;
	        if (!unsubscribed) {
	          listener(lastPublishedLocation);
	        }
	      });
	
	      // History listeners expect a synchronous call. Make the first call to the
	      // listener after subscribing to the store, in case the listener causes a
	      // location change (e.g. when it redirects)
	      listener(lastPublishedLocation);
	
	      // Let user unsubscribe later
	      return function () {
	        unsubscribed = true;
	        unsubscribeFromStore();
	      };
	    },
	
	
	    // It also provides a way to destroy internal listeners
	    unsubscribe: function unsubscribe() {
	      if (adjustUrlOnReplay) {
	        unsubscribeFromStore();
	      }
	      unsubscribeFromHistory();
	    }
	  });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(85);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(86);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(188);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(26);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(88);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation, nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(20);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(196);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 187 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	          window.history.pushState(historyState, null, path);
	        }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	          window.history.replaceState(historyState, null, path);
	        }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if (typeof action === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(24);
	
	var _Actions = __webpack_require__(27);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if (typeof entry === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(193);
	var isArguments = __webpack_require__(192);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ },
/* 192 */
/***/ function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ },
/* 193 */
/***/ function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;
	
	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strictUriEncode = __webpack_require__(195);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};


/***/ },
/* 195 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};


/***/ },
/* 196 */
157,
/* 197 */
15,
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var focusNode = __webpack_require__(125);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var FallbackCompositionState = __webpack_require__(205);
	var SyntheticCompositionEvent = __webpack_require__(249);
	var SyntheticInputEvent = __webpack_require__(252);
	
	var keyOf = __webpack_require__(22);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactInstrumentation = __webpack_require__(11);
	
	var camelizeStyleName = __webpack_require__(268);
	var dangerousStyleValue = __webpack_require__(258);
	var hyphenateStyleName = __webpack_require__(275);
	var memoizeStringOnly = __webpack_require__(278);
	var warning = __webpack_require__(3);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	var isEventSupported = __webpack_require__(74);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createNodesFromMarkup = __webpack_require__(271);
	var emptyFunction = __webpack_require__(14);
	var invariant = __webpack_require__(2);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(22);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticMouseEvent = __webpack_require__(46);
	
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactComponent = __webpack_require__(61);
	var ReactPureComponent = __webpack_require__(239);
	var ReactClass = __webpack_require__(102);
	var ReactDOMFactories = __webpack_require__(217);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypes = __webpack_require__(113);
	var ReactVersion = __webpack_require__(114);
	
	var onlyChild = __webpack_require__(264);
	var warning = __webpack_require__(3);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function () {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(29);
	
	var instantiateReactComponent = __webpack_require__(121);
	var KeyEscapeUtils = __webpack_require__(59);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(12);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildrenMutationWarningHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element._shadowChildren === undefined) {
	    return;
	  }
	  if (element._shadowChildren === element.props.children) {
	    return;
	  }
	  var isMutated = false;
	  if (Array.isArray(element._shadowChildren)) {
	    if (element._shadowChildren.length === element.props.children.length) {
	      for (var i = 0; i < element._shadowChildren.length; i++) {
	        if (element._shadowChildren[i] !== element.props.children[i]) {
	          isMutated = true;
	        }
	      }
	    } else {
	      isMutated = true;
	    }
	  }
	  if (!Array.isArray(element._shadowChildren) || isMutated) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Component\'s children should not be mutated.%s', ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	var ReactChildrenMutationWarningHook = {
	  onMountComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  },
	  onUpdateComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  }
	};
	
	module.exports = ReactChildrenMutationWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMIDOperations = __webpack_require__(219);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	var ReactErrorUtils = __webpack_require__(63);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactNodeTypes = __webpack_require__(112);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactReconciler = __webpack_require__(29);
	
	var checkReactTypeSpec = __webpack_require__(117);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var shallowEqual = __webpack_require__(78);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function invokeComponentDidMountWithTimer() {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	  publicInstance.componentDidMount();
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	}
	
	function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	  publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	    var instanceOrElement;
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	      instanceOrElement = new Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	    } else {
	      // This can still be an instance in case of factory components
	      // but we'll count this as time spent rendering as the more common case.
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	      instanceOrElement = Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	    }
	    return instanceOrElement;
	  },
	
	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onError();
	        }
	      }
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      inst.componentWillMount();
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var selfDebugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      selfDebugID = this._debugID;
	    }
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        inst.componentWillUnmount();
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	    }
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onEndProcessingChildContext();
	    }
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	      inst.componentWillReceiveProps(nextProps, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = this._debugID;
	      }
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedComponent === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDefaultInjection = __webpack_require__(230);
	var ReactMount = __webpack_require__(110);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdates = __webpack_require__(16);
	var ReactVersion = __webpack_require__(114);
	
	var findDOMNode = __webpack_require__(259);
	var getHostComponentFromComposite = __webpack_require__(119);
	var renderSubtreeIntoContainer = __webpack_require__(266);
	var warning = __webpack_require__(3);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(9);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(11);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(227);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(221);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var DisabledInputUtils = __webpack_require__(42);
	
	/**
	 * Implements a <button> host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getHostProps: DisabledInputUtils.getHostProps
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var AutoFocusUtils = __webpack_require__(198);
	var CSSPropertyOperations = __webpack_require__(200);
	var DOMLazyTree = __webpack_require__(28);
	var DOMNamespaces = __webpack_require__(57);
	var DOMProperty = __webpack_require__(25);
	var DOMPropertyOperations = __webpack_require__(100);
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactDOMButton = __webpack_require__(213);
	var ReactDOMComponentFlags = __webpack_require__(103);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMInput = __webpack_require__(220);
	var ReactDOMOption = __webpack_require__(222);
	var ReactDOMSelect = __webpack_require__(104);
	var ReactDOMTextarea = __webpack_require__(225);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChild = __webpack_require__(237);
	var ReactServerRenderingTransaction = __webpack_require__(242);
	
	var emptyFunction = __webpack_require__(14);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var isEventSupported = __webpack_require__(74);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(3);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setContentChildForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setContentChildForInstrumentation = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setContentChildForInstrumentation.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getHostProps(this, props, hostParent);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getHostProps(this, lastProps);
	        nextProps = ReactDOMButton.getHostProps(this, nextProps);
	        break;
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setContentChildForInstrumentation.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function () {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setContentChildForInstrumentation.call(this, null);
	    }
	  },
	
	  getPublicInstance: function () {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMContainerInfo
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(77);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMEmptyComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 218 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var DOMPropertyOperations = __webpack_require__(100);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked !== undefined : props.value !== undefined;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, DisabledInputUtils.getHostProps(inst, props), {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMNullInputValuePropHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMSelect = __webpack_require__(104);
	
	var warning = __webpack_require__(3);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  ReactChildren.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var getNodeForCharacterOffset = __webpack_require__(262);
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DOMChildrenOperations = __webpack_require__(56);
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting('#text', this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTreeTraversal
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], false, arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], true, arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], true, argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], false, argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMUnknownPropertyHook
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDebugTool
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(235);
	var ReactHostOperationHistoryHook = __webpack_require__(233);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactChildrenMutationWarningHook = __webpack_require__(209);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performanceNow = __webpack_require__(280);
	var warning = __webpack_require__(3);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = null;
	var currentFlushStartTime = null;
	var currentTimerDebugID = null;
	var currentTimerStartTime = null;
	var currentTimerNestedFlushDuration = null;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || ReactComponentTreeHook.getOwnerID(parentID),
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements || [];
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = null;
	    currentFlushMeasurements = null;
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
	
	  var startTime = _lifeCycleTimerStack$.startTime;
	  var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
	  var debugID = _lifeCycleTimerStack$.debugID;
	  var timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }
	
	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }
	
	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onError: function (debugID) {
	    if (currentTimerDebugID != null) {
	      endLifeCycleTimer(currentTimerDebugID, currentTimerType);
	    }
	    emitEvent('onError', debugID);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (debugID, type, payload) {
	    checkDebugID(debugID);
	    emitEvent('onHostOperation', debugID, type, payload);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	ReactDebugTool.addHook(ReactChildrenMutationWarningHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactUpdates = __webpack_require__(16);
	var Transaction = __webpack_require__(35);
	
	var emptyFunction = __webpack_require__(14);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(199);
	var ChangeEventPlugin = __webpack_require__(201);
	var DefaultEventPluginOrder = __webpack_require__(203);
	var EnterLeaveEventPlugin = __webpack_require__(204);
	var HTMLDOMPropertyConfig = __webpack_require__(206);
	var ReactComponentBrowserEnvironment = __webpack_require__(210);
	var ReactDOMComponent = __webpack_require__(214);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMEmptyComponent = __webpack_require__(216);
	var ReactDOMTreeTraversal = __webpack_require__(226);
	var ReactDOMTextComponent = __webpack_require__(224);
	var ReactDefaultBatchingStrategy = __webpack_require__(229);
	var ReactEventListener = __webpack_require__(232);
	var ReactInjection = __webpack_require__(234);
	var ReactReconcileTransaction = __webpack_require__(240);
	var SVGDOMPropertyConfig = __webpack_require__(244);
	var SelectEventPlugin = __webpack_require__(245);
	var SimpleEventPlugin = __webpack_require__(246);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(31);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventListener = __webpack_require__(124);
	var ExecutionEnvironment = __webpack_require__(9);
	var PooledClass = __webpack_require__(21);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var getEventTarget = __webpack_require__(72);
	var getUnboundedScrollPosition = __webpack_require__(273);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 233 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostOperationHistoryHook
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (debugID, type, payload) {
	    history.push({
	      instanceID: debugID,
	      type: type,
	      payload: payload
	    });
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactClass = __webpack_require__(102);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactHostComponent = __webpack_require__(108);
	var ReactUpdates = __webpack_require__(16);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInvalidSetStateWarningHook
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(257);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(29);
	var ReactChildReconciler = __webpack_require__(208);
	
	var emptyFunction = __webpack_require__(14);
	var flattenChildren = __webpack_require__(260);
	var invariant = __webpack_require__(2);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPureComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactInputSelection = __webpack_require__(109);
	var ReactInstrumentation = __webpack_require__(11);
	var Transaction = __webpack_require__(35);
	var ReactUpdateQueue = __webpack_require__(67);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(238);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement.ref !== prevElement.ref ||
	    // If owner changes but we have an unchanged function ref, don't update refs
	    typeof nextElement.ref === 'string' && nextElement._owner !== prevElement._owner
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	var Transaction = __webpack_require__(35);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactServerUpdateQueue = __webpack_require__(243);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function () {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},
	
	  checkpoint: function () {},
	
	  rollback: function () {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerUpdateQueue
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactUpdateQueue = __webpack_require__(67);
	var Transaction = __webpack_require__(35);
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  /* :: transaction: Transaction; */
	
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 244 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInputSelection = __webpack_require__(109);
	var SyntheticEvent = __webpack_require__(19);
	
	var getActiveElement = __webpack_require__(126);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var EventListener = __webpack_require__(124);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticAnimationEvent = __webpack_require__(247);
	var SyntheticClipboardEvent = __webpack_require__(248);
	var SyntheticEvent = __webpack_require__(19);
	var SyntheticFocusEvent = __webpack_require__(251);
	var SyntheticKeyboardEvent = __webpack_require__(253);
	var SyntheticMouseEvent = __webpack_require__(46);
	var SyntheticDragEvent = __webpack_require__(250);
	var SyntheticTouchEvent = __webpack_require__(254);
	var SyntheticTransitionEvent = __webpack_require__(255);
	var SyntheticUIEvent = __webpack_require__(34);
	var SyntheticWheelEvent = __webpack_require__(256);
	
	var emptyFunction = __webpack_require__(14);
	var getEventCharCode = __webpack_require__(70);
	var invariant = __webpack_require__(2);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  animationEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationEnd: true }),
	      captured: keyOf({ onAnimationEndCapture: true })
	    }
	  },
	  animationIteration: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationIteration: true }),
	      captured: keyOf({ onAnimationIterationCapture: true })
	    }
	  },
	  animationStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationStart: true }),
	      captured: keyOf({ onAnimationStartCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  invalid: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInvalid: true }),
	      captured: keyOf({ onInvalidCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  transitionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTransitionEnd: true }),
	      captured: keyOf({ onTransitionEndCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topAnimationEnd: eventTypes.animationEnd,
	  topAnimationIteration: eventTypes.animationIteration,
	  topAnimationStart: eventTypes.animationStart,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topInvalid: eventTypes.invalid,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topTransitionEnd: eventTypes.transitionEnd,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topInvalid:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topAnimationEnd:
	      case topLevelTypes.topAnimationIteration:
	      case topLevelTypes.topAnimationStart:
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case topLevelTypes.topTransitionEnd:
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticAnimationEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventCharCode = __webpack_require__(70);
	var getEventKey = __webpack_require__(261);
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTransitionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 257 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var warning = __webpack_require__(3);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstanceMap = __webpack_require__(33);
	
	var getHostComponentFromComposite = __webpack_require__(119);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 * 
	 */
	
	'use strict';
	
	var KeyEscapeUtils = __webpack_require__(59);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(12);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(70);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 262 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getVendorPrefixedEventName
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(110);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 267 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(267);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(277);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createArrayFromMixed = __webpack_require__(270);
	var getMarkupWrap = __webpack_require__(272);
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 273 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 274 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(274);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 276 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(276);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(279);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 281 */
/***/ function(module, exports) {

	"use strict";
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }
	
	var repeat = function repeat(str, times) {
	  return new Array(times + 1).join(str);
	};
	var pad = function pad(num, maxLength) {
	  return repeat("0", maxLength - num.toString().length) + num;
	};
	var formatTime = function formatTime(time) {
	  return "@ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
	};
	
	// Use the new performance api to get better precision if available
	var timer = typeof performance !== "undefined" && typeof performance.now === "function" ? performance : Date;
	
	/**
	 * parse the level option of createLogger
	 *
	 * @property {string | function | object} level - console[level]
	 * @property {object} action
	 * @property {array} payload
	 * @property {string} type
	 */
	
	function getLogLevel(level, action, payload, type) {
	  switch (typeof level === "undefined" ? "undefined" : _typeof(level)) {
	    case "object":
	      return typeof level[type] === "function" ? level[type].apply(level, _toConsumableArray(payload)) : level[type];
	    case "function":
	      return level(action);
	    default:
	      return level;
	  }
	}
	
	/**
	 * Creates logger with followed options
	 *
	 * @namespace
	 * @property {object} options - options for logger
	 * @property {string | function | object} options.level - console[level]
	 * @property {boolean} options.duration - print duration of each action?
	 * @property {boolean} options.timestamp - print timestamp with each action?
	 * @property {object} options.colors - custom colors
	 * @property {object} options.logger - implementation of the `console` API
	 * @property {boolean} options.logErrors - should errors in action execution be caught, logged, and re-thrown?
	 * @property {boolean} options.collapsed - is group collapsed?
	 * @property {boolean} options.predicate - condition which resolves logger behavior
	 * @property {function} options.stateTransformer - transform state before print
	 * @property {function} options.actionTransformer - transform action before print
	 * @property {function} options.errorTransformer - transform error before print
	 */
	
	function createLogger() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var _options$level = options.level;
	  var level = _options$level === undefined ? "log" : _options$level;
	  var _options$logger = options.logger;
	  var logger = _options$logger === undefined ? console : _options$logger;
	  var _options$logErrors = options.logErrors;
	  var logErrors = _options$logErrors === undefined ? true : _options$logErrors;
	  var collapsed = options.collapsed;
	  var predicate = options.predicate;
	  var _options$duration = options.duration;
	  var duration = _options$duration === undefined ? false : _options$duration;
	  var _options$timestamp = options.timestamp;
	  var timestamp = _options$timestamp === undefined ? true : _options$timestamp;
	  var transformer = options.transformer;
	  var _options$stateTransfo = options.stateTransformer;
	  var // deprecated
	  stateTransformer = _options$stateTransfo === undefined ? function (state) {
	    return state;
	  } : _options$stateTransfo;
	  var _options$actionTransf = options.actionTransformer;
	  var actionTransformer = _options$actionTransf === undefined ? function (actn) {
	    return actn;
	  } : _options$actionTransf;
	  var _options$errorTransfo = options.errorTransformer;
	  var errorTransformer = _options$errorTransfo === undefined ? function (error) {
	    return error;
	  } : _options$errorTransfo;
	  var _options$colors = options.colors;
	  var colors = _options$colors === undefined ? {
	    title: function title() {
	      return "#000000";
	    },
	    prevState: function prevState() {
	      return "#9E9E9E";
	    },
	    action: function action() {
	      return "#03A9F4";
	    },
	    nextState: function nextState() {
	      return "#4CAF50";
	    },
	    error: function error() {
	      return "#F20404";
	    }
	  } : _options$colors;
	
	  // exit if console undefined
	
	  if (typeof logger === "undefined") {
	    return function () {
	      return function (next) {
	        return function (action) {
	          return next(action);
	        };
	      };
	    };
	  }
	
	  if (transformer) {
	    console.error("Option 'transformer' is deprecated, use stateTransformer instead");
	  }
	
	  var logBuffer = [];
	  function printBuffer() {
	    logBuffer.forEach(function (logEntry, key) {
	      var started = logEntry.started;
	      var startedTime = logEntry.startedTime;
	      var action = logEntry.action;
	      var prevState = logEntry.prevState;
	      var error = logEntry.error;
	      var took = logEntry.took;
	      var nextState = logEntry.nextState;
	
	      var nextEntry = logBuffer[key + 1];
	      if (nextEntry) {
	        nextState = nextEntry.prevState;
	        took = nextEntry.started - started;
	      }
	      // message
	      var formattedAction = actionTransformer(action);
	      var isCollapsed = typeof collapsed === "function" ? collapsed(function () {
	        return nextState;
	      }, action) : collapsed;
	
	      var formattedTime = formatTime(startedTime);
	      var titleCSS = colors.title ? "color: " + colors.title(formattedAction) + ";" : null;
	      var title = "action " + (timestamp ? formattedTime : "") + " " + formattedAction.type + " " + (duration ? "(in " + took.toFixed(2) + " ms)" : "");
	
	      // render
	      try {
	        if (isCollapsed) {
	          if (colors.title) logger.groupCollapsed("%c " + title, titleCSS);else logger.groupCollapsed(title);
	        } else {
	          if (colors.title) logger.group("%c " + title, titleCSS);else logger.group(title);
	        }
	      } catch (e) {
	        logger.log(title);
	      }
	
	      var prevStateLevel = getLogLevel(level, formattedAction, [prevState], "prevState");
	      var actionLevel = getLogLevel(level, formattedAction, [formattedAction], "action");
	      var errorLevel = getLogLevel(level, formattedAction, [error, prevState], "error");
	      var nextStateLevel = getLogLevel(level, formattedAction, [nextState], "nextState");
	
	      if (prevStateLevel) {
	        if (colors.prevState) logger[prevStateLevel]("%c prev state", "color: " + colors.prevState(prevState) + "; font-weight: bold", prevState);else logger[prevStateLevel]("prev state", prevState);
	      }
	
	      if (actionLevel) {
	        if (colors.action) logger[actionLevel]("%c action", "color: " + colors.action(formattedAction) + "; font-weight: bold", formattedAction);else logger[actionLevel]("action", formattedAction);
	      }
	
	      if (error && errorLevel) {
	        if (colors.error) logger[errorLevel]("%c error", "color: " + colors.error(error, prevState) + "; font-weight: bold", error);else logger[errorLevel]("error", error);
	      }
	
	      if (nextStateLevel) {
	        if (colors.nextState) logger[nextStateLevel]("%c next state", "color: " + colors.nextState(nextState) + "; font-weight: bold", nextState);else logger[nextStateLevel]("next state", nextState);
	      }
	
	      try {
	        logger.groupEnd();
	      } catch (e) {
	        logger.log("—— log end ——");
	      }
	    });
	    logBuffer.length = 0;
	  }
	
	  return function (_ref) {
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        // exit early if predicate function returns false
	        if (typeof predicate === "function" && !predicate(getState, action)) {
	          return next(action);
	        }
	
	        var logEntry = {};
	        logBuffer.push(logEntry);
	
	        logEntry.started = timer.now();
	        logEntry.startedTime = new Date();
	        logEntry.prevState = stateTransformer(getState());
	        logEntry.action = action;
	
	        var returnedValue = undefined;
	        if (logErrors) {
	          try {
	            returnedValue = next(action);
	          } catch (e) {
	            logEntry.error = errorTransformer(e);
	          }
	        } else {
	          returnedValue = next(action);
	        }
	
	        logEntry.took = timer.now() - logEntry.started;
	        logEntry.nextState = stateTransformer(getState());
	
	        printBuffer();
	
	        if (logEntry.error) throw logEntry.error;
	        return returnedValue;
	      };
	    };
	  };
	}
	
	module.exports = createLogger;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = promiseMiddleware;
	
	var _isPromise = __webpack_require__(283);
	
	var _isPromise2 = _interopRequireDefault(_isPromise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultTypes = ['PENDING', 'FULFILLED', 'REJECTED'];
	
	/**
	 * @function promiseMiddleware
	 * @description
	 * @returns {function} thunk
	 */
	function promiseMiddleware() {
	  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var promiseTypeSuffixes = config.promiseTypeSuffixes || defaultTypes;
	
	  return function (ref) {
	    var dispatch = ref.dispatch;
	
	
	    return function (next) {
	      return function (action) {
	        if (action.payload) {
	          if (!(0, _isPromise2.default)(action.payload) && !(0, _isPromise2.default)(action.payload.promise)) {
	            return next(action);
	          }
	        } else {
	          return next(action);
	        }
	
	        // Deconstruct the properties of the original action object to constants
	        var type = action.type;
	        var payload = action.payload;
	        var meta = action.meta;
	
	        // Assign values for promise type suffixes
	
	        var _promiseTypeSuffixes = _slicedToArray(promiseTypeSuffixes, 3);
	
	        var PENDING = _promiseTypeSuffixes[0];
	        var FULFILLED = _promiseTypeSuffixes[1];
	        var REJECTED = _promiseTypeSuffixes[2];
	
	        /**
	         * @function getAction
	         * @description Utility function for creating a rejected or fulfilled
	         * flux standard action object.
	         * @param {boolean} Is the action rejected?
	         * @returns {object} action
	         */
	
	        var getAction = function getAction(newPayload, isRejected) {
	          return _extends({
	            type: type + '_' + (isRejected ? REJECTED : FULFILLED)
	          }, newPayload ? {
	            payload: newPayload
	          } : {}, !!meta ? { meta: meta } : {}, isRejected ? {
	            error: true
	          } : {});
	        };
	
	        /**
	         * Assign values for promise and data variables. In the case the payload
	         * is an object with a `promise` and `data` property, the values of those
	         * properties will be used. In the case the payload is a promise, the
	         * value of the payload will be used and data will be null.
	         */
	        var promise = void 0;
	        var data = void 0;
	
	        if (!(0, _isPromise2.default)(action.payload) && _typeof(action.payload) === 'object') {
	          promise = payload.promise;
	          data = payload.data;
	        } else {
	          promise = payload;
	          data = null;
	        }
	
	        /**
	         * First, dispatch the pending action. This flux standard action object
	         * describes the pending state of a promise and will include any data
	         * (for optimistic updates) and/or meta from the original action.
	         */
	        next(_extends({
	          type: type + '_' + PENDING
	        }, !!data ? { payload: data } : {}, !!meta ? { meta: meta } : {}));
	
	        /*
	         * @function handleReject
	         * @description Dispatch the rejected action and return
	         * an error object. The error object is the original error
	         * that was thrown. The user of the library is responsible for
	         * best practices in ensure that they are throwing an Error object.
	         * @params reason The reason the promise was rejected
	         * @returns {object}
	         */
	        var handleReject = function handleReject(reason) {
	          var rejectedAction = getAction(reason, true);
	          dispatch(rejectedAction);
	          throw reason;
	        };
	
	        /*
	         * @function handleFulfill
	         * @description Dispatch the fulfilled action and
	         * return the success object. The success object should
	         * contain the value and the dispatched action.
	         * @param value The value the promise was resloved with
	         * @returns {object}
	         */
	        var handleFulfill = function handleFulfill() {
	          var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	          var resolvedAction = getAction(value, false);
	          dispatch(resolvedAction);
	
	          return { value: value, action: resolvedAction };
	        };
	
	        /**
	         * Second, dispatch a rejected or fulfilled action. This flux standard
	         * action object will describe the resolved state of the promise. In
	         * the case of a rejected promise, it will include an `error` property.
	         *
	         * In order to allow proper chaining of actions using `then`, a new
	         * promise is constructed and returned. This promise will resolve
	         * with two properties: (1) the value (if fulfilled) or reason
	         * (if rejected) and (2) the flux standard action.
	         *
	         * Rejected object:
	         * {
	         *   reason: ...
	         *   action: {
	         *     error: true,
	         *     type: 'ACTION_REJECTED',
	         *     payload: ...
	         *   }
	         * }
	         *
	         * Fulfilled object:
	         * {
	         *   value: ...
	         *   action: {
	         *     type: 'ACTION_FULFILLED',
	         *     payload: ...
	         *   }
	         * }
	         */
	        return promise.then(handleFulfill, handleReject);
	      };
	    };
	  };
	}

/***/ },
/* 283 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isPromise;
	function isPromise(value) {
	  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	    return value && typeof value.then === 'function';
	  }
	
	  return false;
	}

/***/ },
/* 284 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch;
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 286 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(128);
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 288 */
[305, 290],
/* 289 */
160,
/* 290 */
161,
/* 291 */
162,
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(293)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 293 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 294 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 295 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD//gBJRmlsZSBzb3VyY2U6IGh0dHBzOi8vY29tbW9ucy53aWtpbWVkaWEub3JnL3dpa2kvRmlsZTpMZW9uaGFyZF9FdWxlci5qcGf/4gIcSUNDX1BST0ZJTEUAAQEAAAIMbGNtcwIQAABtbnRyUkdCIFhZWiAH3AABABkAAwApADlhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApkZXNjAAAA/AAAAF5jcHJ0AAABXAAAAAt3dHB0AAABaAAAABRia3B0AAABfAAAABRyWFlaAAABkAAAABRnWFlaAAABpAAAABRiWFlaAAABuAAAABRyVFJDAAABzAAAAEBnVFJDAAABzAAAAEBiVFJDAAABzAAAAEBkZXNjAAAAAAAAAANjMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0ZXh0AAAAAEZCAABYWVogAAAAAAAA9tYAAQAAAADTLVhZWiAAAAAAAAADFgAAAzMAAAKkWFlaIAAAAAAAAG+iAAA49QAAA5BYWVogAAAAAAAAYpkAALeFAAAY2lhZWiAAAAAAAAAkoAAAD4QAALbPY3VydgAAAAAAAAAaAAAAywHJA2MFkghrC/YQPxVRGzQh8SmQMhg7kkYFUXdd7WtwegWJsZp8rGm/fdPD6TD////bAEMABgQFBgUEBgYFBgcHBggKEAoKCQkKFA4PDBAXFBgYFxQWFhodJR8aGyMcFhYgLCAjJicpKikZHy0wLSgwJSgpKP/bAEMBBwcHCggKEwoKEygaFhooKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKP/AABEIAR8A3AMBIgACEQEDEQH/xAAcAAABBQEBAQAAAAAAAAAAAAAGAQMEBQcCAAj/xABMEAABAwIEAwUFBgMGAgYLAAABAgMRAAQFEiExBkFREyJhcYEHFDKRoSNCUrHB0STh8BUWMzRi8XKCQ1Rzk8TTJURTY5Sio6Sys8P/xAAaAQACAwEBAAAAAAAAAAAAAAACAwABBAUG/8QAJREAAgICAwACAgMBAQAAAAAAAAECEQMhBBIxIkETUSMyYQVS/9oADAMBAAIRAxEAPwD54xMt+8KyNhKSSfT+t6gqidB8qk4hPbqCuWlRI1k0lBnhE6jelbWUKSttSkLGoKSQfnXJ+IUnlVlWKog6x414ATEUgEn9a90qUWdyI5E0gjnSeA5V4dDUoh0FSIrwUZJrjnFdHpUJYpJ/o15K41/SuD47xS9eYqUS2dFRI5V0FyP3FNCNNhXQgxChO4AqUSxVKMTtXio8+dcKMCSfDWlykGIg1KJsXOfCa77ZU7JH/KKbMTqT50kgQR9alFWPh5XPKRz7gpztiBGhT0qORI0FejrUpF2x4uAgQlII5gQaTMTv9ab9K9vvVUS2dlZB01r3bEpgJQB/wiuBEePWkBAEEa1KJY8q4dUCBASBHdSBXHaqjVRjkIrjQGZST0rxkkyRPOpRLZ4LIIq3wu4aRbEO2KLhWbRZzbdN6plCDy9KscPuiywUgrAzT3TpUJYuIoi4c0AGYiBUGNfWrLEJVcOGZBUdagqETI0mqRGMEajqeVIRpHWnCNpEVwRBJ50RRyQKXWa8Jiva5v51CHunKvGBppSxXPOoQ6H0pesaeNIkGYAknai7gnh+wxvEnLG9U+l8t50KQ5lA06Rrsem4q0rKbSVggd6ftLZy6eDTIlR18AOpoovuCLy1x+5slOo92aUIeOhUkiRCevLpIqXiNk3htoGLNAS1AzKmVOHqTVMtbHfZrh1g7xWi3uLZq9LTC3Wm3l5UvPCAhJ5Ab7z41q12cGxt9WF4zhSEJQhCuxWyG3GlDcp01TPzHKse4YStjGLZ8E5iohIB1M6T5Ct9YYY4gs2xdEC6a1S4PjbV1B5g1FvRJKtmZcTez3EbG0KsHbt8Qw4yUuW9s2m5bBMwSBJHkfCIoGdbwq5VdsYowLW+R3m3LIJZBV+FbR7o56pAPhW/l+8wJZbukkJnRxGqVHr4VW8UYThfFli6tPZs4q0Ps7oCQf8ASvqDV1+gU/2YJ/ZNoYh+5BPVCFR6yJ+QpVYNaJQkou7hyd/4dKSP/qGpl5hwRc3Fu+0WLu3UQ4lGwPWOhGtVRU60sN58xO0ak0NjOpNxzhe/wnDrTETD+G3SQpD6B8MyIWNcpkEbkePKqE7xsaOcBxu6tcKu8JvQH7F5Cj2Z3Rm0JHI9YPOg+9tF2xQsd9hUhDg2MHY9D4Gr9BqiLPSk9eVKBBM7UmkCoWe8q9J5hJ9K8Na9AAqEPA+A2r0iD3Y/SvaV486ohzznYVNs2nHGZZLoAJBytZhPn5RUI71NtA/2X2C8qZ10586shMvkqbfUlSYIJmDNQyNNd5qfiyi5iFytR73aK5zzqFG37UCei2tjS0iNp9KaUmBrvUsp15b02pEnyoiiKUnUikjXan1I7x+tNqTsPpFWihsfrSxrPnXhpINKdNQKhC1s2Le3tGblx4G6U5CGcukdVHkalYNjDuB48zfNJns8yVD/AEqBB+VVt4w4wkWrndUhKVKHSdf1ptjNcGUkqX8OUDUnkaNugfTb37e3xayav2FBNyWwQ4CVB1JEpkHfc66c6HLgMOH3e/AQpWqFA91XkevgaXgxGMYdh6bRosls65XGVOKRPIQpOWPGatr7D3sRDdtdLzAKKgjKkqE9MoH1Jq5OL8BgpL16JPB/B7vaKuly20swkkSopnTTlOlHdlZP4JcpLsFpyI0kjzqo4Rtscwp5ty0Wl/DWhBtL1wlUD8Dkd0+BkUfoUzjCUdk261cqk+5XKCh1UblIPdWnxSSKFRQTbHBatX7K2nUpWhSfijQeBrMuLuD+IsPbe/sBKLi3Mq7IKCVA9BOh+lGbz15YOrtmUrbQCTt3vnyqNcYveITLWd1zkpSifpzq20/Sla8Pmu4GIWWPPnF2Lhq+dBKkvpyqUdvKPKure1DCZUSp1UFSh+QrYvabapxT2cX166A7e2ZS+CRqk5gDHQQTWQ2Tj2IpQLdIVl+LXU+lJkuux0ZNnbTJK1wsjTpXT1kgsKQ4gqaWRmRMEkAwpJGyhJ12OxkU8htU5VSmI3EU64lSkE5SY01FSyNOgTxbDlWDqciw7buAlt2ImN0kclDmPXaoHL9KMbq3L1tcsrUQgtLcj/WhJKT+nlNB/IERFGnYLVCV6kI1pfLaoQ9Xo8a9HSPOk26VChJGYTr51LQW0tNlTyklQnKUExrHLyqGRrTriVKS3qdExr5moWXOKZffbgo+HtFx4iTUQCpmKkm/ulQRmcUqDy1qIBCem1AvAn6INdutLGmszXRgabTSHfxmNDVoFjbiAQIimCgyZqcEyCa5UgE7aVZRXrTBg+lcR156VOdaGWUkVFUggxr0qyDrD7z7wC1F1xWgKt/nRTw7bpbczspBWkd+4VolI6D96HsOaTnzLJyDfKdV+FHHDtgrE1p7RIRbNf8ARp+EeHidfShlOgowCHD8QLLQRb2y3mNMu4zeg1irmyvMbSD7pgjaE9Q2qT6kyav8Dw9lltMIA6neiu1ZTkA0y70l5GNjjQAnG+KWGkhViUZVaRbKUPoalW3HFwodjithbP8AeCg2p5bBkcxI0PjNaTa2SVgkDTmRXd5gVleW6kXNu06g7hYmqWSf0y3ij9lDw/i+HYx9jaKucLuUpUr3Z5wPoeEb5pJ0J5GfClesTcW7zwZ7J1twtPNZgrIrcQRukjVJ5ieYND2L8JPYA8MUwArWhk512hMnSe8gncxOh3GnSiDh7iK1xK0RcWy2A64mFoc+FY/CoaSJnxSadjydtS9E5MfXa8Kdm3S7dO2FwhJtL1otEL1EyCJ8yAPWg32j+ypVo4rFuEGy0W4Uq1aOqdN0ePhWm4jZdpnetBmbR9opB0cZ1+8N4nZWx86vEXCgArKkudedOUU9MU5NOz5rwC5t8ZUbW/aSxiaB/wAIcH4gPzFR7G1UG70Pg/w68pHWda0X2m8G2+JMOYphaE2mKW57RZa0zf6gORnfrWe4NjTN++5aYkk2+IrI7QA5UOqAidt4FZpwcHo0Rl2Q1auCyxCxvXEyi3fQ8sRMpB7w13EVZcVcE2eJqfdwdpFpiCJUG0jK1cp3Gn3FERHKm8XtFJaIQgFGsjc+IrR7uxzXTShrOVMjwSAD8hRQ3sGej5nuGHbd5xm4bW08g5VtrEKSab1B0raeJ+HLbFyG7xk+8gFLd01ooef4h4Gsq4hwV/Bn0BbiHrd4EtPI0Co0II5EdKYAmVR186TpXqTnUJYlSFSUNkpzd0RodKjnenVKUENgd2E/qahEXmMJKcRezHMSon1qFqogz50/iRPv1xm3DqwOfOo6Dl23pa8GP0cOpnoaVGneUJFJBKtdEjWnUpkQOWup2qyhAlStzAFeAIEcqeSMum5pQnKdfKrTKGCkBOxAjXwqO+kDYROgqe4k5TroaiqjtUEgQAVRyO/8quyqFYltxCG57Q8/wDr51qvBLCWsNZ0MKOonQVlOHd559xRJhO/jWvcKIWmwYQUwqAazZXs0QXxNBsFAITGw+tW9q4ATrQ62pVvbFwxCRJ9KtMJUq4OczIHIUpuxkY0Fdi7lTA5+NWKFJjSIO/8AtVNh6oG+u+lTwoxmM6cwKODpEasS7SDJjf8AOsS4/tHeH8W/tO1bzYdcr/iGRpCz94H7qj16itnunITzgb0G8Z2ScQwe5t1AnOn69aKStWVGST34DvDHGDal2lriL5XaOqHul8QAptfJK/Hl40d3GO2dreoZvotHFrJBWYaVHNC9teh1FfN9k+qxcubK5BVbuHK4k7JI2WPEaelaTZ4/aYlwm/hOKLSMRaa7FIV/0mkJWPTf+dOxZbWxGfD0lrwLMQxNhbzL1u626260tJyKBhWckpMc4I+dYj7SMHQm/FzbIABEkDp/KtBxxFpw1jobdSGcPLTSHHEphLTiUxmUByOqSfKqXi5jt7Bt5hYcbKwpKxBCkK5yOWm9HLb2KjrwAcK4iuLQBm/zXNsNAon7RHhPP1owwvjxFkhttb676zSpOVJhLrYB11PxCOVCd7hakP8AwfFooRp51UPWoztAJEqJSR4il+PQz1G3P4xYYkyXcJu7d5LwhIW4EEEn7yTqPKs79qbdvbYdhdq0sKW0tXe2KhGp+etBCrfM4EpbSpeYAQNZnSp/GWIKv8belwOJZJbCk/CSNyPAnWmp2LaooNvSvHbnXjqDFcneKso9+tduBRS3AEBOkjxNcASa7IVCe8Bp18aotFtiah79cEc3FGPWmECSSdzUnGAkYhcIbH2aXVhPiMx1qK2DOw3pa8GP0eJlOUaCdutOtJ5keMVwkZiCmn20p3Gw1moSh1KFKpfvQPnvTrcdmepOtKkATABMbTFSyUR3dQdCDFQLolrPB17oHPlP51buCW1Ex3Yiql8BT6iqJBzADarRVEvArZxbS16JTm3NaNhOO21upprtG5AA0I15/wBCs2wpL90hLdv3lZiDOgA6k6aCrYNYK4gsoxK4dugJVktzk+f61myK3Zrx11SbNgXi7d7Z3bdvCnAyogJ61MssaOHoC1NqUk6wBJ26UD+x1t24xd/OFOW6Cn7QjRJ10NGXH7pwhhLjTIKX15QRpBNJ8tsc4+RX2WFt7QbVtxLauxnmFKMz+9FOD8UWWJHs2yhDg+7NYdhnETGGXSO0QHXFrVlAtAW1EBJOZcyBCk/MVqFve2d64q0ubJWG4q2nMWFbLH4m1cx4HUVa71bQLULqLsLrlZUkyB4+NVd4JYVGsg+lP4Y8XWCh3dOhUeY/emrxCglRUEgHlTYyYmcTAuM7L3bGniB3FqzD9aZsXkX1r7k6P4u371s7zIGuX0jaiv2gWpdfQ4BrJEgUBNjsVBwkoU33pnUGgT6jev5FQZ8UYuMX4ZW+sD31Y93WjmXCRt4HehIvYngr93b2SwqwbQFKZeTmQSIzKA3SSelT27pbajeNtIdbcyl1B3bWNlAdNTr41Cx7EUO4NeOJ1dKckzrvv+Va4y7GOUXDRKsuJcKxFpK8R/glBWuYykgD7pAmfCPKapMQu8GTdFdndqWhJKkD3dY1jxA60PJaUqyKxOyVD9ahiNvGmOKFKTLpvE2bW7ZuWCpx1p0OoGSEgjaSdd/CqQSEAEkwIml32r3jVlHO0bUn1rqkNQgg3HOlWBlR3o06xzNINCKUwQnTl+tUWi6xMJ97eI1lZ1mdef51HG58DFPYkom9uBmlPaKjymmAZ01jfzpS8GP0lNIOUzrMbbU+UlRAiddddqjocOdCQDE/pVg3okZZM/SqYSFbQSIkmehkV3klRCSZ2MGu0iAIAgbk0+0gZTBmPGKllUKGAGSNSAI1NUeJtdm4FiIIiiLs+4AmYiOVM39h7zYuJZSStBzjlPWopUVRV4Fhrt/ZOsMAqW4fhmAROs0cXdracP4EUs2do1cKASAkArcV4nz8aE+H7x3DlDs4CiClU7jWi3hW1Xj2OB24hxLEZUdVcvlWXLOSk0dLBiUkn+jSvZrgreEYGlJAU6vvLVzUo6k/kKvuLLNu+4edZKG1OEhTalCcqhsak29oqytm2ySpRSCQDVbi98QUtLSUiY150O16XXaWgLwlhy1cy3+GZ0BYVKWO1QsiIJ0k7DfoOlGT9tb42pLl0h4vznQ6QWlJP+mQK7wdtxt3OTmbmQDRKlxOUc0mijdVYE4pStIq7DDvdlGXnHDrAUYj6V7ElJDZAMCNdd6mXTqW0hWm+1D+JXoIygmavYukCXErSH0HSfOs0xy1Nu4ptYISpUiOek1qV4mULcO3IUL8Qpt75xJt0FfuCCHCNO8qOfzpc5UOwR3YIou0Nt9qwuSAZBGniD4VV4qW3sKW5bJWhD4zKQTOTXYHnqPrUjFlBhp05QlTiogGd9AKg4hlZw9tCp0RA8SYrVxU27Zn5zUdI4w1sXGBJBI+yeyZfBQ3+aRVApBQ4tB3SopielEeAoUMCvnR8PaIAEc5mZ9DVVj6Et43epT8PaZhHikGtjWrOcnuiCZpNtJpRqDNdfnQhDe21J9K7Ox1rg86hD1eUYiBPrXgOZrsmANxPQ1TCj6Wl+hIedjko/nTKB3Z2FScSMXTqRsFH86io1UOlLXgb9Hmwcw11JjSra0IIAnlINVYOoMd4HmKl2rpCxrEbeNCy0XDaIPd2HKNTr+dPoQgJ7/dPWKjIJc6QRU5hBQfh030H5UDCH0MpITk15CRBHrU9i3iFDWQe6f3pm3aWVqymAdZ35VYMNyYIgidqCTIgV4nsxZ3SHWRCHQdvxDemsFxR/DSt63e7NxShGu+1XvE9uFYStyO+0vNMcjuKE7NnNdNqKO4FAnloKCuy2bcU3GOjasP4kxzE7ft8It1uBMSl1JST4anX0qytU4zjy30X9mLVCGjkcPdlfIfMVA4fxMWdw5mOVtzKZHLSiZfEFsvudpHmTr50Kha2y5ZVFuonPCuJC7tuyfARds/ZuoO4INXa3Uo0OnhQVeO2zlwu+snA3fNDMoJgdqkciPyNWr992zTawScwkHmakLWiSlGXyRNv3zk7uo39aoFBTip1y1ZrUVNGdo2jeoRIzkiB4UzqKcv0Vl8UhshRypkJBOmpIH61Q8aXFrheGOgxCgEpQBoVRuepqXxSl19pq1tye0cVI9Nf0rJuJ72/u8SLN46VFgxlJ0B60HTvOvoNTUMd/ZGdfLriXrkDMTDbYP1qHiDy3Myl6ZRt5000FG9RJkzGgqWu3D64eWOzBgNtCYHj0roY4pKkczJJydsMuF8JT/ddAdn7R0qKeoAAH5qP+1AOOBScZvErVnKHMsjmBoPpFaxhF/ZKwot29yw0qClKbhQRk0g8zPmPlWU4xlVilwpCgpBWSkjmKfPSpCIXbshJ03r3I710IA6TXPX9qSxxz9a5MTvXXLxpOR6dKogh12NdkwAI5dabA1p4nQZYGlRh49ssr5xK7q4WkCFOKIjpOlM6ATFO3JIfdBGylbedMgkHWSQdaWE/R9s5R4neKfQNgRz0qM2oEpJk+HrUlG+mvXxoS0XdpEIJiRpA51asGFJ1Gg0HhNU2HwjKNfIb1bspJAJHlI29KXIMtWwkAEpTJ+VTmyBEfEBrHOq9qQmMkkRA/OpWUpI0O3L60pkR3coRcMKacACHUlEHx50DtPOWS4WVJWycqhA/WjgqyoTMGOX70P8Q2gD6Lop7phDgA36H9KiY3HKg34cxHB3bO0Dy3h2qQC4sHRR5Eg0TpwvDFN5cyC2diJn5zWY4Fh1wlhy3ZCXWFK0CiQUnzg0dWNpcssgPrQSP9czQJWzTKetIn3WAYai3cesm+zuEo7qgo6+B1qMhZSLZH4RmIp7tiEFPXeTtUVbjbbhJVBI+VPjGjJObZYC4JWrTSmH3kplQIA11qCbmdEa84mu2rNy7+NRS3MGPvUTVAd9jdmlT77t4RCUjI2SN+prGeK0k47drSQFBUGDFbtiADNiG2hlAEJHSsY4isUXTWIXjCgHWVLUtP4kA7joRQw1IKTuLBaxSFXic3NJ/KiPDGEqJQyznCe8oDmNvTp60LpdLLgUnVQmJ/rWpKMVvW7Z9pp4tofTkXlEHLzA6T/Kt0WkYpJvwPbbD7d9bZdtjasLc7NLnbJAJ8zy32rPsaUheK3hZQENh0pQga5QNBTDjzrjaGnXlrbRqhK1FQT5A7U3yNXKSZUYteiQZPWuREbb146ct68JkUAaEiua7VsK4PnVEFSASPGpnYLQlPaIykie9z1IqGDBqaJcbRnyHKIBKQTEk7+tDLwbhSctki/J98uSZntVH/5jTCNxpXb5l1cfjPOa4TEEn0oSP0VJhUEyKkNuZYCfiO5qNOWP0roL1ERUZEXlmtOYSqInlV5ZnP3k8jvzoasHRAgE0SWK/hJI0/qKXINMuGtW9BvyNSEK7onUjSabZnKBImJk0+lYHxHSSOu1JaLR0kAiTpNQcSQ0LV9T4PZBBCtQPWakrcSfhAkjnpQhxtiAathatrClFWZUK+HwosePvKipz6qx/hziRWGJUhaVOMkyCmO6eYNHVpxPZPW6V9uSSNU8xWIYfdlu5RmXlBMZo09R0okQ72KwlyzbW4oZkqbXAcHhTZY+vhFPvs0v+32niQwuToCZinrcm5IUdfHlQXgWL2huOzuLMMcpVrr+VaNYMIfYQu2UgojQT/WlB2oJwbOrViSCvbpP51ZWgzOQPhTyNMMskaKkD5VOQUMNKW4cqUiTOwqrtWD1rRXcROhjD3lqVBCTr0FAWEYQp/B8XddQT2jSrdsHcqWZjz0+dEuMm4xe7t0pQUW6lFSERquPvKPIDlVy7apRg+D21ugJQp0uKKdc0EiR1G2vPWixRt2y8suqpHzbctLt7l1hwfaNLLavNJIP1FNE+Zop9pjLDPHOKotikJKkKVH4ygFX1/OhVWpImtVGUWf30r207Ug3Mg0pgT4VZBtWnKvcxXR22pCPCqLEMczrXJ3EfWuiD/tSKA+tQhz96rS3SOyTMbDfyFVcCfWrW1AU0Mo0ASPXKKCfg7B/YbcEOqBnQnWudNPPanLkZXXAdDmNMqOojnQgvTFJnf5RSJNLEjSkHj661ZCxw5whwT8JERFE+GrJSNYOvLnQjanKoHTTxq+s7tFu0pbkIT1Vz8ooJJsJOlsK2lhLaEhUzyG5qpxPHbWzKg88nP8AgTqr16etDGMY/dOoLdoSyyo6r1zK/ah0IkyZJJ1J50ccFP5C3ltfEIsT4ruHwUWqOyT+I7mqC5uHLhWd1RKjz1/WptpZs3QlBKSN0zqKddwghJLZJjlW6HGm43FaMcuRBSqT2VEKA1EpNX+DYqGG02t+gPWqxIzA909QRqCOo8jIqmcZU3IAkcwa80+UIKdYA7p6TSnBL4yGqbe4mo4Ta4LcBCH7+4sUqHcdeQm5YV/zoylI9DRThmGP4ZcusW7rbxbIM27mZCgRIUAddQRWM4C9fMOXBsSh9tppTz7CjugfEoDqNzFa/wAK4taYrgzYw11an2m0ouGlCFNHUDzBAGorLlw2rRqx5q1IKO3V2YW5KY/EIqLZuKxzE0spze6BeRKYguqHITUiztUBsuIzBfNJ1B8D1GtU1vgH9rPLbQp1Vu0vIhuNUA8yOpI39BSvxu0voNZF1b+w/suEXb1x26x+1ctMKYjKyoZVPJBnvH8JOyR6k7U7ieFvYg6lSnBbspSQpLaR3EbkA8gBGscpoDbwjiXgzCr/ABrD783Ng0A69hrhzsOIBg7apUJB01qKv2qYjxJwji+Ht4BZWAeaTbO4g1eK7gcMEZVDfLm2Om9aopGaX+GSYjdoxvGbt5QPZ3j63UDYgfdI/wCUCqy6w11tcN/aoG3WpyLIqVntZQptSnEIWCFBKQCDHiJohSw3d2TN/agdmtOYiPhUNx8624McMkXGXpi5GWWKSlHxgAQR1NeOlW2JWzTd262RlIUYI86rHW1IVyUORG1ZpRcXRqjNSG9Ry3rw616IIr0adKWxghEdKTWulCBXJHIc6oghneNatcOGZgmOcfQVVxrJq4wlJVbE6/F+goMjpDsCuYzdKzPuqO6lqOvnUc+EVKvhlunkbZVlPyMb1H251EC/TkzypxKSdBqa4nJGaddhzNSGGVvKlYyoJ0QP1p2HBLK6iJy5o41sbXcJtyEpAW7H/KP3pGX1FxK7klwTqelW/uAukhoIOcfCpI1quvbJ61uOzd0VGh5EeFa3xngfb0yLkRzfEtG7ZDwTIC0ESOkVVYlhjtopKkgqZV8JPKpeC3fu9wlDqyGF6K5weRowThovc7T0hlScsj6EVqfTkQ/TRjc58bJ+0zOWs7K0uJMFOxq/w14XSApIGdJgoA50uJ4I/ZXHZOglCvgcGyhTdgy5h912qQTB7ySY0rPx5yxS6vw054xyw7L0l4rhYuEFxKClW2br50MXNmttZnf6VqV4w2wxZvEhTVwFNuEHTN90/nVBjGFSsqROQzEj6Vpy445FZlw55Y3TA/DbhdtftPtKUlaFScu8EQfpNab7HWVN4bi9+ENqaQ60y6VIzBKYJB8BPOs2v7BxpSVJA8I61Z8JcYYtww68rD3EKYf0uLd1AUl3lrzmJFc2cXFOLOnCSnUkfRqbZsW4ubdakI2cQozB5KB3irPhyzYaxJbhSv3ZKEpceQCQFAgzMRA/Shr2TY2xj9s6lQILaApxOhBbJykjpvEHY69KOLqzfsHs7Dqu0bGdpY0DzZ2B5TyI2keNJS1Y2yr9pTjWH8N4+7aOlPb2imnG0mYWSEhQ/wBKpOvnNYDYP2n92MUwxzuLSQ8lThhBWkgBI8SJ+VbdxwwMd4fvG7Aht4MocShRASpXaAlI9EmPHSvm/GG5vn1wUhayqPM0V/aIkXN+05eMoubd9UrbSl/syTO8lQMT5An6VZ8Gpb9zdt4UGs6+7+D7w8+vnVVwdeDtV2Czo6mUAJG4mBPqa9e5sMv1KTCQpKkE+Y0Pzj51uwKPTuvTncmUnP8AGykXmurpTyt1qJImY12qyw7DBc2DmZKc5Woa7wOdc2tuIbWEkhaZT4ijCwtA1htuUJS4lSQQodZqsFNtsPktxikjNMSw9y0cgiRyqu8qM+LkhN1bjQ9yY86oPchcIzJIScszO5mKRkxXNxgPxZvgpTKs6g0v9RTj7DjBIcTHiKapDi4umaE01aFjUbVZ4WSLdXe+918BVWatMLUE2xkT3jSsng/A6mLiQCby4GsB1Y+RqCpxQUEJGZXIVIxJX8U+pQj7RRIjbU0mFWqnl5zpO55AU7DieR0jPmyKCbY5aW5zJKxmWo6k0QYfZJdMQZjQRufOobjGRKciSMup5VLwl/tnw2AQtIzayJjp+1drHBY11Rxss3P5BLYWCWmwlKQSRzpMUwxu9sVsqCQs6oWTsoDT9BSWN8ElKbpMSYCgNPXpVxmSpvMAIVqPEUud/YmLraMretXLd1TTyMriDCk7waLuDMQU6wqydMraGZknmjmPQx6Hwp3ibDc4F2kJkDKqEa+BNUmFOItLllZy90zrpFY1/HPR0pVnx/6G71qL1xFurbKVgcpoWxpnslyEkKO8/lRhawsB5vVLiYBHIc/2qs4ls0uN9uYShcAqjRKuRJ5A+POtGRJ7Rk48nF9WRbF4X/Cdxbk/bWDgUDG6DGvympjTaLmxS7rnnIvzgR9KHsDdLN283plcSUOJ/Eg7j0q2wW493vHLJ4kIWrIfA8j9RrTMMu8K+0ByMfSdrxkW8w1GpUtKEkwCoUIY7hyGFBy3WCSdcogelae7b5YS4AJOmk1BvMOaumFNuJEHw21ockVONMrDmeOVgz7K+L/7ocUMXb4V7ms9ncJGgyq0VPURB80pNfV1u8m+tOxZSzda9sxKilKkkahKuUiCK+MscwtVldrQpMJ+laz7HOL8SawVViq4aW5hxCWe2Rmlog5QIIMJ730rmtOLpnZi1NWjQuJ2mP7Iu8Rwpq5JtPtL2zBBcCB95I2MHfpqeVfOt8C7cPLCQlLi1LCQcwTOv619I2uNuXWKm7caRb3buuZoQ24qIIyknUjxg61kvtS4btcHvkX+EpLVhfOHPbBPdtnYmAfwK1IG4gjoaFU/A9oz+yUpi+ZeSpWZpYXpoSOevlRhxhZhzC3LloR3A4nxHT5U5wGpkquWH7NFwjsy4pSgNAPHx5eNXWOAOWd0FwApKzA2QIMJHlpWrj/a+jFy6uL+wI4TUm9suzJhTSiUxrE/0K0A2qUNpbCUwlIAIFZjwM4prGC1AyKAWRMbf1tWsYkU2yVrROUozo9R+9Fh8sDlO5KKM641ZKr5K0kqSEBJMTBH+9MYLZ5rIkiVZ4mDrA1H5V1j1yQ8+lJC0kxPhG/nV/gTTTGC2xJzLWkuQNdT/QosD/k7Fch9cSiD11Zjs1FeqdiCNTQ3iFgpgdo2FdkTBnlWlu2LLpU2VPSNyGZHzNV68Kw4pW2L6QrulC0RBO3KtebFDLGn6ZOPyJY2ZqOkSKtcOVlt+smajYpZOWN042pJSEKKTzg1MwzsPdE5s4XJzdJnSPSK4OdOCpno+M1N2iFeib51pREIWrMZ0MHrV3g6W1pV2akrWkSUjU+GlU+IJCb+8yxl7dyCDOmY7VOwNSm2ZQQFKVr+la8GR43oxZsf5Fss3Crcp1nbnUG57W1uUutHIsQsRyq6BPvDQM5p72k/1tTWMWwLSCAn8JUNvXpXQWdTX+mB4XB/tFnZKbxG1S60CFH4kjkafwi+csrpVlc/aMTOcAnJ4+VC3DV05b4syylUNvryEHaeVXeP4u9b2yV2RLSApCkL2U4Sr4j4ROnzo7Uo7ESxtTpBsplDiDspCug3BoFx3ClWl6lAns1TCzpI/wBt6NcFuEP29s7GVq4RIg6IUNCP661IxS0Lts43lSpQEon8Q2/b1rLkhemOw5HB2U/DbqWQhhRHZqMTOk1fXNm09buMvoBac7qh4dKDLS4RqVZ0kz3QJP8AvpRlg9+m/tocTDqUg+Y6x+dSEvoPLDfZGb3Fm9hOKXFosqKmSSlUfGjkfUfrUe7vQxi4KdM6QtJnnWh8T4UL62N2wkG6tUSk/iTrKf2rKMWSoLS4nZGg5R0/OgU3gla8GpLPCn6avbOG+srYs99x4ADWpHu7DGjqu1J5JECqD2dXqb1q3amFAqSQDsSCB+tF9qGjZE3IMM6mDv4GtUnb0c9Rr0C+NLBu4sXHFNdmpKM7Z6ihTgO49y4ih1wo+yXMHRUCQPWtAxci/tH3nUkrnbwjb0rN+HrN+54qtLZpBWQ7KsxgJSJKiTyAGs1j5MfGdHhztNGvG6NliVtbNvHI64iddRKhqDykfQ0AcS8X3eN2KbFxplm3bd7RWU51uKEgSogQACdB1qTxriyUFhOGXUoWlWdaU/Ekd0BK9wmB0E77UI2rbSn0G67VNuoFIU2PvQcoB8SKyxRtbNQ4YtOxwtguIACkBcqSErSoichjcDed6a4jlvB7xajm7smT/qSKs8JaWzZWzbqgXA2hCinqBr9arON0qbwZxpMHO4lJnzn8wK3V0VHLcvyTtmZ4aosYwy6k7KMxWo3V8g4FbqnNlOQ+Kd6zK0R/6QT+/OiG0xIrCcPuFHJlgSrfmD9KGOoOhs1eVFbesly8U2kFSSoJAFH4sDZhlgiEoQEgctqpOGWA5i9otKQFodzKHIZdT+XyNG+Itdrbj8STAIq8Px2ByvkkihutAhcAEkIV4zsfnQbiq13NxdoQoEJVlGuhg/yonxd0M4c+uZKFJ5+IoVwIe95ys91x1Wk6gVvTrZhS9Y7xFaJeShSkCFtJJkc8tDNu12KVJWD8WmnKtJxG1bcbZKlBCAgSpWgAGlZ9fLl1JKwNDoBoNTXL5sVKKa9Ov/zcjjKn4V+Iwq5fUgQhTiikAzpmqxw09nagiAc29Qb5v7ZRgDvqETsQdvrU20TDLcgg5+W8f70tLY1vRb2yipaXFlIRJHjG/wCtW2MsgYOUElSgAVa/eIkioLjENNo57qnlU26dW9gpWsd515awByASE0zwX9gEpwtXE5iFBQUlXlVzxrcOKfYKNLe4V7xl5Bf3o8zr51SYggh3MQRyjpT9y4p/BGWiVKSx8IOuXWdKtZX1cWU8S7KSDDgfFG8irC6V9g6qUn/2a+o/WtFtVKebLTuj7OivEciOorBsMuVMPIWOZmtgwS+OI4Uy/br/AI+0QMw5rR18enrWmMlOPYxZYfjl/hEx/CAi798b0aWfthlnvHZVN2/aWq0KbnumQdxRH7w3c2+ZAiUwptQnzHiKpHW+wdLZnsjqg9PMeGopbVbQyE+2gmtrtC2UPIMpUJI6HmDQBxxg6Wgt5hIDKpIA+54GiLD7gW9wUlwFhW8cj1qwxS2RdWbjQPdWkiSNNqJrtEFS/HKzJ+CcROH4vBVA3j1H9fOtXxaTbrLa0Nt3JCk5jAB5pPrWJPJew/EEryZXWXNUnqDqD9a1+yfbxPhd9TJUttbSVo8CDr6jWpgnca/ROTCpdl4xvDibW8S1ctFKXBBHIjwPOs+uLd1nik2yCovOOOWyddVHMU61aW2Mv2Geyuyp63Cu6Se+34pJqZw2yMT42tb7tRcC0Su5cVlyqnSMw6yR9avlY/jZOG6lRScVutrxZxi3JLNskMAnnl0J+c1O4FsDe3CnnsxtrdYeKCBlUvUIBnfadPKq/H7XLi983bqBSHCO6NASdo89POtFwfDP7JwS3tlQXh/iEnZW5SPAbCsmKNys2cmfWNL7LKyBceiTqao+PXExboVJK3FRB2iP3ohwwfxEcusUHe0Qku2xBIhKjHr/ACrRkdGPCrkiiwuzSq+SVRCc0A9SDUHiNlyxvLR9PwHuj0q/4bLl2W0qEqQSoq6wDp/XWo/GtulVhaEJAHaKTMzy/rShv4MY3WZFnwU+2rEX1z31NBSR8gZ8dqMn3O4csEHWZrNPZ8/lu1BwwpKYM7FM6n61oTyiG9dCPrR49qxebUqA/jJ0Iwx7X41J+WtUvCEdm2SPhzGp3tA0w466Aiq/hf7C0ZXupwHKk7HU6n9udO7paYqMG4a/YU4q6g4UlMkLCko30JJBjxoAxAQ+AkQAPw76nWjd1pb1o83qtSFB1URMwdfQxQjxIEtXVtkTlzMJUddzJk1h5FyVnR4qUJUPKt0++AFCD3jGkgE8/pVqxhrL97bMqSEgOJKgnnFQbYFV83mO6pB2miDDUk4onUd0bDxrpOEetUct5JKVpjeJ2imGHigFzMnNIHTlpSKb7PBGkrGVXZjfqdTVrfKLairROm4H9eFd4gznYQ2UkpShMED4TH1FZZYdXE0Q5O6kZXiGYoWVDKdJJB3rmwT2thcpGpAzDTUURcR2o9ycOXvAToIO/OqnhZoP3btsVDM/buJT/wAWWRWVpqWzemnG0ULJhBHQzRjwnjDmHPtuIUO6oDXbyP8AXOg8gouFpOnhVnhS4umxoQVCadx506YjkQ7RNkuGbW9cS5avC0AmR2ZkGes1Ev8AAfebZTRvWlaggzOo6iq+3chAUCryqe2/l5gHr/Ktco6o5kZpO16CrVsmyuJN8ylwax2Z/ejnA1ou7FQMZmxMclDlQriiks4okOhKmXpXO0T+f86IcEdRauNSElhzuKIPyIrPF9ZUbp/yQUgK9oGEFu4VetI7q9VgclDc+og+dd+zfGBa3vuFyR7s+SO8dEk6H5/nR/jdlbPsEFBKFiCk6isgQ0vC8UW2sTkWUkbmOR/WhmnB9kTE1kj0l6i14vtFYfiD7KyV5TKVEbpOoot9kVmtvB8RvVIhFw6lIUTEZQev/EPlQzxa6cQwuzfBzuKGQQDO/wAP6+sUarWxh+GYRw0wsf2jkSHgP+iKgFLWY3I1gcjqdqHPNzSQ3BDom2UeA4QcQ4qusRebHuTL6ltSmM69vUDfzijJ/Vpsnms789BrUi1bbQAltOVpIAQIA9fPnTN2gBLKZESpUeo/ajhDqjPlyd3Z3hY+3E7x8qDeP09+0WP9QHzP6UZ4eAHzB1ykeRihPjXI46wydSlB585NSfheD+yGODxFuiQNApJPyineOWFLwxpSJKA6FAekV7gwDKQVEjLqCdTqKtOIGQqwCAqc6u7I2MfKov6hS1ksBOBwo42tlQErZcSNNiBI+orQisuWqV65jBjx50DcLoDHGNulW6wsCeXdNGzCpZcRtB5+NFg8A5K+QGcfKAw8A6zA08DVPw67msAFSrL3QIk77DrvtU/2hqi1amJKoEc9/wBqreFlONsrcRulakjrBoMj/kG8eP8AEGWBqVcNXJUkJUWVJIB18jPPShbisL99to293T96dJVFEnD2RhZU4oALHe5J30j+dQOM7VCcTZAQSOwEH/mV40jM/gaMKuZBsJVeCYlKjlAMgcv0okw1sJeQ+NAYnxocw5OS9DZ3EgnSjLDEZmYIrq38Ucea+Z1etpWlZmIUnXxiu79SoSUiY1NedIU2sKEqKkjXnpTqwlSCIGmmu8UsjKK7baugsBAUuNUmCoeMc6oMItENcQIdQ3lKVKWkbCYNEV5ahas7UJdTqlUx9aZwy0cuMVNxcZGwEwqFDvK8B40XWLVlxnJaRnnFduLXG3uz/wANffTrOh5UzhbmW4ZVmOihMb1ce0FrJetrKYIJSaorAA3DY6kVhlHplpHThLviTZqFoodglJTvsnc0+lzI5ME+Yqtt3Ww2EkyqNOddrvLNEjO4tXWNK3034cmtj+JBN4wkLTJSDlIOyv6FQrF9VuSwhJuOzVq2hxJKetKrELVQIQ64CZExtVNiCM9yh9pSQVkhRSSkyBueWtZ82N+pGzjyX9ZM0SyxNF1a/aB1tYGX7ROX86FuJsOYdUHs0lRAChyPj1qrtcevLJ1ITed5BgpdUFA9QecVeYhxRZ+6NqFtbXDznxf+6nnA0OvhVQl2VMk8bjJSiD6FusotmrcK99QSGkpBUQskd4Ab9R4nwoh4NtG7fG7tt9ShfM2+YocMLUVHvq8eh561S4apVviWH4mtRSW3HEoB0CVZDl18daawVbrvFlo6hwlbTilLWDACeZnXQztFZo/2pG2a+DNZYZcyEuJyhWmtR71wdqAggJGk023ftqQCtxtKtgAvtFfQaV20024orCXnFHbNoK1HPe/By17riNIBk9TNBXH1yBjncIUUphUeGlGpSUOha4CU6mPpQNxVam4v3nGUFRzEwVRIOulKmPw6eyw4RQn3dxRMECYjmf8AarTHz/AZUqGYKO520qFwy2E2i82kZUnw0+dSsfP8MgKjLrJPMCiX9QZf3AzAnM3F9kcxUQV6+IQT+lGlwsM3Csx0WNAPy+dAfCsJ40s5lQUtadNtUECj3FoQptwwoiPzq8TpFchbM/8AaG4FJt0yIK80ehqv4ZKuzcAVrGbLmp72gOhy8Z2CgFHTzIrngxaA9cFxKIDcCfiJP4Y223pcl2y0OxvpgsK8JaAHbvwWkEECfiV0iqzi26LmIMqKDPYj/wDJVWlhcl5a23coVmkRHyFVXFDKFXluomJZGg/4lUfJxrHj2L42Z5M1jFpc2/v5haCULVlKU5Ry/nRjhau+MpSURy1ipb3sd4yTfLfteFL5KY0Qu6so8v8AH89fpXmfZb7SWXitrhm6RrIi9tP/ADqkc6rZJ8WTdo5WhCnAI5kkc5ppQkQVaQDvV+xwF7QlNZbvhK7zxGdu+s9fm9T6OAuOQSf7oXwE/wDXLI6f9/R/lg16KfGyJ+AkoCSkhXPnUDL2FwFHVB0nejl32dcauKzHhPEAZn/NWR//AL1Ge9mvHThg8J3qgNibqzB//eaKOaH7BfGy/oy72koz29u+AMqiNusUGW5ylB/kK3TiX2Uce4thjNu3wpdIcQvPK7uzgaf9vQsx7CfaUgjNwwvQ/wDXrX/zazZZpzTTN3HxyjjqSKG2uA+lpAMJEZxpmUfAdKIWLVAALVnn01U64B9BVra+xTjzMnt+G7oRuRc2Z+nb0Q2nsu4ytkZf7sYko9feLP8AL3mtaz469Mk+Nku0gPDdzkCQxbISOSD/ACpt9KVsltxgEaiUn9q0BHs740iF8LYgD1D1kf8AxNIr2Z8XlKo4cxIK5HtLL0/9Zqnnh+wVxsv/AJMevDZNAJuUtOKQO8HAQQPDwqOteFFKRaNfaiVnSEmBtrrzrT8U9jXGV+tlw8NPodHxr7a0zRH/AG5Gh8OdVln7EuPLd1+eHbtSChKUEXFpJMyT/mNPrNZcmRXo3Y8cq+SBnBpu7llhCszUjMCkEKAgkQd9h8qNbHB8N7btmLdtDu4KRoeexqbw77J+MsNvVOv8L37iA2UIi4spkkSf8fwq+RwLxi0slvhTESkmQPeLIR/9xQwlFbYOaE5PSK3MG09xDUxrLYH5Uy5euAEEwkbhCYmiJfBPFi0HNwpieYiP8zZ/M/xFR18BcVqMf3SxLzN3ZfP/AB6d3h+xDxZP0U6VpWgpSFEnmTJoKx18OYm6pAzBKsoHSOlac1wJxc2ARwriWbf/ADNmP/EVRO+yvjN45l8NYmFHU5biy356+8UDnH6YzHjmnbRTcNL7K0cL6ZSFjLGhAMx61zxHctt26EEx2qiAlXQDrRhh3s44ttrAtK4bxNbh1lT9nqf/AIg1Axv2aca4gltCOFsQSlAOpuLKJ8veP1qlkVUX+KTlbRlGEoLHF+Hd5OYXCYE6QT/Oj3F3gEJKSRG2mnzriy9j/HzOL2905w1dlppeePeLMkRsP8cdKJLv2d8avN5RwriU66+9WQ35f5ipHJFEy4py+jC+MF9ribahJ+yEGI6zXeAkW5BA1O5o9xj2Je0G5um3LXhm5KQmCHLy0TrJ6PHlTlh7GfaGygJf4VfMa9y+tNfD/GpmLJCM3JkyYpvEopFPZgFzNn0A0g1D4odcF1a6a+7icwg/EqtFtfZZxoSRccLYgAoaKF3ZnKf+/qBxB7IeOry6ZNpwveFttrJK7u0TJzKOn256iq5eWGSFLYviYMmOfZqj/9k="

/***/ },
/* 296 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEB9AH0AAD//gBCRmlsZSBzb3VyY2U6IGh0dHA6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvd2lraS9GaWxlOkxlbWFpdHJlLmpwZ//bAEMABgQFBgUEBgYFBgcHBggKEAoKCQkKFA4PDBAXFBgYFxQWFhodJR8aGyMcFhYgLCAjJicpKikZHy0wLSgwJSgpKP/bAEMBBwcHCggKEwoKEygaFhooKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKP/AABEIAUIA3AMBEQACEQEDEQH/xAAdAAABBAMBAQAAAAAAAAAAAAADAQIEBQAGBwgJ/8QAQxAAAQMDAwEFBQUHAQcEAwAAAQIDEQAEIQUSMUEGEyJRYQcycYGRFCOhscEIFTNCYtHwJBZSU3KC4fE0VaKyY8LS/8QAFwEBAQEBAAAAAAAAAAAAAAAAAAECA//EACQRAQEBAAICAwEBAAIDAAAAAAABESExQVECEmGBcVKRodHw/9oADAMBAAIRAxEAPwDTtVuU968gPKML4CDMVlryo7i6hwbbnIEE7FVRDVdrKTDqCEjryRPTFGdR/tKy4oAtLCsAzHWaLacbu4KOQpRM7QvNVCfbXIWFIXP9VTAZjUG9kONHbJkAZmgY5eMuEAkp3GCZV4aAaXbdKirvFTkYOKoIktlRBdWDEc0BmmkjIeISoc7Z/D/Oaiq27ZBSACVEcykyKqEQ2EBJbUExlRg8E0C9zuUSXEggSIJJ+NBILK0qA3iAmRBiPnQGUwvuJKsKmAIz1qCMlKklMugemM1RguSC2EvJVuxt3CRmIqBXtTKk7AoJUMyAJx6igA09cSFqeUBHAUOKoMly5dUPvVGOSCTnyoCFy7yJVAPWovgxKro4UVAmBlVEE+03aEthSlQRgZFFnsJy5uVgwpYH+9JomGJvLvbAJAGeoH1qh7V9coWohxQkc7iYoaKnU7lII+0uDP8AxVCovLYtW0u9Fy4pTB2lUbhIqKpXdPukJ+8ZdSPnn1qpkVr9s+yo4dTA4M1TEJwLTCRuAnIUKIGHVheNiiAZwKBwuHAkQkgx0maBzl06kAgHpkRk0GJuiEBRSDPmkGgQ3SYKlBElWRGKBVXbQWCA34QODNA8XaFpnII+f0oH94Opcg+Zx8qBUuwSA4oGOCPzoDtLAUob9oV/MAaA63y2Y34jPJiKL4QLvVlNtAJUMYwTQ1TuXlw8kqSTExJMUQNCHXDA3E/gR6UExjRr19PhtnV7iAAkHPpQY5YuMrKXbd5CgYIUkiIoJltYuNDvrNTpE8AAx8RNBZadqCXHQ1dqS0YgqKYCj5EdDUWJ6EJ7vb4J5OTRcMeCUbJ2FUHgmeeaHTCC4nZtST/KZETNDTF2rK1EEGZBKQsDjpHxolxi0NtNKAAO6ev+TRRNiE4++Hyigm6hqq03S/eSiSJBP0oK13W3xhbj4jghXxpiajXOsPONJSp1zOZUZ68R5VTUReolafF7xOQpAIihaY3doVPgag8wmiCpuLciF2yFq4EEic0GOqsVIO62eSRJO1QwfrQR1s2SgmFvT/NuH5UCptLRSVS8f6QOfKgjG1hSS2vcY/wUBEWayklRBIxJoMDKyI8EJMZBHXPxzQFTbKUVEqSTt6KA4oCN2joWFogieJFBF1NbqSQskk+uPoDQUSQXXAkk5MYoO4ezv2QPau0xdaulbNqUlQR1jET5VR2rSfZd2fQlOzTmVulO3vBO1P8AephvpuWndkdJskHuLVO+InbPwirDUDVOzGj3Da0P2LC4E+7zUWV5u9tfZVns7c2r+mN92xcEwtJMg8kYqLrndhteKmtQJUDgKkSaJ45GZWtLvcIUpagfAVGCRQHWLvvDtbdgDIBmhpized2R3VzHwnr0xmhoKXn0mIciYVvbj8auGsN0VQDAVBwUimGiF0nHljiY9KZTU/U1IDzoKZRuzsXyKiKxwI2kqQ5IwBumqAuISU4D0xB3Dk/SgjKbSFHc5tI4Ck8+lA1bSdqjKN0wPCR09KARbKUK93HkrNARDDolW1REGc9aBit4bJAVJgSRQMQtaEpUk7khWQfOgxLy5kHJ9c0BkXKkkhQBByMfnQKblQ8QGeQTQFD6UNEKBUpY939aCYm7UG0+9IEyFHNBQatcqdWrJ5xReGxeybRka123sWHkgtNTcKB4JHuj60hMe1tLQi2Ybb8JXAx1+McfWoYv2D4tglawmCTkTzxWtP4mloFMITwMkDFGcV18y6hBUnKRz1Mef405Vyj2yaKnUOz7jNyxuUlaXG9s+BQ8j0kYPxqLHmfX2HrFCYaAtyYadLYG3+k+vp86FUr10pC2nkSkpyPQ9RRVs3qjm1CtqikgZSZBqYmpbeuvDCQuYAB/tRdSG+0rqIS4TPwBxV5OEhXaW3AEoRKjtygCf8im04F/emmqJLjKCqc7WJptFZqqrIPu/eKSkmPd4E8VE4VziLZSSpNwQOJNVDO6QoDbdJGYGfzoGKackHv0rHBg8UU0odUnPdmBPxoiOpC/5WkKAPyNA1eCkFpaYwohX6UChRBTlwDpQIl4lJysRjKJoEDgMkqQYxlMUBmy1sEhrjrPNAQJQsFO1oHkQvigMlLYVBQnxCBBHQ0BH1N7FqLfCSCAeDQateK+9VyPnQdh/Zvsm06jqWqPrS202Es71wAn+YmfpUtkWR6msGEIWm5jfKNwJ4OKdq5l2x7Y6te9orXTNKvXrCzSgquFWtst91CjwpewGBH61Pr9jWx9luyutXlhZ6ppftIutWdSQpKVtJ+zLI95CkjI8vMeVJPh4Ta6bauPvWqReNlt4DY4mZg9Y8xitdHtU6zatXFo424lKkqSdqVjlQGBTSPMXa3S7u0VcWbNosh1W8NJCShYPG0K4I9DTKrkF5pxN0+wg7LhudzKsbvUeo8qJdH0dLbtqEOBZcSYKRPFCLX7pITtbUkpg7VAncnyNRQO7TuQAFbum2icHJtE7C48pwoBxtSJmMfCi8F7lC/EQoz50FnqWlt/aVhNwkAK4VnFExVu6YgEjv0RnxAzz5VUwBelQqUvMCcySI+dFwJenLSQB3av5t1CsFg+hEJ3QryXNECcs7hHRQwRP+elAMsPJeUnxDcTJIoFdDoCgAoo56jNAEpfASNpgdIoFSHsFSJxkxQEbDpI8BJGT0oJTDSyVEsgiATJGR5/GgIGT4vupKUzBPkeaauIGpFLLWzu1JUZM5iKI11xXjUZxReu3Q/Zz2fv73fcLbW5Z2akqct0vBCyVCZSFQlSoTwSKlk/qzh6J7O9r9N0a30hLF3qWu6a8wq4b+xWjjz7aEmFJWhPuwcGeDjNM/4gms3ruiaFYN6NdobvdTcVdXT4G1RcWneBJ4OQnPAFLyYh+zNzWe9cdU8/p+u65bKulN/Z0rZbLSkpLqknxFyFhPICok9Kv11LXRG9A7Y3A3H2gON4mGdGYSf/AJFVXPj1d/7n/o38R7/sl2n+yk3Pb/VHwhSVwiwtWzAOYhHNT6/H9/7Ja1d72cMa4V269a1641ANFYefvI2K6HaEhIz0iknx9Lemm9tfYH2guuz6NRZ1G2udatmSV2yAT3xEmEKIBmOh64mtSfHpnXndFyW1oIQtJiF7RBJ/v6VlqLVLwdaQUhwbem7rNQIXjPvLE/7qpzRDkvr3pDbjyUbiVJmZBEAZ9YovKWHeYkweTE0FjqOpkPnchkknHhFE1WXV8pZPgbA4jYKGo7j5KQFIbgZ8IzQ08u7k52AjMRJP40LT2nwk7koRuyTgxHwmhMPduAEbV2zZRzBJyT15oaGX1uKKnWGgqAMT9eaG8s78wAllrakyZmfzoaKHQBv7pvd8vn19eKHGsQ6FjZ3bQUeuBFCcpDb+1CSC0gdASDzz0ooZfBJ3utwAMJBk0DVvblrUjvFDPCMx05oNc7RLUpZKd8TjceBVEPsiNPV2u0ROtrSjSjfsC8WrhLPeJ3kx/TNOuSt0eu2k9r+0Wn2Lj7Wm3RWllxQ27EhRAcHTgmD5Gp+n49AexKyRoWgHUXmS05qP3rTZna20AIKUkkjcZWRPKqpW63mlus276LHTWNc01ay620h1Db1qpWSnx4UiZIMgiYyKbzwn+j9mNP1G21J/VdXtmLe8dYFnb27Tm9NqxO4hSuFLUqCYwISKuXo2NxsUBkg+8o8k80PY7jneI2q2iSEkeVFkxAtEhi9W40lAO0JOPeAFPxL0uG1kpSFgpWRMH8ag+fup2lve9sNfdttiLMX9wpCEqgFJdVtAqauEUwltR7u3dWP9xLwnnp0mgEq2aU0hxLVyUncARBzPB9RQO+wtnA+1hUEkltJmgKbC3EBa3wfLu6CJqjb4dVuMkkj3PWqygblJVlIUZn3ePOaACnyCdzaAfpFAEvrK0ygZHnE0BEv7RltAE8E80CKuliZbSrjPNA03SioygcmTQKi5JAIQkEGgeX1lZJQgx/LPPrQPTcOqUkJQjbyccT1oDKvnC5tHCfCITnii6Ypd2sYU7k9ExUw0qWr3bBbfMyTGJmqaKNGvLoAC2dzxvzRGvappr1m6oPNlGfKgtezKX9au06Yu4CFKt3WmnFJ3K4EI+BIHwpxGtj27petXLmh2Oktt22l6w0yn7Q1dtFQbATt3pAI3JJGDPFTlNi50xwlLKLpdv9tDUPPWyC0hSuZCCSY+dVdbAztuW5JBc4JGaayalkNkGTPkai6VQCvcxJgCOtXfZqO60FPoaO4lSuJ24+NQvMU/tE7QsdmOymr6oUOPP21ovagGSlREDPTJBq2mvDmlvuptFFpKnATlRSVSev41F0b94OtXIWoDf03JwfSOtDYM9qjbRSplLYUvxLSZlKoj5j1oaifvAqTuCUc4gxQ2JSbwZAS2ADGetDVpf61cfaSsssrgkgltMxj0phqrVqu15e60tkZ2yhEUxNRXdRZWpW63T8dkfPmhwAbyzPvNJMHkA/3qgxuLBaVLLOSSPdP9/jQ4N7/TlGVpMdPCofrRCpubELPhHIj3uvNRYCq8tUwlA64wr+9U3gqbu33Yb3JJwNh/WidJbeoJQ0VJt2yCcAtj8fnQK1rq23FdxbNAETBQMekx50A3u0moZG5CQPIY+WKFRV61qDgnv1ZIOEmgRm/v1mC8rAxMAUwUmsuuuOHvXFLknkzQxsPsaSlz2odnUu5R9pKiDwYST+lS9D1Ddaqb3tvrOoutXTlnbMsaehDCdyinK1KPpuIA+FMq5W123anRxqBsbxtAuFJ3AsHvS2eQFlIIScjBNOaZW36HcpeaKkpWlA2kBaYInz8qqLJ9bYQokz0phOUNi4BuiBJIEimGKvtMXFWFyPEPDhWcef5VLDw1DtTZt6vY3mnXI2299blBmSkEjr5+dLDHlq1SnQPtWkahaB9dvcrAcPgKvhml1ZGLvtLeJRc6eVoPvDvjkDyzinJhjN1pbiNrzbyiJ2OBeY/qERI8+tDDQvRVT4bhJHPX9KGDqZ0eTD7ok8bB+tDFfqjMvLIbBAUfd+NVFVcFSVrlK2yrz9aCI4tsqB3qTMg4oECtqtqXkq5B8qAZWTKpSRx0NAQqUEpUEJ4xIpoyQF5QkSZmCMjpQIhwkoUNoI6GaBd6ylUJ8PJGYFArlzkkoTtwODx/5oGJuAWjuCgFcx9aBgCVpUFEgATBSc0CBZAICNs5MzNF0VJyVhspT1on+K6/ClEqz680XUnshqn7k7T6XqKp2Wz6Vqg/y8H8DUpr1zrTTd1rugWrA22l9brcuFtTLw5Qkx0GTU3VtdL7OI02ws0t21o0wlIA3CDn8ga1rPCcl4NXi3Wk93uEkxO6roxN2p1rfx1gZn1qbV0PSyVuKWQogiDu6CkuGiawgqtgjxFS8CfWm6W7FO/aJcCVOoKkJB9MxHSi68we262b03titaUlKrllLqkqEeLI6/AUTXNHLiSIOY8uaGm98vaBuIT1wIobCIdUVeJU/wDSDNDU3vQkkKSiZ6pP96LqfqbavtLsDEkGCDNGVS+lwSSFAxJoIalKMz5Tk+lANLjiCNoSn1ii7U+01923VuXp2kXM8puLBCgR8ooixPae0V/G7IdmFpMYDLzZMeqXRTavCFquuaZdqSbbsvpViAM9zcXJ3Hz8Thj4USYrbl9l50OW1sLRogDukOqWPjKiTmgwPspt1oW0sukeF0PFIT/08H60AAErUpRWqUpkTzNAiuBucUAOnWgUubUkd4qPOgRKykKIcUCBz50BS8oQlK3CnoDQCcQh1JV3it05BFBVrG1RBEelB3P2Mdtrq8udJ0u5uD39qO4bWeS30yfLj5Cs2D0/pht2d4dCVEAFE4Ch1/71rQLVdRSSi3sdrjjhgxIAGOtTfSJbEjDrhHklJ4P+TVVbWbSUiQDAiehNQGZYcvLxS4UGBA3ECFfCg517SvbF2Z7BF2xsQNa19GDbNOeFk/8A5V5Cf+USr0HNLR5U7c9vNa7ba4NU155tTiUFplllsJbYQTO1PU56kk1RrrklSQCk/SgbvVPupJ6UD0TMAIJ8upoJZWsqVtZQRPnQT9WtAXlbEkKBJiai9ql1p1pRgqH61URVIWJBKweoPFAikrgqJJjzoGbfEZCQfPrQYpOTugKGKARSDBKcnyNA0DkHz4oEKJ6GOKBiBBBgxPpQEU3gYMCSZoGlIIMggDyHFA7wgZGZ8qBSQlU5BGZjrQFbgoVnnmIoIl00JJjnpigjWd3cafetXNm6tm4aUFIcSYINMHoH2fe09zWghjV714PIACkJASkYgqxyKzmLmuy2naLSWkfcvNlASAStQBPWP1iofVsOhXK79QFigOGf5IISOOelbiLDtT2m7PdidOTcdrNTYZUoS1bAlTjh8koHiV8YjzipbIsjzL7UPbxr/apLtjoZc0LRzKYaX/qXh/Wse4P6U+cEmmeyxxZS0pSAnA6imGGd54dsKjmqYclZEeXT0+dExIaAfX4VQryJouDqt1CU5wJkRRB0Wu4EqxJMTQxbauE/aHFFQCiYhRNDpU3I3YSd22ev+YoIqk+DkSPSaAJSoYTKtwgSJzzQONs6pLigleEhRlP+TQMDD2SEqOMnbMfhQCUy5uTKVDofCaBq0qCASFTM5FAHMxuIjyoEPEJJ45x5UDkk+IEqKYzEUCbsEq3TmgclatgkqxiIoJSW0riJAPSeKAzbUCVKJ29AYoac7tCCUpUJAkUFTftQkKiKCPp15cafet3No5seaO5J/QjrQe2vYNa6F2u7K2uqvxcXZGy4ZW2kBK4yPUdR6GkuFqJ7fvadeez5Vl2X7IWLVndXNt9oVd92NrDZUUgNpiCuUmScARgk4l2rHlTUb261G9evL+6fvL14y5cXDhccWfic0kzo3UO527Y7xMgSSDVNQ3DuMIOOZPWhpMcyD55okp6CmdxOKLpyFgqgDihqWy68CkkhQ8jmhqybebKcqQD5VD7N11DStQFy4U2T4hRk7U8k9MUxe/CtudLvVHNo+MxEAf8A61UxC/d+oFavu3EYJ/iAZnrihlMb0zUFFJVsgKjxXEfTPNTTDzp14rLrtvAOFG4GPSd1NMqKvT3CFb7u3+T4/wD6qmVEc0t5Owi6t1hWRD+f/tQykOlPFMl+3k8nvxj/AOVExcdk+xv76v7pWp3xsNIsbVd7fXjY71TbYwkJTOVqUUgD4+VPGmBdqexl92e1QWqH27+0eZbu7S7b8AuGHEyhe05SYwR0IPNDtRt6Td5C2VAKBiTyfpRcpi9MuESpxtUeqfP5UMpPsNyQQW18iPAP7URIRa3KkgFhYPM7YBigQW7u4At5Pp/3pmgxtlhuVNGYkqKcR9fjVyit1JhQtyVIgAxx+dQa8s+NR5k0Hof9kHWNWZ7S39lbtOO6StpBfUnxdy5MJMcwcgkcQKmDof7YmkW7nZjRNcBbReWt0bYpUoBTjTicgecKSk/M1d8DyYt8iAkziJPFAJalO5JJPwoGOYO2KDN0DIPzoHIWAR+BoHJWZAAJHSgO0TsyDzwCKAy1gqJkiT50HS9YN0bhxCrh/cleU7iayutfuUvAlSiRmfEo5+U1ciIDrTgWrxN7jJIJ4npnrVwKhnfEhB3HmBPGaLSrZSkNlRSEnkmDREd1kFBIW0sJjjE/Kgtuy3Y7Vu1ry7fQGbO4dbUhCkOXLbJ8UxCVkFQEfygxTj2D9uexV12SvrKzvruyunrm0Ref6VCkhAKlJ2ncATlBzFL+C97FnRrT2V9qldoGbtyy1HVLOwW7YrT3rO1px1DgSSAsBUSkkTJ6gU6Gr9vNbtO0Ot2ytIYfZ0zT9PttNsk3Ed8WmkkblhOAokk4oKBLC0KiVlYEzPTpFMDVhZ8JLyAONrihkfOiwoW7kBdynwxAcVUkKlfab1G0JuryQnnvCaporV9qKXRD9yVg4kz9KGnP61qVs0UrfdSAnAVt8+aGtd1TX7u9R3anJR5FCf7UNU8Eq86ImWL1zahb1rdLt1CP4bpQo+URzUsl7WXBLm9ur58OXl0/cuAQFPuKWR8yTSSTo0gVCRHPXyqpopUlSf5gfKcfGgETJ564ousInqYjNDWASRJOOhNEFTIIjk0B20nad2PQ9aGnuJJcVtOJPlQdV1txX2hwf6YncZKXAFTUXGuvJcBWUoQkj/dUk5/TNDAVhwKH+nJT/wAqSZ9DRNFZlqT3TqSgk+51wOnSi1CefIKZCxCuNhHSqgLlygd4p1Y2qB6kFMdeOKDp1iWvZf2Ra1JYab7b64wfsAdEq0yzMgu54Wvp9OhBX/is55ad257UN9pdUt7pkPJattPtrJCXXApctogmesqKjnOak1Fj2IYOu9ju13Zm2+91NaWdW09lKk7n3GJDiAOqi2qQBnFXNq+NJ2g7L9mx2Fte0nZLV9SvbdN4jTr0XtulAL6mu8JbwIA4IM880/iKB/SFMdmrLXQ8hbNxeP2Jb7sS0ttCViTMEFKp+VBUXKkBMoSkgZkAAmaBqEmcIAHnPQ+k0B1oUspVsSMA+/8A5FCCuvNWdup5QSCEnb4jP50XGl3145d3BWpSiPU1JERTHTmqHoEmcRQPyoRUww9PhIPnVD0kfKOlDNFKvBkcCIoYZxHHzoTkZSVARGAZigSfFgSBFAZIAJUY+HnQEkriE7UUByyVqUdo5NB0bUbMi8cAdtVKBPITjyqCpf0UKUVti3zyggYPlzTVwD9z8pSlorxAC1Z+lDD16VcAe64kGICXFD6UWmO2FwlKo+1FAOFBcxj1olbR7OdBaau77tP2kD6uz+hBLq2HIP2y5P8ACtxzMmCcRETg1dzlMah2m1rVdf16+1fV33HLu8V3ioSClA/lQmeAkYA9Kki2qhtT4B8UIGJU0D8KqFt7m9tby3ubW4+zXFusOsvNIKFIUOFAjM0s0XvaLtj2o7RWNta61ft3No0tT6W02iGklw8uKCEjcsyfEZ5Pmaftq6sbe+trj2PXNipy0/eDHaJFy0wTClIXalClBPMSkZ4FTyY0p99YWuGLWSOiCKqHMuqTnZbx8+f0oJjlyrbvDVsQRjJFF4a7rt6XndgDYCceCc1DVZBCJPJNVCQSY60Big7wlJwnmhrOhH5UXWcgdKIe2Ign8aA0cwPQelF4wqUE+VDvs4qgjaZmibh2NySoYTzRdHQgBILsSf8AzQ2iIlQMAhPE9aIkLKd3ug/E0HpBzQdC1C9UtjWGrVe4L7m6WlTavTeUAj5/Wpsva5ahal2OGn7TdP2yEOyUqcDRQv4LCgD9aXO4RT3nZFtaZae0pM8Hw49MOGp9pfJlVF7ovdoJVe6QVAj+ZxOPlMedNnteUK10q6vri3tLF2weuX3Q2yy3eqG5ajCRBFWZbmnhe+0TUrfTmbPsrpF407pmkD751Fx/6m9VPeuHzCTKRPEGnF6Rzpx8urAdWpSRkw6k9fUVSEP2ZRO5w44A2QfKoYG6GgkAuCDjhMj6cVTAUIZBI75qduDHWhgm1tmFh1jelOMGaGC9yl5SfvWdpRKtswTiRzioYKm0t0qHeuNqZiRBO4Dy5/Ghgd0ppizWsusbg2YBkxQxz24X3twpRiSelUwhPi3RgcUTEllrYyXVDxdB1ouBx4T0P50QhVg8RwaKaORQwdklKcQCRFDDhJ8+KGCpUd3hPyAoYxMbxgEehoYM4ChHHUD/ALUMYlKzzB6zRBUKOJUAfhk0XBFLyYQFDzmiOnXBR3yg7uI3dHc/j0qLo9hrV5pZ2WL4DBwthxYcZX/zIUCD9KmejfYr972Z1CTqWjuaY/8A8fS1d40T5lhfH/SoVrb5P8CsOyVlquo2bFlrOlrtH3kodfBU26ykmCosrgkAZwamrdbCez59mFnqWr6qQ32j757T9FZCMbYAVeDgwEqVt8ir6avHETty11CAT92gN8o3Ax6kmfxrIzWrB/RNZutN1G3Qi9tHC06lB3oJgEFJnIIIIPrVRHTcIO3KUk+6NsmPhOacrwULShQTtCTxlvHqefKicE71oD+cxj3YoMS4gyIBjzBovAPettqBGwmegPT50JcSxcNrVvW2gqOQTIxPnNTDVZ2ovALZCEoQkrExEmqcNQSConbk0Q9CCVgHjk0NHuVHwNzAAk/2oBjg+VAxXSYouiBGeQKIJiAZGOPhRdOaBTu3YH50pvsUAHjE1NTRm0hIKh73UDP+CmrpHlhSEBOfFxNJTafKlYKttU2kKQI/UUQYbRIUCTJ4oOo6qWAtwB1e8KIVuGOalFa5cNISpC3FqAOMgTiixGLzACtzi44jw/X0ogLrtoSoOlwwmBJTjFGm3dqu2Fh2m0fR7NzRLpV1pto1aW9+q5PeqATDiViCFpJAKTgj50m0xQpQ09aBlWiOrWAUlYUvc5uPKsGQOgEVcqeem/8AbzQkX/ZTQe19npq37p60ZZ1NlanNzSkp7ptwAAYUWik+u3zp4Rc22io0vRP9kE6Barvr/Qbm/wBQeLSlLRd7e8YZ3HI2pQQQOpBpvOHhyVehaq6pK2ezbpMBWW1R/wDap/8Adrga+zWvplJ7PXIBjKWiZPx3VcQn+zGv/wDsF2YI922cmiobnZjX0EqX2e1CDmDaO/higT9xa4EeLQtR2nkizdAgf9OaZTGk9o0vovSh+3dYI/lcQUn6EUxFVtyRyB5UEpnwoKifUj8qAJUSSVZUfKgWckRigwZzQPmVenlQKJJ9PSgIj3VfPpUBWHJO1VT+BwJBASfhVAiSXk8gVRICiNpMYoClHeZVmc0D9klW3iTQdm1C8Qblew2qVCc/ZEADPlFTauKm8vu7d3NqbR0JFs2CfUGPxptEB28cPiRcqCU9QhAz9KAD128QD9tuBu4II4nHFBGXcvKUSL+5InP3iunwpgatbynCk6lcKRIzuXH4mmT0V03QtXb0jsp2Pv8AUGjqOihWoaFqrESXW1OB9uJPvJmRxwRiac+ERuzWup1r292etO70W2pai4ybd4yQ26yplKT04ikWuYq0963UW1vtksqLeDiUkjn4ChbSpslLck3KEgIwN3J8qcIamxfSopRdmSZ/iVMnpeRU22oIUNt873fQofMz5c1cnpAb681eysllOr3aEkEbRcLj86mT0a0O7fdfeUt55x1eZUtRUT9a0BRwmczmgK4rG0HFAPpIPFA7ME+ZoMEAYoHIIxAoHpOOIige2qEZEdc0DgJPXpQE3mCD+VBix42yOeDQGEgcUBWZJ8h0oJZCdypSk55oOi6o879uO11ACSYhPXyHpUWKZxT7itodRBERtOaIhupeCVK75AA4OzmjWoq1vrUQ2rxAklKEHkDPFEoDi30GPCnfwozH0qjEPvmBvbMefpRDhc3Clhoq8G/vO7Lh27iIKo4mMTQPRdXDTjTrJKXmyFIWhyFJIyCD5igYt51CEqDK5KeZnr0oHJuFyJQ6k85AgmgRdytLhjCVdFIoBOXuSoKQAIG0GBQVeuagtbKWwoFIxhc0Gvp8Tnn1NA9HKl/y+tAkmcp+M0DSCE/rQP4ViMetTsYT4aock5/WgUqkcYNAoCuYzFA9sqHMwM0BgZPu0GK8JT5AjpzQGBhcSeetAZjAM9eIoLBIbVJU4lJk4IoOl3ncuXB2l5IKveWyCAfrTBWuWwCVOJFyqJEJYED15pn4Iy7cmf8AT3qiEgCGByfnTKHW9uwXEqca1AJJIBDCTH4/GmX0tqVd2+moZ2ly9AODutQemMyIqZfQgtsaWpSC5eXDRkAJVZqP47qv8NEXpukd4jZrNugKx95buJnGRiYqb/qQFWi6clP3es6apKufE4ifqmmxcs7R06IlatwubNSSJ2puAndnHIFP6hrmhPgBTXdqXyCh1KgSOAM1QxzRr4+NCHFHdnw7s/I0EO50m7CSpbTgQDk92f7UGmausm4UCIg+UYoIbYPkc0BCISBAmZNAzcpSpJk+czQYD1+dBkEKUOc0BEpJEcUD9oECeKDFKwCDE9aBynIzAz5UDErUQfKgeknxSsAmgcSrneDGfxoDmQsCBIPn50Bg4EyFCADQGKxuV8fKaD0m47dW7rgFqAQqSSETHxKuaoVl+/DuVJTIwFBgH8V5p/QK81e6G9DhcmP5FsJ+ZhVZtVWr169S4djaiOZ79oCotmpdn2tv2vftm3AOpU0qB1ESJpt9pkTx2xe37jpNupsGCk26FFI8zCzV+19rgDna2x70m87N6apMk7HLPaR5SRNX7fL2mIh7TdnHlfednNITHUtFOY6eCn3+XswJWq9gl24VeaBYkH+Vp4pP6Yp9qWMfvPZQ4yC5pF6z0Ox5UT8Qqp9/yIqL0+zRCkd0x2gaRmFNXCFZ/wCofrT7fg1LtZfdkGrFStOv+0/2oqJSFFrbBnkiDzH41Nnr/wAjkjzhceUoqUqTyoyaoc1HeAq4HyqgrxEhQMqInB4HQGgGU7RxHx6UCRgR+VAQeHkcmgWSeI+tAQJVuATBJOCTQIWF7UErQQRiKAezwySOKByMgZAg4poVIIHhKZ54oHDcFRKPpQGbWIKDJPBgUEltUgSAlRzPnQSGkuK3EQBuPTn1oOvXibhbiiEe6SMLBFLBWP3IYWUOKaQdvHep3H5GoGOvF9SFt9+UwDCBukekDORVy1ZVU846oKW2H1IGJUI/SoUL7Q+CFNqMmCQVgR8ZoSnJ75S8gZER3oHwGKGHLbedwpaFqAgKLhMfOhDHrZSEqENCczCiccwaGBItQVwl5mTJ9znHEk01MYhbAJlZXEGMQT/aghretigJC31GTGQBH0qjU9edSp9QQVQD1NQU81QVJymQD1zQKk559KBylHzx8KBCszOZJnGKBN3iMkDrk0DkqAGCJj40BW3Akz16hIqaCfaN6EylePeOIqgKnNw68cRFA3erkCPnQOTumSTQESCFYmfjQOYQsKkg8yaCcmCMyAcyKAxaVJ5gGBmKD1npnsIUdOcuu1ms3l/dBJcOn6Yfs7JMHwBXvqJ88fCtSfDrNTlMtfZjpFpZ2rf7us9NsXIW80hg96qUztW6uVkDrkTVtSWt5Yd7KtILSGrQNNJCYCfd8ukDis6o7eldnrx4KRb2i15lQSFST60+3oA1DsNo90krXp9m4CNsqZSRB+UzVlHA/wBob2cN9kOz7HaHs8u4tkm6Q1dMpILaQoGFAHjxADyzUvI8+HtBqyAQbsmepQJrP1isPaHUyAFOoXBwVNjFMC/7Q3pyW7efPbH605D2e0Tgc+/tm1JiD3ZKSBTkAudddU790lHdjooc05FdeXK7tZW7tCjnAqiKMnNAWCD0oFiJnFBvfYX2Udre2imXNL04s2Tg3JvLs901t809VfIGtT4++B3zsd+y/pNo33/afUXtVc6MWwNu0PicqP4U4nQ6HpXso7H6Lt+xaBYJ2nxLdb71U/FZNL874HN/2pOx2ktdhmda0zTrK2ftL1pDjrLAbUtC0lJSY5AO01L8rZyPKhbIORkelQIUAGMY9KDAiQZoFQ2JMmB8KAgRxnNA5CMZ4HkKCQyCR5xnNAVCTtJgeEzx060E9Ctoz1M9aDs/aD2he0Hsgty/0/U7jUEv7WlpvGg8hO2dpSABtmTJ69eKl+Pody7K+1DQ9d7DN6lqV9aM3Yt0F63Cx3i3NokJandlcgDNPtnHkXWh62xqOpvhqyuLa1dQghTrQCd0HwqHSRV2+RV3Whv9mS45o6m3dP2labRwkKbzkIVxGZAP1q/4JWi9qVP3At12t2y/iUuoIx8eI9RUwUv7SLCbz2J9o1vynugy8kDGUvIiatR4UfbAIjI/SoqOtOdpBBGDQIc9R8YoGlAmetAikgJnr8KBi42gg5oGpHA86AwgKwPxoPSn7OHsb7N9q+zrXajtDd/b1d8ttOnIVtbZUkwO96qJwoDAgiZmrPlJ/o9I32t6fozC0WLK759lABZtAk7YGAVEhKR8SKz9vQouyHa3tD2p1B5CtIb0hi2d2uhx0XBWkiUlKk+Eg9YmDiaSXyN2dSEwX3E7j6AZoOfftC2iL32NdqGtoUplhD6T6ocSv8vzqweEbpvas4HmPWgjpGZJj40GbTHIg0BUIJGIjkyOKAogq8P05oHsoCiBwTmaAzKCpQI2kHORQSw0J3p/A4NARSYURt49Jig9EX9ozKybZBTOUlQifPjNUcr7W6M72X7QWva6ztEuNtPBTtq4ISoEQYIyJB56U3eh3f2eau52t7Fuazchu1068XtNq24twkpVCUKVyVHHAFZn7R0l5onSdPadSllboUQ0FYQYBCfiPzqiFcXH2MtltxK1NKyAY/OnQ0L9ovthpT3sp1TTE6tZfvG6XboTbh5JcI71KleEZwBJqfaXiDxw6QpwHcDGPKqAyJ6fM0GAcTxPNBikncYieKAZwraTiOooAOY8Pz4oHJTA8+tAdCOD50Hoz9ldm21jRda0NLptrhNx377iQNymikAQTxkH61NnkejNN7DaBZsNNhtb7bRKtr7ylpUo8qUDgk+Zq7OxszblvbshtooSlCYCRU3RV6hcpSne6RuGZHQeQoNC9pOuKuexPaK1bcbS0vTLhKlKAInYcfpQeHi9vbQpWFEef4VQDhUcf50oF4STA+EUBW1SmAJigyCYIIUPTkUBEApMAwT1iYoJbQGwkkgDgigKkqO5KiZGKAgVzK8gkcTQehlO2SnFBTbZWZkhZBMeeaq5Ee4VpbyHUOtoW2RtKFbiCmMyKmydGKPT/wB3dnLp1fZ9260zvPEtu3fUEKI4VsMifUVm5e4uGOdp75LSmXdZ1pTZO4JU/JRHQYxgnin1noUvaHWzc6VfNPXd+8pbR/jPKVBHB+NMiOINfxQDMyfyrSJZIChJjrQNPiIifPHSgwSVcEj8qBXAFKxwKAa8GTOAZoAH7xZNAcJwoyfDigVBJMExQbH2K7Uav2P1g6poFylp9SC04hxAW26jB2qHyGealmj1L7JO3uods9GL7qdKuLwKUh2xVqHcuNwfe2EZSQcGT5UG63N25pTh+36e42k+LubZ5CyfSSqnBqu1jtMzethTFtdJWCEM2S1J3vLOchJwkdTSjz17Ye3y3u+0ewuGn7kpKLt1lO1lnoWmx/MfNRp+jkDPjYRAjHU+lUNSRtEDzMUDlKEHriPjQYDySoGgMkgASZH0oM7zAEiBHFAVt6QQRPSgMHIgzg8GgKbhKSQCBnzoO/PNsZUlFwAeu0T/AJ/nSqn2tQ1KbS6pDbDhQSV71mM9YjzrH61qr1JhJMi3fIkZ3jHziraagOW6i0Aqycgq8weRQqDdspCXh9j2+AjxKkjHlHNBxsCLhzBG0n5VUE3YTA9KDJOAPL60GSQoxgemKBQqTHT1NAx4w3A86BrWGzINAQABnM5PPypoc2PGRECOtAdAKWwOnFTYGwApKhIWODMEfMVRKttZ1K0c322o3Ta+J70mfrQS0dqtfRbXFu3qtyhq4G1yDClDy3ATB65zUwVVumSExz0FUKxDaFIPRccUGLBQo9OuM4oBqWM5waBoXgnxfIUBfHIISfQnFBnduEzKfhOaB6QvIkD1oCQRBwTxnigsLa3LzZUSyDuI8TgQfpQelry1Xvk26yqDBCz8qrUmKlzTnFoVNs6AADJUZPSak3DEZ2wccQpxduChsDClEmKmWGK121cDDhNukpACtxJzk55kHNQxW3LCHEFBYKQcZQT9D86GNRd7D6YSpanb1G7OED6VdTA0dktFEeK9WAkySoDNNJDHOzektrSEMXCweqp4+tDCp0bTe8hqxQ4kYBUlQn8aIbrWj2NrpgWNMaQ8FKBVuPT8+aDnz4+8V5DgAzVD9sNgnyoCL/goT5yZoEbJglRnw9aCTkNg4k9KASiOgoGSZHpwaByZM80Dm1qKSkGEzJxQP7uXNwURPlQNW2mRGT5lVApSJEJ+lA7YdvWc9aAgSdokRFAZtBBGBJzmgRTcOQM4mgcpBVuzQPIMnHWg9X3SQsARIxO5yD8qoh7FAqGwyJJUHBAFDUK4CysoQyoQTA3A8eVSrKhqZdUnb3TyeRO4Ewc4rBUB1p4AAC6kDoJ3VrDUV1p1SCSi5AyFbUggUw1EYtiEbltXMhJAgDIxUIhJtXnlqT3Dp8W4lYjpgDr61T9NOmvyd1qtRJAG5YTgUL2qO17a2NL2KaYQIJy5uI4GPKiORvYWeOTV0PPAkcCKAz3uDmMR+tANMbs5ipyDqV4QKoZJEkigbAJBPPwoEPWge3wJPTmgOgkKA86BFnx5+GaBSBxOaBQCAcCPhQGaHhwMQPnQFCQCIwPwoEcQQsTJ6ZoDISAiCMnigOiE7hE+I+lB641T7IxqTlk3asPPgFXhVG4Aieatop1qaCipenbkyTIWBjy9elTkQbtLLZKE6UUpKc/fTNORXrQzgIslSIGXB+GKz3VqE+4yWz/oHBAk+KCRWueCICrlkgA2V03tM4czIHHqKyiP9otEEKLGoDvFSBvwf7VRFdds1FJFrfuTlILnXoPpUWoxdt0qO3TnDkgBbmCD0xmqVrXbR1YswFWYagEkqUSc+dIjmCsq6c1QfaDjr5igI+D3cGMpGY9aBiEgQAREfWgOpI2mPeoBhPkTFBh5NAxUz+VA9HMETHWgMklJ8Mgmga7K/EoyT1oHNDwkmeIFA5MhJFARoEpHQx9KCY2DggSDmSOKAak8nM+XnQSWm96YPwoDpQPFEHJ5OaD1P7SrZuz7YJfTcIIetVEBtwpAIWJE+fmat5GsXLgTAStUZTHe8Y4HmKzZoguvvgLKluBKR73fjE/+KfUQnLtwDdtcnMHvhzz/AHqLQHXHFNKlD6gMyHBAJFCK19xQVti6BWAJCgZ69ePjVKhqZcLyCym8U6DICVgk+cDmkmkolwyRtbCLwBIgJW4AZouoS2vDvKHEk9VPkgEegol7at2vbShlKIZCtsmFKJ/GiNEQJWn1NUTG0eLr8aDLkQSTA4E0A0Ahwg+7A6UElafCP90ZwaBqU7cfPnpQNxnEg4k0DCMk9BnJ59KDEwByYigIAJA6H1oHrSAkc8UGJSIhUGR9KAiUpjgAn40BmUDYmRnpQS0NnbOY+nSgYsSRB/GgOiQmEwsxmKA7aRtygKyeRmg9V6lpLl06TdWz7i20bN60j3ZmAeuauCtf0BJeTNg62tCBKQAcnr88YoK1/s+2oqDjDwCzBKWwSPjnzoIC+z7YeMsXQmQE9ycfGDmpkWobvZ+FuAouskqH3Sh8zmmRNQh2eW44VIavEpjP3S4A+NXA9PZN9xaixbX5PRbaFAifXGaWTzFlHHY6FNqNpdOuEEeMZ9TJVipno2nf7HNlSwi1G7mXFNiPPrTjwlab7UdDa0+0Ckpt0pgEQ6Co4PkPhUHGkJBKI86osG2oIJAIPMZzQNu/dWQBxz056UAm07HEg+8OVAzQSl7i2gEICRjHOT1oAbCJIPxzxQNUnOBJoGETyIGfjQLtAGePpQHKYBImYB4xQNIKgDOPjmgVtIJA88ZoDJSQiBB9aAjYAQOYxmZoJSePETPQxz/egc6CqVExwAfL0oHMwE+ETBkEUEppaQgAiaD2y8trvHCGy4SnEogfDNa1nfCsubgJEps2oIKgVGKy0gXNw+pJcV9jabGQmRj8qCtf1AJeUO/ttwWZKYJ4+NCoF1qhJM3bAOIlRKgfkKn9EBeqHee+v9+4kohtZP0Aq9CJ+8QVH/XvqQSICGD+E9Kn8Ic3etGUd/fglO9QQlKRHxJqcelwou2toKnNSKc4DyEwav8AErn3tbvmV2O1KL07REuvoVOPSg4oyCXED1jmqLJCdzSpgR5Zmgj3RlK5n5CKBidvfkqJCcYHWgPuCkyDgnhIgUDQkqUSJicRQNXuPCTHUnIoBL4yT9KBySQfP/OlBLZWlMlaiBwRE0AVDJAGJkE9aBW8qEjjrQFVtAOeeYFArRBSArGKCY3u3JUMERJ/7UBy6hSFAIhSuIyPWgGHEqykmZEDggUB2ESjCUnPJUf7UHsHVyEE900oEKJgIJnPTNWVrhrzzzq1gG1fHJjbUMV7v2koJRYPLUUxG3aRnyqnCAWdXRIb01SUKhOSEyPnWeS4jKY1RSss2iFxt/8AUSfoDUnZwjXFlqgBIfs0gkQqJg9RNXaXEYabqBX4ruyKSJjuzgeXFS1IMnR39wKtSaZUY923JJHlMCi1Jt9MWlLbf28qM5ULU5H4dRRL20D2qaeu3bUTevPBSYO5sJAgD1qxHJGB96gE9ePWqLFkAmVAgeQMUArtoguQk7gkmPKgjNpVuzO6ADPnQFKBsUeMcxQPSMyRniaBihIgzJyaAJTOCPwoFT6nBNBMbQFpkrgfr8aBXEnifD0NAxMD3gc8zQKs/jGPKgGlXuSYBoJbDpG2FmOYoC96SuUCErEwkHFAjafElSc4z6UFgy+tDYCAI+Aoa9cXr1zKkouU5PEKxNBrt7dXu9cPNFAkAKcIM/CmCueu784UGi4n+vcTnrPWmANxfXqdoLCFzMEx84zzUyrUW41a+cQhp9hxTaPC2nvI2z5EU51EJy6fdSXF2q5VwdwEH600Qe9cKyO4ukk7oIcEyPOnfKw0JUpsLWzdjqZcBkeU0QVkNl1KBavArVtSVPRJMROfOmjRfaOWChwIZebdSDlaxmI+vWro5wlJFyk5IVJkfiaCe2IkjJiSfOgHdJJSuZjafKgjMwHFTMcTQSCDJUmT8f1oBFBiFRnkiga5wBPwoB5KuogxzQKlORzHBoJaNyhCSYHlQK4CEyMwekigEEqkiSR8aBygotkDmepoAhMJBmABEzQTrXyPxSf86UGGSo46mc0DmMrKSY2+uKCUgqCYTMDyNB69vEvrRu7ghEKxJmJ8/jn8K0zKCu23krS2Fb0hZVxsJBxkVFV1whaEApaIg42rB3VFVy0EJlTDpjAVPMnIpytQLpjdulpwGdoJSDA8uKIA5bW5WYZWkDkKjr0n4zQVxYY/hp7wKTkgISqI546U7DmW2ykR3wA6loSMYHGamUMWllLqCVPk+9tDQEE4/Sl4HOfaaUNrhCHPGZ+8QAZwP0pBz9hP3uOUk4jMVRaW6UqR72ODHNAx9pK7d8IG5W0j/PWgr2NxO4iFEDB/OgmIbITMn1PxoGhs7UwYHUGgE83uPPiEz5UA1oGMKAnigYkevHSglJBCuhjPFARSAGwUkxQDQgwBIkg0CqRzxHkaAG0wDA+flQTLNCVYIIngxNAV4jwggmeBH1n1oGIclSoJ+PNBNZJ7sSmfgYoPadw5sCB3i9jgyEODzx1rVl0RFXRuEQgOpUERtLg58/xrICpgKb7wJuEqlSR3YT0HM0EZzSdp2ONXIQvxCGwZxkmi0rumFxQW21eqGDBZBPzxRlFc0dIbAVbXST/xDabiZI601UZrSWUpUlDV6FNqIJNkOvT1k0GGzsLZ8W+qLcsEOEt21ypglpzdwhZjwLHkcHoaAqOxts8tSXb51JQSYDJgGeSYoOFe27TWtL1Ftlm5W6d8be7iOZ/z1qDmDCQX2k7eQoTiqLW3QAkjBlJERxQZtlakgSVI4HXnNBAt2xuKSoQOBz0E0E0MYJUDtgSRmgAtpXBEnzFAJaCCIBgeeaBimpWYyQeU5oGhsD3hCvKOI4oJLUJVtAxxn4UD1JT6SABtI60AYSICuI49KB6gQmIxyBQBOWxjwgmKA9udqxtjHU9RQZcJV35cVKkp43DOev0oI27ZmMA5+FBPacPdp6iMdKD3RbstOaqoONoUA0CApIMZV/YV0+XTE7hjlpb7Sfs7U7lZ2CosC1e2Y+z3X3LeCQPCMYoqEwlPeoECNwER/TUyaJqPCfDjPT4UvcUZhavuRuVG1eJ+FVA7l1wuqBcWQEmMn+ms+FbNYIRcWJbuEpdbWkhSFjcFCOCDzRFTetoSkbUJH3gGB0xWh5Z/aUSE65YFIAKgqSBzWarj9v8AxLf4frUF4gfcE9ds/hQF4uDGJ3THXFBXWv8AAdPWU5+RoLIABRgDj9KCO/x8FfoKAIyXpzCf7UCXYAaVAAyaCE775/5gKCQPESFZG480CyfBnmZ+tBiwJSYEwn8jQYf4KvhQR2v4a/8AmNAa3w0sjkCgV8khZJMkD86CGsnxZ6UEkOLSlIStQEcA0H//2Q=="

/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 299 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 300 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD//gBvRmlsZSBzb3VyY2U6IGh0dHA6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvd2lraS9GaWxlOk1vbmFfTGlzYSxfYnlfTGVvbmFyZG9fZGFfVmluY2ksX2Zyb21fQzJSTUZfcmV0b3VjaGVkLmpwZ//bAEMABgQFBgUEBgYFBgcHBggKEAoKCQkKFA4PDBAXFBgYFxQWFhodJR8aGyMcFhYgLCAjJicpKikZHy0wLSgwJSgpKP/bAEMBBwcHCggKEwoKEygaFhooKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKP/AABEIAb8BLAMBEQACEQEDEQH/xAAcAAACAwEBAQEAAAAAAAAAAAADBAIFBgEABwj/xAA/EAACAQMDAgQDBwQBBQABAwUBAhEAAyEEEjEFQRMiUWFxgZEGMqGxwdHwFCNC4fEHFTNSYiQlcsJDU4KSov/EABoBAAMBAQEBAAAAAAAAAAAAAAECAwAEBQb/xAAxEQACAgICAQMCBQMEAwEAAAAAAQIRAyESMUEEIlETYQUycZHwgaGxI9Hh8RQzQsH/2gAMAwEAAhEDEQA/AM82lLMVYTJkxwa4eTWzmkuQIaFhPlglsAE+9D6lk1jfRy3omSGYQOKV5fgdY/k7/Qb7csrLM8Zg0Y5G/IsoJHbvT4SWaV9G4Pyoucl2zQin0iB0NpVLwoiD8eKVz8hUG3RP+kksptkCY4iaP1KSBwOf9tVrgDKUgGYnn+CkeRMKg0Dbpfm3FJzgMZxW+pRvp/BC704QD4SSQF4zTKb8MXhXZ5dEQkbMwT84oxyBcEFtaFHtwUEMIgntSuaV7DwujqWWtpNlYM+VlaB7z8qWNyUXYdxbrQNtChA8qE8sDVHKSsVQQfS2ovLIHBGPdSIoct+4ZRa6J27VpFEBSCRmPwqUV8DNNEra2wzmIJBAEdu9MtLYN2DTT2nMkHjBiT8ayi19wXYX+nRN3ktiFiQsH50y10Z2wF3SptC+Gs+sxR4+WC34Bf0tsg22SROACf0rLHaszm7psK3TUYAhQT3iYpNR0+jbe12BOgQOH8NTHBHNbnFq4sFNaZIaVbayqgMDPBNLbd3Q3XQL+lRXhLZAAIBAxxWWloNv5If0a+GnkIM58ooNN+QnG0IwfDUme680/KSVWLxV2COikLKIPWBFFNozSZNdLC+UAZGR2Pzo818i8H8EV0pJEjcJ9p/Km5J7FcGgo0ZwwRQT2Mz9aZZNifTdHP6AlAzKJA7HFD6iaaT2FwknbWib6C2BIUZyYFOor4Et/JG1oEV52gqexEUOm0hlbRK50ywSQLVszk/D1p7d0jJP5BDplpp8pHckEgn9KCi2+6GcqXQWz0tdg2tqN092MUjcvDGTp7QK7pNPaeLl65b3SVVW4E95PNVxu12dMJaNLeCyCgMRnFcbkqtmrwiN62Ayj/EHE8RSymqDGIJgPFkKoPqokkx/xStmPWsbWMHng8+/6VoyYGl4OMbbAQpJH4H+Cjya35BQMK7IwC5Mcn14/M/Sl91DasNbU4IXdBgTAn+TRb1QFFXZKfDBLGeSCR2n8efxo2DiRfzOpV5BJmM/GmpUBKiCrtCmATO4yZ/nrSKkM1YJBuUHyLu80dx/P3oKKM/gmsrESwgmDRQGjygM0OpiOxo8kzU0TCofvIAJjIop2CqOhB46YwT8KRSuRWKpUQtnapMeXgVuVWCUbok/njEL7CKKnYONHNgLRDRETNU5vwJxQdFVcEmY5PekbZiJZRzMHsadSA0DKLIgEbveim12wUvB3YTgAx8anKNjIh4WYKGPjSfoM0edVB3KW5IxTJ3oHHyzxUQ2IjvQjJt7ZnFeAZBMROJ+HxptdhqiADEyJg0LS6NXyE2cblMnNNzF4E2QbQzBh8qHI3EiB5TiT/8At5o2+0biujl2T/j5R7Ub8tgr4JWktuVCifiOKLfLSDVbYQIAzYB7fwVuTibimdVBJhFPfyigssurM8cQkIFClB8QOfhTfU8WDgjqIjwNoBXkR+VaM3KrfQJQSCMEBjO4Qc5+FHI22rNCKRneo2bNzUljdVSexz3NNB62WitGktwd4G0sMmK55PZkiITzbie4IJzj1FLFWGRBrQa5kENBkGRH8/Si/hCo4LahPUE8YM85/L6UiVIZuyKiFVVMA4JzET/qivg1WDi4QCcY2zunI9P52ptIFWEYlCZKmSSJMfh+tCzcTlxWZvLkDjFa3YThsFBkD1J9T+lFJg0B83+R2gmA5444iitGaOBPImYb0iMgelBsyRMp5SSInHMTSvsJIWzuVgfhRoBMqT94n4CsA7O2CoAaRg1vI8SNq2DaUd+TmptBCG1Ofwmmh1QsiJQnuee1UFomtny5B+tBb0Z6OG3I3Yj40d9IFHPLOD9KNmo4UMmGj3oMNE0XaB5p7msqTA02SKjuADRQGjzKPDzIJEDFKMCNnaJY5MnFBa0g1Z5re1lI7U3gB4BjxE9vakGo6EPZd2KKTBo9sYYVR9ZrK/AaXkj4ahyYz3NPQr+A1mz5THODmmtCU2Se0ZJIAj4UskmMjwVYwvalqgvYTaJACkwKNAOCyM4z+dCw0CuWnThcRFa9jKqKXqQm+NyAECDB5ya7MduOhdIvtMACJ4ORnmuHvRRhLpWTwTj5Zx+tP0J2cRRvDP52ntn+c0GvLBfhHWYwAFzOfQT2/Kg2+2ZJEERHzg/GtZqJW7SqMZ7cd6ZULsmLKkSQd3rAmg/sMgLptY/fI9ZEUt0NVkSpzIYiMd6blSNVsjbt4EAGe3pW0B2QFoLGDgfWlGOsgBIBk/z2phSQTBiR+lZ6AlYW0gzIz+lIuxmQ2f3lIx5hE/Gje0FLQO0vlkDtzWiGSGUUQDkH0rLTA1ZPwy0nt6ijbYtI74SXPhTV5Acu6YIkrk1k29hqhfwDJYrWb3TCDNsk4mK3ZmTAAkZFahQipLgGTniKKVgDNZyDn84oSVGiBuISBPfOPjQSGvYNkVoIE4rXoNExbIk5GM1jHSuDmRwPjWejLZwWyRJ9e9aJmdtoJMgR7066oVjHE4/1W6Foi4kSZ5rUr2NsgUzyAB8sUZVQEdUhT3MziO9JYzQS2ZJPmk+tDoBy9bkGeSJoWMZzrXk1zKsCAMV2Y5VFC8bNHpbI8KTBEfOuKC2PN6I3QdzBFjgY/L8aZioG4LMOYDGJ9zQYaDLbJDbvUZFJYaOpaIuYxOc/OtC3tglS6Jf4oIJMD96tpCEY8xgmScxSXeh6Jr5sRMTwIEelZ70ZfJ0W1LSCOOYo8V0a32CKeY7TPy/WpvQ3ZwWciVgjHv7Vk0ZkXTbIPpR5UCgiIMFhjtQcrNR3ZkKvB5Fa6DVgnt+dZHlkA0vLex6pHrdojJ4I7VRPsDXRPw5MkgCnWxKokbZ2YPyHetKXwZI4igTJJgzQWuxnvoJkr3mjyYvEHc7qfu96Dfg1ASucDntQX2MySKCDkAzTCh1Xb90E9po2roWjrgniPnQct9hS0Cu4iGEiluxloEwAMAgAAASc0HIZImcjb3I79/lRTBRAfdxBETzWu0GqCoJ8qjMR7TTIDOBYkD1xB+H+6yYGGZTB3RHYE4p20hUQRQEI80ZP8/GlvQzWwhtEEAcd570rkagYWG5yRmD78e1Jz2GtBkUEACD2/wB08XYGjzW2AZvUdqLVmToy32itOeoStsMNgyc+tXi1SGijU6WPAMz6RPFcsYWqQJOnZB1D3GRVIjkx2FGSfkVP4CiyrRAmDjvS1bDdHbyxIkwKLVGTBoY2yYPH4UFKg8ThBKErJn5elBOw1RFFYCMzNMkY6u4juRHpW5Js3GjyW5YAPz39a32MFW0fQDzcxS6Zujl22WAiQSe3wrcWlZkwI3eGBGAKVoKJhWKwx2iskjHmXbx6RTVboHR24hK4JnGf2oUqvyN29HbxtWbBa+6onJLHFI2iig29GX132u0g3L0yxc1Trjc0ovy7mqxUn3ovH03yUOu+1nVHcqvg6eBPlt7iB8SapHHFr5KfQjHsrn+0fU2ZSdfdE4MKg/SqrBH4A4wo8v2o6xb2FNWtxfS7bVvyg0fox+APHB9FhpPtzqrZ/wDy9GhXubTEfgaV+nr8rEeFM0PSftN03qTqi3xZvtkW7vkJPseDUvpvGtojPFJbovFAnjIPEUtrwRaaChYT396La8AoLsAUnMd4NJxpmuwN5cycKODx3p3VWZIHt8uJn1mkaHRKyIbIMxBx/JorQGe2qWJMR+f8/SiqZuiaWxK4nHp/I/aqNCWd2li5iD7fnS32agwSEJjg9qD2gpbJWrU7hzz2+FBdBZK5bO/PrPPNZ0BC7JDA+aAP8anWxwttVZcjIphQrA7Gj/1zAql6E8mS+0Fq6eoEojsNo4MVSMlRSJpdCFWwJB559aWL4onJWybjb5VHmPeZpZO+zJUeW7/6kDuSx/ntQTDRy5bLvhgRP8/nvQkFE7Vpt5yJ7/vSfYclctkKBnv+dBNrs3YMICsCBmmT0bySFoyABMCcH9aNAsJZTa4MZAzWo1kgwAil6RmiKkY2iADma32YSSICzMVhZilk0no1HHt7gMA9wOKVd0Hwda2GiIlaq1Qq2V/Vuo2en6Vrl4+aCEHqfaptvpdl8eNyZ8+6tqtX1fUA6himnU+S0pwB6n1NPqDddnZjhS0d6ZoEG9tsqoyTUcmVvR0RVCeq0xdnZlmTXTCdJEmrZXXdHA3RAGfc10QyWTcaKnU6cRiQR3rojMlJCzam9ZIDedfQ1RwjL7Cqbice5Z1CRbDWjkx+1LxlDvZTlGS0X/2Z+2up6TcTT9UNzU6EY3jNy36fEe1Ry+kWT3Y9MjJLpn1zRamxrNNa1Olui9auDcrrwRXFya01s55QcXTHCoYkBmJxGZrRpiPSBGyJkj2M5rOIUwbJtaFn7uK1JG7O2lBaB+HamAwpX72Z9fem8bF86DrbXadwmB2rS6MuwXg/3ARxxFQkvgogm2AxGdscGtYyRJRtUiDE/wA+VC29BO3JZg3B9YphCPh7gSBP50OwnNsIAe+MU62Kw7wEMCYHpQlKtASsoeqaa22oDORJXv8AEirQVqw2xzRXI06jzTuJJPJpV0F9jdm0H8pHPoJz61qsToM+mDNtBIXGO0UPskH7nTaUEwoOP170jlsZLR0p4YwJOQcZrNUZOzjiVyPjmnUfkF/Bxh5V2rLLz7CkbXgKXyeUT780bQaCKpLxGO+KzkCjwSCSOMULDQArBHvWaMGKqcHABpFFds36HQhaCWwBimUUZsFqHtaXSXL187baLuZvWmYYRbdI+Wa/W3+r9Se66kgytpBnaPYVmlFWejCCSouen/Z/qGpgppyqtjz4rmyZoKRaK0X9n7J3xYa2WC3GEyOO+K5Xm3dDFXrPsprQzFXtNMknIFWj6qPVAoz3VOg67TqbhtBxwdpmurH6mD8iODMxq7bISHQqfccV3wafTIyVdlTqlaSee810wIyQjqFAuYM95A4qyRNkCVdCrwG/Ojxroa7WzUf9P/tU/Qtb/S6t2/7bfJmf/wCk0xuHt6/Wuf1Xpua+pDtf3E/MuLPuVt0FpGGS/AGQc815MPc2RkqPQWnyjdtqnbEArYbJPl9e9amg2cZAI4A9u1CtBsIgIkEAyafwKHUE8nEcUr7CEtWyyiTSOqpBXdnbqqCUXj0jtU2q6KIhdQKh7ACSY+lHoxEoQYIM8H1mte6BXkjbAG717GtAzPKuVPqcGnXYGhh1AUn0BwO9GSTsVFRrT/cUbZheZjua6Ma9oH+pLSKRZBDbv/rn3qC0tlHsbs702scxjGJNBvdIV0OK4aFUbdoyOabSFWzizBYAFe4ihFXsL0TuAOIUTHc0rfj4CkDNliMtg96Ckw0R2YAyST270j30Mgi2huAMT370dIwWIJiTj1ouXhgoCyCYGTjvW0wnhaBUFpHvQcqNQW2gOCeCY/CgvcwdHbvlQQQMSa6YaEez5/8A9QOrM4t9OsOJJDXI9f8AER+P0oL3SbfSOz0+OlyLr7GdDazprbpbUXXEtcuDJ+Q/evK9Tm5zo74xSR9F0nTWVFDXJLCRsUAcVzyYyG20KsWXzZEg7oM4/wB1JMIjrenWzuPm+IPwocmGjOdT6ZFsxcaRMA1SMgHzbr/SQGY8T2ImvT9PnoSUbMN1PTFHK4PfHFevhyJ7OWcKKLVAISTMdzXbB2QkgBIYNu4iMAD6U4oJwIKnI9ae12K/g+v/APSP7Q3Nb0+50nVvvvaUf22OSbfp8vyPtXj+qwrHk5Lp/wCTZFyXI+kABQCvI+9UI2ts52ewpLMMdqL0BHRb3HdwRmkaHTJKsnM7gc4ocvBqJhAuSc5pm7WgUdLHzADHApKHPNbJUSM+9akY41toBkyD6UeJrAMu26QAe+0d6zVBR22CdxODOJpYeQtErSeZFAiDHPzoXvRmGjyndxtmme02L5KbqAC3Eg4KTyPU11enT4IWVWOdM8O7Hh/5LIzxXM7pjN7G/ADPuUwygADsPetG+hZV2e1Nlk1GwKZMGQMDEUIK42wvTolZtsspdeSBANaOm7N3Q1asjadx3D4d/wCCjFcv0M9HVsjcRsHtWaoyIG02Tz6AYik2uxkeNoq67wN2az0FHtvnAgmflWXuZnpHrKy5BgdvWnS+RWwdwAopGDwPpStIKCWlEhoxVIRTdsWTaVIrutaoaHRPcALufKiTl29Pb408qX2GhByZ8Z6G93qf2pN3WXC17ezH0GYgD0FVz1jw+09GC91H337NjYi8Axjt2r5yXZ0mmBAHmJBAA49xSWGiYfdiZIx8amlSCCvkEQcknNb7GKPqHhAOSOeM0UAwn2gt72JQfvXThdMzPnfWNJwYPNezgmQmjJau1NyDIEwccV6UHo52t7Ky9bCkhCCBma6ottbIyVdAXH+BMT3FU+5PxRY/Zrq79G67otck7LbjxV/9l4YfSahnxfUxuIVvXyfpM3UNly7rtgR6HPP0rxXclaIdMilzfcUAGDHHbMUU9Ga2MhkthpJBUcE0jlTGoNYYMSFbc8xis35Zq8I6zoUEZ5BjtFGu0gJkFkn07z6UPGxq+Bm3DKQcnsY9qF2w1RJrZ2EiJkxTN0DsXe1ucbSDP4iptjIE1vmVB/D1pRjtldz5JmOxj60VtgY21ubLAQYHFWT0TaM91Vit2zIUk25MtH+Rq+GTUNGcbYt9ntbaFoCdoxkiJwP9VJx0wS1JIvNNeF294dtoPJxmg/am0BbZ3V6gFQ7lmI2mFP5UsU2hnpimk1YfX29vnDmRHNKo0qYX3aLlWJZkwSDIzVFVWDYe2h2HcSBkenf+fWlk0ZIiLtlrgtliWHI4n1ipykuxl8BLykuBJz3rBoSuKQ87T3+f1NGMVWjNt9hbAUqGH3cTFN3pCv7g1RmNsBeD8/8AmpsZB7doJaydoAkk0baWjVs+Y/bXr7rdU2T/AHL0rbB4t2x3+JP8xVIR+q99I7MOOuzK/YHTf1HVLrqdxQgmYySZq34g+MEi2LbZ956LCLbdl7Sa8BryXLa3udGUMWkwCDHP/FTprYxMFrbSswRE8/zilWwsjc3Q0SIHM03FJaFsotejs3mBIOPmR/utFa0Yo9fpGuAYxAJPpVE0jGX6p0nfkqYHFdeLLxYkkfOvtPpF05OwH1Ne16WfLs58ioy72yF3zII4ntXop+DmryAuLgkTHqOBVCb0BVSWK5O6jQvk+1/ZfrF7X/ZjQ3DdbcloWy2MbMbj9BXkZILHNxI5Lb0aW3rFa1aC79zKGliRiO5+lckXV2O43VExqxd1Aedzcn0HtRjF1voE5V0WqXfA07XWaYWYHrWat0LdKyXjeBpbG4AvgH2J5oOPKWjRfGI2JPEEHgR3ik5Ui1DPhsyEE9p+dBfJidryiDIPFa7A0Qby3ATxBJNI2MugNxGiSDE9+KyCDtPN1RxOMd81RKtsVvwOOB4KwRBba3Yj4UW2+hV9zOdVulL6KF3wn3gB6n1rrwW4aRnVmc6TrhqdOW0zi1sG0Lcgtn2pJx4e1m7dj2s1nhXvv7wEhmnJM8Y9fStBWiUlsjoNWL1hhfYtcElfNwD29qXImtIrFLtnhcOmdLtvxCBBg8getKlybT7C9LRoNP1SUtuNhIO0knbu9f3pGkrSMk/IW91Br9uLbBYG8Tyxzio009lO1oVOv8NgTg5YEH3iPpTRhYk3RZ6fq1j+mtvfdReLbQgaSR6/nVIwblpaF5pLfZYWdl8K4KsCJke/FOqXjZuw9q0q452nOeKTYSVhRtTaAATP51NqmN2I/aBxpem6hhJlAN3u2P1pIt2OlbPhH2vvFuuZYeGbQ2EfP8cV6XpoLh/U7IOkWH/SlT/X6pVOTtIHqIzU/wAVVqLDg1Z9q0rae1ZUsADEiRFeFJuqOhbH9JqbTf8AjaYjEz71NutDUN233LyJjn+fP60qfwYqepdZ0mmJDvuaeAaKjKXRqEB1axeUkBAMcmnUGgMX1ersmGD2weImjGLMUPVNfaIYSIrohDYjZ8v+1rh7rsBivY9KqI5OjGX0iIjb6V7EejjaYBAS7LGGHA9qdrViWRZIZQBOSKCA0b77C6gD7Nvbf7qahkIHoQCB9Zrg9VH/AFLJT8Gk0Go/qLJWWkEhfSMf7rklDiC7LfSW3sMrMSQZmeZj+fSlVS1YJMsLOse7qUR4VUImPw/StxSV/JNyt0S1WrY+Ane4GYZjvA/WtGHn4By1RotHqLLhU3DxAMj0Fcs6XZ1Rdj4bymYk0rY1HlUEZwpPcYqfNXQeIbwfDbxLiiAJMmPrRn1aMuys1F8hHkznuea0VrQZFfpr8307j1HYCa6oLVEZMnqer7NHhIO+AD7D8aosRN5DK9V1167fR2UAlP8AI+5rrwxShQbtmH6K7m+WmAvmHqRGarkjplNWaJbty7ZEHbbB4PeTUFFLvsi9jfTfNdIONsscwCe00k1W0PF62OW7wNwbVLMZIIwB/P2qTi/0Q9jN26LQlCpuRyfjxSKN9hbFbWqed6ncoJIoSWqGSB/15W8Ts4Mc44/5p4wpInLbCabUXL2qVmVZe5gAcCKZ2o0jKCbssrPUL3Trguo3/jKjaTOPf5UmPHzdAnLjE3RDm46qBgjn4+tSjHlsZutHBcAtEgndJEAdq3DTHUtGV+2esYdNJ3MVW4h9YExP40+OCrQIu5Hx/rhtX7s3GMqxC9zH/P5124rj0d0I8k7Hfsvqn6brNVesgFlgERPek9VD6kUmPD2tmyt9cbVadr2u112yF8zW9NpzeZV9WJIC/CvLlg4uoq/1dF077JdD67bXVeL07W3tQF/8lu9a2NHcgTB+VLmwNKpqgxd9H0DXapregbVIx8Nl3A+o5rzIRuXEdnynUajV9Q6iWD7Ubz72wACa9hRhjgSttlnrrnTulaVG1Z6xdFydty2gRCRHG7kVDGsmWVR4jOktmd1nUn279Bq7wX/+3qVAb5EYNdkMPia/Ym38Aumtr9fqNoVmWMsBimyLHjQFbEvtLo7iW2Fw574qnpppvQJrRinSQwErECdtezFnG1Yq8qwM8cmOKrVoi9HpIYEngzkUKsNmn+yRd9NrdPuAAuJdCnjIIP6Vy+opNMlkT0aa3f8ACVJOzYI8hkj1rlcLI9dFp0++5tXLdxmOJDHJQ9/jilcUnaFb1sftXC/ibGV5Ag9/jRqhHvoC3Uxd1tjcFtW7R2+pIA/Wt9Kougpq0afpF7drLW0yGwccnaf3rgyx4xbZ1Qe0kai0oVCzLM9654uyrCoSl8ggkYgEfjSRjbehm9BL2pVVhgGk8k9qpxf9BbKbVXbbW7hG3c0ZHp7UYd0jTWrK/UXAhNu2pVigzPqa6cKvbIZXSpA30nhdPW/cIbd/jHqKupX7UJXkoepWEe5aZ9m42x95gO59TXXg1BBads+f9LB3+HIgnJOI4qmRoqzVaaEuWts7ST7j4muaW1RL7jdlJ07tdOGLGFMz/DS7ukZtBdISxGSnlBEH1ipyST2FSvoC5CXGDXIg7cjjOBS3pJIovklYVWtmGlYLMOO/5UJN9hRWWNQ98spVVtbtwHEfOrqKirvZNvY/otSqXUuFgAhMjj+CoTX2KRdDmm1Fi51u6mvh9KlprrqpiYUQJ+NBclBcNOxGk+/g1us68mns+OGDbkDLBkRHNQVt8YlVHVszdn7R6rTo6Xrhayybw/dWAOB7ZH0rphjTJzb6GvtJrLY6Y62ypvXrYFsdsgSx9hP1ipw8FIK2fG9Y8G+SPOWgmeM8/lXoR20elSUdG1/6SadddqOoFlt3BtRCrZ5mvP8AxTJw4r9Q4Y9s+k2+jpo+l3dKemePZuLDi1A3TXkSzc5KVlkqK/o/QUS4bqdMtaRUHlLMWI98nmtPM5acrCaHriqPswLSgeRNuRFRxOslmaMl9mdEUvgJZRjEgMJyOK6vUTUkKtGk6xp/+521t6zpjajYd6lQfL2xniuSEuDuMqHsqE+zlx7hjpaae1Mk3Blv1ro+vS3Kxatlrf09vSaUjbbRwOFUCKkpXKwtHyf7cXUV7gEZr2PRKyGTo+bs8M/BnHPFe9FaOJuhe+fOW5MHEY4/5q6Iyetkh5wVBExg1O6YatF39lLyJqtUl0Za0IgxBDCZ+tR9R0mieRWaO1dtusKpJU5xiK5pPRz+Sz0dqTKs6gD7qms5rwhHHQYO1u4xVmVgIkiJoXezVRK2bf8AUsGAxGeJFZt1sC7L3ot8Wb9wOViQ6mZmYBrmypS0Wi6PoVq6j2gxIKjOOD6VwKNdnTd9EWup9719OabSBsBfuI0rbIY+s1nTVIZfcS1EspVgFJPPapxTi6C3aKl3Y6pmJMKMCefSu3Eq0znyb2OXn8Xp4VSIic9oHenapixZnup7i9nZe2f28gxnzNnNd/p43AznTrsx/Runvct+MiEo2QWIAxg/jU8mVJ8WVkixLbn2vdtDB2hboYn/AHSNrujRSqmENxrai0162pHaZAPvApk9WQcRjdCl0vKTgeUzSSVaaBGxS5qdtxkgOynBM4P681Nxva6LRtIFrTcsgMpY3WDbo42/8VodhfRHTlSGFvKCAYOM+tM+9it6Frrxdw8KBkdqdIFkrl5zqQbbbWZNhzzx/qhx1sZDK66/c0sFZswEQnMAdvzqX0Vyu9llL20S6pqGNmzbGBsAGKOFbbFmlpHNRrhcdLT3QoS3aQZwMSePcn6UHGnopi/LZieqDfq9RcsuNrNgHBP+q6sbpJM7OL4m1/6Mas6fqOusiN7BSPlXmfjEeSjL9S2DVo+56J2e2vicASR6jFeIizRzUAMqooD4ExxWjFMDYp122qaC2ARBO4gfz+TRxx9wGyo6KoW+u2JmCAKpljZomxs3gWBAhTA4j6/WuVKlsdoV1t9QLhO0ETxNamEw/XdcFDDdHsDXXhhYsnR8i+1+pa5cYSTnj0r3fRxo5crMdtMSCJOCfSK9dM4mjpt/3EBJkERPFOpaEcbA2VggTkkciOfX5VmBMufsxauaj7Q21tKWa9afgjkCTz8KjmaUN+BZqzcjpmoXcLdgiI5uLPPxrheSLXZHi07YzptHr0A//GIJH+IBz9aXnF+TSgzzaXqTffs3So7bYxVeUfDI8WAOk1wuEeERbPG5SYzRbhXZkN6Aai1d3MrbTBINs/tU218hTo2/SOrW206pcRvKAJiuLLifgvjn8lh/WI1shnG2eD+NRUWtFm0wTamyG3eIi5/yPE0rt6GS1YLU6u2SRvWBEZk1VVJiU0hNLiKd0By3c9qurEoX1V1TaUEmDOBgcYHzqlOhF2IdSa0162Ycf2xhT8a7sEvYJKOzJ6Bja6ZdFsCQAu7GSRJE894qE177Z0vboqdQu3UKoBB8qtHqBnP1qy2rFLNWBtKzEERk8wfX/mkRLpnbAUXygID7dxWec9v2oN2FJUFDILzSSA0Rn9Km0xkOXDauh2DDY2GB5HypG3VGitityxusum0rn7oPtTXTsVbE7ltg8WjBUifpTp/Juket2mAW40hNwXAzMVnJPTGS8g2Qq0gnHl28Yn1oKWqH8Artx920eYgAAgcCPamitG8lbf1DQ6sNoZicEH0A96fj5LY/AjeuMA9zDKMAx3gH8IoJJujvpxjaLb/p5rjY+06uTtNxY+NQ/Ecd4f0Bhl72j9E9P1Yv2EYOVEcTzXzTjR1M5e1IbV2rSmN84PcxQj8sDQP7TX7ensLN1VgRLGO3pVIe56FM/wBH1dv/ALrYsjUKRdJAC+sTVJxfG6MuzWWybZG4nA5Mfz1rmpWOVXUtbsRxuExNNCIGz591/W7mbI74r0MOMm2fNPtA7Pff/wBhXsenVHNkdlIQPMwXyiYk13r4OZ67OsQFBDEwQSTTK+haVWKlT4ZYAmRIM9oqhKx7QubWrs31YSjhie8EGTUcivQXuJrU6hqblrZde4yoQOS4AxHf41yuEVshTfktdL13UwFu+Ge+4rH+qR4k+jNOh231i/uIFq2RIBkk5nissSJO0Gtdfuhkmzb2k/dGKLxJiKx/T9ftuolGtMRxMjnsam8DDzZar1NVUNcVsDAx6GofSsqptdkm6tYbhQzRBUx/OKV4fI6y3oQbqrXWcC2ltVkzH5H1p3hUKs0crlZXWusXBfCui3EAkmcx6/jVJYF+gYzbLO51fRWLakOGZ5MbRPzqa9PJvYHlYhqOtb9Iuy0rNgb2UQPl3qv0PuaOR+Svu6q8j+Vy4IncCIPb9K7cKSikjXb2Z23qUtdObxHkF5VAYJHaPnFTlG51RV/IFme5fu3GAKqJgdxn0/OikkkkKnY90pyQyPDEzcb4zx9INJLQslexgZZ7qDsPcfjSdaFT2FuEIqZhgskflj9qTspQK95dxSIKzz3rLYZKhzT3WvIWukAloOR6VmuPRMWDg3Lu1cboEDjn96KQWgawbgUtOZAEZz70WNFEGG1mEsDPG3d9SKHgYWv7nZpEicAyR708WkLuym1LJavONoaB5QBEwCJ/GqU2WxvWxC/Iu7RDWoztPf2+UUyo61JtBek3Dp+qaS9JAVlX3iAKX1EeWNoMHUkz7n0XX3E0tsNORXzOSCO01Q0uj6lo0W8CrKd6OhhrbdiD+lccXKMrCz5n9tdL1d+oXNPfu/1CIBtuWwVx7jsea9X0ssVWicrO/ZDpN7SdRsazU3TFkyFJmKPqcqnFxSFiqN9qesW7h8NGE+3evO+m1tlLKTq952RieI4q0IpCtmL6su/cZPy9K7sQjMH1f77g8nv+tenhOfIUzDdMngZ/Ou1M52iV0MQAsgEngxj+RVExGgF0eU4UASPQZimi7JNUMaWIiSR4UD4gEUmQePwaPT2LhtswZRvVSZ74FcrkmQdx0OFLgTcY/wATKsI47DFbTFbaC2hcXIdGg/dM5k+n4UbEZ0Pc3AAhByRu7RQNQyLqBxltoMGDBOaD6MlsOepObjMpYKTheMdqRQ0kF92Hsax2uMGUjJO4/wA+P0rPH5FUqdDStcXSOjIAY3GVGRMxPbilaXJMZdUhLUqwVQCFJ24GZ5Ip4tN2NToHettaKuSN/wB4Afma12Gg1p0XTBWMgwB3E4n50E2Fx+BvUaU3UsNbsI82xJZtpBk9pq8G6GSRitJpvNZVjLeh+v60Mk+x0hliiG4sgm4NgEn1NBXoBZ6C2LYDNO4qc9sgRU27BLoIQkgK07ZJ25JpNiqJyGuNuuMyiQDNC0uiqTYVkS7uaRtmD6x8aWOlQJW2BN2xatxuX1wP561TbEoh4iuy5U8eU5/4rbG0Sa69oiFYqGkmTB5+VDsZfIG44I3b4J7ztP6UNm0BZDc+/OOTHv8AhTp0JdCXULRu3GLDzbBgCOZz6U0XRbF8lcQqo1zAAzkTJif1ozd6O7GuKsUuOrI7qQP/AFA7fyKql4Fm92fYvsP1Gz1HpdvcwLKoVh3r5z1eJ48jR1wlyjZrNJ0vqG+/qNJ1ZtPbgeXwg4P7VwucXpxsZdi3WNJ1O9aA/r9A+JZ8qT8QR+tHHOEX0x2rRmH0vUmu+F/W2k3d1Wa7VPHV0SaZf9H6emjtAXLz37mS114BPwA4rnnNzd9G0gfV71tUgHAowTFZhuq6jFw7iTgV6GKIkmYjqTb3YmYn07V6WLRzzKsLDFcEtxNdfggztxIjaYUd+8/z9KZP5Fa+BV2G5iGmcjyx/O1UiTex3TKEcAMQuzgjvupJu0GJpOmAPohukOBBHqYH8/SuWb2RktssVFu4xFvYAIEKu3IHxzx60idMWS1skLZVZdWmBgY+OaexG9nUtAXFYqVJaSBjPzrNGUglq0Bs3TgEeUUtMzYzYt2/EG3yqQJxNYR9D1s20HBZpnI71OUW2OpJENRqFcFS6gnIRSSTWjH5GtvoQ1F25dYKjBRt2wO/pJ7z7VSKoPboGiKvhxdN1uSZ96ztoda0Oaa4RaHhoQhxIXzCTnPuaKQL2E1lq4LiQFcbBknPFWj0BGQ099lKF8kGFb0gftSZI2tFY6exgpvuLeMA24YieB/DU+bWjOJZi4WFotJDArLAmMgT8efpQaMifh3CF8OAxO6WXbjgcZ+tJfyEITfVgdwIjBE/tSqggDcuNumX77eVB98UejUQTeXjMATCCP0o68itfB7wluJI5kRPH5U2hXYZdJcBTyFd0sMiD6EcVm67F5WEXT3QxUIW757/AEpLRkwluxe2ptS4DIzt/k0G1sbsr+p6e8msYEeVgrFoiMH/AHWUlR0YlaM3rvEt3CIDA4jtXTGpKzpUtUhO2shAxhTwSPlmnumZ70WfQOrX+jasOj/2mI3qD+NQ9RgWeO+wwn9N0fcfsh1q11bRg2rgMxKk5Bnivms+J45VJHYnatFxr/snZ1l3xfFYE9hMVGOeUNINWUmo6Pa0W9Q8sI471dZXIWhNrosAktGOKZKwGa6x1QsSAwzzNdWLEI2ZjU3y4uFjOMGu3HGicjNa197wvmiu3En2QmxTcV3QO0ZMGfX8q6STBuWBIUkQZz6UyEe9AGUyMgYHeaaLEaosNOH8YcNCn2yJ5+lJLoZLZrOiqLllitsm4Su2fnmuGbp1YuVU7GraXBdZXAyvBJMDtzWbVElsbtackQGAIkyJiP4PSs8nHYnG9HLqsgbwyI3hF9Wxk5GK0cjbqjOIFLjyAwE8YiOOxqnexXrQTe6yDuB7jE8ekUdg0CvXLzEKd2RiZz+sUGFJI7ZRgpkyeJ4n2oWmM9Denss13bczgACRgTTIUheAH3iSxMR60u7KaDWrgWx93sDjA59qLsWtgtY95r2L+mtbVAK3Lm08enpXRi3GxmjHL57dsHkEn8qzVFbLCz57KqxlndVjiexNc0tOw2St27zAgN5Ib5nvB9uaPNaFC9Ne7cui3dhikneM9hIJ78ihJKrAy1ck8TDk7ZGCJ7fOk6MmxMWdrLJBMxJPv3H7Vm9DKWyCMQ6r5mETniR7UaNZJJ3wBHcmIIj8hB/GgCw7PdDW9r98bwJB7xnimXQuhm1Z1H+LoFJwd4IifalaiBsbt6PWmGS7tyZgH170jaQUxH7Q2Lth7F66ykMjIcRkcD8T9KENl8U+0ZK+QVFx9vl8xH8+NdK+EdcVqxYXV3IHECNvue5Nbi/BTmnti5uq19jGTJ2/KqqLSohOSbsuvsz1zUdH6gl/Tsdswy9iK5fUemWeNPsfHl4P7H2jQfb7SajRB/FCvGVPpXz2T0OSEqaOxTjJWio6l9qLFwsUJZjgEetVh6aXkVyRlNf1a9ecqZCjAg12RwKInOyo1N4A7rjD2EzNXjH4Ecq7Ky/qmvYVfKAeOa6YY+O2SlO9IrtRZZCxcdoj+fKrRlekTfyxQhzcPaRE8VVNCHkEqqvIwTuGJx3puhQJgOvl3BckR6U8RJMYtkh025kHnilktGT2aXoF2bl+Ax8NgQJxwZJrmnEnmkXRv21Sd6meFGR3/HipNNvQkR1dYHtBIYZC4MAmPWl+iB5ewGpNu54YkkYwRj400Y12I529ELpQWi5Jm43rBx/BimTa0NVkhdW2QPEFvd2Ge3w5puba0TeN2Cv3L1uSpUAiZUkcnua132MotBdMzsR5j4gyDMwI9TQtGphrGmu3GubfvDkkj6U1/JrA3bF1CqttHwBYflRTTQyGLIKWUgEMRJ3ALSPopqyv1OmDai549+HB/wAUkERXRjl7UZ9masACBkwSRPBzTSHLCxcVGEmdp3EA4An/AJrmlFsFkdTqHbU2bVu4FRBtECOZmtjxqm5CN70MHTlPDZLoRLg3NnnvAHyoXZRaRaWwLqiCFKpAbfE5/wBUiVugN0rOnTnazPeQc/eYR+FPxJ8wadPD5VwRIOJ9PatTM5hl0VhEAa6wjA8p7/lQqQOQ14Gna8nh3riuiqrBTE8wYAMUsYuKoLny2O2+mWhLi7fLk4HE/hSyck6fQFTWuxpEWxaCh35jaWMmkavbCr8Fb9pbSajp9zzS6EOMcQcxPtNGFp3ZTG6aMBr9yXyLbDYVOD8a6oK1bO1SrQgVUEs6yyiJ4PNM76Q6a7BPZJIdTDCnUibQSzuGwqcSCfWlFLLpfi3tTatK0eIQpA5/k1LK0otvwND82i8vdP1tglXJMe2eTXHHLCRdqSEryX1Co2DOaquIlsWOmdmiJMzk0/1EkLxsPa0pLWwoJJnA+BpHkDxOt01nAa4SOccUv1a6NxKXqNoWm8o4/GunHO+xJR+BFjsVoIK9j2JFdK7JPoEBJtyy4ORzn+RTJkmg2VFtpxxntx+9Duwlx0E3/EcLLKfMQIyfXNJkaohkVO2aDw7l0BrnhgKYgiIj4Vy8kLdaGbflI23WmcnYBn2zTMR7JX7IKq1y673CBAg4g80iybG412KsnmQMnJPIn0xk8U6d9DL7nVuoGDgst5ZCjnHqT6mc1q8BsBggAlR7GTuPOf2pg2HtJ4VtNzDYDumfetdgaH7WpGDaZix/+gtLLQkYP5C2tY1646ahwABjwwD8p70Ute0LTQa4J0zPaAdyICFYM0ZOlcmaCbdUUmvOo/qm8O8qrAgBfYVbFuN0UlGnRRWwniJ95pJEAxNO32O6S0OmxcWDdVk3GDjJyZqDa8C9kNRYYMlxCzKZkAZxzWi/DFYe2lzWG0DbAUDA+6AOOTS6iMWmn03hoiJbUgf5XGVuc4ge1Tbt2FPQ9p9ImwNcZFPqp/WKLyUSqwlnTaaVAVDnJZzJxSvI2HiMratJkW7e7nkn8+a3Ji0HvO62maycgSBtjHxouqBFboMlxvElX3YmQZHFBxcjWokHYHarNuYNwcxnnipvQ8d7FdVcCqZ8pgjDH9RQi22NSMD1xAuv1S2j5F2/ASsx8MfiK68b9qOzHtWxK4VdQEUiCAWPcnj6ZrJfc6HJfAvfG4mD4Y/9R2AFNF0TydhAAGAEQff40LJj3Tbhs6q1cE7lcMPgCP2NSyK4uI0XTPsOo6amp04vqZ3DdIrwYzcdHV2Z3qPSCXYQQv8Ar/dXj6gHErB0oqwChiRwY/Oq/XBxGdLoiGAYT2yeKnLKNxDavp4NoYM4iJzSrLsFGM63pSl15EAMFAyJNehgyCyjoz94F4Rj5p5OK7oPyc8lqgElk5+6IOferLRF7D3QV2nbhRuI9BSRdhkqG+h6xbd25aYfeUhWjII7VssLpkZ7WjYaa0l5LZZrYLATnPpNcjkot0ScWy1taDSi0WuakpOBsYZ/OoSzSk6ihow47YK3oVLrF+6EUkkTmPQ1TtC86Z6504Pc/tF3UQAJnHuaZWlUvIrnfQa/obiMFvIB3AJnHyrRaltMN12ji9IXfuDOwAxt75oPLWrHjb8DlroDPawgVexu+X+Gud+q49sqsTl4Ftb0xrJIREQGADvVix59faqQzcqb2Z46tAtFpD4o8ypBBLFvwrp+oqJONlppAxnxXBFrMjj0/euXNPVItijTszuuV3vBy5BcbjJGfeu6DpUCS2UmltTd3MoJwSD2+nwqk5CFzZsm829XUNwIBEY9qixW6DLZDABrogNJgGPpR4E3OmMWLKMNu+fl785peJubDWNJpmXdeuEBT5ioJH7Us010NGd6O6m1OlY6dmtgxsPf4n8oriedt0jqhhS/MKX9U9jVWkvPCXNxjwtxEAAfjP4VSE+asEsSS0LWb+pdHv27jhZbcHzk5Ux68YoufF18jfTTSGNL1uxf0xs6lQNZLL92A2eQTxyKtTekSWFqVp6Gb+vS1a8Urb2IvmLOAQQOBiTUfqSvilsb6C8sHqOraf8AozfQO5UyyHy7SAGIJn5Yp7ldCrFsR1PVLd7UWdRpw5tKCptkxHrOcUr5KWwqGqMrr9T43UNY4BC3LkZOcDkV2wh7Y32dEHxXESa7c3bWk7nVue6iOaLjXRTlZ5CGIwcjAiaFUCTsbsWXubRwFIz8jU3KhaNB0bot7VuvlcWzPmjmuPNnUSsYH1boyumitWLgLFBE94AxXjZHbbRdIY1eiFxQPMQRkfCkUg0VbdLMqNvPI9Kf6hqGLPTfDG5hGY96VzZqB6zQ/wD4paIjnJ5n86XnsKRhPtdooBdVIuKN3EA9gPzr0PSZN0zSWjEaiybshRLx6fGvYxyo5pLkgbaaLLkIQcc/Imnjktk5QpBerWvDs2GBMsgkfp+NLgbcmgZElFMp/wC5bubhlgC8ye2a7GlJUzm2i4say812EeQ6j7rmOPz5+lczjSA4ot7D6t0X+6B6Q0xmueXFbEa8DvSdVqXv3dNJCqCzZgc/nSTailMfg5PiWWp+0Nuzp40FguMrFzDbpiSR2oKEpSuQiVaDdF6nZ6heN3XIwdREAkiJ5pM8ZwjxxuikEuVyVmtuWrYtkpdubztIWTn9q8nHKXKns7mvbrRVaoBdOL10XboJCqpuCZ+HpXbBK+KaX9CEm6tpgNJpFsh71yJCztnAB4/WnyZHJqKFiq2Jagsu8kFEJ2hR37TXZjVoRkdPeuJp3s2ratMqZ/xGRj8aM4JtNmi60iOrMaq74ZJSfKVYjEe1Vxp8QSqyrIt21V5yVAInvSKcnKmWniXG12OaW8HVdpSBzOOfzquzikqYe5/aXc6W8NAz7Uykkmybi26RHSaq0ni+JZXYIhh/v40kskbob6MqsbVRc8pOy2SSEiSQOJ9u9efnzSbaXR2YcCik32A1+riQDhVhQDB+NRgjoUa7FNIPFvsxgXbmNwInj/dUk6VeECiWnuzprll4G8tnjtz9aMo7sUzl1rf/AHW8XAaU2gE8fCu1X9NUL5YK1qwtm2NQbl3bJILkFSP5xTSi27iIutjdseLpr6KzbQ3zzI/Y1N+2SbM1Yj4z6a85YblA80//ALf5+NVcOao17K3e1yS5ksofHqef1rokqQ8FbJWk3srrgBYk4JM8fQUknWiqp7LDp2je4wVFLFsAAScnioZcqj2xlG+je9B+ybIFu62y5LCVtCI5HNeRm9dy9sGVWOuz6N0TpVnTIrXEVY5rzpZHJlKLh9ALTnYvlI7jvPFSlMKQG7pH3+UBhGDx3oRmzNI6uhLkErjtmjzAG/okBBKgnmSDn+etZswlf0qi2wcouZlvxJ/GlbtjGJ+2GiT+mUghAFKqJ5mM5OcV1enn7rCfLtVaVdYgtuNglw+2MivehL2WyDXupEvB/wD0ZrrnzloIkDvH6UVL/VpfAkvyOxHrNsSlsHIInM9v91fBLtkcnSRWskXV3f8Aq3M5x/uurlojQbpu0XCrsBbb7rEwAR2pMn2Bx0Xtnpt29t8C9acGJ/uAZB4iZ/CuZyS/MhWn0i30XQL99HR3Kt6gjPrzxUnlS6Fcfksrf2T/ALQX+8WAgGQBSPO+xdWP9P8AspcsBd20qoyTciR71z5fVX5L48bfg0OsFrTae2uqvsUiFW027HFceOLcriXk+Kp6M3vd9VevFCLQVtkmTA/euykopIi+w+lvBbBe4d9y5LEESvp+FFwuWujXoq9c/iXJtyybgAJ5AArtwritkpO9heloltA10gbnIMjt2/Wlzybeh4L5K3X3ybwCFSAvcA+/611YoJx2TnJp6BIouIjFVI2rPuRArkm6k/6np464pMm9lNzumGJABHFBZZKjTwwlYK7rLjofGRG2lR3B9fWqKXcfk5JenSakn0S6YGfT7blsNuMQB25/MikzNRdpghCy0cgBFAJMGf564rhW9s6+KiDfR+Jd8MtLOREkAD39h3o86V0LXyF0nT0063WsleR5+FE8QOTxSzyOTSkCvgR17Wk0jeCu3aCT3wI/cE1bHblsVqkZwWp1Q5KQGMexrucqiSoF1xTb1O7aMiH9zyT/AD0o+ndxoWfyM6YkdOuJMBnkwe22M/Wln+exkrRUdRVrYAbIYs3MTmunC1JtoVxaWxe3I2gcqomTjvVJjQ+w9o7Tv5BkKTMdq58rUNnRBN6Pp3/T3olu+hvmFYmFBHaa+f8AXZ25cUdUYqKPqug6aqhdwB7mRJrzwPZbppRtBA8wMg+n1pE/JqCf04e0rAEBRgKYHyFJdjdAbun23JYACt0YnbtbSpVWj/2jBzimTBRG/bhgAuRn+Gg3syRT64BVYKOZ4Gf5zQYaPnn28Vrek8QmN1sIDH3STkfSM13ekaeRILXtZ841enFu4vjhmCkjaB8Mf8V7MJ2qiTca2w2sup/2zTbVgk8Dt5jE/Whji+bEyPRnup3i2rIkGWMY9IH6V6GGNROXI/dQJoPmPAUKMdyKdMFaBvbOxSV2q5kCOKdSVma0WvTdcANpm2wAnMSfX+etc+TG+ybjRpOldW1Nh2RLlzzKyncxzNcOTGpKwXTpH0jT6y1c0tprKS5UBnVSQxj1rznFsraiwXULOsaLiW9sCQCIVvjRio65DuV9FddS4bI8NA2zJJEwfjTqUeVtiOLqqFb07ShRVUAfeWNxnsaonW0LXyATS3r63EtgMCGUACIz2ro+pGFNicW+jidOKNtNtnbcIEc/D8ar9dPaYFBiQVXvWFYIqWwznE8kYp/Da8hSvTFNRbN0pdIA8QFvL6FjE11w1FJEpbdshZbZ03TE5ISZGCASf2FcM03ll+p6EekzwZzZDQAm7PfjtSSSUq8lU9bO2dOj6e7u+4qrtURyQKSU3GWvv/kWKu7O9JdRcS2YCMwUH0x3o5k2gJU7RcLoo1LBwQFWY4354rl+prRmDtaNBqbcMxLASM4E5+taWR8WmKlbPXUfTm/bFzcA26CIgREfKlTUqY9Gfu2QUuLebhiuT94GD+ldcZ9NIWUfkVFlHvIiBk2nazgTjmPjVeTUW3snKvBHqFk3be25/wCRpaSePejjnxdgcLVAxbt6fT3FDeUANvYR3H4U1ynK0GMFFGd119b94m2ZRTtBnme/516GGDhHfZGclJ66J6e07uoESQBjtmhOairKY43o1HR9CzXPDTCkQ7xPPrXlepzatnfjhWkfcPsb05LGiUL90qNoH7+tfPZJ8pWx590bCzYhgwYTET3GanYg6qoBEj0rPRgLs7EqoxnkcUtvwEE6f3gWGCIBNK+woOtvbOJHxqiFFNRzE8doEE0H2Ep+qKNojaIMn/isjHzv7Zalbdt0ugNbK7eBJJE9/YV1+mg3K0OvufNr997mkt5LXATAzK49a9uMEpP4JN6I6oi30qyC242oBiB3B/angrm2Rn0Ze4394kSSpg555Neko+0479w7pdO95tgMIJMk4JipTmolYK0Wer6Ve8gVfLtAEsfwx7VCHqEUlDwVuq01zSXhdYLE8Azj0rphNTVIlOLTtlt0bWJcvi3G8GBBaPz4rm9RjaViRj47Nh0/W32K6WyElJM3LhKLHeeD6V58o0rsPtb92y30Gq1d4XXtDSlQQFUWx5vXOam26WzOML6HjqtSmluas3tMpC+S0bXmOeJj51BpSaTKJKPQpptZqtdZLt4SnuRaHPaT6VRwhjdICcpLYV9XasFltlyqDz3ydqg+1VjjlOn8+BeSuhO+2pfU3WRrplSEEnA+HwmuiCgo7Elfgr9WlsDwSVS2p2kzm5Mft+FWi3dgS0V+u/pA1rfcElAYCkgZOBVMf1GtIEuKfYDRoU0to3BAa3hvX+CpZHc3Xyd0VUEDe/cW06WwVEBRgZOcRRaTdsEk6pHUvJa0zqTJ5AjsBUpRbkZMT014NZcEzlW4/AVeUaFUjX2utLqNZpLN9EFm4q23LEgq0Zafc/nXlz9M4qUo9oppKi4axbuFrtkAEwJLCOc5/wCeK5ItrTBaEL2mVXfdcTaxAJ3c9oqibaA5UUfU9OBd8QM11FYMBHcnED2roxS1QJOxCyyu8sGzPlbgese9dEvahYptinWb6WtrEhVUgz61TBCU3SHlUNsyWv1V3W6h4ZhaaPL6kjivXxYo4oo45zc3SBWkCFhtluB6Azii3ezJUaj7MdOOpuAldzPgCfl/v5V5nrc3HR34I6s+g6DolzUPaXTKbl12BdzgMPL34H6V4WTNumdkaStn1zpWjNq1IAOSxIJjOf58686/BN7LayBMGRnsee9MmKGIG7blvefrTUAE6s8QBjn1oUawZtlXAgfHk4rSWkFBXI2kMIPE1rMIalWUEg8dzWfZkUvUFYad9wJB4HOKxj5n9sQDrVJVWYW8ZkKc+uOK7PS9FDEasqCLVtG2M4bzjPqa9TFb22Jk0hXVLd1Wm/p7K83CSxMAcSSe3FdEGoS5SZySuSpEunfZa6VZvCu3S/mATyiJ/wDc/pRy+uj0nX8+BY4Gi+03SdZpgWs2dBoUUxm4Cwj3rjnnhN7bkWUGutC3UOnIqeLqupB3MDyWi0T7k8fKqwzP8sYgcfLZntfpdGdzL1J8Z81ofpXfiyZE/wAn9yE0muykFq5buHwWFwqIlDBx7V2WmvdoirvRd9K6+9hgt6bb/d8UYx6MDXJm9Ffuh+3+w8cqepmu0n2gvIQot6FgCBG1bZIIwMCPwrz3jrWykscXtmi6T17T6lyr6CxYInaFdWn8s/Wpyxpbf+BHifgsDrtGqlXslhJYKE2yPXmkULdxAk2tsd0ut6be04ewVZGwyskgfL2oSxyX5tM249bQd/6NLbujW9pO4EYke3wqXCXVlOa7aKPqfTf6k+IipcwGUoZnHM/PFdGPI8Wnozqa0ZvW9I1/jZRFwMNGK9PBnx8DmnilfRSaGbiWkYKTs5PIE1syqTZ243cUWF23bCqqkuAMk1ycn2ynEg+jF6yTkFFI8ogfP8qX6jixVFPoCtmzYZkt+H4hj3kYxAp+cpb8AUAGtVnOxAoIIEjuRNUhKtszjfQ30u5f0O1rV02mAz3XnMjvxS5YxyOmjVo0n9ZbvW01F0CbiAhdpJWe5j515jxyjJxXj9Bq1Yta041Kkaa5b2kHaynjOR7c0HNwfuGcUyt6nY/o9O9y8NiqhmTnjJ9vjXRil9SSUQUo7Z8+6hq7us1PiFvJwme3r8TX0ODDHHGkcGXK5MjbUAnaVG0cjj4D6UZMWKOBDcvLbQzJ496VulyY6VukfWfsD01HthwwAI2SIk+3tXzXr8rbo9PGqR9Y6T05VuN4VnwbYUSezN6578TXjylsdvWzRW7QVioBjcdswO/rSL4EZNoDAgnn71MAlukRj1pzBkCkgkSwBIHrTAOPagnn5mg4mTIlVLDGD6n3/wCKNIwrqLflwQDnn2qbQUZvql1ip8QnaAYkiaCboZI+YfaHxNTqhdLSjy62lfbwYE/KK9D09RVDvRmrvTEtkXNRcZGMByBIAHYHtz8a9GOV9ROedPstumad2c2undNZ3USHNuQo7STgT8Khkl5nI2l0X7aJkteJ1jqCWS4MoGDuO8COK5uSuoIOyv1/VuhaS94dm2LjLyxgs2c+pq8MOWasW0ig6h9rdykaPp+nQHAd4Zhj5mu2Hor/ADSJuaXRnOo9e1l22YvWhuPZTGR8K7cXpYJ7RGeR+DO3rlwsQ5R8TIwSc/D1r0IxRztsggGoSASGnv3MVR+3aF/NpjvTtTsdbOpKqsgBiT5R6H8Khmx2ucSuOde1mjR0NkDTqA0yWjmcfSuKt+46lHWhkdVvIhW4Uc7uXBPp/IowxpPRKcWy66a2q16G304p4YP9xbRAaPhUcnGLvJ2TkpV9jQ/0GrYi3de3bIXYzEzAjj8q5rS2kCTT0hz+kSxi5dZ0XaBxAUfOp+99IflB9imvWyuoKxeMDsZ/Wur0/Jw91E8n078mA6YqhlJySpwTA5iu31Dd0dWCuNlpdAtSQxB5J/CB9a4G+RcH/VsFIXzPzxxih9NeQOTR21ZlwbuHHm3OIg8QKDl4RlF1bGbtktZLWcwBJZeO0+3Hak5W6YXohZ0RJXyEjbIB8q/zmmllS8i/cbTSanUEjZdaQJW2pAj09BXO8kItNNf1DfyhzSdMfR3hcuxprYG1U/yY9yf2qMsymuK9zDTZkvt71lNUw0OmYstuN5HHwnvXrfhvpJY19SaOfPkX5UYpiX85YSx44ivYOL7jLAi0zLhRgGMVG7dFEtWG6ZZJvW2Y7RG74CalmlppFcSp2z6R9jupnp2ssjUS1gg7h/6f/UV4PrMP1Fyj2d0HXtPuXS+oabVaVXR0If8AyU4/KvBlFxdD2XE7rRZtozDfwUX8oURa4VOwSWLTHt6VSO0gNjmkRnIEwT5o9vb8KD7MPr91GWDief3/AHqnexSbIMjA5GJxTNATAMiqQDtDEce1LQbFtTs2Qvfjila2MjKdde3akEz5cebj0mkUHJ0NdHzvrOoQXdulFu5eIzdJAAHxnAnt9a9HDjpbElOyjS9oNITe1Fw3n7KFhZ7kflgV1OOSS4xEvdsR6r9ub8Pb00BYAUAkKB8Kth/Dk9yEllSMxreoa/W3Dcv3H8EgwzEIo+vNd8cGPHpLf7k/qSkVjXHB2rqkU7p8iSPqf2rpjFd8STk/krrl2TN687zhRvz+FdCj8Ii5fLAM6mSHuDiOTOCapTE5L5JI8sp8VzJAEnBFGvsLy+5O0OCwMDB9OMUQ8r7DEsyAN5sQDMkex+v4UqVFL8lz0jVtesi3cAZlHlaYJA7fKuTLh4vmujsx5uftfZZDxNoDLuSe/NRtFOMl2StpZDYdrThvKVGflTNyr5QnGLfwa7o/2h1Whuhuo+Lq7ERvS4dwxGR3rz83pYZF7Pax/fHxZoL32i0+pEadEa2RywQT8QfjXPH0Sxv3N/3IuWWW1EFptSvhklXyT90pFdeOUYxq/wDJz5PT5m7UT5ZZuta1gdCYIK+m7PMdq9XLBONMpik07NCLlt9zu3ilpmD7ivHkmutHpximO6GwlpCX+65BKjJ+tQnNyfFeCn00lbH7Nu3pn8S7aRi3mAImM8k/ziotuTpMygmjmq1txvDt22XaxyFQH4VoYY7bBwgtB11d/TOQ91u8wBPuPWi8MZq0iUqi+gWo61qSHUXWCsNu0kfM5pF6WKdg5fYxP2l69fa42mt3rhcAm65JJH/z/P0r2vRejjFc2v0/3Ob1GXfFMzTSltmdjuyciY/hzXovbo5OgGlsm7etKcIBye1NN0mxI7Y5eXxWFu0pgnEfia517VyZXvRb6HTEX0BjaBAn1HJ+uPlXJOWisTQhxaS3CDfENIxGIk/GR8jXE42XUvDLXS9VvaV1fQX209yfMN0j1yPgPxrmngjL8ysrGT8mt0P2+1ektx1KwLgH+VpozPcGuOXo1J+xj1qy66N9rtBqtQz3tQLbu0gXBEDtmpz9POKqhTc6HqmgvWAbWosmMYec1zSi12YcXU2pHhXUP+OGyRHv/OfWmiwNE1vCVZ2QZ3CDgA0b8AoX1GphIBGOwHMZ459aDbugpIznXOv2NEjKLieKARCgTxwINaEJSYej5l1br97WanwijOfNFtT933Y8V348CirJuRi/tB1dkARr/mAwEiT7e/4CvS9PgvdEpTpGZuXLjsXvOVBI/wAiWPxr0IwS6IymKvdFiyWRZaRDOMAniBVuHLsk5UJag3tRqtzl3O45YyB2/WrRjGK1onJt9nT0/wAIlbgEwGAifSPhIzR+rfQOHyC1OkRHubViHAGPejGdpWBx2LGRIDEMCVkYjn96ohaJWVlRtXjzRHbtFFsFDVn7rKw+8ZI9cUGNH4C2SBkA7GmQe+R/qlasePtY3oB4V6QzJuE7gJg/Cg/cqHi+Ls1SKHFp7K7bbc7QTB4x868mftuL20exBKaUo6sNc0ihWhQ0DsM80I5N/AJYtdHbHOwMysp4OR/qqtWrIrTromd2lui8AFYjzSJVvamSjk9rFdw2v+P6lrp9Zau6e3cuXrlosMJ4cxn1+M0iw8Ndgnn5u1ow12/t1Nu4QSFB78H4/CvRlC1RxwnTvsuOi39PfQ2kDCebcQV9DXkephKLtnr4MkJR9ui+LMAq+ef8WjiuLirZW1SQ25GpsqmrQo6iN6mQfkal/wCt3Df6g4tC66Qk27iXEJC8t5Sc96eWa9NC1TG30l24yswBc58hmflU1mS0hZK+xHquh12lsPqX0OqG0fe2+WZ+Hwq+LJjnJRUkSaaTaPm9pN2rv3WU4JPmH1r6PXFRR5v/ANWyZUeHcJOWOGmeQaK7Edg7KqiBlncxgSZ5+XtWlsCdDmktFtYpWJnBPE+tc2WS4loLZf6e6tsNsWAh2qIiYGCfXn//AKNcEk29lER1OrFtbV64wkHcYMx2A+MT8z7Vo4+TaQ3JJWT0dy8LK3rqhTcO53OSO8A88Qfn8aXIo3xXgaLfY9pbrai7cdWGxH2LPmBMT8s471GcVFJFOdsskKlQLlsQFDGYlfie0EgR71Nr4CmgyXbUq1q49okgAqxAJkf7pJQvtDKT8Ddnq2rsNNrW31HBhg3NReGL8D2OJ9qup2yR/WSpUAb0ngdqL9NB9IW/kJqPtb1M2S126kN7Bce5nj86H/ixbEeRLSRQdS6ibVkXtXq7is4lUKw7j/8AiPxq8MNuoom8hm7usuahWuam9/SaKSQqgkt8B/kfc11xxKOoq2I5v9DM9R6pYS8w0WnZAT99jvuN869DF6eTXvf+xzzyJdFe117zs4wTmD3xkmutQUSLk2F0trdeJcHauSRn4frU8k6VBitl9pNHb3C/dAI3b2b/AORgAe5rkyZP/lFVHyJ3m8QXbrZLviB/PWqpcaiB7Eda+65qBP8AkCDHuarBaTEaKwjzzLQRBg810JiNHrDEL68kfz5UWKEtQbgEDI+MxWfQY9jFokdoMZjv70KGutMZSUaFUt25oJbsLeqLrR6u4NPDT2BE4x3rlz405KR2+nytRcfgsH1xu6Uh7e3cCdyZk/D5VzRwpS0zqllbjtHdHd8W4ZdCewPr8O1UnHiroSElLVlt1Gw1/SWnVYBAHOQfSKhgyJZKbKZoXDSFLKuLSk3razMDxAO8cHjivRS+DypySdMz91ZYFlABE7fUelObsQ0WpdNfbcP4ckgkehHFTy404NUdOHJxmmarS624zgi6QSJkE5+FeVkxJaaPVjJNWW2n6heIcEHgeb/mZrkyYojpJ9oL/XqVB28+luD+FR+k1/2NxiQ/7r90Km+DEE+n+6dYPLZKUV4E+udYY6FrXgIpJzE5+NdPpfTx+pdnPmTjGzFm4AMFZIjk8xXupHkybIllCf5FQMY5EUUKyIjwlLbokUJMyGulBt7kQAVxPuSPlXPnrorDqx6/qg+uUKGCKIJI4FcqjUbHF9XqBqNZbRVmzbycwD6/U4+dUhHjBt9sDduidzVMFNhXbcTDEiRtncY+NBQV8guXguun3FRHJLNdnfMQCxwPxmubIrY6ZZtcUqLajyyQG5wIVSfQ5dviahFPt/z+aQ7fgiLihQpkb1WfaWwDPsJ+QrO7sK2AfUIbs7l+6xViYEDE/wAzRUdBvYD+qZrqW1Zi427ggILGDj4nGf0qiglsSUn1Yb+quB9wVLl7BdifJaXjk/nz6DvS0v6f5EKLqWusG8He61+4cT90T7dyfeurHjk1VUI5JGe1+sa6dx3ERtye36V248aiQlJsrss8KpBJ7d66NJbJbLDQWQzAPjknueP9VLJOlopGI9aX+0shlLmYngR+351zt7spQ9r9RNtdLYJBLBnkcETgfAfianjjvmwyfgWvIEtWbarucySAPkKdO22wPoMPs9eNu9e191dIgK+QkNcbnAA47c1N+sjqMFf+B/pPuWhS70vRrfNuyLzW1+/dd/N2zAxE08fUTq29/APoqxe9orQs27NvYH8Kd/EvMmT3GYHwq0czvk/n+wrxeEK6ewUuG5ddggJWAuf5H6VdztaEUalsixm5lYMbfN6djPensWrGUJclW47+1azJFl0ohtZaR8JeBUA+p4/KufP/AOtteDqwNLJvyi5fTFbTOAyqhAHfmuKGRN0dskkrsIbAFxtwBwZEQTFGGR1o01HtnHuBrCBWuFlXcfMSBngCuiCpnLOV+SemaLQN3R3bjNmVcAD8DTvj8kvd8FP4oJdSjMQSsTEZ9as0xFKKRXG2TqGbb58gA8Ce9ZvVGTd2aWzZurprJDeXwxEGScCvKySTk6PYhy4r+g/Z011yl1EZ1USQTE/OpSa6YeTQErdLRdUqvZVPGe/40qpdDttrYRptIIBUnAIOeZpNyDpFR1bU2Xssiq7kHLE4+HvXbgxTUuT6OXNmjTj5KIqN6qSAoycV6S6PKk7YB7rLdYwcHn0/anS1Qnk5ausQUYmSYmKSXyMix6dd2G424/eUebg4J/aufKrKRejrMCdRcIMwFWTyef8A+JqbjpIKZDpz7tQXYAAEsfgB+8Uci9tGXYQXFV5I3MTPf1/ahxdGst9NqDY0+/aoad0xPAgfiSa55R5SoZMaTVkWEQZbcqkzg9z9Sak4bsdP5I3dU7ByG/8ALdOR2AkY+lZQ3+geWhK3ce5cPG4CEQ9gDyaq1xQt2MvcFnTCzbYBmEPcMyB/OfpSJcnbA2Vuua7ctBV3pYUnzHEmYk+p/wCKtCKT32I3oor9zIUcj/KPl+ldkY/JFsSuXXYlRIx2GPhVkqEeyekUZYwOy+3qaWb8DJD1i4FTccQxZhHIHb8hUZW3oeNHV1J89wnyruPr5j/BQ4VpGu9h9EDe8W48sx8qDuWJOPpS5JcaSGirZc9KZnup4drffyAedoj+En3rkzdO3orBfHY3qLvnUFWvXmIJ42j4nv8AlUYrT8IrVfcr1sax9VeG5gNxB2nEe5/WqucFFAqTdiD3D5h5HKmQ4eeexNdUItiSddlVf1Za4yqQQQQSBGDjFdsI0jknK2esLPlMgDPrgftRkLHbC2t/iIHAngDtWVDttMYt3TbVT3Uhh3zQcE9DKdGr0nWbD2DvsqGK7nEEZH+5ry5+jyKWn+h6cM2KUVZPX66ze8BrLKAGYnGab0+Ccb5C5pY60xXS3QHtSRtK4aY78fjXZGNnLLQ8l7w7VvzJBEiWg+n6Vz5Iyb9peHCvcVSWyoQE8cSMVVuznSO9O6edT1RrLBwqyzNAkCPz7fGky5eGPkGKuVG4XSmbRtmdg2qpwB2ivGk41TR2rLPwxo6dlDJCEyfvAfhFTTiZ5Mj8kBpFZ1R7NoweIiKLku0zLJkXkFrdJpQjpd09scBDmQPStCTu0wvJkfbMH1YaW0q2raJKkFoMzjj5Ga9zC5v3SODI/CKZm/xIDM3piB/PyrqWyLFwhN08GQMGI9KdsVA7PmchomY5iaEkFMatsQX2kkbpn3ipyiFM8x3WXyBvbv8AA0lbCEtEJZvkDIgZ/ntSS20hgRc+MoTAKiPjxT1rYB+5c8S5tbCKZM9gKglSsayaXDb5jJ3/AEGAKDVhPC6XZVUiQC2B3yf1oca2GxtANNaKnNw5uEHHOFqbuTCdaLdjffH91vN4PBj39KK9z9vQrKPX6u9eujex2rEEcZ9K64QUeibYhcYW0CnbvIniqR2I9AFWOBk+UVQUKSCQABAG35+vzpN9jBLrbdOEBJZjvgDt2H6/OlSt2G9C9lC9yBhRDcc8UZaVgiX1u0bGkt2zksNzHjk5HxwM1xN8pNnRFVouungIsqB5gwMDMkA8VzZdvZeOj3jph9hchsBew7E+uaHF9G12Umu6mLNx/GuvdY/4twvtiuzF6fmlSpE55VD7sz1y/c1D3Q1zbJDbRA/nNejGCiqRxym5OzyIgYBPUifxphA1tyt1X8uGH48ig1aoKdMtTYMEwJtRjGByDUVNJ/qWcbX6HBbBdgGBAEg/jTqTFaT0WvS9Gmps3iVhwRIJ7H/c1z58rhJb0dOFJxqizuaBfBt+HaUtay0iZ9RNRhnfK2+yk9xqhXTSWAgrIJJIgTJ5rqW9nNJvpEblu55dqDaJjbbxyaDr5DykOXum6t7okww+8sAj+YrnlmxxSZRY5tl70jRDQ6e4zuDdf7zDIIHArzc+b6jrwXjDiWqPvtD70SGMGudoemFN7YUIALHgc0nEIV7irabxWud1gNAGP5xU9t0hin+0HU10vSb1wFWuuQlsAyRPf2gV0+mwfUyJPoXJLhFtHzV97sWJJYc45JM19DpaPNt9gzbm5vBG0DkDvTr4EfyeIILgJOIyvNFtBSOBba7yZG7gCt9gNeSSkMrhI5BwKWWgxBBgthgcAH4ZpGthCqSdORiWPYfAVN/mG8AbQB1qiIg8R2FPL8gPI7acm62JnykfialJaGB33LuWIBY5IjijFUYc0AIuNcaIkgepqWSugoZ8TwbQuHN1siR9339z2qVcnQ3RXvcN6ZYiee8mrxXHoRil8hMjEfcB7+9Vir0KyreWubvp710JUqJvZMPB34gfdx3NK14MRtgFoJwo3NTMBIvue6SOe3p3oJUBstNGmxFuvAREJgDJMY/HNc+SV+1FYKtlgB4SAsGD7BHtiua+To6EuKGtLqP6fSjcQGblo4J9alOHOWh06Wyl6p1E2N9rTck8znI+ldeLDyVyJTyU6RRNJDloJ9Oe9dqdaOdq9nhCuZkYgxiMcfWimZoMFE8wJ/WmEYUGZmPcEe9YUudOVe1bbzNuAQzXNNU2dMXaREpseVIgCYGMVRMR6LPoj7dctolj4i7QYkbhkVz+qXsb+C2H81fJpdIotlMtkMG759YrzZOzsohc6axZH0yhbe1iAREE+vtVcXqktSJzwt9Ak0TbAu2+QvG0CADnv8aaWdPdoKhQt1PXXBqLfnbt/iB29J/Cup4Y10cscshFNfqJM3mPcwOPpU5YYfBT6khrSavUCE8a9Puv+6nLHDukbnIZ/qrttApa60ACNhkfKp8IvwNykDv9ZddPdPi3CFMSV4xjvWj6dOXRvqNLsz3Utbd1RU3WkTG05PFd+LEoflITm5diTOy3VCHv2/GrJeSbGUKxbUrCkdyTJqcnJWMkieot+aQ4aRPHNLGY7QjfQkOxIIngDNWjJWTlEjbbYHIPJkj5/wC6MlYsQd1gVZiBE5z3pUthD2iCbSvng/hNSl5oZALbMLxZee84qjWtg8jSP5n5hQecdo5qTXQT1n+6wgncrcAdqz0EeQkuqW5hBlucfz86g+rYyIuwIG8kDMD2/k0VrozA8jgBQcnufYfrToVlbr7niXYByOw9K6McaVk5MUaQqkHkHkVTyAGx8gWccH40AMmWCAjEgEtPfNGr2C6PWzuAGDLZgRmiwFrahwt2NwXaqj1Ocke1ckte0tH5JanV3L117rsCIgY7UkcaSpFXNt2xG9q5Cg42kAKa6I4/gm5/IjfuG42TkkiPT/mqpJCW2EVSNOCFg8QPgf1pbuVFKqJALuUs2Cfb2pm6FSsNM4BPI+96U6JyCK53zAI2/wDriiIP27xQEbhIC8dualJWUjKj39QdxUEj/wCo4FFRA5WFtXnW+LgJVwQwkc5ouKaphUmnaLNtfdO1FZTuiY9v4Kh9GN2W+tKgum1d9mE3SRECfjS/SiukH6kmTW9qWnwrj7QYwSKH04/Bnkl8jXUgovrKTnmY7UG20CMULrbUFQwGeB6VNtsdIJZILIu5eY3CP2qcrDojq7yWVWb8gD7wgk+mO9aEXJ6QG6KfV3vGuLtXw03cMZYk/DArqhHiqEbsWS0xtyziJ9eKpdvSFejqWIO4yQ2Z4+lM2xUN2UJthd7x/wDAHNc0nvoskHayMBnubSImZH5UnJ/YNFfqECsxLj5mavGViNCxYC8oY8jgU92heOxM3v7lxNgzmZ9KdLyK+6JW7hN4bBwCQJ9aDjo1hNOCSWH3tue9CRvIRCfDljn9M0jVsYZ0Vz+0bhjjipzW6ChizItsWAgmdp/yP7VN9jHllpuXCRJyR3+H8xQ60gsr9Tf3EqkBFzg10QjW2SbE58xPfAGe3FWEI7dzIDwv8/SszAbhgKZ5IJ/nzNFCsg+4spGABAH4/WmWhQlryqrt34HzzSv4Ciy02NOHL+TBCxzA/euWf5qLRK65qju22pz/AJTGK6I49e4Vz8IGig3YLCTJk9+cU/6C/qetoXeSQW96DdFIxJ+ZDBMgKDHvk0i2O1RAzySYPaKcVhPKFX0DQI+VMmJJBVO4SDjg+8xTEh1VLkgERA/D9Oak3TKJWjtsGeV9h60wtE0XbcXxIIEe2PasEethmtgCOMxU5tLsrCLY9pbN1RnykzJImADUuUSvFjenDBW3Xxlj/j/uk5peDODfk71K41y+kZA57waDpAjYoXZMKIE/SloLI6zUPp7ClE3XCcK2APc/zvRxw5vfQsnSKm433WuvvukZ9h+me1dK+F0I/kKqXE0y3ntkq7lV8vMRxWf2AiV5We4oC2wu0AhRtE8SR+tK5VthUG+glpfIpPlFv7oEmkeRvQ6xpBra2AzgSvIBMj+c1KUpaKKIVvAcsLWpckCGYGAPhSXJVaNRV3TfvK5NoXQRAcx2/PFWXGL7oWrE7m5bm4g7SIYAZX+RVE7QrVCdwEXpIMHOfarLok+zoDAo64Bgz3rP4NXkLYeLbKAF5AB/Cg15MSktdYRCjAA/Kl6QRywodlQzsEFv2qUrWxkP3V22i7iF7H1+FRTt6GK3U32cRwuQB7d/1q0YUK2V93iBIXj51eKJs4ASYAwfzogPXSQoOInAFZGA3Fb0kj+CmQrIEgbSJA5mPasAkFYMiAeZSIHcd6F6sxLU3h4RCTtPlEelJGG9jctCLM0tBG329K6KJ2FtjcVBEH4UjZWKGmWLhA5JnA9f+fxqdtluKXQByQVIyCqgmPamihJWjm6cwwJgZPNNTFsmuUg5WTS3QaGLBhwDGSOe1UfRKt0WG07iPX1z3qS2O3VkV8tyB6x68U4rCr2YQD37j6UAlhp7e4gbzjEAmWqc35KY7+R/TI67QGO7zZZj5RUZUWV0EW5cEnaSSZMA1PgHkMalCruR96klLZoRdFZqCWHn8qISzGYx3NNHul2zNPsr/Ea8LmovmAT90nAAwAPh6101xqMSPe2RtKGO50YE8DEQDii3xVApyYPxghcpg4m4WOI/2OKHC+x40gmnvm2vnRNoyHvSCRk4A5mklj5dP9v5oopVv/Ivd1yKGDsPNnbbaMVSOF6ElkRy3d09yU/uTjkkTQamt6F5RPPfsoy7WnJ8u6TQ+nNrYynFdHjqC94kZXkKBGZoPGkjKTbB3HlSznJOI7Gso7pBtdsQBaAoznP1/wB10JEWMbh4ITggY+dIluxm9UCbbByPrPemoUNpUZgYIOCSTgHFJJpBRbWtlgM2LlzdJbsPlXNK5MfSAaq4bpcu5wODTRjx6A2JEbjJ4zA9KuAWIJBJbEmJ9f4Kb7CHkO1QeSo4ogOXD5x6z+lBIDOTBM9xgnimoDAnmJ45j8KYUPauSb1wjJO1ZPMjNTa6QfuKXzKhfYH408UBsHEH4UwUMWgACz8dqnItHQyhYtA2wYJBqTRZHrKk3EkzjiML6YoS0jJfci6AWyrIpE4gftTp7ElFC6naCCDknd7SKo1ZJPiHtkxCwuIPt/qmQklQ8bzGFufP6c0vEPLwyM7iTndJxHzrUCxlCN68EAzgVqCWGjceNbBUsJI/GpZFplcemWvhjxkICf5f5H61BPTLNdFpobHi2SzFQwYgiCYpNAdiPWS39TcfufNCjuTSr4Y66szOvunZDkwzCfeMkx9K68cVdkZt1R603iMiPA2knaD74n0p6roVu+yep1DZIhRIjvtz+NJGCsaTdUK27W20107Z4QEEjfOTHcgHHvWlK5KK/iHjGo2WOm6SHLLqlv39YcrpwNzkerAGFHxNQyera/JSj8+P6fP9B44Ivc7b+P5/+hj0O9pt7Xm0mhQ+bYCLr/hgVzv1kZ1Scv7IssDW9L+5xbGiVCq6u9cuYPmhU/I1nkyt3xSX7sDxw6bF9R02/et+IumFxBJ3pdBPf2FVj6hRdcqf6CvDy8X/AFKp5014jzFTytwQR657967E1kV/4OWUXjZ2+26biQBtkluTj0pUq9rDd7QlEloERmrLom+yUkAEwZyP586NGIqCMkQI79qVs1Dli4LaAH7kYAxmam1bCG8Qu2YI5zSVQbBlkjLYo0zAbtyQOPiTVEgAGLE8DJk0wpC6xAED0j40UgMgklVBgzzPb+RRFJXGKiCMRgUFsDFy0wOT3pxSb3CrKgiBzHqaVK9h6BMZMe8TOYpkKzoYnAUetZryMgttWYwVlsjHJxU5Otl4K3QS4mwjdA9gZ78fnSp2O4k7NwWjwhYc+IJn5DtSyi2Muuz17UbyvmOMkcAZ7CjGFCyleha4W3uDmTkRmqpaIth9OwJEwyg5rPQE70MyHvFJTBMS3aayvsD+AgDK7SMzExE1jBRcKpPPxOTiiYb0WoAvWnzKsDBxU5QtNFISppmhtXkZlyFMsDjExxXJT3Z1a8Fj03xf6cm3cdQWM7RIJGP0o6RGVtlV1m9/dY9y0g/LP50uONlJOkZ3V7l1m1zhQDjt/MV2Y9xtEJalTOEgLAIAAPmNGjWC1LkMNglnGB655/KslYW6LnTBUdbhVjasf2rcEAm5yzT7E8+9efO9rzLb/Twv6nZCv2/yWXTdRse4rLs0gHiXLYP3yOM959/fFc2aFpO/d0i0XQGzodd1zV+IqvbsMcY+8T6esepwBWllxelhXb/n8+4HyyP4Qzd0SdPuLb0dmzqW2y1+5fS2gP8A+45PyAqccrzJuba+yTb/AG/7C4cOlYDWLq7XTyb+ts6fTSFVbNslWPoC0E/SqQeOU/bBt/d/7f7galW3RW3+i9SuFYDguu5EvrtciOQokgfGK6I+swR/46/cm8M5ef3KO7bbTuyF0O7ytHAr0ItZEnRxyjwbVg0tbc3SVPafrP50b+BEvk4hVAGlJxAJ71pX0FBbKC1c3Oe/I7UknekYhetjdCng+XaeBRi9bA1sk1z/ABMj1/1WUTAi7+XmeZHtTUayO4Rn09KNGsiJBEelGhbORM4xzmsA4DAieRETn1/Wh2ABduegnMmnSFZy00EtEAUWgHmli0zWAQuAbSSY25+OP9VjB0siV8TyCO3JyaRy+CkY/JJy9ufDGwERzP1pavsqm10SA3qFLgD/AOV5rdbobb1Z42EUmXu/Hb/uhyb8IPFLyDQBsFscYFNbXgV0yWyA4hjDTIoqQjictNtImYEDinqyQdBNxQOCABI4NAIYqULW13AgEENj/ihYaC22NxdrMBskr6ZyYooDDIQrMFC44xx7/lQMi10l4uyyQCTMAc44/wBVFxLcqo0vRb0aQqFRirkEkfCufJCTY6mkil62y2b5P3o8xDCOeBWwpzKSajsoHltRJ+9iTXalSOZ7ZJomJjaZII59qDMhUAtrpclkknJ9BNGWoaDHctl7pVtvcs2vEVFVQTOdzMwMD5n6CvPm2k5V/EdkfCNL4GnPhpfti55WvNP3QsHJAwABJj3NeVzm7cX9jpdIj1LrpudOs6XpSXrbapF8V2g3LgIwgA+4o7KPXJpsXpEpueZ3x6+P1+7+5uWtCel6fb6TpRrtZtF1v/DvM+IeCV/+R/7DngHvVZ5nnl9OHXn7f8/bx2/gCXFWHtXbjNptZaW5qNbqjs0pvAK91piUAxbtLyeJMySAaWcYpOD1GO5V0v1+ZP8At8GTff8AP+gty1uuL0fpmoa/rtTP9drgZLHloPp+eKSGk/U5lUY/lj/g0m/yRe35NF9lvsTo9QPuFdMg2XL4T+5eYcqjf4qDEkc1zep/EMl2+/jwv1XyaGKK6PoGh+zXSNFbB0nTtIhCfe8MMT8WMk15k/UZZ/mk/wByqhFeBPqfQ9LqFYXtLp2BmQbKn9KOPNKO03+4zSfgw/WP+n/TtSWOmtf0V0/5WRifdeK9TD+KZYfmfJff/chP00JdaMR1r7D9U0JY6YW9TbHdPK30P716vp/xPDkpT0zlyeknH8uzJ6izctMUu22t3BMKykGa9OMoy3E5WmtMCwYHEgxJn0ptGaAksJOQTTUhWSLeWYJjB+tahQkgAE5PrFLRmwLHh5+o/npTJCtizkrAE+mD8aZIVkrYyo5BPHNZhRKYneQOO2aBjsB5iQBkbvXvW6McBDtu98+1atDJ7CKhYAEgHmlbKpWGtWxAJVycH4VNsrFJHbqlWO1SQe/rQTTC9C/3fug8QZEVVUyUr7RHeytILKR3FNSJWEt23jeFYICJYr37CayAxhVm4Nu4+/8AqgwpWHeWuOXZm/y59qAVo87z2kxxxRowcAZAkGJ4/nwoijmmtMVumSrIFgEZMmDHwpAy8F/0yGsEoIBP+RgzAqUtMZJUV/2g3HVqGXaQdrD4VP0/To6Mngp3PmLcCJrqrRC9ngFk+i5M9yP5+FH7AryLbg10XATEwInGIotaoye7LfRsA73QBNuSCR6D/dcGWOq+TrhIuer6r+n0Wo09gKb+qne8/dtCIX//ACgH4fGuH02LnNTl1H/P/B0ZJNKl2FUW9Ct/X3kt3tpTS2lYxvMCZ9hn8u9I7y1iWu2/3Ha42/6COq1Q6z1J73VbreAjZCDadgxsQdpiPYSavDH/AOPjUcK2/wDPy/0/uTcuUt9InqdZc1Q/qryLbuX3XT2UQALZsoR5F9ASVX4BvWljiUPYukm392/L/wA/sM3e/wCha/Zq0dPZ6lqSQLxUWlbgy7nj6RUPVPk4Q8d/sjR02z7B0fZpdFp7CYVLYAE/j9a8LJcpOT8lkqVFouoVbSyRwMVHiMBa7v3E++PpWowq9pc5JkyJ7U0QsrtRpgzcYqikEU1PSdFrrRTWaSxfTuLiBqpDNPG7g2gOKlqSPnv2t+wWl2ve6RNi4M+ETKN7CcivY9H+KzT45tr58nNl9JGSuGj5lqNPc0l82dRbe04/xcQSPb1r6GEo5Fyi7R5souLqRAkQeZj0pidnjLTOSDnFagMjcCqq5zkEUFZmKXACDPM1RCM8JA7qAYkc1qMdXIhTBOJImhXyY6CN0scAQZGDn9qFBODaChiSIJBrBQa1dMCIn4ZNBxRRSb0FRnj7zRMZPFI0iibO3dxQEmT8fegqsLsAy4P3hBqiom7Daey1wGGAIEyxj/k+1Fifqd2NZuQR50EkATEfH+RWANaS3v3EPbTaS3AgjORP0oSMjqbWFwBWCnAYcTHH50rRRNHmU7FbdniTnGP903QErGUVmtgL90DbGBzxS9bCnehlASyeYiRE8EYMUF2CSND0wzpt3iqoJkBvgKhN0yiVorPtIxGtxGWLfUA8/Wp+l6K5PBTXBLA4O+K7LpHN2zzwi3SDgEgCeQBSJt0O0lbENRK22UdyD8vT8asnbJS0h/SalvBK5DMCMiJ4rnyRV2XxsL/UFX3bdyKNzA96lx1RW92WnWNemouWRaJaxZYOZEBmZgT+ED5Vy4MLgnfbOjLkukgNpktqz3AIuahlg+gH5S351nctLwl/P7ATSdv5GNXcUWdPbVlZdONoKmQWBLMfcScfCtii7cn5/wCl/YE5dJFppdUbLFVYbGu2bhHtJMiuaUOVP4TKfJ9M0XUkZEhhtC/814s8bR0aGk6mhVVkDik+mzDOn1UkwZ+dJKIRwXgRjip0FnGG4SDng4oWzC7IYnt+dNyMKajSC4CCrHPamjkoaiq6n9m9Ne0hS/prWptnJtXV/FTyp+FXxernCVxlT/n7iyxxmqkrPnnXvsAgW5c6HfuBxJOmviSB8efnmvb9N+MS6zrXyjgyehXeN/uYXWdN6hpbrLqdHfQgwYQkH4EV7MPUYpr2yRwzw5IvaK52O0bjHaPSrEWCLTBg4kCM0bAeYeUkYPMVrMTQ/e+ECRM0Gwog7gQdwEYiaIDikn7kH2GaF12FJvomu5CwdGUx3U/GhafTGqS7RO3cbB5zPFBodSGHcOh8giMQaVWmUtNAciSFnNN+ojvwFt3riqNp2DMwP0o8UhHJsbt2b5XxbjMwvDy3DkMRHJmZGB8KD+AWdSAJt7A0bGAIEnEwO0/vQtj0qPF5bDgGAWEyuMjPr2oroD2w+qV7F+wtxChdQ0c4PHFbsCfEKqkW32gBlaI9BxQTGfdhLV0LfgkqBEZ7TmaVI0nouNJf2adBECBGJqMlbsonSSYr10lzvBTB4ECe3FDC0nRScW1ZRXLm1pBODOPnXW1o5o9kVvLDBm7k8x8aFDOwGoYZgyOeaeIkkd01za8dpEAmlyRtDY5UOLcZrbyQPIY9xUHGmV5WSa+XCk4AAkT/AD0pFCnRRytWFt3t9oBynBMD1Jmg4KLtAc3IJevMNPtxumfX6/ShGOzN2hzTaz+o0PhsPMpkwc4GP0qE8XCfJFY5LjRoen9aa1ZCagsrxAHb4zXHk9Mm7iXhlstdB1ZblwL4iyYjPPwrmngaVlFNM02hvMUnnFcE4lUWtm/Dc5PaudjUOLeiWJn50OzNEBqAW9RP0oOJkSv6hVtll4FLGO6GYlpOrWLt7w2YEg8GqTwSirMmmWOu0Gl6jpYaA4GGUww+BqUMksbtGr5Pln2o6LrrGt8IawJYuD+3dcGN3YN+hr2/S+qxuNuNteCWWMq9pj7/ANh+r+Ptsvo7rlvueLDme+1o9+K9SP4x6erdr+fY8t+iydob6T9hrGoR01mvujVp97TWkCsFE5BbmPhUPUfjEoO8cPb8t/7FYehX/wByI6z7GaG2pWz1G/p7jEBDqrYKHP8A7L3rY/xfI9ygmvs9/sxn6CPiTEX+zlzpZDa3Tm+mYdSdhE+2R2qq/EVn1jdf5/uGPpFDtWaHpd7S29PbbTjS2ljG5FKz6bo/E15udZJNqTb/AJ/OjqhFJaQLqdlfHZdf0rQuGCnd4fgsxHo6GPT0p8GR8f8ATyP97/szSxxb2kV403Tg5NvU6jQ3RJFnU2/GtmRH3hn866Pq5vMVJfKdP9uhOKXTr9Su6j0i21m44bS+IsEPYeQ/xFdWH1TTS3X3I5PTqSvz9iguo1obWMd8GvSjNSPPlBxJ2bqlTuA8QEZ4n50XH4Mp/IUXApDwPKYUL7d/ljn1rAdeDW6dLF7pOmN4i5ZQ3LkAhYntA7EgCKXyLVGcu21s6guVA2wSpyR220bCtgizpfN6FXfMA4jkRTJKqA+yVxAwV0wFaCSR+lYw4sgltsyJH89cUGFbO2lLXh3X37UjdDqNofu3b1sqLdxgsSAaT2vtBqXyNdav6YOqWzvukidoErB71zYITbt9HZmlCKryZO8CWIEsVPHrzXonnoibUpv4jPxxQsYA8BCSadE5HmUgAqJWsCgy3LtoIZBB4I7UjgmMpNEPF3YbcD79qXjQ6kM6XVFSeOByOKWULCpBG1Ae087ZwWB9Z5ocaGTD6Iai9rLaaJHuag/dtINzMKSfGMbn18hjbejZaD7I9W1Kp/3J7OiXja3mc/IY/GvKyevwxdY7kdUME33o1eg+yuk0ekU27RuPH/kuCfoOBXnz9bOctui8cSigul1BtK9pyQbeJ9alON7XkvEsLGqznia53AaxtdVCkHMntScA2cN1ABckiKyT6MHTV2dQoSfN8YmlcZR2EzH2s6BqxZ/ruksVuJkqOSPb1Nd/pPUwvhl6JTjJbiVPRvtlqNIFt9QBC8C4OJ9D6VbL+HxnvGCObxM0Or6pp+oaEg7bquIiJBrhWGWOXxR0pJmVvWdttEuEvZX7ock7R6V3Jqm0tslODTTXR27rNdpFCG4NTaA8QWb67vmrcxntUlix5N1T+V/+iNtb7A6nqT9TNxkRBc2g3bTfcux6++OeaaOBYKTf6P4CmmtCmjvvbslLV68lg4XxHk2Wmdp9vRop8kFKVtb+3n+fAU6FtRqDa1ROs0wBA2u9ryuueT2Ye9Uhj5Q/05fv1/wByp7LHSvavJcs/wBQlzTtEKx8pBjtyp9xiuealFqVU/5+/wDUbTRTdTtvpHa20XLLxEmSvwrtwSWTfTJzVa8CKJbV2ZC5E/cMSDXS22qZBquis1tlX82QwMbW788V14pNaOfLFPZTkbHZgxgevIrtW9HDJVtBQ7JeYhYuNHeCJ/ejWgXsdt6u8enmwty4bbv5kB8sjIHxxSVUrH00R3f2UWQQZEDlc9xHP6UX2BaJeIRtAE7YMxP1pkKwjMAEWD5T25FBhRKS+/zRJwJ7R/qgFfAzogwwGIHBHocVKb3stBOtMev3CmwF+VnHxNJSYdor9SZv3C8li/c96ukkSbbECVVnUnzYI/amBpaI3nIRgARJNZAYB4MFzOZg0yFDyrTIaT3mRStjUc2qNpBIHYKcg0OTDxXYElRIYEtgTR7NfEiwWSWU4EyJE1tgtMe6Nov+59T02jt3Da8Voa4xnaoyT9BUs+T6ONzauimKP1JKKPrmgtdK6HYXTdPtKDHnc5dz/wDTcn8B7V8vlll9S+U3/sv0PVhCONVFD/T2v63VoqQYIZ37Kv6VKcYwi2PZqy2+34VrAGPWuNLyEzfWtFcUm/axcTkdmFdWHKn7ZGryin0uvO6CCCMEHkVeeKkFOy0tardBB47VzuAxZ6Z7WpWAe0R61CSlFh0U3WLGs6PqP6zTqb+kMSoyyfvXThlDOuEtSElcN+Cz6V161rNOIuBpqOb08oPY8ZKStFP9qeh2NWrarTKq34llHDirem9S4eyXQs8fLaMRba7oGnTXGG4+aw54j09K9S1k1Nf1JRk4dfsW2j6lZ1Qe2zbXB8yN97+e9c+TC4e5dHTDKpaIam74TJbL/wDk/wDE/uMxS8buS8diTXFlLfvGzqPFHl3SCAcTXTGHOPE53Lixm9etvqdyOEuEEQ33XGMGoxg1GmtFOSbDXLS37CC2GDKSAZ8y/wDyfUelTjLhL3fz7jtWtFDdDBzc07lLi5KLwfhXoxaqpK0czdPXZJNYLqReB3rzPH0pHi4P2j/U5aYv/UWiX8rAj0q3CSEU09EXIvWWyAQOeKKuDBKKlsoNSNl0kDBEGOK9DG7R5+VcZA1YC2wG4MTzOI/erWc5K3cB2ycSN08RQ8hvQ09w7BJkE55way0FuyViGaJAPrNGhW7C353GSTBiSe/egFWGtW96qN5x97H40jZSKLHp432WBjkx8cVzZXUjqxRuNjGstqzWzz5OQPc1lM30yq1Ll7rtuMkk4rrOMrgQSSojvzz8qYwQDenqQIj1oXRqs8SvAyZ8xjkjt8KXYyo8QHghgIwATWug1Z6PWTmaFmoG6zwTB96KkK42DdNoJk45zTWDiaL7DWd3WxcYR4dl2ke+K4PxKdYaXlo7PRwqdm40ti7r9abFgAMctcIkW1nJ/wBdzXiynGEbf/Z6NGp/q9P0/SrptICLY7kyzH1b3rj4vI+UgJUy26TdC2Bdu5d1kL7dq58ndIYD1Am4LjOREd6MF8B6MZ1mzF7xbQgz9a9HDO1xYkl5I6LVW7x253DsTkfGjkg4hTslc1+p6bqEuDc9k5xkj96CxxyqvILcezV9H6tZ1tgBirq2eZrz8uF42VTtaMv9pOj3Omag9Q6QQLR8z2d2PiPSu703qFlX0sv7kpwcfdEh03rI1iKC8GIKnkfI1svpvpsaGRTAfaPpia1Te0YAvqPuyfNit6bM8b4z6Hy4+StdmOvidTbtvvtXVHlZTBU16kXUW+0cd+77nFuXjdQ6m6z+ESwk+laSjT4rsLnJ6l4F01TvaYXAc5A3TFO8aTVE1NtHOoXQEtkMxJAOG7xWwx2wZXVUOaDqT20QlyduJ3ZPtUMvp1JukVhlpbEtTdBvm4jbW5x61aEPbxZOcrlaIM5ut4lsgNwVpuKj7WDle0KX2UXCwBiBB944q0FqhJPdgvEm35Gin472blrTK64xDNuz7TXTFHJN29gk2yJEjjPwpvBJBVfcxnk9ogfGijWMEqbe1xABmR8K3kxOw5t6veyhiQYzySMfz2oPoKRMAkkKGYA+/NCxkiys29oFwQBBmMyI/n0pWMtjXS4a1uIAzkDuBx/PauXP+ZI68D9rG9cwNxNqJ9wTuahDrYZbZnNVehmgEZImvQPPEgwLQccZFNugavYVLyrIjjHFI02OnQQHxMAqCTxMUNoN2TAUGCQYHEE0jbYyIrcGdwJwQARAH0rNM1kd7EgSRA2+tGtGXZ1lIQLlnH0FBO2F6NL9j7iae9e3A7rlvaMfOB9K8716ckq8M7PSPb/Q2HStb4OhZFwWYl2AzPpXl5Mbc78HXy8B+ng6zWqrSbSmXPqJ4pcn+nH7mWzV6S/4rXLjiLVvGOCfT5CvOkqpDlX1vqqlSq9j9K6MWJm+5ltZ1LxJDSTOAK7seKicpeCj1GrNphctyLg4rrjDlp9Em/KH9J1u3qrZW8CrxMGoz9M4O0MsnIHp9Tc0N43dIxKHLL2P7GtKKyLjMZXF3EtH+0a6tDbZ8jG01z/+I8bsosikU+stf3vHs3Tbu+qmZ9q68c9cZK0SlD/6joZ6T11f6rwtSCl5eM4Ye1Tz+l9tx2h8ea3xlpgftRYs6uyddpl/vIDJU4YUfSzlB/Tl0HPjUlzXaMw+s32HY5YggT713LHUkjic1QtYuQiwTA5qk1sSD0Q1F3denaSEGM8U0FUf1BN7O2r4FvO4wZ5oODbFUiJ1LEEgwB2pvpoHM8L5CyMHn+fWs4+A8iF+8GDEnmjGLRm9CYu4MdzxVaJKQB23EnNUWiTdkVn05mjYoRN0sckxRs1DCQSW80EYzQchlEONnlEQ2Zz3j0+tKthlokl0rvFtYgZ3H3/CiwxH7bb1mGbB5A+f6UllKp0MdOuKijcHFuTuiCZjv8TFRyK5WWxOo0hnVbWdSzQdg9D2pY2vAZGd6mf7jkgwSfxruRxMG7PeuC5dLMAFUGOw4FHpUgJErdkhf8c8iKRyHojctsOVEexkispAaIbtuDIj1PFEBwE+pOKxgiFyp7Hk0rHiHt3sLMekmlaqw90P2LzgoyhpVpnn4ipTgmikJuLtGk6X1Dab3iFTI/x57TNeZlxVR6EZc1o1PQGW/bRLZjed9xx/iteb6h8XbLQjod651hLVnwNLCWkwufzqWHA5PkzN0YTU9T1F4uUuLtkiTmvXhhjHs55TcuhMB3fc19x7LEVa0vBN8vkE2nts2brMP/pporI14Nwvtk201tBJ2g0PqNm4onatMTtS98ATPalcl5QdrpkNVpHPLgdwViaaORLwCVtAVv6myApuLcH/ANc0XGEt1RlOUdPYnrTc1ABXajLkHv8AWq46iJkfLoFc1muGmaybhZDg/wC6dY8fLlQrzZFHjZVb7ijawPBgRXTSe0crbWmTXUFF4g0jhbG58UBF4ncSc+9PwE5nReO2DW4G56O+KNkCM1qMpEWuYMA4/KtRuRwuSVjk81qM5AiYUCihGzgY5jj3omslu95Y9+IrBCKPKYIgcgULY3FDAbaqiEBHBjPw+FYN0dBBziSDOfb+fWtsFDKgbWBYKCCRA78xSXbKpUg1l43A4gcek0QInYuHw1EDygnyiCZ/4pZrY+N0g2oM3TheByK0VoDdCd9Abj7juJxINVIgAAwOYAb6miHweKnaFLgmflQMybKiqWLe38+lC/AGgEW/MMgcx3o2wqKZJfD27Qi7gZmK1PsCpaR4DyHc3J4oN/AVslZ2rcAUnAMn1pZW0MqQTxdowROBkVuIbDaW/ctXBcRs5BBzIPIqeSCkqZTHNxdmz+zWvujpupG4SXCgx7GvG9VgX1EehjyXGyq6xq2Np03BiCPMOfeur0+NWmRzN0VGndxcZCCwbIINdUoqrIpvonevMphXJER92goJiuTF3dpBR3IPI296fivIrkw/nuN5XZhHJApKSCpMPZlDDO8+x5oNJmtgdUxBH9y4Yx97ijFIFsSdoPM+nE1RIDsEXGZWSM80yiC2cZs5E/GikZsDcM4haZIVgGCgzNMLSIMvMuKKFa+4M7YimQjolux71qNyObpWM1qRnI8MQSfShQLPbsEBRmtQeRAGTgx3rUCzgEn4+tEAa1LEjMHECtSGTY5pUS40Ezic4qeR10VxJSeztgAsNskbSDIEimfVAj3YRTtG1ZkH0gc/8UEvIzfgJbyzEHHvQZl0T0s8cCa06Di8jF9Q1wy23tBE1o6QZdlffJUtMkiePjVSIFGWPPmMxMUWn4Mq8ngzAAt3iJ9KzQL+SNxmuCCRPYAUEqC3yPIoEksCeI9KDsy0EH+UbZ7mKFM1kwGzJMA8zSjrsiGVQYJLZitxbNaRFSWJ9e2KLVGjsYtLEbztB+dTlvorHT2W/TNcbKG2coSe3NcebDydnTiyUqFdZqSb1wyGDce1Ux49IWWSmK+JtKkY9Zq3G+yfOiVt4P8A5IExxupGmF0GV1IWXBAGfJz7e1CmK6CJeRTtBwD/AOsUHFms5cuqWJDOJEghfahxaDaFbjg7pe5//r/uqJMVtAXuDhiwHwAplFi8kD8S3/7PPvAzTcWBySOG8mI3SfVqKixXNC91hldgnvJNMk/kSUl8EbjBuEA78UUgN/Yi0xOV+UZrUBsET7n0opCWc7mZogO+gzRCdER2oUEiSaAD2eJxn4UaMcXt6zWoAS20SR8c1qCOaZiXwYPqKTJ0Xw9knm3dA9Ru+uKWLtaDOPGVEZYAwDM5zTJCh0MBjOTij5GVUMdOIe4BBADAAD1nNCaNB9nrzsXJJH0/atFaNJ7FdVIuFZBM+kTVBAMRkRBGYHHtWB0edgVHl8wNagNoCJkTEGjYqTCIBIJPHqtK3XQ/H5J7QMAnbyfetboFbOO5I5GeKC0MRAb/ANpA7DNZsyQdI2gDHfikZSKClPKGkmPWlvwN9yRJdQEnfExHFJ09lKtaAeJPqTFO0STBO5btEe1MlQJNs8Lr7AAWB7RWcUZTfQfxG8IZdrgiG3mI70lIYjvcAkuxMT8a1I2wdy6zEyTjvTKKEcgLgd2nFOTYI5A/WihGRxyfrRAdBzg/OsayIbPtWNZLccRPpS0MmcZvLBJrUZsHOKIh0e/FExJsCCCD3BEUAkZ4rGPeg9TWMeEYHaaxjkyCTMniaICQmT/7c0AoPpXKlROJ54pZq0UxSpjerYk2mfbMFSQKlj80XzPaFyfOY78dqoibqwouKpUhgQRHYUyM3Qxobu1jGQIJgUJ7DAGdjEl5DegAooDVkr5X+puYO3cfpNOxFoVdgCVny+3ajQLOswJ9QTmgbo4p29gVYYJEVmgxdBZC2oBkj17UvbGukBYd5HFMTOLnAJIz8qAyDLafbxj3NI5Ioos65Cp6GJwaHY2kc3P4bLHOa1K7A2+iCXImfXtTON9CxlS2et3QXPAoOJlOzshj+s1uhuzpICgcwa3ZnoNCPYYsNrDA+NTtpqiqSadi7XV8EggyTEz6U6i7JOSUQe8McgKfc01E7R1hKys1l9zNX0BnMR8gaYmQYmROKwGe3Dd2j3rAOE47QMUa0YmCJ7fOlGR58DtWRmDkDggHiiKeBBif3rGOme/PPrWMc7jigE6BWMc4kisY4eB6fGsYkDjIwawUFskKO31/Sgxo0gjvucAjmBFBJJDSbkyLYMg4isBqmEcm2dsrznvMQee8UUEY0YBdt3MH6+lCQ8EEVXuAlWQCYhuaJmLXG/uuMEEkiaoIDIk459I4rAqjgyeBHpQZv1OzmCNxAwIog0R3zAUcc96FGskTJzj1oBGLQJQ42iPvRmkkUjomZIESxj1pQ7Zy5tVZO2SKKTYbSBEqc4kelFJitogzKcwI5M96ZIWwbAByePY80Ra2FXAOKRlUTVUmWO5okjsKVt+B1FXsJbEWnLKPNx7Ur70PHptijsFV/wD17VVK2c8nxTRxVtlZDHccwcRW2BKJ4wBAkj8qIGyJPaM+tahGwVwAEYxRAyWwMMkAmTQs3E46kDkGimK0ERCwkRFK2ikYtnryAJI+BrJhnHVoBmIHemJHI9cCiY9x9e1Ax4fjGKwQm3yTHelvY/HVkI9hmiIcwaxjoHtz60asyCKQoYnLTAilfZSNJNhNx3AzGQOeKWh7tk70b1OGPJE4k1ohyVaIBtwUQMdqahLsPZbacgcjPzrNDJhwjGSJyZxTpAbC9b0VzS9Q1KbFADTj0JgGnjtEnLYkqggw8iJJI4PpWcQqRBo3GSfmKCiFyRK2uW8MknjBiazQE0TbTsqByu4MYGe+KHehujhTaASASW2lQcg8fDtW4sXkiRuQxQBiZ/yjsaHAb6iOs5MST5pg/MitwYfqILo9K2suPat3LauiFgHnzEdhj84rNULyBG0HOCDjsK3RgTKFBkSM89jFGjWiTKEaGUhoB7cGhQyaPKZHHHeKXiPyJ7UZBBOPahTBaYx4YCAs3lA+lKosrzSRBdMzIXSCJlexEHmjdOhGkwX9JccmYB78Zo8khOJFtIwMd4o8kK0QbTsWCzk0U0LXgh4c7QT8KID1u2S6o3JwB70Ggo89skiIUjBEzmaIHsIVbapJEYgAUlIrydA7ltxuQkAzmmSEb1RMWE2GPEcgR2A+XejTEtC7oV+/IYijQCKKDMsdvrFajHVVZAZjI9uK3EJ0SFgRETJ+FLwGU6VEBJ3GTgQZpuItnAuDINagHtpC7pEAwfWtRrPHE+/FLQeVEmuHuADFbgM8l7JSWJyccUVAznbsmiiTM45PpR4hUiZlpKknOT3oqIHI1PQ+iaXU9PS9rg/iv5gFP+JyPzpJSadI0drZ/9k="

/***/ },
/* 301 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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jZdlgrzQv7myFldfJQFOk+E0XjLx/wO6IG3XnQWvfQAAAEx0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlREb25hdGVsbG8yMDEyLnBuZ1IQ5DAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDMtMDdUMjM6NTA6NTkrMDA6MDCf1JlFAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTAzLTA3VDIzOjUwOjU5KzAwOjAw7okh+QAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi42LjktNyAyMDE0LTAzLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ4HTs8MAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADQwNDFqrhIAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMjQ3FC4VkwAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNDI1NzcyMjU5PufDkwAAABJ0RVh0VGh1bWI6OlNpemUAMTIzS0JC4fuycgAAADN0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3RtcC9sb2NhbGNvcHlfYjg3YzQ1OWM0MzQ1LTEucG5nEZaXyAAAAABJRU5ErkJggg=="

/***/ },
/* 302 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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eUFugqPpskfsJlc6HA5vyaOo/69Ysnn/gkJVadt2cWVI17ArEK58Y/valW9sfxIo3/n4mYesSJtZGTStaohRQqdtlVsDMdK66HwbJr1evtrcqLLZ1pR2XKkgYnJDNPhq7r40uVF9bOfl8Vdi1L3FcEDTj23350dVjR2x8pYmJS4zyH/l2N3dXXy52A8ePss9UE5vA/v9jX5Z9osTYmQYvJoYYkdYjESUat7uXX966wvH3nL09PzyuLfzwg2id5KXWS2ZfXmy3/yLrZcn/3R8bfYtVcZdr7FoyBdlVTj05zIej7lx48byjVoC5Lsq4quAEveuTOfP/8crX53O3FMms9MQVULUvNXYd5kiGdTbzZVLX776r4+c27hr/4WdE9Or402MPOmb+K92r1X/dO/y/Pd95Te7UmrGTYbugUoJt6jfx39pyPJ/wX/1//8HVgkkVesS6AMFMDr14Im7jr/5yJvy4/378rXirlGeHZ9fmW8/+enn/7eTj5x4pN6cnNs9v/uVttGnmpm/3vUWflFScVPbKvJK+dAlOJYA+Z4JcwgktgNH2QGmI7VTDE4OV1ePDQf4aG+8uHMNRWNUr1GrQwBwh8qoP88AZxlLgHzPgkReBZTsEEjkVf2LHAJF7ICweL26x1iCYwmQN9R7sQCLPZRdzKtA8mf6l0M/F181CFjGEiBvyPdF/pwXf87Dr4dAw7LHWALkVm7oX/3wL4HwOsb/C6yPRSDGvMY7AAAARnRFWHRjb21tZW50AEZpbGUgc291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZpbGU6VE1OVExlbzIwMTIucG5nJXHGFgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wOS0xNlQyMzoyNzo0MSswMDowMI1cwmAAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDktMTZUMjM6Mjc6NDErMDA6MDD8AXrcAAAARnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjYuOS03IDIwMTItMDgtMTcgUTE2IGh0dHA6Ly93d3cuaW1hZ2VtYWdpY2sub3JnnL25SAAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABh0RVh0VGh1bWI6OkltYWdlOjpoZWlnaHQAMzkze4OWfQAAABd0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAAyNTJ9X9BdAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADEzNzkzNzQwNjFNTtgfAAAAEnRFWHRUaHVtYjo6U2l6ZQAxMzJLQkJkJ/ynAAAAM3RFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL2xvY2FsY29weV82YWIzYWMxMThhYzAtMS5wbmf+cubjAAAAAElFTkSuQmCC"

/***/ },
/* 303 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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/n8n/Kawy9PwPAAAAE90RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlRNaWNoZWxhbmdlbG8yMDEyLnBuZzgbWSMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDQtMTVUMTE6MDI6MzMrMDA6MDDebEYIAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTA0LTE1VDExOjAyOjMzKzAwOjAwrzH+tAAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi42LjktNyAyMDE0LTAzLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ4HTs8MAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADM3M+UAu/MAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMjY2UR9HhwAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNDI5MDk1NzUzILs0cgAAABJ0RVh0VGh1bWI6OlNpemUAMTU5S0JCPGaOBgAAADN0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3RtcC9sb2NhbGNvcHlfZTVlMmQ2OWIyMWZjLTEucG5ntTzkBwAAAABJRU5ErkJggg=="

/***/ },
/* 304 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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fjL+8Y1Pbz/fEymMS0SfiAFUDSEl/6PX9mZb10ZVWVhpJg33frTH7e/dk8OHx4eN56/2j9LXYmKH3Pk664AjWcmt682q9LwCyAV0txSQg93Z3bW1Mq6Nqs/Mx01vf2cqvkmq1uqr/7XzytrVtfL69fWP9ZOSXCIlpaRHoQNc7cev/WDnwZXn1zcP7x/bH3/3Nnu3d/FNvDf3fOnRXvyKD7rbWo4TtwqIhUDP5DHduNovK4BcwFgEWvKTg9361mi90tGl/q8aoTcZN/Lg3mTv1ltHL115dvR5DXFr/GjG4aMJew/GHO7O2LlzwO0fP9y9c2f8hpvU1/dvPSzD1KHKnZmXP3u4H78agh4Cky44jEEHA0O/b/SzlXKrWW2WD+MqLvj9LWj1BTDORX7wPw+//KnPX5s9+8zg91F97sFPDl4OPh0e3Nq7svuGa5tWEtGHLBUdEo3TyXTCq0cPwhc2+lIFlW8e1+nLB8f+lZQ4bsFRt78rGCNqBB0NLYOB4Vs/WdmOlQW5aJG6PGZJFEgxqtu5O75ZleYOpLWHO/Xfbm31XywIX/QuSEqqISaJIZFiZqoSa16fOf5+UPBpMfKNvbH+8eE4/bcqkyVwRAG1xqgCvV5OC48nK4CsLMhF868UrM0khDFq6IIE8K//cP+fRsPipgvabG/3f9O7uA86EKUkaf6XKc6nKZnvxBB/NG34o+N5er2e6w6ngi+LJsQogopBU0xsXFljb3ey2iEf8nWhm4p+63c/wivfuEuM2h01PdEDBEoR6a+tFZct6QVr9bo1PBujNjHHFfOU2JkHect5PeKUySN0nhcsJdryX5NW2arVehoAMhiWxJBw7qTbtzti2uWX6iqoLuaylxnFu8BYvL6wSAAqsppBXa2nCCA/4567TB9F52GW3LHYsRQL0unE+TPgq7VaTz1Auve9TF7QlWbuyoCkpa9XwFit/9cAeRJYnhjzr0CxWu9m/S9ZhZZICVfkQwAAAEp0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlRSYXBoYWVsMjAxMi5wbmekbX/HAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTAzLTA3VDIzOjUwOjQ2KzAwOjAwpTbpMgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wMy0wN1QyMzo1MDo0NiswMDowMNRrUY4AAABGdEVYdHNvZnR3YXJlAEltYWdlTWFnaWNrIDYuNi45LTcgMjAxNC0wMy0wNiBRMTYgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmeB07PDAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAGHRFWHRUaHVtYjo6SW1hZ2U6OmhlaWdodAAzNTRJUkzSAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADI4MVH4/6oAAAAZdEVYdFRodW1iOjpNaW1ldHlwZQBpbWFnZS9wbmc/slZOAAAAF3RFWHRUaHVtYjo6TVRpbWUAMTQyNTc3MjI0NrdD70MAAAASdEVYdFRodW1iOjpTaXplADE1NEtCQs4MVtsAAAAzdEVYdFRodW1iOjpVUkkAZmlsZTovLy90bXAvbG9jYWxjb3B5X2RmZjUwZDE0OTNkZi0xLnBuZ/ZXEo0AAAAASUVORK5CYII="

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var overArg = __webpack_require__(__webpack_module_template_argument_0__);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var getPrototype = __webpack_require__(__webpack_module_template_argument_0__),
	    isHostObject = __webpack_require__(__webpack_module_template_argument_1__),
	    isObjectLike = __webpack_require__(__webpack_module_template_argument_2__);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ }
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNzljYjcxNjkxYjM4ZjljOWUzYTkiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvcm91dGVyV2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NTGF6eVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2tleU1pcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc3RvcmVTaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvTGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlRE9NSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWciLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2FjdGlvbnMvdHVydGxlLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9hY3Rpb25zL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC11c2VyLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9jb250YWluZXJzL3R1cnRsZS1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdHVydGxlLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1saXN0LmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9hZ2UtY2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItYWN0aXZlLXR1cnRsZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci1hY3RpdmUtdXNlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci10dXJ0bGVzLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLXVzZXJzLmpzIiwid2VicGFjazovLy8uL3JvdXRlcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvaG9tZS5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvbm90Zm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL3R1cnRsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi9jb21wb25lbnRzL2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3dyYXBBY3Rpb25DcmVhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvfi9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL21pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL3N5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2lzQWN0aXZlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2hSb3V0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9xdWVyeS1zdHJpbmcvfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EYW5nZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtbG9nZ2VyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4LXByb21pc2UtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtcHJvbWlzZS1taWRkbGV3YXJlL2Rpc3QvaXNQcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtdGh1bmsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9FaW5zdGVpbi5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9FdWxlci5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9MZW1haXRyZS5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9NVGVyZXNhLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL05ld3Rvbi5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9TY2hyb2VkaW5nZXIuanBnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvZGFWaW5jaS5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9kb25hdGVsbG8ucG5nIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvbGVvbmFyZG8ucG5nIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvbWljaGFlbGFuZ2Vsby5wbmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9yYXBoYWVsLnBuZyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIl0sIm5hbWVzIjpbInJlbmRlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJtaWRkbGV3YXJlIiwic2VsZWN0VHVydGxlIiwidHVydGxlIiwidHlwZSIsInBheWxvYWQiLCJzZWxlY3RVc2VyIiwidXNlciIsIkNvbXBUdXJ0bGUiLCJDb21wVXNlciIsIlR1cnRsZURldGFpbCIsInN0YXRlIiwiYWN0aXZlVHVydGxlIiwicHJvcHMiLCJpbWFnZSIsIm5hbWUiLCJha2EiLCJhZ2UiLCJkZXNjcmlwdGlvbiIsIkNvbXBvbmVudCIsIlR1cnRsZUxpc3QiLCJ0dXJ0bGVzIiwibWFwIiwiaWQiLCJjcmVhdGVMaXN0SXRlbXMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXRjaERpc3BhdGNoVG9Qcm9wcyIsImRpc3BhdGNoIiwiVXNlckRldGFpbCIsImFjdGl2ZVVzZXIiLCJsYXN0IiwiYm9ybk1vbnRoIiwiYm9ybkRheSIsImJvcm5ZZWFyIiwiVXNlckxpc3QiLCJ1c2VycyIsImEiLCJiIiwiYyIsImQiLCJNYXRoIiwiYWJzIiwiYWxsUmVkdWNlcnMiLCJyb3V0aW5nIiwiYWN0aW9uIiwidG9kYXkiLCJEYXRlIiwiZGQiLCJnZXREYXRlIiwibW0iLCJnZXRNb250aCIsInl5eXkiLCJnZXRGdWxsWWVhciIsImhpc3RvcnkiLCJBcHAiLCJteVN0eWxlIiwiZm9udEZhbWlseSIsIkNvbnRhaW5lciIsImNoaWxkcmVuIiwiTmF2IiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiSG9tZSIsIk5vdEZvdW5kIiwiVHVydGxlcyIsIlVzZXIiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsb0JBQVNBLE1BQVQsQ0FDRTtBQUFBO0FBQUEsS0FBVSxzQkFBVjtBQUNFO0FBREYsRUFERixFQUlFQyxTQUFTQyxjQUFULENBQXdCLE1BQXhCLENBSkYsRTs7Ozs7O0FDTkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUMvSnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsNEI7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBLCtGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLDBCOzs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBb0Q7O0FBRXBELHVCQUFzQixtQkFBbUI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCOztBQUV4QjtBQUNBOztBQUVBLHFDOzs7Ozs7QUN0Q0E7O0FBRUE7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7QUMzTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxRkFBb0YsYUFBYTtBQUNqRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLHdCOzs7Ozs7O0FDcEJsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUEseUM7Ozs7Ozs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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bkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBbUMsZ0NBQWdDOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDLCtCQUE4QjtBQUM5QjtBQUNBLGlCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0Esc0VBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG9EQUFvRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUEsOEI7Ozs7Ozs7QUM3TUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBLG1DQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7OztBQ25OQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUM7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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RUEsc0M7Ozs7Ozs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWlDO0FBQ2pDLGlCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDOzs7Ozs7O0FDaFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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Q0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQSxnQzs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsWUFBVyxlQUFlO0FBQzFCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDOzs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkI7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtDOzs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBWSxXQUFXO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBaUo7QUFDako7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLHVJQUFzSTtBQUN0STtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxnRDs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Qzs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsVUFBVTtBQUNyQixZQUFXLFFBQVE7QUFDbkIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDOzs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUM7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7QUMvQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxlQUFlO0FBQzVCLGNBQWEsT0FBTztBQUNwQixjQUFhLFNBQVM7QUFDdEIsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxlQUFlO0FBQzVCLGNBQWEsT0FBTztBQUNwQixjQUFhLFNBQVM7QUFDdEIsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQSxnQzs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFXLFdBQVc7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLDRCOzs7Ozs7QUN6QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLG1DOzs7Ozs7QUNqQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFrRSxhQUFhO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLEU7Ozs7OztBQ3ZDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxZQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEIsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWMseUJBQXlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsT0FBTztBQUN4QjtBQUNBLG9CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSx5QkFBeUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRTs7Ozs7O0FDclFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRTs7Ozs7Ozs7QUN4QkEsbUNBQWtDLHd2Rzs7Ozs7Ozs7Ozs7QUNBM0IsS0FBTUMsc0NBQWUsU0FBZkEsWUFBZSxDQUFDQyxNQUFELEVBQVk7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBTztBQUNOQyxXQUFNLGlCQURBO0FBRU5DLGNBQVNGO0FBRkgsSUFBUDtBQUlELEVBVk0sQzs7Ozs7Ozs7Ozs7QUNBQSxLQUFNRyxrQ0FBYSxTQUFiQSxVQUFhLENBQUNDLElBQUQsRUFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFPO0FBQ05ILFdBQU0sZUFEQTtBQUVOQyxjQUFTRTtBQUZILElBQVA7QUFJRCxFQVZNLEM7Ozs7Ozs7Ozs7OztBQ0FQOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBQ0E7O0FBRUEsS0FBTUMsYUFBYSxTQUFiQSxVQUFhO0FBQUEsVUFDakI7QUFBQTtBQUFBO0FBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQURGO0FBRUUsOERBRkY7QUFHRSw4Q0FIRjtBQUlFO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFKRjtBQUtFO0FBTEYsSUFEaUI7QUFBQSxFQUFuQjttQkFTZUEsVTs7Ozs7Ozs7Ozs7O0FDZGY7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFDQTs7QUFFQSxLQUFNQyxXQUFXLFNBQVhBLFFBQVc7QUFBQSxVQUNkO0FBQUE7QUFBQTtBQUNFO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFERjtBQUVFLDREQUZGO0FBR0UsOENBSEY7QUFJRTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSkY7QUFLRTtBQUxGLElBRGM7QUFBQSxFQUFqQjttQkFTZUEsUTs7Ozs7Ozs7Ozs7Ozs7OztBQ2RmOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBO0tBT01DLFksV0FOTCx5QkFBUSxVQUFDQyxLQUFELEVBQVc7QUFDbEIsVUFBTztBQUNQUixhQUFRUSxNQUFNQztBQURQLElBQVA7QUFHRCxFQUpBLEM7Ozs7Ozs7Ozs7OzhCQU9VO0FBQ1AsV0FBSSxDQUFDLEtBQUtDLEtBQUwsQ0FBV1YsTUFBaEIsRUFBd0I7QUFDdEIsZ0JBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQURGO0FBSUQ7QUFDRixjQUNHO0FBQUE7QUFBQTtBQUNFLGdEQUFLLFdBQU0sZ0JBQVgsRUFBNEIsS0FBSyxLQUFLVSxLQUFMLENBQVdWLE1BQVgsQ0FBa0JXLEtBQW5ELEVBQTBELE9BQU0sS0FBaEUsRUFBc0UseUJBQXRFLEdBREY7QUFFRTtBQUFBO0FBQUE7QUFDRTtBQUFBO0FBQUE7QUFBSyxrQkFBS0QsS0FBTCxDQUFXVixNQUFYLENBQWtCWSxJQUF2QjtBQUFBO0FBQW1DLGtCQUFLRixLQUFMLENBQVdWLE1BQVgsQ0FBa0JhLEdBQXJEO0FBQUE7QUFBQSxZQURGO0FBRUU7QUFBQTtBQUFBO0FBQUE7QUFBc0Isa0JBQUtILEtBQUwsQ0FBV1YsTUFBWCxDQUFrQmM7QUFBeEMsWUFGRjtBQUdFO0FBQUE7QUFBQTtBQUFBO0FBQThCLGtCQUFLSixLQUFMLENBQVdWLE1BQVgsQ0FBa0JlO0FBQWhELFlBSEY7QUFJRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSkY7QUFGRixRQURIO0FBV0E7Ozs7R0FuQndCLGdCQUFNQyxTO21CQXFCbEJULFk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEQ7Ozs7Ozs7Ozs7Ozs7O0FDdENBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7S0FFTVUsVTs7Ozs7Ozs7Ozs7dUNBQ2M7QUFBQTs7QUFDaEIsY0FDRSxLQUFLUCxLQUFMLENBQVdRLE9BQVgsQ0FBbUJDLEdBQW5CLENBQXVCLGtCQUFVO0FBQ2hDLGdCQUNLO0FBQUE7QUFBQSxhQUFJLEtBQUtuQixPQUFPb0IsRUFBaEIsRUFBb0IsU0FBUztBQUFBLHNCQUFNLE9BQUtWLEtBQUwsQ0FBV1gsWUFBWCxDQUF3QkMsTUFBeEIsQ0FBTjtBQUFBLGNBQTdCO0FBQ0NBLGtCQUFPWTtBQURSLFVBREw7QUFLQSxRQU5ELENBREY7QUFTRDs7OzhCQUNRO0FBQ1IsY0FDRztBQUFBO0FBQUE7QUFDRTtBQUFBO0FBQUE7QUFDRyxnQkFBS1MsZUFBTDtBQURIO0FBREYsUUFESDtBQU9BOzs7O0dBcEJzQixnQkFBTUwsUzs7QUFzQi9CLFVBQVNNLGVBQVQsQ0FBeUJkLEtBQXpCLEVBQWdDO0FBQzlCLFVBQU87QUFDTFUsY0FBU1YsTUFBTVU7QUFEVixJQUFQO0FBR0Q7QUFDRCxVQUFTSyxvQkFBVCxDQUE4QkMsUUFBOUIsRUFBd0M7QUFDdEMsVUFDRSwrQkFBbUIsRUFBQ3pCLGtDQUFELEVBQW5CLEVBQWlEeUIsUUFBakQsQ0FERjtBQUdEO21CQUNjLHlCQUFRRixlQUFSLEVBQXlCQyxvQkFBekIsRUFBK0NOLFVBQS9DLEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyQ2Y7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7S0FPTVEsVSxXQU5MLHlCQUFRLFVBQUNqQixLQUFELEVBQVc7QUFDbEIsVUFBTztBQUNQSixXQUFNSSxNQUFNa0I7QUFETCxJQUFQO0FBR0QsRUFKQSxDOzs7Ozs7Ozs7Ozs4QkFPVTtBQUNQLFdBQUksQ0FBQyxLQUFLaEIsS0FBTCxDQUFXTixJQUFoQixFQUFzQjtBQUNwQixnQkFDRTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBREY7QUFJRDtBQUNGLGNBQ0c7QUFBQTtBQUFBO0FBQ0UsZ0RBQUssV0FBTSxnQkFBWCxFQUE0QixLQUFLLEtBQUtNLEtBQUwsQ0FBV04sSUFBWCxDQUFnQk8sS0FBakQsRUFBd0QsT0FBTSxLQUE5RCxFQUFvRSx5QkFBcEUsR0FERjtBQUVFO0FBQUE7QUFBQTtBQUNHO0FBQUE7QUFBQTtBQUFLLGtCQUFLRCxLQUFMLENBQVdOLElBQVgsQ0FBZ0JRLElBQXJCO0FBQUE7QUFBNEIsa0JBQUtGLEtBQUwsQ0FBV04sSUFBWCxDQUFnQnVCO0FBQTVDLFlBREg7QUFFRztBQUFBO0FBQUE7QUFBQTtBQUF1QixrQkFBS2pCLEtBQUwsQ0FBV04sSUFBWCxDQUFnQndCLFNBQXZDO0FBQUE7QUFBbUQsa0JBQUtsQixLQUFMLENBQVdOLElBQVgsQ0FBZ0J5QixPQUFuRTtBQUFBO0FBQThFLGtCQUFLbkIsS0FBTCxDQUFXTixJQUFYLENBQWdCMEIsUUFBOUY7QUFBd0csa0JBQUtwQixLQUFMLENBQVdOLElBQVgsQ0FBZ0JVLEdBQWhCLENBQW9CLENBQXBCO0FBQXhHLFlBRkg7QUFHRztBQUFBO0FBQUE7QUFBQTtBQUE0QixrQkFBS0osS0FBTCxDQUFXTixJQUFYLENBQWdCVSxHQUFoQixDQUFvQixDQUFwQixDQUE1QjtBQUFBO0FBQStELGtCQUFLSixLQUFMLENBQVdOLElBQVgsQ0FBZ0JVLEdBQWhCLENBQW9CLENBQXBCLENBQS9EO0FBQUE7QUFBQSxZQUhIO0FBSUc7QUFBQTtBQUFBO0FBQUE7QUFBOEIsa0JBQUtKLEtBQUwsQ0FBV04sSUFBWCxDQUFnQlc7QUFBOUMsWUFKSDtBQUtHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFMSDtBQUZGLFFBREg7QUFZQTs7OztHQXBCc0IsZ0JBQU1DLFM7bUJBc0JoQlMsVTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0Q7Ozs7Ozs7Ozs7Ozs7O0FDeENBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7S0FFTU0sUTs7Ozs7Ozs7Ozs7dUNBQ2M7QUFBQTs7QUFDaEIsY0FDRSxLQUFLckIsS0FBTCxDQUFXc0IsS0FBWCxDQUFpQmIsR0FBakIsQ0FBcUIsZ0JBQVE7QUFDNUIsZ0JBQ0s7QUFBQTtBQUFBLGFBQUksS0FBS2YsS0FBS2dCLEVBQWQsRUFBa0IsU0FBUztBQUFBLHNCQUFNLE9BQUtWLEtBQUwsQ0FBV1AsVUFBWCxDQUFzQkMsSUFBdEIsQ0FBTjtBQUFBLGNBQTNCO0FBQ0dBLGdCQUFLUSxJQURSO0FBQUE7QUFDZVIsZ0JBQUt1QjtBQURwQixVQURMO0FBS0EsUUFORCxDQURGO0FBU0Q7Ozs4QkFDUTtBQUNSLGNBQ0c7QUFBQTtBQUFBO0FBQ0U7QUFBQTtBQUFBO0FBQ0csZ0JBQUtOLGVBQUw7QUFESDtBQURGLFFBREg7QUFPQTs7OztHQXBCb0IsZ0JBQU1MLFM7O0FBc0I3QixVQUFTTSxlQUFULENBQXlCZCxLQUF6QixFQUFnQztBQUM5QixVQUFPO0FBQ0x3QixZQUFPeEIsTUFBTXdCO0FBRFIsSUFBUDtBQUdEO0FBQ0QsVUFBU1Qsb0JBQVQsQ0FBOEJDLFFBQTlCLEVBQXdDO0FBQ3RDLFVBQ0UsK0JBQW1CLEVBQUNyQiw0QkFBRCxFQUFuQixFQUE2Q3FCLFFBQTdDLENBREY7QUFHRDttQkFDYyx5QkFBUUYsZUFBUixFQUF5QkMsb0JBQXpCLEVBQStDUSxRQUEvQyxDOzs7Ozs7Ozs7Ozs7OzttQkM5Q0EsZ0JBQWtCO0FBQUE7O0FBQUEsT0FBUkUsQ0FBUTtBQUFBLE9BQU5DLENBQU07QUFBQSxPQUFKQyxDQUFJOztBQUNqQztBQUNBLE9BQUlDLElBQUksRUFBUjs7QUFFRSxPQUFHRixJQUFFLENBQUwsRUFBUTtBQUNQRCxTQUFFQSxJQUFFLENBQUosRUFDQUMsSUFBRSxLQUFHRyxLQUFLQyxHQUFMLENBQVNKLENBQVQsQ0FETDtBQUVBO0FBQ0QsT0FBR0MsSUFBRSxDQUFMLEVBQVE7QUFDUEQsU0FBRUEsSUFBRSxDQUFKO0FBQ0E7QUFDRCxPQUFJQSxNQUFJLENBQUosSUFBU0MsTUFBSSxDQUFqQixFQUFvQjtBQUNsQkMsU0FBRSwwQkFBRjtBQUNELElBRkQsTUFFTztBQUNOQSxTQUFFLEdBQUY7QUFDQTtBQUNELFVBQ0UsQ0FBQ0gsQ0FBRCxFQUFHQyxDQUFILEVBQUtFLENBQUwsQ0FERjtBQUdELEU7O0FBQUEsRTs7Ozs7Ozs7Ozs7O0FDbkJEOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxLQUFNRyxjQUFjLDRCQUFnQjtBQUNsQ1AsZ0NBRGtDO0FBRWxDZCxvQ0FGa0M7QUFHbENRLDBDQUhrQztBQUlsQ2pCLDhDQUprQztBQUtsQytCO0FBTGtDLEVBQWhCLENBQXBCOzttQkFRZUQsVzs7Ozs7Ozs7Ozs7O21CQ2ZBLFlBQThCO0FBQUEsT0FBcEIvQixLQUFvQix5REFBZCxJQUFjO0FBQUEsT0FBUmlDLE1BQVE7OztBQUUzQyxXQUFPQSxPQUFPeEMsSUFBZDs7QUFFQyxVQUFLLGlCQUFMO0FBQ0UsY0FBT3dDLE9BQU92QyxPQUFkO0FBQ0E7QUFKSDtBQU1BLFVBQU9NLEtBQVA7QUFDRCxFOzs7Ozs7Ozs7Ozs7bUJDVGMsWUFBOEI7QUFBQSxPQUFwQkEsS0FBb0IseURBQWQsSUFBYztBQUFBLE9BQVJpQyxNQUFROzs7QUFFM0MsV0FBT0EsT0FBT3hDLElBQWQ7O0FBRUMsVUFBSyxlQUFMO0FBQ0UsY0FBT3dDLE9BQU92QyxPQUFkO0FBQ0E7QUFDRixVQUFLLGVBQUw7QUFDRSxjQUFPdUMsT0FBT3ZDLE9BQWQ7QUFDQTtBQUNGLFVBQUssY0FBTDtBQUNFLGNBQU91QyxPQUFPdkMsT0FBZDtBQUNBO0FBVkg7QUFZQSxVQUFPTSxLQUFQO0FBQ0QsRTs7Ozs7Ozs7Ozs7O21CQ1ZjLFlBQVc7QUFDeEIsVUFBTyxDQUNMO0FBQ0VZLFNBQUksQ0FETjtBQUVFUixXQUFNLFVBRlI7QUFHRUMsVUFBSyxLQUhQO0FBSUVDLFVBQUssTUFKUDtBQUtFSCw4QkFMRjtBQU1FSSxrQkFBYTtBQU5mLElBREssRUFTTDtBQUNDSyxTQUFJLENBREw7QUFFRVIsV0FBTSxlQUZSO0FBR0VDLFVBQUssUUFIUDtBQUlFQyxVQUFLLGdCQUpQO0FBS0VILG1DQUxGO0FBTUVJLGtCQUFhO0FBTmYsSUFUSyxFQWlCTDtBQUNDSyxTQUFJLENBREw7QUFFRVIsV0FBTSxXQUZSO0FBR0VDLFVBQUssUUFIUDtBQUlFQyxVQUFLLGdCQUpQO0FBS0VILCtCQUxGO0FBTUVJLGtCQUFhO0FBTmYsSUFqQkssRUF5Qko7QUFDQ0ssU0FBSSxDQURMO0FBRUNSLFdBQU0sU0FGUDtBQUdDQyxVQUFLLE1BSE47QUFJQ0MsVUFBSyxnQkFKTjtBQUtDSCw2QkFMRDtBQU1DSSxrQkFBYTtBQU5kLElBekJJLENBQVA7QUFrQ0QsRTs7QUF4Q0Q7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQXFDQyxFOzs7Ozs7Ozs7Ozs7bUJDL0JjLFlBQVc7O0FBRXRCLE9BQUkyQixRQUFRLElBQUlDLElBQUosRUFBWjtBQUFBLE9BQ0lDLEtBQUtGLE1BQU1HLE9BQU4sRUFEVDtBQUFBLE9BRUlDLEtBQUtKLE1BQU1LLFFBQU4sS0FBaUIsQ0FGMUI7QUFBQSxPQUdJQyxPQUFPTixNQUFNTyxXQUFOLEVBSFg7O0FBS0YsVUFBTyxDQUNMO0FBQ0U3QixTQUFJLENBRE47QUFFRVIsV0FBTSxVQUZSO0FBR0VlLFdBQU0sVUFIUjtBQUlFQyxnQkFBVyxPQUpiO0FBS0VDLGNBQVMsRUFMWDtBQU1FQyxlQUFVLElBTlo7QUFPRWhCLFVBQUssNkJBQVEsQ0FBQ2tDLE9BQUssSUFBTixFQUFZRixLQUFHLENBQWYsRUFBa0JGLEtBQUcsRUFBckIsQ0FBUixDQVBQO0FBUUVqQyw2QkFSRjtBQVNFSSxrQkFBYTtBQVRmLElBREssRUFZTDtBQUNFSyxTQUFJLENBRE47QUFFRVIsV0FBTSxPQUZSO0FBR0VlLFdBQU0sUUFIUjtBQUlFQyxnQkFBVyxTQUpiO0FBS0VDLGNBQVMsQ0FMWDtBQU1FQyxlQUFVLElBTlo7QUFPRWhCLFVBQUssNkJBQVEsQ0FBQ2tDLE9BQUssSUFBTixFQUFZRixLQUFHLENBQWYsRUFBa0JGLEtBQUcsQ0FBckIsQ0FBUixDQVBQO0FBUUVqQyw0QkFSRjtBQVNFSSxrQkFBYTtBQVRmLElBWkssRUF1Qkw7QUFDRUssU0FBSSxDQUROO0FBRUVSLFdBQU0sVUFGUjtBQUdFZSxXQUFNLE9BSFI7QUFJRUMsZ0JBQVcsT0FKYjtBQUtFQyxjQUFTLEVBTFg7QUFNRUMsZUFBVSxJQU5aO0FBT0VoQixVQUFLLDZCQUFRLENBQUNrQyxPQUFLLElBQU4sRUFBWUYsS0FBRyxDQUFmLEVBQWtCRixLQUFHLEVBQXJCLENBQVIsQ0FQUDtBQVFFakMsMkJBUkY7QUFTRUksa0JBQWE7QUFUZixJQXZCSyxFQWtDTDtBQUNFSyxTQUFJLENBRE47QUFFRVIsV0FBTSxRQUZSO0FBR0VlLFdBQU0sVUFIUjtBQUlFQyxnQkFBVyxPQUpiO0FBS0VDLGNBQVMsRUFMWDtBQU1FQyxlQUFVLElBTlo7QUFPRWhCLFVBQUssNkJBQVEsQ0FBQ2tDLE9BQUssSUFBTixFQUFZRixLQUFHLENBQWYsRUFBa0JGLEtBQUcsRUFBckIsQ0FBUixDQVBQO0FBUUVqQyw4QkFSRjtBQVNFSSxrQkFBYTtBQVRmLElBbENLLEVBNkNMO0FBQ0VLLFNBQUksQ0FETjtBQUVFUixXQUFNLE9BRlI7QUFHRWUsV0FBTSxjQUhSO0FBSUVDLGdCQUFXLFFBSmI7QUFLRUMsY0FBUyxFQUxYO0FBTUVDLGVBQVUsSUFOWjtBQU9FaEIsVUFBSyw2QkFBUSxDQUFDa0MsT0FBSyxJQUFOLEVBQVlGLEtBQUcsQ0FBZixFQUFrQkYsS0FBRyxFQUFyQixDQUFSLENBUFA7QUFRRWpDLGtDQVJGO0FBU0VJLGtCQUFhO0FBVGYsSUE3Q0ssRUF3REw7QUFDRUssU0FBSSxDQUROO0FBRUVSLFdBQU0sU0FGUjtBQUdFZSxXQUFNLFVBSFI7QUFJRUMsZ0JBQVcsTUFKYjtBQUtFQyxjQUFTLEVBTFg7QUFNRUMsZUFBVSxJQU5aO0FBT0VoQixVQUFLLDZCQUFRLENBQUNrQyxPQUFLLElBQU4sRUFBWUYsS0FBRyxDQUFmLEVBQWtCRixLQUFHLEVBQXJCLENBQVIsQ0FQUDtBQVFFakMsOEJBUkY7QUFTRUksa0JBQWE7QUFUZixJQXhESyxFQW1FTDtBQUNFSyxTQUFJLENBRE47QUFFRVIsV0FBTSxRQUZSO0FBR0VlLFdBQU0sUUFIUjtBQUlFQyxnQkFBVyxRQUpiO0FBS0VDLGNBQVMsRUFMWDtBQU1FQyxlQUFVLElBTlo7QUFPRWhCLFVBQUssNkJBQVEsQ0FBQ2tDLE9BQUssSUFBTixFQUFZRixLQUFHLENBQWYsRUFBa0JGLEtBQUcsRUFBckIsQ0FBUixDQVBQO0FBUUVqQyw2QkFSRjtBQVNFSSxrQkFBYTtBQVRmLElBbkVLLENBQVA7QUErRUQsRTs7QUEvRkQ7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBd0ZDLEU7Ozs7Ozs7Ozs7Ozs7OztBQy9GRDs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQSxLQUFNbUMsVUFBVSx5RkFBaEI7O0tBRXFCQyxHOzs7Ozs7Ozs7Ozs4QkFDVDtBQUNSLGNBQ0U7QUFBQTtBQUFBLFdBQVEsU0FBU0QsT0FBakI7QUFDRTtBQUFBO0FBQUEsYUFBTyxNQUFLLEdBQVosRUFBZ0IsK0JBQWhCO0FBRUUsb0VBQVkscUJBQVosR0FGRjtBQUdFLCtEQUFPLE1BQUssTUFBWixFQUFtQixxQkFBbkIsR0FIRjtBQUlFLCtEQUFPLE1BQUssaUJBQVosRUFBOEIsMkJBQTlCLEdBSkY7QUFLRSwrREFBTyxNQUFLLEdBQVosRUFBZ0IsNkJBQWhCO0FBTEY7QUFERixRQURGO0FBWUQ7Ozs7R0FkOEIsZ0JBQU1sQyxTOzttQkFBbEJtQyxHOzs7Ozs7Ozs7Ozs7O0FDWnJCOzs7O0FBQ0E7Ozs7QUFFQSxLQUFJQyxVQUFVO0FBQ1ZDLGVBQVk7QUFERixFQUFkOztBQUlPLEtBQU1DLGdDQUFZLFNBQVpBLFNBQVksQ0FBQzVDLEtBQUQ7QUFBQSxVQUN2QjtBQUFBO0FBQUEsT0FBSyxPQUFPMEMsT0FBWjtBQUNFLG1DQUFDLEdBQUQsT0FERjtBQUVHMUMsV0FBTTZDO0FBRlQsSUFEdUI7QUFBQSxFQUFsQjtBQU1QLEtBQU1DLE1BQU0sU0FBTkEsR0FBTTtBQUFBLFVBQ1Y7QUFBQTtBQUFBLE9BQUssV0FBTSx1QkFBWDtBQUNFO0FBQUE7QUFBQSxTQUFLLFdBQU0saUJBQVg7QUFDRTtBQUFBO0FBQUEsV0FBSyxXQUFNLGVBQVg7QUFDRTtBQUFBO0FBQUEsYUFBUSxNQUFLLFFBQWIsRUFBc0IsV0FBTSxlQUE1QixFQUE0QyxlQUFZLFVBQXhELEVBQW1FLGVBQVksV0FBL0U7QUFDRSxtREFBTSxXQUFNLFVBQVosR0FERjtBQUVFLG1EQUFNLFdBQU0sVUFBWixHQUZGO0FBR0UsbURBQU0sV0FBTSxVQUFaO0FBSEY7QUFERjtBQURGLE1BREY7QUFVRTtBQUFBO0FBQUEsU0FBSyxXQUFNLDBCQUFYLEVBQXNDLElBQUcsVUFBekM7QUFDRTtBQUFBO0FBQUEsV0FBSSxXQUFNLGdCQUFWO0FBQ0U7QUFBQTtBQUFBO0FBQUk7QUFBQTtBQUFBLGVBQVcsaUJBQWdCLFFBQTNCLEVBQW9DLElBQUcsR0FBdkM7QUFBQTtBQUFBO0FBQUosVUFERjtBQUVFO0FBQUE7QUFBQTtBQUFJO0FBQUE7QUFBQSxlQUFXLGlCQUFnQixRQUEzQixFQUFvQyxJQUFHLE9BQXZDO0FBQUE7QUFBQTtBQUFKLFVBRkY7QUFHRTtBQUFBO0FBQUE7QUFBSTtBQUFBO0FBQUEsZUFBVyxpQkFBZ0IsUUFBM0IsRUFBb0MsSUFBRyxVQUF2QztBQUFBO0FBQUE7QUFBSjtBQUhGO0FBREY7QUFWRixJQURVO0FBQUEsRUFBWixDOzs7Ozs7Ozs7Ozs7O0FDYkE7Ozs7OztBQUVBLEtBQUlKLFVBQVU7QUFDWEssZUFBWSxFQUREO0FBRVhDLGdCQUFhLEVBRkY7QUFHWEwsZUFBWTtBQUhELEVBQWQ7O0FBTU8sS0FBTU0sc0JBQU8sU0FBUEEsSUFBTztBQUFBLFVBQ2xCO0FBQUE7QUFBQSxPQUFLLE9BQU9QLE9BQVo7QUFDRSw4Q0FERjtBQUVFO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFGRjtBQUdFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFIRixJQURrQjtBQUFBLEVBQWIsQzs7Ozs7Ozs7Ozs7OztBQ1JQOzs7Ozs7QUFFTyxLQUFNUSw4QkFBVyxTQUFYQSxRQUFXO0FBQUEsVUFDdEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQURzQjtBQUFBLEVBQWpCLEM7Ozs7Ozs7Ozs7Ozs7QUNGUDs7OztBQUNBOzs7Ozs7QUFFQSxLQUFJUixVQUFVO0FBQ1hLLGVBQVksRUFERDtBQUVYQyxnQkFBYSxFQUZGO0FBR1hMLGVBQVk7QUFIRCxFQUFkOztBQU1PLEtBQU1RLDRCQUFVLFNBQVZBLE9BQVUsQ0FBQ25ELEtBQUQ7QUFBQSxVQUNyQjtBQUFBO0FBQUEsT0FBSyxPQUFPMEMsT0FBWjtBQUNFLDhDQURGO0FBRUU7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUZGO0FBR0U7QUFIRixJQURxQjtBQUFBLEVBQWhCLEM7Ozs7Ozs7Ozs7Ozs7QUNUUDs7OztBQUNBOzs7Ozs7QUFFQSxLQUFJQSxVQUFVO0FBQ1hLLGVBQVksRUFERDtBQUVYQyxnQkFBYSxFQUZGO0FBR1hMLGVBQVk7QUFIRCxFQUFkOztBQU1PLEtBQU1TLHNCQUFPLFNBQVBBLElBQU87QUFBQSxVQUNsQjtBQUFBO0FBQUEsT0FBSyxPQUFPVixPQUFaO0FBQ0UsOENBREY7QUFFRTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BRkY7QUFHRTtBQUhGLElBRGtCO0FBQUEsRUFBYixDOzs7Ozs7QUNUUDs7QUFFQTs7Ozs7OztBQ0ZBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GLGtEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGtEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMkNBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7OztBQzdFQTs7QUFFQSxvREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixrREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDJDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxXQUFVO0FBQ1Y7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUVBQXdFOztBQUV4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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OztBQUVEO0FBQ0EscUM7Ozs7OztBQzNCQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQSxxQzs7Ozs7OztBQzlEQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0EscUM7Ozs7Ozs7QUMzREE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUM7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQSx3Qzs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0I7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzS0FBcUs7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxRQUFRO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSwwQkFBMEI7QUFDdkMsY0FBYSxhQUFhO0FBQzFCLGNBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUE4QjtBQUM5QixrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGFBQWE7QUFDMUIsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsUUFBUTtBQUNyQixjQUFhLFFBQVE7QUFDckIsY0FBYSwwQkFBMEI7QUFDdkMsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDOzs7Ozs7O0FDdjVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0hBQThIOztBQUU5SDtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkI7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCOztBQUVyQixvQkFBbUIsY0FBYztBQUNqQyxtQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTkFBb04sWUFBWTtBQUNoTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnT0FBK04sK0JBQStCO0FBQzlQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEscURBQW9EO0FBQ3BEO0FBQ0Esd0JBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDOzs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILG1DQUFrQztBQUNsQztBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQseUM7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Qzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDOzs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLDZHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDOzs7Ozs7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEI7QUFDMUIsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSw4QkFBNkIsMkNBQTJDOztBQUV4RTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUM7Ozs7Ozs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFdBQVc7QUFDdEIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QjtBQUNBOztBQUVBO0FBQ0EsY0FBYSx1QkFBdUI7QUFDcEMsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7O0FDbk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLDBEQUEwRDtBQUN2RSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsVUFBVTtBQUN2QixjQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRCx3Qzs7Ozs7OztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQzs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBLGNBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBLDBCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQTZDO0FBQzdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDOzs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxvQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0M7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDOzs7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7O0FBRTVCLDZCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrRDs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsWUFBWTtBQUN2Qjs7QUFFQTtBQUNBLGtDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsZUFBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsVUFBVTtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFdBQVc7QUFDeEIsY0FBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUM7O0FBRUQseUM7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdC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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixnQkFBZ0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0M7Ozs7Ozs7QUMxbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDOzs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDOzs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEM7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5Qzs7Ozs7O0FDbkZBO0FB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Ozs7QUM5SEE7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNIQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNsQkEsbUNBQWtDLG8rZjs7Ozs7O0FDQWxDLG1DQUFrQyx3dW1COzs7Ozs7QUNBbEMsbUNBQWtDLDRtb0I7Ozs7OztBQ0FsQyxtQ0FBa0MsZ2hkOzs7Ozs7QUNBbEMsbUNBQWtDLG8xbUM7Ozs7OztBQ0FsQyxtQ0FBa0MsZ3FvQjs7Ozs7O0FDQWxDLG1DQUFrQyx3MTdDOzs7Ozs7QUNBbEMsa0NBQWlDLG9xeEY7Ozs7OztBQ0FqQyxrQ0FBaUMsbzI1Rjs7Ozs7O0FDQWpDLGtDQUFpQyw0MzZJOzs7Ozs7QUNBakMsa0NBQWlDLG90Z0Y7Ozs7OztBQ0FqQzs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNzljYjcxNjkxYjM4ZjljOWUzYTlcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBBcHAgZnJvbSAnLi9hcHAuanMnXG5pbXBvcnQgc3RvcmUgZnJvbSAnLi4vZGV2L2pzL3N0b3JlJ1xuXG5SZWFjdERPTS5yZW5kZXIoXG4gIDxQcm92aWRlciBzdG9yZT17c3RvcmV9PlxuICAgIDxBcHAgLz5cbiAgPC9Qcm92aWRlcj4sXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290JylcbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy9pbmRleC5qc1xuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAod2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgfTtcblxuICAgIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgICB9XG5cbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSByZWFjdFByb2RJbnZhcmlhbnRcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9yZWFjdFByb2RJbnZhcmlhbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L3JlYWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50VHJlZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbi8qKlxuICogRHJpbGwgZG93biAodGhyb3VnaCBjb21wb3NpdGVzIGFuZCBlbXB0eSBjb21wb25lbnRzKSB1bnRpbCB3ZSBnZXQgYSBob3N0IG9yXG4gKiBob3N0IHRleHQgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgcHJldHR5IHBvbHltb3JwaGljIGJ1dCB1bmF2b2lkYWJsZSB3aXRoIHRoZSBjdXJyZW50IHN0cnVjdHVyZSB3ZSBoYXZlXG4gKiBmb3IgYF9yZW5kZXJlZENoaWxkcmVuYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgdmFyIHJlbmRlcmVkO1xuICB3aGlsZSAocmVuZGVyZWQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gcmVuZGVyZWQ7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBgX2hvc3ROb2RlYCBvbiB0aGUgcmVuZGVyZWQgaG9zdC90ZXh0IGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlblxuICogRE9NIG5vZGUuIFRoZSBwYXNzZWQgYGluc3RgIGNhbiBiZSBhIGNvbXBvc2l0ZS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVOb2RlKGluc3QsIG5vZGUpIHtcbiAgdmFyIGhvc3RJbnN0ID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChpbnN0KTtcbiAgaG9zdEluc3QuX2hvc3ROb2RlID0gbm9kZTtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG5mdW5jdGlvbiB1bmNhY2hlTm9kZShpbnN0KSB7XG4gIHZhciBub2RlID0gaW5zdC5faG9zdE5vZGU7XG4gIGlmIChub2RlKSB7XG4gICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gICAgaW5zdC5faG9zdE5vZGUgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gZWFjaCBjaGlsZCBvZiBgaW5zdGAsIGFzc3VtaW5nIHRoYXQgdGhlIGNoaWxkcmVuXG4gKiBtYXRjaCB1cCB3aXRoIHRoZSBET00gKGVsZW1lbnQpIGNoaWxkcmVuIG9mIGBub2RlYC5cbiAqXG4gKiBXZSBjYWNoZSBlbnRpcmUgbGV2ZWxzIGF0IG9uY2UgdG8gYXZvaWQgYW4gbl4yIHByb2JsZW0gd2hlcmUgd2UgYWNjZXNzIHRoZVxuICogY2hpbGRyZW4gb2YgYSBub2RlIHNlcXVlbnRpYWxseSBhbmQgaGF2ZSB0byB3YWxrIGZyb20gdGhlIHN0YXJ0IHRvIG91ciB0YXJnZXRcbiAqIG5vZGUgZXZlcnkgdGltZS5cbiAqXG4gKiBTaW5jZSB3ZSB1cGRhdGUgYF9yZW5kZXJlZENoaWxkcmVuYCBhbmQgdGhlIGFjdHVhbCBET00gYXQgKHNsaWdodGx5KVxuICogZGlmZmVyZW50IHRpbWVzLCB3ZSBjb3VsZCByYWNlIGhlcmUgYW5kIHNlZSBhIG5ld2VyIGBfcmVuZGVyZWRDaGlsZHJlbmAgdGhhblxuICogdGhlIERPTSBub2RlcyB3ZSBzZWUuIFRvIGF2b2lkIHRoaXMsIFJlYWN0TXVsdGlDaGlsZCBjYWxsc1xuICogYHByZXBhcmVUb01hbmFnZUNoaWxkcmVuYCBiZWZvcmUgd2UgY2hhbmdlIGBfcmVuZGVyZWRDaGlsZHJlbmAsIGF0IHdoaWNoXG4gKiB0aW1lIHRoZSBjb250YWluZXIncyBjaGlsZCBub2RlcyBhcmUgYWx3YXlzIGNhY2hlZCAodW50aWwgaXQgdW5tb3VudHMpLlxuICovXG5mdW5jdGlvbiBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSkge1xuICBpZiAoaW5zdC5fZmxhZ3MgJiBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjaGlsZHJlbiA9IGluc3QuX3JlbmRlcmVkQ2hpbGRyZW47XG4gIHZhciBjaGlsZE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIG91dGVyOiBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3QgPSBjaGlsZHJlbltuYW1lXTtcbiAgICB2YXIgY2hpbGRJRCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY2hpbGRJbnN0KS5fZG9tSUQ7XG4gICAgaWYgKGNoaWxkSUQgPT09IDApIHtcbiAgICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nIHRoaXMgY2hpbGQgaW4gUmVhY3RNdWx0aUNoaWxkOyBza2lwIGl0LlxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFdlIGFzc3VtZSB0aGUgY2hpbGQgbm9kZXMgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjaGlsZCBpbnN0YW5jZXMuXG4gICAgZm9yICg7IGNoaWxkTm9kZSAhPT0gbnVsbDsgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxICYmIGNoaWxkTm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSA9PT0gU3RyaW5nKGNoaWxkSUQpIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBjaGlsZE5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LXRleHQ6ICcgKyBjaGlsZElEICsgJyAnIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBjaGlsZE5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LWVtcHR5OiAnICsgY2hpbGRJRCArICcgJykge1xuICAgICAgICBwcmVjYWNoZU5vZGUoY2hpbGRJbnN0LCBjaGlsZE5vZGUpO1xuICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBET00gY2hpbGRyZW4gd2l0aG91dCBmaW5kaW5nIGFuIElEIG1hdGNoLlxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBlbGVtZW50IHdpdGggSUQgJXMuJywgY2hpbGRJRCkgOiBfcHJvZEludmFyaWFudCgnMzInLCBjaGlsZElEKSA6IHZvaWQgMDtcbiAgfVxuICBpbnN0Ll9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3Q7XG4gIHZhciBpbnN0O1xuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xuICAgIGNsb3Nlc3QgPSBpbnN0O1xuICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgaW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAoaW5zdCAhPSBudWxsICYmIGluc3QuX2hvc3ROb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgIShpbnN0Ll9ob3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG5cbiAgaWYgKGluc3QuX2hvc3ROb2RlKSB7XG4gICAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIERPTSBub2RlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIWluc3QuX2hvc3ROb2RlKSB7XG4gICAgcGFyZW50cy5wdXNoKGluc3QpO1xuICAgICFpbnN0Ll9ob3N0UGFyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0IERPTSB0cmVlIHJvb3Qgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbm9kZSByZWZlcmVuY2UuJykgOiBfcHJvZEludmFyaWFudCgnMzQnKSA6IHZvaWQgMDtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuXG4gIC8vIE5vdyBwYXJlbnRzIGNvbnRhaW5zIGVhY2ggYW5jZXN0b3IgdGhhdCBkb2VzICpub3QqIGhhdmUgYSBjYWNoZWQgbmF0aXZlXG4gIC8vIG5vZGUsIGFuZCBgaW5zdGAgaXMgdGhlIGRlZXBlc3QgYW5jZXN0b3IgdGhhdCBkb2VzLlxuICBmb3IgKDsgcGFyZW50cy5sZW5ndGg7IGluc3QgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIGluc3QuX2hvc3ROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHtcbiAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlLFxuICBwcmVjYWNoZUNoaWxkTm9kZXM6IHByZWNhY2hlQ2hpbGROb2RlcyxcbiAgcHJlY2FjaGVOb2RlOiBwcmVjYWNoZU5vZGUsXG4gIHVuY2FjaGVOb2RlOiB1bmNhY2hlTm9kZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJvdXRlcldhcm5pbmc7XG5leHBvcnRzLl9yZXNldFdhcm5lZCA9IF9yZXNldFdhcm5lZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3YXJuZWQgPSB7fTtcblxuZnVuY3Rpb24gcm91dGVyV2FybmluZyhmYWxzZVRvV2FybiwgbWVzc2FnZSkge1xuICAvLyBPbmx5IGlzc3VlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIG9uY2UuXG4gIGlmIChtZXNzYWdlLmluZGV4T2YoJ2RlcHJlY2F0ZWQnKSAhPT0gLTEpIHtcbiAgICBpZiAod2FybmVkW21lc3NhZ2VdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAnW3JlYWN0LXJvdXRlcl0gJyArIG1lc3NhZ2U7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBfd2FybmluZzIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFtmYWxzZVRvV2FybiwgbWVzc2FnZV0uY29uY2F0KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gX3Jlc2V0V2FybmVkKCkge1xuICB3YXJuZWQgPSB7fTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3JvdXRlcldhcm5pbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2ludmFyaWFudC9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RydW1lbnRhdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnVG9vbCA9IG51bGw7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdERlYnVnVG9vbCA9IHJlcXVpcmUoJy4vUmVhY3REZWJ1Z1Rvb2wnKTtcbiAgZGVidWdUb29sID0gUmVhY3REZWJ1Z1Rvb2w7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWJ1Z1Rvb2w6IGRlYnVnVG9vbCB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRUcmVlSG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaXNOYXRpdmUoZm4pIHtcbiAgLy8gQmFzZWQgb24gaXNOYXRpdmUoKSBmcm9tIExvZGFzaFxuICB2YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmdcbiAgLy8gVGFrZSBhbiBleGFtcGxlIG5hdGl2ZSBmdW5jdGlvbiBzb3VyY2UgZm9yIGNvbXBhcmlzb25cbiAgLmNhbGwoaGFzT3duUHJvcGVydHkpXG4gIC8vIFN0cmlwIHJlZ2V4IGNoYXJhY3RlcnMgc28gd2UgY2FuIHVzZSBpdCBmb3IgcmVnZXhcbiAgLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLy8gUmVtb3ZlIGhhc093blByb3BlcnR5IGZyb20gdGhlIHRlbXBsYXRlIHRvIG1ha2UgaXQgZ2VuZXJpY1xuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSBmdW5jVG9TdHJpbmcuY2FsbChmbik7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cbi8vIEFycmF5LmZyb21cbnR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nICYmXG4vLyBNYXBcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxuLy8gTWFwLnByb3RvdHlwZS5rZXlzXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXG4vLyBTZXRcbnR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0KSAmJlxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xuXG52YXIgaXRlbU1hcDtcbnZhciByb290SURTZXQ7XG5cbnZhciBpdGVtQnlLZXk7XG52YXIgcm9vdEJ5S2V5O1xuXG5pZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgaXRlbU1hcCA9IG5ldyBNYXAoKTtcbiAgcm9vdElEU2V0ID0gbmV3IFNldCgpO1xufSBlbHNlIHtcbiAgaXRlbUJ5S2V5ID0ge307XG4gIHJvb3RCeUtleSA9IHt9O1xufVxuXG52YXIgdW5tb3VudGVkSURzID0gW107XG5cbi8vIFVzZSBub24tbnVtZXJpYyBrZXlzIHRvIHByZXZlbnQgVjggcGVyZm9ybWFuY2UgaXNzdWVzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuZnVuY3Rpb24gZ2V0S2V5RnJvbUlEKGlkKSB7XG4gIHJldHVybiAnLicgKyBpZDtcbn1cbmZ1bmN0aW9uIGdldElERnJvbUtleShrZXkpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGtleS5zdWJzdHIoMSksIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0KGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJldHVybiBpdGVtTWFwLmdldChpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcmV0dXJuIGl0ZW1CeUtleVtrZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICBpdGVtTWFwWydkZWxldGUnXShpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcbiAgdmFyIGl0ZW0gPSB7XG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgdGV4dDogbnVsbCxcbiAgICBjaGlsZElEczogW10sXG4gICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICB1cGRhdGVDb3VudDogMFxuICB9O1xuXG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIGl0ZW1NYXAuc2V0KGlkLCBpdGVtKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBpdGVtQnlLZXlba2V5XSA9IGl0ZW07XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm9vdChpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByb290SURTZXQuYWRkKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByb290QnlLZXlba2V5XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUm9vdChpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByb290SURTZXRbJ2RlbGV0ZSddKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZElEcygpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaXRlbU1hcC5rZXlzKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RJRHMoKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3RJRFNldC5rZXlzKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290QnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1cmdlRGVlcChpZCkge1xuICB2YXIgaXRlbSA9IGdldChpZCk7XG4gIGlmIChpdGVtKSB7XG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcblxuICAgIHJlbW92ZShpZCk7XG4gICAgY2hpbGRJRHMuZm9yRWFjaChwdXJnZURlZXApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIG5hbWUgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcjZW1wdHknO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyN0ZXh0JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVJRChpZCkge1xuICB2YXIgbmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpO1xuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVySUQpIHtcbiAgICBvd25lck5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQsICdSZWFjdENvbXBvbmVudFRyZWVIb29rOiBNaXNzaW5nIFJlYWN0IGVsZW1lbnQgZm9yIGRlYnVnSUQgJXMgd2hlbiAnICsgJ2J1aWxkaW5nIHN0YWNrJywgaWQpIDogdm9pZCAwO1xuICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZSwgb3duZXJOYW1lKTtcbn1cblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSB7XG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpZCwgbmV4dENoaWxkSURzKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGl0ZW0uY2hpbGRJRHMgPSBuZXh0Q2hpbGRJRHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRDaGlsZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHRDaGlsZElEID0gbmV4dENoaWxkSURzW2ldO1xuICAgICAgdmFyIG5leHRDaGlsZCA9IGdldChuZXh0Q2hpbGRJRCk7XG4gICAgICAhbmV4dENoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvb2sgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQwJykgOiB2b2lkIDA7XG4gICAgICAhKG5leHRDaGlsZC5jaGlsZElEcyAhPSBudWxsIHx8IHR5cGVvZiBuZXh0Q2hpbGQuZWxlbWVudCAhPT0gJ29iamVjdCcgfHwgbmV4dENoaWxkLmVsZW1lbnQgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25TZXRDaGlsZHJlbigpIHRvIGZpcmUgZm9yIGEgY29udGFpbmVyIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDEnKSA6IHZvaWQgMDtcbiAgICAgICFuZXh0Q2hpbGQuaXNNb3VudGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uTW91bnRDb21wb25lbnQoKSB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzcxJykgOiB2b2lkIDA7XG4gICAgICBpZiAobmV4dENoaWxkLnBhcmVudElEID09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkLnBhcmVudElEID0gaWQ7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSBidXQgbW91bnRpbmcgYSBuZXcgcm9vdCBkdXJpbmcgaW5cbiAgICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGN1cnJlbnRseSBjYXVzZXMgbm90LXlldC1tb3VudGVkIGNvbXBvbmVudHMgdG9cbiAgICAgICAgLy8gYmUgcHVyZ2VkIGZyb20gb3VyIHRyZWUgZGF0YSBzbyB0aGVpciBwYXJlbnQgSUQgaXMgbWlzc2luZy5cbiAgICAgIH1cbiAgICAgICEobmV4dENoaWxkLnBhcmVudElEID09PSBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25CZWZvcmVNb3VudENvbXBvbmVudCgpIHBhcmVudCBhbmQgb25TZXRDaGlsZHJlbigpIHRvIGJlIGNvbnNpc3RlbnQgKCVzIGhhcyBwYXJlbnRzICVzIGFuZCAlcykuJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogX3Byb2RJbnZhcmlhbnQoJzE0MicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcbiAgICBjcmVhdGUoaWQsIGVsZW1lbnQsIHBhcmVudElEKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpdGVtLmlzTW91bnRlZCA9IHRydWU7XG4gICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgYWRkUm9vdChpZCk7XG4gICAgfVxuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS51cGRhdGVDb3VudCsrO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBgaXRlbWAgbWlnaHQgbm90IGV4aXN0IGlmIGl0IGlzIGluc2lkZSBhbiBlcnJvciBib3VuZGFyeSwgYW5kIGEgc2libGluZ1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnkgY2hpbGQgdGhyZXcgd2hpbGUgbW91bnRpbmcuIFRoZW4gdGhpcyBpbnN0YW5jZSBuZXZlclxuICAgICAgLy8gZ290IGEgY2hhbmNlIHRvIG1vdW50LCBidXQgaXQgc3RpbGwgZ2V0cyBhbiB1bm1vdW50aW5nIGV2ZW50IGR1cmluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGNsZWFudXAuXG4gICAgICBpdGVtLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJlbW92ZVJvb3QoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMucHVzaChpZCk7XG4gIH0sXG4gIHB1cmdlVW5tb3VudGVkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdENvbXBvbmVudFRyZWVIb29rLl9wcmV2ZW50UHVyZ2luZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRlZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gdW5tb3VudGVkSURzW2ldO1xuICAgICAgcHVyZ2VEZWVwKGlkKTtcbiAgICB9XG4gICAgdW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5pc01vdW50ZWQgOiBmYWxzZTtcbiAgfSxcbiAgZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW06IGZ1bmN0aW9uICh0b3BFbGVtZW50KSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodG9wRWxlbWVudCkge1xuICAgICAgdmFyIHR5cGUgPSB0b3BFbGVtZW50LnR5cGU7XG4gICAgICB2YXIgbmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgOiB0eXBlO1xuICAgICAgdmFyIG93bmVyID0gdG9wRWxlbWVudC5fb3duZXI7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSB8fCAnVW5rbm93bicsIHRvcEVsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xuXG4gICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGlkKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0U3RhY2tBZGRlbmR1bUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgd2hpbGUgKGlkKSB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlSUQoaWQpO1xuICAgICAgaWQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmNoaWxkSURzIDogW107XG4gIH0sXG4gIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpO1xuICB9LFxuICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICB9LFxuICBnZXRPd25lcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Ll9vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Ll9vd25lci5fZGVidWdJRDtcbiAgfSxcbiAgZ2V0UGFyZW50SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICB2YXIgZWxlbWVudCA9IGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50Ll9zb3VyY2UgOiBudWxsO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sXG4gIGdldFRleHQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnICsgZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBnZXRVcGRhdGVDb3VudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS51cGRhdGVDb3VudCA6IDA7XG4gIH0sXG5cblxuICBnZXRSZWdpc3RlcmVkSURzOiBnZXRSZWdpc3RlcmVkSURzLFxuXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuICAgIHZhciBzaGFkb3dDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pID8gcHJvcHMuY2hpbGRyZW4uc2xpY2UoMCkgOiBwcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2hhZG93Q2hpbGRyZW4nLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzaGFkb3dDaGlsZHJlblxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPSBzaGFkb3dDaGlsZHJlbjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgICAgY29uZmlnLl9fcHJvdG9fXyA9PSBudWxsIHx8IGNvbmZpZy5fX3Byb3RvX18gPT09IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAnUmVhY3QuY3JlYXRlRWxlbWVudCguLi4pOiBFeHBlY3RlZCBwcm9wcyBhcmd1bWVudCB0byBiZSBhIHBsYWluIG9iamVjdC4gJyArICdQcm9wZXJ0aWVzIGRlZmluZWQgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgICAgY29uZmlnLl9fcHJvdG9fXyA9PSBudWxsIHx8IGNvbmZpZy5fX3Byb3RvX18gPT09IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAnUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IEV4cGVjdGVkIHByb3BzIGFyZ3VtZW50IHRvIGJlIGEgcGxhaW4gb2JqZWN0LiAnICsgJ1Byb3BlcnRpZXMgZGVmaW5lZCBpbiBpdHMgcHJvdG90eXBlIGNoYWluIHdpbGwgYmUgaWdub3JlZC4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxuUmVhY3RFbGVtZW50LlJFQUNUX0VMRU1FTlRfVFlQRSA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi93YXJuaW5nL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdEZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGRpcnR5Q29tcG9uZW50cyA9IFtdO1xudmFyIHVwZGF0ZUJhdGNoTnVtYmVyID0gMDtcbnZhciBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG52YXIgYXNhcEVucXVldWVkID0gZmFsc2U7XG5cbnZhciBiYXRjaGluZ1N0cmF0ZWd5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlSW5qZWN0ZWQoKSB7XG4gICEoUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gJiYgYmF0Y2hpbmdTdHJhdGVneSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IGluamVjdCBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcyBhbmQgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjMnKSA6IHZvaWQgMDtcbn1cblxudmFyIE5FU1RFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCAhPT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gQWRkaXRpb25hbCB1cGRhdGVzIHdlcmUgZW5xdWV1ZWQgYnkgY29tcG9uZW50RGlkVXBkYXRlIGhhbmRsZXJzIG9yXG4gICAgICAvLyBzaW1pbGFyOyBiZWZvcmUgb3VyIG93biBVUERBVEVfUVVFVUVJTkcgd3JhcHBlciBjbG9zZXMsIHdlIHdhbnQgdG8gcnVuXG4gICAgICAvLyB0aGVzZSBuZXcgdXBkYXRlcyBzbyB0aGF0IGlmIEEncyBjb21wb25lbnREaWRVcGRhdGUgY2FsbHMgc2V0U3RhdGUgb25cbiAgICAgIC8vIEIsIEIgd2lsbCB1cGRhdGUgYmVmb3JlIHRoZSBjYWxsYmFjayBBJ3MgdXBkYXRlciBwcm92aWRlZCB3aGVuIGNhbGxpbmdcbiAgICAgIC8vIHNldFN0YXRlLlxuICAgICAgZGlydHlDb21wb25lbnRzLnNwbGljZSgwLCB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCk7XG4gICAgICBmbHVzaEJhdGNoZWRVcGRhdGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFVQREFURV9RVUVVRUlORyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5yZXNldCgpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW05FU1RFRF9VUERBVEVTLCBVUERBVEVfUVVFVUVJTkddO1xuXG5mdW5jdGlvbiBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL3RydWUpO1xufVxuXG5fYXNzaWduKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhKSB7XG4gICAgLy8gRXNzZW50aWFsbHkgY2FsbHMgYHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybShtZXRob2QsIHNjb3BlLCBhKWBcbiAgICAvLyB3aXRoIHRoaXMgdHJhbnNhY3Rpb24ncyB3cmFwcGVycyBhcm91bmQgaXQuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLk1peGluLnBlcmZvcm0uY2FsbCh0aGlzLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0sIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sIG1ldGhvZCwgc2NvcGUsIGEpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byBtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBfcHJvZEludmFyaWFudCgnMTI0JywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IHZvaWQgMDtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnRPcmRlckNvbXBhcmF0b3IpO1xuXG4gIC8vIEFueSB1cGRhdGVzIGVucXVldWVkIHdoaWxlIHJlY29uY2lsaW5nIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIHRoaXMgZW50aXJlXG4gIC8vIGJhdGNoLiBPdGhlcndpc2UsIGlmIGRpcnR5Q29tcG9uZW50cyBpcyBbQSwgQl0gd2hlcmUgQSBoYXMgY2hpbGRyZW4gQiBhbmRcbiAgLy8gQywgQiBjb3VsZCB1cGRhdGUgdHdpY2UgaW4gYSBzaW5nbGUgYmF0Y2ggaWYgQydzIHJlbmRlciBlbnF1ZXVlcyBhbiB1cGRhdGVcbiAgLy8gdG8gQiAoc2luY2UgQiB3b3VsZCBoYXZlIGFscmVhZHkgdXBkYXRlZCwgd2Ugc2hvdWxkIHNraXAgaXQsIGFuZCB0aGUgb25seVxuICAvLyB3YXkgd2UgY2FuIGtub3cgdG8gZG8gc28gaXMgYnkgY2hlY2tpbmcgdGhlIGJhdGNoIGNvdW50ZXIpLlxuICB1cGRhdGVCYXRjaE51bWJlcisrO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXG4gICAgLy8gdGhhdCBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaXMgYSBub29wLlxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG5cbiAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcbiAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICB2YXIgbWFya2VyTmFtZTtcbiAgICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgICB2YXIgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAvLyBEdWNrIHR5cGUgVG9wTGV2ZWxXcmFwcGVyLiBUaGlzIGlzIHByb2JhYmx5IGFsd2F5cyB0cnVlLlxuICAgICAgaWYgKGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQucHJvcHMgPT09IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgdXBkYXRlOiAnICsgbmFtZWRDb21wb25lbnQuZ2V0TmFtZSgpO1xuICAgICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpO1xuXG4gICAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICBpZiAoY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsKSB7XG4gICAgY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9IHVwZGF0ZUJhdGNoTnVtYmVyICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmV1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjUnKSA6IHZvaWQgMDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IF9wcm9kSW52YXJpYW50KCcxMjYnKSA6IHZvaWQgMDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIGluamVjdEJhdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uIChfYmF0Y2hpbmdTdHJhdGVneSkge1xuICAgICFfYmF0Y2hpbmdTdHJhdGVneSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTI3JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogX3Byb2RJbnZhcmlhbnQoJzEyOCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBfcHJvZEludmFyaWFudCgnMTI5JykgOiB2b2lkIDA7XG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xuICB9XG59O1xuXG52YXIgUmVhY3RVcGRhdGVzID0ge1xuICAvKipcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBudWxsLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgZW5xdWV1ZVVwZGF0ZTogZW5xdWV1ZVVwZGF0ZSxcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb24sXG4gIGFzYXA6IGFzYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50Q29uc3RhbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IGtleU1pcnJvcih7IGJ1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsIH0pO1xuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzID0ga2V5TWlycm9yKHtcbiAgdG9wQWJvcnQ6IG51bGwsXG4gIHRvcEFuaW1hdGlvbkVuZDogbnVsbCxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBudWxsLFxuICB0b3BBbmltYXRpb25TdGFydDogbnVsbCxcbiAgdG9wQmx1cjogbnVsbCxcbiAgdG9wQ2FuUGxheTogbnVsbCxcbiAgdG9wQ2FuUGxheVRocm91Z2g6IG51bGwsXG4gIHRvcENoYW5nZTogbnVsbCxcbiAgdG9wQ2xpY2s6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiBudWxsLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiBudWxsLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogbnVsbCxcbiAgdG9wQ29udGV4dE1lbnU6IG51bGwsXG4gIHRvcENvcHk6IG51bGwsXG4gIHRvcEN1dDogbnVsbCxcbiAgdG9wRG91YmxlQ2xpY2s6IG51bGwsXG4gIHRvcERyYWc6IG51bGwsXG4gIHRvcERyYWdFbmQ6IG51bGwsXG4gIHRvcERyYWdFbnRlcjogbnVsbCxcbiAgdG9wRHJhZ0V4aXQ6IG51bGwsXG4gIHRvcERyYWdMZWF2ZTogbnVsbCxcbiAgdG9wRHJhZ092ZXI6IG51bGwsXG4gIHRvcERyYWdTdGFydDogbnVsbCxcbiAgdG9wRHJvcDogbnVsbCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IG51bGwsXG4gIHRvcEVtcHRpZWQ6IG51bGwsXG4gIHRvcEVuY3J5cHRlZDogbnVsbCxcbiAgdG9wRW5kZWQ6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEludmFsaWQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTG9hZGVkRGF0YTogbnVsbCxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IG51bGwsXG4gIHRvcExvYWRTdGFydDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BQYXVzZTogbnVsbCxcbiAgdG9wUGxheTogbnVsbCxcbiAgdG9wUGxheWluZzogbnVsbCxcbiAgdG9wUHJvZ3Jlc3M6IG51bGwsXG4gIHRvcFJhdGVDaGFuZ2U6IG51bGwsXG4gIHRvcFJlc2V0OiBudWxsLFxuICB0b3BTY3JvbGw6IG51bGwsXG4gIHRvcFNlZWtlZDogbnVsbCxcbiAgdG9wU2Vla2luZzogbnVsbCxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BTdGFsbGVkOiBudWxsLFxuICB0b3BTdWJtaXQ6IG51bGwsXG4gIHRvcFN1c3BlbmQ6IG51bGwsXG4gIHRvcFRleHRJbnB1dDogbnVsbCxcbiAgdG9wVGltZVVwZGF0ZTogbnVsbCxcbiAgdG9wVG91Y2hDYW5jZWw6IG51bGwsXG4gIHRvcFRvdWNoRW5kOiBudWxsLFxuICB0b3BUb3VjaE1vdmU6IG51bGwsXG4gIHRvcFRvdWNoU3RhcnQ6IG51bGwsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IG51bGwsXG4gIHRvcFZvbHVtZUNoYW5nZTogbnVsbCxcbiAgdG9wV2FpdGluZzogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50cztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q3VycmVudE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDdXJyZW50T3duZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gJyArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICAqXG4gICogQHBhcmFtIHtvYmplY3R9IFN5bnRoZXRpY0V2ZW50XG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAgKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMsICcgKyAneW91XFwncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiAnICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xuICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5pc1JlYWN0Q2hpbGRyZW4gPSBpc1JlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCA9IGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbjtcbmV4cG9ydHMuY3JlYXRlUm91dGVzID0gY3JlYXRlUm91dGVzO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzVmFsaWRDaGlsZChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBpc1JlYWN0Q2hpbGRyZW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB8fCBBcnJheS5pc0FycmF5KG9iamVjdCkgJiYgb2JqZWN0LmV2ZXJ5KGlzVmFsaWRDaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlKGRlZmF1bHRQcm9wcywgcHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciByb3V0ZSA9IGNyZWF0ZVJvdXRlKHR5cGUuZGVmYXVsdFByb3BzLCBlbGVtZW50LnByb3BzKTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGRSb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihyb3V0ZS5jaGlsZHJlbiwgcm91dGUpO1xuXG4gICAgaWYgKGNoaWxkUm91dGVzLmxlbmd0aCkgcm91dGUuY2hpbGRSb3V0ZXMgPSBjaGlsZFJvdXRlcztcblxuICAgIGRlbGV0ZSByb3V0ZS5jaGlsZHJlbjtcbiAgfVxuXG4gIHJldHVybiByb3V0ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgcm91dGVzIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBSZWFjdENoaWxkcmVuLiBKU1hcbiAqIHByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgdG8gdmlzdWFsaXplIGhvdyByb3V0ZXMgaW4gdGhlIGhpZXJhcmNoeSBhcmVcbiAqIG5lc3RlZC5cbiAqXG4gKiAgIGltcG9ydCB7IFJvdXRlLCBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiB9IGZyb20gJ3JlYWN0LXJvdXRlcidcbiAqXG4gKiAgIGNvbnN0IHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKFxuICogICAgIDxSb3V0ZSBjb21wb25lbnQ9e0FwcH0+XG4gKiAgICAgICA8Um91dGUgcGF0aD1cImhvbWVcIiBjb21wb25lbnQ9e0Rhc2hib2FyZH0vPlxuICogICAgICAgPFJvdXRlIHBhdGg9XCJuZXdzXCIgY29tcG9uZW50PXtOZXdzRmVlZH0vPlxuICogICAgIDwvUm91dGU+XG4gKiAgIClcbiAqXG4gKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IHVzZWQgd2hlbiB5b3UgcHJvdmlkZSA8Um91dGU+IGNoaWxkcmVuXG4gKiB0byBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFJvdXRlKSB7XG4gIHZhciByb3V0ZXMgPSBbXTtcblxuICBfcmVhY3QyLmRlZmF1bHQuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAvLyBDb21wb25lbnQgY2xhc3NlcyBtYXkgaGF2ZSBhIHN0YXRpYyBjcmVhdGUqIG1ldGhvZC5cbiAgICAgIGlmIChlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KSB7XG4gICAgICAgIHZhciByb3V0ZSA9IGVsZW1lbnQudHlwZS5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpO1xuXG4gICAgICAgIGlmIChyb3V0ZSkgcm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGVzLnB1c2goY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByb3V0ZXMgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0IHdoaWNoXG4gKiBtYXkgYmUgYSBKU1ggcm91dGUsIGEgcGxhaW4gb2JqZWN0IHJvdXRlLCBvciBhbiBhcnJheSBvZiBlaXRoZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhyb3V0ZXMpIHtcbiAgaWYgKGlzUmVhY3RDaGlsZHJlbihyb3V0ZXMpKSB7XG4gICAgcm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGVzKTtcbiAgfSBlbHNlIGlmIChyb3V0ZXMgJiYgIUFycmF5LmlzQXJyYXkocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IFtyb3V0ZXNdO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFBvb2xlZENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBmaXZlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlcixcbiAgZml2ZUFyZ3VtZW50UG9vbGVyOiBmaXZlQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzXG4gKiogbW9kdWxlIGlkID0gMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qKlxuICogQWxsb3dzIGV4dHJhY3Rpb24gb2YgYSBtaW5pZmllZCBrZXkuIExldCdzIHRoZSBidWlsZCBzeXN0ZW0gbWluaWZ5IGtleXNcbiAqIHdpdGhvdXQgbG9zaW5nIHRoZSBhYmlsaXR5IHRvIGR5bmFtaWNhbGx5IHVzZSBrZXkgc3RyaW5ncyBhcyB2YWx1ZXNcbiAqIHRoZW1zZWx2ZXMuIFBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5L3ZhbCBwYWlyIGFuZCBpdCB3aWxsIHJldHVyblxuICogeW91IHRoZSBzdHJpbmcga2V5IG9mIHRoYXQgc2luZ2xlIHJlY29yZC4gU3VwcG9zZSB5b3Ugd2FudCB0byBncmFiIHRoZVxuICogdmFsdWUgZm9yIGEga2V5ICdjbGFzc05hbWUnIGluc2lkZSBvZiBhbiBvYmplY3QuIEtleS92YWwgbWluaWZpY2F0aW9uIG1heVxuICogaGF2ZSBhbGlhc2VkIHRoYXQga2V5IHRvIGJlICd4YTEyJy4ga2V5T2Yoe2NsYXNzTmFtZTogbnVsbH0pIHdpbGwgcmV0dXJuXG4gKiAneGExMicgaW4gdGhhdCBjYXNlLiBSZXNvbHZlIGtleXMgeW91IHdhbnQgdG8gdXNlIG9uY2UgYXQgc3RhcnR1cCB0aW1lLCB0aGVuXG4gKiByZXVzZSB0aG9zZSByZXNvbHV0aW9ucy5cbiAqL1xudmFyIGtleU9mID0gZnVuY3Rpb24ga2V5T2Yob25lS2V5T2JqKSB7XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIG9uZUtleU9iaikge1xuICAgIGlmICghb25lS2V5T2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlPZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2tleU9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucm91dGVzID0gZXhwb3J0cy5yb3V0ZSA9IGV4cG9ydHMuY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50ID0gZXhwb3J0cy5oaXN0b3J5ID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5mYWxzeSA9IGZhbHN5O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIGZ1bmMgPSBfcmVhY3QuUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3Q7XG52YXIgYXJyYXlPZiA9IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZjtcbnZhciBvbmVPZlR5cGUgPSBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZTtcbnZhciBlbGVtZW50ID0gX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50O1xudmFyIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZTtcbnZhciBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcbmZ1bmN0aW9uIGZhbHN5KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICBpZiAocHJvcHNbcHJvcE5hbWVdKSByZXR1cm4gbmV3IEVycm9yKCc8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBzaG91bGQgbm90IGhhdmUgYSBcIicgKyBwcm9wTmFtZSArICdcIiBwcm9wJyk7XG59XG5cbnZhciBoaXN0b3J5ID0gZXhwb3J0cy5oaXN0b3J5ID0gc2hhcGUoe1xuICBsaXN0ZW46IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcHVzaDogZnVuYy5pc1JlcXVpcmVkLFxuICByZXBsYWNlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvQmFjazogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0ZvcndhcmQ6IGZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cbnZhciBjb21wb25lbnQgPSBleHBvcnRzLmNvbXBvbmVudCA9IG9uZU9mVHlwZShbZnVuYywgc3RyaW5nXSk7XG52YXIgY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50cyA9IG9uZU9mVHlwZShbY29tcG9uZW50LCBvYmplY3RdKTtcbnZhciByb3V0ZSA9IGV4cG9ydHMucm91dGUgPSBvbmVPZlR5cGUoW29iamVjdCwgZWxlbWVudF0pO1xudmFyIHJvdXRlcyA9IGV4cG9ydHMucm91dGVzID0gb25lT2ZUeXBlKFtyb3V0ZSwgYXJyYXlPZihyb3V0ZSldKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0ludGVybmFsUHJvcFR5cGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZXh0cmFjdFBhdGggPSBleHRyYWN0UGF0aDtcbmV4cG9ydHMucGFyc2VQYXRoID0gcGFyc2VQYXRoO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBleHRyYWN0UGF0aChzdHJpbmcpIHtcbiAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eaHR0cHM/OlxcL1xcL1teXFwvXSovKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbCkgcmV0dXJuIHN0cmluZztcblxuICByZXR1cm4gc3RyaW5nLnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBleHRyYWN0UGF0aChwYXRoKTtcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShwYXRoID09PSBwYXRobmFtZSwgJ0EgcGF0aCBtdXN0IGJlIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCBvbmx5LCBub3QgYSBmdWxseSBxdWFsaWZpZWQgVVJMIGxpa2UgXCIlc1wiJywgcGF0aCkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgaWYgKHBhdGhuYW1lID09PSAnJykgcGF0aG5hbWUgPSAnLyc7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaFxuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL1BhdGhVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MSxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4NCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4OCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MTAgfCAweDgsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4MjAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gYW4gYXR0cmlidXRlIG5hbWUgd2lsbCByZXR1cm4gdHJ1ZVxuICAgKiBpZiBpdCBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NIHZlcmJhdGltLiBVc2VmdWwgZm9yIGRhdGEtKiBvciBhcmlhLSpcbiAgICogYXR0cmlidXRlcyB3aGVyZSBpdCdzIGltcG9zc2libGUgdG8gZW51bWVyYXRlIGFsbCBvZiB0aGUgcG9zc2libGVcbiAgICogYXR0cmlidXRlIG5hbWVzLFxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXNwYWNlczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIEluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTVByb3BlcnR5TmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01Qcm9wZXJ0eU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBpZiAoZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpIHtcbiAgICAgIERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5wdXNoKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIURPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2luamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdVxcJ3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5IFxcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzQ4JywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yIG51bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXMnLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNTAnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID0gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSAnOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuLyoqXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XG4gKlxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cbiAqICAgdHJ1ZVxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2Zvb2JhciddXG4gKiAgIHVuZGVmaW5lZFxuICpcbiAqIEFsdGhvdWdoIHRoaXMgbWF5IGJlIGNvbmZ1c2luZywgaXQgcGVyZm9ybXMgYmV0dGVyIGluIGdlbmVyYWwuXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1taXNzaW5nXG4gKi9cbnZhciBET01Qcm9wZXJ0eSA9IHtcblxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG4gIFJPT1RfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0cm9vdCcsXG5cbiAgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUixcbiAgQVRUUklCVVRFX05BTUVfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTVByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29tcGlsZVBhdHRlcm4gPSBjb21waWxlUGF0dGVybjtcbmV4cG9ydHMubWF0Y2hQYXR0ZXJuID0gbWF0Y2hQYXR0ZXJuO1xuZXhwb3J0cy5nZXRQYXJhbU5hbWVzID0gZ2V0UGFyYW1OYW1lcztcbmV4cG9ydHMuZ2V0UGFyYW1zID0gZ2V0UGFyYW1zO1xuZXhwb3J0cy5mb3JtYXRQYXR0ZXJuID0gZm9ybWF0UGF0dGVybjtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIF9jb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIHZhciByZWdleHBTb3VyY2UgPSAnJztcbiAgdmFyIHBhcmFtTmFtZXMgPSBbXTtcbiAgdmFyIHRva2VucyA9IFtdO1xuXG4gIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgIGxhc3RJbmRleCA9IDAsXG4gICAgICBtYXRjaGVyID0gLzooW2EtekEtWl8kXVthLXpBLVowLTlfJF0qKXxcXCpcXCp8XFwqfFxcKHxcXCkvZztcbiAgd2hpbGUgKG1hdGNoID0gbWF0Y2hlci5leGVjKHBhdHRlcm4pKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKFteL10rKSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2gobWF0Y2hbMV0pO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqKicpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKC4qKSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyonKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKj8pJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKD86JztcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKScpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKT8nO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKG1hdGNoWzBdKTtcblxuICAgIGxhc3RJbmRleCA9IG1hdGNoZXIubGFzdEluZGV4O1xuICB9XG5cbiAgaWYgKGxhc3RJbmRleCAhPT0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgICByZWdleHBTb3VyY2UgKz0gZXNjYXBlUmVnRXhwKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBwYXR0ZXJuLmxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgIHJlZ2V4cFNvdXJjZTogcmVnZXhwU291cmNlLFxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMsXG4gICAgdG9rZW5zOiB0b2tlbnNcbiAgfTtcbn1cblxudmFyIENvbXBpbGVkUGF0dGVybnNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgaWYgKCFDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0pIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXSA9IF9jb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICByZXR1cm4gQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dO1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIG1hdGNoIGEgcGF0dGVybiBvbiB0aGUgZ2l2ZW4gcGF0aG5hbWUuIFBhdHRlcm5zIG1heSB1c2VcbiAqIHRoZSBmb2xsb3dpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzOlxuICpcbiAqIC0gOnBhcmFtTmFtZSAgICAgTWF0Y2hlcyBhIFVSTCBzZWdtZW50IHVwIHRvIHRoZSBuZXh0IC8sID8sIG9yICMuIFRoZVxuICogICAgICAgICAgICAgICAgICBjYXB0dXJlZCBzdHJpbmcgaXMgY29uc2lkZXJlZCBhIFwicGFyYW1cIlxuICogLSAoKSAgICAgICAgICAgICBXcmFwcyBhIHNlZ21lbnQgb2YgdGhlIFVSTCB0aGF0IGlzIG9wdGlvbmFsXG4gKiAtICogICAgICAgICAgICAgIENvbnN1bWVzIChub24tZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dFxuICogICAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZlxuICogICAgICAgICAgICAgICAgICB0aGVyZSBpcyBub25lXG4gKiAtICoqICAgICAgICAgICAgIENvbnN1bWVzIChncmVlZHkpIGFsbCBjaGFyYWN0ZXJzIHVwIHRvIHRoZSBuZXh0IGNoYXJhY3RlclxuICogICAgICAgICAgICAgICAgICBpbiB0aGUgcGF0dGVybiwgb3IgdG8gdGhlIGVuZCBvZiB0aGUgVVJMIGlmIHRoZXJlIGlzIG5vbmVcbiAqXG4gKiAgVGhlIGZ1bmN0aW9uIGNhbGxzIGNhbGxiYWNrKGVycm9yLCBtYXRjaGVkKSB3aGVuIGZpbmlzaGVkLlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSByZW1haW5pbmdQYXRobmFtZVxuICogLSBwYXJhbU5hbWVzXG4gKiAtIHBhcmFtVmFsdWVzXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwYXRobmFtZSkge1xuICAvLyBFbnN1cmUgcGF0dGVybiBzdGFydHMgd2l0aCBsZWFkaW5nIHNsYXNoIGZvciBjb25zaXN0ZW5jeSB3aXRoIHBhdGhuYW1lLlxuICBpZiAocGF0dGVybi5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIHBhdHRlcm4gPSAnLycgKyBwYXR0ZXJuO1xuICB9XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjIgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICB2YXIgcmVnZXhwU291cmNlID0gX2NvbXBpbGVQYXR0ZXJuMi5yZWdleHBTb3VyY2U7XG4gIHZhciBwYXJhbU5hbWVzID0gX2NvbXBpbGVQYXR0ZXJuMi5wYXJhbU5hbWVzO1xuICB2YXIgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMi50b2tlbnM7XG5cblxuICBpZiAocGF0dGVybi5jaGFyQXQocGF0dGVybi5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgcmVnZXhwU291cmNlICs9ICcvPyc7IC8vIEFsbG93IG9wdGlvbmFsIHBhdGggc2VwYXJhdG9yIGF0IGVuZC5cbiAgfVxuXG4gIC8vIFNwZWNpYWwtY2FzZSBwYXR0ZXJucyBsaWtlICcqJyBmb3IgY2F0Y2gtYWxsIHJvdXRlcy5cbiAgaWYgKHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnJCc7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChuZXcgUmVnRXhwKCdeJyArIHJlZ2V4cFNvdXJjZSwgJ2knKSk7XG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF0Y2hlZFBhdGggPSBtYXRjaFswXTtcbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKG1hdGNoZWRQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lKSB7XG4gICAgLy8gUmVxdWlyZSB0aGF0IHRoZSBtYXRjaCBlbmRzIGF0IGEgcGF0aCBzZXBhcmF0b3IsIGlmIHdlIGRpZG4ndCBtYXRjaFxuICAgIC8vIHRoZSBmdWxsIHBhdGgsIHNvIGFueSByZW1haW5pbmcgcGF0aG5hbWUgaXMgYSBuZXcgcGF0aCBzZWdtZW50LlxuICAgIGlmIChtYXRjaGVkUGF0aC5jaGFyQXQobWF0Y2hlZFBhdGgubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZW1haW5pbmcgcGF0aG5hbWUsIHRyZWF0IHRoZSBwYXRoIHNlcGFyYXRvciBhcyBwYXJ0IG9mXG4gICAgLy8gdGhlIHJlbWFpbmluZyBwYXRobmFtZSBmb3IgcHJvcGVybHkgY29udGludWluZyB0aGUgbWF0Y2guXG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSAnLycgKyByZW1haW5pbmdQYXRobmFtZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVtYWluaW5nUGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lLFxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMsXG4gICAgcGFyYW1WYWx1ZXM6IG1hdGNoLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgJiYgZGVjb2RlVVJJQ29tcG9uZW50KHYpO1xuICAgIH0pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtTmFtZXMocGF0dGVybikge1xuICByZXR1cm4gY29tcGlsZVBhdHRlcm4ocGF0dGVybikucGFyYW1OYW1lcztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyYW1zKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwYXRobmFtZSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwYXJhbU5hbWVzID0gbWF0Y2gucGFyYW1OYW1lcztcbiAgdmFyIHBhcmFtVmFsdWVzID0gbWF0Y2gucGFyYW1WYWx1ZXM7XG5cbiAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gIHBhcmFtTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1OYW1lLCBpbmRleCkge1xuICAgIHBhcmFtc1twYXJhbU5hbWVdID0gcGFyYW1WYWx1ZXNbaW5kZXhdO1xuICB9KTtcblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBwYXR0ZXJuIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC4gVGhyb3dzXG4gKiBpZiB0aGVyZSBpcyBhIGR5bmFtaWMgc2VnbWVudCBvZiB0aGUgcGF0dGVybiBmb3Igd2hpY2ggdGhlcmUgaXMgbm8gcGFyYW0uXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFBhdHRlcm4ocGF0dGVybiwgcGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICB2YXIgX2NvbXBpbGVQYXR0ZXJuMyA9IGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xuXG4gIHZhciB0b2tlbnMgPSBfY29tcGlsZVBhdHRlcm4zLnRva2VucztcblxuICB2YXIgcGFyZW5Db3VudCA9IDAsXG4gICAgICBwYXRobmFtZSA9ICcnLFxuICAgICAgc3BsYXRJbmRleCA9IDA7XG5cbiAgdmFyIHRva2VuID0gdm9pZCAwLFxuICAgICAgcGFyYW1OYW1lID0gdm9pZCAwLFxuICAgICAgcGFyYW1WYWx1ZSA9IHZvaWQgMDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuID09PSAnKicgfHwgdG9rZW4gPT09ICcqKicpIHtcbiAgICAgIHBhcmFtVmFsdWUgPSBBcnJheS5pc0FycmF5KHBhcmFtcy5zcGxhdCkgPyBwYXJhbXMuc3BsYXRbc3BsYXRJbmRleCsrXSA6IHBhcmFtcy5zcGxhdDtcblxuICAgICAgIShwYXJhbVZhbHVlICE9IG51bGwgfHwgcGFyZW5Db3VudCA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ01pc3Npbmcgc3BsYXQgIyVzIGZvciBwYXRoIFwiJXNcIicsIHNwbGF0SW5kZXgsIHBhdHRlcm4pIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHBhcmFtVmFsdWUgIT0gbnVsbCkgcGF0aG5hbWUgKz0gZW5jb2RlVVJJKHBhcmFtVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcoJykge1xuICAgICAgcGFyZW5Db3VudCArPSAxO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcpJykge1xuICAgICAgcGFyZW5Db3VudCAtPSAxO1xuICAgIH0gZWxzZSBpZiAodG9rZW4uY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgIHBhcmFtTmFtZSA9IHRva2VuLnN1YnN0cmluZygxKTtcbiAgICAgIHBhcmFtVmFsdWUgPSBwYXJhbXNbcGFyYW1OYW1lXTtcblxuICAgICAgIShwYXJhbVZhbHVlICE9IG51bGwgfHwgcGFyZW5Db3VudCA+IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ01pc3NpbmcgXCIlc1wiIHBhcmFtZXRlciBmb3IgcGF0aCBcIiVzXCInLCBwYXJhbU5hbWUsIHBhdHRlcm4pIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHBhcmFtVmFsdWUgIT0gbnVsbCkgcGF0aG5hbWUgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRobmFtZSArPSB0b2tlbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUGF0dGVyblV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnB1c2guXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBQVVNIID0gJ1BVU0gnO1xuXG5leHBvcnRzLlBVU0ggPSBQVVNIO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucmVwbGFjZS5cbiAqL1xudmFyIFJFUExBQ0UgPSAnUkVQTEFDRSc7XG5cbmV4cG9ydHMuUkVQTEFDRSA9IFJFUExBQ0U7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBzb21lIG90aGVyIGFjdGlvbiBzdWNoXG4gKiBhcyB1c2luZyBhIGJyb3dzZXIncyBiYWNrL2ZvcndhcmQgYnV0dG9ucyBhbmQvb3IgbWFudWFsbHkgbWFuaXB1bGF0aW5nXG4gKiB0aGUgVVJMIGluIGEgYnJvd3NlcidzIGxvY2F0aW9uIGJhci4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd0V2ZW50SGFuZGxlcnMvb25wb3BzdGF0ZVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBQT1AgPSAnUE9QJztcblxuZXhwb3J0cy5QT1AgPSBQT1A7XG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIFBVU0g6IFBVU0gsXG4gIFJFUExBQ0U6IFJFUExBQ0UsXG4gIFBPUDogUE9QXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUxhenlUcmVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbi8qKlxuICogSW4gSUUgKDgtMTEpIGFuZCBFZGdlLCBhcHBlbmRpbmcgbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBpcyBkcmFtYXRpY2FsbHlcbiAqIGZhc3RlciB0aGFuIGFwcGVuZGluZyBhIGZ1bGwgc3VidHJlZSwgc28gd2UgZXNzZW50aWFsbHkgcXVldWUgdXAgdGhlXG4gKiAuYXBwZW5kQ2hpbGQgY2FsbHMgaGVyZSBhbmQgYXBwbHkgdGhlbSBzbyBlYWNoIG5vZGUgaXMgYWRkZWQgdG8gaXRzIHBhcmVudFxuICogYmVmb3JlIGFueSBjaGlsZHJlbiBhcmUgYWRkZWQuXG4gKlxuICogSW4gb3RoZXIgYnJvd3NlcnMsIGRvaW5nIHNvIGlzIHNsb3dlciBvciBuZXV0cmFsIGNvbXBhcmVkIHRvIHRoZSBvdGhlciBvcmRlclxuICogKGluIEZpcmVmb3gsIHR3aWNlIGFzIHNsb3cpIHNvIHdlIG9ubHkgZG8gdGhpcyBpbnZlcnNpb24gaW4gSUUuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zcGljeWovaW5uZXJodG1sLXZzLWNyZWF0ZWVsZW1lbnQtdnMtY2xvbmVub2RlLlxuICovXG52YXIgZW5hYmxlTGF6eSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnICYmIC9cXGJFZGdlXFwvXFxkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5mdW5jdGlvbiBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSkge1xuICBpZiAoIWVuYWJsZUxhenkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5vZGUgPSB0cmVlLm5vZGU7XG4gIHZhciBjaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnNlcnRUcmVlQmVmb3JlKG5vZGUsIGNoaWxkcmVuW2ldLCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHJlZS5odG1sICE9IG51bGwpIHtcbiAgICBzZXRJbm5lckhUTUwobm9kZSwgdHJlZS5odG1sKTtcbiAgfSBlbHNlIGlmICh0cmVlLnRleHQgIT0gbnVsbCkge1xuICAgIHNldFRleHRDb250ZW50KG5vZGUsIHRyZWUudGV4dCk7XG4gIH1cbn1cblxudmFyIGluc2VydFRyZWVCZWZvcmUgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChwYXJlbnROb2RlLCB0cmVlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZW4ndCBhY3R1YWxseSBwYXJ0IG9mIHRoZSBET00gYWZ0ZXIgaW5zZXJ0aW9uIHNvXG4gIC8vIGFwcGVuZGluZyBjaGlsZHJlbiB3b24ndCB1cGRhdGUgdGhlIERPTS4gV2UgbmVlZCB0byBlbnN1cmUgdGhlIGZyYWdtZW50XG4gIC8vIGlzIHByb3Blcmx5IHBvcHVsYXRlZCBmaXJzdCwgYnJlYWtpbmcgb3V0IG9mIG91ciBsYXp5IGFwcHJvYWNoIGZvciBqdXN0XG4gIC8vIHRoaXMgbGV2ZWwuIEFsc28sIHNvbWUgPG9iamVjdD4gcGx1Z2lucyAobGlrZSBGbGFzaCBQbGF5ZXIpIHdpbGwgcmVhZFxuICAvLyA8cGFyYW0+IG5vZGVzIGltbWVkaWF0ZWx5IHVwb24gaW5zZXJ0aW9uIGludG8gdGhlIERPTSwgc28gPG9iamVjdD5cbiAgLy8gbXVzdCBhbHNvIGJlIHBvcHVsYXRlZCBwcmlvciB0byBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICBpZiAodHJlZS5ub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgfHwgdHJlZS5ub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSAmJiB0cmVlLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgJiYgKHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCB0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpKSB7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGROb2RlLCBuZXdUcmVlKSB7XG4gIG9sZE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3VHJlZS5ub2RlLCBvbGROb2RlKTtcbiAgaW5zZXJ0VHJlZUNoaWxkcmVuKG5ld1RyZWUpO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUNoaWxkKHBhcmVudFRyZWUsIGNoaWxkVHJlZSkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHBhcmVudFRyZWUuY2hpbGRyZW4ucHVzaChjaGlsZFRyZWUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudFRyZWUubm9kZS5hcHBlbmRDaGlsZChjaGlsZFRyZWUubm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVIVE1MKHRyZWUsIGh0bWwpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLmh0bWwgPSBodG1sO1xuICB9IGVsc2Uge1xuICAgIHNldElubmVySFRNTCh0cmVlLm5vZGUsIGh0bWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlVGV4dCh0cmVlLCB0ZXh0KSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS50ZXh0ID0gdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBzZXRUZXh0Q29udGVudCh0cmVlLm5vZGUsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5ub2RlLm5vZGVOYW1lO1xufVxuXG5mdW5jdGlvbiBET01MYXp5VHJlZShub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgaHRtbDogbnVsbCxcbiAgICB0ZXh0OiBudWxsLFxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICB9O1xufVxuXG5ET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlID0gaW5zZXJ0VHJlZUJlZm9yZTtcbkRPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlID0gcmVwbGFjZUNoaWxkV2l0aFRyZWU7XG5ET01MYXp5VHJlZS5xdWV1ZUNoaWxkID0gcXVldWVDaGlsZDtcbkRPTUxhenlUcmVlLnF1ZXVlSFRNTCA9IHF1ZXVlSFRNTDtcbkRPTUxhenlUcmVlLnF1ZXVlVGV4dCA9IHF1ZXVlVGV4dDtcblxubW9kdWxlLmV4cG9ydHMgPSBET01MYXp5VHJlZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRE9NTGF6eVRyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVmID0gcmVxdWlyZSgnLi9SZWFjdFJlZicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gY2FsbCBSZWFjdFJlZi5hdHRhY2hSZWZzIHdpdGggdGhpcyBjb21wb3NpdGUgY29tcG9uZW50LCBzcGxpdCBvdXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpb25zIGluIHRoZSB0cmFuc2FjdGlvbiBtb3VudC1yZWFkeSBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoUmVmcygpIHtcbiAgUmVhY3RSZWYuYXR0YWNoUmVmcyh0aGlzLCB0aGlzLl9jdXJyZW50RWxlbWVudCk7XG59XG5cbnZhciBSZWFjdFJlY29uY2lsZXIgPSB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSB0aGUgY29udGFpbmluZyBob3N0IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVNb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCwgcGFyZW50RGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtYXJrdXAgPSBpbnRlcm5hbEluc3RhbmNlLm1vdW50Q29tcG9uZW50KHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQgdG9cbiAgICogUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAuXG4gICAqL1xuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZS5nZXRIb3N0Tm9kZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgc2FmZWx5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgIGludGVybmFsSW5zdGFuY2UudW5tb3VudENvbXBvbmVudChzYWZlbHkpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGEgY29tcG9uZW50IHVzaW5nIGEgbmV3IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IHByZXZFbGVtZW50ICYmIGNvbnRleHQgPT09IGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIHtcbiAgICAgIC8vIFNpbmNlIGVsZW1lbnRzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBlbGVtZW50LiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhbiBlbGVtZW50IGNyZWF0ZWQgb3V0c2lkZSBhIGNvbXBvc2l0ZSB0byBiZVxuICAgICAgLy8gZGVlcGx5IG11dGF0ZWQgYW5kIHJldXNlZC5cblxuICAgICAgLy8gVE9ETzogQmFpbGluZyBvdXQgZWFybHkgaXMganVzdCBhIHBlcmYgb3B0aW1pemF0aW9uIHJpZ2h0P1xuICAgICAgLy8gVE9ETzogUmVtb3ZpbmcgdGhlIHJldHVybiBzdGF0ZW1lbnQgc2hvdWxkIGFmZmVjdCBjb3JyZWN0bmVzcz9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIG5leHRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVmc0NoYW5nZWQgPSBSZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcbiAgICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgcHJldkVsZW1lbnQpO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGbHVzaCBhbnkgZGlydHkgY2hhbmdlcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyICE9PSB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCdzIGVucXVldWVkIGJhdGNoIG51bWJlciBzaG91bGQgYWx3YXlzIGJlIHRoZSBjdXJyZW50XG4gICAgICAvLyBiYXRjaCBvciB0aGUgZm9sbG93aW5nIG9uZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwgfHwgaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT09IHVwZGF0ZUJhdGNoTnVtYmVyICsgMSwgJ3BlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogVW5leHBlY3RlZCBiYXRjaCBudW1iZXIgKGN1cnJlbnQgJXMsICcgKyAncGVuZGluZyAlcyknLCB1cGRhdGVCYXRjaE51bWJlciwgaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25VcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb25uZWN0ID0gZXhwb3J0cy5Qcm92aWRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9Qcm92aWRlciA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9Qcm92aWRlcicpO1xuXG52YXIgX1Byb3ZpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Byb3ZpZGVyKTtcblxudmFyIF9jb25uZWN0ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2Nvbm5lY3QnKTtcblxudmFyIF9jb25uZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nvbm5lY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZXhwb3J0cy5Qcm92aWRlciA9IF9Qcm92aWRlcjJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5jb25uZWN0ID0gX2Nvbm5lY3QyW1wiZGVmYXVsdFwiXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxudmFyIGdldERpY3Rpb25hcnlLZXkgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV2ZW50UGx1Z2luSHViID0ge1xuXG4gIC8qKlxuICAgKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgaW5qZWN0aW9uOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBgbGlzdGVuZXJgIGF0IGBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxuICAgKi9cbiAgcHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IF9wcm9kSW52YXJpYW50KCc5NCcsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG5cbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldID0gbGlzdGVuZXI7XG5cbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbmV2ZXIgYmUgbnVsbCAtLSB3aGVuIGlzIGl0P1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKi9cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFuay5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTUnKSA6IHZvaWQgMDtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXG4gICAqL1xuICBfX3B1cmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGlzdGVuZXJCYW5rID0ge307XG4gIH0sXG5cbiAgX19nZXRMaXN0ZW5lckJhbms6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJCYW5rO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5IdWI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFByb3BhZ2F0b3JzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHVwd2FyZHMsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBwaGFzZSA9IHVwd2FyZHMgPyBQcm9wYWdhdGlvblBoYXNlcy5idWJibGVkIDogUHJvcGFnYXRpb25QaGFzZXMuY2FwdHVyZWQ7XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBFdmVudFBsdWdpblV0aWxzLmdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VNYXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKi9cblxuLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggRVM2OiB2YXIgUmVhY3RJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcblxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gICAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gICAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHZhbHVlO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZU1hcDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVUlFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyNycpIDogdm9pZCAwO1xuICAgIHZhciBlcnJvclRocm93bjtcbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBjYWxscyB0aHJldy5cbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcbiAgICAgIHJldCA9IG1ldGhvZC5jYWxsKHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cbiAgICAgICAgICAvLyBieSBpbnZva2luZyBgY2xvc2VBbGxgLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SKSB7XG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgLy8gcmVtYWluaW5nIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xuICAgKiB0aGVtIHRoZSByZXNwZWN0aXZlIHJldHVybiB2YWx1ZXMgb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5pbml0W2ldYFxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCkuXG4gICAqL1xuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzI4JykgOiB2b2lkIDA7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgVHJhbnNhY3Rpb24gPSB7XG5cbiAgTWl4aW46IE1peGluLFxuXG4gIC8qKlxuICAgKiBUb2tlbiB0byBsb29rIGZvciB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqL1xuICBPQlNFUlZFRF9FUlJPUjoge31cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29tcG9zZSA9IGV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBleHBvcnRzLmNvbWJpbmVSZWR1Y2VycyA9IGV4cG9ydHMuY3JlYXRlU3RvcmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfY3JlYXRlU3RvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlU3RvcmUpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VycyA9IHJlcXVpcmUoJy4vY29tYmluZVJlZHVjZXJzJyk7XG5cbnZhciBfY29tYmluZVJlZHVjZXJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbWJpbmVSZWR1Y2Vycyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi9iaW5kQWN0aW9uQ3JlYXRvcnMnKTtcblxudmFyIF9iaW5kQWN0aW9uQ3JlYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmluZEFjdGlvbkNyZWF0b3JzKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2FwcGx5TWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5TWlkZGxld2FyZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseU1pZGRsZXdhcmUpO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLypcbiogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuKiBJZiB0aGUgZnVuY3Rpb24gaGFzIGJlZW4gbWluaWZpZWQgYW5kIE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsIHdhcm4gdGhlIHVzZXIuXG4qL1xuZnVuY3Rpb24gaXNDcnVzaGVkKCkge31cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGlzQ3J1c2hlZC5uYW1lID09PSAnc3RyaW5nJyAmJiBpc0NydXNoZWQubmFtZSAhPT0gJ2lzQ3J1c2hlZCcpIHtcbiAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdG9yZSA9IF9jcmVhdGVTdG9yZTJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBfY29tYmluZVJlZHVjZXJzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmJpbmRBY3Rpb25DcmVhdG9ycyA9IF9iaW5kQWN0aW9uQ3JlYXRvcnMyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuYXBwbHlNaWRkbGV3YXJlID0gX2FwcGx5TWlkZGxld2FyZTJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5jb21wb3NlID0gX2NvbXBvc2UyW1wiZGVmYXVsdFwiXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMpO1xuXG52YXIgX2dldFJvdXRlUGFyYW1zID0gcmVxdWlyZSgnLi9nZXRSb3V0ZVBhcmFtcycpO1xuXG52YXIgX2dldFJvdXRlUGFyYW1zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFJvdXRlUGFyYW1zKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBhcnJheSA9IF9SZWFjdCRQcm9wVHlwZXMuYXJyYXk7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSb3V0ZXJDb250ZXh0PiByZW5kZXJzIHRoZSBjb21wb25lbnQgdHJlZSBmb3IgYSBnaXZlbiByb3V0ZXIgc3RhdGVcbiAqIGFuZCBzZXRzIHRoZSBoaXN0b3J5IG9iamVjdCBhbmQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyQ29udGV4dCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGVyQ29udGV4dCcsXG5cblxuICBwcm9wVHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgcm91dGVyOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICBsb2NhdGlvbjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGVzOiBhcnJheS5pc1JlcXVpcmVkLFxuICAgIHBhcmFtczogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgY29tcG9uZW50czogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlRWxlbWVudDogX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnRcbiAgICB9O1xuICB9LFxuXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcm91dGVyID0gX3Byb3BzLnJvdXRlcjtcbiAgICB2YXIgaGlzdG9yeSA9IF9wcm9wcy5oaXN0b3J5O1xuICAgIHZhciBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbjtcblxuICAgIGlmICghcm91dGVyKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2A8Um91dGVyQ29udGV4dD5gIGV4cGVjdHMgYSBgcm91dGVyYCByYXRoZXIgdGhhbiBhIGBoaXN0b3J5YCcpIDogdm9pZCAwO1xuXG4gICAgICByb3V0ZXIgPSBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgICBzZXRSb3V0ZUxlYXZlSG9vazogaGlzdG9yeS5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGVcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHJvdXRlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGxvY2F0aW9uID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShsb2NhdGlvbiwgJ2Bjb250ZXh0LmxvY2F0aW9uYCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGEgcm91dGUgY29tcG9uZW50XFwncyBgcHJvcHMubG9jYXRpb25gIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1hY2Nlc3Npbmdsb2NhdGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGhpc3Rvcnk6IGhpc3RvcnksIGxvY2F0aW9uOiBsb2NhdGlvbiwgcm91dGVyOiByb3V0ZXIgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvcHMuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgaGlzdG9yeSA9IF9wcm9wczIuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBfcHJvcHMyLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZXMgPSBfcHJvcHMyLnJvdXRlcztcbiAgICB2YXIgcGFyYW1zID0gX3Byb3BzMi5wYXJhbXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBfcHJvcHMyLmNvbXBvbmVudHM7XG5cbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XG5cbiAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgZWxlbWVudCA9IGNvbXBvbmVudHMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGVsZW1lbnQsIGNvbXBvbmVudHMsIGluZGV4KSB7XG4gICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHJldHVybiBlbGVtZW50OyAvLyBEb24ndCBjcmVhdGUgbmV3IGNoaWxkcmVuOyB1c2UgdGhlIGdyYW5kY2hpbGRyZW4uXG5cbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2luZGV4XTtcbiAgICAgICAgdmFyIHJvdXRlUGFyYW1zID0gKDAsIF9nZXRSb3V0ZVBhcmFtczIuZGVmYXVsdCkocm91dGUsIHBhcmFtcyk7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBoaXN0b3J5OiBoaXN0b3J5LFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgICAgcm91dGVQYXJhbXM6IHJvdXRlUGFyYW1zLFxuICAgICAgICAgIHJvdXRlczogcm91dGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCgwLCBfUm91dGVVdGlscy5pc1JlYWN0Q2hpbGRyZW4pKGVsZW1lbnQpKSB7XG4gICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWxlbWVudCwgcHJvcCkpIHByb3BzW3Byb3BdID0gZWxlbWVudFtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHR5cGVvZiBjb21wb25lbnRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb21wb25lbnRzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb21wb25lbnRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUga2V5IGFzIGEgcHJvcCB0byBjcmVhdGVFbGVtZW50IHRvIGFsbG93XG4gICAgICAgICAgICAgIC8vIGN1c3RvbSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9ucyB0byBrbm93IHdoaWNoIG5hbWVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAvLyB0aGV5J3JlIHJlbmRlcmluZywgZm9yIGUuZy4gbWF0Y2hpbmcgdXAgdG8gZmV0Y2hlZCBkYXRhLlxuICAgICAgICAgICAgICBlbGVtZW50c1trZXldID0gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzW2tleV0sIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSB9LCBwcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMsIHByb3BzKTtcbiAgICAgIH0sIGVsZW1lbnQpO1xuICAgIH1cblxuICAgICEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSByb290IHJvdXRlIG11c3QgcmVuZGVyIGEgc2luZ2xlIGVsZW1lbnQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlckNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlckNvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNhblVzZU1lbWJyYW5lID0gZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IGZhbHNlO1xuXG4vLyBOby1vcCBieSBkZWZhdWx0LlxudmFyIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KS54KSB7XG4gICAgICBleHBvcnRzLmNhblVzZU1lbWJyYW5lID0gY2FuVXNlTWVtYnJhbmUgPSB0cnVlO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG5cbiAgaWYgKGNhblVzZU1lbWJyYW5lKSB7XG4gICAgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMob2JqZWN0LCBtZXNzYWdlKSB7XG4gICAgICAvLyBXcmFwIHRoZSBkZXByZWNhdGVkIG9iamVjdCBpbiBhIG1lbWJyYW5lIHRvIHdhcm4gb24gcHJvcGVydHkgYWNjZXNzLlxuICAgICAgdmFyIG1lbWJyYW5lID0ge307XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBDYW4ndCB1c2UgZmF0IGFycm93IGhlcmUgYmVjYXVzZSBvZiB1c2Ugb2YgYXJndW1lbnRzIGJlbG93LlxuICAgICAgICAgIG1lbWJyYW5lW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtwcm9wXS5hcHBseShvYmplY3QsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYXJlIG5vbi1lbnVtZXJhYmxlIHRvIHByZXZlbnQgUmVhY3QgZGV2IHRvb2xzIGZyb21cbiAgICAgICAgLy8gc2VlaW5nIHRoZW0gYW5kIGNhdXNpbmcgc3B1cmlvdXMgd2FybmluZ3Mgd2hlbiBhY2Nlc3NpbmcgdGhlbS4gSW5cbiAgICAgICAgLy8gcHJpbmNpcGxlIHRoaXMgY291bGQgYmUgZG9uZSB3aXRoIGEgcHJveHksIGJ1dCBzdXBwb3J0IGZvciB0aGVcbiAgICAgICAgLy8gb3duS2V5cyB0cmFwIG9uIHByb3hpZXMgaXMgbm90IHVuaXZlcnNhbCwgZXZlbiBhbW9uZyBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIG90aGVyd2lzZSBzdXBwb3J0IHByb3hpZXMuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZW1icmFuZSwgcHJvcCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChwcm9wKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gJ2NvbnRpbnVlJykgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZW1icmFuZTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuZXhwb3J0cy5jYW5Vc2VET00gPSBjYW5Vc2VET007XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX3F1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnktc3RyaW5nJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxudmFyIFNFQVJDSF9CQVNFX0tFWSA9ICckc2VhcmNoQmFzZSc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdpZnlRdWVyeShxdWVyeSkge1xuICByZXR1cm4gX3F1ZXJ5U3RyaW5nLnN0cmluZ2lmeShxdWVyeSkucmVwbGFjZSgvJTIwL2csICcrJyk7XG59XG5cbnZhciBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5wYXJzZTtcblxuZnVuY3Rpb24gaXNOZXN0ZWRPYmplY3Qob2JqZWN0KSB7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHApICYmIHR5cGVvZiBvYmplY3RbcF0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iamVjdFtwXSkgJiYgb2JqZWN0W3BdICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgfXJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNyZWF0ZUhpc3RvcnkgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjcmVhdGVcbiAqIGhpc3Rvcnkgb2JqZWN0cyB0aGF0IGtub3cgaG93IHRvIGhhbmRsZSBVUkwgcXVlcmllcy5cbiAqL1xuZnVuY3Rpb24gdXNlUXVlcmllcyhjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcblxuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IG9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBvcHRpb25zLnBhcnNlUXVlcnlTdHJpbmc7XG5cbiAgICBpZiAodHlwZW9mIHN0cmluZ2lmeVF1ZXJ5ICE9PSAnZnVuY3Rpb24nKSBzdHJpbmdpZnlRdWVyeSA9IGRlZmF1bHRTdHJpbmdpZnlRdWVyeTtcblxuICAgIGlmICh0eXBlb2YgcGFyc2VRdWVyeVN0cmluZyAhPT0gJ2Z1bmN0aW9uJykgcGFyc2VRdWVyeVN0cmluZyA9IGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgZnVuY3Rpb24gYWRkUXVlcnkobG9jYXRpb24pIHtcbiAgICAgIGlmIChsb2NhdGlvbi5xdWVyeSA9PSBudWxsKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG5cbiAgICAgICAgbG9jYXRpb24ucXVlcnkgPSBwYXJzZVF1ZXJ5U3RyaW5nKHNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICBsb2NhdGlvbltTRUFSQ0hfQkFTRV9LRVldID0geyBzZWFyY2g6IHNlYXJjaCwgc2VhcmNoQmFzZTogJycgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiBhbGwgdGhlIGJvb2sta2VlcGluZyBoZXJlLCB0aGlzIHNob3VsZCBqdXN0IHN0cmlwIHRoZVxuICAgICAgLy8gc3RyaW5naWZpZWQgcXVlcnkgZnJvbSB0aGUgc2VhcmNoLlxuXG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgICB2YXIgc2VhcmNoQmFzZVNwZWMgPSBsb2NhdGlvbltTRUFSQ0hfQkFTRV9LRVldO1xuICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcXVlcnkgPyBzdHJpbmdpZnlRdWVyeShxdWVyeSkgOiAnJztcbiAgICAgIGlmICghc2VhcmNoQmFzZVNwZWMgJiYgIXF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHN0cmluZ2lmeVF1ZXJ5ICE9PSBkZWZhdWx0U3RyaW5naWZ5UXVlcnkgfHwgIWlzTmVzdGVkT2JqZWN0KHF1ZXJ5KSwgJ3VzZVF1ZXJpZXMgZG9lcyBub3Qgc3RyaW5naWZ5IG5lc3RlZCBxdWVyeSBvYmplY3RzIGJ5IGRlZmF1bHQ7ICcgKyAndXNlIGEgY3VzdG9tIHN0cmluZ2lmeVF1ZXJ5IGZ1bmN0aW9uJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKGxvY2F0aW9uKTtcblxuICAgICAgdmFyIHNlYXJjaEJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2VhcmNoQmFzZVNwZWMgJiYgbG9jYXRpb24uc2VhcmNoID09PSBzZWFyY2hCYXNlU3BlYy5zZWFyY2gpIHtcbiAgICAgICAgc2VhcmNoQmFzZSA9IHNlYXJjaEJhc2VTcGVjLnNlYXJjaEJhc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2hCYXNlID0gbG9jYXRpb24uc2VhcmNoIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VhcmNoID0gc2VhcmNoQmFzZTtcbiAgICAgIGlmIChxdWVyeVN0cmluZykge1xuICAgICAgICBzZWFyY2ggKz0gKHNlYXJjaCA/ICcmJyA6ICc/JykgKyBxdWVyeVN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgKF9leHRlbmRzMiA9IHtcbiAgICAgICAgc2VhcmNoOiBzZWFyY2hcbiAgICAgIH0sIF9leHRlbmRzMltTRUFSQ0hfQkFTRV9LRVldID0geyBzZWFyY2g6IHNlYXJjaCwgc2VhcmNoQmFzZTogc2VhcmNoQmFzZSB9LCBfZXh0ZW5kczIpKTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIF9ydW5UcmFuc2l0aW9uSG9vazJbJ2RlZmF1bHQnXShob29rLCBhZGRRdWVyeShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihhZGRRdWVyeShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnB1c2goYXBwZW5kUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oIXF1ZXJ5LCAndGhlIHF1ZXJ5IGFyZ3VtZW50IHRvIGNyZWF0ZVBhdGggaXMgZGVwcmVjYXRlZDsgdXNlIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgoYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXSghcXVlcnksICd0aGUgcXVlcnkgYXJndW1lbnQgdG8gY3JlYXRlSHJlZiBpcyBkZXByZWNhdGVkOyB1c2UgYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkgfHwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnVsbExvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbYXBwZW5kUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIGlmIChsb2NhdGlvbi5xdWVyeSkge1xuICAgICAgICBmdWxsTG9jYXRpb24ucXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhZGRRdWVyeShmdWxsTG9jYXRpb24pO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgsIHF1ZXJ5KSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCwgeyBxdWVyeTogcXVlcnkgfSkpO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgsIHF1ZXJ5KSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCwgeyBxdWVyeTogcXVlcnkgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgICAgcmVwbGFjZVN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlcGxhY2VTdGF0ZSwgJ3JlcGxhY2VTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcmVwbGFjZSBpbnN0ZWFkJylcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gdXNlUXVlcmllcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERpc2FibGVkSW5wdXRVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRpc2FibGVhYmxlTW91c2VMaXN0ZW5lck5hbWVzID0ge1xuICBvbkNsaWNrOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrOiB0cnVlLFxuICBvbk1vdXNlRG93bjogdHJ1ZSxcbiAgb25Nb3VzZU1vdmU6IHRydWUsXG4gIG9uTW91c2VVcDogdHJ1ZSxcblxuICBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlXG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSBob3N0IGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG5cbiAgICAvLyBDb3B5IHRoZSBwcm9wcywgZXhjZXB0IHRoZSBtb3VzZSBsaXN0ZW5lcnNcbiAgICB2YXIgaG9zdFByb3BzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIWRpc2FibGVhYmxlTW91c2VMaXN0ZW5lck5hbWVzW2tleV0gJiYgcHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBob3N0UHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaXNhYmxlZElucHV0VXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0Rpc2FibGVkSW5wdXRVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5SZWdpc3RyeVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIUV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBFdmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBFdmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIVBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTcnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gUGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OCcsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTknLCBldmVudE5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMCcsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAgICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICAgKiBvbmx5IGluIF9fREVWX18uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAhIUV2ZW50UGx1Z2luT3JkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDEnKSA6IHZvaWQgMDtcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uIChpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyB1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnO1xuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXSB8fCBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBwaGFzZSBpbiBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKCFkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSkge1xuICAgICAgICByZXR1cm4gUGx1Z2luTW9kdWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICB2YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3doZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnd2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ21vdXNld2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdtb3VzZXdoZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggbmVlZHMgdG8gY2FwdHVyZSBhIGRpZmZlcmVudCBtb3VzZSBzY3JvbGwgZXZlbnQuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy90ZXN0cy9zY3JvbGwuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdET01Nb3VzZVNjcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCkge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMgfHwgZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXMnLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnYmx1cicsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXNpbicsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2ZvY3Vzb3V0JywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BCbHVyXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BGb2N1c10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChkZXBlbmRlbmN5LCB0b3BFdmVudE1hcHBpbmdbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBWaWV3cG9ydE1ldHJpY3MgaXMgb25seSB1c2VkIGJ5IFN5bnRoZXRpY01vdXNlL1RvdWNoRXZlbnQgYW5kIG9ubHkgd2hlblxuICAgKiBwYWdlWC9wYWdlWSBpc24ndCBzdXBwb3J0ZWQgKGxlZ2FjeSBicm93c2VycykuXG4gICAqXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvc2Nyb2xsLmh0bWxcbiAgICovXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYXNFdmVudFBhZ2VYWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoYXNFdmVudFBhZ2VYWSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50ICYmICdwYWdlWCcgaW4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICB9XG4gICAgaWYgKCFoYXNFdmVudFBhZ2VYWSAmJiAhaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcbiAgICAgIHZhciByZWZyZXNoID0gVmlld3BvcnRNZXRyaWNzLnJlZnJlc2hTY3JvbGxWYWx1ZXM7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSBrZXlNaXJyb3Ioe1xuICBwcm9wOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBjaGlsZENvbnRleHQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcbiAgfSxcbiAgcGFnZVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQmFzZWQgb24gdGhlIGVzY2FwZS1odG1sIGxpYnJhcnksIHdoaWNoIGlzIHVzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIGJlbG93OlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQW5kcmVhcyBMdWJiZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IFRpYW5jaGVuZyBcIlRpbW90aHlcIiBHdVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbiAqIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4gKiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUgZm9yIGluc2VydGluZyBpbnRvIEhUTUxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkge1xuICBpZiAodHlwZW9mIHRleHQgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyB0aGlzIHNob3J0Y2lyY3VpdCBoZWxwcyBwZXJmIGZvciB0eXBlcyB0aGF0IHdlIGtub3cgd2lsbCBuZXZlciBoYXZlXG4gICAgLy8gc3BlY2lhbCBjaGFyYWN0ZXJzLCBlc3BlY2lhbGx5IGdpdmVuIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIG9mdGVuXG4gICAgLy8gZm9yIG51bWVyaWMgZG9tIGlkcy5cbiAgICByZXR1cm4gJycgKyB0ZXh0O1xuICB9XG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRJbm5lckhUTUxcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgbmV3Tm9kZXMgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkLmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChuZXdOb2Rlc1tpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRUZGKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL3NldElubmVySFRNTC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uIGtleU1pcnJvcihvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAhKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIva2V5TWlycm9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sb29wQXN5bmMgPSBsb29wQXN5bmM7XG5leHBvcnRzLm1hcEFzeW5jID0gbWFwQXN5bmM7XG5mdW5jdGlvbiBsb29wQXN5bmModHVybnMsIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBjdXJyZW50VHVybiA9IDAsXG4gICAgICBpc0RvbmUgPSBmYWxzZTtcbiAgdmFyIHN5bmMgPSBmYWxzZSxcbiAgICAgIGhhc05leHQgPSBmYWxzZSxcbiAgICAgIGRvbmVBcmdzID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaXNEb25lID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIGRvbmVBcmdzID0gW10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNOZXh0ID0gdHJ1ZTtcbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXRlcmF0ZSBpbnN0ZWFkIG9mIHJlY3Vyc2luZyBpZiBwb3NzaWJsZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jID0gdHJ1ZTtcblxuICAgIHdoaWxlICghaXNEb25lICYmIGN1cnJlbnRUdXJuIDwgdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgd29yay5jYWxsKHRoaXMsIGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChpc0RvbmUpIHtcbiAgICAgIC8vIFRoaXMgbWVhbnMgdGhlIGxvb3AgZmluaXNoZWQgc3luY2hyb25vdXNseS5cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGRvbmVBcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFR1cm4gPj0gdHVybnMgJiYgaGFzTmV4dCkge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgbmV4dCgpO1xufVxuXG5mdW5jdGlvbiBtYXBBc3luYyhhcnJheSwgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuXG4gIHZhciBpc0RvbmUgPSBmYWxzZSxcbiAgICAgIGRvbmVDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKSB7XG4gICAgaWYgKGlzRG9uZSkgcmV0dXJuO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG5cbiAgICAgIGlzRG9uZSA9ICsrZG9uZUNvdW50ID09PSBsZW5ndGg7XG5cbiAgICAgIGlmIChpc0RvbmUpIGNhbGxiYWNrKG51bGwsIHZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICB3b3JrKGl0ZW0sIGluZGV4LCBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICBkb25lKGluZGV4LCBlcnJvciwgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0FzeW5jVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yb3V0ZXIgPSBleHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMubG9jYXRpb24gPSBleHBvcnRzLmhpc3RvcnkgPSBleHBvcnRzLmZhbHN5ID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbnZhciBJbnRlcm5hbFByb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9JbnRlcm5hbFByb3BUeXBlcyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZTtcbnZhciBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcbnZhciByb3V0ZXJTaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSBzaGFwZSh7XG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHNldFJvdXRlTGVhdmVIb29rOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGlzQWN0aXZlOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgbG9jYXRpb25TaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IHNoYXBlKHtcbiAgcGF0aG5hbWU6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzZWFyY2g6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzdGF0ZTogb2JqZWN0LFxuICBhY3Rpb246IHN0cmluZy5pc1JlcXVpcmVkLFxuICBrZXk6IHN0cmluZ1xufSk7XG5cbi8vIERlcHJlY2F0ZWQgc3R1ZmYgYmVsb3c6XG5cbnZhciBmYWxzeSA9IGV4cG9ydHMuZmFsc3kgPSBJbnRlcm5hbFByb3BUeXBlcy5mYWxzeTtcbnZhciBoaXN0b3J5ID0gZXhwb3J0cy5oaXN0b3J5ID0gSW50ZXJuYWxQcm9wVHlwZXMuaGlzdG9yeTtcbnZhciBsb2NhdGlvbiA9IGV4cG9ydHMubG9jYXRpb24gPSBsb2NhdGlvblNoYXBlO1xudmFyIGNvbXBvbmVudCA9IGV4cG9ydHMuY29tcG9uZW50ID0gSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50O1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBJbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzO1xudmFyIHJvdXRlID0gZXhwb3J0cy5yb3V0ZSA9IEludGVybmFsUHJvcFR5cGVzLnJvdXRlO1xudmFyIHJvdXRlcyA9IGV4cG9ydHMucm91dGVzID0gSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzO1xudmFyIHJvdXRlciA9IGV4cG9ydHMucm91dGVyID0gcm91dGVyU2hhcGU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHJlY2F0ZVByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHByb3BUeXBlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCAnVGhpcyBwcm9wIHR5cGUgaXMgbm90IGludGVuZGVkIGZvciBleHRlcm5hbCB1c2UsIGFuZCB3YXMgcHJldmlvdXNseSBleHBvcnRlZCBieSBtaXN0YWtlLiBUaGVzZSBpbnRlcm5hbCBwcm9wIHR5cGVzIGFyZSBkZXByZWNhdGVkIGZvciBleHRlcm5hbCB1c2UsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uLicpO1xuICAgIH07XG5cbiAgICB2YXIgZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKHByb3BUeXBlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsICdUaGUgYCcgKyBuYW1lICsgJ2AgcHJvcCB0eXBlIGlzIG5vdyBleHBvcnRlZCBhcyBgJyArIG5hbWUgKyAnU2hhcGVgIHRvIGF2b2lkIG5hbWUgY29uZmxpY3RzLiBUaGlzIGV4cG9ydCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uLicpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLmZhbHN5ID0gZmFsc3kgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGZhbHN5KTtcbiAgICBleHBvcnRzLmhpc3RvcnkgPSBoaXN0b3J5ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShoaXN0b3J5KTtcbiAgICBleHBvcnRzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoY29tcG9uZW50KTtcbiAgICBleHBvcnRzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShjb21wb25lbnRzKTtcbiAgICBleHBvcnRzLnJvdXRlID0gcm91dGUgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHJvdXRlKTtcbiAgICBleHBvcnRzLnJvdXRlcyA9IHJvdXRlcyA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocm91dGVzKTtcblxuICAgIGV4cG9ydHMubG9jYXRpb24gPSBsb2NhdGlvbiA9IGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShsb2NhdGlvbiwgJ2xvY2F0aW9uJyk7XG4gICAgZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXIgPSBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUocm91dGVyLCAncm91dGVyJyk7XG4gIH0pKCk7XG59XG5cbnZhciBkZWZhdWx0RXhwb3J0ID0ge1xuICBmYWxzeTogZmFsc3ksXG4gIGhpc3Rvcnk6IGhpc3RvcnksXG4gIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gIHJvdXRlOiByb3V0ZSxcbiAgLy8gRm9yIHNvbWUgcmVhc29uLCByb3V0ZXMgd2FzIG5ldmVyIGhlcmUuXG4gIHJvdXRlcjogcm91dGVyXG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWZhdWx0RXhwb3J0ID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShkZWZhdWx0RXhwb3J0LCAnVGhlIGRlZmF1bHQgZXhwb3J0IGZyb20gYHJlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBuYW1lZCBleHBvcnRzIGluc3RlYWQuJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRFeHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvQWN0aW9ucycpO1xuXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMiA9IHJlcXVpcmUoJy4vY29tcHV0ZUNoYW5nZWRSb3V0ZXMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wdXRlQ2hhbmdlZFJvdXRlczIpO1xuXG52YXIgX1RyYW5zaXRpb25VdGlscyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvblV0aWxzJyk7XG5cbnZhciBfaXNBY3RpdmUyID0gcmVxdWlyZSgnLi9pc0FjdGl2ZScpO1xuXG52YXIgX2lzQWN0aXZlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQWN0aXZlMik7XG5cbnZhciBfZ2V0Q29tcG9uZW50cyA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50cycpO1xuXG52YXIgX2dldENvbXBvbmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29tcG9uZW50cyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMgPSByZXF1aXJlKCcuL21hdGNoUm91dGVzJyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hSb3V0ZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBoYXNBbnlQcm9wZXJ0aWVzKG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKGhpc3RvcnksIHJvdXRlcykge1xuICB2YXIgc3RhdGUgPSB7fTtcblxuICAvLyBTaWduYXR1cmUgc2hvdWxkIGJlIChsb2NhdGlvbiwgaW5kZXhPbmx5KSwgYnV0IG5lZWRzIHRvIHN1cHBvcnQgKHBhdGgsXG4gIC8vIHF1ZXJ5LCBpbmRleE9ubHkpXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKGxvY2F0aW9uKSB7XG4gICAgdmFyIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRlcHJlY2F0ZWRJbmRleE9ubHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gICAgdmFyIGluZGV4T25seSA9IHZvaWQgMDtcbiAgICBpZiAoaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgJiYgaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgIT09IHRydWUgfHwgZGVwcmVjYXRlZEluZGV4T25seSAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgaXNBY3RpdmUocGF0aG5hbWUsIHF1ZXJ5LCBpbmRleE9ubHkpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBgaXNBY3RpdmUobG9jYXRpb24sIGluZGV4T25seSlgIHdpdGggYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcbiAgICAgIGxvY2F0aW9uID0geyBwYXRobmFtZTogbG9jYXRpb24sIHF1ZXJ5OiBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSB9O1xuICAgICAgaW5kZXhPbmx5ID0gZGVwcmVjYXRlZEluZGV4T25seSB8fCBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgIGluZGV4T25seSA9IGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2lzQWN0aXZlMy5kZWZhdWx0KShsb2NhdGlvbiwgaW5kZXhPbmx5LCBzdGF0ZS5sb2NhdGlvbiwgc3RhdGUucm91dGVzLCBzdGF0ZS5wYXJhbXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb25Gcm9tUmVkaXJlY3RJbmZvKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIF9BY3Rpb25zLlJFUExBQ0UpO1xuICB9XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gbWF0Y2gobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHBhcnRpYWxOZXh0U3RhdGUgJiYgcGFydGlhbE5leHRTdGF0ZS5sb2NhdGlvbiA9PT0gbG9jYXRpb24pIHtcbiAgICAgIC8vIENvbnRpbnVlIGZyb20gd2hlcmUgd2UgbGVmdCBvZmYuXG4gICAgICBmaW5pc2hNYXRjaChwYXJ0aWFsTmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICgwLCBfbWF0Y2hSb3V0ZXMyLmRlZmF1bHQpKHJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICBmaW5pc2hNYXRjaChfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE1hdGNoKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzID0gKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIG5leHRTdGF0ZSk7XG5cbiAgICB2YXIgbGVhdmVSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMubGVhdmVSb3V0ZXM7XG4gICAgdmFyIGNoYW5nZVJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5jaGFuZ2VSb3V0ZXM7XG4gICAgdmFyIGVudGVyUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmVudGVyUm91dGVzO1xuXG5cbiAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5MZWF2ZUhvb2tzKShsZWF2ZVJvdXRlcywgc3RhdGUpO1xuXG4gICAgLy8gVGVhciBkb3duIGNvbmZpcm1hdGlvbiBob29rcyBmb3IgbGVmdCByb3V0ZXNcbiAgICBsZWF2ZVJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXR1cm4gZW50ZXJSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuICAgIH0pLmZvckVhY2gocmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZSk7XG5cbiAgICAvLyBjaGFuZ2UgYW5kIGVudGVyIGhvb2tzIGFyZSBydW4gaW4gc2VyaWVzXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuQ2hhbmdlSG9va3MpKGNoYW5nZVJvdXRlcywgc3RhdGUsIG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdEluZm8pIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHJldHVybiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbyk7XG5cbiAgICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkVudGVySG9va3MpKGVudGVyUm91dGVzLCBuZXh0U3RhdGUsIGZpbmlzaEVudGVySG9va3MpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoRW50ZXJIb29rcyhlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAvLyBUT0RPOiBGZXRjaCBjb21wb25lbnRzIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAgICAoMCwgX2dldENvbXBvbmVudHMyLmRlZmF1bHQpKG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBjb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBNYWtlIG1hdGNoIGEgcHVyZSBmdW5jdGlvbiBhbmQgaGF2ZSBzb21lIG90aGVyIEFQSVxuICAgICAgICAgIC8vIGZvciBcIm1hdGNoIGFuZCB1cGRhdGUgc3RhdGVcIi5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsLCBzdGF0ZSA9IF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgY29tcG9uZW50czogY29tcG9uZW50cyB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yKTtlbHNlIGNhbGxiYWNrKG51bGwsIGNyZWF0ZUxvY2F0aW9uRnJvbVJlZGlyZWN0SW5mbyhyZWRpcmVjdEluZm8pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgUm91dGVHdWlkID0gMTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUlEKHJvdXRlKSB7XG4gICAgdmFyIGNyZWF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cbiAgICByZXR1cm4gcm91dGUuX19pZF9fIHx8IGNyZWF0ZSAmJiAocm91dGUuX19pZF9fID0gUm91dGVHdWlkKyspO1xuICB9XG5cbiAgdmFyIFJvdXRlSG9va3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIGdldFJvdXRlSG9va3NGb3JSb3V0ZXMocm91dGVzKSB7XG4gICAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgICAgaG9va3MucHVzaC5hcHBseShob29rcywgUm91dGVIb29rc1tnZXRSb3V0ZUlEKHJvdXRlKV0pO1xuICAgICAgcmV0dXJuIGhvb2tzO1xuICAgIH0sIFtdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25Ib29rKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICgwLCBfbWF0Y2hSb3V0ZXMyLmRlZmF1bHQpKHJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbmV4dFN0YXRlKSB7XG4gICAgICBpZiAobmV4dFN0YXRlID09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogV2UgZGlkbid0IGFjdHVhbGx5IG1hdGNoIGFueXRoaW5nLCBidXQgaGFuZ1xuICAgICAgICAvLyBvbnRvIGVycm9yL25leHRTdGF0ZSBzbyB3ZSBkb24ndCBoYXZlIHRvIG1hdGNoUm91dGVzXG4gICAgICAgIC8vIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FjaGUgc29tZSBzdGF0ZSBoZXJlIHNvIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgIC8vIG1hdGNoUm91dGVzKCkgYWdhaW4gaW4gdGhlIGxpc3RlbiBjYWxsYmFjay5cbiAgICAgIHBhcnRpYWxOZXh0U3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcblxuICAgICAgdmFyIGhvb2tzID0gZ2V0Um91dGVIb29rc0ZvclJvdXRlcygoMCwgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMy5kZWZhdWx0KShzdGF0ZSwgcGFydGlhbE5leHRTdGF0ZSkubGVhdmVSb3V0ZXMpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvb2tzLmxlbmd0aDsgcmVzdWx0ID09IG51bGwgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgdGhlIGxvY2F0aW9uIGFyZyBoZXJlIGluZGljYXRlcyB0b1xuICAgICAgICAvLyB0aGUgdXNlciB0aGF0IHRoaXMgaXMgYSB0cmFuc2l0aW9uIGhvb2suXG4gICAgICAgIHJlc3VsdCA9IGhvb2tzW2ldKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB1bnRlc3RhYmxlIHdpdGggS2FybWEgKi9cbiAgZnVuY3Rpb24gYmVmb3JlVW5sb2FkSG9vaygpIHtcbiAgICAvLyBTeW5jaHJvbm91c2x5IGNoZWNrIHRvIHNlZSBpZiBhbnkgcm91dGUgaG9va3Mgd2FudFxuICAgIC8vIHRvIHByZXZlbnQgdGhlIGN1cnJlbnQgd2luZG93L3RhYiBmcm9tIGNsb3NpbmcuXG4gICAgaWYgKHN0YXRlLnJvdXRlcykge1xuICAgICAgdmFyIGhvb2tzID0gZ2V0Um91dGVIb29rc0ZvclJvdXRlcyhzdGF0ZS5yb3V0ZXMpO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJyAmJiBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gUGFzc2luZyBubyBhcmdzIGluZGljYXRlcyB0byB0aGUgdXNlciB0aGF0IHRoaXMgaXMgYVxuICAgICAgICAvLyBiZWZvcmV1bmxvYWQgaG9vay4gV2UgZG9uJ3Qga25vdyB0aGUgbmV4dCBsb2NhdGlvbi5cbiAgICAgICAgbWVzc2FnZSA9IGhvb2tzW2ldKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmxpc3RlbkJlZm9yZSA9IHZvaWQgMCxcbiAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUocm91dGUpIHtcbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUsIGZhbHNlKTtcbiAgICBpZiAoIXJvdXRlSUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgIGlmICghaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKSkge1xuICAgICAgLy8gdGVhcmRvd24gdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgaWYgKHVubGlzdGVuQmVmb3JlKSB7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlKCk7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHVubGlzdGVuQmVmb3JlVW5sb2FkKSB7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkKCk7XG4gICAgICAgIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBob29rIGZ1bmN0aW9uIHRvIHJ1biBiZWZvcmUgbGVhdmluZyB0aGUgZ2l2ZW4gcm91dGUuXG4gICAqXG4gICAqIER1cmluZyBhIG5vcm1hbCB0cmFuc2l0aW9uLCB0aGUgaG9vayBmdW5jdGlvbiByZWNlaXZlcyB0aGUgbmV4dCBsb2NhdGlvblxuICAgKiBhcyBpdHMgb25seSBhcmd1bWVudCBhbmQgY2FuIHJldHVybiBlaXRoZXIgYSBwcm9tcHQgbWVzc2FnZSAoc3RyaW5nKSB0byBzaG93IHRoZSB1c2VyLFxuICAgKiB0byBtYWtlIHN1cmUgdGhleSB3YW50IHRvIGxlYXZlIHRoZSBwYWdlOyBvciBgZmFsc2VgLCB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgKiBBbnkgb3RoZXIgcmV0dXJuIHZhbHVlIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAqXG4gICAqIER1cmluZyB0aGUgYmVmb3JldW5sb2FkIGV2ZW50IChpbiBicm93c2VycykgdGhlIGhvb2sgcmVjZWl2ZXMgbm8gYXJndW1lbnRzLlxuICAgKiBJbiB0aGlzIGNhc2UgaXQgbXVzdCByZXR1cm4gYSBwcm9tcHQgbWVzc2FnZSB0byBwcmV2ZW50IHRoZSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byB1bmJpbmQgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCBob29rKSB7XG4gICAgLy8gVE9ETzogV2FybiBpZiB0aGV5IHJlZ2lzdGVyIGZvciBhIHJvdXRlIHRoYXQgaXNuJ3QgY3VycmVudGx5XG4gICAgLy8gYWN0aXZlLiBUaGV5J3JlIHByb2JhYmx5IGRvaW5nIHNvbWV0aGluZyB3cm9uZywgbGlrZSByZS1jcmVhdGluZ1xuICAgIC8vIHJvdXRlIG9iamVjdHMgb24gZXZlcnkgbG9jYXRpb24gY2hhbmdlLlxuICAgIHZhciByb3V0ZUlEID0gZ2V0Um91dGVJRChyb3V0ZSk7XG4gICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgIGlmICghaG9va3MpIHtcbiAgICAgIHZhciB0aGVyZVdlcmVOb1JvdXRlSG9va3MgPSAhaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKTtcblxuICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IFtob29rXTtcblxuICAgICAgaWYgKHRoZXJlV2VyZU5vUm91dGVIb29rcykge1xuICAgICAgICAvLyBzZXR1cCB0cmFuc2l0aW9uICYgYmVmb3JldW5sb2FkIGhvb2tzXG4gICAgICAgIHVubGlzdGVuQmVmb3JlID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUodHJhbnNpdGlvbkhvb2spO1xuXG4gICAgICAgIGlmIChoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZCkgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZVVubG9hZChiZWZvcmVVbmxvYWRIb29rKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhvb2tzLmluZGV4T2YoaG9vaykgPT09IC0xKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYWRkaW5nIG11bHRpcGxlIGxlYXZlIGhvb2tzIGZvciB0aGUgc2FtZSByb3V0ZSBpcyBkZXByZWNhdGVkOyBtYW5hZ2UgbXVsdGlwbGUgY29uZmlybWF0aW9ucyBpbiB5b3VyIG93biBjb2RlIGluc3RlYWQnKSA6IHZvaWQgMDtcblxuICAgICAgICBob29rcy5wdXNoKGhvb2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaG9va3MgPSBSb3V0ZUhvb2tzW3JvdXRlSURdO1xuXG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgdmFyIG5ld0hvb2tzID0gaG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChuZXdIb29rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSb3V0ZUhvb2tzW3JvdXRlSURdID0gbmV3SG9va3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIEFQSSBmb3Igc3RhdGVmdWwgZW52aXJvbm1lbnRzLiBBcyB0aGUgbG9jYXRpb25cbiAgICogY2hhbmdlcywgd2UgdXBkYXRlIHN0YXRlIGFuZCBjYWxsIHRoZSBsaXN0ZW5lci4gV2UgY2FuIGFsc29cbiAgICogZ3JhY2VmdWxseSBoYW5kbGUgZXJyb3JzIGFuZCByZWRpcmVjdHMuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAvLyBUT0RPOiBPbmx5IHVzZSBhIHNpbmdsZSBoaXN0b3J5IGxpc3RlbmVyLiBPdGhlcndpc2Ugd2UnbGxcbiAgICAvLyBlbmQgdXAgd2l0aCBtdWx0aXBsZSBjb25jdXJyZW50IGNhbGxzIHRvIG1hdGNoLlxuICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIGlmIChzdGF0ZS5sb2NhdGlvbiA9PT0gbG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIobnVsbCwgc3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2gobG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhyZWRpcmVjdExvY2F0aW9uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIobnVsbCwgbmV4dFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdMb2NhdGlvbiBcIiVzXCIgZGlkIG5vdCBtYXRjaCBhbnkgcm91dGVzJywgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoKSA6IHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpc0FjdGl2ZTogaXNBY3RpdmUsXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZTogbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG59XG5cbi8vZXhwb3J0IGRlZmF1bHQgdXNlUm91dGVzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLmdldEhhc2hQYXRoID0gZ2V0SGFzaFBhdGg7XG5leHBvcnRzLnJlcGxhY2VIYXNoUGF0aCA9IHJlcGxhY2VIYXNoUGF0aDtcbmV4cG9ydHMuZ2V0V2luZG93UGF0aCA9IGdldFdpbmRvd1BhdGg7XG5leHBvcnRzLmdvID0gZ287XG5leHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBnZXRVc2VyQ29uZmlybWF0aW9uO1xuZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBzdXBwb3J0c0hpc3Rvcnk7XG5leHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2g7XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMV0gfHwgJyc7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyAnIycgKyBwYXRoKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93UGF0aCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaDtcbn1cblxuZnVuY3Rpb24gZ28obikge1xuICBpZiAobikgd2luZG93Lmhpc3RvcnkuZ28obik7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmFja3QvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4gdWEuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9ET01VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShmbiwgbWVzc2FnZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSAnICsgbWVzc2FnZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlcHJlY2F0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2RlcHJlY2F0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Ib29rKGhvb2ssIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0ID0gaG9vayhsb2NhdGlvbiwgY2FsbGJhY2spO1xuXG4gIGlmIChob29rLmxlbmd0aCA8IDIpIHtcbiAgICAvLyBBc3N1bWUgdGhlIGhvb2sgcnVucyBzeW5jaHJvbm91c2x5IGFuZCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcmV0dXJuIHZhbHVlLlxuICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHJlc3VsdCA9PT0gdW5kZWZpbmVkLCAnWW91IHNob3VsZCBub3QgXCJyZXR1cm5cIiBpbiBhIHRyYW5zaXRpb24gaG9vayB3aXRoIGEgY2FsbGJhY2sgYXJndW1lbnQ7IGNhbGwgdGhlIGNhbGxiYWNrIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBydW5UcmFuc2l0aW9uSG9vaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3J1blRyYW5zaXRpb25Ib29rLmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01DaGlsZHJlbk9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxuZnVuY3Rpb24gZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIG5vZGUpIHtcbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB0ZXh0IGNvbXBvbmVudHMsIHdoaWNoIHJldHVybiBbb3BlbiwgY2xvc2VdIGNvbW1lbnRzXG4gIC8vIGZyb20gZ2V0SG9zdE5vZGUuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgbm9kZSA9IG5vZGVbMV07XG4gIH1cbiAgcmV0dXJuIG5vZGUgPyBub2RlLm5leHRTaWJsaW5nIDogcGFyZW50Tm9kZS5maXJzdENoaWxkO1xufVxuXG4vKipcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIGluc2VydENoaWxkQXQgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgLy8gV2UgcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gKFVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbCBicm93c2VycyBzb1xuICAvLyB3ZSBhcmUgY2FyZWZ1bCB0byB1c2UgYG51bGxgLilcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcbn0pO1xuXG5mdW5jdGlvbiBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGRUcmVlLCByZWZlcmVuY2VOb2RlKSB7XG4gIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUocGFyZW50Tm9kZSwgY2hpbGRUcmVlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlWzBdLCBjaGlsZE5vZGVbMV0sIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIHZhciBjbG9zaW5nQ29tbWVudCA9IGNoaWxkTm9kZVsxXTtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVbMF07XG4gICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGNsb3NpbmdDb21tZW50KTtcbiAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNsb3NpbmdDb21tZW50KTtcbiAgfVxuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCwgcmVmZXJlbmNlTm9kZSkge1xuICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBub2RlID0gbmV4dE5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBzdGFydE5vZGUsIGNsb3NpbmdDb21tZW50KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5vZGUgPSBzdGFydE5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICAvLyBUaGUgY2xvc2luZyBjb21tZW50IGlzIHJlbW92ZWQgYnkgUmVhY3RNdWx0aUNoaWxkLlxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VEZWxpbWl0ZWRUZXh0KG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCwgc3RyaW5nVGV4dCkge1xuICB2YXIgcGFyZW50Tm9kZSA9IG9wZW5pbmdDb21tZW50LnBhcmVudE5vZGU7XG4gIHZhciBub2RlQWZ0ZXJDb21tZW50ID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gIGlmIChub2RlQWZ0ZXJDb21tZW50ID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyB0ZXh0IG5vZGVzIGJldHdlZW4gdGhlIG9wZW5pbmcgYW5kIGNsb3NpbmcgY29tbWVudHM7IGluc2VydFxuICAgIC8vIGEgbmV3IG9uZSBpZiBzdHJpbmdUZXh0IGlzbid0IGVtcHR5LlxuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cmluZ1RleHQpLCBub2RlQWZ0ZXJDb21tZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIC8vIFNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBmaXJzdCBub2RlIGFmdGVyIHRoZSBvcGVuaW5nIGNvbW1lbnQsIGFuZFxuICAgICAgLy8gcmVtb3ZlIGFsbCBmb2xsb3dpbmcgbm9kZXMgdXAgdW50aWwgdGhlIGNsb3NpbmcgY29tbWVudC5cbiAgICAgIHNldFRleHRDb250ZW50KG5vZGVBZnRlckNvbW1lbnQsIHN0cmluZ1RleHQpO1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBub2RlQWZ0ZXJDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUob3BlbmluZ0NvbW1lbnQpLl9kZWJ1Z0lELCAncmVwbGFjZSB0ZXh0Jywgc3RyaW5nVGV4dCk7XG4gIH1cbn1cblxudmFyIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCwgcHJldkluc3RhbmNlKSB7XG4gICAgRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZENoaWxkLCBtYXJrdXApO1xuICAgIGlmIChwcmV2SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocHJldkluc3RhbmNlLl9kZWJ1Z0lELCAncmVwbGFjZSB3aXRoJywgbWFya3VwLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobWFya3VwLm5vZGUpO1xuICAgICAgaWYgKG5leHRJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKG5leHRJbnN0YW5jZS5fZGVidWdJRCwgJ21vdW50JywgbWFya3VwLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cbiAqL1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHtcblxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgcmVwbGFjZURlbGltaXRlZFRleHQ6IHJlcGxhY2VEZWxpbWl0ZWRUZXh0LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHVwZGF0ZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudE5vZGVEZWJ1Z0lEID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocGFyZW50Tm9kZSkuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdXBkYXRlc1trXTtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQOlxuICAgICAgICAgIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCwgZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIHVwZGF0ZS5hZnRlck5vZGUpKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ2luc2VydCBjaGlsZCcsIHsgdG9JbmRleDogdXBkYXRlLnRvSW5kZXgsIGNvbnRlbnQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSwgZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIHVwZGF0ZS5hZnRlck5vZGUpKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ21vdmUgY2hpbGQnLCB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCwgdG9JbmRleDogdXBkYXRlLnRvSW5kZXggfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVA6XG4gICAgICAgICAgc2V0SW5uZXJIVE1MKHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ3JlcGxhY2UgY2hpbGRyZW4nLCB1cGRhdGUuY29udGVudC50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5UOlxuICAgICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ3JlcGxhY2UgdGV4dCcsIHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERTpcbiAgICAgICAgICByZW1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHBhcmVudE5vZGVEZWJ1Z0lELCAncmVtb3ZlIGNoaWxkJywgeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXggfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNoaWxkcmVuT3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01OYW1lc3BhY2VzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuICBtYXRobWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTU5hbWVzcGFjZXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xuICogICBhbmQgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIENvbXBvbmVudFRyZWU7XG52YXIgVHJlZVRyYXZlcnNhbDtcbnZhciBpbmplY3Rpb24gPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIENvbXBvbmVudFRyZWUgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIGluamVjdFRyZWVUcmF2ZXJzYWw6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIFRyZWVUcmF2ZXJzYWwgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuaXNBbmNlc3RvciAmJiBJbmplY3RlZC5nZXRMb3dlc3RDb21tb25BbmNlc3RvciwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdFRyZWVUcmF2ZXJzYWwoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBpc0FuY2VzdG9yIG9yIGdldExvd2VzdENvbW1vbkFuY2VzdG9yLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmUgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTtcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0O1xufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMycpIDogdm9pZCAwO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZGlzcGF0Y2hMaXN0ZW5lciA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShkaXNwYXRjaEluc3RhbmNlKSA6IG51bGw7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCkgOiBudWxsO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cbmZ1bmN0aW9uIGhhc0Rpc3BhdGNoZXMoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcbiAgaXNNb3ZlaXNoOiBpc01vdmVpc2gsXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXG5cbiAgZXhlY3V0ZURpcmVjdERpc3BhdGNoOiBleGVjdXRlRGlyZWN0RGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxuICBoYXNEaXNwYXRjaGVzOiBoYXNEaXNwYXRjaGVzLFxuXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgfSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKG5vZGUpO1xuICB9LFxuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmlzQW5jZXN0b3IoYSwgYik7XG4gIH0sXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmdldExvd2VzdENvbW1vbkFuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRQYXJlbnRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRQYXJlbnRJbnN0YW5jZShpbnN0KTtcbiAgfSxcbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldCwgZm4sIGFyZykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlVHdvUGhhc2UodGFyZ2V0LCBmbiwgYXJnKTtcbiAgfSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBLZXlFc2NhcGVVdGlsc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTGlua2VkVmFsdWVVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0UHJvcHMudmFsdWVMaW5rID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZExpbmssIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluayBhbmQgdmljZSB2ZXJzYS4nKSA6IF9wcm9kSW52YXJpYW50KCc4NycpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IF9wcm9kSW52YXJpYW50KCc4OCcpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgY2hlY2tlZCBwcm9wZXJ0eSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWQgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rJykgOiBfcHJvZEludmFyaWFudCgnODknKSA6IHZvaWQgMDtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIG9uQ2hhbmdlOiBSZWFjdFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBfcHJvZEludmFyaWFudCgnODUnKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxuICAgKi9cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAhIWluamVjdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwNCcpIDogdm9pZCAwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBlbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXJyb3JVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0gez9TdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoYSwgYik7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIGNhdWdodEVycm9yID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSwgYikge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhLCBiKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1NlY3JldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY3RvciAmJiAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzICcgKyAnc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yICcgKyAnc2lkZS1lZmZlY3RzIGFyZSBhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gJyArICdgY29tcG9uZW50V2lsbE1vdW50YC4nLCBjYWxsZXJOYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FuRGVmaW5lUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9IH0pO1xuICAgIGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FuRGVmaW5lUHJvcGVydHk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRDaGFyQ29kZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRJdGVyYXRvckZuXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudFN1cHBvcnRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB2YWxpZGF0ZURPTU5lc3RpbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZG8ge1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBwcm9ibGVtYXRpYyA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBwcm9ibGVtYXRpYy50YWc7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xuXG4gICAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkSW5zdGFuY2UgJiYgY2hpbGRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgdmFyIGNoaWxkT3duZXJzID0gZmluZE93bmVyU3RhY2soY2hpbGRPd25lcik7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcblxuICAgICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHZhciBkZWVwZXN0Q29tbW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XG4gICAgICAgICAgZGVlcGVzdENvbW1vbiA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFVOS05PV04gPSAnKHVua25vd24pJztcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxuICAgICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgICAgaW52YWxpZEFuY2VzdG9yID8gWycuLi4nXSA6IFtdLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgICAgaWYgKGNoaWxkVGFnICE9PSAnI3RleHQnKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4gJyArICdTZWUgJXMuJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIG93bmVySW5mbywgaW5mbykgOiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbztcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpbXBvcnQgeyBhcHBseU1pZGRsZXdhcmUsIGNyZWF0ZVN0b3JlIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgbG9nZ2VyIGZyb20gJ3JlZHV4LWxvZ2dlcidcbmltcG9ydCB0aHVuayBmcm9tICdyZWR1eC10aHVuaydcbmltcG9ydCBwcm9taXNlIGZyb20gJ3JlZHV4LXByb21pc2UtbWlkZGxld2FyZSdcblxuaW1wb3J0IHJlZHVjZXIgZnJvbSAnLi9yZWR1Y2Vycy8nXG5cbmNvbnN0IG1pZGRsZXdhcmUgPSBhcHBseU1pZGRsZXdhcmUocHJvbWlzZSgpLCB0aHVuaywgbG9nZ2VyKCkpXG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN0b3JlKHJlZHVjZXIpXG4vL2V4cG9ydCBkZWZhdWx0IGNyZWF0ZVN0b3JlKHJlZHVjZXIsIG1pZGRsZXdhcmUpXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvc3RvcmUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGUoe1xuICBzdWJzY3JpYmU6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBkaXNwYXRjaDogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGdldFN0YXRlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3N0b3JlU2hhcGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiBUaGlzIGFjdGlvbiB0eXBlIHdpbGwgYmUgZGlzcGF0Y2hlZCBieSB0aGUgaGlzdG9yeSBhY3Rpb25zIGJlbG93LlxuICogSWYgeW91J3JlIHdyaXRpbmcgYSBtaWRkbGV3YXJlIHRvIHdhdGNoIGZvciBuYXZpZ2F0aW9uIGV2ZW50cywgYmUgc3VyZSB0b1xuICogbG9vayBmb3IgYWN0aW9ucyBvZiB0aGlzIHR5cGUuXG4gKi9cbnZhciBDQUxMX0hJU1RPUllfTUVUSE9EID0gZXhwb3J0cy5DQUxMX0hJU1RPUllfTUVUSE9EID0gJ0BAcm91dGVyL0NBTExfSElTVE9SWV9NRVRIT0QnO1xuXG5mdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogQ0FMTF9ISVNUT1JZX01FVEhPRCxcbiAgICAgIHBheWxvYWQ6IHsgbWV0aG9kOiBtZXRob2QsIGFyZ3M6IGFyZ3MgfVxuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICogVGhlc2UgYWN0aW9ucyBjb3JyZXNwb25kIHRvIHRoZSBoaXN0b3J5IEFQSS5cbiAqIFRoZSBhc3NvY2lhdGVkIHJvdXRlck1pZGRsZXdhcmUgd2lsbCBjYXB0dXJlIHRoZXNlIGV2ZW50cyBiZWZvcmUgdGhleSBnZXQgdG9cbiAqIHlvdXIgcmVkdWNlciBhbmQgcmVpc3N1ZSB0aGVtIGFzIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBvbiB5b3VyIGhpc3RvcnkuXG4gKi9cbnZhciBwdXNoID0gZXhwb3J0cy5wdXNoID0gdXBkYXRlTG9jYXRpb24oJ3B1c2gnKTtcbnZhciByZXBsYWNlID0gZXhwb3J0cy5yZXBsYWNlID0gdXBkYXRlTG9jYXRpb24oJ3JlcGxhY2UnKTtcbnZhciBnbyA9IGV4cG9ydHMuZ28gPSB1cGRhdGVMb2NhdGlvbignZ28nKTtcbnZhciBnb0JhY2sgPSBleHBvcnRzLmdvQmFjayA9IHVwZGF0ZUxvY2F0aW9uKCdnb0JhY2snKTtcbnZhciBnb0ZvcndhcmQgPSBleHBvcnRzLmdvRm9yd2FyZCA9IHVwZGF0ZUxvY2F0aW9uKCdnb0ZvcndhcmQnKTtcblxudmFyIHJvdXRlckFjdGlvbnMgPSBleHBvcnRzLnJvdXRlckFjdGlvbnMgPSB7IHB1c2g6IHB1c2gsIHJlcGxhY2U6IHJlcGxhY2UsIGdvOiBnbywgZ29CYWNrOiBnb0JhY2ssIGdvRm9yd2FyZDogZ29Gb3J3YXJkIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9hY3Rpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucm91dGVyTWlkZGxld2FyZSA9IGV4cG9ydHMucm91dGVyQWN0aW9ucyA9IGV4cG9ydHMuZ29Gb3J3YXJkID0gZXhwb3J0cy5nb0JhY2sgPSBleHBvcnRzLmdvID0gZXhwb3J0cy5yZXBsYWNlID0gZXhwb3J0cy5wdXNoID0gZXhwb3J0cy5DQUxMX0hJU1RPUllfTUVUSE9EID0gZXhwb3J0cy5yb3V0ZXJSZWR1Y2VyID0gZXhwb3J0cy5MT0NBVElPTl9DSEFOR0UgPSBleHBvcnRzLnN5bmNIaXN0b3J5V2l0aFN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX3JlZHVjZXIgPSByZXF1aXJlKCcuL3JlZHVjZXInKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdMT0NBVElPTl9DSEFOR0UnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcmVkdWNlci5MT0NBVElPTl9DSEFOR0U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyb3V0ZXJSZWR1Y2VyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlZHVjZXIucm91dGVyUmVkdWNlcjtcbiAgfVxufSk7XG5cbnZhciBfYWN0aW9ucyA9IHJlcXVpcmUoJy4vYWN0aW9ucycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NBTExfSElTVE9SWV9NRVRIT0QnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWN0aW9ucy5DQUxMX0hJU1RPUllfTUVUSE9EO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncHVzaCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLnB1c2g7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZXBsYWNlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMucmVwbGFjZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dvJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuZ287XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnb0JhY2snLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWN0aW9ucy5nb0JhY2s7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnb0ZvcndhcmQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWN0aW9ucy5nb0ZvcndhcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyb3V0ZXJBY3Rpb25zJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMucm91dGVyQWN0aW9ucztcbiAgfVxufSk7XG5cbnZhciBfc3luYyA9IHJlcXVpcmUoJy4vc3luYycpO1xuXG52YXIgX3N5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3luYyk7XG5cbnZhciBfbWlkZGxld2FyZSA9IHJlcXVpcmUoJy4vbWlkZGxld2FyZScpO1xuXG52YXIgX21pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWlkZGxld2FyZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZXhwb3J0cy5zeW5jSGlzdG9yeVdpdGhTdG9yZSA9IF9zeW5jMlsnZGVmYXVsdCddO1xuZXhwb3J0cy5yb3V0ZXJNaWRkbGV3YXJlID0gX21pZGRsZXdhcmUyWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMucm91dGVyUmVkdWNlciA9IHJvdXRlclJlZHVjZXI7XG4vKipcbiAqIFRoaXMgYWN0aW9uIHR5cGUgd2lsbCBiZSBkaXNwYXRjaGVkIHdoZW4geW91ciBoaXN0b3J5XG4gKiByZWNlaXZlcyBhIGxvY2F0aW9uIGNoYW5nZS5cbiAqL1xudmFyIExPQ0FUSU9OX0NIQU5HRSA9IGV4cG9ydHMuTE9DQVRJT05fQ0hBTkdFID0gJ0BAcm91dGVyL0xPQ0FUSU9OX0NIQU5HRSc7XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGxvY2F0aW9uQmVmb3JlVHJhbnNpdGlvbnM6IG51bGxcbn07XG5cbi8qKlxuICogVGhpcyByZWR1Y2VyIHdpbGwgdXBkYXRlIHRoZSBzdGF0ZSB3aXRoIHRoZSBtb3N0IHJlY2VudCBsb2NhdGlvbiBoaXN0b3J5XG4gKiBoYXMgdHJhbnNpdGlvbmVkIHRvLiBUaGlzIG1heSBub3QgYmUgaW4gc3luYyB3aXRoIHRoZSByb3V0ZXIsIHBhcnRpY3VsYXJseVxuICogaWYgeW91IGhhdmUgYXN5bmNocm9ub3VzbHktbG9hZGVkIHJvdXRlcywgc28gcmVhZGluZyBmcm9tIGFuZCByZWx5aW5nIG9uXG4gKiB0aGlzIHN0YXRlIGlzIGRpc2NvdXJhZ2VkLlxuICovXG5mdW5jdGlvbiByb3V0ZXJSZWR1Y2VyKCkge1xuICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBpbml0aWFsU3RhdGUgOiBhcmd1bWVudHNbMF07XG5cbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuICB2YXIgdHlwZSA9IF9yZWYudHlwZTtcbiAgdmFyIHBheWxvYWQgPSBfcmVmLnBheWxvYWQ7XG5cbiAgaWYgKHR5cGUgPT09IExPQ0FUSU9OX0NIQU5HRSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHsgbG9jYXRpb25CZWZvcmVUcmFuc2l0aW9uczogcGF5bG9hZCB9KTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL3JlZHVjZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgYm9vbCA9IF9SZWFjdCRQcm9wVHlwZXMuYm9vbDtcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xudmFyIG9uZU9mVHlwZSA9IF9SZWFjdCRQcm9wVHlwZXMub25lT2ZUeXBlO1xuXG5cbmZ1bmN0aW9uIGlzTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuLy8gVE9ETzogRGUtZHVwbGljYXRlIGFnYWluc3QgaGFzQW55UHJvcGVydGllcyBpbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqZWN0KSB7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHApKSByZXR1cm4gZmFsc2U7XG4gIH1yZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCBfcmVmKSB7XG4gIHZhciBxdWVyeSA9IF9yZWYucXVlcnk7XG4gIHZhciBoYXNoID0gX3JlZi5oYXNoO1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gIGlmIChxdWVyeSB8fCBoYXNoIHx8IHN0YXRlKSB7XG4gICAgcmV0dXJuIHsgcGF0aG5hbWU6IHRvLCBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9O1xuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIEEgPExpbms+IGlzIHVzZWQgdG8gY3JlYXRlIGFuIDxhPiBlbGVtZW50IHRoYXQgbGlua3MgdG8gYSByb3V0ZS5cbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgdGhlIHZhbHVlIG9mIGl0c1xuICogYWN0aXZlQ2xhc3NOYW1lIHByb3AuXG4gKlxuICogRm9yIGV4YW1wbGUsIGFzc3VtaW5nIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgcm91dGU6XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9wb3N0cy86cG9zdElEXCIgY29tcG9uZW50PXtQb3N0fSAvPlxuICpcbiAqIFlvdSBjb3VsZCB1c2UgdGhlIGZvbGxvd2luZyBjb21wb25lbnQgdG8gbGluayB0byB0aGF0IHJvdXRlOlxuICpcbiAqICAgPExpbmsgdG89e2AvcG9zdHMvJHtwb3N0LmlkfWB9IC8+XG4gKlxuICogTGlua3MgbWF5IHBhc3MgYWxvbmcgbG9jYXRpb24gc3RhdGUgYW5kL29yIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXG4gKiBpbiB0aGUgc3RhdGUvcXVlcnkgcHJvcHMsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiAgIDxMaW5rIC4uLiBxdWVyeT17eyBzaG93OiB0cnVlIH19IHN0YXRlPXt7IHRoZTogJ3N0YXRlJyB9fSAvPlxuICovXG52YXIgTGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTGluaycsXG5cblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGVcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0bzogb25lT2ZUeXBlKFtzdHJpbmcsIG9iamVjdF0pLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBoYXNoOiBzdHJpbmcsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBhY3RpdmVTdHlsZTogb2JqZWN0LFxuICAgIGFjdGl2ZUNsYXNzTmFtZTogc3RyaW5nLFxuICAgIG9ubHlBY3RpdmVPbkluZGV4OiBib29sLmlzUmVxdWlyZWQsXG4gICAgb25DbGljazogZnVuYyxcbiAgICB0YXJnZXQ6IHN0cmluZ1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbmx5QWN0aXZlT25JbmRleDogZmFsc2UsXG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICB9LFxuICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICF0aGlzLmNvbnRleHQucm91dGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxMaW5rPnMgcmVuZGVyZWQgb3V0c2lkZSBvZiBhIHJvdXRlciBjb250ZXh0IGNhbm5vdCBuYXZpZ2F0ZS4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB8fCAhaXNMZWZ0Q2xpY2tFdmVudChldmVudCkpIHJldHVybjtcblxuICAgIC8vIElmIHRhcmdldCBwcm9wIGlzIHNldCAoZS5nLiB0byBcIl9ibGFua1wiKSwgbGV0IGJyb3dzZXIgaGFuZGxlIGxpbmsuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB1bnRlc3RhYmxlIHdpdGggS2FybWEgKi9cbiAgICBpZiAodGhpcy5wcm9wcy50YXJnZXQpIHJldHVybjtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdG8gPSBfcHJvcHMudG87XG4gICAgdmFyIHF1ZXJ5ID0gX3Byb3BzLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gX3Byb3BzLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gX3Byb3BzLnN0YXRlO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCB7IHF1ZXJ5OiBxdWVyeSwgaGFzaDogaGFzaCwgc3RhdGU6IHN0YXRlIH0pO1xuXG4gICAgdGhpcy5jb250ZXh0LnJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0byA9IF9wcm9wczIudG87XG4gICAgdmFyIHF1ZXJ5ID0gX3Byb3BzMi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wczIuaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBfcHJvcHMyLnN0YXRlO1xuICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBfcHJvcHMyLmFjdGl2ZUNsYXNzTmFtZTtcbiAgICB2YXIgYWN0aXZlU3R5bGUgPSBfcHJvcHMyLmFjdGl2ZVN0eWxlO1xuICAgIHZhciBvbmx5QWN0aXZlT25JbmRleCA9IF9wcm9wczIub25seUFjdGl2ZU9uSW5kZXg7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMiwgWyd0bycsICdxdWVyeScsICdoYXNoJywgJ3N0YXRlJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdhY3RpdmVTdHlsZScsICdvbmx5QWN0aXZlT25JbmRleCddKTtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCEocXVlcnkgfHwgaGFzaCB8fCBzdGF0ZSksICd0aGUgYHF1ZXJ5YCwgYGhhc2hgLCBhbmQgYHN0YXRlYCBwcm9wcyBvbiBgPExpbms+YCBhcmUgZGVwcmVjYXRlZCwgdXNlIGA8TGluayB0bz17eyBwYXRobmFtZSwgcXVlcnksIGhhc2gsIHN0YXRlIH19Lz4uIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcblxuICAgIC8vIElnbm9yZSBpZiByZW5kZXJlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIHJvdXRlciwgc2ltcGxpZmllcyB1bml0IHRlc3RpbmcuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXI7XG5cblxuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgeyBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9KTtcbiAgICAgIHByb3BzLmhyZWYgPSByb3V0ZXIuY3JlYXRlSHJlZihsb2NhdGlvbik7XG5cbiAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUgfHwgYWN0aXZlU3R5bGUgIT0gbnVsbCAmJiAhaXNFbXB0eU9iamVjdChhY3RpdmVTdHlsZSkpIHtcbiAgICAgICAgaWYgKHJvdXRlci5pc0FjdGl2ZShsb2NhdGlvbiwgb25seUFjdGl2ZU9uSW5kZXgpKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmVTdHlsZSkgcHJvcHMuc3R5bGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMuc3R5bGUsIGFjdGl2ZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0xpbmsuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSZWRpcmVjdD4gaXMgdXNlZCB0byBkZWNsYXJlIGFub3RoZXIgVVJMIHBhdGggYSBjbGllbnQgc2hvdWxkXG4gKiBiZSBzZW50IHRvIHdoZW4gdGhleSByZXF1ZXN0IGEgZ2l2ZW4gVVJMLlxuICpcbiAqIFJlZGlyZWN0cyBhcmUgcGxhY2VkIGFsb25nc2lkZSByb3V0ZXMgaW4gdGhlIHJvdXRlIGNvbmZpZ3VyYXRpb25cbiAqIGFuZCBhcmUgdHJhdmVyc2VkIGluIHRoZSBzYW1lIG1hbm5lci5cbiAqL1xuXG52YXIgUmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlZGlyZWN0JyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgcm91dGUgPSAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KShlbGVtZW50KTtcblxuICAgICAgaWYgKHJvdXRlLmZyb20pIHJvdXRlLnBhdGggPSByb3V0ZS5mcm9tO1xuXG4gICAgICByb3V0ZS5vbkVudGVyID0gZnVuY3Rpb24gKG5leHRTdGF0ZSwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBuZXh0U3RhdGUubG9jYXRpb247XG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXh0U3RhdGUucGFyYW1zO1xuXG5cbiAgICAgICAgdmFyIHBhdGhuYW1lID0gdm9pZCAwO1xuICAgICAgICBpZiAocm91dGUudG8uY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm4pKHJvdXRlLnRvLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyb3V0ZS50bykge1xuICAgICAgICAgIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvdXRlSW5kZXggPSBuZXh0U3RhdGUucm91dGVzLmluZGV4T2Yocm91dGUpO1xuICAgICAgICAgIHZhciBwYXJlbnRQYXR0ZXJuID0gUmVkaXJlY3QuZ2V0Um91dGVQYXR0ZXJuKG5leHRTdGF0ZS5yb3V0ZXMsIHJvdXRlSW5kZXggLSAxKTtcbiAgICAgICAgICB2YXIgcGF0dGVybiA9IHBhcmVudFBhdHRlcm4ucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcm91dGUudG87XG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShwYXR0ZXJuLCBwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGFjZSh7XG4gICAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgICAgIHF1ZXJ5OiByb3V0ZS5xdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSxcbiAgICAgICAgICBzdGF0ZTogcm91dGUuc3RhdGUgfHwgbG9jYXRpb24uc3RhdGVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcm91dGU7XG4gICAgfSxcbiAgICBnZXRSb3V0ZVBhdHRlcm46IGZ1bmN0aW9uIGdldFJvdXRlUGF0dGVybihyb3V0ZXMsIHJvdXRlSW5kZXgpIHtcbiAgICAgIHZhciBwYXJlbnRQYXR0ZXJuID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSByb3V0ZUluZGV4OyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV07XG4gICAgICAgIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICAgICAgICBwYXJlbnRQYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBwYXJlbnRQYXR0ZXJuO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuLmluZGV4T2YoJy8nKSA9PT0gMCkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnLycgKyBwYXJlbnRQYXR0ZXJuO1xuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZnJvbTogc3RyaW5nLCAvLyBBbGlhcyBmb3IgcGF0aFxuICAgIHRvOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgb25FbnRlcjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8UmVkaXJlY3Q+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlZGlyZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9SZWRpcmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuY3JlYXRlUm91dGVyT2JqZWN0ID0gY3JlYXRlUm91dGVyT2JqZWN0O1xuZXhwb3J0cy5jcmVhdGVSb3V0aW5nSGlzdG9yeSA9IGNyZWF0ZVJvdXRpbmdIaXN0b3J5O1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXJPYmplY3QoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgc2V0Um91dGVMZWF2ZUhvb2s6IHRyYW5zaXRpb25NYW5hZ2VyLmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSxcbiAgICBpc0FjdGl2ZTogdHJhbnNpdGlvbk1hbmFnZXIuaXNBY3RpdmVcbiAgfSk7XG59XG5cbi8vIGRlcHJlY2F0ZWRcbmZ1bmN0aW9uIGNyZWF0ZVJvdXRpbmdIaXN0b3J5KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKSB7XG4gIGhpc3RvcnkgPSBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaGlzdG9yeSA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkoaGlzdG9yeSwgJ2Bwcm9wcy5oaXN0b3J5YCBhbmQgYGNvbnRleHQuaGlzdG9yeWAgYXJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYGNvbnRleHQucm91dGVyYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWNvbnRleHRjaGFuZ2VzJyk7XG4gIH1cblxuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX3VzZUJhc2VuYW1lID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUnKTtcblxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcbiAgLy8gc2lnbmF0dXJlcyBhbmQgdHlwZSBjaGVja2luZyBkaWZmZXIgYmV0d2VlbiBgdXNlUm91dGVzYCBhbmRcbiAgLy8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgLCBoYXZlIHRvIGNyZWF0ZSBgbWVtb3J5SGlzdG9yeWAgZmlyc3QgYmVjYXVzZVxuICAvLyBgdXNlUXVlcmllc2AgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSBzaWduYXR1cmVcbiAgdmFyIG1lbW9yeUhpc3RvcnkgPSAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIG1lbW9yeUhpc3Rvcnk7XG4gIH07XG4gIHZhciBoaXN0b3J5ID0gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KSgoMCwgX3VzZUJhc2VuYW1lMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSkob3B0aW9ucyk7XG4gIGhpc3RvcnkuX192Ml9jb21wYXRpYmxlX18gPSB0cnVlO1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjcmVhdGVIaXN0b3J5KSB7XG4gIHZhciBoaXN0b3J5ID0gdm9pZCAwO1xuICBpZiAoY2FuVXNlRE9NKSBoaXN0b3J5ID0gKDAsIF91c2VSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSgpO1xuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVJvdXRlckhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gZXhwb3J0cy5oYXNoSGlzdG9yeSA9IGV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBleHBvcnRzLmFwcGx5Um91dGVyTWlkZGxld2FyZSA9IGV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGV4cG9ydHMudXNlUm91dGVySGlzdG9yeSA9IGV4cG9ydHMubWF0Y2ggPSBleHBvcnRzLnJvdXRlclNoYXBlID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gZXhwb3J0cy5Qcm9wVHlwZXMgPSBleHBvcnRzLlJvdXRpbmdDb250ZXh0ID0gZXhwb3J0cy5Sb3V0ZXJDb250ZXh0ID0gZXhwb3J0cy5jcmVhdGVSb3V0ZXMgPSBleHBvcnRzLnVzZVJvdXRlcyA9IGV4cG9ydHMuUm91dGVDb250ZXh0ID0gZXhwb3J0cy5MaWZlY3ljbGUgPSBleHBvcnRzLkhpc3RvcnkgPSBleHBvcnRzLlJvdXRlID0gZXhwb3J0cy5SZWRpcmVjdCA9IGV4cG9ydHMuSW5kZXhSb3V0ZSA9IGV4cG9ydHMuSW5kZXhSZWRpcmVjdCA9IGV4cG9ydHMud2l0aFJvdXRlciA9IGV4cG9ydHMuSW5kZXhMaW5rID0gZXhwb3J0cy5MaW5rID0gZXhwb3J0cy5Sb3V0ZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZVJvdXRlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcztcbiAgfVxufSk7XG5cbnZhciBfUHJvcFR5cGVzMiA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbG9jYXRpb25TaGFwZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Qcm9wVHlwZXMyLmxvY2F0aW9uU2hhcGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyb3V0ZXJTaGFwZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Qcm9wVHlwZXMyLnJvdXRlclNoYXBlO1xuICB9XG59KTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2Zvcm1hdFBhdHRlcm4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm47XG4gIH1cbn0pO1xuXG52YXIgX1JvdXRlcjIgPSByZXF1aXJlKCcuL1JvdXRlcicpO1xuXG52YXIgX1JvdXRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXIyKTtcblxudmFyIF9MaW5rMiA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluazIpO1xuXG52YXIgX0luZGV4TGluazIgPSByZXF1aXJlKCcuL0luZGV4TGluaycpO1xuXG52YXIgX0luZGV4TGluazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleExpbmsyKTtcblxudmFyIF93aXRoUm91dGVyMiA9IHJlcXVpcmUoJy4vd2l0aFJvdXRlcicpO1xuXG52YXIgX3dpdGhSb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2l0aFJvdXRlcjIpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QyID0gcmVxdWlyZSgnLi9JbmRleFJlZGlyZWN0Jyk7XG5cbnZhciBfSW5kZXhSZWRpcmVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJlZGlyZWN0Mik7XG5cbnZhciBfSW5kZXhSb3V0ZTIgPSByZXF1aXJlKCcuL0luZGV4Um91dGUnKTtcblxudmFyIF9JbmRleFJvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0luZGV4Um91dGUyKTtcblxudmFyIF9SZWRpcmVjdDIgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG5cbnZhciBfUmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVkaXJlY3QyKTtcblxudmFyIF9Sb3V0ZTIgPSByZXF1aXJlKCcuL1JvdXRlJyk7XG5cbnZhciBfUm91dGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGUyKTtcblxudmFyIF9IaXN0b3J5MiA9IHJlcXVpcmUoJy4vSGlzdG9yeScpO1xuXG52YXIgX0hpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSGlzdG9yeTIpO1xuXG52YXIgX0xpZmVjeWNsZTIgPSByZXF1aXJlKCcuL0xpZmVjeWNsZScpO1xuXG52YXIgX0xpZmVjeWNsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaWZlY3ljbGUyKTtcblxudmFyIF9Sb3V0ZUNvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0ZUNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZUNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVDb250ZXh0Mik7XG5cbnZhciBfdXNlUm91dGVzMiA9IHJlcXVpcmUoJy4vdXNlUm91dGVzJyk7XG5cbnZhciBfdXNlUm91dGVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlczIpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0Mik7XG5cbnZhciBfUm91dGluZ0NvbnRleHQyID0gcmVxdWlyZSgnLi9Sb3V0aW5nQ29udGV4dCcpO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRpbmdDb250ZXh0Mik7XG5cbnZhciBfUHJvcFR5cGVzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1Byb3BUeXBlczIpO1xuXG52YXIgX21hdGNoMiA9IHJlcXVpcmUoJy4vbWF0Y2gnKTtcblxudmFyIF9tYXRjaDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRjaDIpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkyID0gcmVxdWlyZSgnLi91c2VSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXJIaXN0b3J5Mik7XG5cbnZhciBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMiA9IHJlcXVpcmUoJy4vYXBwbHlSb3V0ZXJNaWRkbGV3YXJlJyk7XG5cbnZhciBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FwcGx5Um91dGVyTWlkZGxld2FyZTIpO1xuXG52YXIgX2Jyb3dzZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vYnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9icm93c2VySGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icm93c2VySGlzdG9yeTIpO1xuXG52YXIgX2hhc2hIaXN0b3J5MiA9IHJlcXVpcmUoJy4vaGFzaEhpc3RvcnknKTtcblxudmFyIF9oYXNoSGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXNoSGlzdG9yeTIpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5Mik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUm91dGVyID0gX1JvdXRlcjMuZGVmYXVsdDsgLyogY29tcG9uZW50cyAqL1xuXG5leHBvcnRzLkxpbmsgPSBfTGluazMuZGVmYXVsdDtcbmV4cG9ydHMuSW5kZXhMaW5rID0gX0luZGV4TGluazMuZGVmYXVsdDtcbmV4cG9ydHMud2l0aFJvdXRlciA9IF93aXRoUm91dGVyMy5kZWZhdWx0O1xuXG4vKiBjb21wb25lbnRzIChjb25maWd1cmF0aW9uKSAqL1xuXG5leHBvcnRzLkluZGV4UmVkaXJlY3QgPSBfSW5kZXhSZWRpcmVjdDMuZGVmYXVsdDtcbmV4cG9ydHMuSW5kZXhSb3V0ZSA9IF9JbmRleFJvdXRlMy5kZWZhdWx0O1xuZXhwb3J0cy5SZWRpcmVjdCA9IF9SZWRpcmVjdDMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGUgPSBfUm91dGUzLmRlZmF1bHQ7XG5cbi8qIG1peGlucyAqL1xuXG5leHBvcnRzLkhpc3RvcnkgPSBfSGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuTGlmZWN5Y2xlID0gX0xpZmVjeWNsZTMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGVDb250ZXh0ID0gX1JvdXRlQ29udGV4dDMuZGVmYXVsdDtcblxuLyogdXRpbHMgKi9cblxuZXhwb3J0cy51c2VSb3V0ZXMgPSBfdXNlUm91dGVzMy5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0ZXJDb250ZXh0ID0gX1JvdXRlckNvbnRleHQzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRpbmdDb250ZXh0ID0gX1JvdXRpbmdDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5Qcm9wVHlwZXMgPSBfUHJvcFR5cGVzMy5kZWZhdWx0O1xuZXhwb3J0cy5tYXRjaCA9IF9tYXRjaDMuZGVmYXVsdDtcbmV4cG9ydHMudXNlUm91dGVySGlzdG9yeSA9IF91c2VSb3V0ZXJIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMy5kZWZhdWx0O1xuXG4vKiBoaXN0b3JpZXMgKi9cblxuZXhwb3J0cy5icm93c2VySGlzdG9yeSA9IF9icm93c2VySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuaGFzaEhpc3RvcnkgPSBfaGFzaEhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBfY3JlYXRlTWVtb3J5SGlzdG9yeTMuZGVmYXVsdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbWFrZVN0YXRlV2l0aExvY2F0aW9uO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gbWFrZVN0YXRlV2l0aExvY2F0aW9uKHN0YXRlLCBsb2NhdGlvbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5jYW5Vc2VNZW1icmFuZSkge1xuICAgIHZhciBzdGF0ZVdpdGhMb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBzdGF0ZSk7XG5cbiAgICAvLyBJIGRvbid0IHVzZSBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzIGhlcmUgYmVjYXVzZSBJIHdhbnQgdG8ga2VlcCB0aGVcbiAgICAvLyBzYW1lIGNvZGUgcGF0aCBiZXR3ZWVuIGRldmVsb3BtZW50IGFuZCBwcm9kdWN0aW9uLCBpbiB0aGF0IHdlIGp1c3RcbiAgICAvLyBhc3NpZ24gZXh0cmEgcHJvcGVydGllcyB0byB0aGUgY29weSBvZiB0aGUgc3RhdGUgb2JqZWN0IGluIGJvdGggY2FzZXMuXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsb2NhdGlvbiwgcHJvcCkpIHtcbiAgICAgICAgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdGF0ZVdpdGhMb2NhdGlvbiwgcHJvcCwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FjY2Vzc2luZyBsb2NhdGlvbiBwcm9wZXJ0aWVzIGRpcmVjdGx5IGZyb20gdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGBnZXRDb21wb25lbnRgLCBgZ2V0Q29tcG9uZW50c2AsIGBnZXRDaGlsZFJvdXRlc2AsIGFuZCBgZ2V0SW5kZXhSb3V0ZWAgaXMgZGVwcmVjYXRlZC4gVGhhdCBhcmd1bWVudCBpcyBub3cgdGhlIHJvdXRlciBzdGF0ZSAoYG5leHRTdGF0ZWAgb3IgYHBhcnRpYWxOZXh0U3RhdGVgKSByYXRoZXIgdGhhbiB0aGUgbG9jYXRpb24uIFRvIGFjY2VzcyB0aGUgbG9jYXRpb24sIHVzZSBgbmV4dFN0YXRlLmxvY2F0aW9uYCBvciBgcGFydGlhbE5leHRTdGF0ZS5sb2NhdGlvbmAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIGxvY2F0aW9uW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBsb2NhdGlvbikge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChwcm9wKTtcblxuICAgICAgaWYgKF9yZXQgPT09ICdjb250aW51ZScpIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZVdpdGhMb2NhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIGxvY2F0aW9uKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVJvdXRlckhpc3Rvcnk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX3VzZUJhc2VuYW1lID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUnKTtcblxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHVzZVJvdXRlckhpc3RvcnkoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICAgIGhpc3RvcnkuX192Ml9jb21wYXRpYmxlX18gPSB0cnVlO1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXJIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc2F2ZVN0YXRlID0gc2F2ZVN0YXRlO1xuZXhwb3J0cy5yZWFkU3RhdGUgPSByZWFkU3RhdGU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBLZXlQcmVmaXggPSAnQEBIaXN0b3J5Lyc7XG52YXIgUXVvdGFFeGNlZWRlZEVycm9ycyA9IFsnUXVvdGFFeGNlZWRlZEVycm9yJywgJ1FVT1RBX0VYQ0VFREVEX0VSUiddO1xuXG52YXIgU2VjdXJpdHlFcnJvciA9ICdTZWN1cml0eUVycm9yJztcblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICByZXR1cm4gS2V5UHJlZml4ICsga2V5O1xufVxuXG5mdW5jdGlvbiBzYXZlU3RhdGUoa2V5LCBzdGF0ZSkge1xuICB0cnkge1xuICAgIGlmIChzdGF0ZSA9PSBudWxsKSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShjcmVhdGVLZXkoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGNyZWF0ZUtleShrZXkpLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gU2VjdXJpdHlFcnJvcikge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgZHVlIHRvIHNlY3VyaXR5IHNldHRpbmdzJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoUXVvdGFFeGNlZWRlZEVycm9ycy5pbmRleE9mKGVycm9yLm5hbWUpID49IDAgJiYgd2luZG93LnNlc3Npb25TdG9yYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gU2FmYXJpIFwicHJpdmF0ZSBtb2RlXCIgdGhyb3dzIFF1b3RhRXhjZWVkZWRFcnJvci5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiBTYWZhcmkgcHJpdmF0ZSBtb2RlJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gIHZhciBqc29uID0gdW5kZWZpbmVkO1xuICB0cnkge1xuICAgIGpzb24gPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShjcmVhdGVLZXkoa2V5KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byByZWFkIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoanNvbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWdub3JlIGludmFsaWQgSlNPTi5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUhpc3Rvcnkob3B0aW9ucykge1xuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVIaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHtcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBfRE9NVXRpbHMuZ2V0VXNlckNvbmZpcm1hdGlvblxuICB9LCBvcHRpb25zLCB7XG4gICAgZ286IF9ET01VdGlscy5nb1xuICB9KSk7XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0RPTSBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlRE9NSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZURPTUhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGlzQWJzb2x1dGVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCgpIHtcbiAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICBpZiAoaXNBYnNvbHV0ZVBhdGgocGF0aCkpIHJldHVybiB0cnVlO1xuXG4gIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoJy8nICsgcGF0aCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHBhdGggKyAocGF0aC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIChrZXkgKyAnPScgKyB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1s/Jl0/JyArIGtleSArICc9W2EtekEtWjAtOV0rJyksICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIGtleSkge1xuICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKG5ldyBSZWdFeHAoJ1xcXFw/Lio/XFxcXGInICsga2V5ICsgJz0oLis/KVxcXFxiJykpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5cbnZhciBEZWZhdWx0UXVlcnlLZXkgPSAnX2snO1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuXG4gIGlmIChxdWVyeUtleSA9PT0gdW5kZWZpbmVkIHx8ICEhcXVlcnlLZXkpIHF1ZXJ5S2V5ID0gdHlwZW9mIHF1ZXJ5S2V5ID09PSAnc3RyaW5nJyA/IHF1ZXJ5S2V5IDogRGVmYXVsdFF1ZXJ5S2V5O1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBrZXkgPSBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwgcXVlcnlLZXkpO1xuICAgICAgcGF0aCA9IHN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIHF1ZXJ5S2V5KTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG4gICAgICAgIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgoYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKF9yZWYpIHtcbiAgICB2YXIgdHJhbnNpdGlvblRvID0gX3JlZi50cmFuc2l0aW9uVG87XG5cbiAgICBmdW5jdGlvbiBoYXNoQ2hhbmdlTGlzdGVuZXIoKSB7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHJldHVybjsgLy8gQWx3YXlzIG1ha2Ugc3VyZSBoYXNoZXMgYXJlIHByZWNlZWRlZCB3aXRoIGEgLy5cblxuICAgICAgdHJhbnNpdGlvblRvKGdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9XG5cbiAgICBlbnN1cmVTbGFzaCgpO1xuICAgIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ2hhc2hjaGFuZ2UnLCBoYXNoQ2hhbmdlTGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgc2VhcmNoO1xuXG4gICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICBwYXRoID0gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBxdWVyeUtleSwga2V5KTtcbiAgICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEcm9wIGtleSBhbmQgc3RhdGUuXG4gICAgICBsb2NhdGlvbi5rZXkgPSBsb2NhdGlvbi5zdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRIYXNoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAoY3VycmVudEhhc2ggIT09IHBhdGgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnWW91IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGggdXNpbmcgaGFzaCBoaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50SGFzaCAhPT0gcGF0aCkge1xuICAgICAgLy8gUkVQTEFDRVxuICAgICAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aChwYXRoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVET01IaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgbG9jYXRpb24uc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucHVzaChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IGxvY2F0aW9uLnN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnJlcGxhY2UobG9jYXRpb24pO1xuICB9XG5cbiAgdmFyIGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkID0gX0RPTVV0aWxzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgIHJldHVybiAnIycgKyBoaXN0b3J5LmNyZWF0ZUhyZWYocGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIGhpc3RvcnkucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBoaXN0b3J5LnVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcblxuICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IHN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnB1c2hTdGF0ZShzdGF0ZSwgcGF0aCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBzdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgcHVzaFN0YXRlOiBwdXNoU3RhdGUsIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICByZXBsYWNlU3RhdGU6IHJlcGxhY2VTdGF0ZSAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIYXNoSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9kZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX2NyZWF0ZUxvY2F0aW9uMiA9IHJlcXVpcmUoJy4vY3JlYXRlTG9jYXRpb24nKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVMb2NhdGlvbjIpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVSYW5kb21LZXkobGVuZ3RoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgbGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiZcbiAgLy9hLmFjdGlvbiA9PT0gYi5hY3Rpb24gJiYgLy8gRGlmZmVyZW50IGFjdGlvbiAhPT0gbG9jYXRpb24gY2hhbmdlLlxuICBhLmtleSA9PT0gYi5rZXkgJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShhLnN0YXRlLCBiLnN0YXRlKTtcbn1cblxudmFyIERlZmF1bHRLZXlMZW5ndGggPSA2O1xuXG5mdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gb3B0aW9ucy5nZXRDdXJyZW50TG9jYXRpb247XG4gIHZhciBmaW5pc2hUcmFuc2l0aW9uID0gb3B0aW9ucy5maW5pc2hUcmFuc2l0aW9uO1xuICB2YXIgc2F2ZVN0YXRlID0gb3B0aW9ucy5zYXZlU3RhdGU7XG4gIHZhciBnbyA9IG9wdGlvbnMuZ287XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gb3B0aW9ucy5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB2YXIga2V5TGVuZ3RoID0gb3B0aW9ucy5rZXlMZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBrZXlMZW5ndGggIT09ICdudW1iZXInKSBrZXlMZW5ndGggPSBEZWZhdWx0S2V5TGVuZ3RoO1xuXG4gIHZhciB0cmFuc2l0aW9uSG9va3MgPSBbXTtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgIHRyYW5zaXRpb25Ib29rcy5wdXNoKGhvb2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYW5zaXRpb25Ib29rcyA9IHRyYW5zaXRpb25Ib29rcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFsbEtleXMgPSBbXTtcbiAgdmFyIGNoYW5nZUxpc3RlbmVycyA9IFtdO1xuICB2YXIgbG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudCgpIHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uICYmIHBlbmRpbmdMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihwZW5kaW5nTG9jYXRpb24ua2V5KTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gYWxsS2V5cy5pbmRleE9mKGxvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihuZXdMb2NhdGlvbikge1xuICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudCgpO1xuXG4gICAgbG9jYXRpb24gPSBuZXdMb2NhdGlvbjtcblxuICAgIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGFsbEtleXMgPSBbXS5jb25jYXQoYWxsS2V5cy5zbGljZSgwLCBjdXJyZW50ICsgMSksIFtsb2NhdGlvbi5rZXldKTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUkVQTEFDRSkge1xuICAgICAgYWxsS2V5c1tjdXJyZW50XSA9IGxvY2F0aW9uLmtleTtcbiAgICB9XG5cbiAgICBjaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGNoYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgbGlzdGVuZXIobG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2xvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgICBhbGxLZXlzID0gW19sb2NhdGlvbi5rZXldO1xuICAgICAgdXBkYXRlTG9jYXRpb24oX2xvY2F0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbmdlTGlzdGVuZXJzID0gY2hhbmdlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBfQXN5bmNVdGlscy5sb29wQXN5bmModHJhbnNpdGlvbkhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10odHJhbnNpdGlvbkhvb2tzW2luZGV4XSwgbG9jYXRpb24sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgZG9uZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChnZXRVc2VyQ29uZmlybWF0aW9uICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgIGNhbGxiYWNrKG9rICE9PSBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uVG8obmV4dExvY2F0aW9uKSB7XG4gICAgaWYgKGxvY2F0aW9uICYmIGxvY2F0aW9uc0FyZUVxdWFsKGxvY2F0aW9uLCBuZXh0TG9jYXRpb24pKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICBwZW5kaW5nTG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG5cbiAgICBjb25maXJtVHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAocGVuZGluZ0xvY2F0aW9uICE9PSBuZXh0TG9jYXRpb24pIHJldHVybjsgLy8gVHJhbnNpdGlvbiB3YXMgaW50ZXJydXB0ZWQuXG5cbiAgICAgIGlmIChvaykge1xuICAgICAgICAvLyB0cmVhdCBQVVNIIHRvIGN1cnJlbnQgcGF0aCBsaWtlIFJFUExBQ0UgdG8gYmUgY29uc2lzdGVudCB3aXRoIGJyb3dzZXJzXG4gICAgICAgIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICAgICAgdmFyIG5leHRQYXRoID0gY3JlYXRlUGF0aChuZXh0TG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKG5leHRQYXRoID09PSBwcmV2UGF0aCAmJiBfZGVlcEVxdWFsMlsnZGVmYXVsdCddKGxvY2F0aW9uLnN0YXRlLCBuZXh0TG9jYXRpb24uc3RhdGUpKSBuZXh0TG9jYXRpb24uYWN0aW9uID0gX0FjdGlvbnMuUkVQTEFDRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5pc2hUcmFuc2l0aW9uKG5leHRMb2NhdGlvbikgIT09IGZhbHNlKSB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiAmJiBuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gYWxsS2V5cy5pbmRleE9mKG5leHRMb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xICYmIG5leHRJbmRleCAhPT0gLTEpIGdvKHByZXZJbmRleCAtIG5leHRJbmRleCk7IC8vIFJlc3RvcmUgdGhlIFVSTC5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIF9BY3Rpb25zLlBVU0gsIGNyZWF0ZUtleSgpKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFLCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gY3JlYXRlUmFuZG9tS2V5KGtleUxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cbiAgICB2YXIgcmVzdWx0ID0gcGF0aG5hbWU7XG5cbiAgICBpZiAoc2VhcmNoKSByZXN1bHQgKz0gc2VhcmNoO1xuXG4gICAgaWYgKGhhc2gpIHJlc3VsdCArPSBoYXNoO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGNyZWF0ZUtleSgpIDogYXJndW1lbnRzWzJdO1xuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdUaGUgc3RhdGUgKDJuZCkgYXJndW1lbnQgdG8gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgYSAnICsgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBhY3Rpb24gfSk7XG5cbiAgICAgIGFjdGlvbiA9IGtleTtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1szXSB8fCBjcmVhdGVLZXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NyZWF0ZUxvY2F0aW9uM1snZGVmYXVsdCddKGxvY2F0aW9uLCBhY3Rpb24sIGtleSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGxvY2F0aW9uLCBzdGF0ZSk7XG4gICAgICB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uU3RhdGUoZ2V0Q3VycmVudExvY2F0aW9uKCksIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvblN0YXRlKGxvY2F0aW9uLCBzdGF0ZSkge1xuICAgIGxvY2F0aW9uLnN0YXRlID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLnN0YXRlLCBzdGF0ZSk7XG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAodHJhbnNpdGlvbkhvb2tzLmluZGV4T2YoaG9vaykgPT09IC0xKSB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSAhPT0gaG9vaztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICB0cmFuc2l0aW9uVG86IHRyYW5zaXRpb25UbyxcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNyZWF0ZUtleTogY3JlYXRlS2V5LFxuICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICBzZXRTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShzZXRTdGF0ZSwgJ3NldFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBsb2NhdGlvbi5rZXkgdG8gc2F2ZSBzdGF0ZSBpbnN0ZWFkJyksXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZWdpc3RlclRyYW5zaXRpb25Ib29rLCAncmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10odW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAndW5yZWdpc3RlclRyYW5zaXRpb25Ib29rIGlzIGRlcHJlY2F0ZWQ7IHVzZSB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZnJvbSBsaXN0ZW5CZWZvcmUgaW5zdGVhZCcpLFxuICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG5mdW5jdGlvbiB1c2VCYXNlbmFtZShjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcblxuICAgIHZhciBiYXNlbmFtZSA9IG9wdGlvbnMuYmFzZW5hbWU7XG5cbiAgICB2YXIgY2hlY2tlZEJhc2VIcmVmID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBjaGVja0Jhc2VIcmVmKCkge1xuICAgICAgaWYgKGNoZWNrZWRCYXNlSHJlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdXNlIHRoZSB2YWx1ZSBvZiA8YmFzZSBocmVmPiBpbiBIVE1MXG4gICAgICAvLyBkb2N1bWVudHMgYXMgYmFzZW5hbWUgaWYgaXQncyBub3QgZXhwbGljaXRseSBnaXZlbi5cbiAgICAgIGlmIChiYXNlbmFtZSA9PSBudWxsICYmIF9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAgICAgdmFyIGJhc2UgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpWzBdO1xuICAgICAgICB2YXIgYmFzZUhyZWYgPSBiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cbiAgICAgICAgaWYgKGJhc2VIcmVmICE9IG51bGwpIHtcbiAgICAgICAgICBiYXNlbmFtZSA9IGJhc2VIcmVmO1xuXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnQXV0b21hdGljYWxseSBzZXR0aW5nIGJhc2VuYW1lIHVzaW5nIDxiYXNlIGhyZWY+IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgJyArICdiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFRoZSBzZW1hbnRpY3Mgb2YgPGJhc2UgaHJlZj4gYXJlICcgKyAnc3VidGx5IGRpZmZlcmVudCBmcm9tIGJhc2VuYW1lLiBQbGVhc2UgcGFzcyB0aGUgYmFzZW5hbWUgZXhwbGljaXRseSBpbiAnICsgJ3RoZSBvcHRpb25zIHRvIGNyZWF0ZUhpc3RvcnknKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGVja2VkQmFzZUhyZWYgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBjaGVja0Jhc2VIcmVmKCk7XG5cbiAgICAgIGlmIChiYXNlbmFtZSAmJiBsb2NhdGlvbi5iYXNlbmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2VuYW1lKSA9PT0gMCkge1xuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSBiYXNlbmFtZTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gJycpIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgY2hlY2tCYXNlSHJlZigpO1xuXG4gICAgICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKGxvY2F0aW9uKTtcblxuICAgICAgdmFyIHBuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB2YXIgbm9ybWFsaXplZEJhc2VuYW1lID0gYmFzZW5hbWUuc2xpY2UoLTEpID09PSAnLycgPyBiYXNlbmFtZSA6IGJhc2VuYW1lICsgJy8nO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRQYXRobmFtZSA9IHBuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gcG5hbWUuc2xpY2UoMSkgOiBwbmFtZTtcbiAgICAgIHZhciBwYXRobmFtZSA9IG5vcm1hbGl6ZWRCYXNlbmFtZSArIG5vcm1hbGl6ZWRQYXRobmFtZTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKGhvb2ssIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKGFkZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucHVzaChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRCYXNlbmFtZShoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFtwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pXS5jb25jYXQoYXJncykpKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcmVwbGFjZShfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbixcblxuICAgICAgcHVzaFN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHB1c2hTdGF0ZSwgJ3B1c2hTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcHVzaCBpbnN0ZWFkJyksXG4gICAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1c2VCYXNlbmFtZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xufVxuXG5fYXNzaWduKENhbGxiYWNrUXVldWUucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBfcHJvZEludmFyaWFudCgnMjQnKSA6IHZvaWQgMDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LFxuXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzID8gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA6IDA7XG4gIH0sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uIChsZW4pIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID0gbGVuO1xuICAgICAgdGhpcy5fY29udGV4dHMubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbGxiYWNrUXVldWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5T3BlcmF0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICd1cGRhdGUgYXR0cmlidXRlJywgcGF5bG9hZCk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICd1cGRhdGUgYXR0cmlidXRlJywgcGF5bG9hZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICdyZW1vdmUgYXR0cmlidXRlJywgbmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsICdyZW1vdmUgYXR0cmlidXRlJywgbmFtZSk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmM7XG4gIHZhciBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSBrZXlPZih7IG1peGluczogbnVsbCB9KTtcblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIGhvc3QgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRVxuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLCBjb250ZXh0VHlwZXMpO1xuICB9LFxuICAvKipcbiAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH0sXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xuXG4vLyBub29wXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBpbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlIGAlc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzIGRvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3MycsIG5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NCcsIG5hbWUpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpc01peGluVmFsaWQsICclczogWW91XFwncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCAnICsgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgKyAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWMpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGNsYXNzIG9yIGZ1bmN0aW9uIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzUnKSA6IHZvaWQgMDtcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NicpIDogdm9pZCAwO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyB3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzcnLCBzcGVjUG9saWN5LCBuYW1lKSA6IHZvaWQgMDtcblxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICEhaXNSZXNlcnZlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgcHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0IGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzgnLCBuYW1lKSA6IHZvaWQgMDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc5JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IF9wcm9kSW52YXJpYW50KCc4MCcpIDogdm9pZCAwO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyB3aXRoIGNsYXNoaW5nIGtleXMuJywga2V5KSA6IF9wcm9kSW52YXJpYW50KCc4MScsIGtleSkgOiB2b2lkIDA7XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGMgPSB7fTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBib3VuZE1ldGhvZDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcbiAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVyLmlzTW91bnRlZCh0aGlzKTtcbiAgfVxufTtcblxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcbl9hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnODInLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9O1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogX3Byb2RJbnZhcmlhbnQoJzgzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0ge1xuICBoYXNDYWNoZWRDaGlsZE5vZGVzOiAxIDw8IDBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgc2VsZWN0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHJldHVybiBfYXNzaWduKHt9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0VmFsdWVDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFJlYWN0RE9NT3B0aW9uIGxvb2tzIGF0IHRoaXMgaW5pdGlhbCB2YWx1ZSBzbyB0aGUgaW5pdGlhbCBnZW5lcmF0ZWRcbiAgICAvLyBtYXJrdXAgaGFzIGNvcnJlY3QgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRWYWxpZGF0b3JcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG5cbnZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3AsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgc2hvdWxkIG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIGJvb2xlYW4sIG9yICcgKyAnbnVtYmVyLiBJdCBzaG91bGQgYmUgYSBzdHJpbmcgKGZvciBET00gZWxlbWVudHMpIG9yIGEgUmVhY3RDbGFzcyAnICsgJyhmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gICAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUNvbXBvbmVudEZhY3Rvcnk7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudEZhY3Rvcnk6IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgZW1wdHlDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgfVxufTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29tcG9uZW50RmFjdG9yeShpbnN0YW50aWF0ZSk7XG4gIH1cbn07XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RGZWF0dXJlRmxhZ3NcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0ge1xuICAvLyBXaGVuIHRydWUsIGNhbGwgY29uc29sZS50aW1lKCkgYmVmb3JlIGFuZCAudGltZUVuZCgpIGFmdGVyIGVhY2ggdG9wLWxldmVsXG4gIC8vIHJlbmRlciAoYm90aCBpbml0aWFsIHJlbmRlcnMgYW5kIHVwZGF0ZXMpLiBVc2VmdWwgd2hlbiBsb29raW5nIGF0IHByb2QtbW9kZVxuICAvLyB0aW1lbGluZSBwcm9maWxlcyBpbiBDaHJvbWUsIGZvciBleGFtcGxlLlxuICBsb2dUb3BMZXZlbFJlbmRlcnM6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RmVhdHVyZUZsYWdzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SG9zdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIGhvc3QgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBfYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvc3QgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzExMScsIGVsZW1lbnQudHlwZSkgOiB2b2lkIDA7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSB7XG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5wdXRTZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3Rpb24nKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uIChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgfVxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gICAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICAgKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICAgKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAgICovXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIC8vIElFOCBpbnB1dC5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHNlbGVjdGlvbiBwZXIgZG9jdW1lbnQgaW4gSUUsIHNvIGl0IG11c3RcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01Db250YWluZXJJbmZvID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbnRhaW5lckluZm8nKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdEZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgUk9PVF9BVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG52YXIgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50SW50b05vZGUod3JhcHBlckluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgbWFya2VyTmFtZTtcbiAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgIHZhciB3cmFwcGVkRWxlbWVudCA9IHdyYXBwZXJJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHR5cGUgPSB3cmFwcGVkRWxlbWVudC50eXBlO1xuICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgbW91bnQ6ICcgKyAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lKTtcbiAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gIH1cblxuICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHdyYXBwZXJJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIG51bGwsIFJlYWN0RE9NQ29udGFpbmVySW5mbyh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciksIGNvbnRleHQsIDAgLyogcGFyZW50RGVidWdJRCAqL1xuICApO1xuXG4gIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgd3JhcHBlckluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gd3JhcHBlckluc3RhbmNlO1xuICBSZWFjdE1vdW50Ll9tb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHdyYXBwZXJJbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBCYXRjaGVkIG1vdW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogdXNlQ3JlYXRlRWxlbWVudCAqL1xuICAhc2hvdWxkUmV1c2VNYXJrdXAgJiYgUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudCk7XG4gIHRyYW5zYWN0aW9uLnBlcmZvcm0obW91bnRDb21wb25lbnRJbnRvTm9kZSwgbnVsbCwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAqIEBmaW5hbFxuICogQGludGVybmFsXG4gKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLCBzYWZlbHkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkZsdXNoKCk7XG4gIH1cbiAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQoaW5zdGFuY2UsIHNhZmVseSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2goKTtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaGFzIGEgZGlyZWN0IFJlYWN0LXJlbmRlcmVkIGNoaWxkIHRoYXQgaXNcbiAqIG5vdCBhIFJlYWN0IHJvb3QgZWxlbWVudC4gVXNlZnVsIGZvciB3YXJuaW5nIGluIGByZW5kZXJgLFxuICogYHVubW91bnRDb21wb25lbnRBdE5vZGVgLCBldGMuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGVsZW1lbnQgY29udGFpbnMgYSBkaXJlY3QgY2hpbGQgdGhhdCB3YXNcbiAqIHJlbmRlcmVkIGJ5IFJlYWN0IGJ1dCBpcyBub3QgYSByb290IGVsZW1lbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgaWYgKHJvb3RFbCkge1xuICAgIHZhciBpbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcbiAgICByZXR1cm4gISEoaW5zdCAmJiBpbnN0Ll9ob3N0UGFyZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgUmVhY3QgRE9NIGVsZW1lbnQgYW5kXG4gKiBpdCBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWwgJiYgaXNSZWFjdE5vZGUocm9vdEVsKSAmJiAhUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgUmVhY3Qgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIFJlYWN0IERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzUmVhY3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVmFsaWRDb250YWluZXIobm9kZSkgJiYgKG5vZGUuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKSB8fCBub2RlLmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHZhciBwcmV2SG9zdEluc3RhbmNlID0gcm9vdEVsICYmIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gIHJldHVybiBwcmV2SG9zdEluc3RhbmNlICYmICFwcmV2SG9zdEluc3RhbmNlLl9ob3N0UGFyZW50ID8gcHJldkhvc3RJbnN0YW5jZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdCA9IGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gcm9vdCA/IHJvb3QuX2hvc3RDb250YWluZXJJbmZvLl90b3BMZXZlbFdyYXBwZXIgOiBudWxsO1xufVxuXG4vKipcbiAqIFRlbXBvcmFyeSAoPykgaGFjayBzbyB0aGF0IHdlIGNhbiBzdG9yZSBhbGwgdG9wLWxldmVsIHBlbmRpbmcgdXBkYXRlcyBvblxuICogY29tcG9zaXRlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byB3b3JyeSBhYm91dCBkaWZmZXJlbnQgdHlwZXMgb2YgY29tcG9uZW50c1xuICogaGVyZS5cbiAqL1xudmFyIHRvcExldmVsUm9vdENvdW50ZXIgPSAxO1xudmFyIFRvcExldmVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290SUQgPSB0b3BMZXZlbFJvb3RDb3VudGVyKys7XG59O1xuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUb3BMZXZlbFdyYXBwZXIuZGlzcGxheU5hbWUgPSAnVG9wTGV2ZWxXcmFwcGVyJztcbn1cblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzLnByb3BzIGlzIGFjdHVhbGx5IGEgUmVhY3RFbGVtZW50XG4gIHJldHVybiB0aGlzLnByb3BzO1xufTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGRldnRvb2xzLiBUaGUga2V5cyBhcmUgbm90IGltcG9ydGFudC5cbiAgICovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLiBIb29rZWQgYnkgaG9va3MhXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ19yZWdpc3RlckNvbXBvbmVudCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM3JykgOiB2b2lkIDA7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgZmFsc2UpO1xuXG4gICAgLy8gVGhlIGluaXRpYWwgcmVuZGVyIGlzIHN5bmNocm9ub3VzIGJ1dCBhbnkgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmdcbiAgICAvLyByZW5kZXJpbmcsIGluIGNvbXBvbmVudFdpbGxNb3VudCBvciBjb21wb25lbnREaWRNb3VudCwgd2lsbCBiZSBiYXRjaGVkXG4gICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGJhdGNoaW5nIHN0cmF0ZWd5LlxuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICB2YXIgd3JhcHBlcklEID0gY29tcG9uZW50SW5zdGFuY2UuX2luc3RhbmNlLnJvb3RJRDtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3dyYXBwZXJJRF0gPSBjb21wb25lbnRJbnN0YW5jZTtcblxuICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcGFyZW50Q29tcG9uZW50IFRoZSBjb25jZXB0dWFsIHBhcmVudCBvZiB0aGlzIHJlbmRlciB0cmVlLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIFJlYWN0SW5zdGFuY2VNYXAuaGFzKHBhcmVudENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMzgnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgJ1JlYWN0RE9NLnJlbmRlcicpO1xuICAgICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDpcbiAgICAvLyBDaGVjayBpZiBpdCBxdWFja3MgbGlrZSBhbiBlbGVtZW50XG4gICAgbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiBfcHJvZEludmFyaWFudCgnMzknLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBzdHJpbmcgbGlrZSBcXCdkaXZcXCcsIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KFxcJ2RpdlxcJykgb3IgPGRpdiAvPi4nIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjbGFzcyBsaWtlIEZvbywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vKSBvciA8Rm9vIC8+LicgOiBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IHZvaWQgMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgbmV4dFdyYXBwZWRFbGVtZW50ID0gUmVhY3RFbGVtZW50KFRvcExldmVsV3JhcHBlciwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgdmFyIG5leHRDb250ZXh0O1xuICAgIGlmIChwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIHZhciBwYXJlbnRJbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIG5leHRDb250ZXh0ID0gcGFyZW50SW5zdC5fcHJvY2Vzc0NoaWxkQ29udGV4dChwYXJlbnRJbnN0Ll9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldldyYXBwZWRFbGVtZW50LnByb3BzO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZENhbGxiYWNrID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQocHJldkNvbXBvbmVudCwgbmV4dFdyYXBwZWRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCB1cGRhdGVkQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHVibGljSW5zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID0gcmVhY3RSb290RWxlbWVudCAmJiAhIWludGVybmFsR2V0SUQocmVhY3RSb290RWxlbWVudCk7XG4gICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lckhhc1JlYWN0TWFya3VwIHx8IHJlYWN0Um9vdEVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50U2libGluZyA9IHJlYWN0Um9vdEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChyb290RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxHZXRJRChyb290RWxlbWVudFNpYmxpbmcpKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290RWxlbWVudFNpYmxpbmcgPSByb290RWxlbWVudFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudCAmJiAhY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IFJlYWN0TW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQobmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBuZXh0Q29udGV4dCkuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnJlbmRlclxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS51bm1vdW50Y29tcG9uZW50YXRub2RlXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDAnKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgaWYgKCFwcmV2Q29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxuICAgICAgLy8gcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgY29udGFpbmVyLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtwcmV2Q29tcG9uZW50Ll9pbnN0YW5jZS5yb290SURdO1xuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIHByZXZDb21wb25lbnQsIGNvbnRhaW5lciwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIF9tb3VudEltYWdlSW50b05vZGU6IGZ1bmN0aW9uIChtYXJrdXAsIGNvbnRhaW5lciwgaW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MScpIDogdm9pZCAwO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIHJvb3RFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcblxuICAgICAgICB2YXIgcm9vdE1hcmt1cCA9IHJvb3RFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FLCBjaGVja3N1bSk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRNYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgLy8gYmVjYXVzZSByb290TWFya3VwIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBET00sIHZhcmlvdXMgbm9ybWFsaXphdGlvbnNcbiAgICAgICAgICAvLyB3aWxsIGhhdmUgb2NjdXJyZWQgd2hpY2ggd2lsbCBub3QgYmUgcHJlc2VudCBpbiBgbWFya3VwYC4gSGVyZSxcbiAgICAgICAgICAvLyBpbnNlcnQgbWFya3VwIGludG8gYSA8ZGl2PiBvciA8aWZyYW1lPiBkZXBlbmRpbmcgb24gdGhlIGNvbnRhaW5lclxuICAgICAgICAgIC8vIHR5cGUgdG8gcGVyZm9ybSB0aGUgc2FtZSBub3JtYWxpemF0aW9ucyBiZWZvcmUgY29tcGFyaW5nLlxuICAgICAgICAgIHZhciBub3JtYWxpemVyO1xuICAgICAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3JtYWxpemVyLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmlubmVySFRNTDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LndyaXRlKG1hcmt1cCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZmZJbmRleCA9IGZpcnN0RGlmZmVyZW5jZUluZGV4KG5vcm1hbGl6ZWRNYXJrdXAsIHJvb3RNYXJrdXApO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9ICcgKGNsaWVudCkgJyArIG5vcm1hbGl6ZWRNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCkgKyAnXFxuIChzZXJ2ZXIpICcgKyByb290TWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApO1xuXG4gICAgICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gdGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSBtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSBzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzIGFuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBfcHJvZEludmFyaWFudCgnNDInLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgYXR0ZW1wdGVkIHRvIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgKyAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICsgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICsgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICsgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgKyAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArICdvciBzZXJ2ZXI6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCBidXQgeW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBfcHJvZEludmFyaWFudCgnNDMnKSA6IHZvaWQgMDtcblxuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKGNvbnRhaW5lciwgbWFya3VwLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGhvc3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgaWYgKGhvc3ROb2RlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oaG9zdE5vZGUuX2RlYnVnSUQsICdtb3VudCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNb3VudC5qc1xuICoqIG1vZHVsZSBpZCA9IDExMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGFyZSB1cGRhdGVkLCBhIHNlcmllcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvblxuICogb2JqZWN0cyBhcmUgY3JlYXRlZCBpbiBvcmRlciB0byBiYXRjaCBhbmQgc2VyaWFsaXplIHRoZSByZXF1aXJlZCBjaGFuZ2VzLlxuICpcbiAqIEVudW1lcmF0ZXMgYWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IGtleU1pcnJvcih7XG4gIElOU0VSVF9NQVJLVVA6IG51bGwsXG4gIE1PVkVfRVhJU1RJTkc6IG51bGwsXG4gIFJFTU9WRV9OT0RFOiBudWxsLFxuICBTRVRfTUFSS1VQOiBudWxsLFxuICBURVhUX0NPTlRFTlQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Tm9kZVR5cGVzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHtcbiAgSE9TVDogMCxcbiAgQ09NUE9TSVRFOiAxLFxuICBFTVBUWTogMixcblxuICBnZXRUeXBlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuRU1QVFk7XG4gICAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuSE9TVDtcbiAgICAgIH1cbiAgICB9XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgbm9kZTogJXMnLCBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcyNicsIG5vZGUpIDogdm9pZCAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9kZVR5cGVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE5vZGVUeXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbi8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4vKipcbiAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIgd2UgZG9uJ3QgdXNlIHJlYWxcbiAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSAnJztcbn1cbi8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cblByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0ICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgIGlmICghbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICsgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIG5vdCB3b3JrIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uIFlvdSBtYXkgYmUgJyArICdzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyBsaWJyYXJ5LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyBmb3IgZGV0YWlscy4nLCBwcm9wRnVsbE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdSZXF1aXJlZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHdhcyBub3Qgc3BlY2lmaWVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMobnVsbCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgIH1cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAvLyBOYXRpdmUgU3ltYm9sLlxuICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnc3ltYm9sJztcbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbi8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcFR5cGU7XG59XG5cbi8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHJldHVybiBBTk9OWU1PVVM7XG4gIH1cbiAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VmVyc2lvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuMy4xJztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVmlld3BvcnRNZXRyaWNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qc1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFjY3VtdWxhdGVJbnRvXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2FjY3VtdWxhdGVJbnRvLmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2hlY2tSZWFjdFR5cGVTcGVjXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cblxuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDExOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG5cbmZ1bmN0aW9uIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpIHtcbiAgdmFyIHR5cGU7XG5cbiAgd2hpbGUgKCh0eXBlID0gaW5zdC5fcmVuZGVyZWROb2RlVHlwZSkgPT09IFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURSkge1xuICAgIGluc3QgPSBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5IT1NUKSB7XG4gICAgcmV0dXJuIGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzXG4gKiogbW9kdWxlIGlkID0gMTIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBUbyBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5LCB3ZSBjcmVhdGUgdGhlIGZpbmFsIGNsYXNzIGluIHRoaXMgbW9kdWxlXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3QoZWxlbWVudCk7XG59O1xuX2Fzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5NaXhpbiwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIG5leHREZWJ1Z0lEID0gMTtcblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEhhdmVEZWJ1Z0lEXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSwgc2hvdWxkSGF2ZURlYnVnSUQpIHtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEVtcHR5Q29tcG9uZW50LmNyZWF0ZShpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgIShlbGVtZW50ICYmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBfcHJvZEludmFyaWFudCgnMTMwJywgZWxlbWVudC50eXBlID09IG51bGwgPyBlbGVtZW50LnR5cGUgOiB0eXBlb2YgZWxlbWVudC50eXBlLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oZWxlbWVudC5fb3duZXIpKSA6IHZvaWQgMDtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGVtcG9yYXJpbHkgYXZhaWxhYmxlIGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGFyZSBub3Qgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbnMuIEkuZS4gQVJULiBPbmNlIHRob3NlIGFyZSB1cGRhdGVkIHRvIHVzZSB0aGUgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2UgY2FuIGRyb3AgdGhpcyBjb2RlIHBhdGguXG4gICAgICBpbnN0YW5jZSA9IG5ldyBlbGVtZW50LnR5cGUoZWxlbWVudCk7XG5cbiAgICAgIC8vIFdlIHJlbmFtZWQgdGhpcy4gQWxsb3cgdGhlIG9sZCBuYW1lIGZvciBjb21wYXQuIDooXG4gICAgICBpZiAoIWluc3RhbmNlLmdldEhvc3ROb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLmdldEhvc3ROb2RlID0gaW5zdGFuY2UuZ2V0TmF0aXZlTm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKGVsZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcxMzEnLCB0eXBlb2Ygbm9kZSkgOiB2b2lkIDA7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2RlYnVnSUQgPSBzaG91bGRIYXZlRGVidWdJRCA/IG5leHREZWJ1Z0lEKysgOiAwO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaW5zdGFuY2VzIHNob3VsZCBmdWxseSBjb25zdHJ1Y3RlZCBhdCB0aGlzIHBvaW50LCBzbyB0aGV5IHNob3VsZFxuICAvLyBub3QgZ2V0IGFueSBuZXcgZmllbGRzIGFkZGVkIHRvIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cblxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRUZXh0Q29udGVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRUZXh0Q29udGVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9mb2N1c05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21wb3NlO1xuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhc3QgPSBmdW5jc1tmdW5jcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogZnVuY3Rpb24gdigpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdC5yZWR1Y2VSaWdodChmdW5jdGlvbiAoY29tcG9zZWQsIGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmKGNvbXBvc2VkKTtcbiAgICAgICAgICB9LCBsYXN0LmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgaWYgKHR5cGVvZiBfcmV0ID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldC52O1xuICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2NvbXBvc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQWN0aW9uVHlwZXMgPSB1bmRlZmluZWQ7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNyZWF0ZVN0b3JlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZSA9IHJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbnZhciBfc3ltYm9sT2JzZXJ2YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2xPYnNlcnZhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlc2UgYXJlIHByaXZhdGUgYWN0aW9uIHR5cGVzIHJlc2VydmVkIGJ5IFJlZHV4LlxuICogRm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHlvdSBtdXN0IHJldHVybiB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIElmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLlxuICogRG8gbm90IHJlZmVyZW5jZSB0aGVzZSBhY3Rpb24gdHlwZXMgZGlyZWN0bHkgaW4geW91ciBjb2RlLlxuICovXG52YXIgQWN0aW9uVHlwZXMgPSBleHBvcnRzLkFjdGlvblR5cGVzID0ge1xuICBJTklUOiAnQEByZWR1eC9JTklUJ1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW2luaXRpYWxTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5oYW5jZXIgVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBpbml0aWFsU3RhdGU7XG4gICAgaW5pdGlhbFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUmVkdWNlcihuZXh0UmVkdWNlcikge1xuICAgIGlmICh0eXBlb2YgbmV4dFJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIG5leHRSZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgY3VycmVudFJlZHVjZXIgPSBuZXh0UmVkdWNlcjtcbiAgICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJvcGVyYWJpbGl0eSBwb2ludCBmb3Igb2JzZXJ2YWJsZS9yZWFjdGl2ZSBsaWJyYXJpZXMuXG4gICAqIEByZXR1cm5zIHtvYnNlcnZhYmxlfSBBIG1pbmltYWwgb2JzZXJ2YWJsZSBvZiBzdGF0ZSBjaGFuZ2VzLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZSBvYnNlcnZhYmxlIHByb3Bvc2FsOlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cblxuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgX3JlZjtcbiAgfVxuXG4gIC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuICBkaXNwYXRjaCh7IHR5cGU6IEFjdGlvblR5cGVzLklOSVQgfSk7XG5cbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyW19zeW1ib2xPYnNlcnZhYmxlMltcImRlZmF1bHRcIl1dID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdhcm5pbmc7XG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndDRUFBa0dCd2dIQmdrSUJ3Z0tDZ2tMRFJZUERRd01EUnNVRlJBV0lCMGlJaUFkSHg4a0tEUXNKQ1l4Sng4ZkxUMHRNVFUzT2pvNkl5cy9SRDg0UXpRNU9qY0JDZ29LRFF3TkdnOFBHamNsSHlVM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOLy9BQUJFSUFGb0FXZ01CSWdBQ0VRRURFUUgveEFBY0FBQUNBZ01CQVFBQUFBQUFBQUFBQUFBR0J3QUZBUUlFQXdqL3hBQkRFQUFCQWdVQUJ3TUlCd1FMQUFBQUFBQUJBZ01BQkFVR0VRY1NJVEZCVVdFVEluRVVGakl6Z1pHaHdRZ1ZJMEppc2ZCU1k2TFJKalJEUkZOemRJS1NzdkgveEFBYkFRQUNBd0VCQVFBQUFBQUFBQUFBQUFBQ0JBRURCUVlBQi8vRUFDa1JBQUlDQWdFQ0JRTUZBQUFBQUFBQUFBQUJBZ01FRVNFU01RVUdFMUdoRlVGeEZDSWpNbUgvMmdBTUF3RUFBaEVERVFBL0FISkVpUUtYemQvbStoaVFwc3VaNnV6cDFKU1RULzNWeVNQajBBSkZyZWlzdGJqdVNrMjFKZVZWbWNRd2crZ2pldHc4a3AzbUJGTndYdGRTUXEyS00zUjVCUjJUdFU5WXNjMHRqUHpIV082MU5Id2JuQlhyd2RUVnE4NWhSTHZlYWw4YmtvVHUyYzhiT0hPRDBpRmJibXY2bGtZSVhLTkhWVm5zS3VHOWF4Tkw0dHlxdXdSN2huOGhHRG9kdGc5NXgycHJYKzJadmIrVU1VeG9ZeTdyN3Zjc1NRdkZhTTNKTWExQ3UydXlDMCtpRlA4QWFJejFUc3pIa1o3U0piUjFwNlZsTGxrRWVrdVdIWlRBSFBWeGcrQUJoaktqelVNOElWK3AzMVBubEUrbW1VTnEzcFJiblNwRWcrcHViUjYyVG1CcVBObmpzNCtJZ2lnUHU2eDZmY0o4cVpVcW4xZHZ2TVZDVzdyaVZEZHJZeHJENDhqSExabDNUNHFSdGk4VUpZcmJZK3hmVDZ1ZFNQdkpQN1g1OU4wYkdGNGhWbExTNGZzVlRyY1E2aVJJa2FKVVZWMDE2V3RxZ3pkVm04RkRDTzZqT0M0czdFcEhpZm5BL28wdHVaYlE1ZEZ4RHRhOVV4MmhLeC9WMmp0UzJrSDBkbU1qaHU0UlgzTTM1MmFTYVhieWdWVTZrSStzSjBZN3EzRGpVU2ZlUFlvd3l4dWhQSXQwK2xGc0k4SG9NWWdHMHBYMkxLcHpIa3pMYjlRbXlReTI1blZTQnZVckczaU5rRzJZK2R2cEVMV2IxazBFblVUVGtGSTRiWEhNbjljb0dEVW5vbDhEVTBZM3ltOWFVK3Q5bERFL0tLU2w5dHZPcVFjNnFrNTRIQjJkSU1UQ0Iram80NG01S28yTTltcVRCVU9vV01mbVlmeGpQellxTXRJT0lDNldydWZ0TzNrcmtGSlRVSnR6c21GS1NGZG1BTXFYZzc4RFlPcEVEK2gyL1orNFg1cWsxdDhQelRhTzJZZTFBa3JUbkNrbkFBMlpCOXA1UlUvU1BTdnQ2Q3JCMU5WOEE5Y29nWDBIQlp2NlhLTndsM1N2dzFmNTRpZjA5YndtMnVkTm50dnFQbzh3TVgxYXpOeTBvSVFyc2FqTEh0WkthU2NLYWNHMGJlUng4K0VFOGFLM1J5U3ZuUllySVBUUmUwbndEdWpxNVhiaG9xa1ZBZG5XS2VzeTArMmNBaHhPeld3Tm0zSERZRGtRVmJZVzlXSG10cE1wbFhhT3BJMTBlUlRnM0R0ZG1vcnhPeitLR1J0NUgzUjlBdzhtT1RURzFmY1NuSHBsb0FkRnlmTHF6ZDlkV01xbXFtcGhDdjNiZVFNZThlNkdHREM3MEhrcXNrclg2eGM4OHBmamtRd3N4ajVGMzgwaStLNE44d3JkTjFrenR4c1NkVW96SGJ6a29rdE9NcDlKeHNuSXh6SU9kblV3ekVQSVd0U0VuSlFjSzZIZkhwbVBReVhXOW51a1dtaFd6SjIyNmZPVDlYYUxNNU82cVVzS3hyTnRwenY2a25kd3dJWlJqR1l3VEN1UmtPeVRreVV0QW5wS3RBWGhRUEpHM1V0VGJLdzdMdUxIZDF0eEJ4d0krVVVXaXJSODlhUm1aNnFPdE9UNzZlelNsbzVTMmpPZC9FazQ5ME1jeG9ZVHN6ckkwdXBkbUVvcmV6RWVaaVBPcGFRVnJPRWdaSjVSaklNWWR6NDJXb0N0TDBtcVlzaWJtRzhkdkpPTnpMU3VLU2xRQkk5aE1HMUpuR1orbFNjNFZITXd3aDA0L0VrSDV3TzZRQUZXVFhOYmQ1RTUrVVZ0cE91aTFhTUFQN2d4eC9kcGpyZkxOamxpeVQrMG1MWHI5eHBvblY1STVjMUdVTlZValZuQ2xISkMvUlA4SmcrY1dVdHFVQm5BempuQzltejVzYVdVVERuY2tMamx3MFZiZ0poR01lOFkvd0NVTUhPUkZmaWE5SEkyK3o1Q3I1aVZWdXV1TlNNdXhONDdkYmZiYXcvdE5idktQaUZLT2ZZZU1YT3RIRk55YmN5d0dzcWJLTUZweHM0VTJvYmluOVlPNDVCSWl1WFhCU2xwWnVBb2xrSFlpZTNTNitpaWZWcTZLMkhnVHdYNjNkekR2N0JhMFhoTVlqVkswcVNsU1ZCU1ZiUVFjZ3hDWVJzdGE0WktSa3hvVEVKNnhWVkN1U2tyTWlUYUtwcWZVTzdLUzQxbkIxVndRbjhTaUJDdXAydlVGc0xzZHMwK2xoc3JWbFhCS1J2VWVBSFdPS2hwZVJUMHR6QVNGdE9PTmdKT1FFcFVRa0R3R0JHMG5MUHFjRTFVU2d6QkhkYlJ0UXlEdkE1bm1yand3STdBQWdiT2VZVXlMWVFnNmx5L2NKSUU5SzA3NUhZZFVJMnJlUWxoSUhFclVBZmhtQ1czNlF4SjBHbXlyaWUreEtOTnEyY1FnRDVRRTNqL0FFaXZhM3JZYTd6VEx2MWhQQUgwVUk5RUh4MmovY0laZXQwanR2TDJNNnNGT1hlWElwZkxjZ2N2MjJ4Yzl2T3liUyt6bldWQitUZHpqVWVUdTI4QWQzdGpqc0M1L09La3FSTmdOVmFTVjJFK3dkaWtPRFpuSEk0UHR5T0VGOEFsNld0UE4xVk4xMmlFb3JMU2NURXQ5MmRiNGcvaXdCNDRIRUNIL0VjSlpWV2wzWFlHdWZTdzB6R3JqYUhVS2JjU2xhRkRDa3FHUVJ5SWdjdEc4S2ZjMHNvTTYwdlBNN0ptU2UyT05LRy9aeEhYMzRPeUNMTWNIZDZtUE53bXRORGEwK3dNdldYS3NySzZGVUtoUlZFNTFKSjM3RW4vQUNsWlNQWmlPYzBTOFVBb2J2TnBTZUJkcGFDcjJrS3hCZG1NWmd2cXR5WE9uK1VtZTlOQW8zYVZSbWNmWGwxMVNjVDk1bVcxWlZDdWgxTzlqMnhmVXVsU0ZJWUxGTmxHcFpzbldVRzA0MWp6SjNrOVRIWVl3VENlUjRoZmF1bHk0OWx3dmdKUVNKRlZjdGNsTGVvOHhVNTVYMmJRN3FBZHJpdUNSMU1TNGEvVGJka0ZUdFZtRXROalloTzlUaDVKSEV3TFcvUTZsZWxZWnVPNlpjeTFMbHpyVTJscjNrLzRqZy9XZWdHMTN3andpek5zVmsxcUMrZjhRTnRpaWl5MFlVU2JaWW5Ma3JTY1ZhdEtEcWtrWTdGbmVoSFRoOEJ3ZzVpZU1TUHBFWXFLU1FnM3RraVJJa0V5QVR1eXc2Ylg1Z1ZDWGNkcGxaUnRicUVwM1Y1eGdhMk1hMnpBNTQ0eFFpclh2YXc3T3ZVY1Z5U1R1bnFiNnpING0rZnNBNnd5VHZqUEtGTW5Eb3lZOU5zZGh4bTQ5Z0JrZEo5cVRSMUhxZ3VUZTR0emJLa0ZQaWNFZkdMUVhuYkJHUlg2ZGovVUppK3FOTHA4KzBmTHBDVm1kaXZYTXBYdzZpQXR5MmFBSGdCUTZaamw1RzMvQUNqRG41WXhaUGlUUmVyNUh0UDZTYlNrOWlxdzI4ck94TXVoVGhQdEF4OFlydk91NXJpK3p0QzNIbVdsYlByQ3EvWklUMUNlUHN6NFFiVU9pVW1UbEVybEtYSk1MRzVUVXVoSitBaTF6c1BqRjJQNWV3cWRTYTZ2eUJLK1RBZTM5SGpMRStpc1hUT3VWeXJEQlNwOFpaWk9mdUlQTC93Q0RpSkVqZmpGUldraWx0dnVTSkVpUVJCLy85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL1NtaWxleUZhY2UuanBlZ1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0IGNvbnN0IHNlbGVjdFR1cnRsZSA9ICh0dXJ0bGUpID0+IHtcblxuICAvLyBjb25zb2xlLmxvZyhcIllvdSBjbGlja2VkIG9uIHVzZXI6IFwiLCBcbiAgLy8gXHR1c2VyLmZpcnN0ICsgXCIsIFwiICsgXG4gIC8vIFx0dXNlci5kZXNjcmlwdGlvblxuICAvLyApO1xuICByZXR1cm4ge1xuICBcdHR5cGU6IFwiVFVSVExFX1NFTEVDVEVEXCIsXG4gIFx0cGF5bG9hZDogdHVydGxlXG4gIH07XG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2FjdGlvbnMvdHVydGxlLmpzXG4gKiovIiwiZXhwb3J0IGNvbnN0IHNlbGVjdFVzZXIgPSAodXNlcikgPT4ge1xuXG4gIC8vIGNvbnNvbGUubG9nKFwiWW91IGNsaWNrZWQgb24gdXNlcjogXCIsIFxuICAvLyBcdHVzZXIuZmlyc3QgKyBcIiwgXCIgKyBcbiAgLy8gXHR1c2VyLmRlc2NyaXB0aW9uXG4gIC8vICk7XG4gIHJldHVybiB7XG4gIFx0dHlwZTogXCJVU0VSX1NFTEVDVEVEXCIsXG4gIFx0cGF5bG9hZDogdXNlclxuICB9O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9hY3Rpb25zL3VzZXIuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgVHVydGxlTGlzdCBmcm9tICcuLi9jb250YWluZXJzL3R1cnRsZS1saXN0J1xuaW1wb3J0IFR1cnRsZURldGFpbCBmcm9tICcuLi9jb250YWluZXJzL3R1cnRsZS1kZXRhaWwnXG4vL3JlcXVpcmUoJy4uLy4uL3Njc3Mvc3R5bGUuc2NzcycpO1xuXG5jb25zdCBDb21wVHVydGxlID0gKCkgPT4gKFxuICA8ZGl2PlxuICAgIDxoMz5OaW5qYSBUdXJ0bGVzIExpc3Q6PC9oMz5cbiAgICA8VHVydGxlTGlzdCAvPlxuICAgIDxociAvPlxuICAgIDxoMz5CaW86PC9oMz5cbiAgICA8VHVydGxlRGV0YWlsIC8+XG4gIDwvZGl2PlxuKTtcbmV4cG9ydCBkZWZhdWx0IENvbXBUdXJ0bGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvY29tcG9uZW50cy9jb21wLXR1cnRsZS5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBVc2VyTGlzdCBmcm9tICcuLi9jb250YWluZXJzL3VzZXItbGlzdCdcbmltcG9ydCBVc2VyRGV0YWlsIGZyb20gJy4uL2NvbnRhaW5lcnMvdXNlci1kZXRhaWwnXG4vL3JlcXVpcmUoJy4uLy4uL3Njc3Mvc3R5bGUuc2NzcycpO1xuXG5jb25zdCBDb21wVXNlciA9ICgpID0+IChcbiAgIDxkaXY+XG4gICAgIDxoMz5JbmZsdWVudGlhbCBQZXJzb25zIExpc3Q6PC9oMz5cbiAgICAgPFVzZXJMaXN0IC8+XG4gICAgIDxoci8+XG4gICAgIDxoMz5CaW86PC9oMz5cbiAgICAgPFVzZXJEZXRhaWwgLz5cbiAgIDwvZGl2PlxuKTtcbmV4cG9ydCBkZWZhdWx0IENvbXBVc2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC11c2VyLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IFNtaWxleUZhY2UgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvU21pbGV5RmFjZS5qcGVnXCJcblxuLy9hbHRlcm5hdGl2ZSBjb2RlXG5AY29ubmVjdCgoc3RhdGUpID0+IHsgICAgXG4gIHJldHVybiB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHR1cnRsZTogc3RhdGUuYWN0aXZlVHVydGxlXG4gIH07XG59KVxuXG5jbGFzcyBUdXJ0bGVEZXRhaWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLnR1cnRsZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPGg0PlxuICAgICAgICAgICBQbGFjZSB0aGUgY3Vyc29yIG92ZXIgeW91ciBmYXZvcml0ZSBOaW5qYSBhbmQgY2xpY2suLi5cbiAgICAgICAgPC9oND4pO1xuICAgIH1cbiAgXHRyZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGltZyBjbGFzcz1cImltZy1yZXNwb25zaXZlXCIgc3JjPXt0aGlzLnByb3BzLnR1cnRsZS5pbWFnZX0gd2lkdGg9XCIyNTBcIiBhbHQ9e1NtaWxleUZhY2V9IC8+XG4gICAgICAgIDxlbT5cbiAgICAgICAgICA8aDQ+e3RoaXMucHJvcHMudHVydGxlLm5hbWV9IGFrYSBcInt0aGlzLnByb3BzLnR1cnRsZS5ha2F9XCI8L2g0PlxuICAgICAgICAgIDxoND5BZ2U6ICZuYnNwOyZuYnNwO3t0aGlzLnByb3BzLnR1cnRsZS5hZ2V9PC9oND5cbiAgICAgICAgICA8aDQ+RGVzY3JpcHRpb246ICZuYnNwOyZuYnNwO3t0aGlzLnByb3BzLnR1cnRsZS5kZXNjcmlwdGlvbn08L2g0PlxuICAgICAgICAgIDxoNT4oSW1hZ2VzIGFuZCBkZXNjcmlwdGlvbnMgY291cnRlc3kgb2YgV2lraXBlZGlhKTwvaDU+XG4gICAgICAgIDwvZW0+XG4gICAgICA8L2Rpdj5cbiAgXHQpO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBUdXJ0bGVEZXRhaWw7XG4vLyBmdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUpIHtcbi8vICAgcmV0dXJuIHtcbi8vICAgICB0dXJ0bGU6IHN0YXRlLmFjdGl2ZVR1cnRsZVxuLy8gICB9O1xuLy8gfVxuLy8gZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKFR1cnRsZURldGFpbCk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvY29udGFpbmVycy90dXJ0bGUtZGV0YWlsLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnXG5pbXBvcnQgeyBzZWxlY3RUdXJ0bGUgfSBmcm9tICcuLi9hY3Rpb25zL3R1cnRsZSdcblxuY2xhc3MgVHVydGxlTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNyZWF0ZUxpc3RJdGVtcygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5wcm9wcy50dXJ0bGVzLm1hcCh0dXJ0bGUgPT4ge1xuICBcdCAgICByZXR1cm4gKCAgIFxuICAgICAgICAgICAgPGxpIGtleT17dHVydGxlLmlkfSBvbkNsaWNrPXsoKSA9PiB0aGlzLnByb3BzLnNlbGVjdFR1cnRsZSh0dXJ0bGUpfSA+IFxuICAgICAgICAgICAge3R1cnRsZS5uYW1lfSBcbiAgICAgICAgICAgIDwvbGk+ICAgICBcbiAgXHQgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gIFx0cmV0dXJuIChcbiAgICAgIDxoND5cbiAgICAgICAgPHVsPlxuICAgICAgICAgIHt0aGlzLmNyZWF0ZUxpc3RJdGVtcygpfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9oND5cbiAgXHQpO1xuICB9XG59XG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0dXJ0bGVzOiBzdGF0ZS50dXJ0bGVzXG4gIH07XG59XG5mdW5jdGlvbiBtYXRjaERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4gKFxuICAgIGJpbmRBY3Rpb25DcmVhdG9ycyh7c2VsZWN0VHVydGxlOiBzZWxlY3RUdXJ0bGV9LCBkaXNwYXRjaClcbiAgKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzLCBtYXRjaERpc3BhdGNoVG9Qcm9wcykoVHVydGxlTGlzdCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb250YWluZXJzL3R1cnRsZS1saXN0LmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IFNtaWxleUZhY2UgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvU21pbGV5RmFjZS5qcGVnXCJcblxuLy9hbHRlcm5hdGl2ZSBjb2RlXG5AY29ubmVjdCgoc3RhdGUpID0+IHsgICAgXG4gIHJldHVybiB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gIHVzZXI6IHN0YXRlLmFjdGl2ZVVzZXJcbiAgfTtcbn0pXG5cbmNsYXNzIFVzZXJEZXRhaWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLnVzZXIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxoND5cbiAgICAgICAgICBQbGFjZSB0aGUgY3Vyc29yIG92ZXIgeW91ciBmYXZvcml0ZSBmYW1vdXMgcGVyc29uIGFuZCBzZWxlY3QuLi5cbiAgICAgICAgPC9oND4pO1xuICAgIH1cbiAgXHRyZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGltZyBjbGFzcz1cImltZy1yZXNwb25zaXZlXCIgc3JjPXt0aGlzLnByb3BzLnVzZXIuaW1hZ2V9IHdpZHRoPVwiMzAwXCIgYWx0PXtTbWlsZXlGYWNlfSAvPlxuICAgICAgICA8ZW0+XG4gICAgICAgICAgIDxoND57dGhpcy5wcm9wcy51c2VyLm5hbWV9IHt0aGlzLnByb3BzLnVzZXIubGFzdH08L2g0PlxuICAgICAgICAgICA8aDQ+Qm9ybjogJm5ic3A7Jm5ic3A7e3RoaXMucHJvcHMudXNlci5ib3JuTW9udGh9IHt0aGlzLnByb3BzLnVzZXIuYm9ybkRheX0sIHt0aGlzLnByb3BzLnVzZXIuYm9yblllYXJ9e3RoaXMucHJvcHMudXNlci5hZ2VbMl19PC9oND5cbiAgICAgICAgICAgPGg0PldvdWxkIGhhdmUgYmVlbiBhcm91bmQge3RoaXMucHJvcHMudXNlci5hZ2VbMF19IHllYXJzIGFuZCB7dGhpcy5wcm9wcy51c2VyLmFnZVsxXX0gbW9udGhzIG9sZCBub3csIGlmIHdlcmUgc3RpbGwgYWxpdmUuPC9oND5cbiAgICAgICAgICAgPGg0PkRlc2NyaXB0aW9uOiAmbmJzcDsmbmJzcDt7dGhpcy5wcm9wcy51c2VyLmRlc2NyaXB0aW9ufTwvaDQ+XG4gICAgICAgICAgIDxoNT4oUGhvdG9zIGFuZCBkZXNjcmlwdGlvbnMgY291cnRlc3kgb2YgV2lraXBlZGlhKTwvaDU+XG4gICAgICAgIDwvZW0+XG4gICAgICA8L2Rpdj5cbiAgXHQpO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBVc2VyRGV0YWlsO1xuXG4vLyBmdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUpIHtcbi8vICAgcmV0dXJuIHtcbi8vICAgICB1c2VyOiBzdGF0ZS5hY3RpdmVVc2VyXG4vLyAgIH07XG4vLyB9XG4vLyBleHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcykoVXNlckRldGFpbCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb250YWluZXJzL3VzZXItZGV0YWlsLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnXG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnXG5pbXBvcnQgeyBzZWxlY3RVc2VyIH0gZnJvbSAnLi4vYWN0aW9ucy91c2VyJ1xuLy8gaW1wb3J0IHN0b3JlIGZyb20gJy4uL3N0b3JlJ1xuXG4vLyBzdG9yZS5zdWJzY3JpYmUoICgpID0+IHtcbi8vIGNvbnNvbGUubG9nKFwiU3RvcmUgY2hhbmdlZFwiLCBzdG9yZS5nZXRTdGF0ZSgpKVxuLy8gfSk7XG4vLyAvL2JlbG93IHNuaXBwZXQgaXMgYSBzYW1wbGUgb2YgaG93IHRvIGFkZCBhIHN0YXRlIGludG8gdGhlIGNvZGVcbi8vIC8vYnV0IHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgY29ycmVzcG9uZGluZyByZWR1Y2VyIGZ1bmN0aW9uIHRvIHJlY29yZCBhbmQgdXBkYXRlIHRoaXMgbmV3IHN0YXRlXG4vLyBzdG9yZS5kaXNwYXRjaCh7dHlwZTogXCJBRERfVVNFUl9OQU1FXCIsIHBheWxvYWQ6IFwiUm9kXCJ9KVxuLy8gc3RvcmUuZGlzcGF0Y2goe3R5cGU6IFwiQUREX1VTRVJfQUdFXCIsIHBheWxvYWQ6IDIzfSlcblxuY2xhc3MgVXNlckxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjcmVhdGVMaXN0SXRlbXMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucHJvcHMudXNlcnMubWFwKHVzZXIgPT4ge1xuICBcdCAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGxpIGtleT17dXNlci5pZH0gb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5zZWxlY3RVc2VyKHVzZXIpfSA+IFxuICAgICAgICAgICAgICB7dXNlci5uYW1lfSB7dXNlci5sYXN0fVxuICAgICAgICAgICAgPC9saT5cbiAgXHQgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gIFx0cmV0dXJuIChcbiAgICAgIDxoND5cbiAgICAgICAgPHVsPlxuICAgICAgICAgIHt0aGlzLmNyZWF0ZUxpc3RJdGVtcygpfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9oND5cbiAgXHQpO1xuICB9XG59XG5mdW5jdGlvbiBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB1c2Vyczogc3RhdGUudXNlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hdGNoRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKSB7XG4gIHJldHVybiAoXG4gICAgYmluZEFjdGlvbkNyZWF0b3JzKHtzZWxlY3RVc2VyOiBzZWxlY3RVc2VyfSwgZGlzcGF0Y2gpXG4gICk7XG59XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWF0Y2hEaXNwYXRjaFRvUHJvcHMpKFVzZXJMaXN0KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1saXN0LmpzXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oW2EsYixjXSkge1xuLy9UaGlzIGNhbGN1bGF0aW9uIGlzIHJvdWdobHkgYWNjdXJhdGUgdG8gbW9udGhzLGFzIHlvdSBjYW4gc2VlLi4uXG52YXIgZCA9IFwiXCI7XG5cbiAgaWYoYjwwKSB7XG4gIFx0YT1hLTEsXG4gIFx0Yj0xMi1NYXRoLmFicyhiKVxuICB9XG4gIGlmKGM8MCkge1xuICBcdGI9Yi0xXG4gIH1cbiAgaWYgKGI9PT0wICYmIGM9PT0wKSB7XG4gICAgZD1cIjogSGV5LCBIYXBweSBCaXJ0aGRheSEhIVwiXG4gIH0gZWxzZSB7XG4gIFx0ZD1cIi5cIlxuICB9XG4gIHJldHVybiAoXG4gICAgW2EsYixkXVxuICApO1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9yZWR1Y2Vycy9hZ2UtY2FsY3VsYXRvci5qc1xuICoqLyIsImltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IHN5bmNIaXN0b3J5V2l0aFN0b3JlLCByb3V0ZXJSZWR1Y2VyIH0gZnJvbSAncmVhY3Qtcm91dGVyLXJlZHV4JztcbmltcG9ydCBSZWR1Y2VyVXNlcnMgZnJvbSAnLi9yZWR1Y2VyLXVzZXJzJztcbmltcG9ydCBSZWR1Y2VyVHVydGxlcyBmcm9tICcuL3JlZHVjZXItdHVydGxlcyc7XG5pbXBvcnQgQWN0aXZlVXNlclJlZHVjZXIgZnJvbSAnLi9yZWR1Y2VyLWFjdGl2ZS11c2VyJztcbmltcG9ydCBBY3RpdmVUdXJ0bGVSZWR1Y2VyIGZyb20gJy4vcmVkdWNlci1hY3RpdmUtdHVydGxlJztcblxuY29uc3QgYWxsUmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoe1xuICB1c2VyczogUmVkdWNlclVzZXJzLFxuICB0dXJ0bGVzOiBSZWR1Y2VyVHVydGxlcyxcbiAgYWN0aXZlVXNlcjogQWN0aXZlVXNlclJlZHVjZXIsXG4gIGFjdGl2ZVR1cnRsZTogQWN0aXZlVHVydGxlUmVkdWNlcixcbiAgcm91dGluZzogcm91dGVyUmVkdWNlclxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFsbFJlZHVjZXJzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL2luZGV4LmpzXG4gKiovIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHN0YXRlPW51bGwsIGFjdGlvbikge1xuXG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIFxuICBcdGNhc2UgXCJUVVJUTEVfU0VMRUNURURcIjpcbiAgXHQgIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbiAgXHQgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn0gIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItYWN0aXZlLXR1cnRsZS5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdGF0ZT1udWxsLCBhY3Rpb24pIHtcblxuICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICBcbiAgXHRjYXNlIFwiVVNFUl9TRUxFQ1RFRFwiOlxuICBcdCAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xuICBcdCAgYnJlYWs7XG4gIFx0Y2FzZSBcIkFERF9VU0VSX05BTUVcIjpcbiAgXHQgIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbiAgXHQgIGJyZWFrO1xuICBcdGNhc2UgXCJBRERfVVNFUl9BR0VcIjpcbiAgXHQgIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbiAgXHQgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn0gIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItYWN0aXZlLXVzZXIuanNcbiAqKi8iLCJpbXBvcnQgTGVvbmFyZG8gZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvbGVvbmFyZG8ucG5nXCJcbmltcG9ydCBNaWNoYWVsYW5nZWxvIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL21pY2hhZWxhbmdlbG8ucG5nXCJcbmltcG9ydCBEb25hdGVsbG8gZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvZG9uYXRlbGxvLnBuZ1wiXG5pbXBvcnQgUmFwaGFlbCBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9yYXBoYWVsLnBuZ1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogXCJMZW9uYXJkb1wiLFxuICAgICAgYWthOiBcIkxlb1wiLFxuICAgICAgYWdlOiBcIjwgMjBcIixcbiAgICAgIGltYWdlOiBMZW9uYXJkbyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxlb25hcmRvIGlzIHRoZSBjb29sLCBjb3VyYWdlb3VzIGxlYWRlciBvZiB0aGUgTmluamEgVHVydGxlcyBhbmQgYSBkZXZvdGVkIHN0dWRlbnQgb2YgTmluanV0c3UsIHVzdWFsbHkgd2VhcmluZyBhIGJsdWUgbWFzayBhbmQgd2llbGRpbmcgdHdvIGthdGFuYXMuIExlYWRlciBpbiBibHVlLlwiIFxuICAgIH0sXG4gICAge1xuICBcdCAgaWQ6IDIsXG4gICAgICBuYW1lOiBcIk1pY2hhZWxhbmdlbG9cIixcbiAgICAgIGFrYTogXCJNaWNrZXlcIixcbiAgICAgIGFnZTogXCJldGVybmFsbHkgPCAyMFwiLFxuICAgICAgaW1hZ2U6IE1pY2hhZWxhbmdlbG8sXG4gICAgICBkZXNjcmlwdGlvbjogXCJNaWNoZWxhbmdlbG8gaXMgdGhlIG1vc3QgY29taWNhbCBvZiB0aGUgTmluamEgVHVydGxlcywgdXN1YWxseSB3ZWFyaW5nIGFuIG9yYW5nZSBtYXNrIGFuZCB3aWVsZGluZyBhIHBhaXIgb2YgbnVuY2h1Y2tzLlwiXG4gICAgfSxcbiAgICB7XG4gIFx0ICBpZDogMyxcbiAgICAgIG5hbWU6IFwiRG9uYXRlbGxvXCIsXG4gICAgICBha2E6IFwiRG9ubmllXCIsXG4gICAgICBhZ2U6IFwiZXRlcm5hbGx5IDwgMjBcIixcbiAgICAgIGltYWdlOiBEb25hdGVsbG8sXG4gICAgICBkZXNjcmlwdGlvbjogXCJEb25hdGVsbG8gaXMgdGhlIHNjaWVudGlzdCwgaW52ZW50b3IsIGVuZ2luZWVyIGFuZCB0ZWNobm9sb2dpY2FsIGdlbml1cyBvZiB0aGUgTmluamEgVHVydGxlcywgdXN1YWxseSB3ZWFyaW5nIGEgcHVycGxlIG1hc2sgYW5kIHdpZWxkaW5nIGEgYm8tc3RhZmYuXCJcbiAgICAgfSxcbiAgICAge1xuICAgICAgaWQ6IDQsXG4gICAgICBuYW1lOiBcIlJhcGhhZWxcIixcbiAgICAgIGFrYTogXCJSYXBoXCIsXG4gICAgICBhZ2U6IFwiZXRlcm5hbGx5IDwgMjBcIixcbiAgICAgIGltYWdlOiBSYXBoYWVsLFxuICAgICAgZGVzY3JpcHRpb246IFwiUmFwaGFlbCBpcyB0aGUgYmFkIGJveSBvZiB0aGUgTmluamEgVHVydGxlcywgd2VhcmluZyBhIHJlZCBtYXNrIGFuZCB3aWVsZGluZyBhIHBhaXIgb2Ygc2Fpcy5cIlxuICAgICB9XG4gIF1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci10dXJ0bGVzLmpzXG4gKiovIiwiaW1wb3J0IGRhVmluY2kgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvZGFWaW5jaS5qcGdcIlxuaW1wb3J0IEVpbnN0ZWluIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL0VpbnN0ZWluLmpwZ1wiXG5pbXBvcnQgRXVsZXIgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvRXVsZXIuanBnXCJcbmltcG9ydCBMZW1haXRyZSBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9MZW1haXRyZS5qcGdcIlxuaW1wb3J0IE1UZXJlc2EgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvTVRlcmVzYS5qcGdcIlxuaW1wb3J0IE5ld3RvbiBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9OZXd0b24uanBnXCJcbmltcG9ydCBTY2hyb2VkaW5nZXIgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvU2Nocm9lZGluZ2VyLmpwZ1wiXG5pbXBvcnQgYWdlQ2FsYyBmcm9tIFwiLi9hZ2UtY2FsY3VsYXRvclwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKSxcbiAgICAgICAgZGQgPSB0b2RheS5nZXREYXRlKCksXG4gICAgICAgIG1tID0gdG9kYXkuZ2V0TW9udGgoKSsxLFxuICAgICAgICB5eXl5ID0gdG9kYXkuZ2V0RnVsbFllYXIoKTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogXCJMZW9uYXJkb1wiLFxuICAgICAgbGFzdDogXCJEYSBWaW5jaVwiLFxuICAgICAgYm9ybk1vbnRoOiBcIkFwcmlsXCIsXG4gICAgICBib3JuRGF5OiAxNSwgXG4gICAgICBib3JuWWVhcjogMTQ1MixcbiAgICAgIGFnZTogYWdlQ2FsYyhbeXl5eS0xNDUyLCBtbS00LCBkZC0xNV0pLFxuICAgICAgaW1hZ2U6IGRhVmluY2ksXG4gICAgICBkZXNjcmlwdGlvbjogXCJMZW9uYXJkbyBkaSBzZXIgUGllcm8gZGEgVmluY2ksIG1vcmUgY29tbW9ubHkgTGVvbmFyZG8gYSBWaW5jaSBvciBzaW1wbHkgTGVvbmFyZG8sIHdhcyBhbiBJdGFsaWFuIHBvbHltYXRoIHdob3NlIGFyZWFzIG9mIGludGVyZXN0IGluY2x1ZGVkIGludmVudGlvbiwgcGFpbnRpbmcsIHNjdWxwdGluZywgYXJjaGl0ZWN0dXJlLCBzY2llbmNlLCBtdXNpYywgbWF0aGVtYXRpY3MsIGVuZ2luZWVyaW5nLCBsaXRlcmF0dXJlLCBhbmF0b215LCBnZW9sb2d5LCBhc3Ryb25vbXksIGJvdGFueSwgd3JpdGluZywgaGlzdG9yeSwgYW5kIGNhcnRvZ3JhcGh5LiBIZSBoYXMgYmVlbiB2YXJpb3VzbHkgY2FsbGVkIHRoZSBmYXRoZXIgb2YgcGFsYWVvbnRvbG9neSwgaWNobm9sb2d5LCBhbmQgYXJjaGl0ZWN0dXJlLCBhbmQgaXMgd2lkZWx5IGNvbnNpZGVyZWQgb25lIG9mIHRoZSBncmVhdGVzdCBwYWludGVycyBvZiBhbGwgdGltZS4gU29tZXRpbWVzIGNyZWRpdGVkIHdpdGggdGhlIGludmVudGlvbnMgb2YgdGhlIHBhcmFjaHV0ZSwgaGVsaWNvcHRlciBhbmQgdGFuaywgaGUgZXBpdG9taXNlZCB0aGUgUmVuYWlzc2FuY2UgaHVtYW5pc3QgaWRlYWwuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAyLFxuICAgICAgbmFtZTogXCJJc2FhY1wiLFxuICAgICAgbGFzdDogXCJOZXd0b25cIixcbiAgICAgIGJvcm5Nb250aDogXCJKYW51YXJ5XCIsXG4gICAgICBib3JuRGF5OiA0LCBcbiAgICAgIGJvcm5ZZWFyOiAxNjQzLFxuICAgICAgYWdlOiBhZ2VDYWxjKFt5eXl5LTE2NDMsIG1tLTEsIGRkLTRdKSxcbiAgICAgIGltYWdlOiBOZXd0b24sXG4gICAgICBkZXNjcmlwdGlvbjogXCJTaXIgSXNhYWMgTmV3dG9uIHdhcyBhbiBFbmdsaXNoIHBoeXNpY2lzdCBhbmQgbWF0aGVtYXRpY2lhbiAoZGVzY3JpYmVkIGluIGhpcyBvd24gZGF5IGFzIGEgXFxcIm5hdHVyYWwgcGhpbG9zb3BoZXJcXFwiKSB3aG8gaXMgd2lkZWx5IHJlY29nbmlzZWQgYXMgb25lIG9mIHRoZSBtb3N0IGluZmx1ZW50aWFsIHNjaWVudGlzdHMgb2YgYWxsIHRpbWUgYW5kIGEga2V5IGZpZ3VyZSBpbiB0aGUgc2NpZW50aWZpYyByZXZvbHV0aW9uLiBIaXMgYm9vayBQaGlsb3NvcGhpw6YgTmF0dXJhbGlzIFByaW5jaXBpYSBNYXRoZW1hdGljYSAoXFxcIk1hdGhlbWF0aWNhbCBQcmluY2lwbGVzIG9mIE5hdHVyYWwgUGhpbG9zb3BoeVxcXCIpLCBmaXJzdCBwdWJsaXNoZWQgaW4gMTY4NywgbGFpZCB0aGUgZm91bmRhdGlvbnMgZm9yIGNsYXNzaWNhbCBtZWNoYW5pY3MuIE5ld3RvbiBtYWRlIHNlbWluYWwgY29udHJpYnV0aW9ucyB0byBvcHRpY3MsIGFuZCBoZSBzaGFyZXMgY3JlZGl0IHdpdGggR290dGZyaWVkIFdpbGhlbG0gTGVpYm5peiBmb3IgdGhlIGRldmVsb3BtZW50IG9mIGNhbGN1bHVzLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMyxcbiAgICAgIG5hbWU6IFwiTGVvbmhhcmRcIixcbiAgICAgIGxhc3Q6IFwiRXVsZXJcIixcbiAgICAgIGJvcm5Nb250aDogXCJBcHJpbFwiLFxuICAgICAgYm9ybkRheTogMTUsIFxuICAgICAgYm9yblllYXI6IDE3MDcsXG4gICAgICBhZ2U6IGFnZUNhbGMoW3l5eXktMTcwNywgbW0tNCwgZGQtMTVdKSxcbiAgICAgIGltYWdlOiBFdWxlcixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxlb25oYXJkIEV1bGVyIHdhcyBhIFN3aXNzIG1hdGhlbWF0aWNpYW4sIHBoeXNpY2lzdCwgYXN0cm9ub21lciwgbG9naWNpYW4gYW5kIGVuZ2luZWVyIHdobyBtYWRlIGltcG9ydGFudCBhbmQgaW5mbHVlbnRpYWwgZGlzY292ZXJpZXMgaW4gbWFueSBicmFuY2hlcyBvZiBtYXRoZW1hdGljcyBsaWtlIGluZmluaXRlc2ltYWwgY2FsY3VsdXMgYW5kIGdyYXBoIHRoZW9yeSB3aGlsZSBhbHNvIG1ha2luZyBwaW9uZWVyaW5nIGNvbnRyaWJ1dGlvbnMgdG8gc2V2ZXJhbCBicmFuY2hlcyBzdWNoIGFzIHRvcG9sb2d5IGFuZCBhbmFseXRpYyBudW1iZXIgdGhlb3J5LiBIZSBhbHNvIGludHJvZHVjZWQgbXVjaCBvZiB0aGUgbW9kZXJuIG1hdGhlbWF0aWNhbCB0ZXJtaW5vbG9neSBhbmQgbm90YXRpb24sIHBhcnRpY3VsYXJseSBmb3IgbWF0aGVtYXRpY2FsIGFuYWx5c2lzLCBzdWNoIGFzIHRoZSBub3Rpb24gb2YgYSBtYXRoZW1hdGljYWwgZnVuY3Rpb24uICBIZSBpcyBhbHNvIGtub3duIGZvciBoaXMgd29yayBpbiBtZWNoYW5pY3MsIGZsdWlkIGR5bmFtaWNzLCBvcHRpY3MsIGFzdHJvbm9teSwgYW5kIG11c2ljIHRoZW9yeS5cIlxuICAgIH0sICBcbiAgICB7XG4gICAgICBpZDogNCxcbiAgICAgIG5hbWU6IFwiQWxiZXJ0XCIsXG4gICAgICBsYXN0OiBcIkVpbnN0ZWluXCIsXG4gICAgICBib3JuTW9udGg6IFwiTWFyY2hcIixcbiAgICAgIGJvcm5EYXk6IDE0LCBcbiAgICAgIGJvcm5ZZWFyOiAxODc5LFxuICAgICAgYWdlOiBhZ2VDYWxjKFt5eXl5LTE4NzksIG1tLTMsIGRkLTE0XSksXG4gICAgICBpbWFnZTogRWluc3RlaW4sXG4gICAgICBkZXNjcmlwdGlvbjogXCJBbGJlcnQgRWluc3RlaW4gd2FzIGEgR2VybWFuLWJvcm4gdGhlb3JldGljYWwgcGh5c2ljaXN0LiBIZSBkZXZlbG9wZWQgdGhlIGdlbmVyYWwgdGhlb3J5IG9mIHJlbGF0aXZpdHksIG9uZSBvZiB0aGUgdHdvIHBpbGxhcnMgb2YgbW9kZXJuIHBoeXNpY3MgKGFsb25nc2lkZSBxdWFudHVtIG1lY2hhbmljcykuICBFaW5zdGVpbidzIHdvcmsgaXMgYWxzbyBrbm93biBmb3IgaXRzIGluZmx1ZW5jZSBvbiB0aGUgcGhpbG9zb3BoeSBvZiBzY2llbmNlLiAgRWluc3RlaW4gaXMgYmVzdCBrbm93biBpbiBwb3B1bGFyIGN1bHR1cmUgZm9yIGhpcyBtYXNz4oCTZW5lcmd5IGVxdWl2YWxlbmNlIGZvcm11bGEgRSA9IG1jMiAod2hpY2ggaGFzIGJlZW4gZHViYmVkIFxcXCJ0aGUgd29ybGQncyBtb3N0IGZhbW91cyBlcXVhdGlvblxcXCIpLiAgSGUgcmVjZWl2ZWQgdGhlIDE5MjEgTm9iZWwgUHJpemUgaW4gUGh5c2ljcyBmb3IgaGlzIFxcXCJzZXJ2aWNlcyB0byB0aGVvcmV0aWNhbCBwaHlzaWNzXFxcIiwgaW4gcGFydGljdWxhciBoaXMgZGlzY292ZXJ5IG9mIHRoZSBsYXcgb2YgdGhlIHBob3RvZWxlY3RyaWMgZWZmZWN0LCBhIHBpdm90YWwgc3RlcCBpbiB0aGUgZXZvbHV0aW9uIG9mIHF1YW50dW0gdGhlb3J5LlwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNSxcbiAgICAgIG5hbWU6IFwiRXJ3aW5cIixcbiAgICAgIGxhc3Q6IFwiU2Nocm9lZGluZ2VyXCIsXG4gICAgICBib3JuTW9udGg6IFwiQXVndXN0XCIsXG4gICAgICBib3JuRGF5OiAxMiwgXG4gICAgICBib3JuWWVhcjogMTg4NyxcbiAgICAgIGFnZTogYWdlQ2FsYyhbeXl5eS0xODg3LCBtbS04LCBkZC0xMl0pLFxuICAgICAgaW1hZ2U6IFNjaHJvZWRpbmdlcixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkVyd2luIFJ1ZG9sZiBKb3NlZiBBbGV4YW5kZXIgU2NocsO2ZGluZ2VyLCBzb21ldGltZXMgd3JpdHRlbiBhcyBFcndpbiBTY2hyb2RpbmdlciBvciBFcndpbiBTY2hyb2VkaW5nZXIsIHdhcyBhIE5vYmVsIFByaXplLXdpbm5pbmcgQXVzdHJpYW4gcGh5c2ljaXN0IHdobyBkZXZlbG9wZWQgYSBudW1iZXIgb2YgZnVuZGFtZW50YWwgcmVzdWx0cyBpbiB0aGUgZmllbGQgb2YgcXVhbnR1bSB0aGVvcnksIHdoaWNoIGZvcm1lZCB0aGUgYmFzaXMgb2Ygd2F2ZSBtZWNoYW5pY3M6IGhlIGZvcm11bGF0ZWQgdGhlIHdhdmUgZXF1YXRpb24gKHN0YXRpb25hcnkgYW5kIHRpbWUtZGVwZW5kZW50IFNjaHLDtmRpbmdlciBlcXVhdGlvbikgYW5kIHJldmVhbGVkIHRoZSBpZGVudGl0eSBvZiBoaXMgZGV2ZWxvcG1lbnQgb2YgdGhlIGZvcm1hbGlzbSBhbmQgbWF0cml4IG1lY2hhbmljcy4gU2NocsO2ZGluZ2VyIHByb3Bvc2VkIGFuIG9yaWdpbmFsIGludGVycHJldGF0aW9uIG9mIHRoZSBwaHlzaWNhbCBtZWFuaW5nIG9mIHRoZSB3YXZlIGZ1bmN0aW9uLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogNixcbiAgICAgIG5hbWU6IFwiR2Vvcmdlc1wiLFxuICAgICAgbGFzdDogXCJMZW1haXRyZVwiLFxuICAgICAgYm9ybk1vbnRoOiBcIkp1bHlcIixcbiAgICAgIGJvcm5EYXk6IDE3LCBcbiAgICAgIGJvcm5ZZWFyOiAxODk0LFxuICAgICAgYWdlOiBhZ2VDYWxjKFt5eXl5LTE4OTQsIG1tLTcsIGRkLTE3XSksXG4gICAgICBpbWFnZTogTGVtYWl0cmUsXG4gICAgICBkZXNjcmlwdGlvbjogXCJHZW9yZ2VzIEhlbnJpIEpvc2VwaCDDiWRvdWFyZCBMZW1hw650cmUgd2FzIGEgQmVsZ2lhbiBwcmllc3QsIGFzdHJvbm9tZXIgYW5kIHByb2Zlc3NvciBvZiBwaHlzaWNzIGF0IHRoZSBDYXRob2xpYyBVbml2ZXJzaXR5IG9mIExldXZlbi4gIEhlIHByb3Bvc2VkIHRoZSB0aGVvcnkgb2YgdGhlIGV4cGFuc2lvbiBvZiB0aGUgdW5pdmVyc2UsIHdpZGVseSBtaXNhdHRyaWJ1dGVkIHRvIEVkd2luIEh1YmJsZS4gIEhlIHdhcyB0aGUgZmlyc3QgdG8gZGVyaXZlIHdoYXQgaXMgbm93IGtub3duIGFzIEh1YmJsZSdzIGxhdyBhbmQgbWFkZSB0aGUgZmlyc3QgZXN0aW1hdGlvbiBvZiB3aGF0IGlzIG5vdyBjYWxsZWQgdGhlIEh1YmJsZSBjb25zdGFudCwgd2hpY2ggaGUgcHVibGlzaGVkIGluIDE5MjcsIHR3byB5ZWFycyBiZWZvcmUgSHViYmxlJ3MgYXJ0aWNsZS4gIExlbWHDrnRyZSBhbHNvIHByb3Bvc2VkIHdoYXQgYmVjYW1lIGtub3duIGFzIHRoZSBCaWcgQmFuZyB0aGVvcnkgb2YgdGhlIG9yaWdpbiBvZiB0aGUgdW5pdmVyc2UsIHdoaWNoIGhlIGNhbGxlZCBoaXMgXFxcImh5cG90aGVzaXMgb2YgdGhlIHByaW1ldmFsIGF0b21cXFwiIG9yIHRoZSBcXFwiQ29zbWljIEVnZ1xcXCIuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA3LFxuICAgICAgbmFtZTogXCJNb3RoZXJcIixcbiAgICAgIGxhc3Q6IFwiVGVyZXNhXCIsXG4gICAgICBib3JuTW9udGg6IFwiQXVndXN0XCIsXG4gICAgICBib3JuRGF5OiAyNiwgXG4gICAgICBib3JuWWVhcjogMTkxMCxcbiAgICAgIGFnZTogYWdlQ2FsYyhbeXl5eS0xOTEwLCBtbS04LCBkZC0yNl0pLFxuICAgICAgaW1hZ2U6IE1UZXJlc2EsXG4gICAgICBkZXNjcmlwdGlvbjogXCJNb3RoZXIgVGVyZXNhIE1DLCBrbm93biBpbiB0aGUgQ2F0aG9saWMgQ2h1cmNoIGFzIFNhaW50IFRlcmVzYSBvZiBDYWxjdXR0YSB3YXMgYW4gQWxiYW5pYW4tSW5kaWFuIFJvbWFuIENhdGhvbGljIG51biBhbmQgbWlzc2lvbmFyeS4gIFNoZSB3YXMgYm9ybiBpbiBTa29wamUgKG5vdyBjYXBpdGFsIG9mIHRoZSBSZXB1YmxpYyBvZiBNYWNlZG9uaWEpLCB0aGVuIHBhcnQgb2YgdGhlIEtvc292byBWaWxheWV0IGluIHRoZSBPdHRvbWFuIEVtcGlyZS4gQWZ0ZXIgaGF2aW5nIGxpdmVkIGluIE1hY2Vkb25pYSBmb3IgZWlnaHRlZW4geWVhcnMsIHNoZSBtb3ZlZCB0byBJcmVsYW5kIGFuZCB0aGVuIHRvIEluZGlhLCB3aGVyZSBzaGUgbGl2ZWQgZm9yIG1vc3Qgb2YgaGVyIGxpZmUuICBJbiAxOTUwLCBUZXJlc2EgZm91bmRlZCB0aGUgTWlzc2lvbmFyaWVzIG9mIENoYXJpdHksIGEgUm9tYW4gQ2F0aG9saWMgcmVsaWdpb3VzIGNvbmdyZWdhdGlvbiwgd2hpY2ggaW4gMjAxMiBjb25zaXN0ZWQgb2Ygb3ZlciA0LDUwMCBzaXN0ZXJzIGFuZCB3YXMgYWN0aXZlIGluIDEzMyBjb3VudHJpZXMuIFRoZXkgcnVuIGhvbWVzIGZvciBwZW9wbGUgZHlpbmcgb2YgSElWL0FJRFMsIGxlcHJvc3kgYW5kIHR1YmVyY3Vsb3Npczsgc291cCBraXRjaGVuczsgZGlzcGVuc2FyaWVzIGFuZCBtb2JpbGUgY2xpbmljczsgY2hpbGRyZW4ncyBhbmQgZmFtaWx5IGNvdW5zZWxsaW5nIHByb2dyYW1tZXM7IG9ycGhhbmFnZXM7IGFuZCBzY2hvb2xzLiBNZW1iZXJzIG11c3QgYWRoZXJlIHRvIHRoZSB2b3dzIG9mIGNoYXN0aXR5LCBwb3ZlcnR5LCBhbmQgb2JlZGllbmNlLCBhcyB3ZWxsIGFzIGEgZm91cnRoIHZvdywgdG8gZ2l2ZSBcXFwid2hvbGVoZWFydGVkIGZyZWUgc2VydmljZSB0byB0aGUgcG9vcmVzdCBvZiB0aGUgcG9vci5cXFwiXCJcbiAgICB9LFxuICBdXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItdXNlcnMuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBSb3V0ZXIsIFJvdXRlLCBJbmRleFJvdXRlLCBicm93c2VySGlzdG9yeSB9IGZyb20gJ3JlYWN0LXJvdXRlcidcbmltcG9ydCB7IHN5bmNIaXN0b3J5V2l0aFN0b3JlLCByb3V0ZXJSZWR1Y2VyIH0gZnJvbSAncmVhY3Qtcm91dGVyLXJlZHV4J1xuaW1wb3J0IHsgQ29udGFpbmVyIH0gZnJvbSAnLi9jb250YWluZXInXG5pbXBvcnQgeyBIb21lIH0gZnJvbSAnLi9ob21lJ1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdXNlcidcbmltcG9ydCB7IFR1cnRsZXMgfSBmcm9tICcuL3R1cnRsZXMnXG5pbXBvcnQgeyBOb3RGb3VuZCB9IGZyb20gJy4vbm90Zm91bmQnXG5pbXBvcnQgc3RvcmUgZnJvbSAnLi4vZGV2L2pzL3N0b3JlJ1xuXG5jb25zdCBoaXN0b3J5ID0gc3luY0hpc3RvcnlXaXRoU3RvcmUoYnJvd3Nlckhpc3RvcnksIHN0b3JlKVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHAgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8Um91dGVyIGhpc3Rvcnk9e2hpc3Rvcnl9PlxuICAgICAgICA8Um91dGUgcGF0aD0nLycgY29tcG9uZW50PXtDb250YWluZXJ9PlxuXG4gICAgICAgICAgPEluZGV4Um91dGUgY29tcG9uZW50PXtIb21lfSAvPlxuICAgICAgICAgIDxSb3V0ZSBwYXRoPSd1c2VyJyBjb21wb25lbnQ9e1VzZXJ9IC8+ICBcbiAgICAgICAgICA8Um91dGUgcGF0aD0ndHVydGxlcygvOm5hbWUpJyBjb21wb25lbnQ9e1R1cnRsZXN9IC8+XG4gICAgICAgICAgPFJvdXRlIHBhdGg9JyonIGNvbXBvbmVudD17Tm90Rm91bmR9IC8+XG5cbiAgICAgICAgPC9Sb3V0ZT5cbiAgICAgIDwvUm91dGVyPlxuICAgIClcbiAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcm91dGVzL2FwcC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEluZGV4TGluayB9IGZyb20gJ3JlYWN0LXJvdXRlcidcblxudmFyIG15U3R5bGUgPSB7XG4gICAgZm9udEZhbWlseTogJ0Rvc2lzJ1xuICB9XG5cbmV4cG9ydCBjb25zdCBDb250YWluZXIgPSAocHJvcHMpID0+IChcbiAgPGRpdiBzdHlsZT17bXlTdHlsZX0+XG4gICAgPE5hdiAvPiBcbiAgICB7cHJvcHMuY2hpbGRyZW59XG4gIDwvZGl2PlxuKVxuY29uc3QgTmF2ID0gKCkgPT4gKFxuICA8bmF2IGNsYXNzPVwibmF2YmFyIG5hdmJhci1pbnZlcnNlXCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lci1mbHVpZFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1oZWFkZXJcIj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJuYXZiYXItdG9nZ2xlXCIgZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiIGRhdGEtdGFyZ2V0PVwiI215TmF2YmFyXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLWJhclwiPjwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tYmFyXCI+PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi1iYXJcIj48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbGxhcHNlIG5hdmJhci1jb2xsYXBzZVwiIGlkPVwibXlOYXZiYXJcIj5cbiAgICAgIDx1bCBjbGFzcz1cIm5hdiBuYXZiYXItbmF2XCI+XG4gICAgICAgIDxsaT48SW5kZXhMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nYWN0aXZlJyB0bz0nLyc+SG9tZTwvSW5kZXhMaW5rPjwvbGk+XG4gICAgICAgIDxsaT48SW5kZXhMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nYWN0aXZlJyB0bz0nL3VzZXInPkZhbW91cyBQZW9wbGU8L0luZGV4TGluaz48L2xpPlxuICAgICAgICA8bGk+PEluZGV4TGluayBhY3RpdmVDbGFzc05hbWU9J2FjdGl2ZScgdG89Jy90dXJ0bGVzJz5NdXRhbnQgVHVydGxlczwvSW5kZXhMaW5rPjwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICA8L25hdj5cbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy9jb250YWluZXIuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gIFxudmFyIG15U3R5bGUgPSB7XG4gIFx0bWFyZ2luTGVmdDogMzAsXG4gIFx0bWFyZ2luUmlnaHQ6IDI1LFxuICBcdGZvbnRGYW1pbHk6ICdEb3Npcydcbn1cblxuZXhwb3J0IGNvbnN0IEhvbWUgPSAoKSA9PiAoXG4gIDxkaXYgc3R5bGU9e215U3R5bGV9PlxuICAgIDxiciAvPlxuICAgIDxoMj5XZWxjb21lIHRvIHRoZSBXb3JsZCBvZiBmYW1FIGFuZCBtdVRBYXRJb05zITwvaDI+XG4gICAgPGg0Pj4gY2xpY2sgb24gbmF2aWdhdGlvbiB0byBzZWUgbW9yZS4uLjwvaDQ+XG4gIDwvZGl2PlxuKVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvaG9tZS5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IE5vdEZvdW5kID0gKCkgPT4gKFxuICA8aDI+NDA0OiBUaGlzIHBhZ2UgaXMgbm90IGZvdW5kITwvaDI+XG4pXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvbm90Zm91bmQuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgQ29tcFR1cnRsZSBmcm9tICcuLi9kZXYvanMvY29tcG9uZW50cy9jb21wLXR1cnRsZSdcblxudmFyIG15U3R5bGUgPSB7XG4gIFx0bWFyZ2luTGVmdDogMzAsXG4gIFx0bWFyZ2luUmlnaHQ6IDI1LFxuICBcdGZvbnRGYW1pbHk6ICdEb3Npcydcbn1cblxuZXhwb3J0IGNvbnN0IFR1cnRsZXMgPSAocHJvcHMpID0+IChcbiAgPGRpdiBzdHlsZT17bXlTdHlsZX0+XG4gICAgPGJyIC8+XG4gICAgPGgyPlRoaXMgaXMgdGhlIFR1cnRsZXMgUGFnZTwvaDI+XG4gICAgPENvbXBUdXJ0bGUgLz5cbiAgPC9kaXY+XG4pXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvdHVydGxlcy5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBDb21wVXNlciBmcm9tICcuLi9kZXYvanMvY29tcG9uZW50cy9jb21wLXVzZXInXG5cbnZhciBteVN0eWxlID0ge1xuICBcdG1hcmdpbkxlZnQ6IDMwLFxuICBcdG1hcmdpblJpZ2h0OiAyNSxcbiAgXHRmb250RmFtaWx5OiAnRG9zaXMnXG59XG5cbmV4cG9ydCBjb25zdCBVc2VyID0gKCkgPT4gKFxuICA8ZGl2IHN0eWxlPXtteVN0eWxlfT5cbiAgICA8YnIgLz5cbiAgICA8aDI+VGhpcyBpcyB0aGUgRmFtb3VzIFBlb3BsZSBQYWdlPC9oMj5cbiAgICA8Q29tcFVzZXIgLz5cbiAgPC9kaXY+XG4pXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvdXNlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RET00nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LWRvbS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB1bmRlZmluZWQ7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3N0b3JlU2hhcGUgPSByZXF1aXJlKCcuLi91dGlscy9zdG9yZVNoYXBlJyk7XG5cbnZhciBfc3RvcmVTaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdG9yZVNoYXBlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKSB7XG4gIGlmIChkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IHRydWU7XG5cbiAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKCc8UHJvdmlkZXI+IGRvZXMgbm90IHN1cHBvcnQgY2hhbmdpbmcgYHN0b3JlYCBvbiB0aGUgZmx5LiAnICsgJ0l0IGlzIG1vc3QgbGlrZWx5IHRoYXQgeW91IHNlZSB0aGlzIGVycm9yIGJlY2F1c2UgeW91IHVwZGF0ZWQgdG8gJyArICdSZWR1eCAyLnggYW5kIFJlYWN0IFJlZHV4IDIueCB3aGljaCBubyBsb25nZXIgaG90IHJlbG9hZCByZWR1Y2VycyAnICsgJ2F1dG9tYXRpY2FsbHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yZWR1eC9yZWxlYXNlcy8nICsgJ3RhZy92Mi4wLjAgZm9yIHRoZSBtaWdyYXRpb24gaW5zdHJ1Y3Rpb25zLicpO1xufVxuXG52YXIgUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHsgc3RvcmU6IHRoaXMuc3RvcmUgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBQcm92aWRlcihwcm9wcywgY29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm92aWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgIF90aGlzLnN0b3JlID0gcHJvcHMuc3RvcmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIF9yZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gUHJvdmlkZXI7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFByb3ZpZGVyO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgIHZhciBuZXh0U3RvcmUgPSBuZXh0UHJvcHMuc3RvcmU7XG5cbiAgICBpZiAoc3RvcmUgIT09IG5leHRTdG9yZSkge1xuICAgICAgd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKTtcbiAgICB9XG4gIH07XG59XG5cblByb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl0uaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IF9yZWFjdC5Qcm9wVHlwZXMuZWxlbWVudC5pc1JlcXVpcmVkXG59O1xuUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdLmlzUmVxdWlyZWRcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvUHJvdmlkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29ubmVjdDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfc3RvcmVTaGFwZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0b3JlU2hhcGUnKTtcblxudmFyIF9zdG9yZVNoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0b3JlU2hhcGUpO1xuXG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJy4uL3V0aWxzL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgX3NoYWxsb3dFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFsbG93RXF1YWwpO1xuXG52YXIgX3dyYXBBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dyYXBBY3Rpb25DcmVhdG9ycycpO1xuXG52YXIgX3dyYXBBY3Rpb25DcmVhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQWN0aW9uQ3JlYXRvcnMpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzID0gcmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob2lzdE5vblJlYWN0U3RhdGljcyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSkge1xuICByZXR1cm4ge307XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG52YXIgZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIHsgZGlzcGF0Y2g6IGRpc3BhdGNoIH07XG59O1xudmFyIGRlZmF1bHRNZXJnZVByb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBwYXJlbnRQcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59O1xuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSB7XG4gIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxudmFyIGVycm9yT2JqZWN0ID0geyB2YWx1ZTogbnVsbCB9O1xuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIGN0eCkge1xuICB0cnkge1xuICAgIHJldHVybiBmbi5hcHBseShjdHgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JPYmplY3QudmFsdWUgPSBlO1xuICAgIHJldHVybiBlcnJvck9iamVjdDtcbiAgfVxufVxuXG4vLyBIZWxwcyB0cmFjayBob3QgcmVsb2FkaW5nLlxudmFyIG5leHRWZXJzaW9uID0gMDtcblxuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcykge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzNdO1xuXG4gIHZhciBzaG91bGRTdWJzY3JpYmUgPSBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyk7XG4gIHZhciBtYXBTdGF0ZSA9IG1hcFN0YXRlVG9Qcm9wcyB8fCBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzO1xuXG4gIHZhciBtYXBEaXNwYXRjaCA9IHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtYXBEaXNwYXRjaCA9IG1hcERpc3BhdGNoVG9Qcm9wcztcbiAgfSBlbHNlIGlmICghbWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gICAgbWFwRGlzcGF0Y2ggPSBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzO1xuICB9IGVsc2Uge1xuICAgIG1hcERpc3BhdGNoID0gKDAsIF93cmFwQWN0aW9uQ3JlYXRvcnMyW1wiZGVmYXVsdFwiXSkobWFwRGlzcGF0Y2hUb1Byb3BzKTtcbiAgfVxuXG4gIHZhciBmaW5hbE1lcmdlUHJvcHMgPSBtZXJnZVByb3BzIHx8IGRlZmF1bHRNZXJnZVByb3BzO1xuICB2YXIgX29wdGlvbnMkcHVyZSA9IG9wdGlvbnMucHVyZTtcbiAgdmFyIHB1cmUgPSBfb3B0aW9ucyRwdXJlID09PSB1bmRlZmluZWQgPyB0cnVlIDogX29wdGlvbnMkcHVyZTtcbiAgdmFyIF9vcHRpb25zJHdpdGhSZWYgPSBvcHRpb25zLndpdGhSZWY7XG4gIHZhciB3aXRoUmVmID0gX29wdGlvbnMkd2l0aFJlZiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyR3aXRoUmVmO1xuXG4gIHZhciBjaGVja01lcmdlZEVxdWFscyA9IHB1cmUgJiYgZmluYWxNZXJnZVByb3BzICE9PSBkZWZhdWx0TWVyZ2VQcm9wcztcblxuICAvLyBIZWxwcyB0cmFjayBob3QgcmVsb2FkaW5nLlxuICB2YXIgdmVyc2lvbiA9IG5leHRWZXJzaW9uKys7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXBXaXRoQ29ubmVjdChXcmFwcGVkQ29tcG9uZW50KSB7XG4gICAgdmFyIGNvbm5lY3REaXNwbGF5TmFtZSA9ICdDb25uZWN0KCcgKyBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSArICcpJztcblxuICAgIGZ1bmN0aW9uIGNoZWNrU3RhdGVTaGFwZShwcm9wcywgbWV0aG9kTmFtZSkge1xuICAgICAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkocHJvcHMpKSB7XG4gICAgICAgICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKShtZXRob2ROYW1lICsgJygpIGluICcgKyBjb25uZWN0RGlzcGxheU5hbWUgKyAnIG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiAnICsgKCdJbnN0ZWFkIHJlY2VpdmVkICcgKyBwcm9wcyArICcuJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNZXJnZWRQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcykge1xuICAgICAgdmFyIG1lcmdlZFByb3BzID0gZmluYWxNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIHBhcmVudFByb3BzKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrU3RhdGVTaGFwZShtZXJnZWRQcm9wcywgJ21lcmdlUHJvcHMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9XG5cbiAgICB2YXIgQ29ubmVjdCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgICBfaW5oZXJpdHMoQ29ubmVjdCwgX0NvbXBvbmVudCk7XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICFwdXJlIHx8IHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZCB8fCB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gQ29ubmVjdChwcm9wcywgY29udGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29ubmVjdCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XG5cbiAgICAgICAgX3RoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIF90aGlzLnN0b3JlID0gcHJvcHMuc3RvcmUgfHwgY29udGV4dC5zdG9yZTtcblxuICAgICAgICAoMCwgX2ludmFyaWFudDJbXCJkZWZhdWx0XCJdKShfdGhpcy5zdG9yZSwgJ0NvdWxkIG5vdCBmaW5kIFwic3RvcmVcIiBpbiBlaXRoZXIgdGhlIGNvbnRleHQgb3IgJyArICgncHJvcHMgb2YgXCInICsgY29ubmVjdERpc3BsYXlOYW1lICsgJ1wiLiAnKSArICdFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCAnICsgKCdvciBleHBsaWNpdGx5IHBhc3MgXCJzdG9yZVwiIGFzIGEgcHJvcCB0byBcIicgKyBjb25uZWN0RGlzcGxheU5hbWUgKyAnXCIuJykpO1xuXG4gICAgICAgIHZhciBzdG9yZVN0YXRlID0gX3RoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7IHN0b3JlU3RhdGU6IHN0b3JlU3RhdGUgfTtcbiAgICAgICAgX3RoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXB1dGVTdGF0ZVByb3BzID0gZnVuY3Rpb24gY29tcHV0ZVN0YXRlUHJvcHMoc3RvcmUsIHByb3BzKSB7XG4gICAgICAgIGlmICghdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyZUZpbmFsTWFwU3RhdGUoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBzdGF0ZVByb3BzID0gdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzID8gdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgcHJvcHMpIDogdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1N0YXRlU2hhcGUoc3RhdGVQcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZVByb3BzO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29uZmlndXJlRmluYWxNYXBTdGF0ZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZUZpbmFsTWFwU3RhdGUoc3RvcmUsIHByb3BzKSB7XG4gICAgICAgIHZhciBtYXBwZWRTdGF0ZSA9IG1hcFN0YXRlKHN0b3JlLmdldFN0YXRlKCksIHByb3BzKTtcbiAgICAgICAgdmFyIGlzRmFjdG9yeSA9IHR5cGVvZiBtYXBwZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzID0gaXNGYWN0b3J5ID8gbWFwcGVkU3RhdGUgOiBtYXBTdGF0ZTtcbiAgICAgICAgdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzID0gdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcy5sZW5ndGggIT09IDE7XG5cbiAgICAgICAgaWYgKGlzRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVTdGF0ZVByb3BzKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShtYXBwZWRTdGF0ZSwgJ21hcFN0YXRlVG9Qcm9wcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWRTdGF0ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXB1dGVEaXNwYXRjaFByb3BzID0gZnVuY3Rpb24gY29tcHV0ZURpc3BhdGNoUHJvcHMoc3RvcmUsIHByb3BzKSB7XG4gICAgICAgIGlmICghdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyZUZpbmFsTWFwRGlzcGF0Y2goc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXNwYXRjaCA9IHN0b3JlLmRpc3BhdGNoO1xuXG4gICAgICAgIHZhciBkaXNwYXRjaFByb3BzID0gdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzID8gdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgcHJvcHMpIDogdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCk7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1N0YXRlU2hhcGUoZGlzcGF0Y2hQcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwYXRjaFByb3BzO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaCA9IGZ1bmN0aW9uIGNvbmZpZ3VyZUZpbmFsTWFwRGlzcGF0Y2goc3RvcmUsIHByb3BzKSB7XG4gICAgICAgIHZhciBtYXBwZWREaXNwYXRjaCA9IG1hcERpc3BhdGNoKHN0b3JlLmRpc3BhdGNoLCBwcm9wcyk7XG4gICAgICAgIHZhciBpc0ZhY3RvcnkgPSB0eXBlb2YgbWFwcGVkRGlzcGF0Y2ggPT09ICdmdW5jdGlvbic7XG5cbiAgICAgICAgdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcyA9IGlzRmFjdG9yeSA/IG1hcHBlZERpc3BhdGNoIDogbWFwRGlzcGF0Y2g7XG4gICAgICAgIHRoaXMuZG9EaXNwYXRjaFByb3BzRGVwZW5kT25Pd25Qcm9wcyA9IHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMubGVuZ3RoICE9PSAxO1xuXG4gICAgICAgIGlmIChpc0ZhY3RvcnkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlRGlzcGF0Y2hQcm9wcyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1N0YXRlU2hhcGUobWFwcGVkRGlzcGF0Y2gsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkRGlzcGF0Y2g7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS51cGRhdGVTdGF0ZVByb3BzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZVByb3BzSWZOZWVkZWQoKSB7XG4gICAgICAgIHZhciBuZXh0U3RhdGVQcm9wcyA9IHRoaXMuY29tcHV0ZVN0YXRlUHJvcHModGhpcy5zdG9yZSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlUHJvcHMgJiYgKDAsIF9zaGFsbG93RXF1YWwyW1wiZGVmYXVsdFwiXSkobmV4dFN0YXRlUHJvcHMsIHRoaXMuc3RhdGVQcm9wcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS51cGRhdGVEaXNwYXRjaFByb3BzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVEaXNwYXRjaFByb3BzSWZOZWVkZWQoKSB7XG4gICAgICAgIHZhciBuZXh0RGlzcGF0Y2hQcm9wcyA9IHRoaXMuY29tcHV0ZURpc3BhdGNoUHJvcHModGhpcy5zdG9yZSwgdGhpcy5wcm9wcyk7XG4gICAgICAgIGlmICh0aGlzLmRpc3BhdGNoUHJvcHMgJiYgKDAsIF9zaGFsbG93RXF1YWwyW1wiZGVmYXVsdFwiXSkobmV4dERpc3BhdGNoUHJvcHMsIHRoaXMuZGlzcGF0Y2hQcm9wcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoUHJvcHMgPSBuZXh0RGlzcGF0Y2hQcm9wcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS51cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHRNZXJnZWRQcm9wcyA9IGNvbXB1dGVNZXJnZWRQcm9wcyh0aGlzLnN0YXRlUHJvcHMsIHRoaXMuZGlzcGF0Y2hQcm9wcywgdGhpcy5wcm9wcyk7XG4gICAgICAgIGlmICh0aGlzLm1lcmdlZFByb3BzICYmIGNoZWNrTWVyZ2VkRXF1YWxzICYmICgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHRNZXJnZWRQcm9wcywgdGhpcy5tZXJnZWRQcm9wcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lcmdlZFByb3BzID0gbmV4dE1lcmdlZFByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmlzU3Vic2NyaWJlZCA9IGZ1bmN0aW9uIGlzU3Vic2NyaWJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudHJ5U3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5U3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoc2hvdWxkU3Vic2NyaWJlICYmICF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IHRoaXMuc3RvcmUuc3Vic2NyaWJlKHRoaXMuaGFuZGxlQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnRyeVVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdHJ5VW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnRyeVN1YnNjcmliZSgpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICAgIGlmICghcHVyZSB8fCAhKDAsIF9zaGFsbG93RXF1YWwyW1wiZGVmYXVsdFwiXSkobmV4dFByb3BzLCB0aGlzLnByb3BzKSkge1xuICAgICAgICAgIHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFByb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXJnZWRQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICBpZiAoIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RvcmVTdGF0ZSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIHByZXZTdG9yZVN0YXRlID0gdGhpcy5zdGF0ZS5zdG9yZVN0YXRlO1xuICAgICAgICBpZiAocHVyZSAmJiBwcmV2U3RvcmVTdGF0ZSA9PT0gc3RvcmVTdGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwdXJlICYmICF0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMpIHtcbiAgICAgICAgICB2YXIgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gdHJ5Q2F0Y2godGhpcy51cGRhdGVTdGF0ZVByb3BzSWZOZWVkZWQsIHRoaXMpO1xuICAgICAgICAgIGlmICghaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gZXJyb3JPYmplY3QudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHN0b3JlU3RhdGU6IHN0b3JlU3RhdGUgfSk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5nZXRXcmFwcGVkSW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAgICgwLCBfaW52YXJpYW50MltcImRlZmF1bHRcIl0pKHdpdGhSZWYsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICd7IHdpdGhSZWY6IHRydWUgfSBhcyB0aGUgZm91cnRoIGFyZ3VtZW50IG9mIHRoZSBjb25uZWN0KCkgY2FsbC4nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLndyYXBwZWRJbnN0YW5jZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIGhhdmVPd25Qcm9wc0NoYW5nZWQgPSB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQ7XG4gICAgICAgIHZhciBoYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQ7XG4gICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkO1xuICAgICAgICB2YXIgc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICB2YXIgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5yZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBudWxsO1xuXG4gICAgICAgIGlmIChzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcikge1xuICAgICAgICAgIHRocm93IHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZVN0YXRlUHJvcHMgPSB0cnVlO1xuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcyA9IHRydWU7XG4gICAgICAgIGlmIChwdXJlICYmIHJlbmRlcmVkRWxlbWVudCkge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZVN0YXRlUHJvcHMgPSBoYXNTdG9yZVN0YXRlQ2hhbmdlZCB8fCBoYXZlT3duUHJvcHNDaGFuZ2VkICYmIHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcztcbiAgICAgICAgICBzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzID0gaGF2ZU93blByb3BzQ2hhbmdlZCAmJiB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQpIHtcbiAgICAgICAgICBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFVwZGF0ZVN0YXRlUHJvcHMpIHtcbiAgICAgICAgICBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzKSB7XG4gICAgICAgICAgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVEaXNwYXRjaFByb3BzSWZOZWVkZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCB8fCBoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQgfHwgaGF2ZU93blByb3BzQ2hhbmdlZCkge1xuICAgICAgICAgIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgJiYgcmVuZGVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aXRoUmVmKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKFdyYXBwZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCB0aGlzLm1lcmdlZFByb3BzLCB7XG4gICAgICAgICAgICByZWY6ICd3cmFwcGVkSW5zdGFuY2UnXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50ID0gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShXcmFwcGVkQ29tcG9uZW50LCB0aGlzLm1lcmdlZFByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkRWxlbWVudDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb25uZWN0O1xuICAgIH0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gY29ubmVjdERpc3BsYXlOYW1lO1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gICAgICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXVxuICAgIH07XG4gICAgQ29ubmVjdC5wcm9wVHlwZXMgPSB7XG4gICAgICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXVxuICAgIH07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPT09IHZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMltcImRlZmF1bHRcIl0pKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi9jb21wb25lbnRzL2Nvbm5lY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBzaGFsbG93RXF1YWw7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgb2JqQVtrZXlzQVtpXV0gIT09IG9iakJba2V5c0FbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3NoYWxsb3dFcXVhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3cmFwQWN0aW9uQ3JlYXRvcnM7XG5cbnZhciBfcmVkdXggPSByZXF1aXJlKCdyZWR1eCcpO1xuXG5mdW5jdGlvbiB3cmFwQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCkge1xuICAgIHJldHVybiAoMCwgX3JlZHV4LmJpbmRBY3Rpb25DcmVhdG9ycykoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMTU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9+L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSG9zdE9iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L34vbG9kYXNoL19pc0hvc3RPYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9fb3ZlckFyZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvfi9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzWydkZWZhdWx0J10gPSByb3V0ZXJNaWRkbGV3YXJlO1xuXG52YXIgX2FjdGlvbnMgPSByZXF1aXJlKCcuL2FjdGlvbnMnKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbi8qKlxuICogVGhpcyBtaWRkbGV3YXJlIGNhcHR1cmVzIENBTExfSElTVE9SWV9NRVRIT0QgYWN0aW9ucyB0byByZWRpcmVjdCB0byB0aGVcbiAqIHByb3ZpZGVkIGhpc3Rvcnkgb2JqZWN0LiBUaGlzIHdpbGwgcHJldmVudCB0aGVzZSBhY3Rpb25zIGZyb20gcmVhY2hpbmcgeW91clxuICogcmVkdWNlciBvciBhbnkgbWlkZGxld2FyZSB0aGF0IGNvbWVzIGFmdGVyIHRoaXMgb25lLlxuICovXG5mdW5jdGlvbiByb3V0ZXJNaWRkbGV3YXJlKGhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSAhPT0gX2FjdGlvbnMuQ0FMTF9ISVNUT1JZX01FVEhPRCkge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2FjdGlvbiRwYXlsb2FkID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIHZhciBtZXRob2QgPSBfYWN0aW9uJHBheWxvYWQubWV0aG9kO1xuICAgICAgICB2YXIgYXJncyA9IF9hY3Rpb24kcGF5bG9hZC5hcmdzO1xuXG4gICAgICAgIGhpc3RvcnlbbWV0aG9kXS5hcHBseShoaXN0b3J5LCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncykpO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvbWlkZGxld2FyZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBzeW5jSGlzdG9yeVdpdGhTdG9yZTtcblxudmFyIF9yZWR1Y2VyID0gcmVxdWlyZSgnLi9yZWR1Y2VyJyk7XG5cbnZhciBkZWZhdWx0U2VsZWN0TG9jYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIGRlZmF1bHRTZWxlY3RMb2NhdGlvblN0YXRlKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yb3V0aW5nO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHN5bmNocm9uaXplcyB5b3VyIGhpc3Rvcnkgc3RhdGUgd2l0aCB0aGUgUmVkdXggc3RvcmUuXG4gKiBMb2NhdGlvbiBjaGFuZ2VzIGZsb3cgZnJvbSBoaXN0b3J5IHRvIHRoZSBzdG9yZS4gQW4gZW5oYW5jZWQgaGlzdG9yeSBpc1xuICogcmV0dXJuZWQgd2l0aCBhIGxpc3RlbiBtZXRob2QgdGhhdCByZXNwb25kcyB0byBzdG9yZSB1cGRhdGVzIGZvciBsb2NhdGlvbi5cbiAqXG4gKiBXaGVuIHRoaXMgaGlzdG9yeSBpcyBwcm92aWRlZCB0byB0aGUgcm91dGVyLCB0aGlzIG1lYW5zIHRoZSBsb2NhdGlvbiBkYXRhXG4gKiB3aWxsIGZsb3cgbGlrZSB0aGlzOlxuICogaGlzdG9yeS5wdXNoIC0+IHN0b3JlLmRpc3BhdGNoIC0+IGVuaGFuY2VkSGlzdG9yeS5saXN0ZW4gLT4gcm91dGVyXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB3aGVuIHRoZSBzdG9yZSBzdGF0ZSBjaGFuZ2VzIGR1ZSB0byBhIHJlcGxheSBvciBvdGhlclxuICogZXZlbnQsIHRoZSByb3V0ZXIgd2lsbCBiZSB1cGRhdGVkIGFwcHJvcHJpYXRlbHkgYW5kIGNhbiB0cmFuc2l0aW9uIHRvIHRoZVxuICogY29ycmVjdCByb3V0ZXIgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHN5bmNIaXN0b3J5V2l0aFN0b3JlKGhpc3RvcnksIHN0b3JlKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cbiAgdmFyIF9yZWYkc2VsZWN0TG9jYXRpb25TdCA9IF9yZWYuc2VsZWN0TG9jYXRpb25TdGF0ZTtcbiAgdmFyIHNlbGVjdExvY2F0aW9uU3RhdGUgPSBfcmVmJHNlbGVjdExvY2F0aW9uU3QgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRTZWxlY3RMb2NhdGlvblN0YXRlIDogX3JlZiRzZWxlY3RMb2NhdGlvblN0O1xuICB2YXIgX3JlZiRhZGp1c3RVcmxPblJlcGxhID0gX3JlZi5hZGp1c3RVcmxPblJlcGxheTtcbiAgdmFyIGFkanVzdFVybE9uUmVwbGF5ID0gX3JlZiRhZGp1c3RVcmxPblJlcGxhID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZiRhZGp1c3RVcmxPblJlcGxhO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSByZWR1Y2VyIGlzIG1vdW50ZWQgb24gdGhlIHN0b3JlIGFuZCBmdW5jdGlvbmluZyBwcm9wZXJseS5cbiAgaWYgKHR5cGVvZiBzZWxlY3RMb2NhdGlvblN0YXRlKHN0b3JlLmdldFN0YXRlKCkpID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJvdXRpbmcgc3RhdGUgdG8gYmUgYXZhaWxhYmxlIGVpdGhlciBhcyBgc3RhdGUucm91dGluZ2AgJyArICdvciBhcyB0aGUgY3VzdG9tIGV4cHJlc3Npb24geW91IGNhbiBzcGVjaWZ5IGFzIGBzZWxlY3RMb2NhdGlvblN0YXRlYCAnICsgJ2luIHRoZSBgc3luY0hpc3RvcnlXaXRoU3RvcmUoKWAgb3B0aW9ucy4gJyArICdFbnN1cmUgeW91IGhhdmUgYWRkZWQgdGhlIGByb3V0ZXJSZWR1Y2VyYCB0byB5b3VyIHN0b3JlXFwncyAnICsgJ3JlZHVjZXJzIHZpYSBgY29tYmluZVJlZHVjZXJzYCBvciB3aGF0ZXZlciBtZXRob2QgeW91IHVzZSB0byBpc29sYXRlICcgKyAneW91ciByZWR1Y2Vycy4nKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSB2b2lkIDA7XG4gIHZhciBpc1RpbWVUcmF2ZWxpbmcgPSB2b2lkIDA7XG4gIHZhciB1bnN1YnNjcmliZUZyb21TdG9yZSA9IHZvaWQgMDtcbiAgdmFyIHVuc3Vic2NyaWJlRnJvbUhpc3RvcnkgPSB2b2lkIDA7XG5cbiAgLy8gV2hhdCBkb2VzIHRoZSBzdG9yZSBzYXkgYWJvdXQgY3VycmVudCBsb2NhdGlvbj9cbiAgdmFyIGdldExvY2F0aW9uSW5TdG9yZSA9IGZ1bmN0aW9uIGdldExvY2F0aW9uSW5TdG9yZSh1c2VJbml0aWFsSWZFbXB0eSkge1xuICAgIHZhciBsb2NhdGlvblN0YXRlID0gc2VsZWN0TG9jYXRpb25TdGF0ZShzdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICByZXR1cm4gbG9jYXRpb25TdGF0ZS5sb2NhdGlvbkJlZm9yZVRyYW5zaXRpb25zIHx8ICh1c2VJbml0aWFsSWZFbXB0eSA/IGluaXRpYWxMb2NhdGlvbiA6IHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLy8gSW5pdCBjdXJyZW50TG9jYXRpb24gd2l0aCBwb3RlbnRpYWwgbG9jYXRpb24gaW4gc3RvcmVcbiAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGdldExvY2F0aW9uSW5TdG9yZSgpO1xuXG4gIC8vIElmIHRoZSBzdG9yZSBpcyByZXBsYXllZCwgdXBkYXRlIHRoZSBVUkwgaW4gdGhlIGJyb3dzZXIgdG8gbWF0Y2guXG4gIGlmIChhZGp1c3RVcmxPblJlcGxheSkge1xuICAgIHZhciBoYW5kbGVTdG9yZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVN0b3JlQ2hhbmdlKCkge1xuICAgICAgdmFyIGxvY2F0aW9uSW5TdG9yZSA9IGdldExvY2F0aW9uSW5TdG9yZSh0cnVlKTtcbiAgICAgIGlmIChjdXJyZW50TG9jYXRpb24gPT09IGxvY2F0aW9uSW5TdG9yZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBhZGRyZXNzIGJhciB0byByZWZsZWN0IHN0b3JlIHN0YXRlXG4gICAgICBpc1RpbWVUcmF2ZWxpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudExvY2F0aW9uID0gbG9jYXRpb25JblN0b3JlO1xuICAgICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oX2V4dGVuZHMoe30sIGxvY2F0aW9uSW5TdG9yZSwge1xuICAgICAgICBhY3Rpb246ICdQVVNIJ1xuICAgICAgfSkpO1xuICAgICAgaXNUaW1lVHJhdmVsaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHVuc3Vic2NyaWJlRnJvbVN0b3JlID0gc3RvcmUuc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgICBoYW5kbGVTdG9yZUNoYW5nZSgpO1xuICB9XG5cbiAgLy8gV2hlbmV2ZXIgbG9jYXRpb24gY2hhbmdlcywgZGlzcGF0Y2ggYW4gYWN0aW9uIHRvIGdldCBpdCBpbiB0aGUgc3RvcmVcbiAgdmFyIGhhbmRsZUxvY2F0aW9uQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9jYXRpb25DaGFuZ2UobG9jYXRpb24pIHtcbiAgICAvLyAuLi4gdW5sZXNzIHdlIGp1c3QgY2F1c2VkIHRoYXQgbG9jYXRpb24gY2hhbmdlXG4gICAgaWYgKGlzVGltZVRyYXZlbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbWVtYmVyIHdoZXJlIHdlIGFyZVxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuXG4gICAgLy8gQXJlIHdlIGJlaW5nIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWU/XG4gICAgaWYgKCFpbml0aWFsTG9jYXRpb24pIHtcbiAgICAgIC8vIFJlbWVtYmVyIGFzIGEgZmFsbGJhY2sgaW4gY2FzZSBzdGF0ZSBpcyByZXNldFxuICAgICAgaW5pdGlhbExvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgICAgIC8vIFJlc3BlY3QgcGVyc2lzdGVkIGxvY2F0aW9uLCBpZiBhbnlcbiAgICAgIGlmIChnZXRMb2NhdGlvbkluU3RvcmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVsbCB0aGUgc3RvcmUgdG8gdXBkYXRlIGJ5IGRpc3BhdGNoaW5nIGFuIGFjdGlvblxuICAgIHN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IF9yZWR1Y2VyLkxPQ0FUSU9OX0NIQU5HRSxcbiAgICAgIHBheWxvYWQ6IGxvY2F0aW9uXG4gICAgfSk7XG4gIH07XG4gIHVuc3Vic2NyaWJlRnJvbUhpc3RvcnkgPSBoaXN0b3J5Lmxpc3RlbihoYW5kbGVMb2NhdGlvbkNoYW5nZSk7XG5cbiAgLy8gVGhlIGVuaGFuY2VkIGhpc3RvcnkgdXNlcyBzdG9yZSBhcyBzb3VyY2Ugb2YgdHJ1dGhcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgLy8gVGhlIGxpc3RlbmVycyBhcmUgc3Vic2NyaWJlZCB0byB0aGUgc3RvcmUgaW5zdGVhZCBvZiBoaXN0b3J5XG5cbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgLy8gQ29weSBvZiBsYXN0IGxvY2F0aW9uLlxuICAgICAgdmFyIGxhc3RQdWJsaXNoZWRMb2NhdGlvbiA9IGdldExvY2F0aW9uSW5TdG9yZSh0cnVlKTtcblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGV0aGVyIHdlIHVuc3Vic2NyaWJlZCwgYXMgUmVkdXggc3RvcmVcbiAgICAgIC8vIG9ubHkgYXBwbGllcyBjaGFuZ2VzIGluIHN1YnNjcmlwdGlvbnMgb24gbmV4dCBkaXNwYXRjaFxuICAgICAgdmFyIHVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdmFyIHVuc3Vic2NyaWJlRnJvbVN0b3JlID0gc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGdldExvY2F0aW9uSW5TdG9yZSh0cnVlKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMb2NhdGlvbiA9PT0gbGFzdFB1Ymxpc2hlZExvY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQdWJsaXNoZWRMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcbiAgICAgICAgaWYgKCF1bnN1YnNjcmliZWQpIHtcbiAgICAgICAgICBsaXN0ZW5lcihsYXN0UHVibGlzaGVkTG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gSGlzdG9yeSBsaXN0ZW5lcnMgZXhwZWN0IGEgc3luY2hyb25vdXMgY2FsbC4gTWFrZSB0aGUgZmlyc3QgY2FsbCB0byB0aGVcbiAgICAgIC8vIGxpc3RlbmVyIGFmdGVyIHN1YnNjcmliaW5nIHRvIHRoZSBzdG9yZSwgaW4gY2FzZSB0aGUgbGlzdGVuZXIgY2F1c2VzIGFcbiAgICAgIC8vIGxvY2F0aW9uIGNoYW5nZSAoZS5nLiB3aGVuIGl0IHJlZGlyZWN0cylcbiAgICAgIGxpc3RlbmVyKGxhc3RQdWJsaXNoZWRMb2NhdGlvbik7XG5cbiAgICAgIC8vIExldCB1c2VyIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB1bnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB1bnN1YnNjcmliZUZyb21TdG9yZSgpO1xuICAgICAgfTtcbiAgICB9LFxuXG5cbiAgICAvLyBJdCBhbHNvIHByb3ZpZGVzIGEgd2F5IHRvIGRlc3Ryb3kgaW50ZXJuYWwgbGlzdGVuZXJzXG4gICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKGFkanVzdFVybE9uUmVwbGF5KSB7XG4gICAgICAgIHVuc3Vic2NyaWJlRnJvbVN0b3JlKCk7XG4gICAgICB9XG4gICAgICB1bnN1YnNjcmliZUZyb21IaXN0b3J5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL3N5bmMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBBIG1peGluIHRoYXQgYWRkcyB0aGUgXCJoaXN0b3J5XCIgaW5zdGFuY2UgdmFyaWFibGUgdG8gY29tcG9uZW50cy5cbiAqL1xudmFyIEhpc3RvcnkgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogX0ludGVybmFsUHJvcFR5cGVzLmhpc3RvcnlcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ3RoZSBgSGlzdG9yeWAgbWl4aW4gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGFjY2VzcyBgY29udGV4dC5yb3V0ZXJgIHdpdGggeW91ciBvd24gYGNvbnRleHRUeXBlc2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1oaXN0b3J5bWl4aW4nKSA6IHZvaWQgMDtcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmNvbnRleHQuaGlzdG9yeTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTGluayA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQW4gPEluZGV4TGluaz4gaXMgdXNlZCB0byBsaW5rIHRvIGFuIDxJbmRleFJvdXRlPi5cbiAqL1xudmFyIEluZGV4TGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhMaW5rJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9MaW5rMi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBvbmx5QWN0aXZlT25JbmRleDogdHJ1ZSB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qc1xuICoqIG1vZHVsZSBpZCA9IDE2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUmVkaXJlY3QgPSByZXF1aXJlKCcuL1JlZGlyZWN0Jyk7XG5cbnZhciBfUmVkaXJlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUmVkaXJlY3QpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQW4gPEluZGV4UmVkaXJlY3Q+IGlzIHVzZWQgdG8gcmVkaXJlY3QgZnJvbSBhbiBpbmRleFJvdXRlLlxuICovXG5cbnZhciBJbmRleFJlZGlyZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJlZGlyZWN0JyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHNhbml0eSBjaGVjayAqL1xuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSBfUmVkaXJlY3QyLmRlZmF1bHQuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBbiA8SW5kZXhSZWRpcmVjdD4gZG9lcyBub3QgbWFrZSBzZW5zZSBhdCB0aGUgcm9vdCBvZiB5b3VyIHJvdXRlIGNvbmZpZycpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPEluZGV4UmVkaXJlY3Q+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4UmVkaXJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4UmVkaXJlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZ1bmMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLmZ1bmM7XG5cbi8qKlxuICogQW4gPEluZGV4Um91dGU+IGlzIHVzZWQgdG8gc3BlY2lmeSBpdHMgcGFyZW50J3MgPFJvdXRlIGluZGV4Um91dGU+IGluXG4gKiBhIEpTWCByb3V0ZSBjb25maWcuXG4gKi9cblxudmFyIEluZGV4Um91dGUgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4Um91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBbiA8SW5kZXhSb3V0ZT4gZG9lcyBub3QgbWFrZSBzZW5zZSBhdCB0aGUgcm9vdCBvZiB5b3VyIHJvdXRlIGNvbmZpZycpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPEluZGV4Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4Um91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgb2JqZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogVGhlIExpZmVjeWNsZSBtaXhpbiBhZGRzIHRoZSByb3V0ZXJXaWxsTGVhdmUgbGlmZWN5Y2xlIG1ldGhvZCB0byBhXG4gKiBjb21wb25lbnQgdGhhdCBtYXkgYmUgdXNlZCB0byBjYW5jZWwgYSB0cmFuc2l0aW9uIG9yIHByb21wdCB0aGUgdXNlclxuICogZm9yIGNvbmZpcm1hdGlvbi5cbiAqXG4gKiBPbiBzdGFuZGFyZCB0cmFuc2l0aW9ucywgcm91dGVyV2lsbExlYXZlIHJlY2VpdmVzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGVcbiAqIGxvY2F0aW9uIHdlJ3JlIHRyYW5zaXRpb25pbmcgdG8uIFRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbiwgcmV0dXJuIGZhbHNlLlxuICogVG8gcHJvbXB0IHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24sIHJldHVybiBhIHByb21wdCBtZXNzYWdlIChzdHJpbmcpLlxuICpcbiAqIER1cmluZyB0aGUgYmVmb3JldW5sb2FkIGV2ZW50IChhc3N1bWluZyB5b3UncmUgdXNpbmcgdGhlIHVzZUJlZm9yZVVubG9hZFxuICogaGlzdG9yeSBlbmhhbmNlciksIHJvdXRlcldpbGxMZWF2ZSBkb2VzIG5vdCByZWNlaXZlIGEgbG9jYXRpb24gb2JqZWN0XG4gKiBiZWNhdXNlIGl0IGlzbid0IHBvc3NpYmxlIGZvciB1cyB0byBrbm93IHRoZSBsb2NhdGlvbiB3ZSdyZSB0cmFuc2l0aW9uaW5nXG4gKiB0by4gSW4gdGhpcyBjYXNlIHJvdXRlcldpbGxMZWF2ZSBtdXN0IHJldHVybiBhIHByb21wdCBtZXNzYWdlIHRvIHByZXZlbnRcbiAqIHRoZSB1c2VyIGZyb20gY2xvc2luZyB0aGUgd2luZG93L3RhYi5cbiAqL1xuXG52YXIgTGlmZWN5Y2xlID0ge1xuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIC8vIE5lc3RlZCBjaGlsZHJlbiByZWNlaXZlIHRoZSByb3V0ZSBhcyBjb250ZXh0LCBlaXRoZXJcbiAgICAvLyBzZXQgYnkgdGhlIHJvdXRlIGNvbXBvbmVudCB1c2luZyB0aGUgUm91dGVDb250ZXh0IG1peGluXG4gICAgLy8gb3IgYnkgc29tZSBvdGhlciBhbmNlc3Rvci5cbiAgICByb3V0ZTogb2JqZWN0XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgLy8gUm91dGUgY29tcG9uZW50cyByZWNlaXZlIHRoZSByb3V0ZSBvYmplY3QgYXMgYSBwcm9wLlxuICAgIHJvdXRlOiBvYmplY3RcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICd0aGUgYExpZmVjeWNsZWAgbWl4aW4gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBgY29udGV4dC5yb3V0ZXIuc2V0Um91dGVMZWF2ZUhvb2socm91dGUsIGhvb2spYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWxpZmVjeWNsZW1peGluJykgOiB2b2lkIDA7XG4gICAgIXRoaXMucm91dGVyV2lsbExlYXZlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBMaWZlY3ljbGUgbWl4aW4gcmVxdWlyZXMgeW91IHRvIGRlZmluZSBhIHJvdXRlcldpbGxMZWF2ZSBtZXRob2QnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgcm91dGUgPSB0aGlzLnByb3BzLnJvdXRlIHx8IHRoaXMuY29udGV4dC5yb3V0ZTtcblxuICAgICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgTGlmZWN5Y2xlIG1peGluIG11c3QgYmUgdXNlZCBvbiBlaXRoZXIgYSkgYSA8Um91dGUgY29tcG9uZW50PiBvciAnICsgJ2IpIGEgZGVzY2VuZGFudCBvZiBhIDxSb3V0ZSBjb21wb25lbnQ+IHRoYXQgdXNlcyB0aGUgUm91dGVDb250ZXh0IG1peGluJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdGhpcy5fdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUgPSB0aGlzLmNvbnRleHQuaGlzdG9yeS5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUocm91dGUsIHRoaXMucm91dGVyV2lsbExlYXZlKTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSkgdGhpcy5fdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUoKTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTGlmZWN5Y2xlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9MaWZlY3ljbGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG5cbi8qKlxuICogQSA8Um91dGU+IGlzIHVzZWQgdG8gZGVjbGFyZSB3aGljaCBjb21wb25lbnRzIGFyZSByZW5kZXJlZCB0byB0aGVcbiAqIHBhZ2Ugd2hlbiB0aGUgVVJMIG1hdGNoZXMgYSBnaXZlbiBwYXR0ZXJuLlxuICpcbiAqIFJvdXRlcyBhcmUgYXJyYW5nZWQgaW4gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUuIFdoZW4gYSBuZXcgVVJMIGlzXG4gKiByZXF1ZXN0ZWQsIHRoZSB0cmVlIGlzIHNlYXJjaGVkIGRlcHRoLWZpcnN0IHRvIGZpbmQgYSByb3V0ZSB3aG9zZVxuICogcGF0aCBtYXRjaGVzIHRoZSBVUkwuICBXaGVuIG9uZSBpcyBmb3VuZCwgYWxsIHJvdXRlcyBpbiB0aGUgdHJlZVxuICogdGhhdCBsZWFkIHRvIGl0IGFyZSBjb25zaWRlcmVkIFwiYWN0aXZlXCIgYW5kIHRoZWlyIGNvbXBvbmVudHMgYXJlXG4gKiByZW5kZXJlZCBpbnRvIHRoZSBET00sIG5lc3RlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyBpbiB0aGUgdHJlZS5cbiAqL1xuXG52YXIgUm91dGUgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlJyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudFxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBjb21wb25lbnQ6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnQsXG4gICAgY29tcG9uZW50czogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHMsXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jLFxuICAgIGdldENvbXBvbmVudHM6IGZ1bmNcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgUm91dGVDb250ZXh0IG1peGluIHByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgZm9yIHJvdXRlXG4gKiBjb21wb25lbnRzIHRvIHNldCB0aGUgcm91dGUgaW4gY29udGV4dC4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gKiByb3V0ZXMgdGhhdCByZW5kZXIgZWxlbWVudHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgTGlmZWN5Y2xlXG4gKiBtaXhpbiB0byBwcmV2ZW50IHRyYW5zaXRpb25zLlxuICovXG5cbnZhciBSb3V0ZUNvbnRleHQgPSB7XG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcm91dGU6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZTogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGU6IHRoaXMucHJvcHMucm91dGVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBgUm91dGVDb250ZXh0YCBtaXhpbiBpcyBkZXByZWNhdGVkLiBZb3UgY2FuIHByb3ZpZGUgYHRoaXMucHJvcHMucm91dGVgIG9uIGNvbnRleHQgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLXJvdXRlY29udGV4dG1peGluJykgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMTcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhhc2hIaXN0b3J5KTtcblxudmFyIF91c2VRdWVyaWVzID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllcyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGlzRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICByZXR1cm4gIWhpc3RvcnkgfHwgIWhpc3RvcnkuX192Ml9jb21wYXRpYmxlX187XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbmZ1bmN0aW9uIGlzVW5zdXBwb3J0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgLy8gdjMgaGlzdG9yaWVzIGV4cG9zZSBnZXRDdXJyZW50TG9jYXRpb24sIGJ1dCBhcmVuJ3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgcmV0dXJuIGhpc3RvcnkgJiYgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb247XG59XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJvdXRlcj4gaXMgYSBoaWdoLWxldmVsIEFQSSBmb3IgYXV0b21hdGljYWxseSBzZXR0aW5nIHVwXG4gKiBhIHJvdXRlciB0aGF0IHJlbmRlcnMgYSA8Um91dGVyQ29udGV4dD4gd2l0aCBhbGwgdGhlIHByb3BzXG4gKiBpdCBuZWVkcyBlYWNoIHRpbWUgdGhlIFVSTCBjaGFuZ2VzLlxuICovXG5cbnZhciBSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlcicsXG5cblxuICBwcm9wVHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXMsXG4gICAgcm91dGVzOiBfSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzLCAvLyBhbGlhcyBmb3IgY2hpbGRyZW5cbiAgICByZW5kZXI6IGZ1bmMsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYyxcbiAgICBvbkVycm9yOiBmdW5jLFxuICAgIG9uVXBkYXRlOiBmdW5jLFxuXG4gICAgLy8gRGVwcmVjYXRlZDpcbiAgICBwYXJzZVF1ZXJ5U3RyaW5nOiBmdW5jLFxuICAgIHN0cmluZ2lmeVF1ZXJ5OiBmdW5jLFxuXG4gICAgLy8gUFJJVkFURTogRm9yIGNsaWVudC1zaWRlIHJlaHlkcmF0aW9uIG9mIHNlcnZlciBtYXRjaC5cbiAgICBtYXRjaENvbnRleHQ6IG9iamVjdFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm9wcykge1xuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IG51bGwsXG4gICAgICByb3V0ZXM6IG51bGwsXG4gICAgICBwYXJhbXM6IG51bGwsXG4gICAgICBjb21wb25lbnRzOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlRXJyb3I6IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgdGhpcy5wcm9wcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaHJvdyBlcnJvcnMgYnkgZGVmYXVsdCBzbyB3ZSBkb24ndCBzaWxlbnRseSBzd2FsbG93IHRoZW0hXG4gICAgICB0aHJvdyBlcnJvcjsgLy8gVGhpcyBlcnJvciBwcm9iYWJseSBvY2N1cnJlZCBpbiBnZXRDaGlsZFJvdXRlcyBvciBnZXRDb21wb25lbnRzLlxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gX3Byb3BzLnBhcnNlUXVlcnlTdHJpbmc7XG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gX3Byb3BzLnN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoIShwYXJzZVF1ZXJ5U3RyaW5nIHx8IHN0cmluZ2lmeVF1ZXJ5KSwgJ2BwYXJzZVF1ZXJ5U3RyaW5nYCBhbmQgYHN0cmluZ2lmeVF1ZXJ5YCBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIGNyZWF0ZSBhIGN1c3RvbSBoaXN0b3J5LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItY3VzdG9tcXVlcnlzdHJpbmcnKSA6IHZvaWQgMDtcblxuICAgIHZhciBfY3JlYXRlUm91dGVyT2JqZWN0cyA9IHRoaXMuY3JlYXRlUm91dGVyT2JqZWN0cygpO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy5oaXN0b3J5O1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLnRyYW5zaXRpb25NYW5hZ2VyO1xuICAgIHZhciByb3V0ZXIgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy5yb3V0ZXI7XG5cblxuICAgIHRoaXMuX3VubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIubGlzdGVuKGZ1bmN0aW9uIChlcnJvciwgc3RhdGUpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBfdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSwgX3RoaXMucHJvcHMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgfSxcbiAgY3JlYXRlUm91dGVyT2JqZWN0czogZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0cygpIHtcbiAgICB2YXIgbWF0Y2hDb250ZXh0ID0gdGhpcy5wcm9wcy5tYXRjaENvbnRleHQ7XG5cbiAgICBpZiAobWF0Y2hDb250ZXh0KSB7XG4gICAgICByZXR1cm4gbWF0Y2hDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBoaXN0b3J5ID0gdGhpcy5wcm9wcy5oaXN0b3J5O1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcm91dGVzID0gX3Byb3BzMi5yb3V0ZXM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzMi5jaGlsZHJlbjtcblxuXG4gICAgISFpc1Vuc3VwcG9ydGVkSGlzdG9yeShoaXN0b3J5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdZb3UgaGF2ZSBwcm92aWRlZCBhIGhpc3Rvcnkgb2JqZWN0IGNyZWF0ZWQgd2l0aCBoaXN0b3J5IHYzLnguICcgKyAnVGhpcyB2ZXJzaW9uIG9mIFJlYWN0IFJvdXRlciBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHYzIGhpc3RvcnkgJyArICdvYmplY3RzLiBQbGVhc2UgdXNlIGhpc3RvcnkgdjIueCBpbnN0ZWFkLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmIChpc0RlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpKSB7XG4gICAgICBoaXN0b3J5ID0gdGhpcy53cmFwRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykocm91dGVzIHx8IGNoaWxkcmVuKSk7XG4gICAgdmFyIHJvdXRlciA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGVyT2JqZWN0KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gICAgdmFyIHJvdXRpbmdIaXN0b3J5ID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0aW5nSGlzdG9yeSkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gICAgcmV0dXJuIHsgaGlzdG9yeTogcm91dGluZ0hpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfTtcbiAgfSxcbiAgd3JhcERlcHJlY2F0ZWRIaXN0b3J5OiBmdW5jdGlvbiB3cmFwRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IF9wcm9wczMucGFyc2VRdWVyeVN0cmluZztcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBfcHJvcHMzLnN0cmluZ2lmeVF1ZXJ5O1xuXG5cbiAgICB2YXIgY3JlYXRlSGlzdG9yeSA9IHZvaWQgMDtcbiAgICBpZiAoaGlzdG9yeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdJdCBhcHBlYXJzIHlvdSBoYXZlIHByb3ZpZGVkIGEgZGVwcmVjYXRlZCBoaXN0b3J5IG9iamVjdCB0byBgPFJvdXRlci8+YCwgcGxlYXNlIHVzZSBhIGhpc3RvcnkgcHJvdmlkZWQgYnkgJyArICdSZWFjdCBSb3V0ZXIgd2l0aCBgaW1wb3J0IHsgYnJvd3Nlckhpc3RvcnkgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2Agb3IgYGltcG9ydCB7IGhhc2hIaXN0b3J5IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgLiAnICsgJ0lmIHlvdSBhcmUgdXNpbmcgYSBjdXN0b20gaGlzdG9yeSBwbGVhc2UgY3JlYXRlIGl0IHdpdGggYHVzZVJvdXRlckhpc3RvcnlgLCBzZWUgaHR0cDovL3RpbnkuY2Mvcm91dGVyLXVzaW5naGlzdG9yeSBmb3IgZGV0YWlscy4nKSA6IHZvaWQgMDtcbiAgICAgIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYFJvdXRlcmAgbm8gbG9uZ2VyIGRlZmF1bHRzIHRoZSBoaXN0b3J5IHByb3AgdG8gaGFzaCBoaXN0b3J5LiBQbGVhc2UgdXNlIHRoZSBgaGFzaEhpc3RvcnlgIHNpbmdsZXRvbiBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItZGVmYXVsdGhpc3RvcnknKSA6IHZvaWQgMDtcbiAgICAgIGNyZWF0ZUhpc3RvcnkgPSBfY3JlYXRlSGFzaEhpc3RvcnkyLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoeyBwYXJzZVF1ZXJ5U3RyaW5nOiBwYXJzZVF1ZXJ5U3RyaW5nLCBzdHJpbmdpZnlRdWVyeTogc3RyaW5naWZ5UXVlcnkgfSk7XG4gIH0sXG5cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkobmV4dFByb3BzLmhpc3RvcnkgPT09IHRoaXMucHJvcHMuaGlzdG9yeSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoKG5leHRQcm9wcy5yb3V0ZXMgfHwgbmV4dFByb3BzLmNoaWxkcmVuKSA9PT0gKHRoaXMucHJvcHMucm91dGVzIHx8IHRoaXMucHJvcHMuY2hpbGRyZW4pLCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciByb3V0ZXM+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl91bmxpc3RlbikgdGhpcy5fdW5saXN0ZW4oKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGxvY2F0aW9uID0gX3N0YXRlLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZXMgPSBfc3RhdGUucm91dGVzO1xuICAgIHZhciBwYXJhbXMgPSBfc3RhdGUucGFyYW1zO1xuICAgIHZhciBjb21wb25lbnRzID0gX3N0YXRlLmNvbXBvbmVudHM7XG4gICAgdmFyIF9wcm9wczQgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjcmVhdGVFbGVtZW50ID0gX3Byb3BzNC5jcmVhdGVFbGVtZW50O1xuICAgIHZhciByZW5kZXIgPSBfcHJvcHM0LnJlbmRlcjtcblxuICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHM0LCBbJ2NyZWF0ZUVsZW1lbnQnLCAncmVuZGVyJ10pO1xuXG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHJldHVybiBudWxsOyAvLyBBc3luYyBtYXRjaFxuXG4gICAgLy8gT25seSBmb3J3YXJkIG5vbi1Sb3V0ZXItc3BlY2lmaWMgcHJvcHMgdG8gcm91dGluZyBjb250ZXh0LCBhcyB0aG9zZSBhcmVcbiAgICAvLyB0aGUgb25seSBvbmVzIHRoYXQgbWlnaHQgYmUgY3VzdG9tIHJvdXRpbmcgY29udGV4dCBwcm9wcy5cbiAgICBPYmplY3Qua2V5cyhSb3V0ZXIucHJvcFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBwcm9wc1twcm9wVHlwZV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgcm91dGVyOiB0aGlzLnJvdXRlcixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJvdXRlczogcm91dGVzLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFxuICAgIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFJvdXRpbmdDb250ZXh0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0aW5nQ29udGV4dCcsXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYFJvdXRpbmdDb250ZXh0YCBoYXMgYmVlbiByZW5hbWVkIHRvIGBSb3V0ZXJDb250ZXh0YC4gUGxlYXNlIHVzZSBgaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLXJvdXRlcmNvbnRleHQnKSA6IHZvaWQgMDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCB0aGlzLnByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRpbmdDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0aW5nQ29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5ydW5FbnRlckhvb2tzID0gcnVuRW50ZXJIb29rcztcbmV4cG9ydHMucnVuQ2hhbmdlSG9va3MgPSBydW5DaGFuZ2VIb29rcztcbmV4cG9ydHMucnVuTGVhdmVIb29rcyA9IHJ1bkxlYXZlSG9va3M7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uSG9vayhob29rLCByb3V0ZSwgYXN5bmNBcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGhvb2suYXBwbHkocm91dGUsIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2subGVuZ3RoIDwgYXN5bmNBcml0eSkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gQXNzdW1lIGhvb2sgZXhlY3V0ZXMgc3luY2hyb25vdXNseSBhbmRcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGUgY2FsbGJhY2suXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkVudGVyKSBob29rcy5wdXNoKGNyZWF0ZVRyYW5zaXRpb25Ib29rKHJvdXRlLm9uRW50ZXIsIHJvdXRlLCAzKSk7XG5cbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlSG9va3Mocm91dGVzKSB7XG4gIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICBpZiAocm91dGUub25DaGFuZ2UpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25DaGFuZ2UsIHJvdXRlLCA0KSk7XG4gICAgcmV0dXJuIGhvb2tzO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Ib29rcyhsZW5ndGgsIGl0ZXIsIGNhbGxiYWNrKSB7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVkaXJlY3RJbmZvID0gdm9pZCAwO1xuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uLCBkZXByZWNhdGVkUGF0aG5hbWUsIGRlcHJlY2F0ZWRRdWVyeSkge1xuICAgIGlmIChkZXByZWNhdGVkUGF0aG5hbWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aG5hbWUsIHF1ZXJ5KSBpcyBkZXByZWNhdGVkOyB1c2UgYHJlcGxhY2UobG9jYXRpb24pYCB3aXRoIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG4gICAgICByZWRpcmVjdEluZm8gPSB7XG4gICAgICAgIHBhdGhuYW1lOiBkZXByZWNhdGVkUGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBkZXByZWNhdGVkUXVlcnksXG4gICAgICAgIHN0YXRlOiBsb2NhdGlvblxuICAgICAgfTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZGlyZWN0SW5mbyA9IGxvY2F0aW9uO1xuICB9XG5cbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykobGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICBpdGVyKGluZGV4LCByZXBsYWNlLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHtcbiAgICAgICAgZG9uZShlcnJvciwgcmVkaXJlY3RJbmZvKTsgLy8gTm8gbmVlZCB0byBjb250aW51ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uRW50ZXIgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkVudGVyKG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5FbnRlckhvb2tzKHJvdXRlcywgbmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICB2YXIgaG9va3MgPSBnZXRFbnRlckhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICBob29rc1tpbmRleF0obmV4dFN0YXRlLCByZXBsYWNlLCBuZXh0KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uQ2hhbmdlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXJcbiAqIHdpdGggb25DaGFuZ2UocHJldlN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIGNhbGxiYWNrKSBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdEluZm8pIHdoZW4gZmluaXNoZWQuIFRoZSBmaXJzdCBob29rXG4gKiB0byB1c2UgcmVwbGFjZSBzaG9ydC1jaXJjdWl0cyB0aGUgbG9vcC5cbiAqXG4gKiBJZiBhIGhvb2sgbmVlZHMgdG8gcnVuIGFzeW5jaHJvbm91c2x5LCBpdCBtYXkgdXNlIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uIEhvd2V2ZXIsIGRvaW5nIHNvIHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gcGF1c2UsXG4gKiB3aGljaCBjb3VsZCBsZWFkIHRvIGEgbm9uLXJlc3BvbnNpdmUgVUkgaWYgdGhlIGhvb2sgaXMgc2xvdy5cbiAqL1xuZnVuY3Rpb24gcnVuQ2hhbmdlSG9va3Mocm91dGVzLCBzdGF0ZSwgbmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICB2YXIgaG9va3MgPSBnZXRDaGFuZ2VIb29rcyhyb3V0ZXMpO1xuICByZXR1cm4gcnVuVHJhbnNpdGlvbkhvb2tzKGhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlLCBuZXh0KSB7XG4gICAgaG9va3NbaW5kZXhdKHN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIG5leHQpO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25MZWF2ZSBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBydW5MZWF2ZUhvb2tzKHJvdXRlcywgcHJldlN0YXRlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAocm91dGVzW2ldLm9uTGVhdmUpIHJvdXRlc1tpXS5vbkxlYXZlLmNhbGwocm91dGVzW2ldLCBwcmV2U3RhdGUpO1xuICB9XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBtaWRkbGV3YXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChtaWRkbGV3YXJlLCBpbmRleCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkobWlkZGxld2FyZS5yZW5kZXJSb3V0ZXJDb250ZXh0IHx8IG1pZGRsZXdhcmUucmVuZGVyUm91dGVDb21wb25lbnQsICdUaGUgbWlkZGxld2FyZSBzcGVjaWZpZWQgYXQgaW5kZXggJyArIGluZGV4ICsgJyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgJyArICdhIHZhbGlkIFJlYWN0IFJvdXRlciBtaWRkbGV3YXJlLicpIDogdm9pZCAwO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdpdGhDb250ZXh0ID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICB2YXIgd2l0aENvbXBvbmVudCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50O1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgdmFyIG1ha2VDcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gbWFrZUNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgdmFyIGJhc2VDcmVhdGVFbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gX3JlYWN0LmNyZWF0ZUVsZW1lbnQgOiBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzKSB7XG4gICAgICByZXR1cm4gd2l0aENvbXBvbmVudC5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHJldmlvdXMsIHJlbmRlclJvdXRlQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiByZW5kZXJSb3V0ZUNvbXBvbmVudChwcmV2aW91cywgcHJvcHMpO1xuICAgICAgfSwgYmFzZUNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBwcm9wcykpO1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiB3aXRoQ29udGV4dC5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHJldmlvdXMsIHJlbmRlclJvdXRlckNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZW5kZXJSb3V0ZXJDb250ZXh0KHByZXZpb3VzLCByZW5kZXJQcm9wcyk7XG4gICAgfSwgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIF9leHRlbmRzKHt9LCByZW5kZXJQcm9wcywge1xuICAgICAgY3JlYXRlRWxlbWVudDogbWFrZUNyZWF0ZUVsZW1lbnQocmVuZGVyUHJvcHMuY3JlYXRlRWxlbWVudClcbiAgICB9KSkpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9hcHBseVJvdXRlck1pZGRsZXdhcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQnJvd3Nlckhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKF9jcmVhdGVCcm93c2VySGlzdG9yeTIuZGVmYXVsdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2Jyb3dzZXJIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMTc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xuICBpZiAoIXJvdXRlLnBhdGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgcGFyYW1OYW1lcyA9ICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpO1xuXG4gIHJldHVybiBwYXJhbU5hbWVzLnNvbWUoZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIHJldHVybiBwcmV2U3RhdGUucGFyYW1zW3BhcmFtTmFtZV0gIT09IG5leHRTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgeyBsZWF2ZVJvdXRlcywgY2hhbmdlUm91dGVzLCBlbnRlclJvdXRlcyB9IGRldGVybWluZWQgYnlcbiAqIHRoZSBjaGFuZ2UgZnJvbSBwcmV2U3RhdGUgdG8gbmV4dFN0YXRlLiBXZSBsZWF2ZSByb3V0ZXMgaWYgZWl0aGVyXG4gKiAxKSB0aGV5IGFyZSBub3QgaW4gdGhlIG5leHQgc3RhdGUgb3IgMikgdGhleSBhcmUgaW4gdGhlIG5leHQgc3RhdGVcbiAqIGJ1dCB0aGVpciBwYXJhbXMgaGF2ZSBjaGFuZ2VkIChpLmUuIC91c2Vycy8xMjMgPT4gL3VzZXJzLzQ1NikuXG4gKlxuICogbGVhdmVSb3V0ZXMgYXJlIG9yZGVyZWQgc3RhcnRpbmcgYXQgdGhlIGxlYWYgcm91dGUgb2YgdGhlIHRyZWVcbiAqIHdlJ3JlIGxlYXZpbmcgdXAgdG8gdGhlIGNvbW1vbiBwYXJlbnQgcm91dGUuIGVudGVyUm91dGVzIGFyZSBvcmRlcmVkXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHRyZWUgd2UncmUgZW50ZXJpbmcgZG93biB0byB0aGUgbGVhZiByb3V0ZS5cbiAqXG4gKiBjaGFuZ2VSb3V0ZXMgYXJlIGFueSByb3V0ZXMgdGhhdCBkaWRuJ3QgbGVhdmUgb3IgZW50ZXIgZHVyaW5nXG4gKiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRSb3V0ZXMocHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUgJiYgcHJldlN0YXRlLnJvdXRlcztcbiAgdmFyIG5leHRSb3V0ZXMgPSBuZXh0U3RhdGUucm91dGVzO1xuXG4gIHZhciBsZWF2ZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGNoYW5nZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGVudGVyUm91dGVzID0gdm9pZCAwO1xuICBpZiAocHJldlJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50SXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICBsZWF2ZVJvdXRlcyA9IHByZXZSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAocGFyZW50SXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlzTGVhdmluZyA9IG5leHRSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xIHx8IHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgIGlmIChpc0xlYXZpbmcpIHBhcmVudElzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGlzTGVhdmluZztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIG9uTGVhdmUgaG9va3Mgc3RhcnQgYXQgdGhlIGxlYWYgcm91dGUuXG4gICAgICBsZWF2ZVJvdXRlcy5yZXZlcnNlKCk7XG5cbiAgICAgIGVudGVyUm91dGVzID0gW107XG4gICAgICBjaGFuZ2VSb3V0ZXMgPSBbXTtcblxuICAgICAgbmV4dFJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICB2YXIgaXNOZXcgPSBwcmV2Um91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICAgICAgdmFyIHBhcmFtc0NoYW5nZWQgPSBsZWF2ZVJvdXRlcy5pbmRleE9mKHJvdXRlKSAhPT0gLTE7XG5cbiAgICAgICAgaWYgKGlzTmV3IHx8IHBhcmFtc0NoYW5nZWQpIGVudGVyUm91dGVzLnB1c2gocm91dGUpO2Vsc2UgY2hhbmdlUm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBsZWF2ZVJvdXRlcyA9IFtdO1xuICAgIGNoYW5nZVJvdXRlcyA9IFtdO1xuICAgIGVudGVyUm91dGVzID0gbmV4dFJvdXRlcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVhdmVSb3V0ZXM6IGxlYXZlUm91dGVzLFxuICAgIGNoYW5nZVJvdXRlczogY2hhbmdlUm91dGVzLFxuICAgIGVudGVyUm91dGVzOiBlbnRlclJvdXRlc1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb21wdXRlQ2hhbmdlZFJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvY29tcHV0ZUNoYW5nZWRSb3V0ZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uID0gcmVxdWlyZSgnLi9tYWtlU3RhdGVXaXRoTG9jYXRpb24nKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFrZVN0YXRlV2l0aExvY2F0aW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50c0ZvclJvdXRlKG5leHRTdGF0ZSwgcm91dGUsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cykge1xuICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlLmNvbXBvbmVudCB8fCByb3V0ZS5jb21wb25lbnRzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ2V0Q29tcG9uZW50ID0gcm91dGUuZ2V0Q29tcG9uZW50IHx8IHJvdXRlLmdldENvbXBvbmVudHM7XG4gIGlmICghZ2V0Q29tcG9uZW50KSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbG9jYXRpb24gPSBuZXh0U3RhdGUubG9jYXRpb247XG5cbiAgdmFyIG5leHRTdGF0ZVdpdGhMb2NhdGlvbiA9ICgwLCBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMi5kZWZhdWx0KShuZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICBnZXRDb21wb25lbnQuY2FsbChyb3V0ZSwgbmV4dFN0YXRlV2l0aExvY2F0aW9uLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgZmV0Y2hlcyBhbGwgY29tcG9uZW50cyBuZWVkZWQgZm9yIHRoZSBnaXZlbiByb3V0ZXJcbiAqIHN0YXRlIGFuZCBjYWxscyBjYWxsYmFjayhlcnJvciwgY29tcG9uZW50cykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDb21wb25lbnRzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50cyhuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICgwLCBfQXN5bmNVdGlscy5tYXBBc3luYykobmV4dFN0YXRlLnJvdXRlcywgZnVuY3Rpb24gKHJvdXRlLCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICBnZXRDb21wb25lbnRzRm9yUm91dGUobmV4dFN0YXRlLCByb3V0ZSwgY2FsbGJhY2spO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldENvbXBvbmVudHM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldENvbXBvbmVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGFuIG9iamVjdCBvZiBwYXJhbXMgdGhlIGdpdmVuIHJvdXRlIGNhcmVzIGFib3V0IGZyb21cbiAqIHRoZSBnaXZlbiBwYXJhbXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRSb3V0ZVBhcmFtcyhyb3V0ZSwgcGFyYW1zKSB7XG4gIHZhciByb3V0ZVBhcmFtcyA9IHt9O1xuXG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIHJvdXRlUGFyYW1zO1xuXG4gICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcCkpIHtcbiAgICAgIHJvdXRlUGFyYW1zW3BdID0gcGFyYW1zW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlUGFyYW1zO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRSb3V0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Um91dGVQYXJhbXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKF9jcmVhdGVIYXNoSGlzdG9yeTIuZGVmYXVsdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2hhc2hIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0FjdGl2ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gZGVlcEVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBwIGluIGEpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVtwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChiW3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFkZWVwRXF1YWwoYVtwXSwgYltwXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBwYXRobmFtZSBtYXRjaGVzIHRoZSBzdXBwbGllZCBvbmUsIG5ldCBvZlxuICogbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2ggbm9ybWFsaXphdGlvbi4gVGhpcyBpcyBzdWZmaWNpZW50IGZvciBhblxuICogaW5kZXhPbmx5IHJvdXRlIG1hdGNoLlxuICovXG5mdW5jdGlvbiBwYXRoSXNBY3RpdmUocGF0aG5hbWUsIGN1cnJlbnRQYXRobmFtZSkge1xuICAvLyBOb3JtYWxpemUgbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kuIExlYWRpbmcgc2xhc2ggb24gcGF0aG5hbWUgaGFzXG4gIC8vIGFscmVhZHkgYmVlbiBub3JtYWxpemVkIGluIGlzQWN0aXZlLiBTZWUgY2F2ZWF0IHRoZXJlLlxuICBpZiAoY3VycmVudFBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgY3VycmVudFBhdGhuYW1lID0gJy8nICsgY3VycmVudFBhdGhuYW1lO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBlbmQgb2YgYm90aCBwYXRoIG5hbWVzIHRvby4gTWF5YmUgYC9mb28vYCBzaG91bGRuJ3Qgc2hvd1xuICAvLyBgL2Zvb2AgYXMgYWN0aXZlLCBidXQgaW4gdGhpcyBjYXNlLCB3ZSB3b3VsZCBhbHJlYWR5IGhhdmUgZmFpbGVkIHRoZVxuICAvLyBtYXRjaC5cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdChwYXRobmFtZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgKz0gJy8nO1xuICB9XG4gIGlmIChjdXJyZW50UGF0aG5hbWUuY2hhckF0KGN1cnJlbnRQYXRobmFtZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgY3VycmVudFBhdGhuYW1lICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50UGF0aG5hbWUgPT09IHBhdGhuYW1lO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aG5hbWUgbWF0Y2hlcyB0aGUgYWN0aXZlIHJvdXRlcyBhbmQgcGFyYW1zLlxuICovXG5mdW5jdGlvbiByb3V0ZUlzQWN0aXZlKHBhdGhuYW1lLCByb3V0ZXMsIHBhcmFtcykge1xuICB2YXIgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZSxcbiAgICAgIHBhcmFtTmFtZXMgPSBbXSxcbiAgICAgIHBhcmFtVmFsdWVzID0gW107XG5cbiAgLy8gZm9yLi4ub2Ygd291bGQgd29yayBoZXJlIGJ1dCBpdCdzIHByb2JhYmx5IHNsb3dlciBwb3N0LXRyYW5zcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV07XG4gICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gICAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICBwYXJhbU5hbWVzID0gW107XG4gICAgICBwYXJhbVZhbHVlcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPT0gbnVsbCAmJiBwYXR0ZXJuKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9ICgwLCBfUGF0dGVyblV0aWxzLm1hdGNoUGF0dGVybikocGF0dGVybiwgcmVtYWluaW5nUGF0aG5hbWUpO1xuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkLnJlbWFpbmluZ1BhdGhuYW1lO1xuICAgICAgICBwYXJhbU5hbWVzID0gW10uY29uY2F0KHBhcmFtTmFtZXMsIG1hdGNoZWQucGFyYW1OYW1lcyk7XG4gICAgICAgIHBhcmFtVmFsdWVzID0gW10uY29uY2F0KHBhcmFtVmFsdWVzLCBtYXRjaGVkLnBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSAnJykge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIGV4YWN0IG1hdGNoIG9uIHRoZSByb3V0ZS4gSnVzdCBjaGVjayB0aGF0IGFsbCB0aGUgcGFyYW1zXG4gICAgICAgIC8vIG1hdGNoLlxuICAgICAgICAvLyBGSVhNRTogVGhpcyBkb2Vzbid0IHdvcmsgb24gcmVwZWF0ZWQgcGFyYW1zLlxuICAgICAgICByZXR1cm4gcGFyYW1OYW1lcy5ldmVyeShmdW5jdGlvbiAocGFyYW1OYW1lLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcocGFyYW1WYWx1ZXNbaW5kZXhdKSA9PT0gU3RyaW5nKHBhcmFtc1twYXJhbU5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbGwga2V5L3ZhbHVlIHBhaXJzIGluIHRoZSBnaXZlbiBxdWVyeSBhcmVcbiAqIGN1cnJlbnRseSBhY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGFjdGl2ZVF1ZXJ5KSB7XG4gIGlmIChhY3RpdmVRdWVyeSA9PSBudWxsKSByZXR1cm4gcXVlcnkgPT0gbnVsbDtcblxuICBpZiAocXVlcnkgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGRlZXBFcXVhbChxdWVyeSwgYWN0aXZlUXVlcnkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIDxMaW5rPiB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUvcXVlcnkgY29tYmluYXRpb24gaXNcbiAqIGN1cnJlbnRseSBhY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzQWN0aXZlKF9yZWYsIGluZGV4T25seSwgY3VycmVudExvY2F0aW9uLCByb3V0ZXMsIHBhcmFtcykge1xuICB2YXIgcGF0aG5hbWUgPSBfcmVmLnBhdGhuYW1lO1xuICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24gPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE86IFRoaXMgaXMgYSBiaXQgdWdseS4gSXQga2VlcHMgYXJvdW5kIHN1cHBvcnQgZm9yIHRyZWF0aW5nIHBhdGhuYW1lc1xuICAvLyB3aXRob3V0IHByZWNlZGluZyBzbGFzaGVzIGFzIGFic29sdXRlIHBhdGhzLCBidXQgcG9zc2libHkgYWxzbyB3b3Jrc1xuICAvLyBhcm91bmQgdGhlIHNhbWUgcXVpcmtzIHdpdGggYmFzZW5hbWVzIGFzIGluIG1hdGNoUm91dGVzLlxuICBpZiAocGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9XG5cbiAgaWYgKCFwYXRoSXNBY3RpdmUocGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAvLyBUaGUgcGF0aCBjaGVjayBpcyBuZWNlc3NhcnkgYW5kIHN1ZmZpY2llbnQgZm9yIGluZGV4T25seSwgYnV0IG90aGVyd2lzZVxuICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gY2hlY2sgdGhlIHJvdXRlcy5cbiAgICBpZiAoaW5kZXhPbmx5IHx8ICFyb3V0ZUlzQWN0aXZlKHBhdGhuYW1lLCByb3V0ZXMsIHBhcmFtcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVlcnlJc0FjdGl2ZShxdWVyeSwgY3VycmVudExvY2F0aW9uLnF1ZXJ5KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvaXNBY3RpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogQSBoaWdoLWxldmVsIEFQSSB0byBiZSB1c2VkIGZvciBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIGEgbG9jYXRpb24gdG8gYSBzZXQgb2Ygcm91dGVzIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIHJlbmRlclByb3BzKSB3aGVuIGZpbmlzaGVkLlxuICpcbiAqIE5vdGU6IFlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIGluIGEgYnJvd3NlciB1bmxlc3MgeW91J3JlIHVzaW5nXG4gKiBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgd2l0aCBhc3luYyByb3V0ZXMuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoKF9yZWYsIGNhbGxiYWNrKSB7XG4gIHZhciBoaXN0b3J5ID0gX3JlZi5oaXN0b3J5O1xuICB2YXIgcm91dGVzID0gX3JlZi5yb3V0ZXM7XG4gIHZhciBsb2NhdGlvbiA9IF9yZWYubG9jYXRpb247XG5cbiAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydoaXN0b3J5JywgJ3JvdXRlcycsICdsb2NhdGlvbiddKTtcblxuICAhKGhpc3RvcnkgfHwgbG9jYXRpb24pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ21hdGNoIG5lZWRzIGEgaGlzdG9yeSBvciBhIGxvY2F0aW9uJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIGhpc3RvcnkgPSBoaXN0b3J5ID8gaGlzdG9yeSA6ICgwLCBfY3JlYXRlTWVtb3J5SGlzdG9yeTIuZGVmYXVsdCkob3B0aW9ucyk7XG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKHJvdXRlcykpO1xuXG4gIHZhciB1bmxpc3RlbiA9IHZvaWQgMDtcblxuICBpZiAobG9jYXRpb24pIHtcbiAgICAvLyBBbGxvdyBtYXRjaCh7IGxvY2F0aW9uOiAnL3RoZS9wYXRoJywgLi4uIH0pXG4gICAgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQaWNrIHVwIHRoZSBsb2NhdGlvbiBmcm9tIHRoZSBoaXN0b3J5IHZpYSBzeW5jaHJvbm91cyBoaXN0b3J5Lmxpc3RlblxuICAgIC8vIGNhbGwgaWYgbmVlZGVkLlxuICAgIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGhpc3RvcnlMb2NhdGlvbikge1xuICAgICAgbG9jYXRpb24gPSBoaXN0b3J5TG9jYXRpb247XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcm91dGVyID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgaGlzdG9yeSA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGluZ0hpc3RvcnkpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICB0cmFuc2l0aW9uTWFuYWdlci5tYXRjaChsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUpIHtcbiAgICBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlICYmIF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHtcbiAgICAgIGhpc3Rvcnk6IGhpc3RvcnksXG4gICAgICByb3V0ZXI6IHJvdXRlcixcbiAgICAgIG1hdGNoQ29udGV4dDogeyBoaXN0b3J5OiBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcjogdHJhbnNpdGlvbk1hbmFnZXIsIHJvdXRlcjogcm91dGVyIH1cbiAgICB9KSk7XG5cbiAgICAvLyBEZWZlciByZW1vdmluZyB0aGUgbGlzdGVuZXIgdG8gaGVyZSB0byBwcmV2ZW50IERPTSBoaXN0b3JpZXMgZnJvbSBoYXZpbmdcbiAgICAvLyB0byB1bndpbmQgRE9NIGV2ZW50IGxpc3RlbmVycyB1bm5lY2Vzc2FyaWx5LCBpbiBjYXNlIGNhbGxiYWNrIHJlbmRlcnMgYVxuICAgIC8vIDxSb3V0ZXI+IGFuZCBhdHRhY2hlcyBhbm90aGVyIGhpc3RvcnkgbGlzdGVuZXIuXG4gICAgaWYgKHVubGlzdGVuKSB7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2hSb3V0ZXM7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbWFrZVN0YXRlV2l0aExvY2F0aW9uJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VTdGF0ZVdpdGhMb2NhdGlvbik7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbbnVsbCwgcm91dGUuY2hpbGRSb3V0ZXNdO1xuICB9XG4gIGlmICghcm91dGUuZ2V0Q2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc3luYyA9IHRydWUsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICB9O1xuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKHBhcnRpYWxOZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICByb3V0ZS5nZXRDaGlsZFJvdXRlcyhwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIGNoaWxkUm91dGVzKSB7XG4gICAgY2hpbGRSb3V0ZXMgPSAhZXJyb3IgJiYgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoY2hpbGRSb3V0ZXMpO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICByZXN1bHQgPSBbZXJyb3IsIGNoaWxkUm91dGVzXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvciwgY2hpbGRSb3V0ZXMpO1xuICB9KTtcblxuICBzeW5jID0gZmFsc2U7XG4gIHJldHVybiByZXN1bHQ7IC8vIE1pZ2h0IGJlIHVuZGVmaW5lZC5cbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhSb3V0ZShyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuaW5kZXhSb3V0ZSkge1xuICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlLmluZGV4Um91dGUpO1xuICB9IGVsc2UgaWYgKHJvdXRlLmdldEluZGV4Um91dGUpIHtcbiAgICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICAgIH07XG5cbiAgICB2YXIgcGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiA9ICgwLCBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMi5kZWZhdWx0KShwYXJ0aWFsTmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgICByb3V0ZS5nZXRJbmRleFJvdXRlKHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgY2FsbGJhY2soZXJyb3IsICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShpbmRleFJvdXRlKVswXSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGhsZXNzID0gcm91dGUuY2hpbGRSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFJvdXRlKSB7XG4gICAgICAgIHJldHVybiAhY2hpbGRSb3V0ZS5wYXRoO1xuICAgICAgfSk7XG5cbiAgICAgICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHBhdGhsZXNzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICAgIGdldEluZGV4Um91dGUocGF0aGxlc3NbaW5kZXhdLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvciB8fCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVzID0gW3BhdGhsZXNzW2luZGV4XV0uY29uY2F0KEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkgPyBpbmRleFJvdXRlIDogW2luZGV4Um91dGVdKTtcbiAgICAgICAgICAgIGRvbmUoZXJyb3IsIHJvdXRlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcm91dGVzKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlcyk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduUGFyYW1zKHBhcmFtcywgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcbiAgcmV0dXJuIHBhcmFtTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVzICYmIHBhcmFtVmFsdWVzW2luZGV4XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0ucHVzaChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gW3BhcmFtc1twYXJhbU5hbWVdLCBwYXJhbVZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gYXNzaWduUGFyYW1zKHt9LCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVEZWVwKHJvdXRlLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICBwYXJhbVZhbHVlcyA9IFtdO1xuICB9XG5cbiAgLy8gT25seSB0cnkgdG8gbWF0Y2ggdGhlIHBhdGggaWYgdGhlIHJvdXRlIGFjdHVhbGx5IGhhcyBhIHBhdHRlcm4sIGFuZCBpZlxuICAvLyB3ZSdyZSBub3QganVzdCBzZWFyY2hpbmcgZm9yIHBvdGVudGlhbCBuZXN0ZWQgYWJzb2x1dGUgcGF0aHMuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPT0gbnVsbCAmJiBwYXR0ZXJuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaGVkID0gKDAsIF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKShwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gQnkgYXNzdW1wdGlvbiwgcGF0dGVybiBpcyBub24tZW1wdHkgaGVyZSwgd2hpY2ggaXMgdGhlIHByZXJlcXVpc2l0ZSBmb3JcbiAgICAvLyBhY3R1YWxseSB0ZXJtaW5hdGluZyBhIG1hdGNoLlxuICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgIHZhciBfcmV0MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHJvdXRlczogW3JvdXRlXSxcbiAgICAgICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgICAgICAgfTtcblxuICAgICAgICBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSkge1xuICAgICAgICAgICAgICB2YXIgX21hdGNoJHJvdXRlcztcblxuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShpbmRleFJvdXRlLmV2ZXJ5KGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcm91dGUucGF0aDtcbiAgICAgICAgICAgICAgfSksICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIChfbWF0Y2gkcm91dGVzID0gbWF0Y2gucm91dGVzKS5wdXNoLmFwcGx5KF9tYXRjaCRyb3V0ZXMsIGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCFpbmRleFJvdXRlLnBhdGgsICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIG1hdGNoLnJvdXRlcy5wdXNoKGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfSgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9IG51bGwgfHwgcm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAvLyBFaXRoZXIgYSkgdGhpcyByb3V0ZSBtYXRjaGVkIGF0IGxlYXN0IHNvbWUgb2YgdGhlIHBhdGggb3IgYilcbiAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGxvYWQgdGhpcyByb3V0ZSdzIGNoaWxkcmVuIGFzeW5jaHJvbm91c2x5LiBJblxuICAgIC8vIGVpdGhlciBjYXNlIGNvbnRpbnVlIGNoZWNraW5nIGZvciBtYXRjaGVzIGluIHRoZSBzdWJ0cmVlLlxuICAgIHZhciBvbkNoaWxkUm91dGVzID0gZnVuY3Rpb24gb25DaGlsZFJvdXRlcyhlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkUm91dGVzKSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBjaGlsZCByb3V0ZXMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoLlxuICAgICAgICBtYXRjaFJvdXRlcyhjaGlsZFJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBBIGNoaWxkIHJvdXRlIG1hdGNoZWQhIEF1Z21lbnQgdGhlIG1hdGNoIGFuZCBwYXNzIGl0IHVwIHRoZSBzdGFjay5cbiAgICAgICAgICAgIG1hdGNoLnJvdXRlcy51bnNoaWZ0KHJvdXRlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgb25DaGlsZFJvdXRlcyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25DaGlsZFJvdXRlcy5hcHBseSh1bmRlZmluZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBtYXRjaGVzIHRoZSBnaXZlbiBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgc3RhdGUpIHdoZW4gZmluaXNoZWQuIFRoZSBzdGF0ZSBvYmplY3Qgd2lsbCBoYXZlIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSByb3V0ZXMgICAgICAgQW4gYXJyYXkgb2Ygcm91dGVzIHRoYXQgbWF0Y2hlZCwgaW4gaGllcmFyY2hpY2FsIG9yZGVyXG4gKiAtIHBhcmFtcyAgICAgICBBbiBvYmplY3Qgb2YgVVJMIHBhcmFtZXRlcnNcbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDaGlsZFJvdXRlcyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24sIGNhbGxiYWNrLCByZW1haW5pbmdQYXRobmFtZSkge1xuICB2YXIgcGFyYW1OYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzRdO1xuICB2YXIgcGFyYW1WYWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDUgfHwgYXJndW1lbnRzWzVdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1s1XTtcblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgYSBsaXR0bGUgYml0IHVnbHksIGJ1dCBpdCB3b3JrcyBhcm91bmQgYSBxdWlyayBpbiBoaXN0b3J5XG4gICAgLy8gdGhhdCBzdHJpcHMgdGhlIGxlYWRpbmcgc2xhc2ggZnJvbSBwYXRobmFtZXMgd2hlbiB1c2luZyBiYXNlbmFtZXMgd2l0aFxuICAgIC8vIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogJy8nICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICB9XG5cbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocm91dGVzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgbWF0Y2hSb3V0ZURlZXAocm91dGVzW2luZGV4XSwgbG9jYXRpb24sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgaWYgKGVycm9yIHx8IG1hdGNoKSB7XG4gICAgICAgIGRvbmUoZXJyb3IsIG1hdGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNyZWF0ZUhpc3RvcnkgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBjcmVhdGVcbiAqIGhpc3Rvcnkgb2JqZWN0cyB0aGF0IGtub3cgYWJvdXQgcm91dGluZy5cbiAqXG4gKiBFbmhhbmNlcyBoaXN0b3J5IG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gKlxuICogLSBsaXN0ZW4oKGVycm9yLCBuZXh0U3RhdGUpID0+IHt9KVxuICogLSBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUocm91dGUsIChuZXh0TG9jYXRpb24pID0+IHt9KVxuICogLSBtYXRjaChsb2NhdGlvbiwgKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUpID0+IHt9KVxuICogLSBpc0FjdGl2ZShwYXRobmFtZSwgcXVlcnksIGluZGV4T25seT1mYWxzZSlcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVzKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgdXNlUm91dGVzYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcmAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgcm91dGVzID0gX3JlZi5yb3V0ZXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3JvdXRlcyddKTtcblxuICAgIHZhciBoaXN0b3J5ID0gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KShvcHRpb25zKTtcbiAgICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCByb3V0ZXMpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VSb3V0ZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSB7XG4gIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxuZnVuY3Rpb24gd2l0aFJvdXRlcihXcmFwcGVkQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIHZhciB3aXRoUmVmID0gb3B0aW9ucyAmJiBvcHRpb25zLndpdGhSZWY7XG5cbiAgdmFyIFdpdGhSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiAnV2l0aFJvdXRlcicsXG5cbiAgICBjb250ZXh0VHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG4gICAgcHJvcFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxuXG4gICAgZ2V0V3JhcHBlZEluc3RhbmNlOiBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAhd2l0aFJlZiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICdgeyB3aXRoUmVmOiB0cnVlIH1gIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHdpdGhSb3V0ZXIoKSBjYWxsLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcm91dGVyID0gdGhpcy5wcm9wcy5yb3V0ZXIgfHwgdGhpcy5jb250ZXh0LnJvdXRlcjtcbiAgICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IHJvdXRlcjogcm91dGVyIH0pO1xuXG4gICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICBwcm9wcy5yZWYgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIF90aGlzLndyYXBwZWRJbnN0YW5jZSA9IGM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICBXaXRoUm91dGVyLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuICBXaXRoUm91dGVyLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuXG4gIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShXaXRoUm91dGVyLCBXcmFwcGVkQ29tcG9uZW50KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvd2l0aFJvdXRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuZXhwb3J0cy5sb29wQXN5bmMgPSBsb29wQXN5bmM7XG5cbmZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgc3luYyA9IGZhbHNlLFxuICAgICAgaGFzTmV4dCA9IGZhbHNlLFxuICAgICAgZG9uZUFyZ3MgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpc0RvbmUgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgZG9uZUFyZ3MgPSBbXS5jb25jYXQoX3NsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc05leHQgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgZG9uZUFyZ3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VHVybiA+PSB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVET01IaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVET01IaXN0b3J5KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIEhUTUw1J3MgaGlzdG9yeSBBUElcbiAqIChwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudCkgdG8gbWFuYWdlIGhpc3RvcnkuXG4gKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2Qgb2YgbWFuYWdpbmcgaGlzdG9yeSBpbiBicm93c2VycyBiZWNhdXNlXG4gKiBpdCBwcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqXG4gKiBOb3RlOiBJbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBmdWxsXG4gKiBwYWdlIHJlbG9hZHMgd2lsbCBiZSB1c2VkIHRvIHByZXNlcnZlIFVSTHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBmb3JjZVJlZnJlc2ggPSBvcHRpb25zLmZvcmNlUmVmcmVzaDtcblxuICB2YXIgaXNTdXBwb3J0ZWQgPSBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciB1c2VSZWZyZXNoID0gIWlzU3VwcG9ydGVkIHx8IGZvcmNlUmVmcmVzaDtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGhpc3RvcnlTdGF0ZSA9IGhpc3RvcnlTdGF0ZSB8fCB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoaXN0b3J5U3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRXaW5kb3dQYXRoKCk7XG4gICAgdmFyIF9oaXN0b3J5U3RhdGUgPSBoaXN0b3J5U3RhdGU7XG4gICAgdmFyIGtleSA9IF9oaXN0b3J5U3RhdGUua2V5O1xuXG4gICAgdmFyIHN0YXRlID0gdW5kZWZpbmVkO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHN0YXRlID0gX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcblxuICAgICAgaWYgKGlzU3VwcG9ydGVkKSB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGhpc3RvcnlTdGF0ZSwgeyBrZXk6IGtleSB9KSwgbnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFBvcFN0YXRlTGlzdGVuZXIoX3JlZikge1xuICAgIHZhciB0cmFuc2l0aW9uVG8gPSBfcmVmLnRyYW5zaXRpb25UbztcblxuICAgIGZ1bmN0aW9uIHBvcFN0YXRlTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG5cbiAgICAgIHRyYW5zaXRpb25UbyhnZXRDdXJyZW50TG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgICB9XG5cbiAgICBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdwb3BzdGF0ZScsIHBvcFN0YXRlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgcG9wU3RhdGVMaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuXG4gICAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuICAgIHZhciBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICBrZXk6IGtleVxuICAgIH07XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAodXNlUmVmcmVzaCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHBhdGg7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gUHJldmVudCBsb2NhdGlvbiB1cGRhdGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJFUExBQ0VcbiAgICAgIGlmICh1c2VSZWZyZXNoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHBhdGgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgbG9jYXRpb24gdXBkYXRlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBudWxsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZURPTUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGVcbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICBoaXN0b3J5LnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaGlzdG9yeS51bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG5cbiAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9va1xuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbigpIHtcbiAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJy8nIDogYXJndW1lbnRzWzBdO1xuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX0FjdGlvbnMuUE9QIDogYXJndW1lbnRzWzFdO1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICB2YXIgX2ZvdXJ0aEFyZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbM107XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1RoZSBzdGF0ZSAoMm5kKSBhcmd1bWVudCB0byBjcmVhdGVMb2NhdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgYSAnICsgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IGFjdGlvbiB9KTtcblxuICAgIGFjdGlvbiA9IGtleSB8fCBfQWN0aW9ucy5QT1A7XG4gICAga2V5ID0gX2ZvdXJ0aEFyZztcbiAgfVxuXG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoIHx8ICcnO1xuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZSB8fCBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGtleToga2V5XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUxvY2F0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlTG9jYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpIHtcbiAgcmV0dXJuIGVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5zdGF0ZTtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBlbnRyeSkge1xuICAgIG1lbW9bZW50cnkua2V5XSA9IGVudHJ5LnN0YXRlO1xuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBvcHRpb25zIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogW29wdGlvbnNdIH07XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVIaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IHNhdmVTdGF0ZSxcbiAgICBnbzogZ29cbiAgfSkpO1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHZhciBlbnRyaWVzID0gX29wdGlvbnMuZW50cmllcztcbiAgdmFyIGN1cnJlbnQgPSBfb3B0aW9ucy5jdXJyZW50O1xuXG4gIGlmICh0eXBlb2YgZW50cmllcyA9PT0gJ3N0cmluZycpIHtcbiAgICBlbnRyaWVzID0gW2VudHJpZXNdO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJpZXMpKSB7XG4gICAgZW50cmllcyA9IFsnLyddO1xuICB9XG5cbiAgZW50cmllcyA9IGVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuXG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHJldHVybiB7IHBhdGhuYW1lOiBlbnRyeSwga2V5OiBrZXkgfTtcblxuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdvYmplY3QnICYmIGVudHJ5KSByZXR1cm4gX2V4dGVuZHMoe30sIGVudHJ5LCB7IGtleToga2V5IH0pO1xuXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdVbmFibGUgdG8gY3JlYXRlIGhpc3RvcnkgZW50cnkgZnJvbSAlcycsIGVudHJ5KSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9KTtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgY3VycmVudCA9IGVudHJpZXMubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIHtcbiAgICAhKGN1cnJlbnQgPj0gMCAmJiBjdXJyZW50IDwgZW50cmllcy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdDdXJyZW50IGluZGV4IG11c3QgYmUgPj0gMCBhbmQgPCAlcywgd2FzICVzJywgZW50cmllcy5sZW5ndGgsIGN1cnJlbnQpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgc3RvcmFnZSA9IGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKTtcblxuICBmdW5jdGlvbiBzYXZlU3RhdGUoa2V5LCBzdGF0ZSkge1xuICAgIHN0b3JhZ2Vba2V5XSA9IHN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICAgIHJldHVybiBzdG9yYWdlW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tjdXJyZW50XTtcbiAgICB2YXIgYmFzZW5hbWUgPSBlbnRyeS5iYXNlbmFtZTtcbiAgICB2YXIgcGF0aG5hbWUgPSBlbnRyeS5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gZW50cnkuc2VhcmNoO1xuXG4gICAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWUgKyAoc2VhcmNoIHx8ICcnKTtcblxuICAgIHZhciBrZXkgPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YXRlID0gdW5kZWZpbmVkO1xuICAgIGlmIChlbnRyeS5rZXkpIHtcbiAgICAgIGtleSA9IGVudHJ5LmtleTtcbiAgICAgIHN0YXRlID0gcmVhZFN0YXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICBlbnRyeS5rZXkgPSBrZXk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIGluZGV4ID0gY3VycmVudCArIG47XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBpZiAobikge1xuICAgICAgaWYgKCFjYW5HbyhuKSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdDYW5ub3QgZ28oJXMpIHRoZXJlIGlzIG5vdCBlbm91Z2ggaGlzdG9yeScsIG4pIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgKz0gbjtcblxuICAgICAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuXG4gICAgICAvLyBjaGFuZ2UgYWN0aW9uIHRvIFBPUFxuICAgICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oX2V4dGVuZHMoe30sIGN1cnJlbnRMb2NhdGlvbiwgeyBhY3Rpb246IF9BY3Rpb25zLlBPUCB9KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhbnNpdGlvbihsb2NhdGlvbikge1xuICAgIHN3aXRjaCAobG9jYXRpb24uYWN0aW9uKSB7XG4gICAgICBjYXNlIF9BY3Rpb25zLlBVU0g6XG4gICAgICAgIGN1cnJlbnQgKz0gMTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IG9uIHRoZSB0b3Agb2Ygc3RhY2tcbiAgICAgICAgLy8gcmVtb3ZlIHJlc3QgYW5kIHB1c2ggbmV3XG4gICAgICAgIGlmIChjdXJyZW50IDwgZW50cmllcy5sZW5ndGgpIGVudHJpZXMuc3BsaWNlKGN1cnJlbnQpO1xuXG4gICAgICAgIGVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF9BY3Rpb25zLlJFUExBQ0U6XG4gICAgICAgIGVudHJpZXNbY3VycmVudF0gPSBsb2NhdGlvbjtcbiAgICAgICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlTWVtb3J5SGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vZGVlcC1lcXVhbC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vZGVlcC1lcXVhbC9saWIva2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5zcGxpdCgnPycpWzFdIHx8ICcnO1xufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0c3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG5cdGlmICghc3RyKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0cmV0dXJuIHN0ci5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbiAocmV0LCBwYXJhbSkge1xuXHRcdHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG5cdFx0Ly8gRmlyZWZveCAocHJlIDQwKSBkZWNvZGVzIGAlM0RgIHRvIGA9YFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nL3B1bGwvMzdcblx0XHR2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzLmpvaW4oJz0nKSA6IHVuZGVmaW5lZDtcblxuXHRcdGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuXG5cdFx0Ly8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cblx0XHRpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRyZXRba2V5XSA9IHZhbDtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKSB7XG5cdFx0XHRyZXRba2V5XS5wdXNoKHZhbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldFtrZXldID0gW3JldFtrZXldLCB2YWxdO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sIHt9KTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdmFsID0gb2JqW2tleV07XG5cblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH1cblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdHJldHVybiB2YWwuc2xpY2UoKS5zb3J0KCkubWFwKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwyKTtcblx0XHRcdH0pLmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyaWN0VXJpRW5jb2RlKGtleSkgKyAnPScgKyBzdHJpY3RVcmlFbmNvZGUodmFsKTtcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHgubGVuZ3RoID4gMDtcblx0fSkuam9pbignJicpIDogJyc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0fSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L3F1ZXJ5LXN0cmluZy9+L3N0cmljdC11cmktZW5jb2RlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQXV0b0ZvY3VzVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHtcbiAgZm9jdXNET01Db21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBmb2N1c05vZGUoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcykpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9Gb2N1c1V0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQsIHRvcExldmVsVHlwZXMudG9wUGFzdGVdXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZSwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5T3BlcmF0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiVzICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgY2hlY2tSZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gICAgdmFyIG93bmVyO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oY29tcG9uZW50Ll9kZWJ1Z0lELCAndXBkYXRlIHN0eWxlcycsIHN0eWxlcyk7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0JyB8fCBzdHlsZU5hbWUgPT09ICdjc3NGbG9hdCcpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVGbG9hdEFjY2Vzc29yO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgJiYgQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbnZhciBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gU2VlIGBoYW5kbGVDaGFuZ2VgIGNvbW1lbnQgYmVsb3dcbiAgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gaXNFdmVudFN1cHBvcnRlZCgnY2hhbmdlJykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIC8vIElFMTArIGZpcmUgaW5wdXQgZXZlbnRzIHRvIG9mdGVuLCBzdWNoIHdoZW4gYSBwbGFjZWhvbGRlclxuICAvLyBjaGFuZ2VzIG9yIHdoZW4gYW4gaW5wdXQgd2l0aCBhIHBsYWNlaG9sZGVyIGlzIGZvY3VzZWQuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGlmIChhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc1NicpIDogdm9pZCAwO1xuICAgICFtYXJrdXAgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBfcHJvZEludmFyaWFudCgnNTcnKSA6IHZvaWQgMDtcbiAgICAhKG9sZENoaWxkLm5vZGVOYW1lICE9PSAnSFRNTCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSBhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IF9wcm9kSW52YXJpYW50KCc1OCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZENoaWxkLCBtYXJrdXApO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRGFuZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IFtrZXlPZih7IFJlc3BvbmRlckV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNpbXBsZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFRhcEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEVudGVyTGVhdmVFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBDaGFuZ2VFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBTZWxlY3RFdmVudFBsdWdpbjogbnVsbCB9KSwga2V5T2YoeyBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBudWxsIH0pXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VFbnRlcjogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUxlYXZlOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9XG59O1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQgJiYgdG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcikge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCkge1xuICAgICAgZnJvbSA9IHRhcmdldEluc3Q7XG4gICAgICB2YXIgcmVsYXRlZCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50O1xuICAgICAgdG8gPSByZWxhdGVkID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcblxuICAgIHJldHVybiBbbGVhdmUsIGVudGVyXTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMjA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5fYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogMCxcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGFjY2Vzc0tleTogMCxcbiAgICBhY3Rpb246IDAsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcbiAgICBhbHQ6IDAsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogMCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgY2hhclNldDogMCxcbiAgICBjaGFsbGVuZ2U6IDAsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaXRlOiAwLFxuICAgIGNsYXNzSUQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IDAsXG4gICAgY29udGVudDogMCxcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXG4gICAgY29udGV4dE1lbnU6IDAsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogMCxcbiAgICBjcm9zc09yaWdpbjogMCxcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IDAsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiAwLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IDAsXG4gICAgZW5jVHlwZTogMCxcbiAgICBmb3JtOiAwLFxuICAgIGZvcm1BY3Rpb246IDAsXG4gICAgZm9ybUVuY1R5cGU6IDAsXG4gICAgZm9ybU1ldGhvZDogMCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogMCxcbiAgICBmcmFtZUJvcmRlcjogMCxcbiAgICBoZWFkZXJzOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IDAsXG4gICAgaHJlZjogMCxcbiAgICBocmVmTGFuZzogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICBpY29uOiAwLFxuICAgIGlkOiAwLFxuICAgIGlucHV0TW9kZTogMCxcbiAgICBpbnRlZ3JpdHk6IDAsXG4gICAgaXM6IDAsXG4gICAga2V5UGFyYW1zOiAwLFxuICAgIGtleVR5cGU6IDAsXG4gICAga2luZDogMCxcbiAgICBsYWJlbDogMCxcbiAgICBsYW5nOiAwLFxuICAgIGxpc3Q6IDAsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiAwLFxuICAgIG1hbmlmZXN0OiAwLFxuICAgIG1hcmdpbkhlaWdodDogMCxcbiAgICBtYXJnaW5XaWR0aDogMCxcbiAgICBtYXg6IDAsXG4gICAgbWF4TGVuZ3RoOiAwLFxuICAgIG1lZGlhOiAwLFxuICAgIG1lZGlhR3JvdXA6IDAsXG4gICAgbWV0aG9kOiAwLFxuICAgIG1pbjogMCxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IDAsXG4gICAgbm9uY2U6IDAsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogMCxcbiAgICBwYXR0ZXJuOiAwLFxuICAgIHBsYWNlaG9sZGVyOiAwLFxuICAgIHBvc3RlcjogMCxcbiAgICBwcmVsb2FkOiAwLFxuICAgIHByb2ZpbGU6IDAsXG4gICAgcmFkaW9Hcm91cDogMCxcbiAgICByZWFkT25seTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVmZXJyZXJQb2xpY3k6IDAsXG4gICAgcmVsOiAwLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogMCxcbiAgICByb3dzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzYW5kYm94OiAwLFxuICAgIHNjb3BlOiAwLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2Nyb2xsaW5nOiAwLFxuICAgIHNlYW1sZXNzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaGFwZTogMCxcbiAgICBzaXplOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzaXplczogMCxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiAwLFxuICAgIHNyYzogMCxcbiAgICBzcmNEb2M6IDAsXG4gICAgc3JjTGFuZzogMCxcbiAgICBzcmNTZXQ6IDAsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IDAsXG4gICAgc3R5bGU6IDAsXG4gICAgc3VtbWFyeTogMCxcbiAgICB0YWJJbmRleDogMCxcbiAgICB0YXJnZXQ6IDAsXG4gICAgdGl0bGU6IDAsXG4gICAgLy8gU2V0dGluZyAudHlwZSB0aHJvd3Mgb24gbm9uLTxpbnB1dD4gdGFnc1xuICAgIHR5cGU6IDAsXG4gICAgdXNlTWFwOiAwLFxuICAgIHZhbHVlOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIHdtb2RlOiAwLFxuICAgIHdyYXA6IDAsXG5cbiAgICAvKipcbiAgICAgKiBSREZhIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhYm91dDogMCxcbiAgICBkYXRhdHlwZTogMCxcbiAgICBpbmxpc3Q6IDAsXG4gICAgcHJlZml4OiAwLFxuICAgIC8vIHByb3BlcnR5IGlzIGFsc28gc3VwcG9ydGVkIGZvciBPcGVuR3JhcGggaW4gbWV0YSB0YWdzLlxuICAgIHByb3BlcnR5OiAwLFxuICAgIHJlc291cmNlOiAwLFxuICAgICd0eXBlb2YnOiAwLFxuICAgIHZvY2FiOiAwLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICAvLyBhdXRvQ2FwaXRhbGl6ZSBhbmQgYXV0b0NvcnJlY3QgYXJlIHN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxuICAgIGF1dG9DYXBpdGFsaXplOiAwLFxuICAgIGF1dG9Db3JyZWN0OiAwLFxuICAgIC8vIGF1dG9TYXZlIGFsbG93cyBXZWJLaXQvQmxpbmsgdG8gcGVyc2lzdCB2YWx1ZXMgb2YgaW5wdXQgZmllbGRzIG9uIHBhZ2UgcmVsb2Fkc1xuICAgIGF1dG9TYXZlOiAwLFxuICAgIC8vIGNvbG9yIGlzIGZvciBTYWZhcmkgbWFzay1pY29uIGxpbmtcbiAgICBjb2xvcjogMCxcbiAgICAvLyBpdGVtUHJvcCwgaXRlbVNjb3BlLCBpdGVtVHlwZSBhcmUgZm9yXG4gICAgLy8gTWljcm9kYXRhIHN1cHBvcnQuIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtUHJvcDogMCxcbiAgICBpdGVtU2NvcGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGl0ZW1UeXBlOiAwLFxuICAgIC8vIGl0ZW1JRCBhbmQgaXRlbVJlZiBhcmUgZm9yIE1pY3JvZGF0YSBzdXBwb3J0IGFzIHdlbGwgYnV0XG4gICAgLy8gb25seSBzcGVjaWZpZWQgaW4gdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9taWNyb2RhdGEuaHRtbCNtaWNyb2RhdGEtZG9tLWFwaVxuICAgIGl0ZW1JRDogMCxcbiAgICBpdGVtUmVmOiAwLFxuICAgIC8vIHJlc3VsdHMgc2hvdyBsb29raW5nIGdsYXNzIGljb24gYW5kIHJlY2VudCBzZWFyY2hlcyBvbiBpbnB1dFxuICAgIC8vIHNlYXJjaCBmaWVsZHMgaW4gV2ViS2l0L0JsaW5rXG4gICAgcmVzdWx0czogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyBzZWN1cml0eSByZXN0cmljdGlvbnMgb24gYW4gaWZyYW1lXG4gICAgLy8gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIHNhbmRib3ggYXR0cmlidXRlIG9uIElFPDEwXG4gICAgc2VjdXJpdHk6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBjb250cm9scyBmb2N1cyBiZWhhdmlvclxuICAgIHVuc2VsZWN0YWJsZTogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzXG4gKiogbW9kdWxlIGlkID0gMjA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0UHVyZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RQdXJlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudDtcbiAgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xuICBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2xvbmVFbGVtZW50O1xufVxuXG52YXIgX19zcHJlYWQgPSBfYXNzaWduO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCwgJ1JlYWN0Ll9fc3ByZWFkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gVXNlICcgKyAnT2JqZWN0LmFzc2lnbiBkaXJlY3RseSBvciBhbm90aGVyIGhlbHBlciBmdW5jdGlvbiB3aXRoIHNpbWlsYXIgJyArICdzZW1hbnRpY3MuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8geW91ciBjb21waWxlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcHJlYWQtZGVwcmVjYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcbiAgICB3YXJuZWQgPSB0cnVlO1xuICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBSZWFjdFB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gRGVwcmVjYXRlZCBob29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcuXG4gIF9fc3ByZWFkOiBfX3NwcmVhZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkUmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0YW5jZXMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIGtleVVuaXF1ZSA9IGNoaWxkSW5zdGFuY2VzW25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgICB9LCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIHZhciBwcmV2Q2hpbGQ7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgICAvLyBDcmVhdGluZyBtb3VudCBpbWFnZSBub3cgZW5zdXJlcyByZWZzIGFyZSByZXNvbHZlZCBpbiByaWdodCBvcmRlclxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxMDEgZm9yIGV4cGxhbmF0aW9uKS5cbiAgICAgICAgdmFyIG5leHRDaGlsZE1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQobmV4dENoaWxkSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICBtb3VudEltYWdlcy5wdXNoKG5leHRDaGlsZE1vdW50SW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkLCBzYWZlbHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID09PSBlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpc011dGF0ZWQgPSBmYWxzZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4pKSB7XG4gICAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuLmxlbmd0aCA9PT0gZWxlbWVudC5wcm9wcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuW2ldICE9PSBlbGVtZW50LnByb3BzLmNoaWxkcmVuW2ldKSB7XG4gICAgICAgICAgaXNNdXRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpc011dGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4pIHx8IGlzTXV0YXRlZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50XFwncyBjaGlsZHJlbiBzaG91bGQgbm90IGJlIG11dGF0ZWQuJXMnLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2sgPSB7XG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoZGVidWdJRCkpO1xuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rLmpzXG4gKiogbW9kdWxlIGlkID0gMjA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGFsbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSByZWNvbmNpbGVyIHRoYXQgcmVxdWlyZXMga25vd2xlZGdlIG9mXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LiBUT0RPOiBUaGVzZSBjYWxsZXJzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIGF2b2lkIHRoZVxuICogbmVlZCBmb3IgdGhpcyBpbmplY3Rpb24uXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcblxuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMsXG5cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQ29tcG9zaXRlVHlwZXMgPSB7XG4gIEltcHVyZUNsYXNzOiAwLFxuICBQdXJlQ2xhc3M6IDEsXG4gIFN0YXRlbGVzc0Z1bmN0aW9uYWw6IDJcbn07XG5cbmZ1bmN0aW9uIFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpIHt9XG5TdGF0ZWxlc3NDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENvbXBvbmVudCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICB2YXIgZWxlbWVudCA9IENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQsIHRoaXMudXBkYXRlcik7XG4gIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuZnVuY3Rpb24gd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ29tcG9uZW50RGlkTW91bnRXaXRoVGltZXIoKSB7XG4gIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gIH1cbiAgcHVibGljSW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDb21wb25lbnREaWRVcGRhdGVXaXRoVGltZXIocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSB7XG4gIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICB9XG4gIHB1YmxpY0luc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCk7XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tIFRoZSBMaWZlLUN5Y2xlIG9mIGEgQ29tcG9zaXRlIENvbXBvbmVudCAtLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAtIGNvbnN0cnVjdG9yOiBJbml0aWFsaXphdGlvbiBvZiBzdGF0ZS4gVGhlIGluc3RhbmNlIGlzIG5vdyByZXRhaW5lZC5cbiAqICAgLSBjb21wb25lbnRXaWxsTW91bnRcbiAqICAgLSByZW5kZXJcbiAqICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnNdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlcl1cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudERpZE1vdW50XVxuICogICAgIC0gY29tcG9uZW50RGlkTW91bnRcbiAqXG4gKiAgICAgICBVcGRhdGUgUGhhc2VzOlxuICogICAgICAgLSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIChvbmx5IGNhbGxlZCBpZiBwYXJlbnQgdXBkYXRlZClcbiAqICAgICAgIC0gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gKiAgICAgICAgIC0gY29tcG9uZW50V2lsbFVwZGF0ZVxuICogICAgICAgICAgIC0gcmVuZGVyXG4gKiAgICAgICAgICAgLSBbY2hpbGRyZW4ncyBjb25zdHJ1Y3RvcnMgb3IgcmVjZWl2ZSBwcm9wcyBwaGFzZXNdXG4gKiAgICAgICAgIC0gY29tcG9uZW50RGlkVXBkYXRlXG4gKlxuICogICAgIC0gY29tcG9uZW50V2lsbFVubW91bnRcbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxVbm1vdW50XVxuICogICAtIFtjaGlsZHJlbiBkZXN0cm95ZWRdXG4gKiAtIChkZXN0cm95ZWQpOiBUaGUgaW5zdGFuY2UgaXMgbm93IGJsYW5rLCByZWxlYXNlZCBieSBSZWFjdCBhbmQgcmVhZHkgZm9yIEdDLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBBbiBpbmNyZW1lbnRpbmcgSUQgYXNzaWduZWQgdG8gZWFjaCBjb21wb25lbnQgd2hlbiBpdCBpcyBtb3VudGVkLiBUaGlzIGlzXG4gKiB1c2VkIHRvIGVuZm9yY2UgdGhlIG9yZGVyIGluIHdoaWNoIGBSZWFjdFVwZGF0ZXNgIHVwZGF0ZXMgZGlydHkgY29tcG9uZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbmV4dE1vdW50SUQgPSAxO1xuXG4vKipcbiAqIEBsZW5kcyB7UmVhY3RDb21wb3NpdGVDb21wb25lbnQucHJvdG90eXBlfVxuICovXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiA9IHtcblxuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvc2l0ZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVzIGFuZCBSZWFjdFVwZGF0ZVF1ZXVlLlxuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgLy8gQ29tcG9uZW50V2lsbFVubW91bnQgc2hhbGwgb25seSBiZSBjYWxsZWQgb25jZVxuICAgIHRoaXMuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdFBhcmVudFxuICAgKiBAcGFyYW0gez9vYmplY3R9IGhvc3RDb250YWluZXJJbmZvXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICB2YXIgdXBkYXRlUXVldWUgPSB0cmFuc2FjdGlvbi5nZXRVcGRhdGVRdWV1ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGRvQ29uc3RydWN0ID0gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCk7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFN1cHBvcnQgZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgaWYgKCFkb0NvbnN0cnVjdCAmJiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0O1xuICAgICAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCByZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgIShpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA1JywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGluc3QgPSBuZXcgU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCk7XG4gICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuSW1wdXJlQ2xhc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBsYXRlciBpbiBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50LCBidXQgYWRkIGFuIGVhcmx5XG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xuICAgICAgaWYgKGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHNNdXRhdGVkID0gaW5zdC5wcm9wcyAhPT0gcHVibGljUHJvcHM7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdC5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFwcm9wc011dGF0ZWQsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgJ3VwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnRcXCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHNldCB1cCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0LnVwZGF0ZXIgPSB1cGRhdGVRdWV1ZTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXA7XG4gICAgaWYgKGluc3QudW5zdGFibGVfaGFuZGxlRXJyb3IpIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnZva2VDb21wb25lbnREaWRNb3VudFdpdGhUaW1lciwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkTW91bnQsIGluc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudDogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXI6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3RhbmNlT3JFbGVtZW50O1xuICAgIGlmIChkb0NvbnN0cnVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3RhbmNlT3JFbGVtZW50ID0gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY3RvcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgY2FuIHN0aWxsIGJlIGFuIGluc3RhbmNlIGluIGNhc2Ugb2YgZmFjdG9yeSBjb21wb25lbnRzXG4gICAgICAvLyBidXQgd2UnbGwgY291bnQgdGhpcyBhcyB0aW1lIHNwZW50IHJlbmRlcmluZyBhcyB0aGUgbW9yZSBjb21tb24gY2FzZS5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3RhbmNlT3JFbGVtZW50ID0gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VPckVsZW1lbnQ7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nOiBmdW5jdGlvbiAocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwO1xuICAgIHZhciBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuICAgIHRyeSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUm9sbCBiYWNrIHRvIGNoZWNrcG9pbnQsIGhhbmRsZSBlcnJvciAod2hpY2ggbWF5IGFkZCBpdGVtcyB0byB0aGUgdHJhbnNhY3Rpb24pLCBhbmQgdGFrZSBhIG5ldyBjaGVja3BvaW50XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnVuc3RhYmxlX2hhbmRsZUVycm9yKGUpO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZSh0aGlzLl9pbnN0YW5jZS5wcm9wcywgdGhpcy5faW5zdGFuY2UuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KHRydWUpO1xuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG5cbiAgICAgIC8vIFRyeSBhZ2FpbiAtIHdlJ3ZlIGluZm9ybWVkIHRoZSBjb21wb25lbnQgYWJvdXQgdGhlIGVycm9yLCBzbyB0aGV5IGNhbiByZW5kZXIgYW4gZXJyb3IgbWVzc2FnZSB0aGlzIHRpbWUuXG4gICAgICAvLyBJZiB0aGlzIHRocm93cyBhZ2FpbiwgdGhlIGVycm9yIHdpbGwgYnViYmxlIHVwIChhbmQgY2FuIGJlIGNhdWdodCBieSBhIGhpZ2hlciBlcnJvciBib3VuZGFyeSkuXG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnQ6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShyZW5kZXJlZEVsZW1lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgKTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2VsZkRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIHNlbGZEZWJ1Z0lEKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgaWYgKCF0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQgJiYgIWluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IHRydWU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzYWZlbHkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoKSArICcuY29tcG9uZW50V2lsbFVubW91bnQoKSc7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudC5iaW5kKGluc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgfVxuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCAmJiBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0KCk7XG4gICAgfVxuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwOCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBjb250ZXh0IHR5cGVzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBjb250ZXh0IGZpZWxkIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAodHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgdGhpcy5nZXROYW1lKCksIG51bGwsIHRoaXMuX2RlYnVnSUQpO1xuICB9LFxuXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIG5leHRDb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIHByZXZDb250ZXh0LCBuZXh0Q29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGFueSBvZiBgX3BlbmRpbmdFbGVtZW50YCwgYF9wZW5kaW5nU3RhdGVRdWV1ZWAsIG9yIGBfcGVuZGluZ0ZvcmNlVXBkYXRlYFxuICAgKiBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQodGhpcywgdGhpcy5fcGVuZGluZ0VsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlICE9PSBudWxsIHx8IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gdXBkYXRlIHRvIGEgbW91bnRlZCBjb21wb25lbnQuIFRoZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGFuZFxuICAgKiBzaG91bGRDb21wb25lbnRVcGRhdGUgbWV0aG9kcyBhcmUgY2FsbGVkLCB0aGVuIChhc3N1bWluZyB0aGUgdXBkYXRlIGlzbid0XG4gICAqIHNraXBwZWQpIHRoZSByZW1haW5pbmcgdXBkYXRlIGxpZmVjeWNsZSBtZXRob2RzIGFyZSBjYWxsZWQgYW5kIHRoZSBET01cbiAgICogcmVwcmVzZW50YXRpb24gaXMgdXBkYXRlZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2UGFyZW50RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dFBhcmVudEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZQYXJlbnRFbGVtZW50LCBuZXh0UGFyZW50RWxlbWVudCwgcHJldlVubWFza2VkQ29udGV4dCwgbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgIShpbnN0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0F0dGVtcHRlZCB0byB1cGRhdGUgY29tcG9uZW50IGAlc2AgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHVubW91bnRlZCAob3IgZmFpbGVkIHRvIG1vdW50KS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMzYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHZhciB3aWxsUmVjZWl2ZSA9IGZhbHNlO1xuICAgIHZhciBuZXh0Q29udGV4dDtcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgY29udGV4dCBoYXMgY2hhbmdlZCBvciBub3RcbiAgICBpZiAodGhpcy5fY29udGV4dCA9PT0gbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgICAgbmV4dENvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQobmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByZXZQcm9wcyA9IHByZXZQYXJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSBuZXh0UGFyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIE5vdCBhIHNpbXBsZSBzdGF0ZSB1cGRhdGUgYnV0IGEgcHJvcHMgdXBkYXRlXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ICE9PSBuZXh0UGFyZW50RWxlbWVudCkge1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFuIHVwZGF0ZSBoZXJlIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIGJ1dCBpbW1lZGlhdGVseSBzZXRcbiAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXG4gICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuICAgIGlmICh3aWxsUmVjZWl2ZSAmJiBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3MpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKGluc3Quc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKG5leHRQYXJlbnRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUgYnV0IHdlIHNob3J0Y3V0IHRoZSByZXN0IG9mIHRoZSB1cGRhdGUuXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRQYXJlbnRFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGV4dCA9IG5leHRVbm1hc2tlZENvbnRleHQ7XG4gICAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIH1cbiAgfSxcblxuICBfcHJvY2Vzc1BlbmRpbmdTdGF0ZTogZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZTtcbiAgICB2YXIgcmVwbGFjZSA9IHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBpbnN0LnN0YXRlO1xuICAgIH1cblxuICAgIGlmIChyZXBsYWNlICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHF1ZXVlWzBdO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBfYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBfYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBoYXNDb21wb25lbnREaWRVcGRhdGUgPSBCb29sZWFuKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKTtcbiAgICB2YXIgcHJldlByb3BzO1xuICAgIHZhciBwcmV2U3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0O1xuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgICBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnZva2VDb21wb25lbnREaWRVcGRhdGVXaXRoVGltZXIuYmluZCh0aGlzLCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldlJlbmRlcmVkRWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldlJlbmRlcmVkRWxlbWVudCwgbmV4dFJlbmRlcmVkRWxlbWVudCkpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgbmV4dFJlbmRlcmVkRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2xkSG9zdE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgZmFsc2UpO1xuXG4gICAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKG5leHRSZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0UmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICAgICk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2VsZkRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgICAgfVxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLl9ob3N0UGFyZW50LCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgc2VsZkRlYnVnSUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZGVuIGluIHNoYWxsb3cgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmIChyZW5kZXJlZENvbXBvbmVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fCB0aGlzLl9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9XG4gICAgIShcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcbiAgICByZW5kZXJlZENvbXBvbmVudCA9PT0gbnVsbCB8fCByZW5kZXJlZENvbXBvbmVudCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkQ29tcG9uZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMucmVuZGVyKCk6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDknLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTAnKSA6IHZvaWQgMDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSB7XG5cbiAgTWl4aW46IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogUmVhY3RNb3VudC5yZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbi8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5pZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCh7XG4gICAgQ29tcG9uZW50VHJlZToge1xuICAgICAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgICAgIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIC8vIGluc3QgaXMgYW4gaW50ZXJuYWwgaW5zdGFuY2UgKGJ1dCBjb3VsZCBiZSBhIGNvbXBvc2l0ZSlcbiAgICAgICAgaWYgKGluc3QuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBNb3VudDogUmVhY3RNb3VudCxcbiAgICBSZWNvbmNpbGVyOiBSZWFjdFJlY29uY2lsZXJcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IGhhdmUgdGhlIGlzc3VlIHdpdGggZGV2dG9vbHMgbG9hZGVkIG92ZXIgZmlsZTovL1xuICAgICAgICB2YXIgc2hvd0ZpbGVVcmxNZXNzYWdlID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArIChzaG93RmlsZVVybE1lc3NhZ2UgPyAnYW5kIHVzZSBhbiBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBhIGZpbGU6IFVSTCkgJyA6ICcnKSArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRlc3RGdW5jID0gZnVuY3Rpb24gdGVzdEZuKCkge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoKHRlc3RGdW5jLm5hbWUgfHwgdGVzdEZ1bmMudG9TdHJpbmcoKSkuaW5kZXhPZigndGVzdEZuJykgIT09IC0xLCAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhIG1pbmlmaWVkIGNvcHkgb2YgdGhlIGRldmVsb3BtZW50IGJ1aWxkICcgKyAnb2YgUmVhY3QuIFdoZW4gZGVwbG95aW5nIFJlYWN0IGFwcHMgdG8gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRvIHVzZSAnICsgJ3RoZSBwcm9kdWN0aW9uIGJ1aWxkIHdoaWNoIHNraXBzIGRldmVsb3BtZW50IHdhcm5pbmdzIGFuZCBpcyBmYXN0ZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtbWluaWZpY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsIFN0cmluZy5wcm90b3R5cGUudHJpbV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09uZSBvciBtb3JlIEVTNSBzaGltcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG4gIHZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaycpO1xuICB2YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2snKTtcblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2spO1xuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTS5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQnV0dG9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0gcmVxdWlyZSgnLi9EaXNhYmxlZElucHV0VXRpbHMnKTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPGJ1dHRvbj4gaG9zdCBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0ge1xuICBnZXRIb3N0UHJvcHM6IERpc2FibGVkSW5wdXRVdGlscy5nZXRIb3N0UHJvcHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01CdXR0b247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQnV0dG9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRcbiAqL1xuXG4vKiBnbG9iYWwgaGFzT3duUHJvcGVydHk6dHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0gcmVxdWlyZSgnLi9BdXRvRm9jdXNVdGlscycpO1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKCcuL1JlYWN0RE9NQnV0dG9uJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRGbGFncycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZCcpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcbnZhciBkZWxldGVMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGdldE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geyAnc3RyaW5nJzogdHJ1ZSwgJ251bWJlcic6IHRydWUgfTtcblxudmFyIFNUWUxFID0ga2V5T2YoeyBzdHlsZTogbnVsbCB9KTtcbnZhciBIVE1MID0ga2V5T2YoeyBfX2h0bWw6IG51bGwgfSk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogbnVsbCxcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiBudWxsXG59O1xuXG4vLyBOb2RlIHR5cGUgZm9yIGRvY3VtZW50IGZyYWdtZW50cyAoTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKS5cbnZhciBET0NfRlJBR01FTlRfVFlQRSA9IDExO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oaW50ZXJuYWxJbnN0YW5jZSkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHZhciBvd25lciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBUaGlzIERPTSBub2RlIHdhcyByZW5kZXJlZCBieSBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGZyaWVuZGx5U3RyaW5naWZ5KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gJ1snICsgb2JqLm1hcChmcmllbmRseVN0cmluZ2lmeSkuam9pbignLCAnKSArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGtleUVzY2FwZWQgPSAvXlthLXokX11bXFx3JF9dKiQvaS50ZXN0KGtleSkgPyBrZXkgOiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgICAgIHBhaXJzLnB1c2goa2V5RXNjYXBlZCArICc6ICcgKyBmcmllbmRseVN0cmluZ2lmeShvYmpba2V5XSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3snICsgcGFpcnMuam9pbignLCAnKSArICd9JztcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICdbZnVuY3Rpb24gb2JqZWN0XSc7XG4gIH1cbiAgLy8gRGlmZmVycyBmcm9tIEpTT04uc3RyaW5naWZ5IGluIHRoYXQgdW5kZWZpbmVkIGJlY2F1c2UgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdm9pZCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1tjb21wb25lbnQuX3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCcxMzcnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogX3Byb2RJbnZhcmlhbnQoJzYwJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCc2MScpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuaW5uZXJIVE1MID09IG51bGwsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5vbkZvY3VzSW4gPT0gbnVsbCAmJiBwcm9wcy5vbkZvY3VzT3V0ID09IG51bGwsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpIDogdm9pZCAwO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzYyJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIsIHRyYW5zYWN0aW9uKSB7XG4gIGlmICh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgY29udGFpbmVySW5mbyA9IGluc3QuX2hvc3RDb250YWluZXJJbmZvO1xuICB2YXIgaXNEb2N1bWVudEZyYWdtZW50ID0gY29udGFpbmVySW5mby5fbm9kZSAmJiBjb250YWluZXJJbmZvLl9ub2RlLm5vZGVUeXBlID09PSBET0NfRlJBR01FTlRfVFlQRTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRGcmFnbWVudCA/IGNvbnRhaW5lckluZm8uX25vZGUgOiBjb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xuICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHB1dExpc3RlbmVyLCB7XG4gICAgaW5zdDogaW5zdCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIobGlzdGVuZXJUb1B1dC5pbnN0LCBsaXN0ZW5lclRvUHV0LnJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyVG9QdXQubGlzdGVuZXIpO1xufVxuXG5mdW5jdGlvbiBpbnB1dFBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTUlucHV0LnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIHRleHRhcmVhUG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NVGV4dGFyZWEucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uUG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NT3B0aW9uLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbnZhciBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB2YXIgaGFzRXhpc3RpbmdDb250ZW50ID0gdGhpcy5fY29udGVudERlYnVnSUQgIT0gbnVsbDtcbiAgICB2YXIgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgLy8gVGhpcyBJRCByZXByZXNlbnRzIHRoZSBpbmxpbmVkIGNoaWxkIHRoYXQgaGFzIG5vIGJhY2tpbmcgaW5zdGFuY2U6XG4gICAgdmFyIGNvbnRlbnREZWJ1Z0lEID0gLWRlYnVnSUQ7XG5cbiAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQodGhpcy5fY29udGVudERlYnVnSUQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gY29udGVudERlYnVnSUQ7XG4gICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lELCBjb250ZW50KTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGNvbnRlbnREZWJ1Z0lELCBjb250ZW50LCBkZWJ1Z0lEKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIFtjb250ZW50RGVidWdJRF0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxuICAhaW5zdC5fcm9vdE5vZGVJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IF9wcm9kSW52YXJpYW50KCc2MycpIDogdm9pZCAwO1xuICB2YXIgbm9kZSA9IGdldE5vZGUoaW5zdCk7XG4gICFub2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc2NCcpIDogdm9pZCAwO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcblxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycy5wdXNoKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNbZXZlbnRdLCBtZWRpYUV2ZW50c1tldmVudF0sIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BFcnJvciwgJ2Vycm9yJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BFcnJvciwgJ2Vycm9yJywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BSZXNldCwgJ3Jlc2V0Jywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wU3VibWl0LCAnc3VibWl0Jywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEludmFsaWQsICdpbnZhbGlkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NU2VsZWN0LnBvc3RVcGRhdGVXcmFwcGVyKHRoaXMpO1xufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgJ2FyZWEnOiB0cnVlLFxuICAnYmFzZSc6IHRydWUsXG4gICdicic6IHRydWUsXG4gICdjb2wnOiB0cnVlLFxuICAnZW1iZWQnOiB0cnVlLFxuICAnaHInOiB0cnVlLFxuICAnaW1nJzogdHJ1ZSxcbiAgJ2lucHV0JzogdHJ1ZSxcbiAgJ2tleWdlbic6IHRydWUsXG4gICdsaW5rJzogdHJ1ZSxcbiAgJ21ldGEnOiB0cnVlLFxuICAncGFyYW0nOiB0cnVlLFxuICAnc291cmNlJzogdHJ1ZSxcbiAgJ3RyYWNrJzogdHJ1ZSxcbiAgJ3dicic6IHRydWVcbn07XG5cbi8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gICdsaXN0aW5nJzogdHJ1ZSxcbiAgJ3ByZSc6IHRydWUsXG4gICd0ZXh0YXJlYSc6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICAnbWVudWl0ZW0nOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY1JywgdGFnKSA6IHZvaWQgMDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG52YXIgZ2xvYmFsSWRDb3VudGVyID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJlYWN0IGNsYXNzIHRoYXQgaXMgaWRlbXBvdGVudCBhbmQgY2FwYWJsZSBvZiBjb250YWluaW5nIG90aGVyXG4gKiBSZWFjdCBjb21wb25lbnRzLiBJdCBhY2NlcHRzIGV2ZW50IGxpc3RlbmVycyBhbmQgRE9NIHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIHZhbGlkIGFjY29yZGluZyB0byBgRE9NUHJvcGVydHlgLlxuICpcbiAqICAtIEV2ZW50IGxpc3RlbmVyczogYG9uQ2xpY2tgLCBgb25Nb3VzZURvd25gLCBldGMuXG4gKiAgLSBET00gcHJvcGVydGllczogYGNsYXNzTmFtZWAsIGBuYW1lYCwgYHRpdGxlYCwgZXRjLlxuICpcbiAqIFRoZSBgc3R5bGVgIHByb3BlcnR5IGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmcm9tIHRoZSBET00gQVBJLiBJdCBhY2NlcHRzIGFuXG4gKiBvYmplY3QgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgUmVhY3RET01Db21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0TXVsdGlDaGlsZFxuICovXG5mdW5jdGlvbiBSZWFjdERPTUNvbXBvbmVudChlbGVtZW50KSB7XG4gIHZhciB0YWcgPSBlbGVtZW50LnR5cGU7XG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgdGhpcy5fdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIHRoaXMuX25hbWVzcGFjZVVSSSA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgdGhpcy5fZG9tSUQgPSAwO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG4gIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG4gIHRoaXMuX2ZsYWdzID0gMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0aGlzLl9hbmNlc3RvckluZm8gPSBudWxsO1xuICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG51bGwpO1xuICB9XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/UmVhY3RET01Db21wb25lbnR9IHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcHV0ZWQgbWFya3VwLlxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gZ2xvYmFsSWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBSZWFjdERPTU9wdGlvbi5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG5cbiAgICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gICAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuICAgIHZhciBuYW1lc3BhY2VVUkk7XG4gICAgdmFyIHBhcmVudFRhZztcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBob3N0UGFyZW50Ll9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0UGFyZW50Ll90YWc7XG4gICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBob3N0Q29udGFpbmVySW5mby5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdENvbnRhaW5lckluZm8uX3RhZztcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgcGFyZW50VGFnID09PSAnZm9yZWlnbm9iamVjdCcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuaHRtbDtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICBpZiAodGhpcy5fdGFnID09PSAnc3ZnJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLnN2ZztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGFnID09PSAnbWF0aCcpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5tYXRobWw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX25hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0aGlzLl90YWcsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SW5mbywgdGhpcy5fdGFnLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgbW91bnRJbWFnZTtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBlbDtcbiAgICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5fdGFnID09PSAnc2NyaXB0Jykge1xuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwnICsgdHlwZSArICc+PC8nICsgdHlwZSArICc+JztcbiAgICAgICAgICBlbCA9IGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMuaXMpIHtcbiAgICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlLCBwcm9wcy5pcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2VwYXJhdGUgZWxzZSBicmFuY2ggaW5zdGVhZCBvZiB1c2luZyBgcHJvcHMuaXMgfHwgdW5kZWZpbmVkYCBhYm92ZSBiZWN1YXNlIG9mIGEgRmlyZWZveCBidWcuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBlbCk7XG4gICAgICB0aGlzLl9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xuICAgICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JSb290KGVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobnVsbCwgcHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnB1dFBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0ZXh0YXJlYVBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUob3B0aW9uUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBwcm9wcy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya3VwID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyAhPSBudWxsICYmIGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgcHJvcHMpKSB7XG4gICAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAgIC8vIGJ5dGVzLlxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUm9vdCgpO1xuICAgIH1cbiAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX2RvbUlEKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgdGFncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG5cbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHJldCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHJldCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcihjb250ZW50VG9Vc2UpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlSFRNTChsYXp5VHJlZSwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZVRleHQobGF6eVRyZWUsIGNvbnRlbnRUb1VzZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdW50SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgbW91bnRJbWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgICAgLy8gaGFwcGVuIGFmdGVyIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgcHJvcGVydGllcyBieSBkZXRlY3RpbmcgZGlmZmVyZW5jZXMgaW4gcHJvcGVydHkgdmFsdWVzIGFuZFxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXG4gICAqIFRPRE86IEJlbmNobWFyayB0aGUgZWZmZWN0cyBvZiBwdXR0aW5nIHRoaXMgYXQgdGhlIHRvcCBzaW5jZSA5OSUgb2YgcHJvcHNcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbGFzdFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbmV4dFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZ2V0Tm9kZSh0aGlzKTtcbiAgICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKGdldE5vZGUodGhpcyksIHN0eWxlVXBkYXRlcywgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrdXAoJycgKyBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnRzIGxpa2UgPGh0bWw+IDxoZWFkPiBhbmQgPGJvZHk+IGNhbid0IGJlIHJlbW92ZWQgb3IgYWRkZWRcbiAgICAgICAgICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXG4gICAgICAgICAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cbiAgICAgICAgICogbWFuYWdlbWVudC4gU28gd2UganVzdCBkb2N1bWVudCBpdCBhbmQgdGhyb3cgaW4gZGFuZ2Vyb3VzIGNhc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzwlcz4gdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyBpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCA8aGVhZD4sIGFuZCA8Ym9keT4pIHJlbGlhYmx5IGFuZCBlZmZpY2llbnRseS4gVG8gZml4IHRoaXMsIGhhdmUgYSBzaW5nbGUgdG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSBlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY2JywgdGhpcy5fdGFnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oc2FmZWx5KTtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gICAgRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX2RvbUlEID0gMDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9XG5cbn07XG5cbl9hc3NpZ24oUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbiwgUmVhY3RNdWx0aUNoaWxkLk1peGluKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbnRhaW5lckluZm9cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQ29udGFpbmVySW5mbyh0b3BMZXZlbFdyYXBwZXIsIG5vZGUpIHtcbiAgdmFyIGluZm8gPSB7XG4gICAgX3RvcExldmVsV3JhcHBlcjogdG9wTGV2ZWxXcmFwcGVyLFxuICAgIF9pZENvdW50ZXI6IDEsXG4gICAgX293bmVyRG9jdW1lbnQ6IG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFID8gbm9kZSA6IG5vZGUub3duZXJEb2N1bWVudCA6IG51bGwsXG4gICAgX25vZGU6IG5vZGUsXG4gICAgX3RhZzogbm9kZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGwsXG4gICAgX25hbWVzcGFjZVVSSTogbm9kZSA/IG5vZGUubmFtZXNwYWNlVVJJIDogbnVsbFxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluZm8uX2FuY2VzdG9ySW5mbyA9IG5vZGUgPyB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCBpbmZvLl90YWcsIG51bGwpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbnRhaW5lckluZm87XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29udGFpbmVySW5mby5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgLy8gUmVhY3RDb21wb3NpdGVDb21wb25lbnQgdXNlcyB0aGlzOlxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX2RvbUlEID0gMDtcbn07XG5fYXNzaWduKFJlYWN0RE9NRW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBub2RlVmFsdWUgPSAnIHJlYWN0LWVtcHR5OiAnICsgdGhpcy5fZG9tSUQgKyAnICc7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcbiAgICAgIHJldHVybiBET01MYXp5VHJlZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaW5zZXJ0IGEgY29tbWVudCBub2RlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvblxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01FbXB0eUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01FbXB0eUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmFjdG9yaWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0ge1xuICBhOiBjcmVhdGVET01GYWN0b3J5KCdhJyksXG4gIGFiYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2FiYnInKSxcbiAgYWRkcmVzczogY3JlYXRlRE9NRmFjdG9yeSgnYWRkcmVzcycpLFxuICBhcmVhOiBjcmVhdGVET01GYWN0b3J5KCdhcmVhJyksXG4gIGFydGljbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FydGljbGUnKSxcbiAgYXNpZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FzaWRlJyksXG4gIGF1ZGlvOiBjcmVhdGVET01GYWN0b3J5KCdhdWRpbycpLFxuICBiOiBjcmVhdGVET01GYWN0b3J5KCdiJyksXG4gIGJhc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jhc2UnKSxcbiAgYmRpOiBjcmVhdGVET01GYWN0b3J5KCdiZGknKSxcbiAgYmRvOiBjcmVhdGVET01GYWN0b3J5KCdiZG8nKSxcbiAgYmlnOiBjcmVhdGVET01GYWN0b3J5KCdiaWcnKSxcbiAgYmxvY2txdW90ZTogY3JlYXRlRE9NRmFjdG9yeSgnYmxvY2txdW90ZScpLFxuICBib2R5OiBjcmVhdGVET01GYWN0b3J5KCdib2R5JyksXG4gIGJyOiBjcmVhdGVET01GYWN0b3J5KCdicicpLFxuICBidXR0b246IGNyZWF0ZURPTUZhY3RvcnkoJ2J1dHRvbicpLFxuICBjYW52YXM6IGNyZWF0ZURPTUZhY3RvcnkoJ2NhbnZhcycpLFxuICBjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdjYXB0aW9uJyksXG4gIGNpdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpdGUnKSxcbiAgY29kZTogY3JlYXRlRE9NRmFjdG9yeSgnY29kZScpLFxuICBjb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbCcpLFxuICBjb2xncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnY29sZ3JvdXAnKSxcbiAgZGF0YTogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YScpLFxuICBkYXRhbGlzdDogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YWxpc3QnKSxcbiAgZGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2RkJyksXG4gIGRlbDogY3JlYXRlRE9NRmFjdG9yeSgnZGVsJyksXG4gIGRldGFpbHM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RldGFpbHMnKSxcbiAgZGZuOiBjcmVhdGVET01GYWN0b3J5KCdkZm4nKSxcbiAgZGlhbG9nOiBjcmVhdGVET01GYWN0b3J5KCdkaWFsb2cnKSxcbiAgZGl2OiBjcmVhdGVET01GYWN0b3J5KCdkaXYnKSxcbiAgZGw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RsJyksXG4gIGR0OiBjcmVhdGVET01GYWN0b3J5KCdkdCcpLFxuICBlbTogY3JlYXRlRE9NRmFjdG9yeSgnZW0nKSxcbiAgZW1iZWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2VtYmVkJyksXG4gIGZpZWxkc2V0OiBjcmVhdGVET01GYWN0b3J5KCdmaWVsZHNldCcpLFxuICBmaWdjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdmaWdjYXB0aW9uJyksXG4gIGZpZ3VyZTogY3JlYXRlRE9NRmFjdG9yeSgnZmlndXJlJyksXG4gIGZvb3RlcjogY3JlYXRlRE9NRmFjdG9yeSgnZm9vdGVyJyksXG4gIGZvcm06IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvcm0nKSxcbiAgaDE6IGNyZWF0ZURPTUZhY3RvcnkoJ2gxJyksXG4gIGgyOiBjcmVhdGVET01GYWN0b3J5KCdoMicpLFxuICBoMzogY3JlYXRlRE9NRmFjdG9yeSgnaDMnKSxcbiAgaDQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2g0JyksXG4gIGg1OiBjcmVhdGVET01GYWN0b3J5KCdoNScpLFxuICBoNjogY3JlYXRlRE9NRmFjdG9yeSgnaDYnKSxcbiAgaGVhZDogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZCcpLFxuICBoZWFkZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWRlcicpLFxuICBoZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2hncm91cCcpLFxuICBocjogY3JlYXRlRE9NRmFjdG9yeSgnaHInKSxcbiAgaHRtbDogY3JlYXRlRE9NRmFjdG9yeSgnaHRtbCcpLFxuICBpOiBjcmVhdGVET01GYWN0b3J5KCdpJyksXG4gIGlmcmFtZTogY3JlYXRlRE9NRmFjdG9yeSgnaWZyYW1lJyksXG4gIGltZzogY3JlYXRlRE9NRmFjdG9yeSgnaW1nJyksXG4gIGlucHV0OiBjcmVhdGVET01GYWN0b3J5KCdpbnB1dCcpLFxuICBpbnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucycpLFxuICBrYmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2tiZCcpLFxuICBrZXlnZW46IGNyZWF0ZURPTUZhY3RvcnkoJ2tleWdlbicpLFxuICBsYWJlbDogY3JlYXRlRE9NRmFjdG9yeSgnbGFiZWwnKSxcbiAgbGVnZW5kOiBjcmVhdGVET01GYWN0b3J5KCdsZWdlbmQnKSxcbiAgbGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpJyksXG4gIGxpbms6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmsnKSxcbiAgbWFpbjogY3JlYXRlRE9NRmFjdG9yeSgnbWFpbicpLFxuICBtYXA6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcCcpLFxuICBtYXJrOiBjcmVhdGVET01GYWN0b3J5KCdtYXJrJyksXG4gIG1lbnU6IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnUnKSxcbiAgbWVudWl0ZW06IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnVpdGVtJyksXG4gIG1ldGE6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGEnKSxcbiAgbWV0ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGVyJyksXG4gIG5hdjogY3JlYXRlRE9NRmFjdG9yeSgnbmF2JyksXG4gIG5vc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdub3NjcmlwdCcpLFxuICBvYmplY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ29iamVjdCcpLFxuICBvbDogY3JlYXRlRE9NRmFjdG9yeSgnb2wnKSxcbiAgb3B0Z3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGdyb3VwJyksXG4gIG9wdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnb3B0aW9uJyksXG4gIG91dHB1dDogY3JlYXRlRE9NRmFjdG9yeSgnb3V0cHV0JyksXG4gIHA6IGNyZWF0ZURPTUZhY3RvcnkoJ3AnKSxcbiAgcGFyYW06IGNyZWF0ZURPTUZhY3RvcnkoJ3BhcmFtJyksXG4gIHBpY3R1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BpY3R1cmUnKSxcbiAgcHJlOiBjcmVhdGVET01GYWN0b3J5KCdwcmUnKSxcbiAgcHJvZ3Jlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ3Byb2dyZXNzJyksXG4gIHE6IGNyZWF0ZURPTUZhY3RvcnkoJ3EnKSxcbiAgcnA6IGNyZWF0ZURPTUZhY3RvcnkoJ3JwJyksXG4gIHJ0OiBjcmVhdGVET01GYWN0b3J5KCdydCcpLFxuICBydWJ5OiBjcmVhdGVET01GYWN0b3J5KCdydWJ5JyksXG4gIHM6IGNyZWF0ZURPTUZhY3RvcnkoJ3MnKSxcbiAgc2FtcDogY3JlYXRlRE9NRmFjdG9yeSgnc2FtcCcpLFxuICBzY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3NjcmlwdCcpLFxuICBzZWN0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdzZWN0aW9uJyksXG4gIHNlbGVjdDogY3JlYXRlRE9NRmFjdG9yeSgnc2VsZWN0JyksXG4gIHNtYWxsOiBjcmVhdGVET01GYWN0b3J5KCdzbWFsbCcpLFxuICBzb3VyY2U6IGNyZWF0ZURPTUZhY3RvcnkoJ3NvdXJjZScpLFxuICBzcGFuOiBjcmVhdGVET01GYWN0b3J5KCdzcGFuJyksXG4gIHN0cm9uZzogY3JlYXRlRE9NRmFjdG9yeSgnc3Ryb25nJyksXG4gIHN0eWxlOiBjcmVhdGVET01GYWN0b3J5KCdzdHlsZScpLFxuICBzdWI6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1YicpLFxuICBzdW1tYXJ5OiBjcmVhdGVET01GYWN0b3J5KCdzdW1tYXJ5JyksXG4gIHN1cDogY3JlYXRlRE9NRmFjdG9yeSgnc3VwJyksXG4gIHRhYmxlOiBjcmVhdGVET01GYWN0b3J5KCd0YWJsZScpLFxuICB0Ym9keTogY3JlYXRlRE9NRmFjdG9yeSgndGJvZHknKSxcbiAgdGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RkJyksXG4gIHRleHRhcmVhOiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0YXJlYScpLFxuICB0Zm9vdDogY3JlYXRlRE9NRmFjdG9yeSgndGZvb3QnKSxcbiAgdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoJyksXG4gIHRoZWFkOiBjcmVhdGVET01GYWN0b3J5KCd0aGVhZCcpLFxuICB0aW1lOiBjcmVhdGVET01GYWN0b3J5KCd0aW1lJyksXG4gIHRpdGxlOiBjcmVhdGVET01GYWN0b3J5KCd0aXRsZScpLFxuICB0cjogY3JlYXRlRE9NRmFjdG9yeSgndHInKSxcbiAgdHJhY2s6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyYWNrJyksXG4gIHU6IGNyZWF0ZURPTUZhY3RvcnkoJ3UnKSxcbiAgdWw6IGNyZWF0ZURPTUZhY3RvcnkoJ3VsJyksXG4gICd2YXInOiBjcmVhdGVET01GYWN0b3J5KCd2YXInKSxcbiAgdmlkZW86IGNyZWF0ZURPTUZhY3RvcnkoJ3ZpZGVvJyksXG4gIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogY3JlYXRlRE9NRmFjdG9yeSgnY2lyY2xlJyksXG4gIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxuICBkZWZzOiBjcmVhdGVET01GYWN0b3J5KCdkZWZzJyksXG4gIGVsbGlwc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2VsbGlwc2UnKSxcbiAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxuICBpbWFnZTogY3JlYXRlRE9NRmFjdG9yeSgnaW1hZ2UnKSxcbiAgbGluZTogY3JlYXRlRE9NRmFjdG9yeSgnbGluZScpLFxuICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcbiAgbWFzazogY3JlYXRlRE9NRmFjdG9yeSgnbWFzaycpLFxuICBwYXRoOiBjcmVhdGVET01GYWN0b3J5KCdwYXRoJyksXG4gIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcbiAgcG9seWdvbjogY3JlYXRlRE9NRmFjdG9yeSgncG9seWdvbicpLFxuICBwb2x5bGluZTogY3JlYXRlRE9NRmFjdG9yeSgncG9seWxpbmUnKSxcbiAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXG4gIHJlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3JlY3QnKSxcbiAgc3RvcDogY3JlYXRlRE9NRmFjdG9yeSgnc3RvcCcpLFxuICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxuICB0ZXh0OiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0JyksXG4gIHRzcGFuOiBjcmVhdGVET01GYWN0b3J5KCd0c3BhbicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmVhdHVyZUZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIHVzZUNyZWF0ZUVsZW1lbnQ6IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JRE9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudEluc3QsIHVwZGF0ZXMpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHBhcmVudEluc3QpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyhub2RlLCB1cGRhdGVzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlucHV0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWRMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCA6IHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cbnZhciBSZWFjdERPTUlucHV0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcblxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxuICAgICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAuc3RlcCBiZWZvcmUgLnZhbHVlIChzZXR0aW5nIC52YWx1ZSBiZWZvcmUgLnN0ZXBcbiAgICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgICAgc3RlcDogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAubWluICYgLm1heCBiZWZvcmUgLnZhbHVlICh0byBlbnN1cmUgcHJvcGVyIG9yZGVyXG4gICAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgfSwgRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wcyhpbnN0LCBwcm9wcyksIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcblxuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBpbnB1dGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZExpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWRMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYGNoZWNrZWRMaW5rYCBwcm9wIG9uIGBpbnB1dGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNoZWNrZWRMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKCFpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU2hvdWxkbid0IHRoaXMgYmUgZ2V0Q2hlY2tlZChwcm9wcyk/XG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblxuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG5cbiAgICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgICAvLyBzdWJtaXQgb3IgcmVzZXQgaW5wdXRzIGFzIHRob3NlIHZhbHVlcyAmIGRlZmF1bHRWYWx1ZXMgYXJlIGxpbmtlZC4gVGhleVxuICAgIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAgIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAgIC8vIHByb3ZpZGVkLlxuXG4gICAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgY2FzZSAndGltZSc6XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgbm8tc2hvdyBpc3N1ZSBvbiBpT1MgU2FmYXJpIGFuZCBBbmRyb2lkIENocm9tZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUuZGVmYXVsdFZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gICAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAgIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gICAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9ICcnO1xuICAgIH1cbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICAvLyBIZXJlIHdlIHVzZSBhc2FwIHRvIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaFxuICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcblxuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlckluc3RhbmNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSBzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkwJykgOiB2b2lkIDA7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUgIT09ICdpbnB1dCcgJiYgZWxlbWVudC50eXBlICE9PSAndGV4dGFyZWEnICYmIGVsZW1lbnQudHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQucHJvcHMgIT0gbnVsbCAmJiBlbGVtZW50LnByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgdGhlIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcblxuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICB9XG59XG5cbnZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NT3B0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICBSZWFjdENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbikge1xuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcblxuICAgICAgaWYgKHNlbGVjdFBhcmVudC5fdGFnID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBob3N0UHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCA9IHJlcXVpcmUoJy4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCcpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxuICpcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cbiAqIGJlaGF2ZSBhcyB0aG91Z2ggaXQncyBhbHdheXMgZm9yd2FyZC5cbiAqXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcbiAqIGJsb2NrIGVsZW1lbnRzIGVuZCB3aXRoIGEgbmV3IGxpbmUuIFRoaXMgbWVhbnMgY2hhcmFjdGVyIG9mZnNldHMgd2lsbFxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRJRU9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZFJhbmdlLnRleHQubGVuZ3RoO1xuXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cbiAgdmFyIGZyb21TdGFydCA9IHNlbGVjdGVkUmFuZ2UuZHVwbGljYXRlKCk7XG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcbiAgICBlbmQ6IGVuZE9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgdmFyIGN1cnJlbnRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gIC8vIEluIEZpcmVmb3gsIHJhbmdlLnN0YXJ0Q29udGFpbmVyIGFuZCByYW5nZS5lbmRDb250YWluZXIgY2FuIGJlIFwiYW5vbnltb3VzXG4gIC8vIGRpdnNcIiwgZS5nLiB0aGUgdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXNcbiAgLy8gZGl2cyBkbyBub3Qgc2VlbSB0byBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcbiAgLy8gZXJyb3JcIiBpZiBhbnkgb2YgaXRzIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGVcbiAgLy8gd2F5IHRvIGF2b2lkIGVycm9yaW5nIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvclxuICAvLyBub24tYW5vbnltb3VzIGRpdnMgYW5kIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGU7XG4gICAgY3VycmVudFJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiB0aGUgbm9kZSBhbmQgb2Zmc2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLlxuICAvLyBgU2VsZWN0aW9uLmlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgbmF0aXZlbHksIGJ1dCBJRSBzb21ldGltZXMgZ2V0c1xuICAvLyB0aGlzIHZhbHVlIHdyb25nLlxuICB2YXIgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSBpc0NvbGxhcHNlZChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTtcblxuICB2YXIgcmFuZ2VMZW5ndGggPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCA/IDAgOiBjdXJyZW50UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG5cbiAgdmFyIHRlbXBSYW5nZSA9IGN1cnJlbnRSYW5nZS5jbG9uZVJhbmdlKCk7XG4gIHRlbXBSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gIHRlbXBSYW5nZS5zZXRFbmQoY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjdXJyZW50UmFuZ2Uuc3RhcnRPZmZzZXQpO1xuXG4gIHZhciBpc1RlbXBSYW5nZUNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHRlbXBSYW5nZS5zdGFydENvbnRhaW5lciwgdGVtcFJhbmdlLnN0YXJ0T2Zmc2V0LCB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLCB0ZW1wUmFuZ2UuZW5kT2Zmc2V0KTtcblxuICB2YXIgc3RhcnQgPSBpc1RlbXBSYW5nZUNvbGxhcHNlZCA/IDAgOiB0ZW1wUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xuXG4gIC8vIERldGVjdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmQuXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIGRldGVjdGlvblJhbmdlLnNldEVuZChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcbiAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgaWYgKG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLmVuZDtcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgfVxuXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCByYW5nZSk7XG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgcmFuZ2Uuc2VsZWN0KCk7XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKCcjdGV4dCcsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB2YXIgb3BlbmluZ1ZhbHVlID0gJyByZWFjdC10ZXh0OiAnICsgZG9tSUQgKyAnICc7XG4gICAgdmFyIGNsb3NpbmdWYWx1ZSA9ICcgL3JlYWN0LXRleHQgJztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG9wZW5pbmdWYWx1ZSk7XG4gICAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY2xvc2luZ1ZhbHVlKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG9wZW5pbmdDb21tZW50KSk7XG4gICAgICBpZiAodGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX3N0cmluZ1RleHQpKSk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShjbG9zaW5nQ29tbWVudCkpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBvcGVuaW5nQ29tbWVudCk7XG4gICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IGNsb3NpbmdDb21tZW50O1xuICAgICAgcmV0dXJuIGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgZm9yIHRoZSByZWFzb25zIHN0YXRlZFxuICAgICAgICAvLyBhYm92ZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyXG4gICAgICAgIC8vIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzwhLS0nICsgb3BlbmluZ1ZhbHVlICsgJy0tPicgKyBlc2NhcGVkVGV4dCArICc8IS0tJyArIGNsb3NpbmdWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlcyA9IHRoaXMuZ2V0SG9zdE5vZGUoKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3ROb2RlID0gdGhpcy5fY29tbWVudE5vZGVzO1xuICAgIGlmIChob3N0Tm9kZSkge1xuICAgICAgcmV0dXJuIGhvc3ROb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nsb3NpbmdDb21tZW50KSB7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogX3Byb2RJbnZhcmlhbnQoJzY3JywgdGhpcy5fZG9tSUQpIDogdm9pZCAwO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyAvcmVhY3QtdGV4dCAnKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBob3N0Tm9kZSA9IFt0aGlzLl9ob3N0Tm9kZSwgdGhpcy5fY2xvc2luZ0NvbW1lbnRdO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IGhvc3ROb2RlO1xuICAgIHJldHVybiBob3N0Tm9kZTtcbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0YXJlYVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRGlzYWJsZWRJbnB1dFV0aWxzID0gcmVxdWlyZSgnLi9EaXNhYmxlZElucHV0VXRpbHMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MScpIDogdm9pZCAwO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitCZW4gc2VlbWVkIHRvIGxpa2UgdGhpcyBzb2x1dGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wcyhpbnN0LCBwcm9wcyksIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiAnJyArIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGB0ZXh0YXJlYWAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MicpIDogdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnOTMnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gV2FybmluZzogbm9kZS52YWx1ZSBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50IChJRTExKSBpZiBwbGFjZWhvbGRlciBpcyBzZXQuXG4gICAgbm9kZS52YWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7IC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzXG4gKiogbW9kdWxlIGlkID0gMjI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UcmVlVHJhdmVyc2FsXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCBmYWxzZSwgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sIHRydWUsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKGZyb20gJiYgZnJvbSAhPT0gY29tbW9uKSB7XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZnJvbS5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0byAmJiB0byAhPT0gY29tbW9uKSB7XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gdG8uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCB0cnVlLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgZmFsc2UsIGFyZ1RvKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBbmNlc3RvcjogaXNBbmNlc3RvcixcbiAgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3I6IGdldExvd2VzdENvbW1vbkFuY2VzdG9yLFxuICBnZXRQYXJlbnRJbnN0YW5jZTogZ2V0UGFyZW50SW5zdGFuY2UsXG4gIHRyYXZlcnNlVHdvUGhhc2U6IHRyYXZlcnNlVHdvUGhhc2UsXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogdHJhdmVyc2VFbnRlckxlYXZlXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZSxcblxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgdmFsdWVMaW5rOiB0cnVlLFxuICAgIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICAgIGNoZWNrZWRMaW5rOiB0cnVlLFxuICAgIGlubmVySFRNTDogdHJ1ZSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgb25Gb2N1c0luOiB0cnVlLFxuICAgIG9uRm9jdXNPdXQ6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBpZiAoc3RhbmRhcmROYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ3Vlc3Mgd2hpY2ggcHJvcCB0aGUgdXNlciBpbnRlbmRlZC5cbiAgICAgIC8vIEl0IGlzIGxpa2VseSB0aGF0IHRoZSB1c2VyIHdhcyBqdXN0IGJsaW5kbHkgc3ByZWFkaW5nL2ZvcndhcmRpbmcgcHJvcHNcbiAgICAgIC8vIENvbXBvbmVudHMgc2hvdWxkIGJlIGNhcmVmdWwgdG8gb25seSByZW5kZXIgdmFsaWQgcHJvcHMvYXR0cmlidXRlcy5cbiAgICAgIC8vIFdhcm5pbmcgd2lsbCBiZSBpbnZva2VkIGluIHdhcm5Vbmtub3duUHJvcGVydGllcyB0byBhbGxvdyBncm91cGluZy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3AgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGlzIHByb3AgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoZXNlIHByb3BzIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXMoZGVidWdJRCwgZWxlbWVudCk7XG59XG5cbnZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDIyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVidWdUb29sXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vaycpO1xudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0gcmVxdWlyZSgnLi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaycpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gbnVsbDtcbnZhciBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xudmFyIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG5cbnZhciBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjbGVhckhpc3RvcnkoKSB7XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sucHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzKCk7XG4gIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmNsZWFySGlzdG9yeSgpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcykge1xuICByZXR1cm4gcmVnaXN0ZXJlZElEcy5yZWR1Y2UoZnVuY3Rpb24gKHRyZWUsIGlkKSB7XG4gICAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICAgIHZhciBwYXJlbnRJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgIHRyZWVbaWRdID0ge1xuICAgICAgZGlzcGxheU5hbWU6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpLFxuICAgICAgdGV4dDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRUZXh0KGlkKSxcbiAgICAgIHVwZGF0ZUNvdW50OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFVwZGF0ZUNvdW50KGlkKSxcbiAgICAgIGNoaWxkSURzOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldENoaWxkSURzKGlkKSxcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBvd25lcnMgYnV0IHRoaXMgaXMgY2xvc2UgZW5vdWdoLlxuICAgICAgb3duZXJJRDogb3duZXJJRCB8fCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQocGFyZW50SUQpLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgfHwgW107XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBudWxsO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IG51bGw7XG4gICAgY2xlYXJIaXN0b3J5KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzTWVhc3VyZW1lbnRzLmxlbmd0aCB8fCBwcmV2aW91c09wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgdmFyIHJlZ2lzdGVyZWRJRHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFJlZ2lzdGVyZWRJRHMoKTtcbiAgICBmbHVzaEhpc3RvcnkucHVzaCh7XG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIHByZXZpb3VzU3RhcnRUaW1lLFxuICAgICAgbWVhc3VyZW1lbnRzOiBwcmV2aW91c01lYXN1cmVtZW50cyB8fCBbXSxcbiAgICAgIG9wZXJhdGlvbnM6IHByZXZpb3VzT3BlcmF0aW9ucyB8fCBbXSxcbiAgICAgIHRyZWVTbmFwc2hvdDogZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpXG4gICAgfSk7XG4gIH1cblxuICBjbGVhckhpc3RvcnkoKTtcbiAgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGVidWdJRChkZWJ1Z0lEKSB7XG4gIHZhciBhbGxvd1Jvb3QgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBudWxsO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IG51bGw7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKTtcblxuICB2YXIgc3RhcnRUaW1lID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLnN0YXJ0VGltZTtcbiAgdmFyIG5lc3RlZEZsdXNoU3RhcnRUaW1lID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLm5lc3RlZEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgZGVidWdJRCA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5kZWJ1Z0lEO1xuICB2YXIgdGltZXJUeXBlID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLnRpbWVyVHlwZTtcblxuICB2YXIgbmVzdGVkRmx1c2hEdXJhdGlvbiA9IHBlcmZvcm1hbmNlTm93KCkgLSBuZXN0ZWRGbHVzaFN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uICs9IG5lc3RlZEZsdXNoRHVyYXRpb247XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG52YXIgUmVhY3REZWJ1Z1Rvb2wgPSB7XG4gIGFkZEhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9va3MucHVzaChob29rKTtcbiAgfSxcbiAgcmVtb3ZlSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaG9va3NbaV0gPT09IGhvb2spIHtcbiAgICAgICAgaG9va3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1Byb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1Byb2ZpbGluZztcbiAgfSxcbiAgYmVnaW5Qcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgZmx1c2hIaXN0b3J5Lmxlbmd0aCA9IDA7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZW5kUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZ2V0Rmx1c2hIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZsdXNoSGlzdG9yeTtcbiAgfSxcbiAgb25CZWdpbkZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZysrO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5GbHVzaCcpO1xuICB9LFxuICBvbkVuZEZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nLS07XG4gICAgcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZEZsdXNoJyk7XG4gIH0sXG4gIG9uQmVnaW5MaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5MaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVuZExpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZExpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25FcnJvcjogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBpZiAoY3VycmVudFRpbWVyRGVidWdJRCAhPSBudWxsKSB7XG4gICAgICBlbmRMaWZlQ3ljbGVUaW1lcihjdXJyZW50VGltZXJEZWJ1Z0lELCBjdXJyZW50VGltZXJUeXBlKTtcbiAgICB9XG4gICAgZW1pdEV2ZW50KCdvbkVycm9yJywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChkZWJ1Z0lELCB0eXBlLCBwYXlsb2FkKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25Ib3N0T3BlcmF0aW9uJywgZGVidWdJRCwgdHlwZSwgcGF5bG9hZCk7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uU2V0U3RhdGUnKTtcbiAgfSxcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hpbGREZWJ1Z0lEcy5mb3JFYWNoKGNoZWNrRGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblNldENoaWxkcmVuJywgZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoZWNrRGVidWdJRChwYXJlbnREZWJ1Z0lELCB0cnVlKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbk1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblRlc3RFdmVudDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25UZXN0RXZlbnQnKTtcbiAgfVxufTtcblxuLy8gVE9ETyByZW1vdmUgdGhlc2Ugd2hlbiBSTi93d3cgZ2V0cyB1cGRhdGVkXG5SZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vaztcblJlYWN0RGVidWdUb29sLnJlbW92ZURldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rO1xuXG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENvbXBvbmVudFRyZWVIb29rKTtcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2spO1xudmFyIHVybCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcbmlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICBSZWFjdERlYnVnVG9vbC5iZWdpblByb2ZpbGluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVidWdUb29sO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlYnVnVG9vbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuX2Fzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQmVmb3JlSW5wdXRFdmVudFBsdWdpbicpO1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9DaGFuZ2VFdmVudFBsdWdpbicpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZSgnLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlcicpO1xudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJyk7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NRW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRyZWVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL1JlYWN0RE9NVHJlZVRyYXZlcnNhbCcpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbicpO1xudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9TVkdET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TZWxlY3RFdmVudFBsdWdpbicpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TaW1wbGVFdmVudFBsdWdpbicpO1xuXG52YXIgYWxyZWFkeUluamVjdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgaWYgKGFscmVhZHlJbmplY3RlZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHRydWUgYmVjYXVzZSB0aGVzZSBpbmplY3Rpb25zIGFyZSBzaGFyZWQgYmV0d2VlblxuICAgIC8vIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgcGFja2FnZS4gVGhleSBzaG91bGQgYmUgYnVpbHQgaW5kZXBlbmRlbnRseVxuICAgIC8vIGFuZCBub3Qgc2hhcmUgYW55IGluamVjdGlvbiBzdGF0ZS4gVGhlbiB0aGlzIHByb2JsZW0gd2lsbCBiZSBzb2x2ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGFscmVhZHlJbmplY3RlZCA9IHRydWU7XG5cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihSZWFjdEV2ZW50TGlzdGVuZXIpO1xuXG4gIC8qKlxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RUcmVlVHJhdmVyc2FsKFJlYWN0RE9NVHJlZVRyYXZlcnNhbCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyhSZWFjdERPTUNvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5KGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RET01FbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZSk7XG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICovXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzXG4gKiogbW9kdWxlIGlkID0gMjMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudExpc3RlbmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24nKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QuX2hvc3RQYXJlbnQpIHtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3ROb2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuX2Fzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvcExldmVsVHlwZSA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgfVxufSk7XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGFuY2VzdG9yICYmIGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbiAgfSxcblxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gaGFuZGxlIEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhpc3RvcnkgPSBbXTtcblxudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0ge1xuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChkZWJ1Z0lELCB0eXBlLCBwYXlsb2FkKSB7XG4gICAgaGlzdG9yeS5wdXNoKHtcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgIH0pO1xuICB9LFxuICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suX3ByZXZlbnRDbGVhcmluZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGlzdG9yeSA9IFtdO1xuICB9LFxuICBnZXRIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzXG4gKiogbW9kdWxlIGlkID0gMjMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgQ2xhc3M6IFJlYWN0Q2xhc3MuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luVXRpbHM6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIEhvc3RDb21wb25lbnQ6IFJlYWN0SG9zdENvbXBvbmVudC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5qZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1hcmt1cENoZWNrc3VtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG52YXIgQ09NTUVOVF9TVEFSVCA9IC9ePFxcIVxcLVxcLS87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MsIGNvbW1lbnRzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICBpZiAoQ09NTUVOVF9TVEFSVC50ZXN0KG1hcmt1cCkpIHtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzXG4gKiogbW9kdWxlIGlkID0gMjM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBjaGlsZC5fbW91bnRJbmRleCxcbiAgICBmcm9tTm9kZTogUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKGNoaWxkKSxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlNFVF9NQVJLVVAsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVGV4dENvbnRlbnQodGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVCxcbiAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBQdXNoIGFuIHVwZGF0ZSwgaWYgYW55LCBvbnRvIHRoZSBxdWV1ZS4gQ3JlYXRlcyBhIG5ldyBxdWV1ZSBpZiBub25lIGlzXG4gKiBwYXNzZWQgYW5kIGFsd2F5cyByZXR1cm5zIHRoZSBxdWV1ZS4gTXV0YXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWUocXVldWUsIHVwZGF0ZSkge1xuICBpZiAodXBkYXRlKSB7XG4gICAgcXVldWUgPSBxdWV1ZSB8fCBbXTtcbiAgICBxdWV1ZS5wdXNoKHVwZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoaW5zdCwgdXBkYXRlUXVldWUpIHtcbiAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzKGluc3QsIHVwZGF0ZVF1ZXVlKTtcbn1cblxudmFyIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBnZXREZWJ1Z0lEID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgICBpZiAoIWluc3QuX2RlYnVnSUQpIHtcbiAgICAgIC8vIENoZWNrIGZvciBBUlQtbGlrZSBpbnN0YW5jZXMuIFRPRE86IFRoaXMgaXMgc2lsbHkvZ3Jvc3MuXG4gICAgICB2YXIgaW50ZXJuYWw7XG4gICAgICBpZiAoaW50ZXJuYWwgPSBSZWFjdEluc3RhbmNlTWFwLmdldChpbnN0KSkge1xuICAgICAgICBpbnN0ID0gaW50ZXJuYWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0Ll9kZWJ1Z0lEO1xuICB9O1xuICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIHZhciBkZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAvLyBUT0RPOiBSZWFjdCBOYXRpdmUgZW1wdHkgY29tcG9uZW50cyBhcmUgYWxzbyBtdWx0aWNoaWxkLlxuICAgIC8vIFRoaXMgbWVhbnMgdGhleSBzdGlsbCBnZXQgaW50byB0aGlzIG1ldGhvZCBidXQgZG9uJ3QgaGF2ZSBfZGVidWdJRC5cbiAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGRyZW4gPyBPYmplY3Qua2V5cyhjaGlsZHJlbikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2tleV0uX2RlYnVnSUQ7XG4gICAgICB9KSA6IFtdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVhY3RNdWx0aUNoaWxkIGFyZSBjYXBhYmxlIG9mIHJlY29uY2lsaW5nIG11bHRpcGxlIGNoaWxkcmVuLlxuICpcbiAqIEBjbGFzcyBSZWFjdE11bHRpQ2hpbGRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkID0ge1xuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBmb3IgY29tcG9uZW50cyB0aGF0IG11c3QgcmVjb25jaWxlIG11bHRpcGxlXG4gICAqIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgYnkgYFJlYWN0RE9NQ29tcG9uZW50YCB0byBtb3VudCwgdXBkYXRlLCBhbmRcbiAgICogdW5tb3VudCBjaGlsZCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAbGVuZHMge1JlYWN0TXVsdGlDaGlsZC5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIF9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbjtcbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlVGV4dENvbnRlbnQobmV4dENvbnRlbnQpXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlU2V0TWFya3VwKG5leHRNYXJrdXApXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAvLyBIb29rIHVzZWQgYnkgUmVhY3QgQVJUXG4gICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IHt9O1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBudWxsO1xuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgLy8gYG5leHRNb3VudEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBuZXdseSBtb3VudGVkIGNoaWxkLlxuICAgICAgdmFyIG5leHRNb3VudEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0UGxhY2VkTm9kZSA9IG51bGw7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgbGFzdEluZGV4KSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgLy8gVGhlIGByZW1vdmVkTm9kZXNgIGxvb3AgYmVsb3cgd2lsbCBhY3R1YWxseSByZW1vdmUgdGhlIGNoaWxkLlxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl9tb3VudENoaWxkQXRJbmRleChuZXh0Q2hpbGQsIG1vdW50SW1hZ2VzW25leHRNb3VudEluZGV4XSwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpKTtcbiAgICAgICAgICBuZXh0TW91bnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICBsYXN0UGxhY2VkTm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShuZXh0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHJlbW92ZWROb2Rlcykge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSwgcmVtb3ZlZE5vZGVzW25hbWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuIEl0IGRvZXMgbm90IGFjdHVhbGx5IHBlcmZvcm0gYW55XG4gICAgICogYmFja2VuZCBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKSB7XG4gICAgICByZXR1cm4gbWFrZUluc2VydE1hcmt1cChtb3VudEltYWdlLCBhZnRlck5vZGUsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgcmV0dXJuIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlLCBhZnRlck5vZGUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHZhciB1cGRhdGUgPSB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkLCBub2RlKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGU7XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0T3duZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAgICogQGZpbmFsXG4gICAqL1xuICBpc1ZhbGlkT3duZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzExOScpIDogdm9pZCAwO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSByZW1vdmluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTIwJykgOiB2b2lkIDA7XG4gICAgdmFyIG93bmVyUHVibGljSW5zdGFuY2UgPSBvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAncyBvd25lciBpcyBzdGlsbCBhbGl2ZSBhbmQgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWZcbiAgICAvLyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lclB1YmxpY0luc3RhbmNlICYmIG93bmVyUHVibGljSW5zdGFuY2UucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RPd25lcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RPd25lci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHVyZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBSZWFjdENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHVyZUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcbiAgICogcGFzc2VkIHRvIGByb2xsYmFja2AsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlc2V0IHRvIHRoYXQgc3RhdGUuXG4gICAqL1xuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVhY3RNb3VudFJlYWR5IGlzIHRoZSBvdXIgb25seSBzdGF0ZWZ1bCB3cmFwcGVyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGF0dGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cblJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMgPSBmdW5jdGlvbiAocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcbiAgLy8gaGFzIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFuZCB0aGUgcHJldmlvdXMgb3duZXIgKGlmIGRpZmZlcmVudClcbiAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBlbGVtZW50IGluc3RlYWRcbiAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXG4gIC8vIGEgcmVmLiBUaGUgcmVmIGNvbmNlcHR1YWxseSBsaXZlcyBvbiB0aGUgZWxlbWVudC5cblxuICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXG4gIC8vIGl0J3MgZm9yYmlkZGVuIGJ5IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LiBUaGUgcmVmIGNhbiBjaGFuZ2VcbiAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXG4gIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcbiAgLy8gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCBpcyBkb25lLlxuXG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG5cbiAgcmV0dXJuIChcbiAgICAvLyBUaGlzIGhhcyBhIGZldyBmYWxzZSBwb3NpdGl2ZXMgdy9yL3QgZW1wdHkgY29tcG9uZW50cy5cbiAgICBwcmV2RW1wdHkgfHwgbmV4dEVtcHR5IHx8IG5leHRFbGVtZW50LnJlZiAhPT0gcHJldkVsZW1lbnQucmVmIHx8XG4gICAgLy8gSWYgb3duZXIgY2hhbmdlcyBidXQgd2UgaGF2ZSBhbiB1bmNoYW5nZWQgZnVuY3Rpb24gcmVmLCBkb24ndCB1cGRhdGUgcmVmc1xuICAgIHR5cGVvZiBuZXh0RWxlbWVudC5yZWYgPT09ICdzdHJpbmcnICYmIG5leHRFbGVtZW50Ll9vd25lciAhPT0gcHJldkVsZW1lbnQuX293bmVyXG4gICk7XG59O1xuXG5SZWFjdFJlZi5kZXRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyVXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG52YXIgbm9vcENhbGxiYWNrUXVldWUgPSB7XG4gIGVucXVldWU6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbmV3IFJlYWN0U2VydmVyVXBkYXRlUXVldWUodGhpcyk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm9vcENhbGxiYWNrUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge30sXG5cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge30sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5fYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgdXBkYXRlIHF1ZXVlIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKiBJdCBkZWxlZ2F0ZXMgdG8gUmVhY3RVcGRhdGVRdWV1ZSB3aGlsZSBzZXJ2ZXIgcmVuZGVyaW5nIGlzIGluIHByb2dyZXNzIGFuZFxuICogc3dpdGNoZXMgdG8gUmVhY3ROb29wVXBkYXRlUXVldWUgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqL1xuXG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyogOjogdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uOyAqL1xuXG4gIGZ1bmN0aW9uIFJlYWN0U2VydmVyVXBkYXRlUXVldWUodHJhbnNhY3Rpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVDYWxsYmFjayA9IGZ1bmN0aW9uIGVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVGb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVNldFN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNWR0RPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbi8vIFdlIHVzZSBhdHRyaWJ1dGVzIGZvciBldmVyeXRoaW5nIFNWRyBzbyBsZXQncyBhdm9pZCBzb21lIGR1cGxpY2F0aW9uIGFuZCBydW5cbi8vIGNvZGUgaW5zdGVhZC5cbi8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbCBzcGVjaWZpZWQgaW4gdGhlIEhUTUwgY29uZmlnIGFscmVhZHkgc28gd2UgZXhjbHVkZSBoZXJlLlxuLy8gLSBjbGFzcyAoYXMgY2xhc3NOYW1lKVxuLy8gLSBjb2xvclxuLy8gLSBoZWlnaHRcbi8vIC0gaWRcbi8vIC0gbGFuZ1xuLy8gLSBtYXhcbi8vIC0gbWVkaWFcbi8vIC0gbWV0aG9kXG4vLyAtIG1pblxuLy8gLSBuYW1lXG4vLyAtIHN0eWxlXG4vLyAtIHRhcmdldFxuLy8gLSB0eXBlXG4vLyAtIHdpZHRoXG52YXIgQVRUUlMgPSB7XG4gIGFjY2VudEhlaWdodDogJ2FjY2VudC1oZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAwLFxuICBhZGRpdGl2ZTogMCxcbiAgYWxpZ25tZW50QmFzZWxpbmU6ICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICBhbGxvd1Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAwLFxuICBhbXBsaXR1ZGU6IDAsXG4gIGFyYWJpY0Zvcm06ICdhcmFiaWMtZm9ybScsXG4gIGFzY2VudDogMCxcbiAgYXR0cmlidXRlTmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGVUeXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAwLFxuICBiYXNlRnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VQcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYXNlbGluZVNoaWZ0OiAnYmFzZWxpbmUtc2hpZnQnLFxuICBiYm94OiAwLFxuICBiZWdpbjogMCxcbiAgYmlhczogMCxcbiAgYnk6IDAsXG4gIGNhbGNNb2RlOiAnY2FsY01vZGUnLFxuICBjYXBIZWlnaHQ6ICdjYXAtaGVpZ2h0JyxcbiAgY2xpcDogMCxcbiAgY2xpcFBhdGg6ICdjbGlwLXBhdGgnLFxuICBjbGlwUnVsZTogJ2NsaXAtcnVsZScsXG4gIGNsaXBQYXRoVW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uOiAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnM6ICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLFxuICBjb2xvclByb2ZpbGU6ICdjb2xvci1wcm9maWxlJyxcbiAgY29sb3JSZW5kZXJpbmc6ICdjb2xvci1yZW5kZXJpbmcnLFxuICBjb250ZW50U2NyaXB0VHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudFN0eWxlVHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6IDAsXG4gIGN4OiAwLFxuICBjeTogMCxcbiAgZDogMCxcbiAgZGVjZWxlcmF0ZTogMCxcbiAgZGVzY2VudDogMCxcbiAgZGlmZnVzZUNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAwLFxuICBkaXNwbGF5OiAwLFxuICBkaXZpc29yOiAwLFxuICBkb21pbmFudEJhc2VsaW5lOiAnZG9taW5hbnQtYmFzZWxpbmUnLFxuICBkdXI6IDAsXG4gIGR4OiAwLFxuICBkeTogMCxcbiAgZWRnZU1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogMCxcbiAgZW5hYmxlQmFja2dyb3VuZDogJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcbiAgZW5kOiAwLFxuICBleHBvbmVudDogMCxcbiAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAwLFxuICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gIGZpbGxSdWxlOiAnZmlsbC1ydWxlJyxcbiAgZmlsdGVyOiAwLFxuICBmaWx0ZXJSZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJVbml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RDb2xvcjogJ2Zsb29kLWNvbG9yJyxcbiAgZmxvb2RPcGFjaXR5OiAnZmxvb2Qtb3BhY2l0eScsXG4gIGZvY3VzYWJsZTogMCxcbiAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICBmb250U2l6ZUFkanVzdDogJ2ZvbnQtc2l6ZS1hZGp1c3QnLFxuICBmb250U3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXG4gIGZvbnRTdHlsZTogJ2ZvbnQtc3R5bGUnLFxuICBmb250VmFyaWFudDogJ2ZvbnQtdmFyaWFudCcsXG4gIGZvbnRXZWlnaHQ6ICdmb250LXdlaWdodCcsXG4gIGZvcm1hdDogMCxcbiAgZnJvbTogMCxcbiAgZng6IDAsXG4gIGZ5OiAwLFxuICBnMTogMCxcbiAgZzI6IDAsXG4gIGdseXBoTmFtZTogJ2dseXBoLW5hbWUnLFxuICBnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbDogJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLFxuICBnbHlwaE9yaWVudGF0aW9uVmVydGljYWw6ICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXG4gIGdseXBoUmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudFRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAwLFxuICBob3JpekFkdlg6ICdob3Jpei1hZHYteCcsXG4gIGhvcml6T3JpZ2luWDogJ2hvcml6LW9yaWdpbi14JyxcbiAgaWRlb2dyYXBoaWM6IDAsXG4gIGltYWdlUmVuZGVyaW5nOiAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2luJzogMCxcbiAgaW4yOiAwLFxuICBpbnRlcmNlcHQ6IDAsXG4gIGs6IDAsXG4gIGsxOiAwLFxuICBrMjogMCxcbiAgazM6IDAsXG4gIGs0OiAwLFxuICBrZXJuZWxNYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWxVbml0TGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6IDAsXG4gIGtleVBvaW50czogJ2tleVBvaW50cycsXG4gIGtleVNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5VGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aEFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlclNwYWNpbmc6ICdsZXR0ZXItc3BhY2luZycsXG4gIGxpZ2h0aW5nQ29sb3I6ICdsaWdodGluZy1jb2xvcicsXG4gIGxpbWl0aW5nQ29uZUFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogMCxcbiAgbWFya2VyRW5kOiAnbWFya2VyLWVuZCcsXG4gIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gIG1hcmtlckhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlclVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJXaWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogMCxcbiAgbWFza0NvbnRlbnRVbml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrVW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6IDAsXG4gIG1vZGU6IDAsXG4gIG51bU9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAwLFxuICBvcGFjaXR5OiAwLFxuICBvcGVyYXRvcjogMCxcbiAgb3JkZXI6IDAsXG4gIG9yaWVudDogMCxcbiAgb3JpZW50YXRpb246IDAsXG4gIG9yaWdpbjogMCxcbiAgb3ZlcmZsb3c6IDAsXG4gIG92ZXJsaW5lUG9zaXRpb246ICdvdmVybGluZS1wb3NpdGlvbicsXG4gIG92ZXJsaW5lVGhpY2tuZXNzOiAnb3ZlcmxpbmUtdGhpY2tuZXNzJyxcbiAgcGFpbnRPcmRlcjogJ3BhaW50LW9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZS0xJyxcbiAgcGF0aExlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm5UcmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlckV2ZW50czogJ3BvaW50ZXItZXZlbnRzJyxcbiAgcG9pbnRzOiAwLFxuICBwb2ludHNBdFg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNBdFk6ICdwb2ludHNBdFknLFxuICBwb2ludHNBdFo6ICdwb2ludHNBdFonLFxuICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlQXNwZWN0UmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZlVW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHI6IDAsXG4gIHJhZGl1czogMCxcbiAgcmVmWDogJ3JlZlgnLFxuICByZWZZOiAncmVmWScsXG4gIHJlbmRlcmluZ0ludGVudDogJ3JlbmRlcmluZy1pbnRlbnQnLFxuICByZXBlYXRDb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0RHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRFeHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRGZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXN0YXJ0OiAwLFxuICByZXN1bHQ6IDAsXG4gIHJvdGF0ZTogMCxcbiAgcng6IDAsXG4gIHJ5OiAwLFxuICBzY2FsZTogMCxcbiAgc2VlZDogMCxcbiAgc2hhcGVSZW5kZXJpbmc6ICdzaGFwZS1yZW5kZXJpbmcnLFxuICBzbG9wZTogMCxcbiAgc3BhY2luZzogMCxcbiAgc3BlY3VsYXJDb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhckV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAwLFxuICBzcHJlYWRNZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydE9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkRGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6IDAsXG4gIHN0ZW12OiAwLFxuICBzdGl0Y2hUaWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gIHN0b3BPcGFjaXR5OiAnc3RvcC1vcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaFBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2hUaGlja25lc3M6ICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsXG4gIHN0cmluZzogMCxcbiAgc3Ryb2tlOiAwLFxuICBzdHJva2VEYXNoYXJyYXk6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgc3Ryb2tlRGFzaG9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdzdHJva2UtbGluZWpvaW4nLFxuICBzdHJva2VNaXRlcmxpbWl0OiAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gIHN1cmZhY2VTY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbUxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZVZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0WDogJ3RhcmdldFgnLFxuICB0YXJnZXRZOiAndGFyZ2V0WScsXG4gIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXG4gIHRleHREZWNvcmF0aW9uOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgdGV4dFJlbmRlcmluZzogJ3RleHQtcmVuZGVyaW5nJyxcbiAgdGV4dExlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0bzogMCxcbiAgdHJhbnNmb3JtOiAwLFxuICB1MTogMCxcbiAgdTI6IDAsXG4gIHVuZGVybGluZVBvc2l0aW9uOiAndW5kZXJsaW5lLXBvc2l0aW9uJyxcbiAgdW5kZXJsaW5lVGhpY2tuZXNzOiAndW5kZXJsaW5lLXRoaWNrbmVzcycsXG4gIHVuaWNvZGU6IDAsXG4gIHVuaWNvZGVCaWRpOiAndW5pY29kZS1iaWRpJyxcbiAgdW5pY29kZVJhbmdlOiAndW5pY29kZS1yYW5nZScsXG4gIHVuaXRzUGVyRW06ICd1bml0cy1wZXItZW0nLFxuICB2QWxwaGFiZXRpYzogJ3YtYWxwaGFiZXRpYycsXG4gIHZIYW5naW5nOiAndi1oYW5naW5nJyxcbiAgdklkZW9ncmFwaGljOiAndi1pZGVvZ3JhcGhpYycsXG4gIHZNYXRoZW1hdGljYWw6ICd2LW1hdGhlbWF0aWNhbCcsXG4gIHZhbHVlczogMCxcbiAgdmVjdG9yRWZmZWN0OiAndmVjdG9yLWVmZmVjdCcsXG4gIHZlcnNpb246IDAsXG4gIHZlcnRBZHZZOiAndmVydC1hZHYteScsXG4gIHZlcnRPcmlnaW5YOiAndmVydC1vcmlnaW4teCcsXG4gIHZlcnRPcmlnaW5ZOiAndmVydC1vcmlnaW4teScsXG4gIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgdmlld1RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAwLFxuICB3aWR0aHM6IDAsXG4gIHdvcmRTcGFjaW5nOiAnd29yZC1zcGFjaW5nJyxcbiAgd3JpdGluZ01vZGU6ICd3cml0aW5nLW1vZGUnLFxuICB4OiAwLFxuICB4SGVpZ2h0OiAneC1oZWlnaHQnLFxuICB4MTogMCxcbiAgeDI6IDAsXG4gIHhDaGFubmVsU2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGxpbmtBY3R1YXRlOiAneGxpbms6YWN0dWF0ZScsXG4gIHhsaW5rQXJjcm9sZTogJ3hsaW5rOmFyY3JvbGUnLFxuICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgeGxpbmtSb2xlOiAneGxpbms6cm9sZScsXG4gIHhsaW5rU2hvdzogJ3hsaW5rOnNob3cnLFxuICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICB4bGlua1R5cGU6ICd4bGluazp0eXBlJyxcbiAgeG1sQmFzZTogJ3htbDpiYXNlJyxcbiAgeG1sbnM6IDAsXG4gIHhtbG5zWGxpbms6ICd4bWxuczp4bGluaycsXG4gIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gIHhtbFNwYWNlOiAneG1sOnNwYWNlJyxcbiAgeTogMCxcbiAgeTE6IDAsXG4gIHkyOiAwLFxuICB5Q2hhbm5lbFNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6IDAsXG4gIHpvb21BbmRQYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7fSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge31cbn07XG5cbk9iamVjdC5rZXlzKEFUVFJTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1trZXldID0gMDtcbiAgaWYgKEFUVFJTW2tleV0pIHtcbiAgICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1trZXldID0gQVRUUlNba2V5XTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VsZWN0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWxlY3RDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnUsIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcbnZhciBPTl9TRUxFQ1RfS0VZID0ga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZTpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9TRUxFQ1RfS0VZKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNpbXBsZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQW5pbWF0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNXaGVlbEV2ZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGFib3J0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25BYm9ydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQWJvcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQW5pbWF0aW9uRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uSXRlcmF0aW9uOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25BbmltYXRpb25JdGVyYXRpb246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkl0ZXJhdGlvbkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25BbmltYXRpb25TdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQW5pbWF0aW9uU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBibHVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CbHVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CbHVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2FuUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXlUaHJvdWdoOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2hDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29udGV4dE1lbnU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvcHk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvcHk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvcHlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkN1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZG91YmxlQ2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VudGVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRW50ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbnRlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFeGl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRXhpdDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0V4aXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnTGVhdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ092ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdPdmVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcm9wOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ecm9wOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ecm9wQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHVyYXRpb25DaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVtcHRpZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVtcHRpZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVtcHRpZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmNyeXB0ZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVuY3J5cHRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5jcnlwdGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5kZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVuZGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVycm9yOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FcnJvcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRXJyb3JDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBmb2N1czoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRm9jdXM6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkZvY3VzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbklucHV0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25JbnB1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGludmFsaWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkludmFsaWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkludmFsaWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVByZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlQcmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5VXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkRGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgLy8gTm90ZTogV2UgZG8gbm90IGFsbG93IGxpc3RlbmluZyB0byBtb3VzZU92ZXIgZXZlbnRzLiBJbnN0ZWFkLCB1c2UgdGhlXG4gIC8vIG9uTW91c2VFbnRlci9vbk1vdXNlTGVhdmUgY3JlYXRlZCBieSBgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luYC5cbiAgbW91c2VEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlVXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGFzdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhc3RlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhdXNlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXVzZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblByb2dyZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Qcm9ncmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmVzZXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJlc2V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TY3JvbGw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNjcm9sbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2VkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVrZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVraW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVraW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVraW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3RhbGxlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3RhbGxlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VibWl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdWJtaXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdXNwZW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdXNwZW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdXNwZW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0cmFuc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25UcmFuc2l0aW9uRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25UcmFuc2l0aW9uRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdm9sdW1lQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Wb2x1bWVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdhaXRpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbldhaXRpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbldhaXRpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB3aGVlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2hlZWw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbldoZWVsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxufTtcblxudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAgdG9wQWJvcnQ6IGV2ZW50VHlwZXMuYWJvcnQsXG4gIHRvcEFuaW1hdGlvbkVuZDogZXZlbnRUeXBlcy5hbmltYXRpb25FbmQsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZXZlbnRUeXBlcy5hbmltYXRpb25JdGVyYXRpb24sXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBldmVudFR5cGVzLmFuaW1hdGlvblN0YXJ0LFxuICB0b3BCbHVyOiBldmVudFR5cGVzLmJsdXIsXG4gIHRvcENhblBsYXk6IGV2ZW50VHlwZXMuY2FuUGxheSxcbiAgdG9wQ2FuUGxheVRocm91Z2g6IGV2ZW50VHlwZXMuY2FuUGxheVRocm91Z2gsXG4gIHRvcENsaWNrOiBldmVudFR5cGVzLmNsaWNrLFxuICB0b3BDb250ZXh0TWVudTogZXZlbnRUeXBlcy5jb250ZXh0TWVudSxcbiAgdG9wQ29weTogZXZlbnRUeXBlcy5jb3B5LFxuICB0b3BDdXQ6IGV2ZW50VHlwZXMuY3V0LFxuICB0b3BEb3VibGVDbGljazogZXZlbnRUeXBlcy5kb3VibGVDbGljayxcbiAgdG9wRHJhZzogZXZlbnRUeXBlcy5kcmFnLFxuICB0b3BEcmFnRW5kOiBldmVudFR5cGVzLmRyYWdFbmQsXG4gIHRvcERyYWdFbnRlcjogZXZlbnRUeXBlcy5kcmFnRW50ZXIsXG4gIHRvcERyYWdFeGl0OiBldmVudFR5cGVzLmRyYWdFeGl0LFxuICB0b3BEcmFnTGVhdmU6IGV2ZW50VHlwZXMuZHJhZ0xlYXZlLFxuICB0b3BEcmFnT3ZlcjogZXZlbnRUeXBlcy5kcmFnT3ZlcixcbiAgdG9wRHJhZ1N0YXJ0OiBldmVudFR5cGVzLmRyYWdTdGFydCxcbiAgdG9wRHJvcDogZXZlbnRUeXBlcy5kcm9wLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogZXZlbnRUeXBlcy5kdXJhdGlvbkNoYW5nZSxcbiAgdG9wRW1wdGllZDogZXZlbnRUeXBlcy5lbXB0aWVkLFxuICB0b3BFbmNyeXB0ZWQ6IGV2ZW50VHlwZXMuZW5jcnlwdGVkLFxuICB0b3BFbmRlZDogZXZlbnRUeXBlcy5lbmRlZCxcbiAgdG9wRXJyb3I6IGV2ZW50VHlwZXMuZXJyb3IsXG4gIHRvcEZvY3VzOiBldmVudFR5cGVzLmZvY3VzLFxuICB0b3BJbnB1dDogZXZlbnRUeXBlcy5pbnB1dCxcbiAgdG9wSW52YWxpZDogZXZlbnRUeXBlcy5pbnZhbGlkLFxuICB0b3BLZXlEb3duOiBldmVudFR5cGVzLmtleURvd24sXG4gIHRvcEtleVByZXNzOiBldmVudFR5cGVzLmtleVByZXNzLFxuICB0b3BLZXlVcDogZXZlbnRUeXBlcy5rZXlVcCxcbiAgdG9wTG9hZDogZXZlbnRUeXBlcy5sb2FkLFxuICB0b3BMb2FkZWREYXRhOiBldmVudFR5cGVzLmxvYWRlZERhdGEsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBldmVudFR5cGVzLmxvYWRlZE1ldGFkYXRhLFxuICB0b3BMb2FkU3RhcnQ6IGV2ZW50VHlwZXMubG9hZFN0YXJ0LFxuICB0b3BNb3VzZURvd246IGV2ZW50VHlwZXMubW91c2VEb3duLFxuICB0b3BNb3VzZU1vdmU6IGV2ZW50VHlwZXMubW91c2VNb3ZlLFxuICB0b3BNb3VzZU91dDogZXZlbnRUeXBlcy5tb3VzZU91dCxcbiAgdG9wTW91c2VPdmVyOiBldmVudFR5cGVzLm1vdXNlT3ZlcixcbiAgdG9wTW91c2VVcDogZXZlbnRUeXBlcy5tb3VzZVVwLFxuICB0b3BQYXN0ZTogZXZlbnRUeXBlcy5wYXN0ZSxcbiAgdG9wUGF1c2U6IGV2ZW50VHlwZXMucGF1c2UsXG4gIHRvcFBsYXk6IGV2ZW50VHlwZXMucGxheSxcbiAgdG9wUGxheWluZzogZXZlbnRUeXBlcy5wbGF5aW5nLFxuICB0b3BQcm9ncmVzczogZXZlbnRUeXBlcy5wcm9ncmVzcyxcbiAgdG9wUmF0ZUNoYW5nZTogZXZlbnRUeXBlcy5yYXRlQ2hhbmdlLFxuICB0b3BSZXNldDogZXZlbnRUeXBlcy5yZXNldCxcbiAgdG9wU2Nyb2xsOiBldmVudFR5cGVzLnNjcm9sbCxcbiAgdG9wU2Vla2VkOiBldmVudFR5cGVzLnNlZWtlZCxcbiAgdG9wU2Vla2luZzogZXZlbnRUeXBlcy5zZWVraW5nLFxuICB0b3BTdGFsbGVkOiBldmVudFR5cGVzLnN0YWxsZWQsXG4gIHRvcFN1Ym1pdDogZXZlbnRUeXBlcy5zdWJtaXQsXG4gIHRvcFN1c3BlbmQ6IGV2ZW50VHlwZXMuc3VzcGVuZCxcbiAgdG9wVGltZVVwZGF0ZTogZXZlbnRUeXBlcy50aW1lVXBkYXRlLFxuICB0b3BUb3VjaENhbmNlbDogZXZlbnRUeXBlcy50b3VjaENhbmNlbCxcbiAgdG9wVG91Y2hFbmQ6IGV2ZW50VHlwZXMudG91Y2hFbmQsXG4gIHRvcFRvdWNoTW92ZTogZXZlbnRUeXBlcy50b3VjaE1vdmUsXG4gIHRvcFRvdWNoU3RhcnQ6IGV2ZW50VHlwZXMudG91Y2hTdGFydCxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZXZlbnRUeXBlcy50cmFuc2l0aW9uRW5kLFxuICB0b3BWb2x1bWVDaGFuZ2U6IGV2ZW50VHlwZXMudm9sdW1lQ2hhbmdlLFxuICB0b3BXYWl0aW5nOiBldmVudFR5cGVzLndhaXRpbmcsXG4gIHRvcFdoZWVsOiBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZykge1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdHlwZV0uZGVwZW5kZW5jaWVzID0gW3R5cGVdO1xufVxuXG52YXIgT05fQ0xJQ0tfS0VZID0ga2V5T2YoeyBvbkNsaWNrOiBudWxsIH0pO1xudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGljdGlvbmFyeUtleShpbnN0KSB7XG4gIC8vIFByZXZlbnRzIFY4IHBlcmZvcm1hbmNlIGlzc3VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHJldHVybiAnLicgKyBpbnN0Ll9yb290Tm9kZUlEO1xufVxuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBYm9ydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDYW5QbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXlUaHJvdWdoOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcER1cmF0aW9uQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVtcHRpZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5jcnlwdGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVuZGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVycm9yOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcElucHV0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEludmFsaWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWREYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZE1ldGFkYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXVzZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXlpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUHJvZ3Jlc3M6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmF0ZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSZXNldDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVrZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2luZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdGFsbGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdXNwZW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRpbWVVcGRhdGU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVm9sdW1lQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdhaXRpbmc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBbmltYXRpb25FbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQW5pbWF0aW9uSXRlcmF0aW9uOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFuaW1hdGlvblN0YXJ0OlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRyYW5zaXRpb25FbmQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29weTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICFFdmVudENvbnN0cnVjdG9yID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzg2JywgdG9wTGV2ZWxUeXBlKSA6IHZvaWQgMDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAgIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICBpZiAoIW9uQ2xpY2tMaXN0ZW5lcnNba2V5XSkge1xuICAgICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgb25DbGlja0xpc3RlbmVyc1trZXldLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNBbmltYXRpb25FdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNEcmFnRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRm9jdXNFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RvdWNoRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljV2hlZWxFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWRsZXIzMlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIGFkbGVyMzIgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgYW5kIGlzIG9ubHkgdXNlZCB0byBzYW5pdHkgY2hlY2sgdGhhdFxuLy8gbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIG1hdGNoZXMgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gKGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgU2hlZXRKUyB2ZXJzaW9uKSBoYXMgYmVlbiBvcHRpbWl6ZWRcbi8vIGZvciBvdXIgdXNlIGNhc2UsIGF0IHRoZSBleHBlbnNlIG9mIGNvbmZvcm1pbmcgdG8gdGhlIGFkbGVyMzIgc3BlY2lmaWNhdGlvblxuLy8gZm9yIG5vbi1hc2NpaSBpbnB1dHMuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgdmFyIG0gPSBsICYgfjB4MztcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgdmFyIG4gPSBNYXRoLm1pbihpICsgNDA5NiwgbSk7XG4gICAgZm9yICg7IGkgPCBuOyBpICs9IDQpIHtcbiAgICAgIGIgKz0gKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICB9XG4gICAgYSAlPSBNT0Q7XG4gICAgYiAlPSBNT0Q7XG4gIH1cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBiICs9IGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIGEgJT0gTU9EO1xuICBiICU9IE1PRDtcbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2FkbGVyMzIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkYW5nZXJvdXNTdHlsZVZhbHVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xudmFyIHN0eWxlV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmaW5kRE9NTm9kZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLmZpbmRkb21ub2RlXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudHxET01FbGVtZW50fSBjb21wb25lbnRPckVsZW1lbnRcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB2YXIgaW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgIHJldHVybiBpbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkgOiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0NCcpIDogdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZSAoa2V5czogJXMpJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBfcHJvZEludmFyaWFudCgnNDUnLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9maW5kRE9NTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZsYXR0ZW5DaGlsZHJlblxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2VsZkRlYnVnSUQgT3B0aW9uYWwgZGVidWdJRCBvZiB0aGUgY3VycmVudCBpbnRlcm5hbCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIGlmICh0cmF2ZXJzZUNvbnRleHQgJiYgdHlwZW9mIHRyYXZlcnNlQ29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICAgIHZhciBrZXlVbmlxdWUgPSByZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbiwgc2VsZkRlYnVnSUQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgICAgIHJldHVybiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzXG4gKiogbW9kdWxlIGlkID0gMjYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRLZXlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgJ0VzYyc6ICdFc2NhcGUnLFxuICAnU3BhY2ViYXInOiAnICcsXG4gICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICdVcCc6ICdBcnJvd1VwJyxcbiAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAnRGVsJzogJ0RlbGV0ZScsXG4gICdXaW4nOiAnT1MnLFxuICAnTWVudSc6ICdDb250ZXh0TWVudScsXG4gICdBcHBzJzogJ0NvbnRleHRNZW51JyxcbiAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgJ01velByaW50YWJsZUtleSc6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzXG4gKiogbW9kdWxlIGlkID0gMjYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9vbmx5Q2hpbGQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQucmVuZGVyU3VidHJlZUludG9Db250YWluZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jYW1lbGl6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlcnMgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3RcbiAgLy8gaW4gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2Ygb2JqLmNhbGxlZSAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IGNhblxcJ3QgYmUgYGFyZ3VtZW50c2AuIFVzZSByZXN0IHBhcmFtcyAnICsgJyhmdW5jdGlvbiguLi5hcmdzKSB7fSkgb3IgQXJyYXkuZnJvbSgpIGluc3RlYWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuIChcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmIChcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICAgIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXG4gICAgLy8gbm8gRE9NIG5vZGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gYXJyYXktbGlrZVxuICAgIC8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIC8vIGFyZ3VtZW50c1xuICAgICdjYWxsZWUnIGluIG9iaiB8fFxuICAgIC8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0XG4gICAgJ2l0ZW0nIGluIG9iailcbiAgKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgYnkgd3JhcHBpbmcgaXQgaW4gYW4gYXJyYXkgaWYgaXQgaXMgbm90LlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXG4gKlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGlkaW9tYXRpY2FsbHk6XG4gKlxuICogICB2YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb21NaXhlZCcpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQodGhpbmdzKTtcbiAqICAgICAuLi5cbiAqICAgfVxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmVhdCBgdGhpbmdzJyBhcyBhbiBhcnJheSwgYnV0IGFjY2VwdCBzY2FsYXJzIGluIHRoZSBBUEkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCwgbGlrZSBgYXJndW1lbnRzYCwgaW50byBhbiBhcnJheVxuICogdXNlIHRvQXJyYXkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1peGVkKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb21NaXhlZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMjcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCAqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgY2Fubm90IHVzZSBgaW5uZXJIVE1MYCB0byByZW5kZXIgY2VydGFpbiBlbGVtZW50cyBzdGFuZGFsb25lLFxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxuICpcbiAqIEluIElFOCwgY2VydGFpbiBlbGVtZW50cyBjYW5ub3QgcmVuZGVyIGFsb25lLCBzbyB3cmFwIGFsbCBlbGVtZW50cyAoJyonKS5cbiAqL1xuXG52YXIgc2hvdWxkV3JhcCA9IHt9O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLCAnPC9zdmc+J107XG5cbnZhciBtYXJrdXBXcmFwID0ge1xuICAnKic6IFsxLCAnPzxkaXY+JywgJzwvZGl2PiddLFxuXG4gICdhcmVhJzogWzEsICc8bWFwPicsICc8L21hcD4nXSxcbiAgJ2NvbCc6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gICdwYXJhbSc6IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICd0cic6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuXG4gICdvcHRncm91cCc6IHNlbGVjdFdyYXAsXG4gICdvcHRpb24nOiBzZWxlY3RXcmFwLFxuXG4gICdjYXB0aW9uJzogdGFibGVXcmFwLFxuICAnY29sZ3JvdXAnOiB0YWJsZVdyYXAsXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcbiAgJ3Rmb290JzogdGFibGVXcmFwLFxuICAndGhlYWQnOiB0YWJsZVdyYXAsXG5cbiAgJ3RkJzogdHJXcmFwLFxuICAndGgnOiB0cldyYXBcbn07XG5cbi8vIEluaXRpYWxpemUgdGhlIFNWRyBlbGVtZW50cyBzaW5jZSB3ZSBrbm93IHRoZXknbGwgYWx3YXlzIG5lZWQgdG8gYmUgd3JhcHBlZFxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxuLy8gdGhlIHdyb25nIG5hbWVzcGFjZSAoYW5kIHdpbGwgbm90IGRpc3BsYXkpLlxudmFyIHN2Z0VsZW1lbnRzID0gWydjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICd0ZXh0JywgJ3RzcGFuJ107XG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICBtYXJrdXBXcmFwW25vZGVOYW1lXSA9IHN2Z1dyYXA7XG4gIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZXMgYXJlIHVuYm91bmRlZCwgdW5saWtlIGBnZXRTY3JvbGxQb3NpdGlvbmAuIFRoaXMgbWVhbnMgdGhleVxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xuICogaW5lcnRpYWwgc2Nyb2xsaW5nKS5cbiAqXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcCB3aXRoIGB4YCBhbmQgYHlgIGtleXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9oeXBoZW5hdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gMjc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2lzTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaXNUZXh0Tm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKCcuL3BlcmZvcm1hbmNlJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdztcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmIChwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanNcbiAqKiBtb2R1bGUgaWQgPSAyODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH1cblxudmFyIHJlcGVhdCA9IGZ1bmN0aW9uIHJlcGVhdChzdHIsIHRpbWVzKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodGltZXMgKyAxKS5qb2luKHN0cik7XG59O1xudmFyIHBhZCA9IGZ1bmN0aW9uIHBhZChudW0sIG1heExlbmd0aCkge1xuICByZXR1cm4gcmVwZWF0KFwiMFwiLCBtYXhMZW5ndGggLSBudW0udG9TdHJpbmcoKS5sZW5ndGgpICsgbnVtO1xufTtcbnZhciBmb3JtYXRUaW1lID0gZnVuY3Rpb24gZm9ybWF0VGltZSh0aW1lKSB7XG4gIHJldHVybiBcIkAgXCIgKyBwYWQodGltZS5nZXRIb3VycygpLCAyKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0TWludXRlcygpLCAyKSArIFwiOlwiICsgcGFkKHRpbWUuZ2V0U2Vjb25kcygpLCAyKSArIFwiLlwiICsgcGFkKHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpO1xufTtcblxuLy8gVXNlIHRoZSBuZXcgcGVyZm9ybWFuY2UgYXBpIHRvIGdldCBiZXR0ZXIgcHJlY2lzaW9uIGlmIGF2YWlsYWJsZVxudmFyIHRpbWVyID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09IFwiZnVuY3Rpb25cIiA/IHBlcmZvcm1hbmNlIDogRGF0ZTtcblxuLyoqXG4gKiBwYXJzZSB0aGUgbGV2ZWwgb3B0aW9uIG9mIGNyZWF0ZUxvZ2dlclxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgZnVuY3Rpb24gfCBvYmplY3R9IGxldmVsIC0gY29uc29sZVtsZXZlbF1cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7YXJyYXl9IHBheWxvYWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXG4gKi9cblxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWwobGV2ZWwsIGFjdGlvbiwgcGF5bG9hZCwgdHlwZSkge1xuICBzd2l0Y2ggKHR5cGVvZiBsZXZlbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGxldmVsKSkge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiB0eXBlb2YgbGV2ZWxbdHlwZV0gPT09IFwiZnVuY3Rpb25cIiA/IGxldmVsW3R5cGVdLmFwcGx5KGxldmVsLCBfdG9Db25zdW1hYmxlQXJyYXkocGF5bG9hZCkpIDogbGV2ZWxbdHlwZV07XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICByZXR1cm4gbGV2ZWwoYWN0aW9uKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBsb2dnZXIgd2l0aCBmb2xsb3dlZCBvcHRpb25zXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtvYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciBsb2dnZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgZnVuY3Rpb24gfCBvYmplY3R9IG9wdGlvbnMubGV2ZWwgLSBjb25zb2xlW2xldmVsXVxuICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLmR1cmF0aW9uIC0gcHJpbnQgZHVyYXRpb24gb2YgZWFjaCBhY3Rpb24/XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMudGltZXN0YW1wIC0gcHJpbnQgdGltZXN0YW1wIHdpdGggZWFjaCBhY3Rpb24/XG4gKiBAcHJvcGVydHkge29iamVjdH0gb3B0aW9ucy5jb2xvcnMgLSBjdXN0b20gY29sb3JzXG4gKiBAcHJvcGVydHkge29iamVjdH0gb3B0aW9ucy5sb2dnZXIgLSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYGNvbnNvbGVgIEFQSVxuICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLmxvZ0Vycm9ycyAtIHNob3VsZCBlcnJvcnMgaW4gYWN0aW9uIGV4ZWN1dGlvbiBiZSBjYXVnaHQsIGxvZ2dlZCwgYW5kIHJlLXRocm93bj9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy5jb2xsYXBzZWQgLSBpcyBncm91cCBjb2xsYXBzZWQ/XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMucHJlZGljYXRlIC0gY29uZGl0aW9uIHdoaWNoIHJlc29sdmVzIGxvZ2dlciBiZWhhdmlvclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gb3B0aW9ucy5zdGF0ZVRyYW5zZm9ybWVyIC0gdHJhbnNmb3JtIHN0YXRlIGJlZm9yZSBwcmludFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gb3B0aW9ucy5hY3Rpb25UcmFuc2Zvcm1lciAtIHRyYW5zZm9ybSBhY3Rpb24gYmVmb3JlIHByaW50XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvcHRpb25zLmVycm9yVHJhbnNmb3JtZXIgLSB0cmFuc2Zvcm0gZXJyb3IgYmVmb3JlIHByaW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICB2YXIgX29wdGlvbnMkbGV2ZWwgPSBvcHRpb25zLmxldmVsO1xuICB2YXIgbGV2ZWwgPSBfb3B0aW9ucyRsZXZlbCA9PT0gdW5kZWZpbmVkID8gXCJsb2dcIiA6IF9vcHRpb25zJGxldmVsO1xuICB2YXIgX29wdGlvbnMkbG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gIHZhciBsb2dnZXIgPSBfb3B0aW9ucyRsb2dnZXIgPT09IHVuZGVmaW5lZCA/IGNvbnNvbGUgOiBfb3B0aW9ucyRsb2dnZXI7XG4gIHZhciBfb3B0aW9ucyRsb2dFcnJvcnMgPSBvcHRpb25zLmxvZ0Vycm9ycztcbiAgdmFyIGxvZ0Vycm9ycyA9IF9vcHRpb25zJGxvZ0Vycm9ycyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9vcHRpb25zJGxvZ0Vycm9ycztcbiAgdmFyIGNvbGxhcHNlZCA9IG9wdGlvbnMuY29sbGFwc2VkO1xuICB2YXIgcHJlZGljYXRlID0gb3B0aW9ucy5wcmVkaWNhdGU7XG4gIHZhciBfb3B0aW9ucyRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gIHZhciBkdXJhdGlvbiA9IF9vcHRpb25zJGR1cmF0aW9uID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJGR1cmF0aW9uO1xuICB2YXIgX29wdGlvbnMkdGltZXN0YW1wID0gb3B0aW9ucy50aW1lc3RhbXA7XG4gIHZhciB0aW1lc3RhbXAgPSBfb3B0aW9ucyR0aW1lc3RhbXAgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfb3B0aW9ucyR0aW1lc3RhbXA7XG4gIHZhciB0cmFuc2Zvcm1lciA9IG9wdGlvbnMudHJhbnNmb3JtZXI7XG4gIHZhciBfb3B0aW9ucyRzdGF0ZVRyYW5zZm8gPSBvcHRpb25zLnN0YXRlVHJhbnNmb3JtZXI7XG4gIHZhciAvLyBkZXByZWNhdGVkXG4gIHN0YXRlVHJhbnNmb3JtZXIgPSBfb3B0aW9ucyRzdGF0ZVRyYW5zZm8gPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSA6IF9vcHRpb25zJHN0YXRlVHJhbnNmbztcbiAgdmFyIF9vcHRpb25zJGFjdGlvblRyYW5zZiA9IG9wdGlvbnMuYWN0aW9uVHJhbnNmb3JtZXI7XG4gIHZhciBhY3Rpb25UcmFuc2Zvcm1lciA9IF9vcHRpb25zJGFjdGlvblRyYW5zZiA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGFjdG4pIHtcbiAgICByZXR1cm4gYWN0bjtcbiAgfSA6IF9vcHRpb25zJGFjdGlvblRyYW5zZjtcbiAgdmFyIF9vcHRpb25zJGVycm9yVHJhbnNmbyA9IG9wdGlvbnMuZXJyb3JUcmFuc2Zvcm1lcjtcbiAgdmFyIGVycm9yVHJhbnNmb3JtZXIgPSBfb3B0aW9ucyRlcnJvclRyYW5zZm8gPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSA6IF9vcHRpb25zJGVycm9yVHJhbnNmbztcbiAgdmFyIF9vcHRpb25zJGNvbG9ycyA9IG9wdGlvbnMuY29sb3JzO1xuICB2YXIgY29sb3JzID0gX29wdGlvbnMkY29sb3JzID09PSB1bmRlZmluZWQgPyB7XG4gICAgdGl0bGU6IGZ1bmN0aW9uIHRpdGxlKCkge1xuICAgICAgcmV0dXJuIFwiIzAwMDAwMFwiO1xuICAgIH0sXG4gICAgcHJldlN0YXRlOiBmdW5jdGlvbiBwcmV2U3RhdGUoKSB7XG4gICAgICByZXR1cm4gXCIjOUU5RTlFXCI7XG4gICAgfSxcbiAgICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBcIiMwM0E5RjRcIjtcbiAgICB9LFxuICAgIG5leHRTdGF0ZTogZnVuY3Rpb24gbmV4dFN0YXRlKCkge1xuICAgICAgcmV0dXJuIFwiIzRDQUY1MFwiO1xuICAgIH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKCkge1xuICAgICAgcmV0dXJuIFwiI0YyMDQwNFwiO1xuICAgIH1cbiAgfSA6IF9vcHRpb25zJGNvbG9ycztcblxuICAvLyBleGl0IGlmIGNvbnNvbGUgdW5kZWZpbmVkXG5cbiAgaWYgKHR5cGVvZiBsb2dnZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm1lcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJPcHRpb24gJ3RyYW5zZm9ybWVyJyBpcyBkZXByZWNhdGVkLCB1c2Ugc3RhdGVUcmFuc2Zvcm1lciBpbnN0ZWFkXCIpO1xuICB9XG5cbiAgdmFyIGxvZ0J1ZmZlciA9IFtdO1xuICBmdW5jdGlvbiBwcmludEJ1ZmZlcigpIHtcbiAgICBsb2dCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAobG9nRW50cnksIGtleSkge1xuICAgICAgdmFyIHN0YXJ0ZWQgPSBsb2dFbnRyeS5zdGFydGVkO1xuICAgICAgdmFyIHN0YXJ0ZWRUaW1lID0gbG9nRW50cnkuc3RhcnRlZFRpbWU7XG4gICAgICB2YXIgYWN0aW9uID0gbG9nRW50cnkuYWN0aW9uO1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGxvZ0VudHJ5LnByZXZTdGF0ZTtcbiAgICAgIHZhciBlcnJvciA9IGxvZ0VudHJ5LmVycm9yO1xuICAgICAgdmFyIHRvb2sgPSBsb2dFbnRyeS50b29rO1xuICAgICAgdmFyIG5leHRTdGF0ZSA9IGxvZ0VudHJ5Lm5leHRTdGF0ZTtcblxuICAgICAgdmFyIG5leHRFbnRyeSA9IGxvZ0J1ZmZlcltrZXkgKyAxXTtcbiAgICAgIGlmIChuZXh0RW50cnkpIHtcbiAgICAgICAgbmV4dFN0YXRlID0gbmV4dEVudHJ5LnByZXZTdGF0ZTtcbiAgICAgICAgdG9vayA9IG5leHRFbnRyeS5zdGFydGVkIC0gc3RhcnRlZDtcbiAgICAgIH1cbiAgICAgIC8vIG1lc3NhZ2VcbiAgICAgIHZhciBmb3JtYXR0ZWRBY3Rpb24gPSBhY3Rpb25UcmFuc2Zvcm1lcihhY3Rpb24pO1xuICAgICAgdmFyIGlzQ29sbGFwc2VkID0gdHlwZW9mIGNvbGxhcHNlZCA9PT0gXCJmdW5jdGlvblwiID8gY29sbGFwc2VkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgIH0sIGFjdGlvbikgOiBjb2xsYXBzZWQ7XG5cbiAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZm9ybWF0VGltZShzdGFydGVkVGltZSk7XG4gICAgICB2YXIgdGl0bGVDU1MgPSBjb2xvcnMudGl0bGUgPyBcImNvbG9yOiBcIiArIGNvbG9ycy50aXRsZShmb3JtYXR0ZWRBY3Rpb24pICsgXCI7XCIgOiBudWxsO1xuICAgICAgdmFyIHRpdGxlID0gXCJhY3Rpb24gXCIgKyAodGltZXN0YW1wID8gZm9ybWF0dGVkVGltZSA6IFwiXCIpICsgXCIgXCIgKyBmb3JtYXR0ZWRBY3Rpb24udHlwZSArIFwiIFwiICsgKGR1cmF0aW9uID8gXCIoaW4gXCIgKyB0b29rLnRvRml4ZWQoMikgKyBcIiBtcylcIiA6IFwiXCIpO1xuXG4gICAgICAvLyByZW5kZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgICAgIGlmIChjb2xvcnMudGl0bGUpIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIiVjIFwiICsgdGl0bGUsIHRpdGxlQ1NTKTtlbHNlIGxvZ2dlci5ncm91cENvbGxhcHNlZCh0aXRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbG9ycy50aXRsZSkgbG9nZ2VyLmdyb3VwKFwiJWMgXCIgKyB0aXRsZSwgdGl0bGVDU1MpO2Vsc2UgbG9nZ2VyLmdyb3VwKHRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIubG9nKHRpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZTdGF0ZUxldmVsID0gZ2V0TG9nTGV2ZWwobGV2ZWwsIGZvcm1hdHRlZEFjdGlvbiwgW3ByZXZTdGF0ZV0sIFwicHJldlN0YXRlXCIpO1xuICAgICAgdmFyIGFjdGlvbkxldmVsID0gZ2V0TG9nTGV2ZWwobGV2ZWwsIGZvcm1hdHRlZEFjdGlvbiwgW2Zvcm1hdHRlZEFjdGlvbl0sIFwiYWN0aW9uXCIpO1xuICAgICAgdmFyIGVycm9yTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbZXJyb3IsIHByZXZTdGF0ZV0sIFwiZXJyb3JcIik7XG4gICAgICB2YXIgbmV4dFN0YXRlTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbbmV4dFN0YXRlXSwgXCJuZXh0U3RhdGVcIik7XG5cbiAgICAgIGlmIChwcmV2U3RhdGVMZXZlbCkge1xuICAgICAgICBpZiAoY29sb3JzLnByZXZTdGF0ZSkgbG9nZ2VyW3ByZXZTdGF0ZUxldmVsXShcIiVjIHByZXYgc3RhdGVcIiwgXCJjb2xvcjogXCIgKyBjb2xvcnMucHJldlN0YXRlKHByZXZTdGF0ZSkgKyBcIjsgZm9udC13ZWlnaHQ6IGJvbGRcIiwgcHJldlN0YXRlKTtlbHNlIGxvZ2dlcltwcmV2U3RhdGVMZXZlbF0oXCJwcmV2IHN0YXRlXCIsIHByZXZTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3Rpb25MZXZlbCkge1xuICAgICAgICBpZiAoY29sb3JzLmFjdGlvbikgbG9nZ2VyW2FjdGlvbkxldmVsXShcIiVjIGFjdGlvblwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5hY3Rpb24oZm9ybWF0dGVkQWN0aW9uKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBmb3JtYXR0ZWRBY3Rpb24pO2Vsc2UgbG9nZ2VyW2FjdGlvbkxldmVsXShcImFjdGlvblwiLCBmb3JtYXR0ZWRBY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IgJiYgZXJyb3JMZXZlbCkge1xuICAgICAgICBpZiAoY29sb3JzLmVycm9yKSBsb2dnZXJbZXJyb3JMZXZlbF0oXCIlYyBlcnJvclwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5lcnJvcihlcnJvciwgcHJldlN0YXRlKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBlcnJvcik7ZWxzZSBsb2dnZXJbZXJyb3JMZXZlbF0oXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0U3RhdGVMZXZlbCkge1xuICAgICAgICBpZiAoY29sb3JzLm5leHRTdGF0ZSkgbG9nZ2VyW25leHRTdGF0ZUxldmVsXShcIiVjIG5leHQgc3RhdGVcIiwgXCJjb2xvcjogXCIgKyBjb2xvcnMubmV4dFN0YXRlKG5leHRTdGF0ZSkgKyBcIjsgZm9udC13ZWlnaHQ6IGJvbGRcIiwgbmV4dFN0YXRlKTtlbHNlIGxvZ2dlcltuZXh0U3RhdGVMZXZlbF0oXCJuZXh0IHN0YXRlXCIsIG5leHRTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIubG9nKFwi4oCU4oCUIGxvZyBlbmQg4oCU4oCUXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxvZ0J1ZmZlci5sZW5ndGggPSAwO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIC8vIGV4aXQgZWFybHkgaWYgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgZmFsc2VcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgPT09IFwiZnVuY3Rpb25cIiAmJiAhcHJlZGljYXRlKGdldFN0YXRlLCBhY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dFbnRyeSA9IHt9O1xuICAgICAgICBsb2dCdWZmZXIucHVzaChsb2dFbnRyeSk7XG5cbiAgICAgICAgbG9nRW50cnkuc3RhcnRlZCA9IHRpbWVyLm5vdygpO1xuICAgICAgICBsb2dFbnRyeS5zdGFydGVkVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxvZ0VudHJ5LnByZXZTdGF0ZSA9IHN0YXRlVHJhbnNmb3JtZXIoZ2V0U3RhdGUoKSk7XG4gICAgICAgIGxvZ0VudHJ5LmFjdGlvbiA9IGFjdGlvbjtcblxuICAgICAgICB2YXIgcmV0dXJuZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGxvZ0Vycm9ycykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm5lZFZhbHVlID0gbmV4dChhY3Rpb24pO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0VudHJ5LmVycm9yID0gZXJyb3JUcmFuc2Zvcm1lcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuZWRWYWx1ZSA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ0VudHJ5LnRvb2sgPSB0aW1lci5ub3coKSAtIGxvZ0VudHJ5LnN0YXJ0ZWQ7XG4gICAgICAgIGxvZ0VudHJ5Lm5leHRTdGF0ZSA9IHN0YXRlVHJhbnNmb3JtZXIoZ2V0U3RhdGUoKSk7XG5cbiAgICAgICAgcHJpbnRCdWZmZXIoKTtcblxuICAgICAgICBpZiAobG9nRW50cnkuZXJyb3IpIHRocm93IGxvZ0VudHJ5LmVycm9yO1xuICAgICAgICByZXR1cm4gcmV0dXJuZWRWYWx1ZTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVMb2dnZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgtbG9nZ2VyL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBwcm9taXNlTWlkZGxld2FyZTtcblxudmFyIF9pc1Byb21pc2UgPSByZXF1aXJlKCcuL2lzUHJvbWlzZScpO1xuXG52YXIgX2lzUHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1Byb21pc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZGVmYXVsdFR5cGVzID0gWydQRU5ESU5HJywgJ0ZVTEZJTExFRCcsICdSRUpFQ1RFRCddO1xuXG4vKipcbiAqIEBmdW5jdGlvbiBwcm9taXNlTWlkZGxld2FyZVxuICogQGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRodW5rXG4gKi9cbmZ1bmN0aW9uIHByb21pc2VNaWRkbGV3YXJlKCkge1xuICB2YXIgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgdmFyIHByb21pc2VUeXBlU3VmZml4ZXMgPSBjb25maWcucHJvbWlzZVR5cGVTdWZmaXhlcyB8fCBkZWZhdWx0VHlwZXM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSByZWYuZGlzcGF0Y2g7XG5cblxuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKCEoMCwgX2lzUHJvbWlzZTIuZGVmYXVsdCkoYWN0aW9uLnBheWxvYWQpICYmICEoMCwgX2lzUHJvbWlzZTIuZGVmYXVsdCkoYWN0aW9uLnBheWxvYWQucHJvbWlzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNvbnN0cnVjdCB0aGUgcHJvcGVydGllcyBvZiB0aGUgb3JpZ2luYWwgYWN0aW9uIG9iamVjdCB0byBjb25zdGFudHNcbiAgICAgICAgdmFyIHR5cGUgPSBhY3Rpb24udHlwZTtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgdmFyIG1ldGEgPSBhY3Rpb24ubWV0YTtcblxuICAgICAgICAvLyBBc3NpZ24gdmFsdWVzIGZvciBwcm9taXNlIHR5cGUgc3VmZml4ZXNcblxuICAgICAgICB2YXIgX3Byb21pc2VUeXBlU3VmZml4ZXMgPSBfc2xpY2VkVG9BcnJheShwcm9taXNlVHlwZVN1ZmZpeGVzLCAzKTtcblxuICAgICAgICB2YXIgUEVORElORyA9IF9wcm9taXNlVHlwZVN1ZmZpeGVzWzBdO1xuICAgICAgICB2YXIgRlVMRklMTEVEID0gX3Byb21pc2VUeXBlU3VmZml4ZXNbMV07XG4gICAgICAgIHZhciBSRUpFQ1RFRCA9IF9wcm9taXNlVHlwZVN1ZmZpeGVzWzJdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0QWN0aW9uXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHJlamVjdGVkIG9yIGZ1bGZpbGxlZFxuICAgICAgICAgKiBmbHV4IHN0YW5kYXJkIGFjdGlvbiBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gSXMgdGhlIGFjdGlvbiByZWplY3RlZD9cbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gYWN0aW9uXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBnZXRBY3Rpb24gPSBmdW5jdGlvbiBnZXRBY3Rpb24obmV3UGF5bG9hZCwgaXNSZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlICsgJ18nICsgKGlzUmVqZWN0ZWQgPyBSRUpFQ1RFRCA6IEZVTEZJTExFRClcbiAgICAgICAgICB9LCBuZXdQYXlsb2FkID8ge1xuICAgICAgICAgICAgcGF5bG9hZDogbmV3UGF5bG9hZFxuICAgICAgICAgIH0gOiB7fSwgISFtZXRhID8geyBtZXRhOiBtZXRhIH0gOiB7fSwgaXNSZWplY3RlZCA/IHtcbiAgICAgICAgICAgIGVycm9yOiB0cnVlXG4gICAgICAgICAgfSA6IHt9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXNzaWduIHZhbHVlcyBmb3IgcHJvbWlzZSBhbmQgZGF0YSB2YXJpYWJsZXMuIEluIHRoZSBjYXNlIHRoZSBwYXlsb2FkXG4gICAgICAgICAqIGlzIGFuIG9iamVjdCB3aXRoIGEgYHByb21pc2VgIGFuZCBgZGF0YWAgcHJvcGVydHksIHRoZSB2YWx1ZXMgb2YgdGhvc2VcbiAgICAgICAgICogcHJvcGVydGllcyB3aWxsIGJlIHVzZWQuIEluIHRoZSBjYXNlIHRoZSBwYXlsb2FkIGlzIGEgcHJvbWlzZSwgdGhlXG4gICAgICAgICAqIHZhbHVlIG9mIHRoZSBwYXlsb2FkIHdpbGwgYmUgdXNlZCBhbmQgZGF0YSB3aWxsIGJlIG51bGwuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGRhdGEgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKCEoMCwgX2lzUHJvbWlzZTIuZGVmYXVsdCkoYWN0aW9uLnBheWxvYWQpICYmIF90eXBlb2YoYWN0aW9uLnBheWxvYWQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHByb21pc2UgPSBwYXlsb2FkLnByb21pc2U7XG4gICAgICAgICAgZGF0YSA9IHBheWxvYWQuZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9taXNlID0gcGF5bG9hZDtcbiAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJzdCwgZGlzcGF0Y2ggdGhlIHBlbmRpbmcgYWN0aW9uLiBUaGlzIGZsdXggc3RhbmRhcmQgYWN0aW9uIG9iamVjdFxuICAgICAgICAgKiBkZXNjcmliZXMgdGhlIHBlbmRpbmcgc3RhdGUgb2YgYSBwcm9taXNlIGFuZCB3aWxsIGluY2x1ZGUgYW55IGRhdGFcbiAgICAgICAgICogKGZvciBvcHRpbWlzdGljIHVwZGF0ZXMpIGFuZC9vciBtZXRhIGZyb20gdGhlIG9yaWdpbmFsIGFjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIG5leHQoX2V4dGVuZHMoe1xuICAgICAgICAgIHR5cGU6IHR5cGUgKyAnXycgKyBQRU5ESU5HXG4gICAgICAgIH0sICEhZGF0YSA/IHsgcGF5bG9hZDogZGF0YSB9IDoge30sICEhbWV0YSA/IHsgbWV0YTogbWV0YSB9IDoge30pKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBAZnVuY3Rpb24gaGFuZGxlUmVqZWN0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBEaXNwYXRjaCB0aGUgcmVqZWN0ZWQgYWN0aW9uIGFuZCByZXR1cm5cbiAgICAgICAgICogYW4gZXJyb3Igb2JqZWN0LiBUaGUgZXJyb3Igb2JqZWN0IGlzIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAgKiB0aGF0IHdhcyB0aHJvd24uIFRoZSB1c2VyIG9mIHRoZSBsaWJyYXJ5IGlzIHJlc3BvbnNpYmxlIGZvclxuICAgICAgICAgKiBiZXN0IHByYWN0aWNlcyBpbiBlbnN1cmUgdGhhdCB0aGV5IGFyZSB0aHJvd2luZyBhbiBFcnJvciBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbXMgcmVhc29uIFRoZSByZWFzb24gdGhlIHByb21pc2Ugd2FzIHJlamVjdGVkXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaGFuZGxlUmVqZWN0ID0gZnVuY3Rpb24gaGFuZGxlUmVqZWN0KHJlYXNvbikge1xuICAgICAgICAgIHZhciByZWplY3RlZEFjdGlvbiA9IGdldEFjdGlvbihyZWFzb24sIHRydWUpO1xuICAgICAgICAgIGRpc3BhdGNoKHJlamVjdGVkQWN0aW9uKTtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogQGZ1bmN0aW9uIGhhbmRsZUZ1bGZpbGxcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIERpc3BhdGNoIHRoZSBmdWxmaWxsZWQgYWN0aW9uIGFuZFxuICAgICAgICAgKiByZXR1cm4gdGhlIHN1Y2Nlc3Mgb2JqZWN0LiBUaGUgc3VjY2VzcyBvYmplY3Qgc2hvdWxkXG4gICAgICAgICAqIGNvbnRhaW4gdGhlIHZhbHVlIGFuZCB0aGUgZGlzcGF0Y2hlZCBhY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdGhlIHByb21pc2Ugd2FzIHJlc2xvdmVkIHdpdGhcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBoYW5kbGVGdWxmaWxsID0gZnVuY3Rpb24gaGFuZGxlRnVsZmlsbCgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgICAgdmFyIHJlc29sdmVkQWN0aW9uID0gZ2V0QWN0aW9uKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgZGlzcGF0Y2gocmVzb2x2ZWRBY3Rpb24pO1xuXG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBhY3Rpb246IHJlc29sdmVkQWN0aW9uIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlY29uZCwgZGlzcGF0Y2ggYSByZWplY3RlZCBvciBmdWxmaWxsZWQgYWN0aW9uLiBUaGlzIGZsdXggc3RhbmRhcmRcbiAgICAgICAgICogYWN0aW9uIG9iamVjdCB3aWxsIGRlc2NyaWJlIHRoZSByZXNvbHZlZCBzdGF0ZSBvZiB0aGUgcHJvbWlzZS4gSW5cbiAgICAgICAgICogdGhlIGNhc2Ugb2YgYSByZWplY3RlZCBwcm9taXNlLCBpdCB3aWxsIGluY2x1ZGUgYW4gYGVycm9yYCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gb3JkZXIgdG8gYWxsb3cgcHJvcGVyIGNoYWluaW5nIG9mIGFjdGlvbnMgdXNpbmcgYHRoZW5gLCBhIG5ld1xuICAgICAgICAgKiBwcm9taXNlIGlzIGNvbnN0cnVjdGVkIGFuZCByZXR1cm5lZC4gVGhpcyBwcm9taXNlIHdpbGwgcmVzb2x2ZVxuICAgICAgICAgKiB3aXRoIHR3byBwcm9wZXJ0aWVzOiAoMSkgdGhlIHZhbHVlIChpZiBmdWxmaWxsZWQpIG9yIHJlYXNvblxuICAgICAgICAgKiAoaWYgcmVqZWN0ZWQpIGFuZCAoMikgdGhlIGZsdXggc3RhbmRhcmQgYWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZWplY3RlZCBvYmplY3Q6XG4gICAgICAgICAqIHtcbiAgICAgICAgICogICByZWFzb246IC4uLlxuICAgICAgICAgKiAgIGFjdGlvbjoge1xuICAgICAgICAgKiAgICAgZXJyb3I6IHRydWUsXG4gICAgICAgICAqICAgICB0eXBlOiAnQUNUSU9OX1JFSkVDVEVEJyxcbiAgICAgICAgICogICAgIHBheWxvYWQ6IC4uLlxuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBGdWxmaWxsZWQgb2JqZWN0OlxuICAgICAgICAgKiB7XG4gICAgICAgICAqICAgdmFsdWU6IC4uLlxuICAgICAgICAgKiAgIGFjdGlvbjoge1xuICAgICAgICAgKiAgICAgdHlwZTogJ0FDVElPTl9GVUxGSUxMRUQnLFxuICAgICAgICAgKiAgICAgcGF5bG9hZDogLi4uXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGhhbmRsZUZ1bGZpbGwsIGhhbmRsZVJlamVjdCk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgtcHJvbWlzZS1taWRkbGV3YXJlL2Rpc3QvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAyODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgtcHJvbWlzZS1taWRkbGV3YXJlL2Rpc3QvaXNQcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBjcmVhdGVUaHVua01pZGRsZXdhcmUoZXh0cmFBcmd1bWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoO1xuICAgIHZhciBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpO1xudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHRodW5rO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4LXRodW5rL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGFwcGx5TWlkZGxld2FyZTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcik7XG4gICAgICB2YXIgX2Rpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG4gICAgICB2YXIgY2hhaW4gPSBbXTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2goYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBfY29tcG9zZTJbXCJkZWZhdWx0XCJdLmFwcGx5KHVuZGVmaW5lZCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9hcHBseU1pZGRsZXdhcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYmluZEFjdGlvbkNyZWF0b3JzO1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICcgKyAoYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgYWN0aW9uQ3JlYXRvcnMpICsgJy4gJyArICdEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiPycpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhY3Rpb25DcmVhdG9ycyk7XG4gIHZhciBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2JpbmRBY3Rpb25DcmVhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb21iaW5lUmVkdWNlcnM7XG5cbnZhciBfY3JlYXRlU3RvcmUgPSByZXF1aXJlKCcuL2NyZWF0ZVN0b3JlJyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc1BsYWluT2JqZWN0Jyk7XG5cbnZhciBfaXNQbGFpbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc1BsYWluT2JqZWN0KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uTmFtZSA9IGFjdGlvblR5cGUgJiYgJ1wiJyArIGFjdGlvblR5cGUudG9TdHJpbmcoKSArICdcIicgfHwgJ2FuIGFjdGlvbic7XG5cbiAgcmV0dXJuICdHaXZlbiBhY3Rpb24gJyArIGFjdGlvbk5hbWUgKyAnLCByZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQuICcgKyAnVG8gaWdub3JlIGFuIGFjdGlvbiwgeW91IG11c3QgZXhwbGljaXRseSByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLic7XG59XG5cbmZ1bmN0aW9uIGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2UoaW5wdXRTdGF0ZSwgcmVkdWNlcnMsIGFjdGlvbikge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUID8gJ2luaXRpYWxTdGF0ZSBhcmd1bWVudCBwYXNzZWQgdG8gY3JlYXRlU3RvcmUnIDogJ3ByZXZpb3VzIHN0YXRlIHJlY2VpdmVkIGJ5IHRoZSByZWR1Y2VyJztcblxuICBpZiAocmVkdWNlcktleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdTdG9yZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcmVkdWNlci4gTWFrZSBzdXJlIHRoZSBhcmd1bWVudCBwYXNzZWQgJyArICd0byBjb21iaW5lUmVkdWNlcnMgaXMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgcmVkdWNlcnMuJztcbiAgfVxuXG4gIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSk7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNhbml0eShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiAnICsgJ0lmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCAnICsgJ2V4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgJyArICdub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gJ0BAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05fJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHsgdHlwZTogdHlwZSB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlciBcIicgKyBrZXkgKyAnXCIgcmV0dXJuZWQgdW5kZWZpbmVkIHdoZW4gcHJvYmVkIHdpdGggYSByYW5kb20gdHlwZS4gJyArICgnRG9uXFwndCB0cnkgdG8gaGFuZGxlICcgKyBfY3JlYXRlU3RvcmUuQWN0aW9uVHlwZXMuSU5JVCArICcgb3Igb3RoZXIgYWN0aW9ucyBpbiBcInJlZHV4LypcIiAnKSArICduYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSAnICsgJ2N1cnJlbnQgc3RhdGUgZm9yIGFueSB1bmtub3duIGFjdGlvbnMsIHVubGVzcyBpdCBpcyB1bmRlZmluZWQsICcgKyAnaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlICcgKyAnYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuZnVuY3Rpb24gY29tYmluZVJlZHVjZXJzKHJlZHVjZXJzKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGZpbmFsUmVkdWNlcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHZhciBmaW5hbFJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMoZmluYWxSZWR1Y2Vycyk7XG5cbiAgdmFyIHNhbml0eUVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTYW5pdHkoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzYW5pdHlFcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzYW5pdHlFcnJvcikge1xuICAgICAgdGhyb3cgc2FuaXR5RXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbik7XG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2NvbWJpbmVSZWR1Y2Vycy5qc1xuICoqIG1vZHVsZSBpZCA9IDI4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcG9ueWZpbGwnKShnbG9iYWwgfHwgd2luZG93IHx8IHRoaXMpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L3N5bWJvbC1vYnNlcnZhYmxlL3BvbnlmaWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMjkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQkxBRXNBQUQvL2dCa1JtbHNaU0J6YjNWeVkyVTZJR2gwZEhBNkx5OWpiMjF0YjI1ekxuZHBhMmx0WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2tWcGJuTjBaV2x1WHpFNU1qRmZZbmxmUmw5VFkyaHRkWFI2WlhKZkxWOXlaWE4wYjNKaGRHbHZiaTVxY0dmLzJ3QkRBQVlFQlFZRkJBWUdCUVlIQndZSUNoQUtDZ2tKQ2hRT0R3d1FGeFFZR0JjVUZoWWFIU1VmR2hzakhCWVdJQ3dnSXlZbktTb3BHUjh0TUMwb01DVW9LU2ovMndCREFRY0hCd29JQ2hNS0NoTW9HaFlhS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDai93QUFSQ0FFaEFOd0RBU0lBQWhFQkF4RUIvOFFBSEFBQUFRVUJBUUVBQUFBQUFBQUFBQUFBQlFJREJBWUhBQUVJLzhRQVJoQUFBZ0VEQXdFSEFRUUdDQVFGQlFFQUFRSURBQVFSQlJJaE1RWVRJa0ZSWVhHQkJ6S1JvUlFqTTdIQjBSVVdKRUpTY3JMaE5HSnpna05Ua3FMd0NHTmtnN1BDLzhRQUdBRUFBd0VCQUFBQUFBQUFBQUFBQUFBQUFBRUNBd1QveEFBakVRRUJBQUlDQXdFQUFnTUJBQUFBQUFBQUFRSVJBeUVTTVVFVEltRUVNbEdSLzlvQURBTUJBQUlSQXhFQVB3REZKSWQyb1hoOVozL2ZUOHFNa0oySEZPS00zbDBmL3ZQL0FLalhYY2JzaTdPUUR6V0dWN1BIMEVTRm5KWmlTdzlhVENmMXFFOU1pcE40Z2liUFRjTVlxS09NYzlEUkFzMFl5bytLWHQ5cVRiRE1hbXBLcnh6V1N6SVNrbUlFY2o2MUpFZExXT2dhTTJjVGlYQTVHRFUwUWt3ajV6U1lBeXNTdkhGUHVHN3NZUFU1K2FWcHFKcTVKMUNiT090UXVhbWF0L3g4M3pVTURtdG96cmlhOE9jOEd2V0hKcEpwazQrMWVWMWVVQjZhNEhrVjVYVWpPUmpKSXJ3R3VRSHkvS3ZXWGJqZG1tVHpQUEZlZ24xcVZBSXdSZ2NuOHFibkdaVGdZQjZVYk1oZHpjQ3Awa2ZkMnc5L1dvOEk3dVFad2MwWGpqV2FFNVBsU3RFZ2RhVDl5L1BRMFZnY1RKdUdhRUxIK3VaT2hCeFJTMGg3b0VoczU4cUtjUGg4eWdaK2xPWUhxZnhxUElNeXJqZzFKS2RPdElrVlArS3V2K3MvK28xTlJjZytsUTRqL2FMai9yUC9BS2pSdlJZMG0xS3lpa0FLU1RvckQxQllacFowOFZYMVZnMG5HY0R6eFEvSEdlSzFIN1ZFeDIydTQ3TzBDMmNTSWdXSUFET1BTcUhjMjF5T3RzeWgrUmxlYVdPVzRlVTFSZXdHYmRQaXBnU3EzRmNhakNvMkJzZEFDdk5PeDMycEtlY0VEazdrcGVJMnNRVDZVcFV4MW9BbXNYeWN0Q3BYekd3MGh0ZXUwY0FRSjdncWFYalQzRmxWUURTM3lVVWVXVFZZWHRKT1B2UXhmblN2NnpzUUFiWkRqcGhxUENqeWdMcW5OL1A3Tmlvb0ZTcnFXS2VWNVNKRlpqa2dFRVY2SUlDQ1FaeGpIQlVlZGF4Q0djMGtpcHoyMElRczBzb1VIQjhISS9PbTJ0NHQrRm5iSHJzLzNvMkVRMTU2MU9qczFrYkF1RkhxU3A0cjMralpOdVZrUnM4OUNLTmpTQUJYb0ZUVjA2UTV6SkdCVGdzbU1aSGZSQURnNXlLTmpTS0FCZ29hZmVIY2dPZVJTNHJReE1NelF5YnM0Q3NUU0VpTFNoak5IdEhPQy81VUdYYTRVRU90S2FaZHhWZ1BZMUlqQ3lBQkRHV1BBRzhDbzk3QXdabHdCSW5EQUhOSUc3UkQzdVdHUWVob3ZCYm5ZV0J3S0dhZEl1Q0pENThab3AzcEkycHlLVk9JVW9WYmp3L2ZOVFloa0RkVUM0aUluRGRNbWlhSW9YTEhuMHBrYW1LOTRtMDg1cVlDTURKb1JKNGJvL05TdkUzS2s0cDZKNUMyYm01SGwzMG4rbzBmMEp6RnFkbklvQktUSXdCNmNHcTdCbjlKdWY4QXJTZjZqVmcwTWI5UXRoNUZ4MXFlVDZlQzU5b3V6UDhBU0dwM0dvVDNlWkxodHdDZ2dEaXE5SjJVbFU1TTdTRG9BYzFwY2NKYTNJWURhRDRhYWxpVnNCY0FpdVNjbG5Ub3VFclBvdXlzb0taeXU3a0hKNXBWMTJkdUlWSS9TQTJmSlplbFcyNlRGMmhMTmhSanJRUzVRTkpKM2VjWkpCcXBuYVZ4a1ZXNTBTNU1tWGxPTThnUG1rTnBsMnhaVzVBSFVQaitGV1pVM0ErSWdueXB5SzJhV1RhRDFCNjFYblUrS2xUOW43bDFKQXo2WksveXBoK3pVM1VxRGdZd3A1cSt0YXlkMmVDVkRIbjBwNjIwdTh2Yjh4Mk1EU3N2M3RvNFVlcFBRQ24rbEx3WnIvVjJWUXhrUjhCc1ozRHBTcDlDdVZnL1VPMHJ0eWVoeGpwV292b2R0YXlzdXJhdGJ4WVBNVnNETTJmVDBycElPemNCM0MwMUM3TzNCM2tSZy9oUitvL05tRXVneTNCajd1T2NGbHhKdllITGVvOXE5L29TOGhpMncya200SHhNU0NUL0FMVnA5cmU2VkdDa0dnUkZBTVlrblkwV3RiQzB1WGtWdElodGNESllUTndQWDJwWG1zK0hPT1ZpZHRvR290SnRNTGdOeVNSZ0Q4YU9RZG0wdGc0bFlzekRsZ2VNSEdPSzB5ZlRrZzNCVkM3bTJqYzNtQ0NQNDFYdFV1NGJTQkFWVXl2bkNJZlZqNSsvdFIrdHk5RHdrVXFUVFliZDJWUnRjanIxb1hjMmNLT1RPaElQUm8zd0RSMjl1akp1NzNDeWNGc2VFQUUrWEhOUWRVczVFRzhzMjdaZ2dyMXdPbGFTMzZpd0xpUzNzNWU4aU15TVFjZDVnOFk1NHFIYlJXNUJrRWtwNXdQQ0tKZG50VjdpNUZ0SXNUd1NZeHVHZHArdFhpSzJ0cEJHVEJic0dIK0FldldubGw0aVRiTlpOUGRtRFJySnRQbklBS2JRTkEwNHpncWNIM3JXMjA2eFZDWkxPSXFPQVJWRzdlV2tWbmV4ckJFc2FPbWNMNSs5R1BKNVhRdUd1MWVzWkFrcDNESU5HckprSGlicDVDZzFndVNUanBSWU9zYUFFRFBTcXBRM2VneVNvRkhHN3FLbE9vMnJrOUtZTDVJYkFBcHhtN3dIYm41b0NKS0M5emdmRlRVVENnVU9VRVRZenlEVTRsejVrZXdxa21yYy93Qm91UDhBclA4QTZqVmw3TmpPcTJveG54aXEzYURNOCtQL0FEbi9BTlJxMWRrMDNhemE0NXdTZndCcU9UNmVEVTUyN3RVQ2tBZWVLWWhLbTZ6aGdNZEtsWTd5MlRjdTdJNE5OeElnbFk0OHZTdUYxaHQrc2JLKzBNQ09sRE80MlJzd0p5QjVWWkh0VTVPM0pJOGpVT2UwWHVYWVpYYXZRdDE1cHlsWUJRd3JuSlZzbnJUMHNQZzRRN3VlUUtuUnh4cmp4T1BYSW81cFZoYjNUU1QzVC8yQzJUdkp5T0N3endnOTJQRlZjaTBDMk5uREZZUjN1ck0wZG81SmloakdIbndlY2VpKzlkZWFyTGZzOFM3Yld6QkNyYndEQ2daOHoxSithazZqSkxxRnhCTFBoV3poRUhSRUI0VWV3cU1JUUhsWXF1Q3cvZWFXL3dEcGhwczRoSzZna0JXOU90UlpZTUFrdXd4eFJxYU1QNHU3WExjNUZRYjZJRlBER0FPZWhxcFUyR05Kc1d1U3lKSVNXYlprK1dRZWExVHM1MmZPcXlXTm84c2hoamJ2N2w5dkRCUnRSU2VoNXlmT3F2OEFaNXBEWEx5elN3citqSTZzN01jWkE2RFB6KzZ0dTdOMndoczJsSUhlVHNXSUgzUVBJRDIrS2NubGxvVytPSWVleCtsTklaYnEyVzVmYmpkSU9ucWFxZXYvQUdlNkxMdm1FVFJzQWNnTmdIMzl2cFdueURnOU00cXVkbzk2MlVtT09NbmpQMHFzOFpqT2l4eXR2YkJ0YzdQYVJZUlNpR0loaHlEbnFhcDhzU3REZFJUYnBGWHhyem5hRGo2OEdyVDJ6bjJNN0syUjUreHFsdzNrWW5SSlplNzM1UXVCbmc5UisrbGh1ell6MXRVdGIwK1N5bjc2TmdBR3p2R09jOURpcnYyWGwvU3RKdDVkZ0pYd24yT2VsUU5YdDlQdlVNWmRtT0J0YllNcWVPVHo4K3RTZXg0TnBadkFTdUEvSGh5ZmpQU3RNcnZGRW1xUHNSSmxWQUdINkUrVlVUN1JaQTJxUUx0d1Zpd1B4cTZ4emdUQjhjRnY4UHZWTyswYUNTYlcwZU1JeXJDdjNUNW5tbHgvN0huNkJ0R2dEUXRJVzhKYkJBb3REWXd5NUxTZUVET2ZlaG1telBaYWNUM1kzTy9COUttTXpXOFp4SVdFdlBOYTFuRUs1VWxsV051TTFMZ1VwRVFmVHJVS1BCdUR1Ym9jZ1VWblFQQmhmVG1tQVdNa1Q1Nm5QNDFOeXdQQXFFRjJ5bFFlaDYxT1hlUnhWcElzdjIwMlAvTmYvVWF0L1k1QzJ0UTRPUEM1eWZpcWhZZnRaZjhBcVA4QTZqVjU3RUlEckNFai93QU5oMCtLeTVmVlZ4L0doUUlEZHdSZ0VBQWZ1cUlKWEFsSVk3czhaUHZSbTBDdnEwQUNZeG56OUZORFl3Z09DQUFhNG5VZWdNc2thOGsrWEpxQmNOSUxTVjJjRTk0RlZjZGNjbWpGc3E1UmVNWlBOUUxrZ2FleU1xK0tYSUlISTRwUUlZa1lvSE8wREhwUnk4bE5sb2VuMmloZDkwUDAyWWVvUEVZUHdBVDlhRE1qQzNHVkdTcCt0RnUyTndZZGZtaFZlSVVpaEFJQndGUUQrZFVTQXpEdmJZbGNBQTlQbWtOY0lJV0tvTTd1Zyt0S2E1Mi9veXRFdVRHQ2Zlb3l5cTRHSVFNdDB5ZlNrYVpiUnJjQkFWNUM4MUJ2NFFpU0RIUFNpTnZjd3hUc1dRa2JUeHV4aW8ycHRHa2pESndRcllQVVo4alJQWXF3Nk5xampRRFlDSXRDU1hsZU5kem9Ob1VjZko2MWV0TzF5NjA3c2ZhVExhQzVtalR1MkN0Z2NjNUF6azhjNHJMZEhsZFZJZU5XV1JDRDFHMzZqNDZWcDhlald2YUxSckJnWkpiYTNhUXRGRklVNzF5QUFDVDVEcjhnVmVHOTlKeTFyc1MwN3RORmZhRk5xYXg3VWhRdEtwSU8wZ2RLeVhXL3ROMURWN3RyVFJJb0dpa3dBN2o4ZnpxNTZob0E3SC9aenJTV1VFY1VrMFd3SXNqU3NCenl6bkc1dXVUZ1ZtWDJVUlFMTlBickhBWkpZMktTeXg3eU55N1dIWG9SL0dyeXQxMm1hMzBwbmFYVnA3dUNRbVd6dUh6aGpBZnUvU3FacWJ1MW92VldXdHExejdQUDBPOFdRVFdNVm9zVEtrVnVoRzRkUU9SZ2MrMVk5MnhraGp1M2hpem5vMlRrN3ZPdE9PeTlSR2N2dW84Mm9ySkVaa08wa0hjaEhuUTg2amN3WExTV3N6b0d5Tm9QQm9lSFp0cWtsbHo5MDlLZXN1N2l2NHYwbU5wWTFmbEVHUzJPbkZiYTB6MjByU1picVMydEpMdEF0eDFaUU1ET2VQeEZRKzFkdXNsN0c4bVZCT1hJOHhSWFI1b3IwV2t0dXhrUnhsY2pIMDlxRmR0KzRXN1pRemk1VUtkbzZBR3NKL3MwdnBWNUgzUzl6RWpDSU5sV1lkYWR1WUpIaDN1K1ZQVEhsWE9qeVdnbEl4R3AyajFOZXozZHJieHFzWWNram93Nkd0VUJzRU1tUkw1Wnh6MU5HbGNpSXBRcjlLWjBSUkhsUWMwN0Zmc2NxNlp6MHhWV2JJd294S2MrdEVveWR2R0RRNDh5bkl4azBRUmdxNEdhb2ptbFdVMHNjc3lMbE84Ym42bXRQN05XRVZycHB1RnlaY1lCUGwwcXBkanY3UlppR1BraDIzZmlhdmRyQk5id21OdUl5dVFEODF6YzJYZW12SFBxeTZUbDlWalBvckhuL0lhRXhNUXE1OUtMNko0dFNKSnlCRkwvQVB6TkJWQkNyOGV0Y3pjVHRsWmlwVUVrazR4ejVWRHZ4czB0SGY3elNNUVBQSFNuN1pqdUJJa0cwZXRSOWQ0MDZ3Wm1KTG94QXowOFJwVDJkUm1ZbUtESXdPT3YrYW5PMVc2WHRYcW00bkl1SkIvN3FadUFmMFRjdmtwSSthS2F0QjN2YUM0bG1YQ3ppT1lFZWpxR3F0NlNFM2JNTGhBMzkwQk9LYmlJYVlxQXc1SkpIblVtNmpEYWpKak8wUGdmU21iVEt6Rmp5TnBQRkFlSmxESXdVTmpHTWp6cU1aakpmWElkc2t1TWs5YWxrSzhhNDZzNEpvWktWRjNPd3hudk9QZm1uQlZnc3BuTm8zaUlYTzBEUFd0Tyt5UzhFbWxhaEE1d1liamZrLzRXWCthbXNsc3JuZFp3S0ZCYkxNVFY0K3lxOXhxbW8yd1lLbHhDTnVmTjFKUDdpYXJDK09XeXk3eEV2dGk3VExaZGdaWlZzN2wydXdWakhkazRHY2Jqam9NZXZyWHp6OW5XdXZwK3YycGhna2VDUUVUNXp3MmVNZWxhVHJPaGR0dFlsdlpoREpKRER2aUJrbjJkNFY4bEhwejA2Y1ZrR3FhVnJHbGFsSkMxczZNMkF5eHlCK2ZwV2t2bHZhTC9BQjFwclhiZnRFOFVZN2xoc0l5UFlWOC9kcFhaOVZrZHpsbThSOXMxWjdlNzFGTkdrR3B4eUJWbkNRYitUZ2prSDQ0cXI5b28rNzFIazVZcUMxVnhZZUtjOHZKQWgyaFpHWnNNQU52cm1wMmxhUmNha3dhSEt3Z2pmTDVLZlFlcHFGYm9wTE5LSk81VWVJcGpkOU04WnJVdE5zOU9zdEhoR2ozTXQxYU9UTDM4b0N1eElIQkE0QkhUSHRXbWVYaWpISGFWcEVhVzA4RWNTK0NOUUZ6N1ZXUHRHRWg3US9xaUFuZHg3eXRXVzFQOXBHNDhqakgxcjNXdXdtcWRvTlpsZXhhTVFvaU9XYzRKRzNPS3h4eWt5M1dsbTVxS05jR1B1RVNNc0VYeEUxRHVFZ25JZmZnK1F6UkxXTkx1dE9rbHQ1VkpKT0FWTlZ4VXpMdGM3Y0hGYjQ5OXM2a3h5Z3k3TndXTStuRmVkMHl6YkJuT2VEVGJXOGlOZ29UbnBpcE1VVEZ3czVaU0J3S29pU2R6NVBORVltUW9DQVB4b2FCZ3NLSjJpS3NJeVNDVG1tU3cvWjI0RU55Y2M5OFNmak5hZGQzbjZYRkFGVUtGUUxrZVlyRyt4bDBZYmg0MkpDeXNjZk9hMVhTVm1Odk1aRWJ1eHRFWkk0UFhOY3ZOUDViYThWNldyczFHRzFjWklJV0NWam5wK3pOQ1p3V0NEekFKSXh4UjNRV0ViYWpkRVphR3pZRHl5V0lUK05BcnZLT29QUEJGYzdjNUdBcUJpVHV4akFORHRaa0JXMWpJUGhqWEdEODVvaHNCalhhcDVCSEp6UTNWMmFXZEZZRHdlQmVQTC80YUo3Rk9NNnZiQUxucDYwYWRsbTAvUzcwa251Mi9vK2YySzVhTS9WU1Ivd0J0QUpCaEQ3RHlvbm9WMHRxL2MzU3M5bGRLWTdoVjVJSFZYWC9tVThqNmp6cGtqekFDN0toc254RnMvRmVhZkNqWk1zb1NQYWR4MjVIblRXcWFkTnAyb20ybmtETUUzQ1JEbFpGSkJWaDdFWU5JamtkZFBrajJFbCtOdzlPdjhhTkRaY1NybFFEZ0xucDVVRndUT3hKVTczOHpSdUlBU3NYR1Fpbnp4UU15YkZESXFBN3V1TW56cHdxTHdReGQxRkVtZDdFc0NnREhrY0RIelR1blR6NlpJa2tUR0c3aGx5R2IrNFFCZysvblVLT2QzczRaWFg5WWdPMGpqSXlLWEZkT2JWU3dBS2tuSjZrOWMwRzJ6czdyT25kcGRFbEVuZDdsSDlvaEIrNlQ1anoybjFyUGUyejluZEV0VXZkUGpqZU50MlhCNVkrNSthRDlucjFwdGQwdTJ0cmdDN3ZMaU9BaUUvZFFuTDUvN1F4eFJMN1MreDlsWjYvYjJMUExCcDJvZ3RaTTdsNCsvSExRdG43cEl3eW56d3c4cXZWeW03OFR1UzZqQTlkMWszZDl0alhGdXNuZTU4dW5sUU5iT2UvdVhubUJWV09mZkg4SzJyVi9zb2x0ZXdPczlvN3NHQ1cxaWFlQzN6eVVRakx0OGpKQTlPYXluVU5laU1JaDBxTExCY3ZNeStGZmdlZnlhNk1iMTFHTi9zRzFJckZ0dG9oaFY1STk2bGRuOWJsMHJmQzI1N0tVN25RZFZiL0V2OFI1MEpMRm1KWWxtSjVKNmswcGtaTWJ1TTFlcFpxcDIweXpsV2VhT1dOd3lrQXE0UEJHYXZGcGZ5MnRoY3ltTW5LQUJnMk04VmcrbDMxM3AwZ210R3ltZkZHM0tOOGorSXJYZEU3YjZGcUdpMjFuTkViVy9CUGVyUHdHL3dBcmRDUHdOYy9KaFkxd3lWVHRRSm83WVh6RWhHT0NPdFZoYlFUdWtpQnVXeXhQbUtzZmFtNmZmY1J4cUJaT09OM2tmYWdtbXpNMXFGNkFjQTFyajFFWmUwdTBnRFhPVDBGTzM2b0dMWUdjVWlGeEVTYzVhazNiRjRpU2NERlA2UVpGR0pKanlQV2kwYUtVSGh6UWVCY3lqQm8xQkV4akhVMWRTQjZSZUpBNnNjK0Z5ZnpyYnV6UGFhRFd0Qml0cmVGb3pac0ZrWmwrOFNDUjgxZ2xtTWc0YkhKL2ZXcC9aVUF1bTM3TzNXNlFZOWZCL3ZXZlBqTmJYeFh2VFgrelQyVy9VTGZVcmxyV0s0aVJGY0p1Snd3Ykg1VTVlV3ZaZHNsOVUxQWpvZHNBNTVvVll3bTgxVzF0NHhscEpVUUQ1Ni9sbXAzYU93ZTY3U05wZW53ckpldTdTeVNra0E4RmdxanB0QzQ1OHpYSEhTY2VEc3VOa1oxRFZZd1JrRXdBNU5JbjB6czNQY0FycnR6RWhKd1h0ZW4rMUJib2xMaUx2Z1ZNWnd3STVHT0NLWmFVRzRmRC9xem5BeDA1cGIvb2FHWjlEMFYyS1FkcDRHL3pXN0RqNXFFTE8yZzFTM2l0YnlPOWpLbGpJaWxRRDA2SDRxRVdXS0lGVHlXeCtBcDZ6SWpRekVrRXhucDgwV2lKaXlRM2RsRnBkMUtpWE52ZzJrekh3RU0zaWlZK1hQSVBRVU4xaTN1ZFBkTFM1aE1NcWdzUTNtUGJ5STZVek1WTTdqUEdCNVVTaDFtU0szUzB2VVcrc0dHQkROOTVCL3lOMVhwMDZjVUFFN3pNUmJrNUhsOWFDS1EwYXF3Nm5QSHhWMW0wbXh2WXM2THFFUW1ibGJPN2J1M2JnL2RiN3JmR2FxT3ZhZGU2Q0l4cWRyTmJ1MkFPOFhBSjlRZWgrbFhpbXZOVXZZSUxlQ0czOGNtejlZQ2VGK3RCSjcyZThsd1h3dkdRbkNnZkZSMVl5UStZSlk1L0UveXBGNWRSNmZaUE0zQVFFZ0E4aytRclNZNloyN1dyN043aStYdDdZSFI3YUs0bnRVbDJwSm5hWkhRZ0U0UGtPdnpXbS9hbGVhaE5wMHVuZHByYlM1OU1pRWR6SitpR1NPWU92aURSdVNRcHlDT1IwSjlhcnY4QTlOK2xzTll2Ym1RWm10N2RCSVQ1U1NrdTM0QlVIeFEzN2VOZmZVTlMvbzdUSlkxVzhuU0l5TzJNb0FGejdBblAwcXJ2V3BSTmZUWGFEN2E5UjdTMitvYU5vbWdXaDA2NXM1SUo1Ymd1QkNqSVZZbGh4Z0ErZ3owckZCcHEyVm9sdG5lN2N1NUdNK2cvRG42MWMzMUZyYlFZTkJ0bTIyTUxHZTZLL3dEankrV1Q1cU9nSHFTZlNxN3RhNGtZbnFUdTYrZFhLbXdHaHNrUjk1SFB2VEdxSXF4SmpCeWZLaXQydTF2Q01aNmZOQzV3clhWc3B3Y3Y0aG1ybFRVN1Q3TS9vaUFqbkdUUzN0RUJ4c0J6MUhrS0tRS0VnM0VZNHJvRVZ2RVJrQVpQdlU3UFFGZXh5ZHgzYlNrUkx5Rk9jQ245UGtqTUNxcDNCUmcrb3FKclRzYmdMbkM4OFZCaWthTnc2SERDcTF1SldCRlZwU1J5S1RkWUVEQmlSbWhrTi9QR2NncWZrVXFlN2t1Q04rMEQwQXB5RFp5ek9KUGFqbHNUM1FvQmIvdEZ3ZXRGMTNnRGJUcFJCMHZUa2MzR1I5eUVTRDVOYWoyQXRFdHREVjFYbVdUY3grRkZaenBhdi9iU3ZRV3kxcUhZM2RGMmJ0QTR6dWNuOGhXUE5lbW5GN1dmVHIxckM4RjFHb2FWVWNLV09NRXFWejhqTlNkTzE2U3p2dEl1VmgzU1d0dWJWenU1bFhuSHdSa0Q2VUhuT0kyNmUxSmc4TWl2Z1lDMXl0ejF5NVhhUzI3d3NTZlU1NXFJa201WkN3MmpHRGoxcWNRcVFScWNIS0VrbjE1cUlvUmtLZmU2RHA4VW9kSXVHMnh4S0NRYzUrYWVXUS9vamtIbmFBZjlxWnVpbS9JUEc3QS9DbjRpb2dRUmxkd1h4ZkpZL3dBQlRKQ25MSzBwNDRBR0tnNnZHMGtZakVqeEhBZFdVOGtVVHZDWG51Qms0TGZ5RlJyOGI1STBIK0VLZWZQTk9GVVNTWGNGNXlPNllISnp6MDZVQzdRM3M4OWlsazg4MGtLQWlLSm5MS2pOeHdQTHlxd1BDZDdLQVB1SGdrZVpxcVllVFU1V1lob2tKYnJ5R3p3TWZuV21LY2prYWR4Q2taUGlBQUpQVTRGQTdrblZ1MGRwWWptM2didjV2Z2VYMU9LSmF0ZGkxdFpKblBRY1VQN013Yk5CdWIxLzI5NjV5M291N2FCKzgxcE9wdG5mK1BvZjdLU2RLK3kvVzlXKzdjM1FrdWQyY0VLd0t4ZiswQnYrNnNKMUtScnZVWnRRbjhYOXkyVTlGVWNidjVWdTNhZWEwMG43TGRWdERLRU54cWt0c2thNEJkWTVOb1Vld1NOUWZhc0UxR2JmY0pFdmlsY2diVjRDajFQb01lVkwvaXFpVEhFQ2dIQmtiY2NlbmwvR3ZZOElENVpwREh2Ym5JKzZPQjdVcVE1VWtjcGtnRWVlS3BJTnJ6VENBTkUyRUI4WUhYNlVQMGFBU1RkNjNPMDRGR2JsNDFnbE12Q1lPUWZPZ21oeWJiaGxBT0NNNDlLdWVrMzJzZW9UQ0d3Ym5vT2VhNjBuSTBWWmhuZElNajZVSzEyNHpDSTg4bWlXbkRkcFZxTndXR09JYjI5U2VjVXRkSDlWdTczOThUSXdMazlBYzRwb1U3Y3NodUhNU2phVDFQT2FheldpQ2w0cVRCOTEvaW1yVUswNksvQ3NjRSttYWZraWFDV1NQT2NIRkFMdC93Qm90RzRud2c2bWd0cUNaQVBPaXFNUW9IV2loNXA4azBjTjRUR1ZEVzZESkhXdFQ3S3NmNnFXUGVub1cvZUtxSGFtYUtUc0pwRjNEQ0lwWlpHamJIbUFLdEhZa201N0pXVWtod0czWUh3Y1ZoeTl6YlRqOWpNaFhBOCthOVFuZkV1UjkzSkZOT2NyN0JpRFVtRkZZQTg3c0FFZTFjemRJTVArTW5hTVpZZGZpa0IwSWNoVDRRQU9uclNaY2t4c0RuMCtLU3EvMlhCKzg3OC9BRkkwWFVSQ1pBa2N5a291NCtFZ0Q2MUVzNXhHczJDSFVLcEo4dlArZGUzMlZNcGJCTEtBUGdHdXRZLzdFZkR5d0hOVlBSZlQxMjZicFcvdjVIbm5HY1UzZHVISVkvZTNMelRjd0xkNkNjSGYvS2tUcUJIeVNDQ0Nmd29Kd2JiSks1STZlZmx6VlhqRzFHUCtKaXhxWHE4cmxSRkdTUzUzSDM5TTBOMVNkYmUxWW5qYUsweGlNcXEzYXE2ZTZ1WXJLSEpaMkF3UFVuQW8zcVg2alNIczdVWlpFRVVlT3VSMC9NVlZkSWtNK3ZSelB5Y2xoL0NyWmQyMHB0Kytabmd0eTIyV1Jlb0hvRDVlNThoVzJVMXFNNTMyc0hhL3ROTDJsMXlaclBmSGF4c1hJWWdwYnMrR2tDK1JabXlmWVl6NlZWNFhScExxV05TSW94M2FBbkpMSHFTZk0venFUcVBkMk9sOXpBaXhvQnRWVjR3S0h5S1liQ0NEcEk0N3h2ay83WXFaRHRQV3B5cHlPRDVVeEpMM01yWTVqYjd5L3dBUlNyZCs3aTIrZmxReS91ZTRoYWJxeDhJSHZWU0VINjNkZDVLSVZQZ1RsdmMwdlM0ZTZpYVJ1QzM3cWpXa1EybVdiTE1lZWFWUGRsUVVUanJXbXZpZjdONmhOM3M1eDBVWSt0V0JXUk5JZ0RrckdFR3hCMVBISk5WVTlENzFiKzdBaGlYYnVJVWVKdmlsa0lyM2N5U0ZpSXRxNTQ4c1V5NjdXSXlEOFVXdkM3TVYzZFBJY1VMbGoyRURtbktLOEhJcVVXWm8rOFlrbGp5VFVWZWxTRUxHTGJ4Z0hOTWk0V0tzQ090RlVVc29OQzRWM09CbkhuVThTT0JnVXdPZG85VTB5ODdMYVBwK21UQjJoZG5ZZW1SVjY3RVFiT3lHbERjeEpWK0Ivbk5ZcHBrWU1hZUk5SzNic2VOblpMU1VYQXpFY256NVkxaHpUV09tbkYzUkJveEdoSjhUa25qeUZQeER4UjViR1NNbjFyMTQ4UmdLTUR6cnlVNWtDcGc0d2E1SFFSS0NBTTRHQWFRWk1sTTlBR1A4S2Z1R0hkeG9BYytlZm1va2c0bTUrNm9HVFJBSDNiNzNLaFEzR0tuMmFvWUFKZCtGVVkyNFBQRkNJZ1huTGY4QU1meXF5ZG1OTWwxZlVvYktJaU41NUNON2M3VkF5VGoyQTZWVm54SWUwWU9XWVlVeWRRUGVpdmE3c3BMMmQ3Sy8wMXFsNUhFTXF6Vyt3bGtCOVQ2Z2RSaXJCcVU2ZGlkVnQrNjdKYXJxTVNTaHYwMk9MOUljbjFVRGhmb09LR2ZhZDlwVmgvVXlHYTcwNTQ5UW1tYjlGczd4UU1rSGgzVHJ0SFhCQXljZXRWamovd0NsYXpUVTdWcllXODg4OENUeWdzTFRKNzVJL3dDNjdqb29iSndEenhtcUwyd3Y4bGJhTnVEeTFEWjlldlpaYmlXU1RmTFBLMDAwekh4eXNmTW1obHhLODhqeVNITEd1bkREWGRZNVpiV2JzbnBwVlJlU0RCY2VBSDBxd1NFdEhoMll4RTVFWlBoUHVSOUtnNks0L282SkpwRWgvVitIZHhuSHA3MUlpbFdTRldJSzVKSFBvRDErQ09hakx1blBTUGNadXJxT0p1ZWVmaWgrcHpkOXFSSzlCNUNpMEtnU3pTbklDakFQdWFyekVpOWJJT09vcW9WRWR4ZUk5QWNaK0txOTFNYnk4OVlrKzdSTFhMdnVvaGJ4c2Q3anhIMEZEYmNDT1BKNm1xeG4wclRydmhjY2dZK0tIdWR6RTA3TzVKd0tZSFNyaVNoeVFQY1ZjWjIyN1FjZE9CbXFqYkFHNWhCL3hyKytyYTBXK1F2a3Q3QTlLbkpVUk83QmNuem9WZmpiSmpHUGY2MGZLamFjZFJRclZrMmdIUG4weFN4dllvYWxQeG5BSXBoYWRUcldpVDhmQkdLbUpKaGVjQTFEaTRaYzlNMUtjS1dvQVpwS2t4TDQ4REZmUUhaVXFuWjdSWW5PMGkyVWdZNUlyNTEwbTViOUY4dlhOZlFXZ3lEK2lOS0pZaGx0SXhnL0ZZLzVFNlh3alYwdzJqYTR4N1ZFTnlzVEJqay9TbGQ5YnNjdk1WSkdTdTNwWGpXc002ZDUzb0tqcWVnTmNqb00zRjlIM3NKa0REY01rZW5OSW52SXRyS0EyWDhYTlE5WWppVzhWRlk4SmdnYzU1cGs5MkdiZVN4QTQ1cDZMWnBwUkVZZ0NmRUNlUGVyTjJLMVdLMDdRNlpLMHhnSDZTc1R1dzRBWUZTZmptcXBjaVBldUMyMGNEbWtqWVlIUmpoR1llZnRWYUxiZE8yOS93Qm85TmhrVzAxSFI0OElmMmp5SklRZU00d1FEMTg2K1dQdEwxdS8xZTd0QnFiYWM3VzJZMU5xdUNlT1N4Nm4rZGJWSGRkbmUzZlpxOWp1cmZVYnJ0Um9kdWtVc05sTTRrblVEd01GQjhROGljWkI0OHhXRzlvN0RBbGVQUzIwZTJqSkR0Y2c5NHg5TUhuTmE0eitXNnp5OUtyTDNTcVZpWXY0amh5dU1qeTRyclU3WjBPME1SMEZNNTRxZHBNSWttM3NEdFgwL090MlN4V2psM1JuKzhvNDlqVXRzNExaT2V0UmU1aGt1WkRBcnBia1pUZGtFbi81aW1ab0Nvd2traXNmK2JOWnJFTGhwQnBnSSs4eExIM0hTZ2QxS3NGdDM3bnhIaFY4eWFzV3Bxc0ZxTnpIYkNneWZnVlFiMjROMU84bktybndyNkNuaE5qSjRoYWFjdklTV1BKTlNabUFqL0xtbzhIM1J4NzBxVHp6K05hSU1zYzE1WGVkZFFDNGVKNC84NC9mVnppaENxR1lubXFVQ1FRdzhqbXJuQUJMRXNnYmN1M09CNUNwelZpVE9DeDRCNlVGMU1zY0E5TTVvK1hReGtBbnBWZHZXM3MzWGcwc1JVTVZMdEpCRVh5b080WTVxSXZXblZyUktXREd6WnhzcDNBUFIxeFVSZWFWK0ZFQVRwb1R1RDZZeFgwUGFveDB1MG1pVUpIK2p4cno1WVVDdm5IU2ptM0hubXZwR3l1b3BleTlxakZsa1ZRdjRBVmwva2ZGOEtHSnpEUGhzRUFjaWxpOGNuRUxIWW9KR1Z5S0hPLzY4N2d4RzNqM3IyR1JZTGFiSllrOFk5VG5pdWF4cks5ZTdra0k3d2d0Z0RJQUJwTHVGZDRwRzJFZGFTdVpwVmtoanlCd0I4Y1UxUEJJOGtqR1B4SGtpbURjL09UdlBocHlSdHNEczhxcTRZZUUrZE1QQzZnK0RxQlVLYVY1YnlhTGIrejV4L2hwNkpVWnRWdnRCN1p6YXJwZHpMYTNpVE1VbGlPR0FJR1I2WVBvZUNLUjJodmJqVTdiOUoxT1o1OVJhUXpUU2xzaHR6RURIa0FlVDlLT1huWjZPOG11TG00a2xPN2F3VlNBQmdZK2VRS0VkcGJTR3gwNUZpQjNUeXJuSjZLaW5BQThoelcwc3VtZGxWckdTQjY4VlpyV0pMUzFSU0JsOEtNOVQ2MEgwYXllK3YwUk9pK0pxdU56R1JhU1dpcWdCd1RLUnlEeDA4K0tySy9DeGlFMXdvNHdPdE4yN2QvZndSNElET00vU3BiUm9TZHFnZnhwaFpsczJsdkpBQ0xlTm5BOVRqQUg0bXBVaGR0TlFHOFdVVGNueHlrZVhvS3F0S2xsZWVSNVptM1N5TVdaajVrMTdFdWVUMC9mV2ttcHBuYnN0T0I2R3VjK2d4VGlEZzRwcHhqTk1FZXRlVW9ESitLOFBGTVBSUjNRNW5FUWtadGtNQndYUDk0ZjRSNzBCSDUxWmREaGRiTm83bU1CUSs5Y2pKR2V1YW5MMGNLZTZTYkpVam1oMTRyY2xSeDFKb3RjUkxHM2lSZHA2TXZTbzdScjA4alV5blFWZXRPQ2wza0lobktqb1Jta0xuTmFSSjFCMHBkSVhwU3g5YWNJQjBuOWtuSHArK3RlMWZYVzBxLy9BRWVIdkh0dGl1SStNS1NPaHJJOUdYd1JaQkF5TW4yeldsOXBWdDdyVlpaN0c3dDNqN3RCdURkU0I1VkhKSmIyZUY2TnQybXZIa0lpdDhuMTJkS2l6ZHBaV0JSeXlxU1B1Snptbm90THRCcGF6eXkzRFhVcFlva2JBSW9CeHpTUnBPbFNXNUVhNmlibmNEbG5HekhuK2RaL3hYMmwybmJPMXN3NkpiU3k3ZVVhVEMvUEZGRTdjNk0wVzlyZThVOUdHMU9EK1BTcS9Ib3RqY25kdHVZMkxFRTd4ajhNVng3TjJhb3hsTnkvbmxHVWZ2RlRjY0ZUTEtEOTcycjB5YXlNdWxibGxYaDF1Q3FrK21PYXI1MXE0RHlhZ3p4cXN6WVlrY0VyemluN0xzNXBWeVFKN3UraWN0dUtwYm95L1RrVjVxSFp6VElJc0RVdFI1SmtBL1JWMmdueTRORW1NNkY4cjJIM0d2U1hTa3ZjUmdNM0NxTUhOTWR0NUdOelpSU0hMSkVXYjVKeC9DbnRON1BZdmJlVnBKREdqaHlIUURPRGtVRzdSWHEzMnJ6enhuZEdNSWg5UVBQNm5OWEpOOUl1OWRqUFkxNHhiemhRZTkzNVp2YnlxYmNYcFFPSFIxYmQ0bEs0SXA3VFVnMFhTQTdOc1pVNzJTVEhPZXRSbWpLdTh6dDNobDJzcmJjRGFlUisrcDkzYXZpSEpxYUFZN3R4OUtINmxkQ1d3dWRwTzQ3QWMrbTcvYWk0Z1UramZUcFVIVnJaUnBseVVVN2h0YnA1QWorZFZORlZaUlN6WUZTUDJhWUg1MHUyVEM1UEpQV3ZMd1p4NmVmTldoN2FydVFraW1yaytQQUdCVW13WEtIUHJTTDVWVURHTjNtYUROUW9XWG9UOUtSSW0wNE9NaXAxcHRhMUE0eU92TlIwdGJpOEx0QkdXVUhHNDRBejgwOWtkMGkydUpydUtTR0V2R2pnc3g0R1BQbXJWc2FKejNiQUkzazFOUHV0VmdIQ3hNb1hhRDRWT0s1cEFQQzJRRDc1RloyN1hKbzRaSXdvRXdBOWVldEFMaTVXS1IxaU81U2VPZWxPNmlTakZTZUNPRFFrZGFyR0ZhZHl6a3N4eWZNMHRhUWd6VGlqM3EwbGlsajVwSThxY0FQeFRoSXVqUTRnWGJ5Y0RBcTdhRHBNd1V5WEpRWjV4bnlxczZab056SHBWcmZQSEl0ck1Ta2NtN3FSUldIVDNCQkUwdjhBNnpXZWQzOVBFZDExZTVrdDB0R2psalZNNVhvVG5wUU9PNHZFWnpHb0pQbG5pcDF2RzF1aXdsbWJnc00waG5YZDRmdkhxZmVzNTEwdEZndlowRDdvU1h5T2o4Vk1YVlowallmb3JIUFVoK29wQ2xTQ001T2NuaXBVaXRhYVQvU0Q5MjBUa3B0Qnl5Z2VaSGtLTG96UTFraUo5MWs0YkdPSEF4U0xqV0ZNQWphMG5Ma2M3bUF4OFZINyszbWozYnNnampGSUxoeGpHNXMwYWcyUnF1cnVtaU1zYXZESk0zZEtHUE8zSGlJL2Q5YXFRNEFJQXdQS2lXdk5KL1NVa012SGNBUmhjOVBNL21hSFZwak5SRnUxczdRekc4MHUxamcrN2N5Um9DUFEwWDFHSDlGaWhpWTVLeHFNL0F4VVRUYkpybnMvcE10dXVaWVpZNUNDY1pWWDUvTE5FdFhDWFhmNDRmZ3FmaXNyZmkvN0JSSUFBQitHYVJLNnlJOFo0RGpiMTllS1lKMm9YWmdxRDd6TjBGSWlTZTdZaTJUYkdSKzFsR0I5QjFOVm9nYmFFY29jK0U0eFhPdThIcU0xTjFDM01WeGplSEJHU3dHTW56L09tZG5HUjgxZTBrdzRpaUpQSEZENVhhZVhnZGVncDY2a2JadEgxb2pvZW5OTWR4SHlmUVUvWFlKdHJTUVFDS0pHWjNJQklIQzU4ejZVY2lrUzJMV29SVWpUaVBqZ2lwVzBXeUJZOEFlL244MUN2WkZCQVllRTlRZkkxRzlxMW91ZjlaRTBiZ0ZTT2dvTE5MTGFudTJPVS91c2V2d2FuOThJbHlDU252elFyVUxvUzRHT2xQR0ZUTnpNMG1TVGtWSEZjR09UWHExYVRpZE9hZEE1OHFiVWNVNm9wZ3RlY1U1dGJ5cnhBY0NuZ3ZyeFJDUXJEdEhmVDZCWjZaSVIrald6bDA1NXlha3gzMHdBeG44YXZYWjNUTklhMmkzYUpwYm5BKy9HVG41NXExMitqNk12TXZablFuUUVkSVdCeC82cXl5NVpQaThjTFdjV2JQUGFXMGp0NGlweU0rVktaZlBCQnJWN2V3MFF3RVI5bnRGWFprWTdodVBNWThWZXlXT2twR0NleitpRSs4TGMvd0R2ckw5WTBuSFdVWTIvZEpCOXFhdUxZU29WWXZ0STVBT0FhMHZicGtrNWlpN042T3hCd3pDM2ZDOGRQdjFKRmhwU2Z0ZEMwWWs4K0dHUWYvN28vU1EvQmpxV2d0MndtY2VucFRvUTdoNkhyV3N6V0dqRFozZlpyUjVXWUJzWWw4Ly9BTmxNUHB1bU9NeWRuTkVUMkxUQS9nSG8vV0YrZFlwclF4ZnNjazdsVTVQNGZ3cUJ5VGdkVDByUVB0S3NiSzEwNjBsdGRKMDZ6a2VmYUpiWjVTU29VbmFkN0VmbFZGdElubnVvWTQxTE1XQndQWTVyZkRMYzJ6eW1xMHJRWWphNlhCYm5xbTVSN25yVVhVUDFWeE1jWVU1WVkvR2pjdHZtSnlnd1EyNFVQMWV5bnVFamVCZVc4SnowSHJXRXZiVFhTclIyOFZ6Y2Q0NmxtRGRDY2daOXFLOXpJKzJHQ041Slc0VkkxTE1lblFEazFKMHZScjJXY1F3eDk3UExoRWpqUWxtYk9BQjcxdnZZYnNxblpmVHJpeXRoRE4ybXVvYzN0MlRsTEtNOUV6L0Fjc1Jub0JWWElwR0V4L1o1Mml1N2FHWjdTS3pSemtOZVRyRmtIenh5ZnlvZ2ZzbDFkVlh2dFMweU1NaFlNdmVTS2ZRWndPdnIwclJkWEZyYWFoYTZYMllzWk5adjFRaWRwVkRoZWZ2c1Q0VUg0RDNvYk5xR29hZTl3MnU2cmFnSzNGdkVwYzdRUHVxeHdBUGowckw5TS9qU1lZcUhiZlpEZFR6cVplMGVqckRuQlpJNVg2ZGZJZnZyenRCb3Y5V2JrMlJhT1dJK0tHNGorN01NWno4KzFhTG9tcUc1aWFiVGlJOU9JYmVqUTVMZkRVRTFiVXJQV29XMHVOeFBDUEM1WUFFTjFCQjhpS0p5Wlc5aTRZeWRNenVMamdqT2ZRME91SDNqQjg2ZTF1MmwwdlVKTFY1RmtDbnd1cHlHRkRKSFp1bld1bkdmV05ldktGUXFUd09ocUJLUVd5T2xQT2p2MTRGTU91MGdlZFhFa0FjMHBSWEFVN0V1N2puTk1pa0hGUElLNVl1UENhV3FObnBTQnhCeFR1UG44YWFSVGtDbndwOXFBc3ZaN1dybU9CTWR6MEhXTUdyVkgybHZTb0g5bUlIL0FPT244cXpuUVpCM1NaT09LczBMWkdldFpaWXhlTldnZHByOHFUL1poNWNRS1A0Vnc3VDN5NFA2anA1d3AvS3E0SDRyaTVJd01uSHBXWGpGK1ZXTWRyTDhNZjhBaGo3R0JNZnVwdVh0UGZOZ21PeFBzYlpQNVZXMmZuT0JYR1E0bzhZUEtqWjdSWHFsdjFWa3U0Y2tRQWZ4cU8rdTNiWkxSV1o1L3dESi93QjZFczVJemdVMlRqOTlQeGc4cVIybTFDZThodFJLc1NMR3pFQ09QWjFHS3JxN00vczhmQnhSaTlVT01FZzQ1b2NFVlpBY2dnbnpyVEhxSXFWR3dVSU9GQjY1elNKMkdXNi9JSnBhc25nOFE5aDFycE9Rd3puUDBvQzcvWWRmMk9uZHA3KzkxRmxqN2l5Y3hUcy9NTEVnRXFwNnNSNFFmTFB2VjNQYXROWHM3KzlpMU5iSFNCY0dHUzNnWUc0ZDlnWWxuUENyamplYzVQQTZWaStrelMybHl6eHNSdVVxUURuSVBXckdJclM0MG9JMGNReElYNVVaNkFZL0tzODV1cnh1b3RHbDlyYi9BRksySFovc2Zwa01ZdVpkdmZiOXBuYkI4VHNUbHpnSG5weFFTNHU5RDBIVURQck0vd0RXSytLc0U0SXRZM0hvbldRWkdNbmoyb0hZQkxDZUtTSnZ1TVRzeVFPaDlPbENackdLZWQ1R1p0NUhMTVNTYUpqTmk1VTFyZmFuVTlTdTdpZWFaNG9wU0QzYUhDcmowQTRGUTdMVzViSlA3T0hhUW5PU0tXZFBZdVFXNEhRbXBVVnBGQW02WGEzb0sxMWpKcEhhczZoZHl6VGJuRGI4NU82bHdQdkFJOHFrNmpiaVhMSXBETDkwZndvZEVTclpIUThWYzlKU1paUW8yanJVUThuM3BaQno2KzllcXZOTWlRT0tXQWVLVUZ3YVhzUEhIRkFTTGZMcU00YjVxWEdub2NmUElxRkdXWEcwMU50NWloNUZLbWtJZ09OeWJ2Y1VoNDFEZUVrQ2lUU3huUjVYQWlNcnVxQTU4U0x5VCtQRkRjQ2lVVWpRUW5jSVI2VlpJU01jWXFyNkNvN2lQam4xcTBSWklIVEZUa01UeUVEazRQc2E4WUJzOUI4VXBWUHA5SzlBSVBwbjJyTlpyYWM5UlhoUW5yejlha01yQVl4ejdVMlVKNnJRRERSL05JTWZIVDg2ZTdya25uNHJqR2NHbUVLU05pTXJnOC80cWdzRzNFRXY4WW9xMFNuSllObjJxTTBDbGdBWEo4c25GTWpLZzVYQWY4S1U2bGdlU1ByVDNkaFNBd1llMWNZeGpoRCtkQVIwVjE1RGpHTTVGRUlwbVNFaGp5UjZWR1NOaWNiY2ZCcDBxeXhuSUpvb0lrazV6Z2ZoVEc5OXgvZDBwUWNmNFcrS1RuUFJTZm1nR1N6aklHZWZla3R2WVlZcWZtbnczaEFBK2E5WURHUmdtZ0I3eEVja0NobDliN0pPOFFZVnVvOURWaThUY0JDZllDbVhzKzlMb3lqQkhRbkg0VlVwV0s2Qm5wWG9YSjlxa1QyelFUTkc0OFE4L1gzcmtqeDVmbFZwTnFuaHpYRmVldFNBbnRYclIwQTJpNEFxVEd2VGlrcWhwOUV4U011TlZCSklQSXdNSHpyMEFmM2djL09LV29QeFRrcWwyM3lTQm5ia2tubjYwQXhwSC9EUWY1UlZpVDc2L0g4NjZ1cWNoaWtuOW45S2NqKzYzMC9mWFYxWjFaUTZINHBNdjNxNnVwR1Q1L1NtNVBML0FPZVZkWFV5Sm0rNFBpb0xmYytwcnE2bkNwY2ZSYWRQN1A4QUd1cnFabWJmNzUrS2NIWC9BTGE2dW9wZkVkLzJyMGwrbythNnVwa1lsL1kvaFN2S3VycUE4WDdnK1JUemZzRithNnVvcHdKMWo5cEgvay9qVVNIb2E2dXE1NlJUaS94cnY4WHhYVjFNSFUrN1QwZjN2d3JxNmtjTy93QjJsUjlEODExZFJDZi8yUT09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9FaW5zdGVpbi5qcGdcbiAqKiBtb2R1bGUgaWQgPSAyOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVBU0FCSUFBRC8vZ0JKUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEJ6T2k4dlkyOXRiVzl1Y3k1M2FXdHBiV1ZrYVdFdWIzSm5MM2RwYTJrdlJtbHNaVHBNWlc5dWFHRnlaRjlGZFd4bGNpNXFjR2YvNGdJY1NVTkRYMUJTVDBaSlRFVUFBUUVBQUFJTWJHTnRjd0lRQUFCdGJuUnlVa2RDSUZoWldpQUgzQUFCQUJrQUF3QXBBRGxoWTNOd1FWQlFUQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE5dFlBQVFBQUFBRFRMV3hqYlhNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBcGtaWE5qQUFBQS9BQUFBRjVqY0hKMEFBQUJYQUFBQUF0M2RIQjBBQUFCYUFBQUFCUmlhM0IwQUFBQmZBQUFBQlJ5V0ZsYUFBQUJrQUFBQUJSbldGbGFBQUFCcEFBQUFCUmlXRmxhQUFBQnVBQUFBQlJ5VkZKREFBQUJ6QUFBQUVCblZGSkRBQUFCekFBQUFFQmlWRkpEQUFBQnpBQUFBRUJrWlhOakFBQUFBQUFBQUFOak1nQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQjBaWGgwQUFBQUFFWkNBQUJZV1ZvZ0FBQUFBQUFBOXRZQUFRQUFBQURUTFZoWldpQUFBQUFBQUFBREZnQUFBek1BQUFLa1dGbGFJQUFBQUFBQUFHK2lBQUE0OVFBQUE1QllXVm9nQUFBQUFBQUFZcGtBQUxlRkFBQVkybGhaV2lBQUFBQUFBQUFrb0FBQUQ0UUFBTGJQWTNWeWRnQUFBQUFBQUFBYUFBQUF5d0hKQTJNRmtnaHJDL1lRUHhWUkd6UWg4U21RTWhnN2trWUZVWGRkN1d0d2VnV0pzWnA4ckdtL2ZkUEQ2VEQvLy8vYkFFTUFCZ1FGQmdVRUJnWUZCZ2NIQmdnS0VBb0tDUWtLRkE0UERCQVhGQmdZRnhRV0Zob2RKUjhhR3lNY0ZoWWdMQ0FqSmljcEtpa1pIeTB3TFNnd0pTZ3BLUC9iQUVNQkJ3Y0hDZ2dLRXdvS0V5Z2FGaG9vS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tQL0FBQkVJQVI4QTNBTUJJZ0FDRVFFREVRSC94QUFjQUFBQkJRRUJBUUFBQUFBQUFBQUFBQUFHQVFNRUJRY0NBQWoveEFCTUVBQUJBd0lFQXdVRkJnTUdBZ1lMQUFBQkFnTVJBQVFGRWlFeEJrRlJFeUpoY1lFSEZES1JvU05DVXJIQjBTVGg4QlVXTXpSaThYS0NRMVJ6azhUVEpVUlRZNVNpbzZTeXM4UC94QUFhQVFBQ0F3RUJBQUFBQUFBQUFBQUFBQUFDQXdBQkJBVUcvOFFBSlJFQUFnSUNBd0FDQWdNQkFRQUFBQUFBQUFFQ0VRTWhCQkl4SWtFVFVTTXlZUVZTLzlvQURBTUJBQUlSQXhFQVB3RDU0eE10KzhLeU5oS1NTZlQrdDZncWlkQjhxazRoUGJxQ3VXbFJJMWswbEJuaEU2amVsYldVS1N0dFNrTEdvS1NRZm5YSitJVW5sVmxXS29nNng0MTRBVEVVZ0VuOWE5MHFVV2R5STVFMGdqblNlQTVWNGREVW9oMEZTSXJ3VVpKcmpuRmRIcFVKWXBKL28xNUs0MS9TdUQ0N3hTOWVZcVVTMmRGUkk1VjBGeVAzRk5DTk5oWFFneENoTzRBcVVTeFZLTVR0WGlvOCtkY0tNQ1NmRFdseWtHSWcxS0pzWE9mQ2E3N1pVN0pIL0tLYk1UcVQ1MGtnUVI5YWxGV1BoNVhQS1J6N2dwenRpQkdoVDBxT1JJMEZlanJVcEYyeDR1QWdRbElJNWdRYVRNVHY5YWI5Szl2dlZVUzJkbFpCMDFyM2JFcGdKUUIvd2l1QkVlUFdrQkFFRWExS0pZOHE0ZFVDQkFTQkhkU0JYSGFxalZSamtJcmpRR1pTVDByeGtreVJQT3BSTFo0TElJcTN3dTRhUmJFTzJLTGhXYlJaemJkTjZwbENEeTlLc2NQdWl5d1VnckF6VDNUcFVKWXVJb2k0YzBBR1lpQlVHTmZXckxFSlZjT0daQlVkYWdxRVRJMG1xUkdNRWFqcWVWSVJwSFduQ05wRVZ3UkJKNTBSUnlRS1hXYThKaXZhNXY1MUNIdW5LdkdCcHBTeFhQT29RNkgwcGVzYWVOSWtHWUFrbmFpN2duaCt3eHZFbkxHOVUrbDh0NTBLUTVsQTA2UnJzZW00cTByS2JTVmdnZDZmdExaeTZlRFRJbFIxOEFPcG9vdnVDTHkxeCs1c2xPbzkyYVVJZU9oVWtpUkNldkxwSXFYaU5rM2h0b0dMTkFTMUF6S21WT0hxVFZNdGJIZlpyaDFnN3hXaTN1TFpxOUxUQzNXbTNsNVV2UENBaEo1QWI3ejQxcTEyY0d4dDlXRjR6aFNFSlFoQ3V4V3lHM0dsRGNwMDFUUHpIS3NlNFlTdGpHTFo4RTVpb2hJQjFNNlQ1Q3Q5WVlZNGdzMnhkRUM2YTFTNFBqYlYxQjVnMUZ2UkpLdG1aY1RlejNFYkcwS3NIYnQ4UXc0eVV1VzlzMm01YkJNd1NCSkhrZkNJb0dkYndxNVZkc1lvd0xXK1IzbTNMSUpaQlYrRmJSN281NnBBUGhXL2wrOHdKWmJ1a2tKblJ4R3FWSHI0Vlc4VVlUaGZGbGk2dFBaczRxMFBzN29DUWY4QVN2cURWMStnVS8yWUovWk5vWWgrNUJQVkNGUjZ5SitRcFZZTmFKUWtvdTdoeWQvNGRLU1AvcUdwbDVod1JjM0Z1KzBXTHUzVVE0bEd3UFdPaEd0VlJVNjBzTjU4eE8wYWswTmpPcE54emhlL3duRHJURVREK0czU1FwRDZCOE15SVdOY3BrRWJrZVBLcUU3eHNhT2NCeHU2dGNLdThKdlFIN0Y1Q2oyWjNSbTBKSEk5WVBPZys5dEYyeFFzZDloVWhEZzJNSFk5RDRHcjlCcWlMUFNrOWVWS0JCTTdVbWtDb1dlOHE5SjVoSjlLOE5hOUFBcUVQQStBMnIwaUQzWS9TdmFWNDg2b2h6em5ZVk5zMm5IR1paTG9BSkJ5dFpoUG41UlVJNzFOdEEvMlgyQzhxWjEwNTg2c2hNdmtxYmZVbFNZSUptRE5ReU5OZDVxZml5aTVpRnl0UjczYUs1enpxRkczN1VDZWkydGpTMGlOcDlLYVVtQnJ2VXNwMTViMDJwRW55b2lpS1VuVWlralhhbjFJN3grdE5xVHNQcEZXaWhzZnJTeHJQblhocElOS2ROUUtoQzFzMkxlM3RHYmx4NEc2VTVDR2N1a2RWSGthbFlOakR1QjQ4emZOSm5zOHlWRC9BRXFCQitWVnQ0dzR3a1dybmRVaEtWS0hTZGYxcHRqTmNHVWtxWDhPVURVbmthTnVnZlRiMzdlM3hheWF2MkZCTnlXd1E0Q1ZCMUpFcGtIZmM2NmM2SExnTU9IM2UvQVFwV3FGQTkxWGtldmdhWGd4R01ZZGg2YlJvc2xzNjVYR1ZPS1JQSVFwT1dQR2F0cjdEM3NSRGR0ZEx6QUtLZ2pLa3FFOU1vSDFKcTVPTDhCZ3BMMTZKUEIvQjd2YUt1bHkyMHN3a2tTb3BuVFRsT2xIZGxaUDRKY3BMc0ZweUkwa2p6cW80UnRzY3dwNXR5MFdsL0RXaEJ0TDF3bFVEOERrZDArQmtVZm9VempDVWRrMjYxY3FrKzVYS0NoMVVibElQZFdueFNTS0ZSUVRiSEJhdFg3SzJuVXBXaFNmaWpRZUJyTXVMdUQrSXNQYmUvc0JLTGkzTXE3SUtDVkE5Qk9oK2xHYnoxNVlPcnRtVXJiUUNUdDN2bnlxTmNZdmVJVExXZDF6a3BTaWZwenEyMC9TbGE4UG11NEdJV1dQUG5GMkxocStkQktrdnB5cVVkdktQS3VyZTFEQ1pVU3AxVUZTaCtRcll2YWJhcHhUMmNYMTY2QTdlMlpTK0NScWs1Z0RIUVFUV1EyVGoySXBRTGRJVmwrTFhVK2xKa3V1eDBaTm5iVEpLMXdzalRwWFQxa2dzS1E0Z3FhV1JtUk1Fa0F3cEpHeWhKMTJPeGtVOGh0VTVWU21JM0VVNjRsU2tFNVNZMDFGU3lOT2dUeGJEbFdEcWNpdzdidUFsdDJJbU4wa2NsRG1QWGFvSEw5S01icTNMMXRjc3JVUWd0TGNqL1doSktUK25sTkIvSUVSRkduWUxWQ1Y2a0kxcGZMYW9ROVhvOGE5SFNQT2syNlZDaEpHWVRyNTFMUVcwdE5sVHlrbFFuS1VFeHJITHlxR1JyVHJpVktTM3FkRXhyNW1vV1hPS1pmZmJnbytIdEZ4NGlUVVFDcG1La20vdWxRUm1jVXFEeTFxSUJDZW0xQXZBbjZJTmR1dExHbXN6WFJnYWJUU0hmeG1ORFZvRmpiaUFRSWltQ2d5WnFjRXlDYTVVZ0U3YVZaUlhyVEJnK2xjUjE1NlZPZGFHV1VrVkZVZ2d4cjBxeURyRDd6N3dDMUYxeFdnS3QvblJUdzdicGJjenNwQldrZCs0Vm9sSTZEOTZIc09hVG56TEp5RGZLZFYrRkhIRHRnckUxcDdSSVJiTmY4QVJwK0VlSGlkZlNobE9nb3dDSEQ4UUxMUVJiMnkzbU5NdTR6ZWcxaXJteXZNYlNEN3BnamFFOVEycVQ2a3lhdjhEdzlsbHRNSUE2bmVpdTFaVGtBMHk3MGw1R05qalFBbkcrS1dHa2hWaVVaVmFSYktVUG9hbFczSEZ3b2RqaXRoYlA4QWVDZzJwNWJCa2N4STBQak5hVGEyU1Zna0RUbVJYZDVnVmxlVzZrWE51MDZnN2hZbXFXU2YweTNpajlsRHcvaStIWXg5amFLdWNMdVVwVXIzWjV3UG9lRWI1cEowSjVHZkNsZXNUY1c3endaN0oxdHd0UE5aZ3JJcmNRUnVralZKNWllWU5EMkw4SlBZQThNVXdBcldoazUxMmhNblNlOGduY3hPaDNHblNpRGg3aUsxeEswUmNXeTJBNjRtRm9jK0ZZL0NvYVNKbnhTYWRqeWR0UzlFNU1mWGE4S2RtM1M3ZE8yRndoSnRMMW90RUwxRXlDSjh5QVBXZzMyait5cFZvNHJGdUVHeTBXNFVxMWFPcWROMGVQaFdtNGpaZHBuZXRCbWJSOW9wQjBjWjErOE40blpXeDg2dkVYQ2dBcktrdWRlZE9VVTlNVTVOT3o1cndDNXQ4WlViVy9hU3hpYUIvd0FJY0g0Z1B6RlI3RzFVRzcwUGcvdzY4cEhXZGEwWDJtOEcyK0pNT1lwaGFFMm1LVzU3UlphMHpmNmdPUm5mcldlNE5qVE4rKzVhWWtrMitJckk3UUE1VU9xQWlkdDRGWnB3Y0hvMFJsMlExYXVDeXhDeHZYRXlpM2ZROHNSTXBCN3cxM0VWWmNWY0UyZUpxZmR3ZHBGcGlDSlVHMGpLMWNwM0duM0ZFUkhLbThYdEZKYUlRZ0ZHc2pjK0lyUjd1eHpYVFNock9WTWp3U0FEOGhSUTNzR2VqNW51R0hiZDV4bTRiVzA4ZzVWdHJFS1NhYjFCMHJhZUorSExiRnlHN3hrKzhnRkxkMDFvb2VmNGg0R3NxNGh3Vi9CbjBCYmlIcmQ0RXRQSTBDbzBJSTVFZEtZQW1WUjE4NlRwWHFUblVKWWxTRlNVTmtwemQwUm9kS2puZW5WS1VFTmdkMkUvcWFoRVhtTUpLY1JlekhNU29uMXFGcW9nejUwL2lSUHYxeG0zRHF3T2ZPbzZEbDIzcGE4R1AwY09wbm9hVkduZVVKRkpCS3RkRWpXblVwa1FPV3VwMnF5aEFsU3R6QUZlQUlFY3FlU011bTVwUW5LZGZLclRLR0NrQk94QWpYd3FPK2tEWVJPZ3FlNGs1VHJvYWlxanRVRWdRQVZSeU8vOHF1eXFGWWx0eENHNTdROC93RHI1MXF2QkxDV3NOWjBNS09vblFWbE9IZDU1OXhSSmhPL2pXdmNLSVdtd1lRVXdxQWF6WlhzMFFYeE5Cc0ZBSVRHdyt0VzlxNEFUclE2MnBWdmJGd3hDUko5S3RNSlVxNE9jeklISVVwdXhrWTBGZGk3bFRBNStOV0tGSmpTSU8vOEF0Vk5oNm9HK3UrbFR3b3htTTZjd0tPRHBFYXNTN1NESmpmOEFPc1M0L3RIZUg4Vy90TzFiellkY3IvaUdScEN6OTRIN3FqMTZpdG51bklUemdiMEc4WjJTY1F3ZTV0MUFuT242OWFLU3RXVkdTVDM0RHZESEdEYWwybHJpTDVYYU9xSHVsOFFBcHRmSksvSGw0MGQzR08yZHJlb1p2b3RIRnJKQldZYVZITkM5dGVoMUZmTjlrK3F4Y3ViSzVCVmJ1SEs0azdKSTJXUEVhZWxhVFo0L2FZbHdtL2hPS0xTTVJhYTdGSVYvMG1rSldQVGYrZE94WmJXeEdmRDBscndMTVF4TmhiekwxdTYyNjI2MHRKeUtCaFdja3BNYzRJK2RZajdTTUhRbS9GemJJQUJFa0RwL0t0Qnh4RnB3MWpvYmRTR2NQTFRTSEhFcGhMVGlVeG1VQnlPcVNmS3FYaTVqdDdCdDVoWWNiS3dwS3hCQ2tLNXlPV205SExiMktqcndBY0s0aXVMUUJtL3pYTnNOQW9uN1JIaFBQMW93d3ZqeEZraHR0YjY3NnpTcE9WSmhMcllCMTFQeENPVkNkN2hha1A4QXdmRm9vUnA1MVVQV296dEFKRXFKU1I0aWwrUFF6MUczUDR4WVlreVhjSnU3ZDVMd2hJVzRFRUVuN3lUcVBLczc5cWJkdmJZZGhkcTBzS1cwdFhlMktoR3ArZXRCQ3JmTTRFcGJTcGVZQVFOWm5TcC9HV0lLdjhiZWx3T0paSmJDay9DU055UEFuV21wMkxhb29OdlN2SGJuWGpxREZjbmVLc285K3RkdUJSUzNBRUJPa2p4TmNBU2E3SVZDZThCcDE4YW90RnRpYWg3OWNFYzNGR1BXbUVDU1NkelVuR0FrWWhjSWJIMmFYVmhQaU14MXFLMkRPdzNwYThHUDBlSmxPVWFDZHV0T3RKNWtlTVZ3a1ppQ21uMjBwM0d3MW1vU2gxS0ZLcGZ2UVBudlRyY2RtZXBPdEtrQVRBQk1iVEZTeVVSM2RRZENERlFMb2xyUEIxN29IUGxQNTFidUNXMUV4M1lpcWw4QlQ2aXFKQnpBRGFyUlZFdkFyWnhiUzE2SlRtM05hTmhPTzIxdXBwcnRHNUFBMEkxNS93QkNzMndwTDkwaExkdjNsWmlET2dBNms2YUNyWU5ZSzRnc294SzRkdWdKVmt0emsrZjYxbXlLM1pyeDExU2JOZ1hpN2Q3WjNiZHZDbkF5b2dKNjFNc3NhT0hvQzFOcVVrNndCSjI2VUQreDF0MjR4ZC9PRk9XNkNuN1FqUkoxME5HWEg3cHdoaExqVElLWDE1UVJwQk5KOHRzYzQrUlgyV0Z0N1FiVnR4TGF1eG5tRktNeis5Rk9EOFVXV0pIczJ5aERnKzdOWWRobkVUR0dYU08wUUhYRnJWbEF0QVcxRUJKT1pjeUJDay9NVnFGdmUyZDY0cTB1YkpXRzRxMm5NV0ZiTEg0bTFjeDRIVVZhNzFiUUxVTHFMc0xybFpVa3lCNCtOVmQ0SllWR3NnK2xQNFk4WFdDaDNkT2hVZVkvZW1yeENnbFJVRWdIbFRZeVltY1RBdU03TDNiR25pQjNGcXpEOWFac1hrWDFyN2s2UDR1Mzcxczd6SUd1WDBqYWl2MmdXcGRmUTRCckpFZ1VCTmpzVkJ3a29VMzNwblVHZ1Q2amV2NUZRWjhVWXVNWDRaVytzRDMxWTkzV2ptWENSdDRIZWhJdlluZ3I5M2IyU3dxd2JRRktaZVRtUVNJektBM1NTZWxUMjdwYmFqZU50SWRiY3lsMUIzYldObEFkTlRyNDFDeDdFVU80TmVPSjFkS2NrenJ2ditWYTR5N0dPVVhEUktzdUpjS3hGcEs4Ui9nbEJXdVl5a2dEN3BBbWZDUEthcE1RdThHVGRGZG5kcVdoSktrRDNkWTFqeEE2MFBKYVVxeUt4T3lWRDlhaGlOdkdtT0tGS1RMcHZFMmJXN1p1V0NweDFwME9vR1NFZ2phU2RkL0NxUVNFQUVrd0ltbDMycjNqVmxITzBiVW4xcnFrTlFnZzNIT2xXQmxSM28wNnh6TklOQ0tVd1FuVGwrdFVXaTZ4TUo5N2VJMWxaMW1kZWY1MUhHNThERlBZa29tOXVCbWxQYUtqeW1tQVowMWpmenBTOEdQMGxOSU9VenJNYmJVK1VsUkFpZGRkZHFqb2NPZENRREUvcFZnM29rWlpNL1NxWVNGYlFTSWttZWhrVjNrbFJDU1oyTUd1MGlBSUFnYmswKzBnWlRCbVBHS2xsVUtHQUdTTlNBSTFOVWVKdGRtNEZpSUlpaUxzKzRBbVlpT1ZNMzloN3pZdUpaU1N0QnpqbFBXb3BVVlJWNEZocnQvWk9zTUFxVzRmaG1BUk9zMGNYZHJhY1A0RVVzMmRvMWNLQVNBa0FyY1Y0bno4YUUrSDd4M0RsRHM0Q2lDbFU3aldpM2hXMVhqMk9CMjRoeExFWlVkVmN2bFdYTE9TazBkTEJpVWtuK2pTdlpyZ3JlRVlHbEpBVTZ2dkxWelVvNmsva0t2dUxMTnUrNGVkWktHMU9FaFRhbENjcWhzYWsyOW9xeXRtMnlTcFJTQ1FEVmJpOThRVXRMU1VpWTE1ME8xNlhYYVdnTHdsaHkxY3kzK0daMEJZVktXTzFRc2lJSjBrN0Rmb09sR1Q5dGI0MnBMbDBoNHZ6blE2UVdsSlArbVFLN3dkdHh0M09UbWJtUURSS2x4T1VjMG1pamRWWUU0cFN0SXE3RER2ZGxHWG5IRHJBVVlqNlY3RWxKRFpBTUNOZGQ2bVhUcVcwaFdtKzFEK0pYb0l5Z21hdll1a0NYRXJTSDBIU2ZPczB4eTFOdTRwdFlJU3BVaU9lazFxVjRtVUxjTzNJVUw4UXB0NzV4SnQwRmZ1Q0NIQ05POHFPZnpwYzVVT3dSM1lJb3UwTnQ5cXd1U0FaQkduaUQ0VlY0cVczc0tXNWJKV2hENHpLUVRPVFhZSG5xUHJVakZsQmhwMDVRbFRpb2dHZDlBS2c0aGxadzl0Q3AwUkE4U1lyVnhVMjdabjV6VWRJNHcxc1hHQkpCSSt5ZXlaZkJRMythUlZBcEJRNHRCM1NvcGllbEVlQW9VTUN2blI4UGFJQUVjNW1aOURWVmo2RXQ0M2VwVDhQYVpoSGlrR3RqV3JPY251aUNacE50SnBScUROZGZuUWhEZTIxSjlLN094MXJnODZoRDFlVVlpQlByWGdPWnJzbUFOeFBRMVRDajZXbCtoSWVkamtvL25US0IzWjJGU2NTTVhUcVJzRkg4NmlvMVVPbExYZ2I5SG13Y3cxMUpqU3JhMElJQW5sSU5WWU9vTWQ0SG1LbDJycEN4ckViZU5DeTBYRGFJUGQySEtOVHIrZFBvUWdKNy9kUFdLaklKYzZRUlU1aEJRZmgwMzBINVVEQ0gwTXBJVGsxNUNSQkhyVTlpM2lGRFdRZTZmM3BtM2FXVnF5bUFkWjM1VllNTnlZSWdpZHFDVElnVjRuc3haM1NIV1JDSFFkdnhEZW1zRnhSL0RTdDYzZTdOeFNoR3UrMVh2RTl1RllTdHlPKzB2Tk1janVLRTdObk5kTnFLTzRGQW5sb0tDdXkyYmNVM0dPamFzUDRreHpFN2Z0OEl0MXVCTVNsMUpTVDRhblgwcXl0VTR6ankzMFg5bUxWQ0dqa2NQZGxmSWZNVkE0ZnhNV2R3NW1PVnR6S1pITFNpWmZFRnN2dWRwSG1UcjUwS2hhMnk1WlZGdW9uUEN1SkM3dHV5ZkFSZHMvWnVvTzRJTlhhM1VvME9uaFFWZU8yemx3dStzbkEzZk5ETW9KZ2Rxa2NpUHlOV3I5OTJ6VGF3U2N3a0htYWtMV2lTbEdYeVJOdjN6azd1bzM5YW9GQlRpcDF5MVpyVVZOR2RvMmplb1JJemtpQjRVenFLY3YwVmw4VWhzaFJ5cGtKQk9tcElINjFROGFYRnJoZUdPZ3hDZ0VwUUJvVlJ1ZXBxWHhTbDE5cHExdHllMGNWSTlOZjBySnVKNzIvdThTTE40NlZGZ3hsSjBCNjBIVHZPdm9OVFVNZC9aR2RmTHJpWHJrRE1URGJZUDFxSGlEeTNNeWw2WlJ0NTAwMEZHOVJKa3pHZ3FXdTNENjRlV096QmdOdENZSGowcm9ZNHBLa2N6Skp5ZHNNdUY4SlQvZGRBZG43UjBxS2VvQUFINXFQKzFBT09CU2NadkVyVm5LSE1zam1Cb1BwRmF4aEYvWkt3b3QyOXl3MHFDbEtiaFFSazBnOHpQbVBsV1U0eGxWaWx3cENncEJXU2tqbUtmUFNwQ0lYYnNoSjAzcjNJNzEwSUE2VFhQWDlxU3h4ejlhNU1UdlhYTHhwT1I2ZEtvZ2gxMk5ka3dBSTVkYWJBMXA0blFaWUdsUmg0OXNzcjV4SzdxNFdrQ0ZPS0lqcE9sTTZBVEZPM0pJZmRCR3lsYmVkTWdrSFdTUWRhV0UvUjlzNVI0bmVLZlFOZ1J6MHFNMm9FcEprK0hyVWxHK212WHhvUzBYZHBFSUppUnBBNTFhc0dGSjFHZzBIaE5VMkh3aktOZkliMWJzcEpBSkhsSTI5S1hJTXRXd2tBRXBUSitWVG15QkVmRUJySE9xOXFRbU1ra1JBL09wV1VwSTBPM0w2MHBrUjNjb1JjTUthY0FDSFVsRUh4NTBEdFBPV1M0V1ZKV3ljcWhBL1dqZ3F5b1RNR09YNzBQOFEyZ0Q2TG9wN3BoRGdBMzZIOUtpWTNIS2czNGN4SEIzYk8wRHkzaDJxUUM0c0hSUjVFZzBUcHd2REZONWN5QzJkaUpuNXpXWTRGaDF3bGh5M1pDWFdGSzBDaVFVbnpnMGRXTnBjc3NnUHJRU1A5Y3pRSld6VEtldEluM1dBWWFpM2Nlc20renVFbzdxZ282K0IxcU1oWlNMWkg0Um1JcDd0aUVGUFhlVHRVVmJqYmJoSlZCSStWUGpHakpPYlpZQzRKV3JUU21IM2twbFFJQTExcUNibWRFYTg0bXUyck55NytOUlMzTUdQdlVUVkFkOWpkbWxUNzd0NFJDVWpJMlNOK3ByR2VLMGs0N2RyU1FGQlVHREZidGlBRE5pRzJobEFFSkhTc1k0aXNVWFRXSVhqQ2dIV1ZMVXRQNGtBN2pvUlF3MUlLVHVMQmF4U0ZYaWMzTkovS2lQREdFcUpReXpuQ2U4b0RtTnZUcDYwTHBkTExnVW5WUW1KL3JXcEtNVnZXN1o5cHA0dG9mVGtYbEVITHpBNlQvS3QwV2tZcEp2d1BiYkQ3ZDliWmR0amFzTGM3TkxuYkpBSjh6eTMyclBzYVVoZUszaFpRRU5oMHBRZ2E1UU5CVERqenJqYUduWGxyYlJxaEsxRlFUNUE3VTN5TlhLU1pVWXRlaVFaUFd1UkViYjE0NmN0NjhKa1VBYUVpdWE3VnNLNFBuVkVGU0FTUEdwbllMUWxQYUl5a2llOXoxSXFHREJxYUpjYlJueUhLSUJLUVRFazcrdERMd2JoU2N0a2kvSjk4dVNabnRWSC81alRDTnhwWGI1bDFjZmpQT2E0VEVFbjBvU1AwVkpoVUV5S2tOdVpZQ2ZpTzVxTk9XUDByb0wxRVJVWkVYbG10T1lTcUlubFY1Wm5QM2s4anZ6b2FzSFJBZ0UwU1dLL2hKSTAvcUtYSU5NdUd0VzlCdnlOU0VLN29uVWpTYWJabktCSW1KazArbFlIeEhTU091MUphTFIwa0FpVHBOUWNTUTBMVjlUNFBaQkJDdFFQV2FrcmNTZmhBa2pucFFoeHRpQWF0aGF0ckNsRldaVUsrSHdvc2VQdktpcHo2cXgvaHppUldHSlVoYVZPTWt5Q21PNmVZTkhWcHhQWlBXNlY5dVNTTlU4eFdJWWZkbHU1Um1YbEJNWm8wOVIwb2tRNzJLd2x5emJXNG9aa3FiWEFjSGhUWlkrdmhGUHZzMHYrMzJuaVF3dVRvQ1ppbnJjbTVJVWRmSGxRWGdXTDJodU96dUxNTWNwVnJyK1ZhTllNSWZZUXUyVWdvalFUL1dsQjJvSndiT3JWaVNDdmJwUDUxWldnek9RUGhUeU5NTXNrYUtrRDVWT1FVTU5LVzRjcVVpVE93cXJ0V0QxclJYY1JPaGpEM2xxVkJDVHIwRkFXRVlRcC9COFhkZFFUMmpTcmRzSGNxV1pqejArZEV1TW00eGU3dDBwUVVXNmxGU0VScXVQdktQSURsVnk3YXBSZytEMjF1Z0pRcDB1S0tkYzBFaVIxRzJ2UFdpeFJ0Mnk4c3VxcEh6YmN0THQ3bDFod2ZhTkxMYXZOSklQMUZORStab3A5cGpMRFBIT0tvdGlrSktrS1ZINHlnRlgxL09oVldwSW10VkdVV2YzMHIyMDdVZzNNZzBwZ1Q0VlpCdFduS3ZjeFhSMjJwQ1BDcUxFTWN6clhKM0VmV3VpRC90U0tBK3RRaHo5NnJTM1NPeVRNYkRmeUZWY0NmV3JXMUFVME1vMEFTUFhLS0NmZzdCL1liY0VPcUJuUW5XdWROUFBhbkxrWlhYQWREbU5NcU9vam5RZ3ZURkpuZjVSU0pOTEVqU2tIajY2MVpDeHc1d2h3VDhKRVJGRStHckpTTllPdkxuUWphbktvSFRUeHErczd0RnUwcGJrSVQxVno4b29KSnNKT2xzSzJsaExhRWhVenlHNXFweFBIYld6S2c4OG5QOEFnVHFyMTZldERHTVkvZE9vTGRvU3l5bzZyMXpLL2FoMElreVpKSjFKNTBjY0ZQNUMzbHRmRUlzVDRydUh3VVdxT3lUK0k3bXFDNXVITGhXZDFSS2p6MS9XcHRwWnMzUWxCS1NOMHpxS2Rkd2doSkxaSmpsVzZIR200M0ZhTWN1UkJTcVQyVkVLQTFFcE5YK0RZcUdHMDJ0K2dQV3F4SXpBOTA5UVJxQ09vOGpJcW1jWlUzSUFrY3dhODArVUlLZFlBN3A2VFNuQkw0eUdxYmU0bW80VGE0TGNCQ0g3KzRzVXFIY2RlUW01WVYvem95bEk5RFJUaG1HUDRaY3VzVzdyYnhiSU0yN21aQ2dSSVVBZGRRUldNNEM5Zk1PWEJzU2g5dHBwVHo3Q2p1Z2ZFb0RxTnpGYS93QUs0dGFZcmd6WXcxMWFuMm0wb3VHbENGTkhVRHpCQUdvckxsdzJyUnF4NXExSUtPM1YyWVc1S1kvRUlxTFp1S3h6RTBzcHplNkJlUktZZ3VxSElUVWl6dFVCc3VJekJmTkoxQjhEMUd0VTF2Z0g5clBMYlFwMVZ1MHZJaHVOVUE4eU9wSTM5QlN2eHUwdm9OWkYxYit3L3N1RVhiMXgyNngrMWN0TUtZakt5b1pWUEpCbnZIOEpPeVI2azdVN2llRnZZZzZsU25CYnNwU1FwTGFSM0Via0E4Z0JHc2Nwb0Rid2ppWGd6Q3IvQUJyRDc4M05nMEE2OWhyaHpzT0lCZzdhcFVKQjAxcUt2MnFZanhKd2ppK0h0NEJaV0FlYVRiTzRnMWVLN2djTUVaVkRmTG0yT205YW9wR2FYK0dTWWpkb3h2R2J0NVFQWjNqNjNVRFlnZmRJL3dDVUNxeTZ3MTF0Y04vYW9HM1dweUxJcVZudFpRcHRTbkVJV0NGQktRQ0RIaUpvaFN3M2QyVE4vYWdkbXRPWWlQaFVOeDg2MjRNY01rWEdYcGk1R1dXS1NsSHhnQVFSMU5lT2xXMkpXelRkMjYyUmxJVVlJODZySFcxSVZ5VU9SRzFacFJjWFJxak5TRzlSeTNydzYxNklJcjBhZEtXeGdoRWRLVFd1bENCWEpISWM2b2dobmVOYXRjT0daZ21PY2ZRVlZ4ckpxNHdsSlZiRTYvRitnb01qcERzQ3VZemRLelB1cU82bHFPdm5VYytFVkt2aGx1bmtiWlZsUHlNYjFIMjUxRUMvVGt6eXB4S1NkQnFhNG5KR2FkZGh6TlNHR1Z2S2xZeW9KMFFQMXAySEJMSzZpSnk1bzQxc2JYY0p0eUVwQVc3SC9LUDNwR1gxRnhLN2tsd1RxZWxXL3VBdWtob0lPY2ZDcEkxcXV2Yko2MXVPemQwVkdoNUVlRmEzeG5nZmIweUxrUnpmRXRHN1pEd1RJQzBFU09rVlZZbGhqdG9wS2tncVpWOEpQS3BlQzNmdTl3bERxeUdGNks1d2VSb3dUaG92YzdUMGhsU2NzajZFVnFmVGtRL1RSamM1OGJKKzB6T1dzN0swdUpNRk94cS93MTRYU0FwSUdkSmdvQTUwdUo0SS9aWEhaT2dsQ3ZnY0d5aFRkZ3k1aDkxMnFRVEI3eVNZMHJQeDV5eFM2dncwNTR4eXc3TDBsNHJoWXVFRnhLQ2xXMmJyNTBNWE5tdHRabmY2VnFWNHcyd3hadkVoVFZ3Rk51RUhUTjkwL25WQmpHRlNzcVJPUXpFajZWcHk0NDVGWmx3NTVZM1RBL0RiaGR0ZnRQdEtVbGFGU2N1OEVRZnBOYWI3SFdWTjRiaTkrRU5xYVE2MHk2Vkl6QktZSkI4QlBPczJ2N0J4cFNWSkE4STYxWjhKY1lZdHd3NjhyRDNFS1lmMHVMZDFBVWwzbHJ6bUpGYzJjWEZPTE9uQ1NuVWtmUnFiWnNXNHViZGFrSTJjUW96QjVLQjNpclBoeXpZYXhKYmhTdjNaS0VwY2VRQ1FGQWd6TVJBL1NocjJUWTJ4ajlzNmxRSUxhQXB4T2hCYkp5a2pwdkVIWTY5S09McXpmc0hzN0RxdTBiR2RwWTBEeloyQjVUeUkya2VOSlMxWTJ5cjlwVGpXSDhONCs3YU9sUGIyaW1uRzBtWVdTRWhRL3dCS3BPdm5OWURZUDJuOTJNVXd4enVMU1E4bFRoaEJXa2dCSThTSitWYmR4d3dNZDRmdkc3QWh0NE1vY1NoUkFTcFhhQWxJOUVtUEhTdm0vR0c1dm4xd1VoYXlxUE0wVi9hSWtYTiswNWVNb3ViZDlVcmJTbC9zeVRPOGxRTVQ1QW42Vlo4R3BiOXpkdDRVR3M2KzcrRDd3OCt2blZWd2RlRHRWMkN6bzZtVUFKRzRtQlBxYTllNXNNdjFLVENRcEtrRStZMFB6ajUxdXdLUFR1dlRuY21VblA4QUd5a1htdXJwVHl0MXFKSW1ZMTJxeXc3REJjMkRtWktjNVdvYTd3T2RjMnR1SWJXRWtoYVpUNGlqQ3d0QTFodHVVSlM0bFNRUW9kWnFzRk50c1BrdHhpa2pOTVN3OXkwY2dpUnlxdThxTStMa2hOMWJqUTl5WTg2b1BjaGNJekpJU2Nzek81bUtSa3hYTnhnUHhadmdwVEtzNmcwdjlSVGo3RGpCSWNUSGlLYXBEaTR1bWFFMDFhRmpVYlZaNFdTTGRYZSs5MThCVldhdE1MVUUyeGtUM2pTc25nL0E2bUxpUUNieTRHc0IxWStScUNweFFVRUpHWlhJVkl4Slg4VStwUWo3UlJJamJVMG1GV3FubDV6cE81NUFVN0RpZVIwalBteUtDYlk1YVc1ekpLeG1XbzZrMFFZZlpKZE1RWmpRUnVmT29iakdSS2NpU011cDVWTHdsL3RudzJBUXRJemF5SmpwKzFkckhCWTExUnhzczNQNUJMWVdDV213bEtRU1J6cE1Vd3h1OXNWc3FDUXM2b1dUc29EVDlCU1dOOEVsS2JwTVNZQ2dOUFhwVnhtU3B2TUFJVnFQRVV1ZC9ZbUxyYU1yZXRYTGQxVFR5TXJpRENrN3dhTHVETVFVNndxeWRNcmFHWmtubWptUFF4Nkh3cDNpYkRjNEYya0prREtxRWErQk5VbUZPSXRMbGxaeTkwenJwRlkxL0hQUjBwVm54LzZHNzFxTDF4RnVyYktWZ2Nwb1d4cG5zbHlFa0tPOC9sUmhhd3NCNXZWTGlZQkhJYy8ycXM0bHMwdU45dVlTaGNBcWpSS3VSSjVBK1BPdEdSSjdSazQ4bkY5V1JiRjRYL0NkeGJrL2JXRGdVREc2REd2eW1walRhTG14Uzdybm5JdnpnUjlLSHNEZExOMjgzcGxjU1VPSi9FZzdqMHEyd1c0OTN2SExKNGtJV3JJZkE4ajlSclRNTXU4SyswQnlNZlNkcnhrVzh3MUdwVXRLRWt3Q29VSVk3aHlHRkJ5M1dDU2Rjb2dlbGFlN2I1WVM0QUpPbWsxQnZNT2F1bUZOdUpFSHcyMW9ja1ZPTk1yRG1lT1ZnejdLK0wvN29jVU1YYjRWN21zOW5jSkdneXEwVlBVUkI4MHBOZlYxdThtK3RPeFpTemRhOXN4S2lsS2trYWhLdVVpQ0srTXNjd3RWbGRyUXBNSitsYXo3SE9MOFNhd1ZWaXE0YVc1aHhDV2UyUm1sb2c1UUlJTUo3MzBybXRPTHBuWmkxTldqUXVKMm1QN0l1OFJ3cHE1SnRQdEwyekJCY0NCOTVJMk1IZnBxZVZmT3Q4QzdjUExDUWxMaTFMQ1Fjd1RPdjYxOUkydU51WFdLbTdjYVJiM2J1dVpvUTI0cUlJeWtuVWp4ZzYxa3Z0UzRidGNIdmtYK0VwTFZoZk9IUGJCUGR0blltQWZ3SzFJRzRnam9hRlUvQTlveit5VXBpK1plU3BXWnBZWHBvU09ldmxSaHhoWmh6QzNMbG9SM0E0bnhIVDVVNXdHcGtxdVdIN05Gd2pzeTRwU2dOQVBIeDVlTlhXT0FPV2QwRndBcEt6QTJRSU1KSGxwV3JqL2ErakZ5NnVMK3dJNFRVbTlzdXpKaFRTaVV4ckUvMEswQTJxVU5wYkNVd2xJQUlGWmp3TTRwckdDMUF5S0FXUk1iZjF0V3NZa1UyeVZyUk9Vb3pvOVIrOUZoOHNEbE81S0tNNjQxWktyNUswa3FTRUJKTVRCSCs5TVlMWjVySWtpVlo0bURyQTFINVYxajF5UTgrbEpDMGt4UGhHL25WL2dUVFRHQzJ4SnpMV2t1UU5kVC9Rb3NEL2s3RmNoOWNTaUQxMVpqczFGZXFkaUNOVFEzaUZncGdkbzJGZGtUQm5sV2x1MkxMcFUyVlBTTnlHWkh6TlY2OEt3NHBXMkw2UXJ1bEMwUkJPM0t0ZWJGRExHbjZaT1B5SlkyWnFPa1NLdGNPVmx0K3NtYWpZcFpPV04wNDJwSlNFS0tUemcxTXd6c1BkRTVzNFhKemRKblNQU0s0T2RPQ3BubytNMU4yaUZlaWI1MXBSRUlXck1aME1IclYzZzZXMXBWMmFrcldrU1VqVStHbFUrSUpDYis4eXhsN2R5Q0RPbVk3Vk93TlNtMlpRUUZLVnIrbGE4R1I0M294WnNmNUZzczNDcmNwMW5iblVHNTdXMXVVdXRISXNRc1J5cTZCUHZEUU01cDcyay8xdFRXTVd3TFNDQW44SlVOdlhwWFFXZFRYK21CNFhCL3RGblpLYnhHMVM2MENGSDRramthZndpK2NzcnBWbGMvYU1UT2NBbko0K1ZDM0RWMDViNHN5eWxVTnZyeUVIYWVWWGVQNHU5YjJ5VjJSTFNBcENrTDJVNFNyNGo0Uk9uem83VW83RVN4dFRwQnNwbERpRHNwQ3VnM0JvRngzQ2xXbDZsQW5zMVRDenBJL3dCdDZOY0Z1RVAyOXM3R1ZxNFJJZzZJVU5DUDY2MUl4UzBMdHM0M2xTcFFFb244UTIvYjFyTGtoZW1PdzVIQjJVL0RicVdRaGhSSFpxTVRPazFmWE5tMDlidU12b0JhYzdxaDRkS0RMUzRScVZaMGt6M1FKUDhBdnBSbGc5K20vdG9jVERxVWcrWTZ4K2RTRXZvUExEZlpHYjNGbTloT0tYRm9zcUttU1NsVWZHamtmVWZyVWU3dlF4aTRLZE02UXRKbm5XaDhUNFVMNjJOMndrRzZ0VVNrL2lUcktmMnJLTVdTb0xTNG5aR2c1UjAvT2dVM2dsYThHcExQQ242YXZiT0crc3JZczk5eDRBRFdwSHU3REdqcXUxSjVKRUNxRDJkWHFiMXEzYW1GQXFTUURzU0NCK3RGOXFHalpFM0lNTTZtRHY0R3RVbmIwYzlScjBDK05MQnU0c1hIRk5kbXBLTTdaNmloVGdPNDl5NGloMXdvK3lYTUhSVUNRUFd0QXhjaS90SDNuVWtybmJ3amIwck4rSHJOKzU0cXRMWnBCV1E3S3N4Z0pTSktpVHlBR3MxajVNZkdkSGh6dE5Hdkc2TmxpVnRiTnZISTY0aWRkUktocUR5a2ZRMEFjUzhYM2VOMktiRnhwbG0zYmQ3UldVNTF1S0VnU29nUUFDZEIxcVR4cml5VUZoT0dYVW9XbFdkYVUvRWtkMEJLOXdtQjBFNzdVSTJyYlNuMEc2N1ZOdW9GSVUyUHZRY29COFNLeXhSdGJOUTRZdE94d3RndUlBQ2tCY3FTRXJTb2ljaGpjRGVkNmE0amx2Qjd4YWptN3NtVC9xU0tzOEphV3paV3picWdYQTJoQ2lucUJyOWFyT04wcWJ3WnhwTUhPNGxKbnpuOHdLM1YwVkhMY3Z5VHRtWjRhb3NZd3k2azdLTXhXbzNWOGc0RmJxbk5sT1ErS2Q2ekswUi82UVQrL09pRzB4SXJDY1B1RkhKbGdTcmZtRDlLR09vT2hzMWVWRmJlc2x5OFUya0ZTU29KQUZINHNEWmhsZ2lFb1FFZ2N0cXBPR1dBNWk5b3RLUUZvZHpLSElaZFQrWHlORytJdGRyYmo4U1RBSXE4UHgyQnl2a2tpaHV0QWhjQUVrSVY0enNmblFiaXExM054ZG9Rb0VKVmxHdWhnL3lvbnhkME00Yyt1WktGSjUrSW9Wd0llOTV5czkxeDFXazZnVnZUclpoUzlZN3hGYUplU2hTa0NGdEpKa2M4dEROdTEyS1ZKV0Q4V21uS3RKeEcxYmNiWktsQkNBZ1NwV2dBR2xaOWZMbDFKS3dORG9Cb05UWEw1c1ZLS2E5T3YvemNqaktuNFYrSXdxNWZVZ1FoVGlpa0F6cG1xeHcwOW5hZ2lBYzI5UWI1djdaUmdEdnFFVHNRZHZyVTIwVERMY2dnNStXOGY3MHRMWTF2UmIyeWlwYVhGbElSSkhqRy93Q3RXMk1zZ1lPVUVsU2dBVmEvZUlraW9MakVOTm81N3FubFUyNmRXOWdwV3NkNTE1YXdCeUFTRTB6d1g5Z0Vwd3RYRTVpRkJRVWxYbFZ6eHJjT0tmWUtOTGU0Vjd4bDVCZjNvOHpyNTFTWWdnaDNNUVJ5anBUOXk0cC9CR1dpVktTeDhJT3VYV2RLdFpYMWNXVThTN0tTRERnZkZHOGlyQzZWOWc2cVVuLzJhK28vV3RGdFZLZWJMVHVqN09pdkVjaU9vckJzTXVWTVBJV09abXRnd1MrT0k0VXkvYnIvQUkrMFFNdzVyUjE4ZW5yV21NbE9QWXhaWWZqbC9oRXgvQ0FpNzk4YjBhV2Z0aGxudkhaVk4yL2FXcTBLYm51bVFkeFJIN3czYzIrWkFpVXdwdFFuekhpS3BIVyt3ZExabnNqcWc5UE1lR29wYlZiUXlFKzJnbXRydEMyVVBJTXBVSkk2SG1EUUJ4eGc2V2d0NWhJREtwSUErNTRHaUxEN2dXOXdVbHdGaFc4Y2oxcXd4UzJSZFdialFQZFdraVNOTnFKcnRFRlMvSEt6SitDY1JPSDR2QlZBM2oxSDlmT3RYeGFUYnJMYTBOdDNKQ2s1akFCNXBQcldKUEpldy9FRXJ5WlhXWE5VbnFEcUQ5YTEreWZieFBoZDlUSlV0dGJTVm84Q0RyNmpXcGduY2EvUk9UQ3BkbDR4dkRpYlc4UzFjdEZLWEJCSElqd1BPcyt1TGQxbmlrMnlDb3ZPT09XeWRkVkhNVTYxYVcyTXYyR2V5dXlwNjNDdTZTZSszNHBKcVp3MnlNVDQydGI3dFJjQzBTdTVjVmx5cW5TTXc2eVI5YXZsWS9qWk9HNmxSU2NWdXRyeFp4aTNKTE5za01Bbm5sMEorYzFPNEZzRGUzQ25uc3h0cmRZZUtDQmxVdlVJQm5mYWRQS3EvSDdYTGk5ODNicUJTSENPNk5BU2RvODlQT3RGd2ZEUDdKd1MzdGxRWGgvaUVuWlc1U1BBYkNzbUtOeXMyY21mV05MN0xLeUJjZWlUcWFvK1BYRXhib1ZKSzNGUkIyaVAzb2h3d2Z4RWN1c1VIZTBRa3UyeEJJaEtqSHIvQUNyUmtkR1BDcmtpaXd1elNxK1NWUkNjMEE5U0RVSGlObHl4dkxSOVB3SHVqMHEvNGJMbDJXMHFFcVFTb3E2d0RwL1hXby9HdHVsVmhhRUpBSGFLVE16eS9yU2h2NE1ZM1daRm53VSsyckVYMXozMU5CU1I4Z1o4ZHFNbjNPNGNzRUhXWnJOUFo4L2x1MUJ3d3BLWU03Rk02bjYxb1R5aUc5ZENQclI0OXF4ZWJVcUEvakowSXd4N1g0MUorV3RVdkNFZG0yU1BoekdwM3RBMHc0NjZBaXEvaGY3QzBaWHVwd0hLazdIVTZuOXVkTzdwYVlxTUc0YS9ZVTRxNmc0VWxNa0xDa28zMEpKQmp4b0F4QVErQWtRQVB3NzZuV2pkMXBiMW84M3F0U0ZCMVVSTXdkZlF4UWp4SUV0WFZ0a1Rsek1KVWRkekprMWg1RnlWblI0cVVKVVBLdDArK0FGQ0QzakdrZ0U4L3BWcXhockw5N2JNcVNFZ09KS2dubkZRYllGVjgzbU82cEIybWlERFVrNG9uVWQwYkR4cnBPRWV0VWN0NUpLVnBqZUoyaW1HSGlnRnpNbk5JSFRscFNLYjdQQkdrckdWWFpqZnFkVFZyZktMYWlyUk9tNEg5ZUZkNGd6bllRMlVrcFNoTUVENFRIMUZaWllkWEUwUTVPNmtaWGlHWW9XVkRLZEpKQjNybXdUMnRoY3BHcEF6RFRVVVJjUjJvOXljT1h2QVRvSU8vT3FuaFpvUDNidHNWRE0vYnVKVC93QVdXUldWcHFXemVtbkcwVUxKaEJIUXpSanduakRtSFB0dUlVTzZvRFhieVA4QVhPZzhnb3VGcE9uaFZuaFM0dW14b1FWQ2FkeDUwNllqa1E3Uk5rdUdiVzljUzVhdkMwQW1SMlprR2VzMUV2OEFBZmViWlRSdldsYWdnek9vNmlxKzNjaEFVQ3J5cWUyL2w1Z0hyL0t0Y282bzVrWnBPMTZDclZzbXl1Sk44eWx3YXgyWi9lam5BMW91N0ZRTVpteE1jbERsUXJpaWtzNG9rT2hLbVhwWE8wVCtmODZJY0VkUmF1TlNFbGh6dUtJUHlJclBGOVpVYnAveVFVZ0s5b0dFRnU0VmV0STdxOVZnY2xEYytvZytkZCt6ZkdCYTN2dUZ5UjdzK1NPOGRFazZINS9uUi9qZGxiUHNFRkJLRmlDazZpc2dRMHZDOFVXMnNUa1dVa2JtT1IvV2htbkI5a1RFMWtqMGw2aTE0dnRGWWZpRDdLeVY1VEtWRWJwT29vdDlrVm10dkI4UnZWSWhGdzZsSVVURVpRZXYvRVBsUXp4YTZjUXd1emZCenVLR1FRRE8vd0FQNitzVWFyV3hoK0dZUncwd3NmMmprU0hnUCtpS2dGTFdZM0kxZ2NqcWRxSFBOelNRM0JEb20yVWVBNFFjUTRxdXNSZWJIdVRMNmx0U21NNjl2VURmemlqSi9WcHNubXM3ODlCclVpMWJiUUFsdE9WcElBUUlBOWZQblROMmdCTEtaRVNwVWVvL2FqaERxalBseWQzWjNoWSszRTd4OHFEZVAwOSswV1A5UUh6UDZVWjRlQUh6QjF5a2VSaWhQalhJNDZ3eWRTbEI1ODVOU2ZoZUQreUdPRHhGdWlRTkFwSlB5aW5lT1dGTHd4cFNKS0E2RkFla1Y3Z3dES1FWRWpMcUNkVHFLdE9JR1Fxd0NBcWM2dTdJMk1mS292NmhTMWtzQk9Cd280MnRsUUVyWmNTTk5pQkkrb3JRaXN1V3FWNjVqQmp4NTBEY0xvREhHTnVsVzZ3c0NlWGROR3pDcFpjUnRCNStORmc4QTVLK1FHY2ZLQXc4QTZ6QTA4RFZQdzY3bXNBRlNyTDNRSWs3N0RydnRVLzJocWkxYW1KS29FYzkvd0JxcmVGbE9Oc3JjUnVsYWtqckJvTWova0c4ZVA4QUVHV0JxVmNOWEpVa0pVV1ZKSUIxOGpQUFNoYmlzTDk5dG8yOTNUOTZkSlZGRW5EMlJoWlU0b0FMSGU1SjMwaitkUU9NN1ZDY1RaQVFTT3dFSC9tVjQwak0vZ2FNS3VaQnNKVmVDWWxLamxBTWdjdjBva3cxc0plUStOQVlueG9jdzVPUzlEWjNFZ25TakxERVptWUlycTM4VWNlYStaMWV0cFdsWm1JVW5YeGl1NzlTb1NVaVkxTmVkSVUyc0tFcUtralhucFRxd2xTQ0lHbW11OFVzaktLN2JhdWdzQkFVdU5VbUNvZU1jNm9NSXRFTmNRSWRRM2xLVktXa2JDWU5FVjVhaGFzN1VKZFRxbFV4OWFad3kwY3VNVk54Y1pHd0V3cUZEdks4QjQwWFdMVmx4bkphUm5uRmR1TFhHM3V6L3dBTmZmVHJPaDVVemhibVc0WlZtT2loTWIxY2UwRnJKZXRyS1lJSlNhb3JBQTNEWTZrVmhsSHBscEhUaEx2aVRacUZvb2RnbEpUdnNuYzArbHpJNU1FK1lxdHQzV3cyRWt5cU5PZGRydkxORWpPNHRYV05LMzAzNGNtdGorSkJONHdrTFRKU0RsSU95djZGUXJGOVZ1U3doSnVPelZxMmh4SktldEtyRUxWUUlRNjRDWkV4dFZOaUNNOXloOXBTUVZraFJTU2t5QnVlV3RaODJOK3BHemp5WDlaTTBTeXhORjFhL2FCMXRZR1g3Uk9YODZGdUpzT1lkVUhzMGxSQUNoeVBqMXFydGNldkxKMUlUZWQ1QmdwZFVGQTlRZWNWZVloeFJaKzZOcUZ0YlhEem54Zis2bm5BME92aFZRbDJWTWs4YmpKU2lENkZ1c290bXJjSzk5UVNHa3BCVVFza2Q0QWI5UjRud29oNE50RzdmRzd0dDlTaGZNMitZb2NNTFVWSHZxOGVoNTYxUzRhcFZ2aVdING10UlNXM0hFb0IwQ1ZaRGwxOGRhYXdWYnJ2RmxvNmh3bGJUaWxMV0RBQ2VablhRenRGWm8vMnBHMmErRE5aWVpjeUV1SnloV210Ujcxd2RxQWdnSkdrMDIzZnRxUUN0eHRLdGdBdnRGZlFhVjIwMDI0b3JDWG5GSGJOb0sxSFBlL0J5MTdyaU5JQms5VE5CWEgxeUJqbmNJVVVwaFVlR2xHcFNVT2hhNENVNm1QcFFOeFZhbTR2M25HVUZSekV3VlJJT3VsS21QdzZleXc0UlFuM2R4Uk1FQ1lqbWY4QWFyVEh6L0FaVXFHWUtPNTIwcUZ3eTJFMmk4MmtaVW53MCtkU3NmUDhNZ0tqTHJKUE1DaVg5UVpmM0F6QW5NM0Y5a2N4VVFWNitJUVQrbEdsd3NNM0NzeDBXTkFQeStkQWZDc0o0MHM1bFFVdGFkTnRVRUNqM0ZvUXB0d3dvaVB6cThUcEZjaGJNLzhBYUc0Rkp0MHlJSzgwZWhxdjRaS3V6Y0FWckdiTG1wNzJnT2h5OFoyQ2dGSFR6SXJuZ3hhQTljRnhLSURjQ2ZpSlA0WTIyM3BjbDJ5ME94dnBnc0s4SmFBSGJ2d1drRUVDZmlWMGlxemkyNkxtSU1xS0RQWWovd0RKVldsaGNsNWEyM2NvVm1rUkh5RlZYRkRLRlhsdW9tSlpHZy80bFVmSnhySGoyTDQyWjVNMWpGcGMyL3Y1aGFDVUxWbEtVNVJ5L25SamhhdStNcFNVUnkxaXBiM3NkNHlUZkxmdGVGTDVLWTBRdTZzbzh2OEFIODlmcFhtZlpiN1NXWGl0cmhtNlJySWk5dFAvQURxa2M2clpKOFdUZG81V2hDbkFJNWtrYzVwcFFrUVZhUUR2Vit4d0Y3UWxOWmJ2aEs3enhHZHUrczlmbTlUNk9BdU9RU2Y3b1h3RS93RFhMSTZmOS9SL2xnMTZLZkd5SitBa29DU2toWFBuVURMMkZ3RkhWQjBuZWpsMzJkY2F1S3pIaFBFQVpuL05XUi8vQUwxR2U5bXZIVGhnOEozcWdOaWJxekIvL2VhS09hSDdCZkd5L295NzJrb3oyOXUrQU1xaU51c1VHVzV5bEIva0szVGlYMlVjZTR0aGpOdTN3cGRJY1F2UEs3dXpnYWY5dlFzeDdDZmFVZ2pOd3d2US93RFhyWC96YXpaWnB6VFROM0h4eWpqcVNLRzJ1QStscEFNSkVaeHBtVWZBZEtJV0xWQUFMVm5uMDFVNjRCOUJWcmEreFRqek1udCtHN29SdVJjMlorbmIwUTJuc3U0eXRrWmY3c1lrbzlmZUxQOEFMM210YXo0NjlNaytOa3UwZ1BEZHprQ1F4YklTT1NEL0FDcHQ5S1ZzbHR4Z0VhaVVuOXEwQkhzNzQwaUY4TFlnRDFEMWtmOEF4TklyMlo4WGxLbzRjeElLNUh0TEwwLzlacW5uaCt3Vnhzdi9BSk1ldkRaTkFKdVV0T0tRTzhIQVFRUER3cU90ZUZGS1JhTmZhaVZuU0VtQnRycnpyVDhVOWpYR1YrdGx3OE5Qb2RIeHI3YTB6UkgvQUc1R2g4T2RWbG43RXVQTGQxK2VIYnRTQ2hLVUVYRnBKTXlUL21OUHJOWmNtUlhvM1k4Y3ErU0JuQnB1N2xsaENzelVqTUNrRUtBZ2tRZDloOHFOYkhCOE43YnRtTGR0RHU0S1JvZWV4cWJ3NzdKK01zTnZWT3Y4TDM3aUEyVUlpNHNwa2tTZjhmd3ErUndMeGkwc2x2aFRFU2ttUVBlTElSLzl4UXdsRmJZT2FFNVBTSzNNRzA5eERVeHJMWUg1VXk1ZXVBRUV3a2JoQ1ltaUpmQlBGaTBITndwaWVZaVA4elovTS94RlIxOEJjVnFNZjNTeEx6TjNaZlAvQUI2ZDNoK3hEeFpQMFU2VnBXZ3BTRkVubVRKb0t4MThPWW02cEF6Qktzb0hTT2xhYzF3SnhjMkFSd3JpV2JmL0FETm1QL0VWUk8reXZqTjQ1bDhOWW1GSFU1Yml5MzU2KzhVRG5INll6SGptbmJSVGNOTDdLMGNMNlpTRmpMR2hBTXg2MXp4SGN0dDI2RUV4MnFpQWxYUURyUmhoM3M0NHR0ckF0SzRieE5iaDFsVDlucWYvQUlnMUF4djJhY2E0Z2x0Q09Gc1FTbEFPcHVMS0o4dmVQMXFsa1ZVWCtLVGxiUmxHRW9MSEYrSGQ1T1lYQ1lFNlFUL09qM0YzZ0VKS1NSRzJtbnpyaXk5ai9Iek9MMjkwNXcxZGxwcGVlUGVMTWtSc1A4Y2RLSkx2MmQ4YXZONVJ3cmlVNjYrOVdRMzVmNWlwSEpGRXk0cHkrakMrTUY5cmliYWhKK3lFR0k2elhlQWtXNUJBMU81bzl4ajJKZTBHNXVtM0xYaG01S1FtQ0hMeTBUcko2UEhsVGxoN0dmYUd5Z0pmNFZmTWE5eSt0TmZEL0dwbUxKQ00zSmt5WXB2RW9wRlBaZ0Z6Tm4wQTBnMUQ0b2RjRjFhNmErN2ljd2cvRXF0RnRmWlp4b1NSY2NMWWdBb2FLRjNabktmKy9xQnhCN0llT3J5NlpOcHd2ZUZ0dHJKSzd1MFRKektPbjI1NmlxNWVXR1NGTFl2aVlNbU9mWnFqLzlrPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvRXVsZXIuanBnXG4gKiogbW9kdWxlIGlkID0gMjk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQjlBSDBBQUQvL2dCQ1JtbHNaU0J6YjNWeVkyVTZJR2gwZEhBNkx5OWpiMjF0YjI1ekxuZHBhMmx0WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2t4bGJXRnBkSEpsTG1wd1ovL2JBRU1BQmdRRkJnVUVCZ1lGQmdjSEJnZ0tFQW9LQ1FrS0ZBNFBEQkFYRkJnWUZ4UVdGaG9kSlI4YUd5TWNGaFlnTENBakppY3BLaWtaSHkwd0xTZ3dKU2dwS1AvYkFFTUJCd2NIQ2dnS0V3b0tFeWdhRmhvb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LUC9BQUJFSUFVSUEzQU1CRVFBQ0VRRURFUUgveEFBZEFBQUJCQU1CQVFBQUFBQUFBQUFBQUFBREFRSUVCUUFHQndnSi84UUFReEFBQVFNREF3RUZCUVVIQVFjRUF3QUFBUUlERVFBRUlRVVNNVUVHRXlKUllRY3ljWUdSRkNPaHNjRUlGVE5DWXRId0pCWlNVM0tDNGZFMFZhS3lZOExTLzhRQUZ3RUJBUUVCQUFBQUFBQUFBQUFBQUFBQUFBRUNBLy9FQUNRUkFRRUJBQUlDQXdFQkFBSURBQUFBQUFBQkVTRXhRVkVDRW1HQmNWS1JvZEh3LzlvQURBTUJBQUlSQXhFQVB3RFR0VnVVOTY4Z1BLTUw0Q0RNVmxyeW83aTZod2JibklFRTdGVlJEVmRyS1REcUNFanJ5UlBURkdkUi90S3k0b0F0TENzQXpIV2FMYWNidTRLT1FwUk03UXZOVkNmYlhJV0ZJWFA5VlRBWmpVRzlrT05IYkprQVptZ1k1ZU11RUFrcDNHQ1pWNGFBYVhiZEtpcnZGVGtZT0tvSWt0bFJCZFdERWMwQm1ta2pJZUlTb2M3Wi9EL09haXEyN1pCU0FDVkVjeWt5S3FFUTJFQkpiVUV4bFJnOEUwQzl6dVVTWEVnZ1NJSkorTkJJTEswcUEzaUFtUkJpUG5RR1V3dnVKS3NLbUFJejFxQ01sS2tsTXVnZW1NMVJndVNDMkV2SlZ1eHQzQ1JtSXFCWHRUS2s3QW9KVU15QUp4NmlnQTA5Y1NGcWVVQkhBVU9Lb01seTVkVVB2VkdPU0NUbnlvQ0Z5N3lKVkFQV292Z3hLcm80VVZBbUJsVkVFKzAzYUV0aFNsUVJnWkZGbnNKeTV1Vmd3cFlIKzlKb21HSnZMdmJBSkFHZW9IMXFoN1Y5Y29Xb2h4UWtjN2lZb2FLblU3bElJKzB1RFA4QXhWQ292TFl0VzB1OUZ5NHBUQjJsVWJoSXFLcFhkUHVrSis4WmRTUG5uMXFwa1ZyOXMreW80ZFRBNE0xVEVKd0xUQ1J1QW5JVUtJR0hWaGVOaWlBWndLQnd1SEFrUWtneDBtYUJ6bDA2a0FnSHBrUmswR0p1aUVCUlNEUG1rR2dRM1NZS2xCRWxXUkdLQlZYYlFXQ0EzNFFPRE5BOFhhRnBuSUkrZjBvSDk0T3BjZytaeDhxQlV1d1NBNG9HT0NQem9EdExBVW9iOW9WL01BYUE2M3kyWTM0alBKaUtMNFFMdlZsTnRBSlVNWXdUUTFUdVhsdzhrcVNURXhKTVVRTkNIWERBM0UvZ1I2VUV4alJyMTlQaHRuVjdpQUFrSFBwUVk1WXVNcktYYmQ1Q2dZSVVraUlvSmx0WXVORHZyTlRwRThBQXg4Uk5CWmFkcUNYSFExZHFTMFlncUtZQ2o1RWREVVdKNkVKN3ZiNEo1T1RSY01lQ1ViSjJGVUhnbWVlYUhUQ0M0blp0U1QvS1pFVE5EVEYycksxRUVHWkJLUXNEanBIeG9seGkwTnROS0FBTzZlditUUlJOaUU0KytIeWlnbTZocXEwM1MvZVNpU0pCUDBvSzEzVzN4aGJqNGpnaFh4cGlhalhPc1BPTkpTcDF6T1pVWjY4UjVWVFVSZW9sYWZGN3hPUXBBSWloYVkzZG9WUGdhZzh3bWlDcHVMY2lGMnlGcTRFRWljMEdPcXNWSU82MmVTUkpPMVF3ZnJRUjFzMlNnbUZ2VC9OdUg1VUNwdExSU1ZTOGY2UU9mS2dqRzFoU1MydmNZL3dVQkVXYXlrbFJCSXhKb01ES3lJOEVKTVpCSFhQeHpRRlRiS1VWRXFTVHQ2S0E0b0NOMmpvV0ZvZ2llSkZCRjFOYnFTUXNrayt1UG9EUVVTUVhYQWtrNU1Zb080ZXp2MlFQYXUweGRhdWxiTnFVbFFSMWpFVDVWUjJyU2ZaZDJmUWxPelRtVnVsTzN2Qk8xUDhBZXBodnB1V25ka2RKc2tIdUxWTytJbmJQd2lyRFVEVk96R2ozRGEwUDJMQzRFKzd6VVdWNXU5dGZaVm5zN2MycittTjkyeGNFd3RKTWc4a1lxTHJuZGh0ZUttdFFKVURnS2tTYUo0NUdaV3RMdmNJVXBhZ2ZBVkdDUlFIV0x2dkR0YmRnRElCbWhwaXplZDJSM1Z6SHducjB4bWhvS1huMG1JY2lZVnZiajhhdUdzTjBWUURBVkJ3VWltR2lGMG5IbGppWTlLWlRVL1UxSUR6b0taUnV6c1h5S2lLeHdJMmtxUTVJd0J1bXFBdUlTVTREMHhCM0RrL1NnaktiU0ZIYzV0STRDazgrbEExYlNkcWpLTjB3UENSMDlLQVJiS1VLOTNIa3JOQVJERG9sVzFSRUdjOWFCaXQ0YkpBVkpnU1JRTVF0YUVwVWs3a2hXUWZPZ3hMeTVrSEo5YzBCa1hLa2toUUJCeU1mblFLYmxROFFHZVFUUUZENlVORUtCVXBZOTM5YUNZbTdVRzArOUlFeUZITkJRYXRjcWRXcko1eFJlR3hleWJSa2ExMjNzV0hrZ3ROVGNLQjRKSHVqNjBoTWUxdExRaTJZYmI4SlhBeDErTWNmV29ZdjJENHRnbGF3bUNUa1R6eFd0UDRtbG9GTUlUd01rREZHY1YxOHk2aEJVbktSejFNZWY0MDVWeWoyeWFLblVPejdqTnl4dVVsYVhHOXMrQlE4ajBrWVB4cUxIbWZYMkhyRkNZYUF0eVlhZExZRzMrayt2cDg2RlVyMTBwQzJua1NrcHlQUTlSUlZzM3FqbTFDdHFpa2daU1pCcVltcGJldXZEQ1F1WUFCL3RSZFNHKzBycUlTNFRQd0J4VjVPRWhYYVczQUVvUktqdHlnQ2Y4aW0wNEYvZW1tcUpMaktDcWM3V0pwdEZacXFySVB1L2VLU2ttUGQ0RThWRTRWemlMWlNTcE53UU9KTlZETzZRb0RiZEpHWUdmem9HS2Fja0h2MHJIQmc4VVUwb2RVblBkbUJQeG9pT3BDLzVXa0tBUHlOQTFlQ2tGcGFZd29oWDZVQ2hSQlRsd0RwUUlsNGxKeXNSaktKb0VEZ01rcVFZeGxNVUJteTFzRWhyanJQTkFRSlFzRk8xb0hrUXZpZ01sTFlWQlFueENCQkhRMEJIMU43RnFMZkNTQ0FlRFFhdGVLKzlWeVBuUWRoL1p2c20wNmpxV3FQclMyMDJFczcxd0FuK1ltZnBVdGtXUjZtc0dFSVdtNWpmS053SjRPS2RxNWwyeDdZNnRlOW9yWFROS3ZYckN6U2dxdUZXdHN0OTFDandwZXdHQkg2MVByOWpXeDlsdXl1dFhsaFo2cHBmdEl1dFdkU1FwS1Z0Sit6TEk5NUNrakk4dk1lVkpQaDRUYTZiYXVQdldxUmVObHQ0RFk0bVpnOVk4eGl0ZEh0VTZ6YXRYRm80MjRsS2txU2RxVmpsUUdCVFNQTVhhM1M3dTBWY1diTm9zaDFXOE5KQ1NoWVBHMEs0STlEVEtya0Y1cHhOMCt3ZzdMaHVkektzYnZVZW84cUpkSDBkTGJ0cUVPQlpjU1lLUlBGQ0xYN3BJVHRiVWtwZzdWQW5jbnlOUlFPN1R1UUFGYnVtMmljSEp0RTdDNDhwd29CeHRTSm1NZkNpOEY3bEMvRVFvejUwRm5xV2x0L2FWaE53a0FLNFZuRkV4VnU2WWdFanYwUm54QXp6NVZVd0JlbFFxVXZNQ2N5U0krZEZ3SmVuTFNRQjNhdjV0MUNzRmcraEVKM1FyeVhORUNjczdoSFJRd1JQK2VsQU1zUEplVW54RGNUSklvRmREb0NnQW9vNTZqTkFFcGZBU05wZ2RJb0ZTSHNGU0p4a3hRRWJEcEk4QkpHVDBvSlREU3lWRXNnaUFUSkdSNS9HZ0lHVDR2dXBLVXpCUGtlYWF1SUdwRkxMV3p1MUpVWk01aUtJMTF4WGpVWnhSZXUzUS9aejJmdjczZmNMYlc1WjJha3FjdDB2QkN5VkNaU0ZRbFNvVHdTS2xrL3F6aDZKN085cjlOMGEzMGhMRjNxV3U2YTh3cTRiK3hXamp6N2FFbUZKV2hQdXdjR2VEak5NLzRnbXMzcnVpYUZZTjZOZG9idmRUY1ZkWFQ0RzFSY1duZUJKNE9RblBBRkx5WWgrek56V2U5Y2RVOC9wK3U2NWJLdWxOL1owclpiTFNrcExxa254RnlGaFBJQ29rOUt2MTFMWFJHOUE3WTNBM0gyZ09ONG1HZEdZU2YvQUpGVlhQajFkLzduL28zOFI3L3NsMm4reWszUGIvVkh3aFNWd2l3dFd6QU9ZaEhOVDYvSDkvN0phMWQ3MmNNYTRWMjY5YTE2NDFBTkZZZWZ2STJLNkhhRWhJejBpa254OUxlbW05dGZZSDJndXV6Nk5SWjFHMnVkYXRtU1YyeUFUM3hFbUVLSUJtT2g2NG10U2ZIcG5YbmRGeVcxb0lRdEppRjdSQkovdjZWbHFMVkx3ZGFRVWh3YmVtN3JOUUlYalB2TEUvN3FwelJEa3ZyM3BEYmp5VWJpVkptWkJFQVo5WW92S1dIZVlrd2VURTBGanFPcGtQbmNoa2tuSGhGRTFXWFY4cFpQZ2JBNGpZS0dvN2o1S1FGSWJnWjhJelEwOHU3azUyQWpNUkpQNDBMVDJud2s3a29SdXlUZ3hId21oTVBkdUFFYlYyelpSekJKeVQxNW9hR1gxdUtLbldHZ3FBTVQ5ZWFHOHM3OHdBbGxyYWt5Wm1mem9hS0hRQnY3cHZkOHZuMTllS0hHc1E2RmpaM2JRVWV1QkZDY3BEYisxQ1NDMGdkQVNEenowb29aZkJKM3V0d0FNSkJrMERWdmJsclVqdkZEUENNeDA1b05jN1JMVXBaS2Q4VGpjZUJWRVBzaU5QVjJ1MFJPdHJTalNqZnNDOFdyaExQZUoza3gvVE5PdVN0MGV1Mms5ciswV24yTGo3V20zUldsbHhRMjdFaFJBY0hUZ21ENUdwK240OUFleEt5Um9XZ0hVWG1TMDVxUDNyVFpuYTIwQUlLVWtramNaV1JQS3FwVzYzbWx1czI3NkxIVFdOYzAxYXk2MjBoMURiMXFwV1NueDRVaVpJTWdpWXlLYnp3bitqOW1OUDFHMjFKL1ZkWHRtTGU4ZFlGbmIyN1RtOU5xeE80aFN1RkxVcUNZd0lTS3VYbzJOeHNVQmtnKzhvOGs4MFBZN2puZUkycTJpU0VrZVZGa3hBdEVoaTlXNDBsQU8wSk9QZUFGUHhMMHVHMWtwU0ZncFdSTUg4YWcrZnVwMmx2ZTlzTmZkdHRpTE1YOXdwQ0VxZ0ZKZFZ0QXFhdUVVd2x0Ujd1M2RXUDl4THdubnAwbWdFcTJhVTBoeExWeVVuY0FSQnpQQjlSUU8rd3RuQSsxaFVFa2x0Sm1nS2JDM0VCYTN3Zkx1NkNKcWpiNGRWdU1ra2ozUFdxeWdibEpWbElVWm4zZVBPYUFDbnlDZHphQWZwRkFFdnJLMHlnWkhuRTBCRXY3Umx0QUU4RTgwQ0t1bGlaYlNyalBOQTAzU2lveWdjbVRRS2k1SkFJUWtFR2dlWDFsWkpRZ3gvTFBQclFQVGNPcVVrSlFqYnljY1Qxb0RLdm5DNXRIQ2ZDSVRuaWk2WXBkMnNZVTdrOUV4VXcwcVdyM2JCYmZNeVRHSm1xYUtOR3ZMb0FDMmR6eHZ6Ukd2YXBwcjFtNm9QTmxHZktndGV6S1g5YXUwNll1NENGS3QzV21uRkozSzRFSStCSUh3cHhHdGoyN3BldFhMbWgyT2t0dDIybDZ3MHluN1ExZHRGUWJBVHQzcEFJM0pKR0RQRlRsTmk1MHh3bExLTHBkdjl0RFVQUFd5QzBoU3VaQ0NTWStkVmRiQXp0dVc1SkJjNEpHYWF5YWxrTmtHVFBrYWk2VlFDdmN4SmdDT3RYZlpxTzYwRlBvYU80bFN1SjI0K05Rdk1VL3RFN1FzZG1PeW1yNm9VT1BQMjFvdmFnR1NsUkVEUFRKQnEybXZEbWx2dXB0RkZwS25BVGxSU1ZTZXY0MUYwYjk0T3RYSVdvRGYwM0p3ZlNPdERZTTlxamJSU3BsTFlVdnhMU1psS29qNWoxb2FpZnZBcVR1Q1VjNGd4UTJKU2J3WkFTMkFER2V0RFZwZjYxY2ZhU3Nzc3Jna2dsdE14ajBwaHFyVnF1MTVlNjB0a1oyeWhFVXhOUlhkUlpXcFc2M1Q4ZGtmUG1od0FieXpQdk5KTUhrQS8zcWd4dUxCYVZMTE9TU1BkUDkvalE0TjcvVGxHVnBNZFBDb2ZyUkNwdWJFTFBoSElqM3V2TlJZQ3E4dFV3bEE2NHdyKzlVM2dxYnUzM1liM0pKd05oL1dpZEpiZW9KUTBWSnQyeUNjQXRqOGZuUUsxcnEyM0ZkeGJOQUVUQlFNZWt4NTBBM3UwbW9aRzVDUVBJWStXS0ZSVjYxcURnbnYxWklPRW1nUm0vdjFtQzhyQXhNQVV3VW1zdXV1T0h2WEZMa25relF4c1BzYVNsejJvZG5VdTVSOXBLaUR3WVNUK2xTOUQxRGRhcWIzdHZyT291dFhUbG5iTXNhZWhEQ2R5aW5LMUtQcHVJQStGTXE1VzEyM2FuUnhxQnNieHRBdUZKM0FzSHZTMmVRRmxJSVNjakJOT2FaVzM2SGNwZWFLa3BXbEEya0JhWUluejhxcUxKOWJZUW9rejBwaE9VTmk0QnVpQkpJRWltR0t2dE1YRldGeVBFUERoV2NlZjVWTER3MUR0VFp0NnZZM21uWEkyMjk5YmxCbVNrRWpyNStkTERIbHExU25RUHRXa2FoYUI5ZHZjckFjUGdLdmhtbDFaR0x2dExlSlJjNmVWb1B2RHZqa0R5emluSmhqTjFwYmlOcnpieWlKMk9CZVkvcUVSSTgrdEREUXZSVlQ0YmhKSFBYOUtHRHFaMGVURDdvazhiQit0REZmcWpNdkxJYkJBVWZkK05WRlZjRlNWcmxLMnlyejlhQ0k0dHNxQjNxVE1nNG9FQ3RxdHFYa3E1QjhxQVpXVEtwU1J4ME5BUXFVRXBVRUo0eElwb3lRRjVRa1NabUNNanBRSWh3a29VTm9JNkdhQmQ2eWxVSjhQSkdZRkFybHpra29UdHdPRHgvNW9HSnVBV2p1Q2dGY3g5YUJnQ1ZwVUZFZ0FUQlNjMENCWkFJQ05zNU16TkYwVkp5VmhzcFQxb24rSzYvQ2xFcXo2ODBYVW5zaHFuN2s3VDZYcUtwMld6NlZxZy95OEg4RFVwcjF6clRUZDFydWdXckEyMmw5YnJjdUZ0VEx3NVFreDBHVFUzVnRkTDdPSTAyd3MwdDIxbzB3bElBM0NEbjhnYTFyUENjbDROWGkzV2s5M3VFa3hPNnJveE4ycDFyZngxZ1puMXFiVjBQU3lWdUtXUW9naUR1NkNrdUdpYXdncXRnanhGUzhDZldtNlc3Rk8vYUpjQ1ZPb0trSkI5TXhIU2k2OHdlMjYyYjAzdGl0YVVsS3JsbExxa3FFZUxJNi9BVVRYTkhMaVNJT1k4dWFHbTk4dmFCdUlUMXdJb2JDSWRVVmVKVS93RFNETkRVM3ZRa2tLU2laNnBQOTZMcWZxYmF2dExzREVrR0NETkdWUytsd1NTRkF4Sm9JYWxLTXo1VGsrbEFOTGppQ05vU24xaWk3VSswMTkyM1Z1WHAya1hNOHB1TEJDZ1I4b29peFBhZTBWL0c3SWRtRnBNWURMelpNZXFYUlRhdkNGcXV1YVpkcVNiYnN2cFZpQU05emNYSjNIejhUaGo0VVNZcmJsOWw1ME9XMXNMUm9nRHVrT3FXUGpLaVRtZ3dQc3B0MW9XMHN1a2VGMFBGSVQvMDhINjBBQUVyVXBSV3FVcGtUek5BaXVCdWNVQU9uV2dVdWJVa2Q0cVBPZ1JLeWtLSWNVQ0J6NTBCUzhvUWxLM0Nub0RRQ2NRaDFKVjNpdDA1QkZCVnJHMVJCRWVsQjNQMk1kdHJxOHVkSjB1NXVEMzlxTzRiV2VTMzB5ZkxqNUNzMkQwL3BodDJkNGRDVkVBRkU0Q2gxLzcxclFMVmRSU1NpM3NkcmpqaGd4SUFHT3RUZlNKYkVqRHJoSGtsSjRQK1RWVmJXYlNVaVFEQWllaE5RR1pZY3ZMeFM0VUdCQTNFQ0ZmQ2c1MTdTdmJGMlo3QkYyeHNRTmExOUdEYk5PZUZrLzhBNVY1Q2YrVVNyMEhOTFI1VTdjOXZOYTdiYTROVTE1NXRUaVVGcGxsbHNKYllRVE8xUFU1NmtrMVJycmtsU1FDay9TZ2J2VlB1cEo2VUQwVE1BSUo4dXBvSlpXc3FWdFpRUlBuUVQ5V3RBWGxiRWtLQkppYWk5cWwxcDFwUmdxSDYxVVJWSVdKQkt3ZW9QRkFpa3JncUpKanpvR2JmRVpDUWZQclFZcE9UdWdLR0tBUlNEQktjbnlOQTBEa0h6NG9FS0o2R09LQmlCQkJneFBwUUVVM2dZTUNTWm9HbElJTWdnRHlIRkE3d2daR1o4cUJTUWxVNUJHWmpyUUZiZ29Wbm5tSW9JbDAwSkpqbnBpZ2pXZDNjYWZldFhObTZ0bTRhVUZJY1NZSU5NSG9IMmZlMDl6V2doalY3MTRQSUFDa0pBU2tZZ3F4eUt6bUxtdXkybmFMU1drZmN2TmxBU0FTdFFCUFdQMWlvZlZzT2hYSzc5UUZpZ09HZjVJSVNPT2VsYmlMRHRUMm03UGRpZE9UY2RyTlRZWlVvUzFiQWxUamg4a29IaVY4WWp6aXBiSXNqekw3VVBieHIvYXBMdGpvWmMwTFJ6S1lhWC9xWGgvV3NlNFA2VStjRW1tZXl4eFpTMHBTQW5BNmltR0dkNTRkc0tqbXFZY2xaRWVYVDArZEV4SWFBZlg0VlFyeUpvdURxdDFDVTV3SmtSUkIwV3U0RXF4Sk1UUXhiYXVFL2FIRkZRQ2lZaFJORHBVM0kzWVNkMjJlditZb0lxaytEa1NQU2FBSlNvWVRLdHdnU0p6elFPTnM2cExpZ2xlRWhSbFArVFFNREQyU0VxT01uYk1maFFDVXk1dVRLVkRvZkNhQnEwcUNBU0ZUTTVGQUhNeHVJanlvRVBFSko0NXg1VURraytJRXFLWXpFVUNic0VxM1RtZ2NsYXRna3F4aUlvSlNXMHJpSkFQU2VLQXpiVUNWS0oyOUFZb2FjN3RDQ1VwVUpBa1VGVGZ0UWtLaUtDUHAxNWNhZmV0M05vNXNlYU81Si9RanJRZTJ2WU5hNkYydTdLMnVxdnhjWFpHeTRaVzJrQks0eVBVZFI2R2t1RnFKN2Z2YWRlZXo1VmwyWDdJV0xWbmRYTnQ5b1ZkOTJOckRaVVVnTnBpQ3VVbVNjQVJnazRsMnJIbFRVYjI2MUc5ZXZMKzZmdkwxNHk1Y1hEaGNjV2ZpYzBrem8zVU81MjdZN3hNZ1NTRFZOUTNEdU1JT09aUFdocE1jeUQ1NW9rcDZDbWR4T0tMcHlGZ3FnRGlocVd5NjhDa2toUThqbWhxeWJlYktjcVFENVZEN04xMURTdFFGeTRVMlQ0aFJrN1U4azlNVXhlL0N0dWRMdlZITm8rTXhFQWY4QTYxVXhDL2Qrb0ZhdnUzRVlKL2lBWm5yaWhsTWIwelVGRkpWc2dLanhYRWZUUE5UVER6cDE0ckxydHZBT0ZHNEdQU2QxTk1xS3ZUM0NGYjd1MytUNC93RDZxbVZFYzB0NU93aTZ0MWhXUkQrZi90UXlrT2xQRk1sKzNrOG52eGovQU9WRXhjZGsreHY3NnY3cFdwM3hzTklzYlZkN2ZYalk3MVRiWXdrSlRPVnFVVWdENCtWUEdtQmRxZXhsOTJlMVFXcUgyNyswZVpidTdTN2I4QXVHSEV5aGUwNVNZd1IwSVBORHRSdDZUZDVDMlZBS0JpVHlmcFJjcGk5TXVFU3B4dFVlcWZQNVVNcFBzTnlRUVcxOGlQQVA3VVJJUmEzS2tnRmhZUE03WUJpZ1FXN3U0QXQ1UHAvM3BtZ3h0bGh1Vk5HWWtxS2NSOWZqVnlpdDFKaFF0eVZJZ0F4eCtkUWE4cytOUjVrMEhvZjlrSFdOV1o3UzM5bGJ0T082U3RwQmZVbnhkeTVNSk1jd2Nna2NRS21Eb2Y3WW1rVzduWmpSTmNCYlJlV3QwYllwVW9CVGpUaWNnZWNLU2svTTFkOER5WXQ4aUFremlKUEZBSmFsTzVKSlB3b0dPWU8yS0ROMERJUHpvSElXQVIrQm9ISldaQUFKSFNnTzBUc3lEendDS0F5MWdxSmtpVDUwSFM5WU4wYmh4Q3JoL2NsZVU3aWF5dXRmdVV2QWxTaVJtZkVvNStVMWNpSURyVGdXcnhON2pKSUo0bnBuclZ3S2huZkVoQjNIbUJQR2FMU3JaU2tObFJTRW5rbURSRWQxa0ZCSVcwc0pqakUvS2d0dXkzWTdWdTFyeTdmUUdiTzRkYlVoQ2tPWExiSjhVeENWa0ZRRWZ5Z3hUajJEOXVleFYxMlN2ckt6dnJ1eXVucm0wUmVmNlZDa2hBS2xKMm5jQVRsQnpGTCtDOTdGblJyVDJWOXFsZG9HYnR5eTFIVkxPd1c3WXJUM3JPMXB4MURnU1NBc0JVU2trVEo2Z1U2R3I5dk5idE8wT3QyeXRJWWZaMHpUOVB0dE5zazNFZDhXbWtrYmxoT0Fva2s0b0tCTEMwS2lWbFlFelBUcEZNRFZoWjhKTHlBT05yaWhrZk9pd29XN2tCZHlud3hBY1ZVa0tsZmFiMUcwSnVyeVFubnZDYXBvclY5cUtYUkQ5eVZnNGt6OUtHblA2MXFWczBVcmZkU0FuQVZ0OCthR3RkMVRYN3U5UjNhbkpSNUZDZjdVTlU4RXE4NkltV0wxemFoYjFyZEx0MUNQNGJwUW8rVVJ6VXNsN1dYQkxtOXVyNThPWGwwL2N1QVFGUHVLV1I4eVRTU1RvMGdWQ1JIUFh5cXBvcFVsU2Y1Z2ZLY2ZHZ0VUSjU2NG91c0lucVlqTkRXQVNSSk9PaE5FRlRJSWprMEIyMG5hZDJQUTlhR251SkpjVnRPSlBsUWRWMXR4WDJod2Y2WW5jWktYQUZUVVhHdXZKY0JXVW9Ra2ovZFVrNS9UTkRBVmh3S0grbkpUL3dBcVNaOURSTkZabHFUM1RxU2drKzUxd09uU2kxQ2VmSUtaQ3hDdU5oSFNxZ0xseWdkNHAxWTJxQjZrRk1kZU9LRHAxaVd2WmYyUmExSllhYjdiNjR3ZnNBZEVxMHl6TWd1NTRXdnA5T2hCWC9pczU1YWQyNTdVTjlwZFV0N3BrUEphdHRQdHJKQ1hYQXBjdG9nbWVzcUtqbk9hazFGajJJWU91OWp1MTNabTIrOTFOYVdkVzA5bEtrN24zR0pEaUFPcWkycVFCbkZYTnErTkoyZzdMOW14MkZ0ZTBuWkxWOVN2YmRONGpUcjBYdHVsQUw2bXU4SmJ3SUE0SU04ODAvaUtCL1NGTWRtckxYUThoYk54ZVAySmI3c1MwdHRDVmlUTUVGS3ArVkJVWEtrQk1vU2tnWmtBQW1hQnFFbWNJQUhuUFErazBCMW9Vc3BWc1NNQSsvOEE1RkNDdXZOV2R1cDVRU0NFbmI0alA1MFhHbDMxNDVkM0JXcFNpUFUxSkVSVEhUbXFIb0VtY1JRUHlvUlV3dzlQaElQblZEMGtmS09sRE5GS3ZCa2NDSW9ZWnhISHpvVGtaU1ZBUkdBWmlnU2ZGZ1NCRkFaSUFKVVkrSG5RRWtyaUU3VVVCeXlWcVVkbzVOQjBiVWJNaThjQWR0VktCUElUanlxQ3BmMFVLVVZ0aTN6eWdnWVBselRWd0Q5ejhwU2xvcnhBQzFaK2xERDE2VmNBZTY0a0dJQ1hGRDZVV21PMkZ3bEtvKzFGQU9GQmN4ajFvbGJSN09kQmFhdTc3dFAya0Q2dXoraEJMcTJISVAyeTVQOEFDdHh6TW1DY1JFVGcxZHpsTWFoMm0xclZkZjE2KzFmVjMzSEx1OFYzaW9TQ2xBL2xRbWVBa1lBOUtraTJxaHRUNEI4VUlHSlUwRDhLcUZ0N205dGJ5M3ViVzQrelhGdXNPc3ZOSUtGSVVPRkFqTTBzMFh2YUx0ajJvN1JXTnRhNjFmdDNObzB0VDZXMDJpR2tsdzh1S0NFamNzeWZFWjVQbWFmdHE2c2JlK3RyajJQWE5pcHkwL2VESGFKRnkwd1RDbElYYWxDbEJQTVNrWjRGVHlZMHA5OVlXdUdMV1NPaUNLcUhNdXFUblpieDgrZjBvSmpseXJidkRWc1FSakpGRjRhN3J0NlhuZGdEWUNjZUNjMURWWkJDSlBKTlZDUVNZNjBCaWc3d2xKd25taHJPaEg1VVhXY2dkS0llMklnbjhhQTBjd1BRZWxGNHdxVUUrVkR2czRxZ2phWm1pYmgyTnlTb1lUelJkSFFnQklMc1NmOEF6UTJpSWxRTUFoUEU5YUlrTEtkM3VnL0UwSHBCelFkQzFDOVV0aldHclZlNEw3bTZXbFRhdlRlVUFqNS9XcHN2YTVhaGFsMk9HbjdUZFAyeUVPeVVxY0RSUXY0TENnRDlhWE80UlQzblpGdGFaYWUwcE04SHc0OU1PR3A5cGZKbFZGN292ZG9KVmU2UVZBaitaeE9QbE1lZE5udGVVSzEwcTZ2cmkzdExGMndldVgzUTJ5eTNlcUc1YWpDUkJGV1pibW5oZSswVFVyZlRtYlBzcnBGNDA3cG1rRDc1MUZ4LzZtOVZQZXVIekNUS1JQRUduRjZSenB4OHVyQWRXcFNSa3c2azlmVVZTRVAyWlJPNXc0NEEyUWZLb1lHNkdna0F1Q0RqaE1qNmNWVEFVSVpCSTc1cWR1REhXaGdtMXRtRmgxamVsT01HYUdDOXlsNVNmdldkcFJLdHN3VGlSemlvWUttMHQwcUhldU5xWmlSQk80RHk1L0doZ2QwcHBpeldzdXNiZzJZQmt4UXh6MjRYM3R3cFJpU2VsVXdoUGkzUmdjVVRFbGxyWXlYVkR4ZEIxb3VCeDRUMFA1MFFoVmc4UndhS2FPUlF3ZGtsS2NRQ1JGRERoSjgrS0dDcFVkM2hQeUFvWXhNYnhnRWVob1lNNENoSEhVRC9BTFVNWWxLenpCNnpSQlVLT0pVQWZoazBYQkZMeVlRRkR6bWlPblhCUjN5Zzd1STNkSGMvajBxTG85aHJWNXBaMldMNERCd3RoeFljWlgveklVQ0Q5S21lamZZcjk3MloxQ1RxV2p1YVkvOEE4ZlMxZDQwVDVsaGZIL1NvVnJiNVA4Q3NPeVZscXVvMmJGbHJPbHJ0SDNrb2RmQlUyNnlrbUNvc3Jna0Fad2FtcmRiQ2V6NTltRm5xV3I2cVEzMmo3NTdUOUZaQ01iWUFWZURnd0VxVnQ4aXI2YXZIRVR0eTExQ0FUOTJnTjhvM0F4NmttZnhySXpXckIvUk5adXROMUczUWk5dEhDMDZsQjNvSmdFRkpuSUlJSVByVlJIVGNJTzNLVWsrNk5zbVBoT2FjcndVTFNoUVR0Q1R4bHZIcWVmS2ljRTcxb0QrY3hqM1lvTVM0Z3lJQmp6Qm92QVBldHRxQkd3bWVnUFQ1MEpjU3hjTnJWdlcyZ3FPUVRJeFBuTlREVloyb3ZBTFpDRW9Ra3JFeEVtcWNOUVNDb25iazBROUNDVmdIamswTkh1Vkh3TnpBQWsvMm9CamcrVkF4WFNZb3VpQkdlUUtJSmlBWkdPUGhSZE9hQlR1M1lINTBwdnNVQUhqRTFOVFJtMGhJS2g3M1VEUCtDbXJwSGxoU0VCT2ZGeE5KVGFmS2xZS3R0VTJrS1FJL1VVUVliUklVQ1RKNG9PbzZxV0F0d0IxZThLSVZ1R09hbEZhNWNOSVNwQzNGcUFPTWdUaWl4R0x6QUN0emk0NGp3L1gwb2dMcnRvU29PbHd3bUJKVGpGR20zZHF1MkZoMm0wZlI3TnpSTHBWMXB0bzFhVzkrcTVQZXFBVERpVmlDRnBKQUtUZ2o1MG0weFFwUTA5YUJsV2lPcldBVWxZVXZjNXVQS3NHUU9nRVZjcWVlbS84QWJ6UWtYL1pUUWUxOW5wcTM3cDYwWloxTmxhbk56U2twN3B0d0FBWVVXaWsrdTN6cDRSYzIyaW8wdlJQOWtFNkJhcnZyL1FibS93QlFlTFNsTFJkN2U4WVozSEkycFFRUU9wQnB2T0hoeVZlaGFxNnBLMmV6YnBNQldXMVIvd0RhcC84QWRyZ2Ereld2cGxKN1BYSUJqS1dpWlB4M1ZjUW4rekd2L3dEc0YyWUk5MjJjbWlvYm5aalgwRXFYMmUxQ0RtRGFPL2hpZ1Q5eGE0RWVMUXRSMm5raXpkQWdmOU9hWlRHazlvMHZvdlNoKzNkWUkvbGNRVW42RVV4RlZ0eVJ5QjVVRXBud29LaWZVajhxQUpVU1NWWlVmS2dXY2tSaWd3WnpRUG1WZW5sUUtKSjlQU2dJajNWZlBwVUJXSEpPMVZUK0J3SkJBU2ZoVkFpU1hrOGdWUklDaU5wTVlvQ2xIZVpWbWMwRDlrbFczaVRRZG0xQzhRYmxldzJxVkNjL1pFQURQbEZUYXVLbTh2dTdkM05xYlIwSkZzMkNmVUdQeHB0RUIyOGNQaVJjcUNVOVFoQXo5S0FEMTI4UUQ5dHVCdTRJSTRuSEZCR1hjdktVU0wrNUluUDNpdW53cGdhdGJ5bkNrNmxjS1JJenVYSDRtbVQwVjAzUXRYYjBqc3AyUHY4QVVHanFPaWhXb2FGcXJFU1hXMU9COXVKUHZKbVJ4d1JpYWMrRVJ1eld1cDFyMjkyZXRPNzBXMnBhaTR5YmQ0eVEyNnlwbEtUMDRpa1d1WXEwOTYzVVcxdnRrc3FMZURpVWtqbjRDaGJTcHNsTGNrM0tFZ0l3TjNKOHFjSWFteGZTb3BSZG1TWi9pVk1ucGVSVTIyb0lVTnQ4NzNmUW9mTXo1YzFjbnBBYjY4MWV5c2xsT3IzYUVrRWJSY0xqODZtVDBhME83ZmRmZVV0NTV4MWVaVXRSVVQ5YTBCUndtY3ptZ0s0ckcwSEZBUHBJUEZBN01FK1pvTUVBWW9ISUl4QW9IcE9PSWlnZTJxRVpFZGMwRGdKUFhwUUUzbUNEK1ZCaXg0MnlPZURRR0VnY1VCV1pKOGgwb0paQ2R5cFNrNTVvT2k2bzg3OXVPMTFBQ1NZaFBYeUhwVVdLWnhUN2l0b2RSQkVSdE9hSWh1cGVDVks3NUFBNE96bWpXb3ExdnJVUTJyeEFrbEtFSGtEUEZFb0RpMzBHUENuZndvekgwcWpFUHZtQnZiTWVmcFJEaGMzQ2xob3E4Ry92TzdMaDI3aUlLbzRtTVRRUFJkWERUalRySktYbXlGSVdoeUZKSXlDRDVpZ1l0NTFDRXFESzVLZVpucjBvSEp1RnlKUTZrODVBZ21nUmR5dExoakNWZEZJb0JPWHVTb0tRQUlHMEdCUVZldWFndGJLV3dvRkl4aGMwR3ZwOFRubjFOQTlIS2wveSt0QWttY3ArTTBEU0NFL3JRUDRWaU1ldFRzWVQ0YW9jazUvV2dVcWtjWU5Bb0N1WXpGQTlzcUhNd00wQmdaUHUwR0s4SlQ1QWpwelFHQmhjU2VldEFaakFNOWVJb0xCSWJWSlU0bEprNElvT2wzbmN1WEIybDVJS3ZlV3lDQWZyVEJXdVd3Q1ZPSkZ5cUpFSllFRDE1cG40SXk3Y21mOEFUM3FpRWdDR0J5Zm5US0hXOXV3WEVxY2ExQUpKSUJEQ1RINC9HbVgwdHFWZDIrbW9aMmx5OUFPRHV0UWVtTXlJcVpmUWd0c2FXcFNDNWVYRFJrQUpWWnFQNDdxdjhORVhwdWtkNGpack51Z0t4OTVidUpuR1JpWXFiL3FRRldpNmNsUDNlczZhcEt1ZkU0aWZxbW14Y3M3UjA2SWxhdHd1Yk5TU0oycHVBbmRuSElGUDZocm1oUGdCVFhkcVh5Q2gxS2dTT0FNMVF4elJyNCtOQ0hGSGRudzdzL0kwRU81MG03Q1NwYlRnUURrOTJmN1VHbWF1c200VUNJZytVWW9JYllQa2MwQkNJU0JBbVpOQXpjcFNwSmsrY3pRWUQxK2RCa0VLVU9jMEJFcEpFY1VEOW9FQ2VLREZLd0NERTlhQnluSXpBejVVREVyVVFmS2dla254U3NBbWdjU3JuZURHZnhvRG1Rc0NCSVBuNTBCZzRFeUZDQURRR0t4dVY4ZkthRDBtNDdkVzdyZ0ZxQVFxU1NFVEh4S3Vhb1ZsKy9EdVZKVEl3RkJnSDhWNXAvUUs4MWU2RzlEaGNtUDVGc0orWmhWWnRWV3IxNjlTNGRqYWlPWjc5b0NvdG1wZG4ydHYydmZ0bTNBT3BVMHFCMUVTSnB0OXBrVHgyeGUzN2pwTnVwc0dDazI2RkZJOHpDelYrMTlyZ0RuYTJ4NzBtODdONmFwTWs3SExQYVI1U1JOWDdmTDJtSWg3VGRuSGxmZWRuTklUSFV0Rk9ZNmVDbjMrWHN3SldxOWdsMjRWZWFCWWtIK1ZwNHBQNllwOXFXTWZ2UFpRNHlDNXBGNnowT3g1VVQ4UXFwOS95SXFMMCt6UkNrZDB4MmdhUm1GTlhDRlovd0NvZnJUN2ZnMUx0WmZka0dyRlN0T3YrMC8yb3FKU0ZGcmJCbmtpRHpINDFObnIvd0Fqa2p6aGNlVW9xVXFUeW95YW9jMUhlQXE0SHlxZ3J4RWhRTXFJbkI0SFFHZ0dVN1J4SHg2VUNSZ1IrVkFRZUhrY21nV1NlSSt0QVFKVnVBVEJKT0NUUUlXRjdVRXJRUVJpS0Flend5U09LQnlNZ1pBZzRwb1ZJSUhoS1o1NG9IRGNGUktQcFFHYldJS0RKUEJnVUVsdFVnU0FsUnpQblFTR2t1SzNFUUJ1UFRuMW9PdlhpYmhiaWlFZTZTTUxCRkxCV1AzSVlXVU9LYVFkdkhlcDNINUdvR092RjlTRnQ5K1V3RENCdWtla0RPUlZ5MVpWVTg0Nm9LVzJIMUlHSlVJL1NvVUw3UStDRk5xTW1DUVZnUjhab1NuSjc1UzhnWkVSM29Id0dLR0hMYmVkd3BhRnFBZ0tMaE1mT2hESHJaU0VxRU5DY3pDaWNjd2FHQkl0UVZ3bDVtVEo5em5IRWswMU1ZaGJBSmxaWEVHTVFUL2FnaHJldGlnSkMzMUdUR1FCSDBxalU5ZWRTcDlRUVZRRDFOUVU4MVFWSnltUUQxelFLazU1OUtCeWxIeng4S0JDc3pPWkpuR0tCTjNpTWtEcmswRGtxQUdDSmo0MEJXM0FrejE2aElxYUNmYU42RXlsZVBlT0lxZ0tuTnc2OGNSRkEzZXJrQ1BuUU9UdW1TVFFFU0NGWW1malFPWVFzS2tnOHlhQ2NtQ015QWN5S0F4YVZKNWdHQm1LRDFucG5zSVVkT2N1dTFtczNsL2RCSmNPbjZZZnM3Sk1Id0JYdnFKODhmQ3RTZkRyTlRsTXRmWmpwRnBaMnJmN3VzOU5zWElXODBoZzk2cVV6dFc2dVZrRHJrVFZ0U1d0NVlkN0t0SUxTR3JRTk5KQ1lDZmQ4dWtEaXM2bzdlbGRucng0S1JiMmkxNWxRU0ZTVDYwKzNvQTFEc05vOTBrclhwOW00Q05zcVpTUkIrVXpWbEhBL3dCb2IyY045a096N0hhSHM4dTR0a202UTFkTXBJTGFRb0dGQUhqeEFEeXpVdkk4K0h0QnF5QVFic21lcFFKclAxaXNQYUhVeUFGT29YQndWTmpGTUMvN1EzcHlXN2VmUGJINjA1RDJlMFRnYysvdG0xSmlEM1pLU0JUa0F1ZGRkVTc5MGxIZGpvb2MwNUZkZVhLN3RaVzd0Q2puQXFpS01uTkFXQ0Qwb0ZpSm5GQnZmWVgyVWRyZTJpbVhOTDA0czJUZzNKdkxzOTAxdDgwOVZmSUd0VDQrK0IzenNkK3kvcE5vMzMvYWZVWHRWYzZNV3dOdTBQaWNxUDRVNG5RNkhwWHNvN0g2THQreGFCWUoybnhMZGI3MVUvRlpOTDg3NEhOLzJwT3gya3RkaG1kYTB6VHJLMmZ0TDFwRGpyTEFiVXRDMGxKU1k1QU8wMUw4clp5UEtoYklPUmtlbFFJVUFHTVk5S0RBaVFab0ZRMkpNbUI4S0FnUnhuTkE1Q01aNEhrS0NReUNSNXhuTkFWQ1R0SmdlRXp4MDYwRTlDdG96MU05YURzL2FEMmhlMEhzZ3R5LzAvVTdqVUV2N1dscHZHZzhoTzJkcFNBQnRtVEo2OWVLbCtQb2R5N0srMURROWQ3RE42bHFWOWFNM1l0MEY2M0N4M2kzTm9rSmFuZGxjZ0ROUHRuSGtYV2g2MnhxT3B2aHF5dUxhMWRRZ2hUclFDZDBId3FIU1JWMitSVjNXaHY5bVM0NW82bTNkUDJsYWJSd2tLYnprSVZ4R1pBUDFxLzRKV2k5cVZQM0F0MTJ0MnkvaVV1b0l4OGVJOVJVd1V2N1NMQ2J6Mko5bzF2eW51Z3k4a0RHVXZJaWF0UjRVZmJBSWpJL1NvcU90T2RwQkJHRFFJYzlSOFlvR2xBbWV0QWlrZ0pucjhLQmk0MmdnNW9HcEhBODZBd2dLd1B4b1BTbjdPSHNiN045cSt6clhhanREZC9iMWQ4dHRPbklWdGJaVWt3Tzk2cUp3b0RBZ2labXJQbEovbzlJMzJ0NmZvekMwV0xLNzU5bEFCWnRBazdZR0FWRWhLUjhTS3o5dlFvdXlIYTN0RDJwMUI1Q3RJYjBoaTJkMnVoeDBYQldraVVsS2srRWc5WW1EaWFTWHlOMmRTRXdYM0U3ajZBWm9PZmZ0QzJpTDMyTmRxR3RvVXBsaEQ2VDZvY1N2OHZ6cXdlRWJwdmFzNEhtUFdnanBHWkpqNDBHYlRISWcwQlVJSkdJamt5T0tBb2dxOFAwNW9Ic29DaUJ3VG1hQXpLQ3BRSTJrSE9SUVN3MEozcC9BNE5BUlNZVVJ0NDlKaWc5RVg5b3pLeWJaQlRPVWxRaWZQak5VY3I3VzZNNzJYN1FXdmE2enRFdU50UEJUdHE0SVNvRVFZSXlKQjU2VTNlaDNmMmVhdTUydDdGdWF6Y2h1MTA2OFh0TnEyNHR3a3BWQ1VLVnlWSEhBRlpuN1IwbDVvblNkUGFkU2xsYm9VUTBGWVFZQkNmaVB6cWlGY1hIMk10bHR4SzFOS3lBWS9PblEwTDlvdnRocFQzc3AxVFRFNnRaZnZHNlhib1RiaDVKY0k3MUtsZUVad0JKcWZhWGlEeHc2UXB3SGNER1BLcUF5SjZmTTBHQWNUeFBOQmlrbmNZaWVLQVp3cmFUaU9vb0FPWThQejRvSEpUQTgrdEFkQ09ENTBIb3o5bGRtMjFqUmRhME5McHRyaE54Mzc3aVFOeW1pa0FRVHhrSDYxTm5rZWpOTjdEYUJac05OaHRiN2JSS3RyN3lscFVvOHFVRGdrK1pxN094c3pibHZic2h0b29TbENZQ1JVM1JWNmhjcFNuZTZSdUdaSFFlUW9OQzlwT3VLdWV4UGFLMWJjYlMwdlRMaEtsS0FJblljZnBRZUhpOXZiUXBXRkVlZjRWUURoVWNmNTBvRjRTVEErRVVCVzFTbUFKaWd5Q1lJSVVQVGtVQkVBcE1Bd1QxaVlvSmJRR3dra2dEZ2lnS2txTzVLaVpHS0FnVnpLOGdrY1RRZWhsTzJTbkZCVGJaV1praFpCTWVlYXE1RWU0VnBieUhVT3RvVzJSdEtGYmlDbU15S215ZEdLUFQvd0IzZG5McDFmWjkyNjB6dlBFdHUzZlVFS0k0VnNNaWZVVm01ZTR1R09kcDc1TFNtWGRaMXBUWk80SlUvSlJIUVl4Z25pbjFub1V2YUhXemM2VmZOUFhkKzhwYlIvalBLVkJIQitOTWlPSU5meFFETXlmeXJTSlpJQ2hKanJRTlBpSWlmUEhTZ3dTVmNFajhxQlhBRkt4d0tBYThHVE9BWm9BSDd4Wk5BY0p3b3lmRGlnVkJKTUV4UWJIMks3VWF2MlAxZzZwb0Z5bHA5U0MwNGh4QVcyNmpCMnFIeUdlYWxtajFMN0pPM3VvZHM5R0w3cWRLdUx3S1VoMnhWcUhjdU53ZmUyRVpTUWNHVDVVRzYzTjI1cFRoKzM2ZTQyaytMdWJaNUN5ZlNTcW5CcXUxanRNemV0aFRGdGRKV0NFTTJTMUozdkxPY2hKd2tkVFNqejE3WWUzeTN1KzBld3VHbjdrcEtMdDFsTzFsbm9XbXgvTWZOUnAramtEUGpZUkFqSFUrbFVOU1J0RUR6TVVEbEtFSHJpUGpRWUR5U29HZ01rZ0FTWkgwb003ekFFaUJIRkFWdDZRUVJQU2dNSElnemc4R2dLYmhLU1FDQm56b08vUE5zWlVsRndBZXUwVC9BSi9uU3FuMnRRMUtiUzZwRGJEaFFTVjcxbU05WWp6ckg2MXFyMUpoSk1pM2ZJa1ozakh6aXJhYWdPVzZpMEFxeWNncTh3ZVJRcURkc3BDWGg5ajIrQWp4S2tqSGxITkJ4c0NMaHpCRzBuNVZVRTNZVEE5S0RKT0FQTDYwR1NRb3hnZW1LQlFxVEhUMU5BeDR3M0E4NkJyV0d6SU5BUUFCbk01UFB5cG9jMlBHUkVDT3RBZEFLV3dPbkZUWUd3QXBLaElXT0RNRWZNVlJLdHRaMUswYzMyMm8zVGErSjcwbWZyUVMwZHF0ZlJiWEZ1M3F0eWhxNEcxeURDbER5M0FUQjY1elV3VlZ1bVNFeHowRlVLeERhRklQUmNjVUdMQlFvOU91TTRvQnFXTTV3YUJvWGdueGZJVUJmSElJU2ZRbkZCbmR1RXpLZmhPYUI2UXZJa0Qxb0NRUkJ3VHhuaWdzTGEzTHpaVVN5RHVJOFRnUWZwUWVscnkxWHZrMjZ5cURCQ3o4cXJVbUtselRuRm9WTnM2QUFESlVaUFNhazNERVoyd2NjUXB4ZHVDaHNEQ2xFbUttV0dLMTIxY0REaE51a3BBQ3R4SnprNTVrSE5ReFczTENIRUZCWUtRY1pRVDlEODZHTlJkN0Q2WVNwYW5iMUc3T0VENlZkVEEwZGt0RkVlSzlXQWt5U29ETk5KREhPemVrdHJTRU1YQ3dlcXA0K3REQ3AwYlRlOGhxeFE0a1lCVWxRbjhhSWJyV2oyTnJwZ1dOTWFROEZLQlZ1UFQ4K2FEbno0KzhWNURnQXpWRDlzTmdueW9DTC9nb1Q1eVpvRWJKZ2xSbnc5YUNUa05nNGs5S0FTaU9nb0dTWkhwd2FCeVpNODBEbTFxS1NrR0V6SnhRUDd1WE53VVJQbFFOVzJtUkdUNWxWQXBTSkVKK2xBN1lkdldjOWFBZ1Nkb2tSRkFadEJCR0JKem1nUlRjT1FNNG1nY3BCVnV6UVBJTW5IV2c5WDNTUXNBUkl4TzV5RDhxb2g3RkFxR3d5SkpVSEJBRkRVSzRDeXNvUXlvUVRBM0E4ZVZTcktocVpkVW5iM1R5ZVJPNEV3YzRyQlVCMXA0QUFDNmtEb0ozVnJEVVYxcDFTQ1NpNUF5RmJVZ2dVdzFFWXRpRWJsdFhNaEpBZ0RJeFVJaEp0WG5scVQzRHA4VzRsWWpwZ0RyNjFUOU5PbXZ5ZDFxdFJKQUc1WVRnVUwycU8xN2EyTkwyS2FZUUlKeTV1STRHUEtpT1J2WVdlT1RWMFBQQWtjQ0tBejN1RG1NUit0QU5NYnM1aXB5RHFWNFFLb1pKRWtpZ2JBSkJQUHdvRVBXZ2Uzd0pQVG1nT2drS0E4NkJGbng1K0dhQlNCeE9hQlFDQWNDUGhRR2FIaHdNUVBuUUZDUUNJd1B3b0VjUVFzVEo2Wm9ESVNBaUNNbmlnT2lFN2hFK0krbEI2NDFUN0l4cVRsazNhc1BQZ0ZYaFZHNEFpZWF0b3AxcWFDaXBlbmJreVRJV0JqeTllbFRrUWJ0TExaS0U2VVVwS2MvZlROT1JYclF6Z0lzbFNJR1hCK0dLejNWcUUrNHlXei9vSEJBaytLQ1JXdWVDSUNybGtnQTJWMDN0TTRjeklISHFLeWlQOW90RUVLTEdvRHZGU0J2d2Y3VlJGZGRzMUZKRnJmdVRsSUxuWG9QcFVXb3hkdDBxTzNUbkRrZ0JibUNEMHhtcVZyWGJSMVlzd0ZXWWFnRWtxVVNjK2RJam1Dc3E2YzFRZmFEanI1aWdJK0QzY0dNcEdZOWFCaUVnUUFSRWZXZ09wSTJtUGVvQmhQa1RGQmg1TkF4VXorVkE5SE1FVEhXZ01rbEo4TWdtZ2E3Sy9Fb3lUMW9ITkR3a21lSUZBNU1oSkZBUm9FcEhReDlLQ1kyRGdnU0RtU09LQWFrOG5NK1huUVNXbTk2WVB3b0RwUVBGRUhKNU9hRDFQN1NyWnV6N1lKZlRjSUlldFZFQnR3cEFJV0pFK2ZtYXQ1R3NYTGdUQVN0VVpUSGU4WTRIbUt6Wm9ndXZ2Z0xLbHVCS1I3M2ZqRS8rS2ZVUW5MdHdEZHRjbk1Idmh6ei9BSHFMUUhYSEZOS2xENmdNeUhCQUpGQ0sxOXhRVnRpNkJXQUpDZ1o2OWVQalZLaHFaY0x5Q3ltOFU2RElDVmdrK2NEbWtta29sd3lSdGJDTHdCSWdKVzRBWm91b1MydkR2S0hFazlWUGtnRWVnb2w3YXQydmJTaGxLSVpDdHNtRktKL0dpTkVRSlduMU5VVEcwZUxyOGFETGtRU1RBNEUwQTBBaHdnKzdBNlVFbGFmQ1A5MFp3YUJxVTdjZlBucFFOeG5FZzRrMERDTWs5Qm5KNTlLREV3QnlZaWdJQUpBNkgxb0hyU0FrYzhVR0pTSWhVR1I5S0FpVXBqZ0FuNDBCbVVEWW1SbnBRUzBObmJPWStuU2dZc1NSQi9HZ09pUW1Fd3N4bUtBN2FSdHlnS3llUm1nOVY2bHBMbDA2VGRXejdpMjBiTjYwajNabUFldWF1Q3RmMEJKZVROZzYydENCS1FBY25yODhZb0sxL3MrMm9xRGpEd0N6QktXd1NQam56b0lDK3o3WWVNc1hRbVFFOXljZkdEbXBrV29idlorRnVBb3Vza3FIM1NoOHptbVJOUWgyZVc0NFZJYXZFcGpQM1M0QStOWEE5UFpOOXhhaXhiWDVQUmJhRkFpZlhHYVdUekZsSEhZNkZOcU5wZE91RUVlTVo5VEpWaXBubzJuZjdITmxTd2kxRzdtWEZOaVBQclRqd2xhYjdVZERhMCswQ2twdDBwZ0VRNkNvNFBrUGhVSEdrSkJLSTg2b3NHMm9JSkFJUE1aelFOdS9kV1FCeHowNTZVQW0wN0hFZys4T1ZBelFTbDdpMmdFSUNSakhPVDFvQWJDSklQeHp4UU5Vbk9CSm9HRVR5SUdmalFMdEFHZVBwUUhLWUJJbVlCNHhRTklLZ0RPUGptZ1Z0SUpBODhab0RKU1FpQkI5YUFqWUFRT1l4bVpvSlNlUEVUUFF4ei9lZ2M2Q3FWRXh3QWZMMG9ITXdFK0VUQmtFVUVwcGFRZ0FpYUQyeTh0cnZIQ0d5NFNuRW9nZkROYTFuZkNzdWJnSkVwczJvSUtnVkdLeTBnWE53K3BKY1Y5amFiR1FtUmo4cUN0ZjFBSmVVTy90dHdXWktZSjQrTkNvRjFxaEpNM2JBT0lsUktnZmtLbjlFQmVxSGVlK3Y5KzRrb2h0WlAwQXE5Q0orOFFWSC9YdnFRU0lDR0QrRTlLbjhJYzNldEdVZC9mZ2xPOVFRbEtSSHhKcWNlbHdvdTJ0b0tuTlNLYzREeUV3YXY4QUVybjN0YnZtVjJPMUtMMDdSRXV2b1ZPUFNnNG95Q1hFRDFqbXFMSkNkelNwZ1I1Wm1najNSbEs1bjVDS0JpZHZma3FKQ2NZSFdnUHVDa3lEZ25oSWdVRFFrcVVTSmljUlFOWHVQQ1RIVW5Jb0JMNHlUOUtCeVNRZlAvT2xCTFpXbE1sYWlCd1JFMEFWREpBR0prRTlhQlc4cUVqanJRRlZ0QU9lZVlGQXJSQlNBckdLQ1kzdTNKVU1FUkovN1VCeTZoU0ZBSWhTdUl5UFdnR0hFcXlrbVpFRGdnVUIyRVNqQ1VuUEpVZjdVSHNIVnlFRTkwMG9FS0pnSUpuUFROV1ZyaHJ6enpxMWdHMWZISmpiVU1WN3Yya29KUllQTFVVeEczYVJueXFuQ0FXZFhSSWIwMVNVS2hPU0V5UG5XZVM0aktZMVJTc3MyaUZ4dC84QVVTZm9EVW5ad2pYRmxxZ0JJZnMwZ2tRcUpnOVJOWGFYRVlhYnFCWDRydXlLU0pqdXpnZVhGUzFJTW5SMzl3S3RTYVpVWTkyM0pKSGxNQ2kxSnQ5TVdsTGJmMjhxTTVVTFU1SDRkUlJMMjBEMnFhZXUzYlVUZXZQQlNZTzVzSkFnRDFxeEhKR0I5NmdFOWVQV3FMRmtBbVZBZ2VRTVVBcnRvZ3VRazdna21QS2dqTnBWdXpPNkFEUG5RRktCc1VlTWN4UVBTTXlSbmlhQmloSWd6SnlhQUpUT0NQd29GVDZuQk5CTWJRRnBrcmdmcjhhQlhFbmlmRDBOQXhNRDNnYzh6UUtzL2pHUEtnR2xYdVNZQm9KYkRwRzJGbU9Zb0M5NlN1VUNFckV3a0hGQWphZkVsU2M0ejZVRmd5K3REWUNBSStBb2E5Y1hyMXpLa291VTVQRUt4TkJydDdkWHU5Y1BORkFrQUtjSU0vQ21DdWV1Nzg0VUdpNG4rdmNUbnJQV21BTnhmWHFkb0xDRnpNRXg4NHp6VXlyVVc0MWErY1FocDloeFRhUEMybnZJMno1RVU1MUVKeTZmZFNYRjJxNVZ3ZHdFSDYwMFFlOWNLeU80dWtrN29JY0V5UE9uZkt3MEpVcHNMV3pkanFaY0JrZVUwUVZrTmwxS0JhdkFyVnRTVlBSSk1ST2ZPbWpSZmFPV0Nod0laZWJkU0RsYXhtSSt2V3JvNXdsSkZ5azVJVkprZmlhQ2UySWtqSmlTZk9nSGRKSlN1WmphZktnak13SEZUTWNUUVNDREpVbVQ4ZjFvQkZCaUZSbmtpZ2E1d0JQd29CNUt1b2d4elFLbE9SekhCb0phTnloQ1NZSGxRSzRDRXlNd2VraWdFRXFraVNSOGFCeWdvdGtEbWVwb0FoTUpCbUFCRXpRVHJYeVB4U2Y4NlVHR1NvNDZtYzBEbU1yS1NZMit1S0NVZ3FDWVRNRHlOQjY5dkV2clJ1N2doRUt4Sm1KOC9qbjhLMHpLQ3UyM2tyUzJGYjBoWlZ4c0pCeGtWRlYxd2hhRUFwYUlnNDJyQjNWRlZ5MEVKbFREcGpBVlBNbklweXRRTHBqZHVscHdHZG9KU0RBOHVLSUE1Ylc1V1laV2tEa0tqcjBuNHpRVnhZWS9ocDd3S1RrZ0lTcUk1NDZVN0RtVzJ5a1Izd0E2bG9TTVlIR2FtVU1XbGxMcUNWUGsrOXREUUVFNC9TbDRIT2ZhYVVOcmhDSFBHWis4UUFad1AwcEJ6OWhQM3VPVWs0ak1WUmFXNlVxUjcyT0RITkF4OXBLN2Q4SUc1VzBqL1BXZ3IyTnhPNGlGRURCL09nbUliSVRNbjFQeG9HaHM3VXdZSFVHZ0U4M3VQUGlFejVVQTFvR01LQW5pZ1lrZXZIU2dsSkJDdWhqUEZBUlNBR3dVa3hRRFFnd0JJa2cwQ3FSenhIa2FBRzB3REErZmxRVExOQ1ZZSUluZ3hOQVY0andnZ21lQkgxbjFvR0ljbFNvSitQTkJOWko3c1NtZmdZb1BhZHc1c0NCM2k5amd5RU9EengxclZsMFJGWFJ1RVFnT3BVRVJ0TGc1OC94cklDcGdLYjd3SnVFcWxTUjNZVDBITTBFWnpTZHAyT05YSVF2eENHd1p4a21pMHJ1bUZ4UVcyMWVxR0RCWkJQenhSbEZjMGRJYkFWYlhTVC94RGFiaVpJNjAxVVpyU1dVcFVsRFY2Rk5xSUpOa092VDFrMEdHenNMWjhXK3FMY3NFT0V0MjF5cGdscHpkd2haandMSGtjSG9hQXFPeHRzOHRTWGI1MUpRU1lESmdHZVNZb09GZTI3VFd0TDFGdGxtNVc2ZDhiZTdpT1ovejFxRG1EQ1FYMms3ZVFvVGlxTFczUUFrakJsSkVSeFFadGxha2dTVkk0SFhuTkJBdDJ4dUtTb1FPQnowRTBFME1ZSlVEdGdTUm1nQXRwWEJFbnpGQUphQ0NJQmdlZWFCaW1wV1l5UWVVNW9HaHNEM2hDdktPSTRvSkxVSlZ0QXh4bjRVRDFKVDZTQUJ0STYwQVlTSUN1STQ5S0I2Z1FtSXh5QlFCT1d4andnbUtBOXVkcXh0akhVOVJRWmNKVjM1Y1ZLa3A0M0RPZXYwb0kyN1ptTUE1K0ZCUGFjUGRwNmlNZEtEM1Jic3RPYXFvT05vVUEwQ0FwSU1aVi9ZVjArWFRFN2hqbHBiN1NmczdVN2xaMkNvc0MxZTJZK3ozWDNMZUNRUENNWW9xRXdsUGVvRUNOd0VSL1RVeWFKcVBDZkRqUFQ0VXZjVVpoYXZ1UnVWRzFlSitGVkE3bDF3dXFCY1dRRW1NbittcytGYk5ZSVJjV0pidUVwZGJXa2hTRmpjRkNPQ0R6UkZUZXRvU2tiVUpIM2dHQjB4V2g1Wi9hVVNFNjVZRklBS2dxU0J6V2Fyajl2OEF4TGY0ZnJVRjRnZmNFOWRzL2hRRjR1REdKM1RIWEZCWFd2OEFBZFBXVTUrUm9MSUFCUmdEajlLQ08veDhGZm9LQUl5WHB6Q2Y3VUNYWUFhVkFBeWFDRTc3NS81Z0tDUVBFU0ZaRzQ4MEN5ZkJubVordEJpd0pTWUV3bjhqUVlmNEt2aFFSMnY0YS84QW1OQWEzdzBzamtDZ1Y4a2haSk1rRDg2Q0dzbnhaNlVFa09MU2xJU3RRRWNBMEgvLzJRPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL0xlbWFpdHJlLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELy9nQktSbWxzWlNCemIzVnlZMlU2SUdoMGRIQTZMeTlqYjIxdGIyNXpMbmRwYTJsdFpXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9rMXZkR2hsY2xSbGNtVnpZVjh3T1RRdWFuQm4vOXNBUXdBR0JBVUdCUVFHQmdVR0J3Y0dDQW9RQ2dvSkNRb1VEZzhNRUJjVUdCZ1hGQllXR2gwbEh4b2JJeHdXRmlBc0lDTW1KeWtxS1JrZkxUQXRLREFsS0Nrby85c0FRd0VIQndjS0NBb1RDZ29US0JvV0dpZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvLzhBQUVRZ0E1UURjQXdFaUFBSVJBUU1SQWYvRUFCMEFBQUFIQVFFQkFBQUFBQUFBQUFBQUFBQUJBZ01GQmdjRUNBbi94QUJERUFBQkFnUUVBd1VGQlFZRkF3VUFBQUFCQWdNQUJBVVJCaEloTVVGUllRY1RJbkdCRkRLUm9iRUlGU05Dd1RORFVtTFI0UllrY29Md29zTGlOSE9Tc3ZIL3hBQWJBUUFDQXdFQkFRQUFBQUFBQUFBQUFBQUNBd0VFQlFBR0IvL0VBRElSQUFJQ0FRUUJBZ1FGQWdjQkFBQUFBQUFCQWhFREJCSWhNVUVUVVFVaU12QWpjWkhCNFdHQkJoUWtRbEt4MGZILzJnQU1Bd0VBQWhFREVRQS9BTDEyYTE1aVlsbFV3K0Jjdm9rRVpkRHRwRjlIbkdWWW5wemtraVF4RFNFbnZHa0R2VUovT2ppUDFpOTRjclRWWXBqTXl5dk1GSkJPc1lEUnAzYmRrNm5ZUVlCSENHRXYyaFllR3NSUnc1cU5qcEViaVNoU2VKS1M3VGFnbTZITlVxR2ltMWNGQTg0N2xQSVNrcmNVbENCdW9td0E2bU1jN1VPMlduMG1YbUtmaGR3VGRTSUtWVFExYVo1Mi9pTU14NDVUZFJJbE5RNVpqMWNXaW16ODdLOStKaHVXZVd5SDBEUmVVMnZhR0tWWEpWVjB1NkZKL054aWlDcFREVGp0bk00V3NxV0Y2aFJKMUpoNlduSlZ4WDQyWmsyM0dvalRlbDQ1RHhhMjZMeE5ZZ2xzMlVKdnBwbGdTZGZtVm9lVEw1aGZ3M0oySmlueXk1YTV6cVd1L3VtMjhTTWxPZXdzdVowZ05xMUIzTUE4RVVxU0grdktYYjRMSFdwdG1YdzM3SGNFdXFTYmNTb0c1TVBZUzdTTVNZZkJacHRVZTdocFhoWWUvRWJ0eXNkdlNNL25KOWMzTVoxbXdHaUUzMkVJbG5DbDBuK0tIUjA2VWFseVoyZlA2a3JqNFBROGoyLzFudS84elNwQjg4U2hha0g0YXhYNjkyclZpdHVrNWxTalIvSzJxL3pqTEpkd2hYUThJMmJzUDdPR3NSUC9BSDdYMlN1aXNMc3l3clFUYmczdi9Jbmp6T25Bd21lTEZqVzVvR0VwUzRRV0NzSllweHBsbTVOVDB0SUUvd0RyWnBSU2hYK2dicjlOT3NiZGhiczZGQmNiZC94RFZIM1I3NEFRbHRYKzBna2ZHTGkwK2tOb1EyaENHMGdKUWxBc0FCc0FPVVBCWlBMNnhUYjNEVzVJTU1KR3kxMzZnUXNKVWpZNWhCQlVIbXNOWTVSQWRuSldwNllsSkZ4NlhEYWU3U1ZyS3dUWUFhNkRlUEtIYXAydDFmRktIYWRKUHFscVFGRUtEZmhVL2IrTGlCMCtNZXVpUWJrSFdNYjdhT3lhWHhPdzlWc1BOdHkxZFNNeTJrZ0pST2REeVh5UEhqRDhUU2w4d0xqYTRQSU0yck1UZjZ4SHVXdnB0RXJVV1haZVlkWW1HMXRQTnFLRm9XbXlrcUdoQkhBeEZPYUtQS05TSFJXWXlyZUMzZzE2d1I0d1pKM1VTb0xwTldsWjVEWWNMS3I1Q2JaaGExcnhjNXJ0UG5DMlV5Vk5sMkZuODdqaGN0NmFSbnhnY2RvQ1dLRTNja0dweVhDWjAxR2RtYWxPT3pjODhwNTl6M2xuNkFjSTVyMjNnZWNIWUhqREVrdUVBMzdudktrTkJkQmxXblJkS21SZS9XS1RMS2R3WGlidVZYKzZweGZnUEJ0WjRlUmk3eU03SnFwREV5MU5NR1VTMGs5N25BVFlEZThaWDJvOXBlSG5LWTlUcWFuN3ptem9IVTZOTm5ubTRrZEk4N0hIS2ZDUm9Ua2s3WnN2dERRbFRNTGRRMndCbUsxcUFBSFV4bmVMTzJQRDFFenMwOHFxczJuU3pPallQVmZIMHZIblN2WXVyRllZUXhQejc3c3MyTEpadlpBOUJ2NnhYWFhTVHZweUVYY2VpOHpLODg3L0FOcGRzYmRvMWR4UzZvVHMwV1pPNXl5akJLVUFkZUt2V0tNODlmY3cydGRocjhJWmNPbzFpL0RHb3FrVm5KdnNEYW15NFErQ0VLL01OMEhuMThvZXFsTm1LYzQySDBwVTI2bk8wOGczUTRubUQra2NoM2lUcGxYVkxTYmtqTk5pYXByeHVwbFc3YXY0a0hnZnJCeXRjeENWZVMwZG1Ua210cW9NVGlaWlM3cFdqdnJYdGEybDRsTVUxR21NVXFabDB6RXNISEVsSWJZc1NmaEdlVDFPVXcwM05OZmp5VHBzMjliai9Db2NGUXdoRmhjSkh3aEhveGxMZllieU5SMmhzalZPYnlqdFFOaU43eHpJMVVMYlh2SGUwbTQ2UTZRdEZzN1BNTHpPTDhUeWxLbHN5VzFuUE1PajkweVBlVWZvT3BFZXpwRm1VcDBoTFNrbzBHWkdXUWxsbHRJMENScC96bkdWOWd1Ry91TEJBcVRxQ0orc2tPNmpWREE5d2V1cXZVUnFUU1VxUVhwcFdSbHNhQTZYNnhsWnA3NWYwTHVPTzFFa3pNaFNGS1NsS1VEZFN6b0J6am1UWEcxT0ZMS0hYa2pkWThLZlFieFVhL2lTVVNncW5KbHFUcDZkZzRyTG45TnpFZEpZcG42aW51OExVR1ptMEhRVEV4K0F6NTY2bUpqaGJWbk5xelRtcHZ2TEVvS1BNdzZIQ1RvQ2ZTTXJuWjJzUzNpeEJqV2tVUlBGbVVRbFN4MHVyWDVSSC9lK0hIRDQ4YTRzbTFjVnk2RjVma2kwV0k2Vy93RDR4VG1rYklWcUcvemhMaWdwSnplVVpHeFZxT2xRRW4yaVZxVGMvS21vTWtwLzZraUxGSTFERXpiWGZ5a3hSOFV5UUYxS2sxaGwrM2xjcEpnbnBXdnRyL3ZnaFpFektQdFA0T1pRMHppbVNRRXVsYVplZEFGczkvY2NQWFRLZWVrZWE1aTVVZVlqMnhqbCtTeHBnQ3Z5TXFsMUU2SmRXYVZmUmtlYWNUNGtoU1QxR2hHaGp4Tk1HNnMxdUdvaDJGTmZLL0F2Snk3UXlybkNZVWRSQ2VFV0FFR1lLREVFZG80NnhWcndWK2tCSjA5WVY2MmppQ2FWUHpIc2laZnZuZTVHb2F6bko4Tm81bFBGWEdFa0ZTMG9TQ1ZxTmtwQXVTZVFFT3pNak5TcUVybXBXWVpRdlZDbkd5QWZXRUxhaDZ4VGxGeVN0SVlLb2JkVnZmYnBCcXNkaUNPWWhra2s2M2hpRXlWQmxZUERXR3pxWU80NlFrNzZ3UUlSMkVIMWdIWXdFNjZHSkpKT2lWWmRNVzQyNDBtWmtIeGxtSlZmdXJITUhnb2NESGJVS0tnU3lxblFuVlRsTC9Pay90WmIrVnhQL2NOSWdJN2FUVVpxbVRhWm1RZUxUeWRMalpRNUViRWRJVktEVDNSN0NVdkRFb0FLMGtjZm5GMzdNOE1LeGJqQ24wb2dpV1dydlpsWS9LeWpWZngwSHJFZWlXa01TS0M2ZWxxblZuZFVvVFptWVBOc24zVmZ5bU51K3p0U1B1dWlWcXF6ekttWm1ZZkVrbk9raFNHMndGTHNPcWlQaENNdVg1YTZZM0hEbS9CdGt1eWpKbnlJWmxHVWhLQVNFb1NnYUM1NEFBUlFjYTE2ZXFoTXZSNWxtbTBoczNtS3JOQzNlVzROSVA1UnpPL0NJN0V1TGE5WHF6T1VtbFUxaVVrWkRLRk9UYmxrQzR1RkVEM3pheDVDS3BOMUNpMDk4VE5VbWw0a3FpRFpDRFpNczByK1ZJOFAxTUx3NEhkdERKVExIaDJSazNIUk1VR2xURmZuZHpWcXF2S3lEelRtNGY2UjZ3NVdxclRtM0Z0NHR4ak1UV1UyKzdLQzJVTitSV05UOFlwRmJ4SFhLMm51NWg0dE1IM1padndOSkhVRFZYckRGUG9UaXdsYllzYkQzbGhJK0pJQWk4c0ZmTmtkZmZ2L0FPQ2Q5OFJSYVdNVzBPbmE0ZXdZd2kyejlRV014NjIxUHpoOVhhZGlHNERDYWRMcDRKYmwxS0h6TVIwbGd1Y2ZSbVhQeURLT2swMzlibUpCbkFTcjJGU2sxcVBIdndyNkdHS1dtajN6K3JCYXlzZmI3VHEwdEpUUHlWTW5XdUtYR0NuOVREa3RXc0l6ejZYWm1tVGVIcDRud3psUGN5cEI1bkx3OHhDMDluZFJjUmFYbVpWeSszaUkrY1JOZHdUWDZOS3FtSnlTdkxEVXV0TEN3bnFiYlE2UCtYbjlMcC9vTGZxeDc1TGc3TlREYy9LTzFTWlpuU2xCY2xLdXlBUGFXQnF0cDBEVE1CNGg1UjQwcURxWHBwOXh2UkMzRnFTT2hVU1BsRzNWbkVTNk5naXZTeFViUElDWlpKL0k2czVGVzVlRWsra1lTdlFXNFdpdkxIc20wRnV0SUpPdWxqQ1J0cmZXREI4WFdBUlkyNHh4d1NkOWRvVmEvV0V3b2FwdkhFTUpPL25DN25wNndnNldNTEI2MmpqbWFiZ2hkTVlrKzhSTXlycjZsQXVNVExMZmVOT1d0ZENqcVIwK2h2RnZTNnNsU2t1cUZ4cnJjZk9HcEppbUZ4MlhtcWJJeVNnUUdraGxPM25iZUVUTkxtR2xxV3k0RkpBTmtyMVNmSTdpUFA1SktjbXo2ejhQeHZUNEl3alRyMnY5L3YySUxHbEVibXBKdHlUcHFIWjFac0hFS0RRQUk5NG5RSzVBSG5HWFRqRHNyTU9NVERaYmRiVlphRkRVR05JcmxlcWxEUTA0bGh0eVVtQmErY3FRVmNVcUJITDQ2eG1zMjkzOHk4NzNiYldkUlZrYUdWQ2I4QU9BalMwYW50cDlIamY4U1BUeXk3b0pxZmxWUy9Qcm0vZXhzbm5CWHZBdkJIMWk4ZVlCQnAwSU4rbTBBOGJid1hBZ1J4dzViU0RidG5OK01FbnhKQnZyQzBEeERyb2JSeHgyTVdGMUVhSjhYV1BZR0RwQittWU1va3BPcld1WVJMSmRlS2xYSldvWmlDZWx3UFNQS3VGWlJFL2lHbHlhZ1ZJZm0yVzFEbUNzQS9LUFpkVHRuWGwwRno4SW82ajVuUlp3OEt6QWUxK1pmUmpOeExTblBadloya3V0aFJ5RlZpYjIySnNSRURLK0VvV3RLcm5ZQWVNamtsUEFkWXNuYVBNQldNNnV5bFJ6SmJselljRGtzZjBnOEx5Nk83Y3pwU1hEbEpYYlVpMEZrMXZwUXBMa2RoMGl5U3R2Z09nVXhjK3NtWlV0aG8vdWtIeGY3bGZvSXNNelJXSmVYU21Ua3BSUkcvZk4zMDg5NGJRbjJaMEZGOG14eW1KUm1iU3ROczFsYmFSaTV0Umt5eTNTWnM0Y01NYTJwVVozaVNqVEtscWNXeElyVURidWkwZTdTT2x1UFV4RU4wS3lrcVlZWjd6UUh1ejRibmx4alZINUdabUhDR1pnTk0yOTFUWVZieXZyRExGSWxXbEVOM0xpVldXNVlFazh1a05qcUdvMFRQQ3JzcjB4U1JJMGxjMlhsSURhTGdoWlQvd3hBMFRIMks1Q29vTktyS2kxZXlwTjFmZk5MVHhTcEtpZmxhTk5xa2dtYXBTMmJXQnRiejRSVTVMREVyUHVxUk1PV2VDZ1Rac0pVQ0RwNTJnc09aUlRiRlpNTHljRkI3WUttek56a21pVGFNc2gzTk1PeXQ3OXl2UVpiOHIzdDBNWjBlc1R1T3B0TTdpcXBMUWZ3MjNsTm8xdm9rMnY2a0V4QUdOekcyNHB2MlBQWkVsTjEwRnhoYXRSZUcrSU1PQ0RBWWd3YURydkE4L25CY1k0a1VSb2VFR2tBaUFMRy9XRXBVUUxheHdKczJLYXU2cVpxRTZtWGIrNlczM0dmYWxMM1drQzRTT1pVZFBXS001amFyRmQyM1VOcHRiTGJOZjFNYXhWTUl5azVnbWVaUzJKWkpiVS9LbFI5d2c1czZpZUtyYTlMUjU4SnVCR1hvL1N6N3FYVE5ySjhSMXVPTVZ2YVZjVngxK1JacDdGYnM1UUg2Zk5OcFc0NnBKRGdzQW14dmNmUzBWZ2tYM2hONEJqUWhqakRpSlIxT3F5NnBxV1YyMHEvc0dEcEIzNndqMGdlZXNNS3RDN2p5Z0E2N3dnUjBTMG85TS9za2VIaXRSc2tlc2NkUWxzZ0tJTm9lWVpXNnF6S0NzamUzRDFqdlpwOHV3RXFkdk1PY2hvaS8xTVBHWkFiVWx0QVNnZmxUb1BsRWZrRnQ5eXdkbmJLWmZHMUFjbUZwU0V6elJ5ZzNKMTQ4bzlZdXFTNExranhIWG9PTWVLNWViZFlkYmRaT1Z4bFFXZzIyVWszRWVvcTFYc3VDSGFvM29xWWxrcWFBNHJkU0FBUFVuNFJWeVFibWw3allTVzM4aklYSDNhemlQRWxVc1ZOT081K2lRVkZLZmtrUlAwaFlZZGJCTmdwRnJkUkUvZy9EYUpQRDcwck5ONUhwc1puanhBSXNrZWgrWmlCbkpWMlZVdGgxSlMreXF4OHh4aXJyb3JkeDBYOURLMVQ3Sng0bFRPZEkyMUF2dVlLUUJBUzZGMkZyRk45eU56RGRMY0R6YmExSHdwTjFKNFhFT1RTa3V0T0psVmhCMEtsbFFCRjk3UmwxelJxeGZGczZwdWFlZFlXM0pxVTJrRHhPSjNCdHNPc08waWFrL1lrTnk3NkE4QUNxNTFLdU54RWRMemFHbVFoS1prRWFGSGNFZ2lJdW9Ja1p0YVZLZFJMektGWmdweEJRYmpsY1FhamZBTGsyN0x2UHZKYmtIbmdvWFNrRUFIamNDS2xqdkZiV0c2ZXBiU2tHZG1FRU1JdHJmK0k5QkhIVlo5TWhUbHpVMDZ0MlhaQWRXcENoWlJ2NFVqcVRHTVlrcTh4WEtxOU96V2lsK0ZDQWJodEEyU1ArYnhaMHVtOVNWdnBGWFZhdjA0Vkh0a1Mrb3FVcFNsWmlUY2s4VHhNTUdGS2hCR29qZFhCZ0EwNDd3c0hhK25TR2p2Q2dZNDZyRm1FbURJMEVKTVNjaFNEckN5a0sxMEVOQ0hFblRlMGNRMGJaMmdTZFZxVW9tbnFubkdKQ1dKU3Rwc2I2N3FCMUkydHJicEdTMUdsdXk4ODQwNDJaYVhiQVVYVkt6akx0ZS9FazhCeGpYYW0vT1AxT1ltbnB3TFUrbE5tOG9MWXRwNFNPRnJDMnUwWmZpZWRtS2pOTVNIc1R6Y3hMcVVPN0J6RmQ3V0lTT25VeGs2TnlqOHNlZzhtU1U1dTNaQXZxUXBaN3BCUTJORWdtNVBVbm5EVnhhSmhtbEphZjdxYktucG9BcU1wTHFGMEFjWEhQZFFCeDNQTzBSY3lFQjlZYktTam1nRUo5TDYyNm1OR01rK0VDTm1CZmFDNEd3aVJwckNRa3pMb0JBOXdIaWVjTXNsY2owbklOdG83MmQxSjJhMitQOEFTT2g2YzkxSUhoQXNBTmgwQWprZW1BNHJ4VzN1cTVPc01aeHJiUVgySmlWRyt3bkpMbzZISmhXcEhoNm5XRXR1Nld2WUVlVWM1VWxSTzE3NlFiWk9hd0JpYUFiSDJENHJIbkcrWURRN2lUQ2RDbDN2RkswNXR3ck92aWRDaWxzZjdVNitvakFtUlo2MGVvT3dhWERuWndsZHRVenJxZlRNRCtzTG5TYVlVUEtMUXpMcXVnbTF5MkZDK3h2dUlpY1gwQXp6YVp5U1RlWlFNcWtiRnhJNGY2aDg0dURzdC9sV0ZBZnN5VUh5SnQvU0VPSUsybEU1Y3dGaWVmbkZUTEZaRnlXY2MzamRveHVsUEtZY2VDa0tQNVNrNkVIbHJ0RWcydHBhRUlTaXl4ZlVLSXRwdDFpNFZhbk16QWNXK3lVckF0M3pZQVdQNitzVmFTb2M1Y3BNNlhibjMzVWk0SFhLQkdiTFR5dmcwNGF1TmNnYWFtaW5RQllHd0IvNEREVGladnZUMzZYRkJSMEJTSWpxWFhFMUNlVkpTS2k3TUljN3JKbEl1YjJGanRZeEQ0N3IxUWFrcDZTcGtzNnAxZ1duWnBvWmt5NkNiR3hHbStsK0VkRFNaWEt0dEV5MVdLTWJVaW5ZK3J5S25OZmQ4amxSSVN6aE4wZnZYTmlvK1dvSHFZbzd4MU45NDZIRTVGQzBJY0FXa2JjaEczaXhySEhhakZ5emVTVzVuQ2JjWWJWRGlobFVSYmJlR3lkSVlLUVIzMGhRT2tKRzI4QUdJUnc0Q09JMGdqYUFrNjZ3ZG9JNFI2MnRDZ3F3MStrRmJlRWtrSFMwY2NiUzZ3aGhQY3RPdU9raTVjSUZpbzYyNkhqWXhWYTBKcHBieXc0aVRrbEpIZlRhUmQxZjhuTWNvdGduR1p4dHdUYmJ6RXFsd2xLMExLVkxLUnBtSnZtMTREYjRSQTFTczA5cGxiVlRCVzA3NEMwUEdvcHZ2dzIzakV4Ym92aFdNenhqdTNSOC9mMnlscmRlbm1WeWRKbGxOU0tQRXNYQXpXL002czZlaE5oRVM0bklzb0MwcnQrWkp1UGp4aXp5THpGUUtucW9wS2FKTE9wUjdITE9oa3FLcmhLejRUNFFiWFVSZld3MWlMcmxMVklyN3hocVpNcDNpMmU4Y1I0QzRrNnBRb0h4aktVbSttL3FkT0VrbnRBU2RXUmlFbGF3bE9wSnNJNzV0MjZVdG95aEtmRFlSeHkxd3JNTnliQ0ZPaXppbEN3UFV4WVNPdWtEUysrZzR3UEw0d2tLdWVXdXRvVnNkN3dhQUVpNHViamh4aHhCc29XUFdHbDh4RGpKOFhIV09PTzFwTm5FSGUvR1BWbjJiVWQvMmN6YmRoNEtnNWw2M1NreDVVWjNUME1lcS9zc0Jad2ZWQ1JkQ2FoWWREM2FZVGtEZ3pTQTBGdE9vVnhjSXQ1aThjYlRaYmNYbnNMSnNxNHY2eE5sa0NZbU11MTBxK3NLUXdrekNTUVFGZUUyOG9UR0l4eUszT3lTSnBsUVF0U1ZKR1ljUkZLeG80NVM2QTZwSkh0VC93Q0cxYmZVYWtlUWpVWjZnSldsU20xT0RRakxmUW1NbTdTcHRnTnNTeVVJTDdReW9PNUdZZUwwMGhtUEI2ajJvQ1dWUlZzeDJtSmNrSHNpSDFNTG1KeGxsTG9QaVFrWEsxRDR4ZThVMW1XVlhKT2tzTnBUaEVJTW02SlE1WFgwRlF6RUswdmNqWWJtS2lzcFJYV0ZCb3VvbFVxV1VEOHhJMitnamZjVVlZYnFQWjJaS1daUTA0M0tvY1lBVDdqaVVoU2Jlb2k3cThYcC9MSDdvUmh5YnVXZVM4VVVsRk1ubkdtSEM0d1ZMTE9jV2NTZ0tJQVduZ3ExdWtRUjQvSXh0L2JkS21wMERDV0tlNkxUMDNLbVNtMGtXSWRiMUYvbkdKT3B5TEk1UlV4dTBtT1p5cUhlSjA5NFF3YmJpT2hSeXUzSEhXRzVoQVNjdzBCNVExb0d4a0hxYndML0FBZ2hCNzdRc0lBT29zWVdEcERZT2doU1RyQklnWHgwZ3ZqNlFxOStzR0FUdEhFSm0xU3NoSXpNNEhaMWI2a0VBSmFDaGtQUTdHMjJnSWlPeFRnNmtWQ2NFMGlvdXlnS0I0RVN1Y3FBdllFQWdoWExRM0dzUzlMcHo3VENYSnFiczhzbk9nQUtDZHRiNzMzK1VTRXpVNU5Fc0V5MHcybTdxVzNPNGFDOG9WcHFMKzdiTWJiWEE0bU1DR1NVWmZLK2pSamdrc2I5VGkvMVpsMC9oZDZSa25YcFdWdE55anBhbW01Z3BjVWxXYTFtd0xwWHBxZE9PbHhySEJSYXBORVZGaWZxODNMRmN0Wm9xbUZwVjNpVTVXMDJBSkl5S1VpM2hBQ3Q5TEhVS25VMktXM25lY1JuQTdscEdVcmt6Y2tGekxrT1hZbFFWcU9Sak5jVlRJcXROa3Azdmt2cVpXcVd6ZTJvSnkzS2hsWVA0aVJjKzhTb2NMN0FhR0tieWNTWDl5cEtLajBSMVpsNmRMVDZVMHlhRDdLVURObHpGSVVBQWJLVUJtQk56c0xiZFlqRldKSnRmcEJJOXhSNW0wQyttc2FFVlNvVTJKTjBuVWJ3YWVPL2xDVDhlVUVEWTJnaUJ4WHVuamFDYTk2M3poUXVZUTNjTDBpU0NWbDc1VWY2cmFqYVBWdjJYZkJnaW9HeXRha3JYaGJ1MHg1VWxoK0czMUpqMXQ5bTFrTmRtcTN0UHhKOTYvT3dDUitrS3lka3JvMUZrZDQ3TnFJNEpIMWcxSTk1TnRkd2VSaHltZU9YbVhQNG5MZWdGb1luWEEyNENUcDV3bUtKYk9QRUZTN3VUVXN1QkJLYjNPZ1RwcVRIbmpFTlErOGFtL05oUlUwazVXeWRMZ2NmVW1MejJtVmxiazQvU1dGZUVxQ25TRHNDTDVmMU1RVTFSbTVmczVUVVZnRjZwVHlXRTZlNDAzY20zVXFIeWpaMGVKWTBwdnowVWM4OTF4WGdoT3pxbWUxNHJrVk9JdVhuaXF5djRRa245STlMU2txbnVRaGFiMlFuNlJodlpheG54blR5UHlKY1dmOEE0SCtzZWhHMEJMcWdSWVpFZ3hYK0lTcklrdllacGw4aG5YYmpoeHVyZG1GVGFsMmtKZGtVaWNaQ1UyMVFicXRibWttUEU4NmdCWU9oQ2hwSDBjcUVzaWFrWEdIQmRENkZOS0hNS0JINng4OHE3SnFrcHlhbEZncFhMdkxaSVBES29pS0VXV2tRTG1xUWQ3RzBFRGRCQk54YUhGZzVWRGNhL3dEN0RLQ1JjNjZDTEtCWXd0T1ZXWHJ2Q2VFUE9DNlFSdnREUkhwQzVLbUV1VUZZK2NDOXplQU9rSDAxaURnSU5vY0J2RFkrRUdMSGhlSk9OYVpOUnF6eVE5bmJrczEzQ1BBay9xcUorVnBFcElsUzIyODd0aU85V2JuVTZnY2hETXROWlhPN2Q4RHFScWhHWlNoYm1MWGhEbGZwckYybHV1QlNUWW9EUkpCOHQ0ODlQZkxpSzROdkJIREI3OGtrNWYxWlRlMDcybjd3WnFDWFhFcVdoVXN2S3MrNmIrSHlJS2gxaWdnMko2UnBlTlptVnFWSGVUTDk5M2liTFRuWVdpOXVwRnVjWm9rWE52cEdybzIzQkorQ2pyWXhXUzQ5TVhmd2hPbW1zRmM4NENqZFY0VHlpOFVoZVk4TjRKVjllY0FRZS9DSjdJRW9VZGhEbXpzTW5SVU9wOThSeTlpR1RFb0RsYnZ6Sk1leWV4MlgrNk95MmtKY3VDOUxHWVZjZm1Xb3FIMUVlT2FlMFgzR1drZTg0UTJPWUtqYjlZOXhVdGdKUkp5VGVrcEp0Tm84OG9DWUNaMGVpMTBob3RVMXBLdmVLYm56TVZESDlYRkhsVk9IS1ZnMlFtL3ZLNEQrc1hKeDFNdkozVmJiVFNNQ3h4VjExdXZPcWJLbHNNcTdwcEtkY3gydVBNNlF6UllQVm56MEx6NU5pdnlJd2JTVjRqeEtmYmxsVEtFcm5adFpPcFNOVDhTUUlsY1RqdU96REJjdFloYnBkbUxkRGNqNUxFUzJHYVFyRGpHTjFQdUF6TXRTRXBjSTJRdGFGS0tSNWFEempoN1RMTTA3QjBpQlpURkxTb2dqbUVEL0FMVEduNm5xWm9wZExyOVA1S2pqc3h0dnYrZjRFZGpjdVhNVnZ1RWFOU3FyWDZrQ04xQ2Z4MWdibEdsL09NajdGR3JUVldtRCtWRFRZSjVsUk1hNjJienF3VHNMUm1mRUhlZGxyVHI4TkJ6QS9BQjVFSDV4NG0rMERTbXFkanlwbGxHUmJzd3NySEEzQVVrK2RpUjZSN2NtQi9sMS9HUEp2MnFaTExpdE15Qm80dzA1Zm43eVQ5QkNjSEtraGt1R2p6MnE5OWRUZmFPYTlyNngxTEJDalkrTGVPUTdxODRhaVJTZFJyc2VNSVVONFVDZXRvSlhNYlJNbHdjdXh1eEF1WUE2RGVIT050K2NJVWxRSk1MZkFTRW0ra0dQT0JmU0RCTnR4QThFOG85QlZmRHpsSGRkbW5aVnFZWmNVRmgvS1ZKU1NEYTk5dVBtYlJ6c0xTa251R2t0WmpleVA2eHFyaFo5blhMclFGTnFCU1VIVzRPOTR6S3RVOWRHcVBkYSt5dWtsbFo0aitFOVJHSGx4dEt6YjBiakY3VXFaR1ZsdGN4S1BJV1ZlSkpHcDN1SXhRSVUwdHhDdENnbEo4eHBHNVAzVWtuaGJTTWt4WExDVXE4emJaMVFYYmdMN3hhK0h5cVRpQjhTaGNWTDJJV0FBWUlHRkEvRHJHc2pHQ3NSQ2dlY0tncmdjb05JRVE0RGJTRnREeEoxSUVJVVUyc0REakJzb0hlMnNENU9mUmVPemlucXFtTTZQS3BzYzAwbFJ2cG9ueEgvQU9zZXlHWmFxSVJubDB5aWN3eldKVnhqelg5bXFsR2Z4eUpoU2JpVGxISGY5eWlFajZtUFZOZHFjdFE2Ty9PemlyTXNJMkc2anNFanFUWVFFdVhSSFJUY2I0d25wT2lMcDh6SnNOenp5TWpiclRsd0U3RlJCMUg5WWlleUREcG42aXFxekxZTXRLTHlNSkkvYVA4QThYa2tmTWpsRlBreFBZenhLdGJweXVPWGNkVW5WTERTZUE4aG9PWk1lZ3FRekw0ZHd6blFoTGN2Snl5bkxYMnNDbzM2OVl1NWY5Tmg5R1AxUzdLMGZ4WjczMGpQNXgxVTFoZkc4d2trdVZTcm9welIvaUFVaEgwS29nKzExOUs4YnZTNlBjbFpkcGhJNEFXS3YrNkoraHNLVlJleituS0g0MVJxSzZzOENQeW96T1hQeFRGQnhuUCszWXVyTDdSSys4bTFvYkNkU3JLY2d0OElzYVpmaXQrRmY3TDloZVovSWw5Ky93QzVwM1lsSzNvZFNtbEQ5cE5wUWs4OG9INm1OSFkwbWxxMTFJK2NVK2pLbGNEWUdwYk5TS2krdFdaVGJZQlU0NnE2aUJyYlRuMGpqbXNmdXB6R1dwaUVLVmF4ZWVKdGJvQitzWU9zMWVOWnBPVE5YVGFQTGt4cllqUTM5V1hMY293bjdRTkRGVWVBVzJDVjBhYXlLSTkxMXF6cWZrRkQxaDJ0WWhuYW02MjlVWjRBSkJLRW9PUkNmSUE3OVRlT1Iyb2ZlVEtVelQwM050SmJXMk00VzRNcTA1Vlc1QWdrZXNVOGZ4S0VKTzR1aTgvaEdTVVU5eXM4anVveldVQWRSZU9GVmdUZmVQVWN2ZzNBNzRDSGFQS3Q2NWJGYmphaC93QlY0eUh0b3d0UThNMXlUVGgyWlV0bVphTGpqQ25NNVpJTmhxZGJIZ0R5TVc5UHJZNW50U29WcU5CUEREZTJtak9NNEJPOEhtQjRXaGVVRk1ORVpUcnc0eGRkb29jQmczdUJ0RGx1VjRaR20wTFN2YThBblpMVEFwUEtFYmFYdDZRK254QzQrTVdpaDRDeERXNmVpZWtaRUdXY0p5S2NXRVpnT0lCNGRZR2M0dzVrNkpoR1UzVVZaNkw5cGRsMzBNdnFLa3VISzI2QllxVi9BcmtlUkdoNkdJckhyaUUwVXRGRjFwL0VLaUNTa2prZUdrVFJsZmFXSHZhVTVTNE1xQ0ZXRjdpeEhJZ2dIMGl1VjFhcDJrSVRNV0V5NmxhSFVoWnVGMklJdnR2OVJGWEpCVTBpekRJMUpNcTBpNmw5cTF3UVl6VHRDSVRYdTdCSnl0cHZwemk2NFZjTGt2ZFZ5VTZHS0xqNXhLOFVUU1VhaENVSUp2ZlVBWCtzVnRIR3N6WDlEUTEwcndvcndGeVAxZ3lxMEoyMjNnc3ZPOGE1aWhrbUFFNjNKTUYwRnZXRlpkUUZFM08wY2lHQllBVHBDMnRWQUNBV1ZXOEJCSFUyZ2srQTJJMTZ3VmNrZUQwNTlsVmh0cVJydFFkS1VKek5zNTFXQUNVZ3FWcjZpTy90SHhhNWlpcXN5bE9DMVU1aHpLd2hJMW1IRHBudDhranJHV1lPeEtxVHdLMVJaRlNrR1ltSEg1MWRyWmhjQkRkK1ZrM0o4aHpqVyt6bW1wcFVneGlPZVpEOVFtbGR4UjVSV2hjY1VQMmhISzF6ZmdrRTdrUmN3WW80MTZzdVg0UlV5emNwYkYxNU5Ed2JoaHZEMURWTFBoSnFMK1ZjMnBKdlkvbGJCNUp2cnpKdkhYMm5UamlNQlRNbXlRSDU5YmNrZ0E2cUxpd1BwZUlrWXl3L0lQSms2aFg2ZUgwSDhSUzMwNWxyL01vMjJ1ZGh5RVpoMmlkcTlPbnBxUis1SG5YVnlMNm53OWtBUVhBTEp0ZmNKMU43Ym1LOGFsbDN6WXh4YWh0aWk5WXF4Vkw0Wng4WEVzbDhVaWxwa0pOc0hLa09yc1ZLSjVCSUEwaXE0R1liWlVuRU5VSlRKdHVsVFFPcGRWcVNldXVnak1LSldmdi9BQlF3MVVuSEZvZlVwVGk4eFU0NFFDY29QTlcxK0VhaFVYWFoxaGkrUnRwdEpTMHkyUEEyQnBZZWx0ZDRUck5majAwTm1QbHN0NlBRVHp5M1Q2UjBZa3hITzRocUxjM00zUzAxcEx5eURjTko0K2FqcGM5T1VPcm1ncVh6bFN1UXRiVXhYdTdYblVHZ1N1MXN3T2dISVIzMGgxTElMYitVcFZ0YzlkYlI1Ykkza2U2UjZmRWxqVzJLRUdvc3N2Wm0yVzBxSnVWS0FDb2NHS0tiSWdMbkowSWMzeXA4UjYrWHJIWk1leHJiVTNNeWlGb1ZzaGRpVDhyeHl0eWRHU3JNaWt5Z0pOMVptd3MvTzhRdHZsRExrdWgzL0dGRW1tckdZYmNGdjNpUXEwVm50RW91RnFoZ3FyMUFTOHRMejdLQXVYbTJVaEJXdlFCQnQ3MTlySDlJc3N6U3FKUHJTL01VNldTNjJSK00yMkd6L3dCSUZ4NXhUZTFlanlqR0JIWm1VYzdzc1RqUlVnNjk0Q0NBQWVZdmZ5RVdOTWw2c2Ryb3I2am5GTGNyNE1FY1pLVjJLaENQRU4vRU9VZGIyVldoMUIydEhPZERZNjhqSHBkcDVoc1pPbHJiUUlVc2FYaEVJbXRyR0xsRTdndVJscWhpR1dhbjcreG8vRWRBL01CdzlUYVBSY3RYWmZ1RUJzdEJBRmtoSnNBQnNMY0k4dlNVNDlKVEFlbDE1Vmo0RWNqRnZsc1pTNWFIdE1zOGwzaUdsREw2Um42dkJMTEpOY28wOURueDRvdFBobnBKMEpjVXRJU0ZJeTJVTXZUZ2VCSE9LclhaaGFKbGhwOTBxV1NWcFhtQUxnQkZ3ZW8rWTFpelBURFdkVEV1Qyt0SS9FS2ZFbEk2bmE4VmZFS0M2MjJGWnZCWll5MkJCR3grSDFpM09DN0tGbFJvc20zSWUxc2pkTHkxYTZXQk53UG5HVFlrZEwxZG4zRkN4THl0TFcyTnYwalVtM0YvZUZRU29oS2c1ZlFXQkZ1WENNbnJ0eFdKek1ia3VxSlBtWXJhUlZra3k3ckgrRkU0TG1EdGM2d1FzYlFxK2thS1JtQmc1Zk9GSTk3WGVHeHBxZC9PRmcyU1R4TUVpQlNUM3J1VUhLbUhwVklDeG5UZFcyb2puYk5pRHZySFdGZ200QXVlUFdEWElMNEpGcDVUUlRrVVVqYlF4WlovR2RmcVJaWE8xV2JjV3d5V0d5RlpNclozQXlnYmpReFVBb213UEE4bzZtN0VBQzhESnM1TTZTK1FOTlBTRUpXVkZWd1RZL2xNSUNiMnZlNTR3cElBS2hydzkwd3NNN0taTXJrcDVpWlJaQ21uRXVYM09odkhvRUs3MVZnTHBLUVVrbXdYY1hBSThyLzhFZWRtMGduUkZ3ZUtvM0xETlZFMWhtbE9ncTcxREtXM1ZaYnBCVHBjOHhwcjBNWmZ4R0ZxTWthdnc2ZFhFNjNFTE5tbExEUk55a0VYdmJVMjlQbEhMTExSTExiL0FNMG9lSXF6QURLTG5ySFZNTXJMcEtjaXlDUm56SnVqcGJlRXV0b1dMVGExa2FBWnJKNGNocjh6R2NvK0RSYzY1WktQdnkwMndvVFRhSFc3QUt1a2tFeER6Rkd3ODgyRUpZUzAyQVRsUzh0QUhvRERpbEZsU1JUNU54dFZqK0tEWW4wNCtzVnFzVjVjaDRLZy9VM0Y1aUZobVhDTW5tU2JIMGhzY0UvQXVXcHgrV1RBd3BRVktROGwrZFFzV09jVHF3RXB2cWJrNkMzT01ZeG5XRlZDc1RqRXRQVEV4U0pkNG9sVXFjSlNVcDA3eTNNNjZ4TVkxcjZhckxwa2FlcWJNb0RuY2NtRjJXNmVBeTNOa2o1bUtRNW9udzZXTWFtajA4b3ZmUHN6TlpxbEpiSWREUzc3M3YxaHBRNmJ3cStwdHNkb1NkaHBHa1pnZzZpMXRZYmhhemZiZUVDRTVPUnNRUUlBZ1FGQkhzbGlucVlaU3c4b0t6QXFDazdFOFUyNmNPbnJIQlVwTkNXbG9zQVNrNjVSK3NTcy9QSlcwcHBoSlU4TEVaaWJ0bmdiQUg0UldxcTdPVExDbEZ4TEs3bEtrdHQyc29jTHFOOWY2UjBtcXBBMC9KUVorVkxjNVBkMGxhbEtzdndKSkpzTGZwR1Exekthck1GQnVsU3JneG9tSXE4L2hxcm9RR3UrUTh4Yk1kRG1CUEhZNzhJem1weks1K2NlbTFJQ002dFFOaEZiQkJ4bTIrbVhzK1NNOE1ZcnRIRkJqejFnUU9POFhMS0ZBdnpoZXBBdjhZYjQ3UXNiV0p0QlJaQXBISzhPSk50ZmhEYVRyNXdyZmFEVEJaMUlOeUw2azZ4MnNyMEZyZ2JrRVJ3TmtXVHZ6anJSZlMydHRJNlIwVHBMbGlBUUlEYWlYdDdaaHZhRUpGLzZtSE1sbEpKVGZwd01LWVk4ZzY2cUpNYTMyUFUyYXJVbyt4TE9Ob2JsWFBHRkp1YkxHbnBjR01vYWFVU0xJdGZibVkzRDdPbE1xOHRpYVpkZXA3NktXOUxaWFhYVUZBQ2dRVVpiNnFON2pUbmVGeWhHZkVsYUNVNVkrWXVtYUZKWUhVcGQ1cDNOYlFKU2tEU0pFWU1hUytBakxwdWJjWTBCRXVsTGlOTmIyUHdoNVV1RE1LdHZ4K0Fqa3NjZUl4Rnl5NUpjeVpTRjRTU2xJdFlxQUt2aEhMVXNGeTg2bFJXMGxXZEtnQVJ4QUJFYU10b0J6L2FyaDBodHBvSmxFS0F1VUxDdlRRUWU5ZXd0N211enpmajNzZFROTSsxVU96TTRXMUw3cTNoZEtSZTNRa1I1dm5HaVJtTno1N2pwSDBQbnBWTmdoSkNWSmRLVzFjaVFjdnp0SGxIN1JXQzJLTFZKV3YwcHNOU05XVXJ2bWRneE1BWFVCMFZxZk1HRHVQYVJFVzdwbUhLM08wSVVkTnJ4MFRqTHJBU1hRbTZ0ckdPVGZqckVQSXE0SHFEVHBnSmd2U0FMOElFTDc1Q0JCK2NGeE1DT0pSN0xsRm9UTExBQ0FwQVVwQ3JhNmVlOFI4eVZLY0RpWEVxUTZNcWtsQUhpQThPM3crRUtLMXl6RHEvQ0F0QlFDU2JrbitnSHppUG1IY3FNcXRiK0hXQmNmRkFwbVpkc2xLUW1XcDgwM0wyTGJoUzQ3bU5sWmdOQU50Q1BQV0tCVDVCaDZuVkZ4YXlFaEduR3locmY5STJxdXpFbk55THJWVlNISmNObnZXVXFzVkN4MXZ3c1FEY2F4aTgzTnBrOFBNeTdOczc5eVNCdU9jSXVYMG91YWRScVVwZUYvQlhCcnJBdnZ3Z1FMeGFzcVVBYmtjSUFPc0FXZ2VucEVwa1VMRzhMVHFJYVNRTlRjMmk4MDNBRS9NTU1Pdk9oSGZKQ2twUzJTU0NOSVBmR1BiQmFiNktrMmttdzQyanZaYlVScVBqR2hTSFppNnB3QmJyMlcrcEtRSTBURG5aTkp0NVhIbVM1L3dDNmJqNFJHL2Q5S0IrbnRtSlVxalRsU2NTaVNsWEgxZnlEUWVaMmpVc0lkajg1VU83WFVsaENUKzdiMkhtcitrYlRSY0x5TWd5aENXazZhQUpGaEZscDdhbVNwT1ZBYUJHUUpCQ2h6djY4bzdiWDFFUEovd0FTbzRTN01LTlJsaGFHa2w1TzdoR1paOVQra1grbFU1bVZSZHBHdCtPdG9kU2dKVUZDMnZ6anJaVUI0WVhLWEZJaFcrem9VbXo3WTUzTVBKQTlyV09GaDlJNW5WM21XQ0RyZTE0ZWJVVFBPOGdBUGxDV3d4YXhkWXZ3U1lTMm4vS3FUMC9TRFdkTk5TUVJDV1ZEdXJIaUQ5SWl6cU9Hb3BTcEpXUm9Vb1VmUlF2R1MvYU1wWW1lem1ya3A4Y204MU5KNkFyc1Q4MXhxMDhUN0ViblVOS0h3Ri8waUN4eFRHYTVKelZPZi9ZMUdTZGxsY2dUNGtuMElpeEI4VUxmWjRCcUNzMHJsTzdaRmp4dEVXZWNURmJsSHBHYm1aU1pSa2ZZV3BseFBKU1RZL01SRHh6VmNsaFNjbHlDRGdvQjJnYkpCQXZBNDhvT0pPUFZrMU5LVk5zdGtISTJrclNMN0hXT09lWFpLbGNoL2VCQWlVM3lDMTBVdXRPcWJsNTlTUW15SlZ5eWJDMzdOWDlZeGQ5U2xMQ1NvbEtCWklKMkVDQkMySEQ2Um9qckF0ODRFQ09mWkFBSU1DQkFnbzlIQm9IaUFQbEhxenMxS0p6QStIbjVoR1p3eWdRVGZmSVNrZkpJZ1FJc1I2c1RrTGVDeWdyQ1dkdHRmN1JMVXFvanVzcGFKeW13OFg5b0VDSWxKMFFvcGtrbXBvR1pQY0hZNjk1L2FIQlYwbG9yOW5PWWZ6LzJnUUlyU203R0tDb2UrLzdJQjluTmxianZQN1E2Y1FnaEtoS2tHNC9lL3dCb0VDQWJDMm9EZUpSN1lGR1VQZzBBNzMveGhaeFFHNWh4WHNaSk5oKzE2ZjZZRUNBYkNVVUsvd0FVZ3Exa3pzZjN2L2pDVjRvRGFVajJNbTRQNzNwL3BnUUk2enRpSTZjeFVDeVVleGJvVisrNlcvaGptcWVKMHZPU3Q1S3dTYmZ0ZHhzZUVDQkJ4a3dYQ0o1Tzdmd3czMmpUYjB1ejNRbkpkbVpXa0hRTEtiS1BybHY2eG1scndJRU9rL2xSRVZRVm9BZ1FJQU1Nd0JBZ1IxczQvOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9NVGVyZXNhLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELy9nQlpSbWxzWlNCemIzVnlZMlU2SUdoMGRIQTZMeTlqYjIxdGIyNXpMbmRwYTJsdFpXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9rZHZaR1p5WlhsTGJtVnNiR1Z5TFVsellXRmpUbVYzZEc5dUxURTJPRGt1YW5Cbi8rSU1XRWxEUTE5UVVrOUdTVXhGQUFFQkFBQU1TRXhwYm04Q0VBQUFiVzUwY2xKSFFpQllXVm9nQjg0QUFnQUpBQVlBTVFBQVlXTnpjRTFUUmxRQUFBQUFTVVZESUhOU1IwSUFBQUFBQUFBQUFBQUFBQUFBQVBiV0FBRUFBQUFBMHkxSVVDQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFSWTNCeWRBQUFBVkFBQUFBelpHVnpZd0FBQVlRQUFBQnNkM1J3ZEFBQUFmQUFBQUFVWW10d2RBQUFBZ1FBQUFBVWNsaFpXZ0FBQWhnQUFBQVVaMWhaV2dBQUFpd0FBQUFVWWxoWldnQUFBa0FBQUFBVVpHMXVaQUFBQWxRQUFBQndaRzFrWkFBQUFzUUFBQUNJZG5WbFpBQUFBMHdBQUFDR2RtbGxkd0FBQTlRQUFBQWtiSFZ0YVFBQUEvZ0FBQUFVYldWaGN3QUFCQXdBQUFBa2RHVmphQUFBQkRBQUFBQU1jbFJTUXdBQUJEd0FBQWdNWjFSU1F3QUFCRHdBQUFnTVlsUlNRd0FBQkR3QUFBZ01kR1Y0ZEFBQUFBQkRiM0I1Y21sbmFIUWdLR01wSURFNU9UZ2dTR1YzYkdWMGRDMVFZV05yWVhKa0lFTnZiWEJoYm5rQUFHUmxjMk1BQUFBQUFBQUFFbk5TUjBJZ1NVVkROakU1TmpZdE1pNHhBQUFBQUFBQUFBQUFBQUFTYzFKSFFpQkpSVU0yTVRrMk5pMHlMakVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGaFpXaUFBQUFBQUFBRHpVUUFCQUFBQUFSYk1XRmxhSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJZV1ZvZ0FBQUFBQUFBYjZJQUFEajFBQUFEa0ZoWldpQUFBQUFBQUFCaW1RQUF0NFVBQUJqYVdGbGFJQUFBQUFBQUFDU2dBQUFQaEFBQXRzOWtaWE5qQUFBQUFBQUFBQlpKUlVNZ2FIUjBjRG92TDNkM2R5NXBaV011WTJnQUFBQUFBQUFBQUFBQUFCWkpSVU1nYUhSMGNEb3ZMM2QzZHk1cFpXTXVZMmdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWkdWell3QUFBQUFBQUFBdVNVVkRJRFl4T1RZMkxUSXVNU0JFWldaaGRXeDBJRkpIUWlCamIyeHZkWElnYzNCaFkyVWdMU0J6VWtkQ0FBQUFBQUFBQUFBQUFBQXVTVVZESURZeE9UWTJMVEl1TVNCRVpXWmhkV3gwSUZKSFFpQmpiMnh2ZFhJZ2MzQmhZMlVnTFNCelVrZENBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUdSbGMyTUFBQUFBQUFBQUxGSmxabVZ5Wlc1alpTQldhV1YzYVc1bklFTnZibVJwZEdsdmJpQnBiaUJKUlVNMk1UazJOaTB5TGpFQUFBQUFBQUFBQUFBQUFDeFNaV1psY21WdVkyVWdWbWxsZDJsdVp5QkRiMjVrYVhScGIyNGdhVzRnU1VWRE5qRTVOall0TWk0eEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMmFXVjNBQUFBQUFBVHBQNEFGRjh1QUJEUEZBQUQ3Y3dBQkJNTEFBTmNuZ0FBQUFGWVdWb2dBQUFBQUFCTUNWWUFVQUFBQUZjZjUyMWxZWE1BQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUtQQUFBQUFuTnBaeUFBQUFBQVExSlVJR04xY25ZQUFBQUFBQUFFQUFBQUFBVUFDZ0FQQUJRQUdRQWVBQ01BS0FBdEFESUFOd0E3QUVBQVJRQktBRThBVkFCWkFGNEFZd0JvQUcwQWNnQjNBSHdBZ1FDR0FJc0FrQUNWQUpvQW53Q2tBS2tBcmdDeUFMY0F2QURCQU1ZQXl3RFFBTlVBMndEZ0FPVUE2d0R3QVBZQSt3RUJBUWNCRFFFVEFSa0JId0VsQVNzQk1nRTRBVDRCUlFGTUFWSUJXUUZnQVdjQmJnRjFBWHdCZ3dHTEFaSUJtZ0doQWFrQnNRRzVBY0VCeVFIUkFka0I0UUhwQWZJQitnSURBZ3dDRkFJZEFpWUNMd0k0QWtFQ1N3SlVBbDBDWndKeEFub0NoQUtPQXBnQ29nS3NBcllDd1FMTEF0VUM0QUxyQXZVREFBTUxBeFlESVFNdEF6Z0RRd05QQTFvRFpnTnlBMzREaWdPV0E2SURyZ082QThjRDB3UGdBK3dEK1FRR0JCTUVJQVF0QkRzRVNBUlZCR01FY1FSK0JJd0VtZ1NvQkxZRXhBVFRCT0VFOEFUK0JRMEZIQVVyQlRvRlNRVllCV2NGZHdXR0JaWUZwZ1cxQmNVRjFRWGxCZllHQmdZV0JpY0dOd1pJQmxrR2FnWjdCb3dHblFhdkJzQUcwUWJqQnZVSEJ3Y1pCeXNIUFFkUEIyRUhkQWVHQjVrSHJBZS9COUlINVFmNENBc0lId2d5Q0VZSVdnaHVDSUlJbGdpcUNMNEkwZ2puQ1BzSkVBa2xDVG9KVHdsa0NYa0pqd21rQ2JvSnp3bmxDZnNLRVFvbkNqMEtWQXBxQ29FS21BcXVDc1VLM0FyekN3c0xJZ3M1QzFFTGFRdUFDNWdMc0F2SUMrRUwrUXdTRENvTVF3eGNESFVNamd5bkRNQU0yUXp6RFEwTkpnMUFEVm9OZEEyT0Rha053dzNlRGZnT0V3NHVEa2tPWkE1L0Rwc090ZzdTRHU0UENROGxEMEVQWGc5NkQ1WVBzdy9QRCt3UUNSQW1FRU1RWVJCK0VKc1F1UkRYRVBVUkV4RXhFVThSYlJHTUVhb1J5UkhvRWdjU0poSkZFbVFTaEJLakVzTVM0eE1ERXlNVFF4TmpFNE1UcEJQRkUrVVVCaFFuRkVrVWFoU0xGSzBVemhUd0ZSSVZOQlZXRlhnVm14VzlGZUFXQXhZbUZra1diQmFQRnJJVzFoYjZGeDBYUVJkbEY0a1hyaGZTRi9jWUd4aEFHR1VZaWhpdkdOVVkraGtnR1VVWmF4bVJHYmNaM1JvRUdpb2FVUnAzR3A0YXhScnNHeFFiT3h0akc0b2JzaHZhSEFJY0toeFNISHNjb3h6TUhQVWRIaDFISFhBZG1SM0RIZXdlRmg1QUhtb2VsQjYrSHVrZkV4OCtIMmtmbEIrL0grb2dGU0JCSUd3Z21DREVJUEFoSENGSUlYVWhvU0hPSWZzaUp5SlZJb0lpcnlMZEl3b2pPQ05tSTVRandpUHdKQjhrVFNSOEpLc2syaVVKSlRnbGFDV1hKY2NsOXlZbkpsY21oeWEzSnVnbkdDZEpKM29ucXlmY0tBMG9QeWh4S0tJbzFDa0dLVGdwYXltZEtkQXFBaW8xS21ncW15clBLd0lyTml0cEs1MHIwU3dGTERrc2JpeWlMTmN0REMxQkxYWXRxeTNoTGhZdVRDNkNMcmN1N2k4a0wxb3ZrUy9ITC80d05UQnNNS1F3MnpFU01Vb3hnakc2TWZJeUtqSmpNcHN5MURNTk0wWXpmek80TS9FMEt6UmxOSjQwMkRVVE5VMDFoelhDTmYwMk56WnlOcTQyNlRja04yQTNuRGZYT0JRNFVEaU1PTWc1QlRsQ09YODV2RG41T2pZNmREcXlPdTg3TFR0ck82bzc2RHduUEdVOHBEempQU0k5WVQyaFBlQStJRDVnUHFBKzREOGhQMkUvb2ovaVFDTkFaRUNtUU9kQktVRnFRYXhCN2tJd1FuSkN0VUwzUXpwRGZVUEFSQU5FUjBTS1JNNUZFa1ZWUlpwRjNrWWlSbWRHcTBid1J6VkhlMGZBU0FWSVMwaVJTTmRKSFVsalNhbEo4RW8zU24xS3hFc01TMU5MbWt2aVRDcE1ja3k2VFFKTlNrMlRUZHhPSlU1dVRyZFBBRTlKVDVOUDNWQW5VSEZRdTFFR1VWQlJtMUhtVWpGU2ZGTEhVeE5UWDFPcVUvWlVRbFNQVk50VktGVjFWY0pXRDFaY1ZxbFc5MWRFVjVKWDRGZ3ZXSDFZeTFrYVdXbFp1Rm9IV2xaYXBscjFXMFZibFZ2bFhEVmNobHpXWFNkZGVGM0pYaHBlYkY2OVh3OWZZVit6WUFWZ1YyQ3FZUHhoVDJHaVlmVmlTV0tjWXZCalEyT1hZK3RrUUdTVVpPbGxQV1dTWmVkbVBXYVNadWhuUFdlVForbG9QMmlXYU94cFEybWFhZkZxU0dxZmF2ZHJUMnVuYS85c1YyeXZiUWh0WUcyNWJoSnVhMjdFYng1dmVHL1JjQ3R3aG5EZ2NUcHhsWEh3Y2t0eXBuTUJjMTF6dUhRVWRIQjB6SFVvZFlWMTRYWStkcHQyK0hkV2Q3TjRFWGh1ZU14NUtubUplZWQ2Um5xbGV3UjdZM3ZDZkNGOGdYemhmVUY5b1g0QmZtSit3bjhqZjRSLzVZQkhnS2lCQ29GcmdjMkNNSUtTZ3ZTRFY0TzZoQjJFZ0lUamhVZUZxNFlPaG5LRzE0YzdoNStJQklocGlNNkpNNG1aaWY2S1pJcktpekNMbG92OGpHT015bzB4alppTi80NW1qczZQTm8rZWtBYVFicERXa1QrUnFKSVJrbnFTNDVOTms3YVVJSlNLbFBTVlg1WEpsalNXbjVjS2wzV1g0SmhNbUxpWkpKbVFtZnlhYUpyVm0wS2JyNXdjbkltYzk1MWtuZEtlUUo2dW54MmZpNS82b0dtZzJLRkhvYmFpSnFLV293YWpkcVBtcEZha3g2VTRwYW1tR3FhTHB2Mm5icWZncUZLb3hLazNxYW1xSEtxUHF3S3JkYXZwckZ5czBLMUVyYml1TGE2aHJ4YXZpN0FBc0hXdzZyRmdzZGF5UzdMQ3N6aXpyclFsdEp5MUU3V0t0Z0cyZWJid3QyaTM0TGhadU5HNVNybkN1anU2dGJzdXU2ZThJYnlidlJXOWo3NEt2b1MrLzc5NnYvWEFjTURzd1dmQjQ4SmZ3dHZEV01QVXhGSEV6c1ZMeGNqR1JzYkR4MEhIdjhnOXlMekpPc201eWpqS3Q4czJ5N2JNTmN5MXpUWE50YzQyenJiUE44KzQwRG5RdXRFODBiN1NQOUxCMDBUVHh0UkoxTXZWVHRYUjFsWFcyTmRjMStEWVpOam8yV3paOGRwMjJ2dmJnTndGM0lyZEVOMlczaHplb3Q4cDM2L2dOdUM5NFVUaHpPSlQ0dHZqWStQcjVIUGsvT1dFNWczbWx1Y2Y1Nm5vTXVpODZVYnAwT3BiNnVYcmNPdjc3SWJ0RWUyYzdpanV0TzlBNzh6d1dQRGw4WEx4Ly9LTTh4bnpwL1EwOU1MMVVQWGU5bTMyKy9lSytCbjRxUGs0K2NmNlYvcm4rM2Y4Qi95WS9Tbjl1djVML3R6L2JmLy8vOXNBUXdBR0JBVUdCUVFHQmdVR0J3Y0dDQW9RQ2dvSkNRb1VEZzhNRUJjVUdCZ1hGQllXR2gwbEh4b2JJeHdXRmlBc0lDTW1KeWtxS1JrZkxUQXRLREFsS0Nrby85c0FRd0VIQndjS0NBb1RDZ29US0JvV0dpZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvLzhBQUVRZ0JMZ0RjQXdFUkFBSVJBUU1SQWYvRUFCd0FBQUlEQVFFQkFRQUFBQUFBQUFBQUFBUUZBZ01HQndFQUNQL0VBRUVRQUFJQkFnUURCd0lGQkFFREF3SUhBQUVDRVFNaEFBUVNNUVZCVVFZVEltRnhnWkdoOEJRak1ySEJRdEhoOFZJSEZXSWtjb0l6b2hZbFEwU1MwdUwveEFBYUFRQURBUUVCQVFBQUFBQUFBQUFBQUFBQkFnTUFCQVVHLzhRQUxSRUFBZ0lDQWdJQ0FnSUJBd1VCQUFBQUFBRUNFUU1oRWpFRVFTSlJFekpDWVhFamtiRUZGSUdoMGZELzJnQU1Bd0VBQWhFREVRQS9BT0Y1aWpVR1loUXpNYXJlTGVRU1Q1eDYrZUZHNEh0SzdpQUFLWkpHbUFCejU4b2dZQUQ2cXdCRU1UVUtuekF2RWtqY2RMZGNZeFE2RVZHQVk2TlVuVno2YmVtTVlJeTZsa0FNOTRUQ3dZbTh6L2s0SmoycFNSRnBDdTZIVXBJTjROOU1XODcrWkdNWXFUdXlDRVowTFdNN2VvOHQ4WXhlNnBXZUVjR0RBV29ZQXZmNytrWXcwT3l1cWxLb1dKcUhTb01Tb0luMTllZkxHTHk2STFLWnB1RGNnaytIY2tqZGV2TTR4TXUzYW5xMUFoSU1DL3A2L3dBakdNVlZhTk9vTldsUUNTRko5Ujg3akFla0RUMHl4TXBVY3lsSU1zWGs3anp2ZjF4TG1QR0RYNkYxSEpaZ0pWS296QXFvSkNTdS9QNEdLWEVxc2MrQVJRNGRtYWlzMU1GYkVpMFc1aWY1R0ozQW5ERVN6ZkNzeFNnc1dKQjFEU2R4c1AzSXcwWndib2VVWkxvV2R5cGdWR21RVENBeUx3SVB6aW5ManBBanBVeXpMVWdsUlRwU29vSUlPOFNlVThqZXg1Z1kxM3NaTXJhV0lsVTFOeWJZSDlqdmdvMUVxeUFLMEJXRm9KcUVRT285eWIrZm5na3BrR1JCWGd2WU1BRDliUnVMNEtGTDExMkZRYUZNcUhDallEbDdIOThaalI3SnJWWVZYMWpVQ0FwTS9wMjk3YllGWG9hWFJVbFh2QVJVT29hVG9La2lEeStweHVGYkpsdE55dENSSmJWUHFKSnVUYU52cGliN01XbVFYZEg3elZ2YUk4cjN0aGpGUVlocE9wYmF2RUl0YThIMytNWWtmWmVqcVR4VVZZeVJlb2l4OG0vcmpGUVhNMTBOZXNOSVA1cDFLSi9WUFB6c0RqRXVaWjNsT200ZnhWRFVIaEhVbmxQcEUrVTR3M0pGQmMxYWkrSXF5NlZZaXczQk0vMzVSakc1SXNINmlXVmdTYnF0T0Fia3laOW94Z04yeU9wZFVCbVJWQUxTWnRIbWZMNzU0S2xSQmFhVkZWZGVzeVpXQ1pnN0RuTnh0akFic3N5MU12Uk5ReVFKWTdIVkYvaTJNQWtLclhZTHFYYllnMjUvTUU0Qmp5aXphdElLaGpGK2t5SitaOWNZTnNoVUovUllEVnN3OUI5TnZuQk5Ic2t3T2xrYnhJWWhRMFNkb01mN3dIMFBkYlBGcDFuVkZwMHhlU1BNa0NEZjl2SytKL0ZleDR4bFAwYkhnTkdqdzhpbG5hQ0dxNk1nTXpESC9qeU84VGM3eHl4eTVhbDB6b2hHVVBScU1yeFJCbDNGZmg2MU84VWtvWDhDeHNDUElBeWZYSFBPSExwLyt6cWc1UjdBK09wVHoyWXFWZUhyU0RzQXIweHBwVXhCZ1J1Wmk5eGM0YkRhV3lPVGN0Q0tyVHpPWEFOY2Q0bzhmaVlFZkhuanBoSkNTRmxaUTFHZjBGVjFOWUV4c1lqL0FPVThzV1V0aVBvVEZTYXQycHdvQlV5YldKMkdLcDJLdWl4TkJZNlcwRG90NDVrOWQ0d2JvelRaNnNCM3BuV3JyeUlGcGlHMzljYTdNbFhaR3NpaEQzWkxzUUhzRHNaMkh2aG9nbEd3ZFNacWxTWTNBT3d0YWZyOGtZZEFoR21TMWttUUFPN1lrU1NJSFg5dm5BWXpMNkNwb0JMck53d0Eza3p2MTg4S0xMb25VUnAvTFlRQ0xFMk1iZnYrMk1UTHFWZW9RTlIwRXNicUFTSTVmZlRDR0sxcWhIWU5xWXV2S2JXbisyQ1krcG1tZ0lFZ0V6QlVXeGhsR3RDWE5QOEFtNWxXVUdLckFueWt4MDVHUDlZYWptcEUrOGFvbmpqV0pWakJ1SjJIejV6T0FHanlyVklobElBVnRWakc1Mm4yTUQxd0RCQjhkSUVHNGxtbXBxRTh3YkE5RDVIR01WTVNhTFNKYitnRW1ZUElpUExiMTZZd1M5bVVvVUZSWE1SZHQ3bmFQVEdNZlVhaUVCbnBsZ2ZFeEZwdGZiMCtudGpHQ0tWZFRUVVVsSmJTWUtONzlMWURHaVJid2VFQzVIOVg3QWJmNHQ2cjM3R3BIMlhvVmN5NjBxUzYzWmdmQ2w3OHYzK3hoWEpSN1k4Y2JidEhSdXluL1RkczlscU5iTTFXWjNDdUFEcFdJTnllZitlV09MeVBPUzFFN3NmaXhrdG1uZnNad1hJRWl2U0pjUmMwU1FPVXplUDg0NDM1RXBkTXNzYXg5SStmSzVUSUl6MGFMMGc0VU5WWkNLamlmMEpQNlJlNTh4N0dNNVNEUG9VMXExWE5VcWkwY3RTcDBRN080WXJTcGhMMkxFamtESnZNOVl4V01XTEtRbXI4UnlsVUY2eTFrUXROTmloQUo1aVJFZGQ4VVVMMG1jOHBwYlNFdWZOR24rZmxxMVduVEJrTVRKanJQcmJGNFJwVUpKM3V3Q2pXTlhPYWFxZDlTQUJCVU1HTWNoLzVHM1VXdzcxc1dJYlQ0SVhwcTlESjVqdXAxTVZBWWpjVHltd3hsbEg0cjBRbzhQUkhEMGxKV2xMTWFpYVNJSG43NHB6dG00Z1ZlbTlJTWpMUnBrblZwTVc5ZW1HYjJxRmtxQjdvNFk2UEJ2S3pQTGZrUGpGRTJJdXdjTjNRSGVDV1ZpVC9BQi9Iemdwc0xQSnB2VnFNQXdVay9xRWdjZ1FDT1UzSHJnOWs1UFJLaVZWZnl3eGFDUVFKQWs4c0VWTnQweVJySTFlV3FLckFsaVF1NGl4dDk3WURIU1gwRVVScnBJcnlDRnZwNWIyOUxqQ2pVcTZLaU5YNmxMQlJBZ0FSYWY4QVdNUlBhU3JwdllUNGZUR0c1UDJJYzFJclZTSko3MXBrL3dCT296dGM3ZTN2ZzJjNUZSVkU2Z0ZNRThnVEF0SjViNEJnbEdSa1VzQXdtVllyWnVjK3dKTWVmbmdtUFZyOTRvcGdNemRaRUM4ZnoweGpGbEoxWUFPLzVZSnRQSWZxODV2ZmxnTUs3SlV3SDJBQUJLc0lGcjgrbHp2Z0JhbzhOSFVDRi9wSi9wSHovR016Qk9SSDZuV0JJa2lOK1FQVENTdlZNYUt1eGx3M2dlYjRwWFZNdlNyVkZhQVNMS0p2Yzhwd21iTkNDT2pIZ2M0blpPd0gvVHBzalVvWnZpOWNSS01xTWRJbTU1K1h6anhzM21la2p2eDQxQldkSHk5SEk1SExybDhvOVF0b0NvcUF3SUJ1WXRmbmpqL2JhS1dKT0tKbWMwcjFxNzFNdlRwaGRLMDBKVVdNR0J1ZCtwOU1XZzZSclhSbGUwK1hGUEx2VWlvR053akV5VHpMRWJzZWcyODhkR09iWFFydm93K2JvMUtsU2t0U2t3cUtaWnFqU2ZRRGtCanFpL2paR1NHUEVpL0ZWcDk1bnN6VnJaZFZvclR6VGx0Q2dDU29IaEErcGpDUm5YUm9xTWxWYk10eGJKdGxtcjBxRlJseXhhN1g4TWk4SHI5TEhIVkdhT2ZOaDRxd0xzemwyZG0xVktNSkhnazNKbm51SU1RYjRNOGthcWdlUEJ5MHpwZkR1SDBXNGNSbWMzVFN1dmlWZTlFbTVJMEVEYUJjZFp4eThxWmZqeDBCY1NvdTFHcldWNlQxdG1WeEFZRXdUNWpZaThXeFpUdmFGdlJtdUpVWEZNYVlLT3Fqd1RGejFPM1BIUW55NlpwUjVKR2N6QVFFbnVTU1NmNnRoeUcvbml5MTdJY1dnRFBCaUF3UWhYT21BZHJIRFJhc1I4Z1VGMkZYVHFYeGtFY29POGo0K1RoN1hvMVAyR0pKUm1pR01rZ3hieTYyNVlEQ29xeTE2YUdMc0FiTUxTUU50dnUyRnNaSTlMVXd6aDFHZ2d0SUFKOHR1YzJ4Z2txZElNRlZYQllvSnNQRWVmMCtNWVhndm9sVG9tcnJjTG9KYTZsb2c0UzJEaC9RanFudWN6WHF1cUg4eDUxSHhmUEltMjNtT1p4UTVTYjBWSytCZTc4T2tpYmMvRDF3QW53YW5WRFhkV1hhWkpLNzdIekErU2R6akdJME1yVHFhaFRVU29IT0lNZUd4Ky9qR01FVXN1OU1NVG9MQzhlYzNIOHovbkN0aFNMeFM3eFVjc0E0WTZpUkZ3Q0Q3M0kvdmpXUE9PeXlvV2dhd0lFRlNGdDVtUGcrczRWdHRvV21OT3ozRGpuYTZxYWJ0SThUQ1RBLzl2VTJ0NTRqbW5XaTJPQjJUc3prdndPU2VuUnBoS3F3SFlBRVV4ZVZIWHpQWEhqNUpTY2oxTVNTVkYrYjRoV3A1M0w5MVVOVE1FQUtIR29sUURjOGw2NEt4cDdabVdOeDZ0UnFycXpEd242eFNYOVVBM24rTUJ3U0ZISER1SlVhMldwNW5OVnExZ3JsWElVamxlODh0Z01LNE45QlZHVDQ3Mm5UTVpsemtLTld1LzZLZFJoQ0l2UkI3YjR2and5cTJLNW1jek42WXExMTd6TXVWOEtCbWFJM01ZdEdscGg0dDlGTmJoM0VBd3FWOHRtc3ZRYzZnV1FnUUJFek5oZ3hrcm9FbzNzRHE1cFJTQ1ZYZXBwQjB6elkrdnRoMG51eU0zVDBFNTNKdlN5bVR6T1RtaGsrNmhUVmpYbUh2SlZCc29QUG9ONzQwSnU2WnBTcm9yQ3NvS21XVlZXU3BzcE1pUmZiNjN3VytTc1pKSlVnc0N2bXVIMWtxTVdiTEtOVEZ5U3FrbmNmOGJnVHZNemhVOUFVYld6ek0wbXJvd3IwZ0VRcXowMkFrUUc4WG1PZnZncGhUYVJuczlsYUJXby9jajlVS2RPNDIyNjNOdjc0dkdWQzk5aS9PNUlqTHFmQUVwd1Naa1IwbkZvdEVaSklWa29nWUZLYW5kRDV6OTJ4VlVLVlFxcy9kYWRCYUFRWkttQnQ5OG93YkRTUHFiYTZ2ZG5wWU41eWIydk1mdmpHZWxaTllVb3hEaVJCNWtpSVA4NHhMbkltN01RbGdVSWtjLzhBZjk4WVBObGdmU0FvUmFnRmhDQXdCc01Da1VGV2FSZTlyNkFVaG1Ba1RZRW4vd0RyZ25EWVJsS2V1bjRRMGNpb3V3M2duM2tXeGpXZW9sUFFEM2pCUVFUWWk5aEI1Yy9mR29ObnRIUUdjbG1tWi9TSUFKdkVjeDVlY1l3U09YcWttWFZ0SUVBa3dEZWVWdXYxd3JDaTFTU2pFQi8rVXFPditoZ0Q4MlVyU1VsaEpSQVFKbVFMeVluNzljQzZadWI3U04vL0FOUHFEVlVjMGhxck5DSkFnMDdqeFczaVQ4anBqei9KbHZaMitPdVd6cCtjclpiaFhDMW81TlFhamdKVER0NFVNRTZtOU4vVTQ0Vjh1anJhYU02MVVyVW9aZkxsWHJNbjVqNml4WVFUSk1iYjc0dXJpaGI5bFdkNG9NZ0FXYktaZ0ZGYlJVa0VTQ05Xd25hdzh1V054dGE3RmM2QU15Mlc0clNwczRjVkdVSDlla0FneVRwUDdIQlVlSzJNdm1CUDJiclp2T011VEx2VVp3RkNUNGZjbnkvME1VV1pWVE5MREkwWENPSFozaGRaUlN6TlhWVGRWWm0wT05YL0FCODFzVDFNZW1JVG1zaXVJME1UWHMxOWRWNDl3ek0wSzlHcFh6TE5xUTZDakNCRjJ2cEFJdEhUSFBUak5Oc2ZVVlJ5ZnRGd1BPY09wMGUvS210VWxVRkVGek1XbGowNitXUFR4NUl2U09UTmllbkV5Qnp1YUZETlVsZlFhODBpZ0ExRUtDMEE3amJsdmlxaHgyaURkNlkvcDVsY3JWVjZ1cW9wUUNVQWh3UUxTVGJ6K2VXRWNXOUlmbFRHbFhpWXlwV3BRekdXY0VnbGFaMkJtUXhHOWlSenZHSnZHMTJWL0l1a0haVE4wK0lWSHBwcWVucGxHZVdJSUJCVW56SHhoSmZEWmw4blFxNCtpNWJMOTdsbFE1ZXFZME1ibzRzeXg2WXJqYWtyQktQQmlXcFRMTlZOSmFpekxNRklpQnlnMnRmRmt5YlZvQXpORkpLQmR5Q0JCQUo2anl4ZFNwV2lYVEFFZlNHL1FKbFNHc0lnN1lvbllTZE9ucVpYcDJWZ1RIbEd3UFRCTjZvK1haV0lZQzdFYkhwOU1ZVDhhSU1JQ3RyRnhjZ1JxSTVldU1iZ2o2blRwbFlkeFRLbUlMajV4ckhRdnJQTmF2Y0FHc1FDQ1J6dWZMYWZmR09BbFJyRmFTK0Fpb1RJQXZlT1dNWkt3dE5JQkNzMmlvSk1IYzN1ZktmNDZZdzlVUk1zZ1VnQjdydEczTDV3R3cwZW9ra0F3TEM4Q1pISyszK3NLMllzVUsxQXdBUXhNc0FCUE9EL0FHdGVlZ09NTTQxN0s2YlM5TmlRQWJFWGpwOSt1QTE3R2l1emRkaU0vVHlJcGtLVTAwcW9ESVJ6R3dIeGp6L0lpMzBqcnh5cFVoN1U0djhBaUM5V3BsaTFLa2dLcmE0bUFBZCtueGlDZzB0SXNzamIyRFp6akswTXNjdGxOUmVxOE81aUlBbjk4UEhISk8yYm5GdWpMWnpPRHZxVk5tTlJtZ0VzZVY3L0FCOFk2SXBjVzY2SnVTNVVkTzdGOERVNVdtOVNvV0p0YndnYmRNZWRteXUyZWpoZ2tyTnBVeWdwWlh1NkN2VEo1ckl1RDFqenZqamVTL1pWcHZzb3FjQjd4V2ZOVVdJaFRJTUJTT1hwZ3JKVWRCVFNkQ2JONVRNWktyV3A1SHZ3QzRpcVNkTnhzUWI5TVdoSlBzUDQwMVprZU9WczlUNGZVV3RSbFlBYXE3VE43UmMzSkgrc2RlQnh0dEhOa2c2b3pIRHVBb3h5M2VVaWRjcjRESjJ1Zkk5Y1hubW9oajhkdGJHZVk0STFQTDFBVllMM2xsaVNiY3ZMbjY0bkh5SFowUzhhNDBZblBVc3h3d21XVnFMQWFISExmNTMyeDZFYW1lWmtpOFJkd2pqVlhKNlNoYW1JZ3diTVJ5bjIrY0RKaVRWQ0tidXhsVjQ0dkVlOHk1VVU2bFloZ0NZMU1PaDZrUVBuRWxEaDBQOEFrY25zTG81Z0ptYU5ITVpZcUtzOTI5STJjekJnOGlPbU0yR0xiZTBEY1l5U0FGcVRrSTRCQmkvMysxOE5HZXd6alJsYWlOVFZ3R0VxMGkrKzE4ZGExUkM2MEUwU0JWQVlTTk02STNtYi9mWHl3YkdDbWJWUjhYaUtxYmkwOWZqR0IyQzFDd1ZmMFdBRngrcmMvZnJnakY2ZHlWSGVGVk1BRDhvR1JHQllMTTltbXAvaWFpa1ROVWlZZ21abmYxSjN4amdQcWNtbUMxNGlJTzk5NG1lUTNnMnhneFZCNlZEM0tOZlhJZ0V4TWpmK2NJNVU2b1prcWo2Wmxvc2Y2dHowUHZncmV3bFpmUzgxVmd1U1NTNGdHSnQ2WTFHc3BvbG1CTFNHWUdQajE2NHc3bW13bEdERk5JTUtMRWo3UCs4QjlEUm9lOEJSNm9wVWtZS3pzUXBreGRpZjdmYzQ1cGZIc3FuVlVPK0pQK0hSQlQxb2pBVXBrTnRib2VrOUlJODhSVnVSMFMrTWRpSE9lUE1PV2QxMUh3d0FCdDZ4aTYwdGsrTjdRUmw4dTJZek9XMGFsV21xbDlTeDluKzJKeWtvSnI3S1k4ZkoyZDY3SnAzT1Zwb0ZZc1JKZ2lXTUNUNjJ4NGZrTzVPajE4YXFKdDhtNmxTSFVIWWpwam5SSEpmb090b0kwaU1OYnFpRzdzRHptVXk5YWtROUJYTzhhSkk2WUhKbG9Ua24yWUh0TndVVktlaFllQkFYUnBpUmEzWC9BQml1SEsxZG5XcWtMK0U5bjNKcGFRb0V6MDViRHo4L1hEeXpXUFhHSkxqSEMyeTlOMVlraWJhU1JKNWV3d0lTWnJ0V2N1N2NaQjZKVXFCM1V5ZkRzZVIrbVBYOGJKYlBKOHVPdG5PcXVjT1F6cEN6VVFRd1F0SUJPODlmNHg2T3BIa3lkQStlek91b3h5N0VvcGthUkVjNDlRUWI0WkpMc1J6bDZOZjJTNHZudUkxOHJrWElxVnFsVmFOTWhSSUpJbmxiWVk1c3FvNnNNM1BzMUhFMlExczFscWIvQUluTHJyQ1BkUzhFalVMVzg5dHNTaXVXem9uMlpUTVVpS2FtVWFXWWJ6TzE4ZE1YZE1qTHNEZHRMNjlRS2dSY2JlM3JpdGlON0lhcFEvOEFOVnROak0vWXdROUUyQ2xqb2pTQnUwQTI2eWVuN1lISW4rVCtqNTBxVzBMM2dqZldvLzM2NDFsS0VHY3FkL21La2tFTVNEYTVNL1dlWHZnbkRSYlNxQWFhakFLaXdXaTR0Tno1YmkyQ0U5Q2xBdmgwRkJyS3RBMk56NXp2NllXZ2hIZGdOVWRkUkRRTmh6Ri8zSHpPTVlyQ3dsQnFaV0huVXR3VHZOOGF6RnRDa2pGQTB2VWUxcE1reDc0bGtlN0hoQlNlelU4TjRCbDRCNGlhbElzRWJ1cVZQVzBGeHZlQmZsOU1jOHNqL2lkdVBERkxadjhBcy93SEpVNjY1amgrUmVnVlEwa3FaZ1FRU0NDWUhyeUh4amx5WlcreS9DSzJWZG8rQnBReUZKVnBqOE5TR2hIRTZxamtrWDZEYysvUVlPT2FsdEJjZVRNTHhaVlNvR2htU1lKYVlnRHAvT09sZEVYY1hvSjREbkRXNGxxcUV3NnFXLzhBdUVuMEdKZVM2aXkvanQzczd2d00wNlNVR0t4VVdtSkMzT3FCOWI0OFdUdHM5VHRhTlRrNmpGZkcwamJxUmlYUkxJdnBCalZ0TTZXbnlJeHBTU2ROa2VOOWtEbUNWRE1oVVJOeUlPRjBIZ3VrQVoxNk5UV3NEa0xpL3RQUERKMHRGNFJra2dZaFNwWkxRVEJ2SkZyU09mWENMN1pXL3N6M0dLbEt1OVIzY3NnSUlJSkMrMTlzV2ozcGFHWFZITysxZVdHYnk5ZnUxMUtBR0xHVDRRWng2SGp6NHUyYy9rUTV4cEk0cDJrcEpsK0x0VFFsd0ZHcmxmbWVuVEh1eDZ2N1BuTXlxVkFPVXFLZ04vSHFJamUxcEgzMXdYMFRqN1JyZXgyYXkrUzR0U2FuU2JNTzdhS2VscmdrRSszTmVXT2ZLcldqcHhWRkdzNGhXbzBHcVVTUEVWMU9ZQWtrR2R0dDlzVGhHdEY1eVNkaU5DSzJWQlVTRFZuVkZ2WHl4YU90RTN2WXV6TkpoSlJYRjc2VnQ3NG9tSTFleVZDak5OQXcwb1JBRXpIS1IrMkd0QnNJN3FuSjd1SWV4L24rZkxDV0NpTEtoUGpSV085dGhOLzNKd1JkbWFxb0Z6YlZERWpNRWdHMFhZbWZxWjJ1Qmh6a3NyVkhiTG92aVlsSWhsdWJ6eTIybU1FSllGQW91NFV0ZlQ0UjAza2VRRjR3QWhIZGFkREVNQnBZcVRNUkFrUmdXWW5WVjRVRUVLRjJuZjhBZjcrY0JqSk5qcnMxbEttWXovZTBrSk5NR0NJOEpnM1B6am56UzRsc1NwMHphWk5VeWRPbGNkNDZ5UnVaa0dZOXVvQXh4dHQ3WFIzV24wTmN2eGl0a2ErcWpWU29Xa0Vqa0NObDJIcmhYQ00rd3VYMEZyMnM3N0pQa21Ta211bWFkU3ZVWWEzRnJXc3N5Yjd3TUlzS2pMWFFlZjJaL2lsSGd0U2toV3ZSZk1PQnFXbWo5MVRFR0FKdXh2dVR6MnhaT2ZTNk44V0wrRlU2ZFRqTk9obHU3VkRvUVFiQXpjeWZQN3ZnZVJLb3V4c01ibC9SMGppUEhxbkNjb1RscVlxWm93bE1FYzQvZStQTmpoamtsYlBSY3VNYVJoT0ljWTdRNWlqbUtqY1dxRlViOC91VklwMHVjQnlZbnJFNDc0WXNVZTRuTzNQdmtJNnZiVGl0Q21hRkxpalV5UkFOT3VvQTlBRGg0ZUZobDh1T2ptZmtTVHBobkRPM1BhSEpLTmZGYTFlbVovTHpJRlJmci9mQW40bUtmVVRZL0ljZXpkY0Y3UjV2anRTald5aXZUeTlBbDh3N0xxbG9zUEtldmxqejhuand4U3BucVljdjVZMks4OTJ6U2hrL3c3bDZwVWt1cWlEQWF3bmw1K3VMUjhSeTAwVHpaNHdiU1lxUGIybG1YSzFjclNwa25abUl2NVgyL3Rqb2ZnT0M3bzVWNXV0RVc3Y1phbFJxSytScVBVSnNRM2hNMm56M3hsNEx1MjdNL05sK3JPVWRxcXRLcHhXcFZvU0tSRXI2UnNaNld4NjJOSlJTUEZ6eWNwT1FMUW9kNW9wd084V2JrU0NDZXZ5WjlNTXljZnMyZlk3SmlubTlUYWRUZnBPbUFJSWozeHpaWHJSMTQ2dlpieEp4VTRwVjcxanJZTVFSUG9DUjlQUzJHakc0OGdaYjVKRTZLb2NucFp6ckZYeENKV0NQdjV3YWRodlFLb1pHZDRMTCtxQ0JPM1hyaGdIcXV5U0JwMHJlVzh3TmlNTUtlcURwUXFRSnQxMURwZ1VOWjlBZTVKTy9MendSZEdYcm1tY3hVRlhRVmVxeWkrcitvekhRYmV3T0hPSWpsNWFrdE5hamtLQVFJa2dFYi96R0NNRVVhZXFtekF5U3E3anhDUmVPdlQwakFDRzBoTlZTVkJFYURBSElUOWV1RllTTFExTFYzc3liaHpjN0cveHRPRjkwUEZwZG10N0E4SHpXZnExaGw5SThCZnZHYlNGRnIrdU9UeWNpV2pzd3gzYk43UzdPNWhpZ3AwMXIxQ3hRQlJNRWdHU2V2bE9PYjgzeHBIUzhhWXM0cHcrclFMTFRpb0VwNjlTN1JZRWptQkpBazduYkRLYXFqZmpvVlZlSDVnVkt0T3RxUnFkUFU0STJuWVllTFZna3FWaVROY000aG1LOUNwVGY4c0VLRkIwaFZCM1BXWkk5TVY1eFNJL2lmS3hwMmNvMUtQRjh0clZUM2RXV2szQUVRRDU3ZStJZVRLNHVrZEhqeGNaV2Ruem5aVEs4WXlzVkVDVkdzV1FIVWQvYVRPK1BLV1p3bHBIcHVTNDdPZWNaN0Y1VElabEtlZXFPMmtudXFWVWdVWFdQNmVRWUc5OS8zNjRlVmZvbms4VlpJL0ZtRDdYZGtzN3hIakJ6Z3I1Y3E5TkZKZW9xaEFCcGxZdHA1aGVXUFF3K1hGWTZQT3llRGM3VEduWnpzay9HYzFXeWlrbW5UcDZsZW0yeEE2a1hCL25IUG04amdkY1BHajdPN2RqK3orWDRKMmJ6L0RFVUFNN0FFWFlnZ0M1NTNuSGs1YzduTzJWY2VFbzhlajg2ZHVNZ2N2MnF6ZVU4UzB4cHFBQXhxMWJ6Nlk5M3dwcDRsSm5INStPWDVXbysvd0Q0aFRuY28rVDRWVXpsRmFCcXJWQTdsNlpaZ0ozZzI2RytPaUdYbTZaenpnNExRb3kyZXExbEZhclJRalZjMEFGV045b2lMeGk3VjluTkdUazdGbkZIMVpwUy9pSUFBMnZQN20yTWxSenpkMkU4SlV1bE5hSTFrTnNONEV6NmUrTTBhUFZHMTRQVHBLaEZTb3laa2sxTkxyR3BnYkZUNmNyWTU1TFIwYlRET0lETFZxSzFDSFZ3cFErRVNid2Y3WVhISnBVeWs2ZTBLNmVxbWRMTk92eUhRZ25lM0xGbHNuMTJSWm1XWEpBQk03OG9QK2NFT2lDZUozWWFZUFVIZnkrUHFNRVVzcGF1N0ROQkRUWWo0eGpFYXFoMzFQVVFuek1ZeGpLWmhXclpsMUxGUWFyQUJpUnNTUVoySEllK0hPSThBcEFWSENTZEVnZ2FTRC95Nm4wUHJnakJGTWdnQ25xMUVxRjVXZ2J6Z0JEcUxGbmU3RVNSR283Z1JHL1Q5OEt3aGVUb00xU2twVmxYWEVsclFQdVBQRTVOSjNaU01iUjJQc05rNldWbzFXekRPTXNHUWhOSUpkdVVlZHY1eDVQa09Vblo2T05xS052K015WXlkTlFHRkhVZTZwSmMxR0lpRmpyQmx6N1J2am1xV2pvNXBDN2lDWldqVXAxSFRXcWtNS2RIL3dEVlpicXEvd0RpQ2Y1eFNMY2RtNXBuamNCRlRLMUV6RmVtYzFXS1ptb2FiQWdQY3gxZ0dGSFg1d0hsZklibEY2b3gzYXA2T1gvQUl0UUlLZ1pTQjRBRkJ1U1J5M1B2UHAwWTdiUkhMTkxTTUh3TGlTSytWVTFBSHVwWW5hd20vV2VmcGpvelJ1TFFtSExVclora2V5T2VwMThwVGVvZFdwUXN6ZVJ5OWVweDRXWlZJOU9hYzRKb1o4ZjRWa3VOWlR1c3dvQTFUTnJ4alJuU0o0cHp4bURyZjlOTWhYck5vekpKQm5RS1FnZlhhMk9oZVpPTWRIVExMSDJqWTludUFjUDROazY2WlBTYXhBRlNyRnpibDVZNWNtV1UyUW5rbHlXaXhhYksrWUFXWGFrQ0NMbXpSSDF4TnJaUnRXbjZQejcvQU5SZTd6SGJyUHRTZlFWS3FqV3N3QnQ4emozdkRiL0EwaUhrci9WalpWbXptWHk3SzlJWmlpMmt4RW4xakR4ZnR1aEpRYlZVL3dEWXptY3lkVE4xQlR5ZVNGQ2pNczVwNlFlbjhXeDF3eWZiT0tlTGkrakY4V1h1OCs2YVFTRTBtWnR5L2o3bkhRbmFQTnlLcE1jOWphUnE1b29panZmQ3RMY0JuTWdpZWdFbWVVWW5sNjB4c1N1UnVNelF5MVdoUVJVVmdQeXpVVzVZek1uM0Zqam1oYVd6b3lhZG9DbzFoVUdsMkpyb0ltWTFsUnVmT0JoeFl0M3NYVnFxczZHbDRnNEpGNXZlODlKNjRwQTB1eWtMRE9IQjB4cUpBdk56SThvL2JGQUVNa08rcmFhWllCbEFnMzFlWVAxdGpBc0lXbm9wcURVUlFHSWdqWWJYODdZd2FKWmFnNXBtRUZXREdvcVFmUTRVYXpONXZMczlXdnBVeUt6SFR6TU1mcGY2WW9jQlJUcVZXZ3pyVmZDU1JZMy9BTGVtQ1l0eStvT28xTkRiay9KUGx5SjlQUEdHRDhxbmR1MEkwamxwQjhpSjh6dGllUVpEVGhtWkhmaVkwczRFUi9TTjQ5Zm0zbmlUamNTMk9WSTNQRHVJTDNDbzFNc2lzenRlSjVSNUFBVDc0NVpRczZJeUcyVjRtN1YrOGNBS3RJeHA1Q05oZi9jREVaUUx4WVpTNHNhejBjem0yWkljd3FFUUNmZm9BUEtSME9KcU5XTW1VOFM3U1Z1K3pDclVkWGRGSlpsQllXdHA2QVhBK2NOSEVtdGg1VnM1cDJrNGc5YWhYVjNaV1Jqb0xFeUU5YjIyeDI0WXhSelpIN00zd2hqVXpxb2ZDVk15VFBPK09uS290YUo0WkhmT3hIRm1USTVlZFdvZUZwL2IvT1BuZkpoOGo2THhYK1NGSFI4bm5UbXFiTFl3U0NOcGc0NDVMaU5QR29zSlJrRWxBcWsrSWdXbnpPQTZKdE1GcThTbzBhbFhMWllNelVCK2FWZ3dUeUhVeGhxSGhqYy9sSU95SlVWWExXQXB4Znp2R0I3SjVlbFgyZm03L3FGVEZIdGxuMW1JcUJyemE1QUhwdDg0OTd3dFkxLys5a3ZNamVUbC9qL2hEN2hBbkowd3RXYVRIVUZ0SG4vckhMblR1MGVoaHByWlgyak5QOElkSklqeEFUcHVKSUk2MzVZcDQvS1RUT2Z5K0VGUnhIaW1rOFJ6VXRFRVFDRGM4K2VQYnROS2o1WEwrekdIWjZ2VW81dFhwMG5xa0tVSlVrYVo5UDZZa2VmcGhKdzVJT0dWTm0veWkxSDRlNzFzdTlNTXdLaHo0aVNKNWM1UGxqa2VtZGpqcXp3MEZCcFZIMU1KSllLZjFEbkJqY0RCVGRnNDJaN05WTlRpZ2FZQ0FIU0R0R3NqZnBFV3hhUFJKdW5SQ3VTY3RXUGRrTnBKVmo1ZE9sNXd4bjB5bksxdE9iVlVFQTBWT3NiODVOK2ZQREVBNm5VSDRpcDRRVllScXZBNWZNRWZHRk9obFBlRjdtbnJISXF4RnZuZkRDbWR6aW1wbWFnbVF6c1FOOW4yUFV6enRoemlLYWRPeXp1MTVKMk8wRHoyajF4aGhwbDZVVW5hVk9rV2ttRnRmK1BqR0NXdTJ4UXFDTlB3Zkw3M3dvVDdMNWxxRHNVVmRTVEd0cnlaSCt2YkNTM29LbFROUjJWcnZtNlpvbnhQM2RRTjRwOHpOc2NzNGNYUjBRZG9acldxTFJkVmVTMmxWQ3R1Sk52WEUyazVLenFpV1pOcXBwNWRHS2hGcVhCZnhOZTl1WCtNQ1VWYm9MZE5BN1puVm42M2ZPa2hTQUprYXZmK2VtREdQeERPV3pFZG9NeHJxVmFJc05MR0prOU44ZGNGVWJPVEpJWGNGY0x4SEtobmpVWTFlZDc0cGw2RndTdG5hK3lsUC8waDhDcW9hQnlnbmtUODN4NG5rOW4wZmhQUjBMaCtZWExvMEFHVjArSzAvd0NzZWJLUEtSMlNYSUovRjV6aU5iOEhraVZkaDRxb1dkQWpmMTh1ZUdVV21UcU9MNXlFZmF6ajU3QzZhTmJoT2F6R1hyRVZLV1lTb3F5WThRSi81MkpQV2NXdzRmektveUl5ektVWEsraHYyUjdiOE00OWxxelpUVlNxcFQ4VktyNFNreC9uRTh1Q2VCMFNqSlprcEk1eC93QlQ4L3djOGRyOXhVRDVxcmxXcFpsVlBPSkVIbWJEYm9NZC9oNDhsSnJvR2JMQkxpK3hMMld6VHRrMnB2R3RZSURYNWI3ZW1MWjRYdGorSE5QNG9XOXJzNnhxSWtFZ0tXWTdUdlB2SUdMK0hqOW5KLzFETTNwSE44bmxLL0VlSUxUcHZkOVdyV1JDS2R6UHJqME9WV2VFNHlmN0duNGR3N0xKbUtGUGdoZXE2K0Y2empUTEh5NmJpNS9qRW5KTk95K09MdlEvWEw1MFY4cTJmcUVJcWxxRk5qWjJKZ2tubU43K1dPZTQ4ZER6aTFKTmhHWnJLS1NMVE1ocElKQjU5U09lQkYwN0xUTTIxR2FpMXJGU1NtcnJ2OWIvQUV4ZFMwYzhsYm9MYW1ydlVGVTZpNm1GVTJNamxnY2hlQXF6T1dxVXMydFdnMm5ReTJ0cGRUYUFQbjZZdkNZc29iR3FLcGttd1FRUFVqQ0ZmWlcxWlVPbHdzLytWTU1mY3pnVUp3TXRVcU1NMDdFbEdMdUxiUkpCL2Y0eGM1U3dGR3BPVkRzcXpBaUltMGpvWkg3WUFRMUNQdzdTeEVTQVEwaVptUFB6eGpId3FFVmFhajlLZ0FUYy9UNGpDc0lmd1RoZWE0MW1PNnl5TUtWTzJ1ZElBRW45Vmh2RWtqcHp4TEpLRWUreXVLTGYrRHBQWmZzL1ZwMWN4WEZOUWN4UjAwd3o3eXBra2N2czQ0TW1TenRoQlJhb040WDJaYXErWFJxUU9vTEJCMkY0RUVkWU9KdkxVVWl5amNoTnhYTGZoT0laNm1XYlhTckhVNFhjRFkvdjljUGpsYUZsR20yWit0bVNsYXRVZENwcDYyWUhUTDdSY2RUUHppOFk4dEhPOU13bkcyaXJUZVNYSlppMzcvRnNkbU5VcU9YSlBaVHdObWJpMlZVQmxBcWdhaHl1TU5QY1dQamR0STc5MmNKVExLcFFraXBwaTBDd0JIOS9USHoyZGZKbjB2alNxS05mbEtZcVZrb21EcUI5SUIvYnp4eXM2SlNORmxjeGxPRTVhQS81bGRwZ3hKdEViYjlNVGFsUG81TXo1eVBPSlBUNHBsQ2owalZwYXhLdkFNekhPd2JCVVhqZnhER05IRmUyblpQUFpEakEvd0N4VVdGSE1VeXRZbzNlVXpCQjBtRFlmM3g2M2o1WTVNVC9BQzlwNko1c0RtdVVUbkdab1ZrclZCbkdLVlpJS3g5bU5vTzJQVHg1TFZIbFplYW5iTkx3R3FVSGVLdWthVlZwUGtabjZuSE5salo2R0dlcllxN1Q1bzkxbTY2U0dTbm9BNkV0QU1kYkhsenhiQmo0dWpqOHZKeVJuZXpWSjg3bmx5dEI5TklxdXVKTWttQkEvd0NVay9QVEZwZkZublJtK2tkMDdEOEI0Zmw4aU9JNW1qbHlGWmdodUFlcitoTWdZOGZ5TXpjcWllbGl4SlJRSjJtNGRXekhGODFuR05Mdkdwb2xPbFR1S0ZNMldmV1pIVG5pdUdmR0tUN0o1SUpTMFp1cFJLbFJUWkZXbTJoRHNDZVE5N1FmNzQ2WjcySlZHYnp0UjNWbEI4ZW9ySU1RVnRQa1luRnNmUk9ZV2U5NzV5d0Rnb0NRQlppRGEzS3hJZ1lFdXd4NkFrcjk2YWI2bC9NRU5Kc1NPUjU5TU53WkdjOWxtVXJoVUFxVElVaVFvZzlKR053S2FQYUlaVk9na1NaSVpSdkhyaGpHTnpGUTY2eXNSclYzdUNSL1VUdjVqbDVZdWNZVFFZc2hMQ0NxeUdack5ZSDc5VGhSNFNYc0pvYVRSQ0M1MkVHYlR0L09NQ1hiRy9Cc2djeG5TdW15RU5MR0oyajMyeERKS21QampiT29jSXlTaktNdEdsVFpCLzhBVWVQQkhJQVc2NDgvSks1V3p0Z3FWQjJYR1pwMUJUcFVEUXBDRVlsZkV4aWRKSjl2TENXbTZLTmIwYWJzeHhONkdWcHQzbmZFRXl6QUFBYWpJQitrNDVza1haUldqTWRyeFZkVFh5VkxXeXRxTlBidkJGNXR5RzNYRmNEKzJOTmNvbUp6bkNUbjZMUGtxNkNrSEhlcUJwWlZtZjhBNDh6ZnBqc2prcVZITEtQS05lem5IYU9wU3A1MGlpOHFwSkU3bjQvZkhvUTJyT0xKQlJGM0RIRkhPMFhGZ0RJSE1SZWNHU3ROQnhPbW1kNTdINStsbXNzaFpwQkVnQXo1ejZYR1BFOHFGTm52K0ZsVFZNM0MxMVNyU3FMcWtCa0ZySG5IL3R4d1VlaE5LaFZuZUVadnRUeGlVenRiSjVYTExLdXFra3R5RVJFMnhhTW80VjFaenJIVXVWaWJqZlpMaTlOdTh6bkU4NW1sQm52S2NNRi8rQmk5K1dHam1oTCtLLzJPekhpakwzUWpGS3ZsbWVqbCtLVVNHV1B6TGFmWUVUYU44WFN4UHREeWh4VFNabjg3bHF2NGtEOFhsR2FQMTA2ZXJTUG4vV091R1NsbzhUeW94VHU5ZytVZHFJekNHdVdxSFNVTGlOUWpmejJHS1NkcXptak16L2FXdFVUSTZZQWFyVllSemdHZjhZNnNmN0wvQUFjZWFlbWdYc2xtbXkrWmFuVDFtdG1JUUZiUlk4eHovd0FZMlJYSWpqYVgvazdudy9pakRoRkFWTTJDOUZ4M05Nc1BHUUFGQmdjaEpJODhlVmt4cms2UFRoVFJWeFhpZEdsdytrbE9zNXpXWU5Xb0hZWDhTK0twMWcyVlJ6dWVXTkdHMFRsWGFFdEpWZWc4T05Pc0tWa0cwYmZGeGkrU1ZhUXlTYTJMT0w4SFhOMGU5eWtWYzBHOGVYSUFGVFQra3JIOVhuNTRwaXk3VVdReVlyMm1KYUtWUjNEVnRKY0RRelI5TEgzODhXcUxkcGlKVnBnaTVXVDN4cDZYUm0wa0tRVElpVCsvbmh1Wk9VQzlaTEN3MGdBV3RQc2ZuR0tFZzVwcUZUdUFJMk1XK3VNQXh0YlNNeFVndXo5NnpFeGFkVFc4NUh2ZkZ6aHN0UXN0WUpUN3p3a2dXaWZMQ2hpSEZuUmxlRmwyWW1OeFlmNStjWWQ5bXg3SjA5V1VyUFRDQ3JVZUE1TWFDYlNSSHJqajhodTJkR0ZhUjB6S1Vrb1RsS2FxcVVXU1czTE5lUmZ6akhDenB1bjBYS2l3R09rOTJBbjZabVJZZlVTZlBDZTdLclpSU0ZSS0thMlVHalZPc0FhWk84YjlPZUE2OWpwV1VjVHFWaGxlOThJZEFDR3FHTndTU2ZPMi90aFVxWTIvUnpMdExYTk9tSFJsYzIxT1UwaHpjUWZTUWZPMlBSeFFVdjJSeTVYUzBjL3pqR3JtbWVvUUhZalVlWmt6OC9USGJIU3BIQk5Mc3JwVXpTeklwcXhMZjBteE4vc1lML29FZTBqZWRqZU1Od25OVTZlWkRhQXhJMDlJL2EzMXh5ZVhnVWxjVHZ3NS93QWVqcktjUXBabkwwTTFUWXZTWXdYTzBSWW55eDQ3aFQ2UFlXVlNoWTc0ZnhKS2RJOXlDck5CRmlmazg4UnlRMVJXTWt5N1BjT3pPZXlzVTZwOGFRZEN3VFBJSGxoSXVPUHRGYVhzeStaN0FxdGRtcjBDN3RjR213YTQzbmMvNngxeDh4cWt1aFB3UW1tNi93Q1RKOGE3UFpuS2FuWWFLSytLQkJ0Y1NlbU8zRjVFWnZaNS9rZUh4VnJvekZRakpHb05Xb3dScS80K2Z5ZnB6eDFSWEk0WnJnekY1L04vak04aHFFOTJnT205ejl6NjdZNllxdG5Ca2FsSXU3UFVnYzJjM1dKVmtid3d2NmlZakFteG9ybzZKazgwVHc1RnFCbVBlS1kvcU4yMU41RzN2ZkhGT0R1enNqT0xWRW5xVmEyYTc1dzF3aWVFU0ZFVzlyQzNJWUtRUDdEc3U0R2tGeFRHcTBtTitYenpubU1EK1ZsVjFzdnpRZkxkMVRjZ3JVcHFESWtnRWJUMTg4S3QzWnRWb1NaeWdvek5Lb0VWWmJRNFZmRElKMkVkY1dnaU1nRHZxZW9vd09rT1F3a0RsNmVuemluRmtwTjJET2dHZ3Bkb2k0a0g3L3ZoeGlPWkNOVUdzdklVQ1EwVGJ6UDdZRmljak0xRFRXdm1HY05xRlVqeVBpdmFOc2RCeGs2VCtKTlE4TXh2QllldkxlL1hDakxRenlDOS9UcXlGSlFCaUNDQVJzVmplOC8yd3JkRkVrelJkanNwbmFHWnE1ZXRRWUtGaEtyUkViemU1NVk1YzdpMFd4MnRIV09INVNyVUplclRDTFZpbzduOUliY3F2WEhuVGx4UjF4ZjJFWjNMbkk1YnZFMDZnTlFEYm1MWDZTWXZnUmxZOG5yUU53Mmkvd0NHWVZYVm5kbXF0NFp2Ym4wQW5DdmJwalFkcXdUdjB5alVNMW5uUWNQcVVSVHJCazFhU3BJMWV0L3JodTZIYmRhT2ZkcU9HMU12eEtwUVJxZGVnMVJqVGVsZFhwd1NwSjVNSWo0eDZHR1ZScG5GbHQ5R0Y0NVFVOFJyR210UWVIU3lrVERDSisvUEhXbTJ0SExMclpXK1dwUG1zcG1HVis0cWFtY1UxMUVkWXZzTWJrdW1DRUcycU45UzdPSm4rRGQvU0xQVXBHRnFTVkJGcHR0RTM4NU9PQlo1UW5UZWoxY2ZqOG9Pdm9YY0k0OW1PQjEvd3VhdlNNQ0NUTnVjYlJiRkpZbFA1UklyTkxIOEgwYmJzOTJrb1Y4dWlPeWxZOExtNEJ2dmJlY2NHYkJLQjI0TTZsMHpvdVY0OGk1Y1dFNkNDZ2FSeXQ3NzQ0WnhsZEhiSE5GcTJCVXUwRkorSUNqVFVOTXQ0UDFFSFkrM1BDdkZXNkhobXZTWm1PM0hGRXk5SnFGTmRUUExoUVByNmVXT3p4Y0xjdVgyYy9tWjZqeHM0MTJsNGlDQmxxUlh2V0YrZzlQVTQ5bkZGci9CNGViTDZNeFNBTWFXT2x6Y1NKQTg4ZExyMGNTSGxLb1B4S1VVbFlJQ2lkMmkvd0JMK3h4T1NiYUtSaytqVDVkTTFYeWo1dkpvS2hUUTNkS1pMZ01SYjJCLy9saWM1ZHI2THdnMk9rV3M5Zkx2NGhsOHpTQkJnRFMyMjQ5TCt1T2ROZGxhbEhURHNtTmVXUDRtc2FmZGtCbTBhaUlqa1BZWVdja25vckZOOW51aXBtYzAxT293cHFKVVBVUWdneFlRRGE4WDZEQVRTVGFFVnNUMVRVcklXcW9pUDNoMUtwTUMreG5uSU9MSnBVMExLN0ZWZWs5TnZBaWtxMHNQTG9SL09MeGxaS1NaVHFZdTBydXhpREVjbysrdURScklLcXNKMW9SeWxKd2FFNG95ZFo5T2JxbExwM3BHbVpqeEczUDF4VTVTM0wxZ2E5Tnc1OEl2RmlMOHpnVU1PZUUxMFROSHZDRlI0VUcvbEhydlBzWXhMTEhROGZpMDBkTDRKbk01a3NxdE9vMUEwbFkxSktSSWF4SUp1TndmYkhGT05hT3BPdG1vNGZ4SE1BQUxXb3dpUW9TWEtIcDArY2Mwa20rTEt4bGZZOGFqMzlIVTcwM1VuVUFXWWwvS1J5bU44UmNrbVZTNUlGVktsSjY5UXFvcGdsVjNoM3RZRSs4WXorMFVTNHFqTThYNGhRcDFhK1RkV2JMc3hWMW5kaVlCSG5pc0kyckVsTXpHY2FudzlOTkxMcTFHb3kwNWlTWDNreDVFUk03WXVrNUt5TGxiTWZ4R2dsYk9WdTRZbGU4WllBOFJNRGFiYkFrNDdZTnhXemx5S3p6c3BYcEptV1hNVTFxS3BkNElCRWxZUHZ0N1lYTEgyaW1CM3BuWE93MUQ4STlmSTVpbTlPblVpdFFZZ0FNdWtBZ2VodkdQSXoyNGMvWjYvaWZFVWR1ZXl3WVZpdE9GYUdwVkZFYUdHNFBrYll2NG5sSkttTDVmamMva2psdFdubk9FNWt0UzFVeVdaUTZ6RFg1NDlWVSt6eXB4bkRvZFpQdGJtMHBpalh5OVJnQitxbFUzSG9mc1k1OHZqSjdSU1BrdUtvdG9kcW5Tb3pKU3pDc1NDQ3JxV3RPMGIvenRncnhyU3REZjl6U0V2R3UwVmVxM2UxVWRxMS96SGZVd2ttNDlJK3VLWXNYNDNTSVpjdkpYWmxYZnZxbXNxekZtTTIxRWRmWDdPT2xhVkhMS1RrN1piUTAwcWdxbGJTSk1rZ0RlUFF3TDRWZ1F4eXluOGNMTzZzNEpFUktrU1FUMUEvakF1aWxKTk03bDJMNEVtWHk5RE1aYW95Wm5MUG9hbVZNdlNMU3BBM2dDYitSeDVQa1pIYm85VEZHMG1NT0tjRG9KUTdwQ0VaWllxVk1mcS9Xc2IrbUlZc2xGWlkza2ZJRVRMMGNuTFo0bzFQUkRFaWRZQU5vNW5hM2xpODN5ZXV5U2RhWUJtczRjNW1LemxoUnBrZ0ZsVVdFVzk4TzRTUzJUU1NZaXpEQlZXbTdMcWFyYzFEdk5pRDg0b2szb0VtckYzRVRUWTFGaFlXU0NON3dZK3YxeGFLWkdVaFc2TTFROTJFZ0xPOG5iNlh4YXdVUmNHb3ROZ3pNTk1DWE52cmdpMFkyb1NhdFlJSTFWWGoveE9vaS83NHRSeDBXNVVyM2lGUklNQmh2ejh4RVlBYkd0T28xYXRVcFZuSmx3U1lnam5ZZVVjc0xOdHFxSGk3YXMxbkRzN21Fb3dRS2loUXV1RElBbUNPc2pISktKMHFhWnFjbldyWmxhdFI2ekRVb0JXbzExSnZ0SHppTFNUdWg0bWh5UEZDbVZWMlhTMGFTQ3cwanp0eXh6VGl1VmxVNjBBY1M0MW1hdzBxVTc5TEJBMGFKdDlSend5Z25vZE8wN01wVXpLRFBNTTJ6SlRwVTJyTTRhRHFpS2F6MXVXMjZZcnhxTlIyUmxQN0ZPZnE1S25Sb25MMVdGZFM2Z1ZXRHJNQlFERUdmSWphTDRyamk2cGsyL29zeStXSW81ZzFGQUlKMUgrcWRKSlBtU0NCL2FUZ051OU1majhiWms4czJuTlZYUmlsSU1zd2JNQ1lrYlIxeDFTWEtGZXlHTjFLMGZvV3B4TGhuYUhpVFYrQTV2S3ZuRmNaZ1V2RWpraUFHQUlGamNIck9QQ1VadE8vczliSGxYRkI5VnFXZnlTT29ZVTZpaHJrUUR0ZTNJd01SakJ4bmFPOVBsRXczYXZoMUNta09rYXFwalVCS0VuOWorK08vREtaNS9rS1BvNVRYUjh0V3FwM2I5MEdKWHdrQWlZMzU4K25QSHFyL0o1OUw2S2M1bWU2b2tyNFNmQ0RQTWNoOEgrK0dXeEpWOUNHdVhxTTFSMEpUY0VySUIrUFNjT3RNNVgyVnFvQTJNckNpVDlmZjZYd2Jzd1FzbEZCQ0VCek9sdjM2M0krY0Jndll5eXVZVUNrK21YUmxWa0ovNDNpZXZLL1RDU2k1ZEZHOVdkdTdNOFJ5bkdPQ1pTbmw4d3REaWVXcGhhVEY5SXpGSU1DTDhtRjVVK3U4akhtWkljWlBsN1BSeFpFNHBOME1zenhiUG5MbEdXbnFFb2FpQWgwQS9xaWZrREVZWTRwOWxKYzA5QzNLVks5V2tsQjZkVE1HbW1wbmJaT3JFbjY0dEpKN0VVR3V4UG1xaXE1T29vaHNhZW9FenRFamx0OWNWaTNKcXlVdE1UWnZNZDVsbldpQXFNMWd4azliK1Z4ODRxbFF2WXNxR20xYlV3RWJFbFoyQTNqRllFSHVWRmNvdFVxRVlCZHZESjlEZ2xTdW9ZSWlvaWVUZ21iN2p5d2JOUmtxcUUxbVZhYkV0VllwSm4rby9YWTQ2RGlKMGFqQUJ6TGJ4MUVmVGtiWUZBb0pkU3dkbExLSWxmRmVJNWZUR2RWUVgxb2JjRXp4VHZzdG1xeDB1b0NzclREVzIvdjZZak5VaHNkclJyK0hjYWZoYjZjNXFxSVNGRC9xRDIyYjJpZlhISE5Xck90UGpvZTFjM2szeVRHdTR5N2tIU2FhZ2s5QlBUL09PZW0zMFV0dmFRdjRqbUtiVlN0ZXRsYWVXVVFwMVNXRmdaamxlSSt1R2RxbFFMdnBnZGJPcG5hUXl1UkRkMVMwMXozb1VDb1pFRmdCdnZCMmkyMkhqR1Vkc1J1OVVXWmJnNm51bnIxS04xSmFLaWh5UzBudzh0eGRyVzU0TXMxS3FLeHhMc0E3Wlp5blMxSmxhSnAwbllpRnFCaElFRUwxaUFQTTRPQlBpMnpaM2JTUms2T1ZZanUxSzZwVTFGbVk4djNuSGJMNHBTK2pudy90VE41d2Nydy9pK1R6bmRvNzBVRENKVU9vSk1qYjdHUE95Ymk0cEhYamdyN09oclV5dERpSi9DdFYvQ1p4TzhBYUZDMUIrc1IwdUQ1ZzQ0bkdUaTJ2UjZPT1RjYUYzYUxLMEtvcExWWUJBWjFIeEdEekk4N2Z6YkJ4U2xFWEp4WmcrMGVXU25RcXNBd29nRlRxWHhPWkoweE52V0xSNVg5UEZrYmZSeFpvS0tPWFZucTVuTVppcXRQUlJGakhUeTVjemUyK094Zlo1azNiS3FuNWpveWtxc2FWR21BQU9aSE1uNnpodTlpRVVxYWJhdjZ0MjNnZ2p6TnhQenl3VEVGSkJHclVDWUVxWUlubDd3YjRGQUQrSFZWTFN4V29FL3BnbmJiK1AyRzJOVFcweXEycU5UMmRxL2g2bXVRS1lYdnBCZ3NWSnVBQ0o1R1JlVGpteXdVbmIyV3h4NDk3T2c4TzdRME9Kd2pWb3FFYXFGYXRKVm5nV1BuUEwzeHh5eFU3UjB2SzJOaUsrWG9MbUtiWmRxZFZQR0dFZDIzTWp6amwweE9DY2htM1YyWkRpOUt2VXpkTmdpd1ZLbFZFRGxJSFFZNjhUVFRSR2NhYUZBektHblhOU0lTbVAxWDhWdkNiWDNQemlna1pKc3BEZDQrcVUwc0xrSkJnM3VNUEhRdkQ1Y2o1bjNZdElpQVppOFgvM3p3UmloM0NtQ2Fha1RZejE1WHdhQlpsTTgxVHY2eXJyRGx5VkVnbU5VUlAzdmpvT01yYlVLakVBbHJjeUNlVWdiK2Z2akdMNk5aUUFBalNIR3pYTUVTSStNQ2pFc3dvVGZUS3FZSUJ1UEkrdkxDT093bWk0Sng3VWdvOFJkdFNnaEgySUpFRU5FZW1JNUlVN1hSU0UvVE5IUzR2bGN0Uk9YcUhKMTZCU3pHdVZQUHoyZzN0am40dC9xanI1OFZRdHorY3BWYXJEaGkwS0JqOVgvRUFSekhUM3hSSnBiSXpwUDRzREQvaHFOTjZkVVpoV0laMUpQakpGcEozdUQ5TUg5dFNIVXFMS1hINjdVaGwycmloU1ZUYkxwcGFvRGJmckdGL0ZHd1N5U2ZzUWNYNG5WcmltS2RabDd1UXVsanBTU0pBNWt6TWs3NHBpaHgwTGtseTZadjhBL3BYMmYvSGF1TDUrbURScHl5eGNsZ1FPZTk1M3h5K1ZtM1NPcnhZcmkyelk4WTRCU3lmRU1yVnFVelhUTVA4QWgycFZTR05TcVJMQWRRRDVZNVk1R3pwY1lvKzdkNStqVnozQlJTTk0xOHRseVhOSjVoVG9DZzMvQVBGckc4SEJ4T1VvdGZZWXozU0s4dnI0a1VRc3BEVWc3MUtwOE5NUU5SY25ZWE9OeFRkSWJscTJjejdaY1lHY3pOZks1Sml1V1I2aXNVVUtYVThpSi9xQW4wSUVXSXgzNG9jZXp6cytUbXFSZzh3d2VwcHBzQWlUZS9pOC9iSFdrY0pFNmtMa2xwQ2t3WjhWaEczSWZ2ZzlHSXE1UWxTQ0ZCMVhPNDVDOTc5UFBCTVFlbUVaWUU2SjNpOTl0cld4akRYZ3pwU3pXcXBTcVZkU2xRQ0FEcDZrKzV1TDJ3c2s2MFBBM1haN0xaV3ZTcThSejFQdWFJYjhoV0xJNWFaRWZkNHh5U2xLNlIxd2VteG1tYVhOOE5XdkNpcDM0MGFBQkJrQ1JITTlNU3VYSnhrT3Fhc3Z6bkZZcFVLYk9xbnhlRW13TzgzM25TcDM1WVdFSFRZRkxkRWVJNTFDMUFFaERTOFFNeEFBMm1SMGozeFhBbmUwTGxtcXY2TVZ3UHZ2KzE2cTBoaWRWeVRia0QxanJ6eDAwam14dHAyTVdlcUhCYlVwQzZCY3lUdkI2NDFGT2FQUktveXc2d2czSDZvVWlkL3VjQVBORUhwa2FSQk50d29QTTljTVl4TmJRS2xlREJXb3hJWWRPWHdUaTV5RUhidVN4YUVaYWpjaEdxL0xrQmJiQk1UNzlGREFPTkxHeFZZTnA2ZlArc1l3V2xTblcwTFZxK01tMXJieUw5WWc0Vm9KWXlvY3lpOTR1cGo0V200M0g5dVhMQ3R5V2pGdEpaU2xDSzhUTWdubU9jV3dOb2E3N0xIejFYOHRxWkNna0VobW1lUjNtMjNuR0JWOWc2NlBxdkY2OVJVcENxSDBpQXJLRjBBL1dKbTNuaFZDbU04bElXVmMxWGNLUVRTcGY4UVRFZEQwM3cxQ3VTbG8rb0s5WnhSUS9tdVZwS0NMYXBqNzljQjFIYkRGSzBmcVBzbHdxamxNdGtNamxRdmNQR2lGTUZLSUJCUFA5V2tuSGc1SnR5YmtlMWpTVU5IM2JETUU4UDRqbTAxazVScVdYeWp3UjQyckFzODlZVTM4aGg4U2FuVEhsVFZJeVBaenN1M0VWZk81M00wc2hrQkxtdlZTOVFEZDFYL2o1bTJLeXljSFJLTVZGM0lCN1pjVHkvRHVDUGx1SFVTdVZzdXZNa2Q3bWphQ1lQZ1FmcTBqRk1FZVR2MFR6NUZCVjdPT1oxaGw4bUZFcldxU1lBa3F2VW5jZjRuSHBSaWtlYk5zRFNtRzhUclQ4WUpnMkc5djNqRDJnSnFpb0ExQzRTWURFRWl3c0QvQnhoWHQ2TEdKVndLYXNTWUVSY0cyM1hsYitNWUI4S1RVNnloZ1ZTUUpKdHVKSWcvNkdOWVdtdXhuMmN5ZFBOdlVOU3FhVEl3OElRc1NPUTNFYng3WVdVbXVoNFJUN05Ma3NqU3plWnBBWnJPUFFEeXhxS0NQRHV0akFqK2NTYzlmMmRNZU1laHJuQ21YcWZsVTNYS1VRVzFOdTlUVk9wanRZOHZNMmkrSksydGpTZHY0OUNUTmNWcFBtNmFVSHBnQmo4Ym4yRjU5VGlrSXVNV2Mvd0NTcFV5V2V5OUROVm9xWnQzQllsMGdYUGtkNHY2Y3NHRXF1TE03a1cxSFNrRFRSa0FWUXN4L2pwSHhod3BKSThxSXJNeEJxRUVScVVHSjh1dHYyeHJFS2xxQ21YMWtsaVN4dnRJc1IrM3RoYUNXb2FnV0tGRVZGSFB2UHZsR0dLR096UlUxcWkzVmdTQVVNU1F4RnVtNCtNZEJ5QTlVTDNpYVZTQ3g1N0FtSWdlMCt1TVk4cG9YRk5XZ1RFTjZpZHZmZnJHTVl1cDA2amdydUFTUEUwU3hqNnpKOXNBSVUxUFN3WnFZQjFrejBZV3VUenRmQVpqNDBtcXpDaHlIZ2lSeU13Y0tZOHIxTlA1U0ZYQlVpQi9UdkErNzRBTG9yeXROOHdhalZBdWtYMU1BUkpIUDQrbU1NbDludFRLOTJsTjVrZjFBUll6elAwbkdOUVgyZHByVTQvbGFiZ2xFcWhpdHBzUTN6eXhQSS9peG9LNUkvVlhBS3FVNldacU1BRnlYRHF5RlZJbGkxV0Y5Q2RNZStQQ21tMnoyb2Zxa1kzdFZuRXBjTDRid25OUFZGT3RXcVp6TVZGQ3M2VTZhc1BDTnAxRXdNZEVJcHpUOUU4cmFlZ09seEhQY1pXaFRZTlF5UXFKVHkyVHB4cnJWRkhoMUUvMGdiN0FkTHppcWhVdGdiK0p5L3RseEpPS2RvcTNjUFYvQ1VBS2F1WXVWSGlZQWNpd0lIa0JqdHhZMUdOSEJreUtjcnN5Slo4MW1GWlB6UVNRRVVBYzl2ZjhBYkYrdXlNbmZRUXFrVkZEL0FLcGtFN0gxOHZ2ZkFCeGFXd2RuMFZTNkJ1Z01BaVJldzVSMDJQdGhrekZWRk5iZ09xTTIwbWYxUllkRC9qY1lEQjdEcXRQdU81WUxUZUhKSWRMTVFMeU9jbmxqQlo1bEt0VEtWcWRTa3lzNktWTE1KRDA0Z2c4eklKK01ha3dYUXlUdFBYV25xcTkyZy9TZEZLTHp5Kzl3TVQvSGJLZmxjZWlqTmRwcTlWV3BKVDcxRGI4OGF0dWdIUGNEMk9Dc1lIbWNoQTlTcFZZVkdnUTB3aXdCenRpdEtpYmZzWlpMalZmTHFVckpxOFpZVkRPbzJNL3hpYmh1MEZaTmRtbTRaeEVabW1lN0RWRUpIalpyZ3h0SFBhWndyR1U3RFhwa29OWGhBamE0a1dQbWVkL1RDdHBkanJaQ3JwMDZRQmNlSUJyemI1RnQvUERtS3FJWE1CbVVTQXhBMEVpQnVQVXdjWWZrakp2U0w1dXFxR3F6TFZNV3NCcU4vUEY3UnlsT1lDbW9KVjJVamxKT3h2dnYvYkJNUzd3YWlXWmlaOFoyMVhtSkd3ajNHQVl0VmFhVWRMejR4TXhZeHNaODc5TVlKSmpSVjNWU2JzZE9tMENaSUJQbU1CZ3RIdGJOTldWNVpOTjlSSkk1V3YwNjRBVDdLWkVPOE9UM2wxZ2pvVGY5OEJtU3RobElhRkpwcTRCc0xtU0RIbjkrK0ZLU1NyUkh1RmZNMFZSQ1ROclhuK1lINzRENkZSNXdSaW5FS3phTkxDaFZjNkNESG5Pd0Zva0RwaFo2V3d4N3RINko0Um1EbktYRU5DR3AzOURLVVNBWkRBbHFzR0xYMUFlMlBIeXFtejJjVHRJekhheEV6SEdzcXJOcTd0Q2piblVkYkVuY2MrV0s0bFMySm1hNk1yMmk0M1Z5em1sbGF1aDY5RnN0U0d4cFVZSWVwSEl0K2tlUm5uanR4dzVLMmN1WEpVYVRNSm5HYWhSS0lXVm1VSmJaUkJIMzZZdEc2T0VqdytqRGh0QVVDUVJ6SklHM3BPK0tTMlVpby9aZG1XQlJYMGFDUUJ0Y1FManJNZytlQU5KcjdCS2RCcW9QaUNrbVhIUTNJOHY5NDFrVXJHclpWTXRsMnJ2VFFWQ1FBbzNpZHA1ZFBPK010bEl5VVZURmVjcVVoWEFZYUNnOE1EWWprSjN2Ym56NjRJczVjbmFLMlErSlRFUFl6VW04RG42RS9HTUtWcFNaL0M2cnFBMkc4MzJQM2ZCUnFzcGFpcWs2NmltOWdrMzMrUHJnbXFqeHFCU1FkU0JSSUxFZ3pFemJsNTQxZ2FLNmxBYUJVZ3VTWk56dDArbU1xc0hFbFNhdmxhZ2VuS01GSUlpMGJ3ZWZQNkRHbEZBMnVoL3c3akRPZ29WNWJXTkphWjBucFBudDdERXBRS1FuUTlKV3FWYlVDTjFPMjl4SFhHYktkOUZCZGtNczRHcnhEeFJnMFA4QUV6dFlEOFZVSUlhcDNqcWIvd0RrWStiZkdLSElDZ0t6TWU3bFIrcFltU1R6amYxL3RoZ250YlNNc2lHRERLeEJ1WmlEL0V4TytNWUhVbDFJQ3dCTlNReG5ZVDdZSmd4Y2t5bEhxR0ZxalN1Z21aSXVQbTg0eGxHMmVaa0xsOHdhZjZ1N3ZBMnNQMUQyNWVlRlk4bFFibEMxS3I0ekpKRXRNZ3libWVkaHY1NFZnUk5YSGVJTkdsVEpOK2NmNnR5T0FZWVpIUTJlT1pZUG95OUZuaG1nQmlDSTk1d2srZ3g5aTdndEthV2IxRXdLQXB5QVRkaGEzUzAzeHBwTjB4c0t0MGZvenNId3lsd2JzdlR6bWFJTlZhSnJNekN3TUJLZS9RUWNlUGx5cWM2UFh3cWtjMzR4eExKNWJLUG1NeEtpcTdEUURMYkd3ODdpL3dEZkhWQ0ZwSTVzczZrem5xTlh6MWJNNTZxU0FET3JiZmIwSDNmSGZ4VVluRkNYS1lCbUdPWXpNaHlTV3R2Ynd3TC9BRVByaGlZd1NhV1VDSWFmNWkvcDNFRzBYNVQ3K21BWXFkUnFsNFlMRVNkTVIxMyt5Y1l3WncrajN1YWVXQ0JBVHFNRUJlUk1lZUZrUEVoeEpqK0lwSXVvQXlGQUlqbUJQVytORG8wK3diTVVxUVVNS2FrMkFaVE1DOXVabUpFWDJNSERpQWRXblh0cWgxMDNLa3hJa25mbHRqR0tCcU5JV2NzUUJPOENmMjVUNllLQVRwb3V0aTNlQWF0eUxBQUU0ek1YMHcxUmlYSllBZUx3N1JZM08xcjRVZjhBaVN6dE1JdE9tTlJiOVJiK21JTmo3QTRJb1BuS2VqVVhwNnBXekFFQ1lNUlBXRDl4aGdBcHBLdDlVZ0RlL1Q3UE00d28yNFJ4TjZSRkRONm5wMkttTGdqWWZ2aFp3RENZK2F0VXBrSHVxamh4cW5mN3ZPTVdNNVcxTG1xcklRVHJlVkVDYm42eURocklBTGlYQ3dQMWVLTFRlUHYwT0dDZlZrN3ltUWZETnlBT2wrVzNyakdDc2pUTk9XbGRiRGFOdXY4QUZzRUM3WmV3L3dEM05WbENud0tRMHhDeCs0UDB3Q3N1Z1UxQ0tsQndWSlZoQWczSXZjZkdBeWE5aEZCdTdva0JtQmN5TG1kejB0dHF0NVlWakJXU1l0WHJNb0pVTHR6a2liZlUvWXdyTUhWS3lVZXorYXBxb0ZYTVZGVXpNYUVOL3dCeWZLK0pQOWdsdlpQaGg0am44ams2YTZtem1aV24zY3dkR3h0MEFKUHRqWjVjVnlLWU5INkI3YjhReS9EdXo5YW5yQ3BWcUducVY1aW1paWI4Z0ZnRHpPUEt4UTV6czliSi9weFIrY00vbXEzRzg3M2xVbjhQVFhUVFRWdE13STZtQmZ5eDdFRndpanlKUGxOc3Q0cm1mdzJRcFpGS2FvN2pWWE9rZnBGMVNPa1JiendJcm5Oc0lzcFQzZmVFRTZkeW92dEl2MTMreGh5UjdVck1wcUh3c3hHa0hVSWphM2xQM3RnbUxPQVpFY1Y0bFNvaGpUcEg4eXBVQi9SU0Yybnk1RHppTnNMS1ZJZUVUWUxTbzV6L0FMaG04dWxQTFUzcUpsc3ZUVlNxcXFKcmFSNkFEMWpFSnowam9qRHN5ZWZxbGMzUkxVZ3lzc2c2VEVuZjM1L0dPaE8xWnlWV2krbmt1OXFxdVljdTF3d01DNXZ5OHA5TUxLVk9oNHh0RjM0VExzaTZ3TklNa0V5b0F0OFd3WXV5a1ZHUFpPc1F0SjJVZDJxckE4TVJjMmprTm90YStDTGtjZFVMM0xOUjFCZExGZEM2cmtUL0FJdE9NU1BhVkpnOGtnVTV1ekV5TEhsNndmZkJNZlBUU2tvWE1CU3QvQUI0cGx2cllXODhZeDd4Q3BXemRFbXZUWTBYVU1IMHphSS9VWmpHTXhNNm1rWVJqVXZLa0MxdWZwMTljTUlEZDVZYVF1aFpVd0lrVFB2dU1Zdys0ZnhHbXRBbk1MWDFzeGFFcHpFOWI5WittRTRES1pWbktJTmZNYWlDTzhZenNOei9BRGIzT0gvSUtBMWdHZU5LcVhBbThHZlA2NGYrd2txZEh3eFMwdWRTZ0VmMVQrMk1hUFl4cDVWYWRJR29kZFJtSlZySHc4eVBQQUtQc0g0cFVJQzJBTGcyV3dBZzJCNUMzdkF4Z1BvWGdOVXFqUWZHMFNCYVQxNlg2ZVdBeWNmWVlHTHF1a3hINkFvL1VJZ042eUp3UFE2RGNpR3FBR2hJcVZhaENySUIyQUF2ei9uRW4weW1QMlM0MnhxWjVNckdxbFFRVS9BMGlmNmlDUGJBaCtvUFp2ditrK1hYTTl0OHBWTU5ReUdUYk1FQVdGUjVGaDk3NDV2TXlOUjBYOFBIYzdQditzUEgxNGh4eCtFWmFxV3krVUMwbklJQUxDN2owSk04dGhoZkR3cEp6ZlpUek15bFVURzB0TkRKR3FYMHFDUlRRZ0JqRndUUFArYjdZN0VjUXVxSytZcjkvVmNQVllndXczdnVmakRBQmMzNEZLMDRzeEkwN0VlVUhmcjc0STAreS9oZkRtNHRYcXIzK1hvVUtOUFhXcTFpVkNyMEFGMk50aDBPMitBcGNBWW9mRmpic3RTZE9HWjJzNjZCbVhXa0JhWVFBbjJNaVA4QTJqZTV4UE03YVpYRDB4NW1xb29jQW9KVFVqdk16VkR6eUVnYjdiQ1FSMHdpamJzcnlxSWl6WnAxcTlXbVZCa25UcU5qTWJqci9ZV20rTHBVcUpOMmVWSlZscXU1SlE4b3NDZjM1emdnSVZhZ1ZRRWtXQkdrajAydHl4akVNOVEvQzVQTDBVcGhtcW52U3BNd3UzWG1JK1BmR054c3B5ZVZyRWx0VFdKOFFzWWkxK2NnWUJ1TkJoeTdzRnBVTkthbWg1M1lSc092TUE0TjFzS1Z1Z2pJOFBvSlJyWm5Nck9tWUZRMjk3N0NOcnpHSk9WdWh1QktwVHF2bEF0S3VSUnFVYWxZcWlBK0FLVGFkdDRnZGZJeXlXMEJ4U1JqcUZTS0xUVElmU1Mwd3R6dEZzVk9TUDdNRk5Vc0FwQk9sU2JuMHZoeGk1SzVwZ2hURW1TYlgrOXZiQ0dYUTR6akFaak1TUTUxdUFBaElXV08vd0E0MUFCTXFGRmVpcHBCMTFRQkFBc09VN2pEQkdhTXROdStOSU40MWVTSW1PUitNQmhKTFlvU0NYSk1rL3FBTW4vSHZnRElYY1ZyS2MwMHFvUlFxQVFZQXZ0OTlNTWhXRFpkcDFhaHBKYXdJdmNHQVJHKytNQkJMdWdwRU1RSUJVZ01ic0wyUFdQNHdmUVJwdzZ0VHl6TFZxSXJMUlF0WVdaaXBqKy8weEgyWGk2VEFzalRlcTFTdTR1SEd1NUVzeEo5STN4bm9sQmFiWnQrd0hhU2h3REk5cDg0Rkg0c1VGTkVWRThMT1dBQUhPeEUzOHVXT1R5TVRuSkYvSHlmamk0c3lsSTFURk0xNXFWQ2FsVmp5NW5Wek1uN0F4MUtxVmVpTGZKdG5uRUtwYW1LYU1BaWp3QjFWU29Jc2JlWUI5L1BCRkpVNmZjMHlXSGhDaVlpVm43QnhqQ2JNT3RScktGVFRlMGtyMEVkRmt6Ylk0STB6UThUeW80WDJaNGZSekEwWnpPazVpb25kZ0ViYVFiU05JMi96ZEZKU2Vpamc0SWFjRjFKd2JKS2xOZ0tsYldkVEhtWm4wSksrNXdqN0s0MThXQlZjeUdOQ2dhUWJ1cWpzeDFHRHFsdnFDSjlNWlJmN0FqMFY1MEpSYzYxaGxOenE1K3ZwejlNVlFWUUZXekMxYWlxdEZsbFdrTzNNN0czcU4rY1lFaWMrd3ZoMlZXclRneFVWUEUzL0g3M3dyZTBHUFRQcTVUOGZWSjBVelRoYVpEU0RBTW4wdzZFZlpkU0ZFcFRDMUNsSng0Wkppd01ENG0vV0RnbVBLcmYrb2ZUVVA1UktDRCtvVFlid1lMUjg3UmdWWVl1bUE1ak1OWHJwdyttZnlYUGlsWmt3ZjM1RCsrTW83QTU3R09hekM1WGhyWmp2aFVvS2hvVVZJSzk3QUVrZThiN3dPUnhQSDJ6T2VxTWM2YUNpd0cxMmcrUG52OEFmWHl4YzVwRlZkREV4TXlRTk1iYi93QVl3VHltb1pmRXJFcVNQQ1A4NHdSbG1tQnpsUkFXRlJxckNaNUZqOFdqKytNQWpUMHRVTEdOS3k5NTVEL0kyOHNHekJ0QmxxVUtaa2dncVNBL080OUxnL0dBTWdsZERrMDRCTTZlc0M4eDk5TUZHRkdiOFZaZ0VrS1Rwa0UyRXg5ODhFVjNaNmk5MjBoZExneXBtVHF1ZC9UNThzWUt2MlZNMFZBcWp4eVlZbm9kOWowd2ZRUWo4UTNjVmFsUXNiM2tBRzRrM0dKTHRqeTZMdUIxVFZ6TktnQ1NLb01CUk54SkJIVDBQbmd0QWo5RlZITVBUNytsUGdEQm5qbHAyUGx2L3ZmQXF3UHNPeU5SYVdYclZxa3E1L1VTbWtnSGY2NEhYUXkxRjBlTURWS0kwaGcycGdSTUc4VFl5REgxd3JabDJXY1VycGwwU25xSVZRSnVaVVFSQm5lZXY3WTBXMzJHYVM2QWVCY1BiakhHc2xrRlVzMlpyQUh5UzViMEdrTWZiRFNrb1F0Z2pGekduYnJpUTRsMmhyS3Jma1VtWVVocGkxdklHL0svTHl2TERCeGpaWE5PMmtoemw2NXBwa1ZsZ1VwaVk2NklIOFJodjdIV2xTRUNtTTNSQ3lXVmRYNmY2aU5oSEkrSDBubnladDhhRlRkMFg4VnJNdGN0RUlRTFhIOS92MHhvOUdrMm5vaHdpbUt6MGhVME5TSU5OOVJ2Qi9pVE1qa2ZMQW1MMjlqb0dua01vK3NnRlF6RUhvdHQ1bnIxNSswYmRsVWtMS2EweGxGMUNGSk1zZVcyM3JmOTdiWXZFU2FSR3BXR29va2hrMUZSZTlwZ2U5c01UbDBBNXJNSlJvdTVWYmszRnBON2VVWHhrSmJBZUdGcXVac25qcU9GUlppMFhNbXdpMkJKdW5RRnRqTHRibTZaemxETDVlRm8wS1kwcUZnU2dna2VwOHRzTGpWYk5MUWdVdFVLcXFoOUlhSmliZnpBK1p4VVJrS3hVd05KMWM5WHpiR0ZrMlhEOFFmMDB3dzZzcFk5ZVJpTDR3eGRYZzUvTXdnL1c0SkVmOGlKbjB4akUwSkNNNU1BS0lKRWF2VUQyK21NWXZ5dFowbzFDMXdXUGhpUlpmcGNmWEdHUVhScUJjMnJMWXJCSWliYjM2V3hyQ2tVbWkxTVZVYUM2d1BPUnY4QXZoa2F2b2pUQld0V3FPSEJDVHRCMkpuNDVlV01CaThTZEFkV3RUS3dnRndSRnV2cmcrbVl2emRHTWs3b3BSVXFCWEF2WWdHdys3emlTN1pXclRMT0IxS0NjVHl6T0F3V29JR21DSTJodW45c0Y5YUo0NzlrbWVsVXpWYlFIN291eFJXR2trR1kreDBqQ3EvWm4yV0lVVmRBQlZ0UUJnbVZHMGVkK3RyK1dNRy9RZGttcFUyWXlRUUFGZ3laOUJ5OWI0elNveTdGdkVhb3Ixa01zeGdBa0xaZ0xXL2s0MEVnemJIWFl4MDRmbCtLOGFxQVU2bENnMlhvanJWcUFoaU45bG4zT0paNm0rUG9yZ2tvUnNXOEt5Ly9BSERpMUNrQ1B6bTFIWE4rWnYwdkZwdVJ0aWpiU3BFNHBOMnhobmM0QnhSa0VJQzNoTVRZQ3g5Lzc0VmRJZmswOTlBZ2RXNHJBTnRJSkcwV0Z1dkw2K1dDK2dwMjJ5dmlXbGE2SkpCMmxiRDlJc0xmZnJndzZFeU44ZzNnekxSQVJoS1BUYW1WS2tDUVExL1lXK2NDUm92MkVjV3JxcktJTlFEUXRnZk1rM0E2bTJKUlNmWTNKb2dPSlpVdG9yVS9IcTFBcXdoU0xRUlBPUnNRTjhPK1g4UXVjYVBPSkpsOHRWZnUzRElGM05ndzNFZVIraHcxc0RTYU16eENzMWF2b3FFRlRjTVppWXViZmRzVWlyVmtaZGpuczFURktubStLRTJ5cTZLSVpUR3RnUmUyOG1mTUE0VjkwTkZMc1Faa3JVcXNDQ1dRaGRSK2g5NG4zd2Jyb25Oc095ZEhTbmVCVjFRWU1EVXZoTTgvUEd0aGlyN0FjMGYvQUtMTUNRMDZnYlRlWTYydjlNTUpKSStRVlFnN3FyWTNPbHlCUHNjWUpmV1djeFZnalM5Vm1BQTM4UkdNWStBWVVvaytJUkIyalZQTHJIMHhqQmVUSWlxd0hpMWJnM0pBMzZkUG5HREYzWWJraUsvZnMzaWlZS0c4MlUyNjR3MGRoVHBHWHFud0hYcWdRTGJpQnlqL0FEZ1c3b3AwaFl6RVBycGhFTlM0QUE1c1FOdWxqNllvOUVtMnhmck9rRWhWSUJnN2crRzAvSHBPTjZBUE1rcTFjdm1LV3RGb3RDTXJXdk5qUHRpTjdaMFE5aXppV1NxY05yMHl6TzlKU1dXcHAyTTNuMzJ3YkoyMXBGRk53R0RTekRUdklPOXlZOHpmcmJHdXdPcXYyRzVhcUhXc3hxR2U3SkxMYUI2YytzWUFZcTBYWnlvYWFNc0FIUVNkSW1adWZrUmpCNCt4T3phNmdxRjlURWhicHo1K3RzRmE2RWJ2c2Y1cDF5ZkFNaGtBU2pzVFhiU0puVXZPMndVQWllbm5pVVZic3BOSktnanM0cHllU2JpQ1ExWXV5VXhGb0lKbnlOcDVuYkFsSjhxR3hSVGpZSFQ3ck9MVXBHYWRkQXBCUHJFeHpzVGIrK0tValNkNkI4dFVxTHhFcVNyRVNuaEhNR3dIejE1NDB0SVdPblJieFpaelZSSDB0VENzQmFRczh6OFduNjRFT2c1RjdHdkFNaU14WHlWR1FWY083eEtoZ0dJaSsxbHdNanBCakhkZWlQRjgwcWNTelRaZFhTaURwUm1pUVJ6MzhqalFqU3RtbFhTRUdXcVU4eG5lOGNzclRMRGtmbm45TVBmRk9pQ2h5a2tOZUt1S1ZEU0RwQUEwSVo4TUhZVGFOaDhZV0M1SzJkVW9xS3BtYmhzeldOTlFocTFTUkFtM242WG5GZWpqdHQ3SEdmcWpMOEV5MlZXczhGalZyS3gwZ21JV1IvNGhwOVdPRlN0bFozRmZFRDRkUS9FWjJtYXBxUnFZdTVJTXFMUUkrRGdOMDZKcE45akdyM2RSRFQ4Zm1TaEFKaTVpUEtNRVphTTlYa3BTa0txeVFOTk9QMjMvQU00TmlTUHRDRXpVY2c4b1lHM3hnaERYMUROVnc0V0E3aGRMWHVUL0FMeGdFMkEwZ2hEL0FPVjRBa2dUNmJnWXhqM2h3VVpkeEJOcGh1a2MvbjVqR010Qk9TWTA4dFZUVXpCbUMvWGJ5eGhvNkQzZi93REtxbFNRU0R1SXVlWDM1WUZic2R5MExNMnhwc3FGdytrWEdtM1dUMW5rTVBka2tBVldWYUFZTHBOekUzaTF2OCtlR1NzUFE1NERVRlVQVHFhZTZZRlR1SThQK01SYXBuUmkycll5eXRTaXJOdzNpTGlCK21vUVNYVWsrTGJsZjR3c20wdEFxbm9ROFo0YytTcWp1V1I2VEU2SEJOckhueUlFNEtZa29OYko1ZVVwZm1IVFZRVEdxWUY0OWNFYUZVVlo0cFZxQTB5dzFXUlR1T1pGdWQ3K3VNTEtWRk9VcG1wbUtGSnBDWEpNL3dCUDl2TWNzWUVZMkdjWXpEWmpPUXRMd3JGUGUwYkFiN1h3c1kwVXlOT1ZJY1ZIcHBsT0c1SmFqQkZtcThFZnFnMm4wSit6aVMyN0tSaW9xZ2JNclNxQlZWNHJpRmRnYjZmc20yMkxDUHNYNUg4M2lLaGwzWWhUTmdiaitNQ1hRcTdET05IODZraEVnMkVtd05wVy9UK2NhSFFjbjZqM3NqVkdXNEx4TFB0b1BkVWxwVTlYOWJHVDhTYmZ4aWVSWEl0R2tyTXZtSGRhVGVBc3JIV1NwM1BJRG5GdGplSjU0cW5wTDZJdFZZRnduVUtsT3BTTGFwRzBXdHZ0NWJZelhvbkdQSjkxUmZ4VE1tcldjS3lnRFVnbm56bjVPK05CS09qU2JiN1B1RVpZTVNUVEJaeHFPcTJsUWIvSWoyd3pvS2pxaXg4c2N4bVhkaEZPQ0NDUDFYNlc5dW0rQmRBbTdZM3krV1NobHd1V0NNeElhUWJsb0kyNmpwNVltNWV5a1VxWXZ6QVpYSmlvcmliWEFpYmlaamxQK3NNblpONkVlYVlzMmhsWUJaSkJhRHZ5KzlzUFJPUkJtMFFEYzNtKzF6Z21EbUNMbmF6VkZzS3p4SUVtNXhoVkt5dXRLeW02QnBFRytuN0gwR01NRVpTcHBSNVZ0VTJhOXR2cHlKd2FGNWJvdnBCdndGUlZRek9vQ0Q4R2ZuQUh1andWQ2VIZDNKSjF6SS9xNUhCb042b0Z6YmQ1WGFvRk1NQVFkVWlZNStSL2pCV2hhSzAwc0Nxclp4QUo1K1h3TUZPZzFhb3U0TXpMVXFvVENrR0QxYUxmY1lScjJXeHk0cWgvbkVmUFphanBBL0VVQnBWcWU1QnVkL1FINUdKOHZzZVNmYUZDMTNycWFPWkJaUUlxQUVXdVNkSjY4NHhsSCtWaytidlo0K1hTaURVVStHekF3TGlSTWRPWDF0aGdMY2ltcXpGMVlzMnBWL1R5NWZXM0szeGpBbVhaUlZBNzRNUEV0OUY0bmYyNjR3MER6SjB6WHplWEdsaXRSeE9ybGVUNjJHMkZjcUVndm1oenhKdFFXcTlOdFRzM2phQVpQSTlPUnhHSFkvSUdvZDVXelk3eGdJTUVra3pZa1gzNi9URjBEa0JVU3FaK0NDdHlDQ0lPa205ajVmUFhBa0dPM1laeDFpS3RJdHFaR1UybnBFZ2RRWjNQbjB0c1c5RFpQMUNsYy84QTRieTZoNEZTc3oxQUpJUElYOUpqN09GYitWRGVoRnhCanBnaVNXaUNDU0Q3ODkvV3h4WHRFdVZXVlVxaTZWQXNzR0dkdE5nSUh2OEEyT05RdGtFVm1jYmhpRE9xK2tDM3Z2OEFVNERqWXRiSG1RcEZjblVyVlBBamdLWjJBSk1BY3BOdmljTDB5cTBySjVMaDlaMkk3eEJVZ3R2QU55Ynp0YVBwZ3FWYkFseWxRNWRjcHduSU9JWE1acHJsMGFBa3g5UmY0eEtTY21VL1ZVWjNPWjJ0VVVhcWxNTVBGcG45UnZzT1hNbWVwNjRvbFJHVEVPYkdweHFNM0lFTlBRQ2Z2cGg3SnlaSDhNOWNzMU5XY1RCbHdzSHBHQ0VZTU5XY1lNc1RWWUtWYnF4aWNZbkFsbVFTWUs2UzdGcFF4ZVk5dWUrTVVLTXNWTlZTVUJKTnZEdGEzb1ovZkJUSi93QW1NV0xwbHFpZ0FRMHN5MkxYa0dkNXZ2Z1h1aWpCRnJtTlNqZTRBdFliY3p0YjU4c05WQkE5WkZabUxFSXBrK0c0STUrdUNZbXJGQlRZaGxBSURBaSszcDZmR01aRmp3bGVtNklGQmlSRTh2cmdWWXlkTTFYRDh5MEVNNEFoVWJvQ05tOXQ1NmVtT2VjWDBkUzJySThiNGVYWVZhZWtWbExIeERlKzNuMTg4Q010MEpPR3JGQ3ZVcUtWWkFtbVZOb2kxdWYrTDduRkxKcU5NcXFVS2pKS0tTZ0VCdFBVeDYrV01DVWJKdlVDVUNxbGU4V3hDam5lUjBQUTRJSXVpZkI2VHZtalZOTW1raWtrcnZCc1ByQTk4VG1HSDdXTWM0d0dXQkFVaFdKTEFqVVJ0dk8wRS9IbmdSZzFzQlExRXBVeTdIdkhVZ2duU1JKSUFqeitMUmlnQmNvamlCYy9vMVhJM0FKa3g3REFrdFdOQU40Nnk5NWxhc1dLT0xnbnBBaWR2ODRPSlUyUGw2UjdsNjdQbGFZYlVPN0pJRWxnSUFQd0FUR0U0MjJ3cDhvMktjMHdMS3BVZzZpU1dNOUo5L3UrS1JJeTdCNk5UVGxrWWsyOFY5OW9NZGNNQVA0YWxOcXc3eWxwUU1MTDRqQkkyRnBtU054aEpQUThZK3pVVVAwS0srWHBNQjRVV3FBNHAzQUpIVStjWWdtM0lvMm1xSzYxS21hVHNkQXE2aUxMSm1UL0FDQkdLSy9ZaVZiRk9YT1dMbHN3emhXSW14dVBiYm43WVpVRHVTSVp5cFFGTVVLRkppVEpkbzVlY2pmZTNtY01HYmlKSGNxS20zNnlHV2R4SE1mSTk4R2lEVm5xVWkwc1VWNWd5K3FkaDBHQ0VNY011YXFPVkEwVkhuemd6OFl3a1l0ZGwrZmFRYmtLRkI2V1AyUHM0dzRDbFFpb1QzcERTTkxUcEc0SDJNWW12Mll3ekRzY3RWWUlkSmFWRXpjbUFEek5yWUZic29BSTBGakZwTjQraCttSGJNQ2hDVlVRc1hrYWR6RXo5TWEwRXRvcVZxMDBjdHVOVnIrbnFSakJMeTdNNG9rM0lGMUhoQkF3Um8xN0dYRE0yTzlVay9yQUZqdHY5TVNsRjlsSXkzUSt5eFhONUh1TlFGYW40aXdKR29DODd6SS9iRUtmSXQyVTAweTYxbVRQVWxORmlGcXVxalVoNU9oM2k5eGh0Z2F0QUw1ZHN0VHJVSEFaMWdFMklnN0VSc0RZNHlzazFRcHJ5TXdVQjJCQVluVHNOL2o2SDBpcEpxaHB3c0NsdzU2eUxvTlNvRkRKSWtEWS93RDI0ak9ROEV5RlJOTkp1OUJMdC9TWU9xYmN2VzN2aWxnNHNobHlHVkNGYUd0TU5KUDdlWHhoaFJkVEJUT2tHVEJJWUM1a2c3ZTBER2UxUTBYc040eTd2UnlEeUVsWmdubnpJNVJiYjV4b2ZGN0d5djRvcHlsY0dreUVoVWlmQ2RoYUpHL2w2bnBnSkFqTktOQVBFS3cvRWdNR1FJUklLaVFkK1hQOThNaEc5bmlGcWlVbFN6YTVJQkJtUDJ0T014V3pROE55azBobXF4U21xejNVS1RxMGtDd0d3QXRQVXh5T0p5YVIwS09yR2xPbFZjaFJUWmlTRVVBa3hNOU9YbmlTZE96Y1MxOGptYWxRZUJxWS9vSkZ5STM2akRjMFp4ZEFEY0hLc3hSYXdNaTRKSEl4YjB0SHJnODBLb1AyREhocmR6SnBzUUtrMzNqcEE1K21IVXI2Rm5qUm04ekljcWhjNldocHNENWp6bkRwcDlFaWhWcnJJb3FYRStLT1I2ZnNmZkJDTkZsTXptVnAyTE00UG40cmZmck9NQWhtMjd5a2dxcVN0U25NVGNiWEE1RzEvWEdNQ3JLa3QwSU1xd1B4OTdqR0VYYkdWUlNNdFZKMHNRc2FpSUcvL3dEbzR3NEdvcUxsaUZZM0FGeklOanozNTR4aUlVRkVrcUhCQjhNd1FUQis3YzhZS0t5NE5aZEowNmZENFRzTnZlY0ZCTGRNR2t4RUtBTEhrUUlJOVA3WUlVZk4zZFBPRjZRL0xZaG1FYmlZTWRNYlhzWmRqL0oxbEwwM3BNZFptUmN3d056RzNUNU9KU1h0SFF1aG9uZDE2UTBoU3hHcGRJdEk1ZXZUMkdKMnJvMU1vcUl0V2hQZGdWS0lWUWdZYWhUdkFrYnhjZWhHR0VtSmMwb3EwQURwY0pCZ1JCMmtDT1YvdU1PUmx2b0s0VFdRWmRLRE5CUGlLSGVSdjZEbjY0ak9MZlE4WkpkaHJvMVFJd1Y1cUMxd1JmcjEvc2NNTTR0ZGdMRDh4bURhU0JEYU9SNUgwMkdIUkppM01HbU9KV0RNdDlKbll0eVAzeXdRTHNzNHdkZFBKS3pLcjZYOFNjZ1lOdmpHRGszRlVMa3F1WEN2QmNocGk1TFNRUG5Hb1ZQUlhtZExWOVFCaWJ4ZllRZjVnY3NGYTdNd3JKTFRaRk5YV3NSTEdmWGJuTnB3Yk1sN1llL0UrOHFEdWFJY29OSTFUS3g1Yzl4eUdKMTlqcHZvS29mOXpxeWFUaWpTalVOSGc4OTl4Y0h5d3JTWXk1UFNReTRmdy9pMmNmdTFyMUg3c2FwTmNpQVFZSkFrbXh0NmVZd2pjWTdHL0hKNlo1VXllVnliMUt1WnJ0VTFSTFZLaEFBbTkrZlByMEdDbktTMGhIR01IdGl6T2NYRDF2OEEwcU1oRFJyZWRSTjRQeWQvU1p4U0tvbktWbWR6Y0dvektWbGd5bjF2TnNORlYyQUZxa09RVzBneHpCTSs0dzlNdzg3eFZ6ZFdGa0dxMEE5Wk8veWNBQlZVcWE4dlNxSDlRWUdSYmZHTUNoa1lCVlN5c0JjeEVua09uUEdKL3dBbU5YSjdwcHZjS0ZKa0VHOS9MeXhpZ0JVcUkyWHBLNDhMTUN3ajFBNStYMXhqSDJZcGlrVEkvTVFSRzR1QWQ3SG5qQlJGMWhxZ0NyRXdmUHhSSHBBR0NnazRZSXJWQUlKVllESG1OdjRuMXNjRUtQZEpDcTJveUtnbUJFZ3lUak0xMXNMNFhYZEthNmlTWFVWQVoyTjcrdHNMVmxZeWREaklWelN6VlNpd3ZwNzBFR2J3UDc0azQ3R1VyZEJyb1dwaDFLcTZvRE9tWlh4TGZ6djhZd0o5Q3QxVFFwOFRJMCtFMmdBenB0eXY4WWNpQkZIU29nMWVNTnFWeGF3NmozUCtNWXc1eTdybmN0UnEwaDNaY0gySWt6dmIvT0pqUm01ZGd0U1dvdG1GSjFEeE9DZG9Fa3I1M3c2QSsySmMwd1hORmtnbFYvcVVYdnY2Mkh5ZkxHQWZjWXJhK0gwZEtnaEdieG45WEsyR1FmUXZGeVdTZFdwaEo2bStDSWduaGxGcy9YY2lPN0JWbURtNUVlbSsrQXpQc3ZWeldWbUpDVWFRalNvMlh5RTcrdUFQNkNhZWZhaUNNdlJwTDRwRGtTd21BRCsyTWxZTG9xVGlOZGhTQ3VBak1vQUEvU1lteDZZS2dGVGFENkhHYW1SUjF5VklKVXFBQjNMdExlRmppVGdtemZsWXV6T2NyVjh6K2NkWmtFalZZa3pmNmorTU1seEZidllOM2dxVTlhcnAwZ3NlcDhSQU51ZUdGS0toRDFhYWxtMU1iUUFCWTRZd0dLcUlXRGxnU1NmQ0FmM3c0VC8vMlE9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvTmV3dG9uLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFaQUJrQUFELy9nQllSbWxzWlNCemIzVnlZMlU2SUdoMGRIQnpPaTh2WTI5dGJXOXVjeTUzYVd0cGJXVmthV0V1YjNKbkwzZHBhMmt2Um1sc1pUcEZjbmRwYmw5VFkyaHlKVU16SlVJMlpHbHVaMlZ5WHlneE9UTXpLUzVxY0dmLzJ3QkRBQVlFQlFZRkJBWUdCUVlIQndZSUNoQUtDZ2tKQ2hRT0R3d1FGeFFZR0JjVUZoWWFIU1VmR2hzakhCWVdJQ3dnSXlZbktTb3BHUjh0TUMwb01DVW9LU2ovMndCREFRY0hCd29JQ2hNS0NoTW9HaFlhS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDai93QUFSQ0FFM0FOd0RBUkVBQWhFQkF4RUIvOFFBSEFBQUFnTUJBUUVCQUFBQUFBQUFBQUFBQlFZREJBY0NBUUFJLzhRQVBoQUFBUU1EQXdJRkFRWUZCQUlCQkFNQUFRSURFUUFFSVFVU01RWkJFeUpSWVhHQkJ4UXlrYUd4STBMQjBmQVZVdUh4SkRPQ0NCWmljaVdTMHYvRUFCUUJBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC94QUFVRVFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBLzlvQURBTUJBQUlSQXhFQVB3QlFVa21TTWVoRkJYV25KQTNHY2ZOQjhrZ3FQbXg2VUYyMnl1QnpIMG9DTElVb2lFSkxXWlBKL0wwb0pIV3ltWkJDaHgzb0I5d25FR2VmeW9BdDBpTTlwSnhpYUFVOGtna2tHSng4VUZmbUVpQVI3ODBGaGtLQ1FyT1BiOWYrS0FsYmtqMEo0amlndnREanRHTW1nc0pFb0FneWNtVCsxQjZST0FZUHhRZUU4d28rYVJJUEo5S0R4TUdER0ZEQkI1LzZvSzdpUVVLM0FRVTkrZjhBT2FDdXR0VTl5SjdEK2xCQTgzSW5pZTR5S0NxdHNBVFBmdDNvSUZJZ1NKd08vTkJ5QkF3Ukh0UWRKT1pQbDllODBFcWZLbUJ6NmlnN1RFRUFDT1BVaWdrUkFWT2NEa2Z2UVNoSklIUEZBYVNnZ21lVDI5UlFSTFFNa0hIRUgxb0l3bmpNcG51QlFXYllIY0NJSHBRRmJjSkNUOGlnc3VNZ2c3WWpnUU85QlJ1RytkNDRvQkY2d2NqRVR6eFFCcnRvSUJVbzdZbVZIaWdESzFDejhRRHgwR1BTZ3ROWHRvMjBmNDZZaVlTYy9UMm9JV3RlWlN2YTJnclFCL054UHpRVHRkVk5vZVFIYmR3QS93QXd6aWdsZTZ0dG1zTk5xVmo0aWc0UFZyRHFURGJnVVJqZ2o4NkN6YTlSMnBSNWdzRVp5TS9TZ21aNmpzM1hnMmpjRDNVS0FxMDYyOEJzMndSNjU5NkRsMEVnUUFkeHh0b0tycUpUS0lQeGcwRmRhTm9JNEJ6Nmo2MEVDMDUvc2FDRllQZU05cUR4TWdBNUJuajJvSjB6bkg5cUNRQWtmMTVvT2s5NUdlMFVFZ0JJeWlUNjhVREZ0ZzhaNHhRVjNRTUV5VDMvQUxVSEFUdVVUaFJpU01ab0xMSUlHVE9NZjJvQ2RvRS96QWNqRXhJb0NDVTdrQktveUlKQjVQdlFVcnBJUU42OEpneW93UDhBTzFBazlTZFMydW5yVTAzL0FCWE9DbE9RREZCbjJwNjIvcWl5bDFiZ1FQNUJoTkJTV3dsSVRzQlVZNUo0eFFYV0dmRWJWdUN0NllJVWs1OTZDQjlwZXdFcUtnZXhvSVdYVkJaU29wS1NKQkpqOHFEM1VDVW9hVzJBRm81anZRY3N2dHYrSktkc0prLzhVRTdkeUdUdGMzQkJ3WVBGQjBvbmNDM0pUeVNQM29KbWRSdm1DaHhsMWFJeEJOQWMwdnFwOE9BWDVTcG9uS3duSVByUU5qYnpiNkV1TWtPQlEzWUVpT2VLRHh4c0FLajVvSzZtNGpjTzNQRkJDcEJnRUhqdlFSS1FDb1p6MzdVRXFFeGdwbk9CTkJJQ0FDVHoyaWc2Q1RIc09LRDJkdU4wZnBRTXhFNUgwOTZDcThtVkFDQ0QzbjlxRGtKbUlNSGpGQlpiQmdFUXBNY3hRRXJZZ0pTRmpuQjdRZTJhQVgxUDFiYTZTejRiU2ZHZlA4b01BWTROQmx1cWRUNnZxYjZ6OTRXbEIvbFFZQTloUVJXZW1YRjYwdHhoRWtEUHJRVE02WDkzQ2c2M0s0R1Qyb0NKMFZsRnFwZVZKQTNLeGxBUGVLRDJ6MHhTclFORktRcFVGSjdrRS81aWdwMitrTzNLbGt3R0dTcE0rNHpBL0tncFA2WVdyZGI2VzVRbHp3eVQ2K2xCRS9wcTM5UUZ1MENyYU41S1J4Ni8xb0F6akhnWFJJTzVVeUp3SlA4QXhRWEcyQ29JSlFyUDRvSGFnck9oYU5wVEpTRmJZU00vRkJJdFk4QWtlYmdpVCtsQndITnUxSmhSeVNrOXg2ZlNndmFQcmoybVhBRXFVeE1GQXlJOVJRUDJsYXBiWHlkemJvbjBQTkJkY1NxVlRudkFvSUZKUHBqa1VFVUNaZzQ3ak5COVBrQklqNW9QUmtETWppZ2xRbkhHYURzTmpNaWM0a1RRTW9HQkdEOFVFQzBTZjkxQnhzNEJISDZVRmhyYUNKSW9CUFUrdURUTEZXMGplY0FBeVQ4Q2d4Mit2N2pVYnRUem01S0NZZ0tKSW9HSFFtVWtCRHBhdUV4SVdRUW9EOG9QMW9Mem11ZmRrdU1vUWxKU1pTUU9mbjNvQjdHc09YU0VvY1dWTGtrRkJHZTlCY3VOU05xOTRiTHlWdDNMWWFVazRKRWdqNjBBOXpWWFV2aTRhOG5nZ0RCbmFvRXhRSGJYVlZXNituN1U3ai83SG5pRmNxV09Kb0ttbTNaZHNyeE4wVHRKS29JeUZKVkhQWXpGQmZ2MC9jTDVEakNrZUk4MjJ5RXhJbFpnL29jMEFaL1RsS3VBNjJnN1hYMUJLb3dRRHlQYkVVRVR6TzFoZXlWdXJWQVVBWVNQUWVwb0tDN1B3MG54RXEzbm1NQWZOQlJjQkxLaXNRa1FvUmtuMm9JMXBVTGR0UlQ1MWJwZ1NZL3lhQ3VvRlIvQ0ZFSDhjVUU5azg0MDJmQ1Z0OUZwUEJvSFBwdnFNM0VXMTRDSFpBU3JzYUJuV2tUT0RQcWFDSlNDRHhuOGhRY2dLQlBvS0QxT1RKRTBFZ1BHZS9hZ2xBQjVVZnlGQTBiWkJFSEFreHhRVmxreklJUFlDS0NMaU5oNTdVSGx3NmkzdFhIM1BLaENUelFaTDFocjUxUzY4T3lDb1NQT3VPVDZDZ0hhVGFYb2RTNGJNcmFrQlN1YUI3MUhVYmZUN0pEU2JGcll0SWtqbWFCRTFtNFJkclV0bElDZ1p4elFDN2Z4RTNhQ2hPMVc3Z2NVQmUxU3U1ZFFuYVZES2h0R1pvQ2xwb2R5K1hReWh4UWQybmFjeFFYN25TTDBxWjN0S1N0dVVqMnlQMW9QWHRIdkV2cVJrRC8ya0ErcG1mZnRRWGRZYWR1TlNEb2JjTFZ2c0NBVTVrSTU5OHpRY3ZoeTIwZERTeXB0UzJpc3J3REN1UDBHS0N6YjJLbm43UnBUWUNrb1NsTFJFSlFDTUpQclBKb09kZjBrTktXbHBvbGxNbFMwaUFxSUJqMmt3S0FPenBEWXMybkhWd3RaVzRsSXo1UmlZOU9meW9CTGxpcTZlMnNrRWhQbVBvQjJIeFFWTGhsTENRa2VhY0NEa2p1WW9JSFBMazRQWVJKTkI2MHJ3VnRxUWxaTTlqeFFhUm9sNTkrMDV0WklLeDVmaWd2RWJza0VqdWFEaFNmWE1kNkRtRWdoVTgrMUJJaVlpSU5CS0ZZOHhBUGVSUU16b093Y0dCeHhGQlhXUmd5UDcwRURraUFTUFRGQWkvYUxyU205dGloUUE1WFFadHZLM2dFZ2tUTUFkcUJ6MDE1RFZoTHFydHJIUGFmZzgwQW5VTlpmVTRFSnVHcmxwQklUNHJjRkk5Si92UUNGWEw3aWxHUkhNSkFBL1NnYWVqdWxiclhMZ0FJY1EzaVZxRTdSUWJSbzNRRm5iMkxhV3dsRHlRVkZha3lWMER0b25TVm8yVUR3RUVGQm5HVW50UDZtUmlnS1gzU1Z0ZUpjWGNJUGpKUklVRTVCQWpOQUNYME9VSHd3dVZMQVR0Um5jbVpNazk4Y1VIRnowSmJ0NldsWmE4UzRVbmNwR1VuZVNZVEgxSDVVQVcvNkw4QmRxcTBZUzgrbGFRcExpY2JnTzg0SXhRTCtzNkxlMmR3K0x0dDlhbEE3MXFQNHlyektNamlaL3RRQWRlYXVYVzJ3d25ZaEtkb1NCRzRnUkpIYU9BQjdudlFJMTdiWG9jV3BhbHB4QlVKNGlBUGlLQ3VFdXR0bGxLVlRFVDZqc1BpZ3BYSGlTVnFBQ2pHZDA0OVBhZ3FJWElWQ1NENjkvclFjbGFnc2tBcDI0a2lnTzlNNmtxenVDaFN3RzNNRUdnZlVLQ2tCU1NsUVZrQ2c5V1pWdVNaeFBOQjRFd014bk0rdEJJbE80UWNlNnUzeFFTdEpPd1FTbjJJSm9HTmFRRXlyQmlCbkpvSzZ3WnhCekdUUVZIakRtUU1kKzFCaTNXcjVlMTE4RlVnVUZqcGEyYUZ5SG5Ya2lJSkVab0RHdjNTTHRPd3VKMng1UW1ab0Y4YVdDeXAxeEtsSjRCM1VCbm9ycGIvWE5hYnRtQXZ3d3J6cmlBZmp2UWZvZnB6U0xiVGJWREZvZ3FUdjJDRCtLT1NmYnRRT3VuMjRLUDR1OUtjZnd5aUJ4d1BlZ01zdEVvT3dRbU53SnoyeVBTZ2xRdys2MlhWSmNLRXdaRTkvVDAvYWdJV3FFSWJLRlQ1Uk8rSktpZjMvQU9LQ0s2aVVsVzBuZ2c1eDNJL3p2UVZMdExialkzbFM0QU1uQ2dQVEZBSXZyQVhGdStoYmJhWWxXMENjKy8xNy9OQXB2OUtXenpyd1dnN2p3UkFnOXlQMjk2QWRkOUNOdzZwckxhd2tvMzVqdFB4UUoydTlEQmhIbTJKVUNUSEFTYUJKMWJwc3NRRXQ1aVpqOTZCTzFqVDNiT1ZwQ2dnSDA0OWpRQlczbkM1dFZrOWdlOUJZdDN5Q0pKU2ZmMW9ITFJ0WGRhYVMydEpVbVBYUHhRTk5zKzNjdGhTUkI0MitoOWFDZVB3eUQ3Wm9QVzBiY1FuSTVubWdzRnNUSGNleE5BeE9JVVdESU9TY2VudlFWSFJ0amcvSEZBUHVCdGphREptUGVneHpxcTNRTmFkQ3lzTEovQ2tab0xXald5R0c5eTBPSUhPNC92UWRwYlpldWtoYWlVVGdIeXBIelFHNzIyY3ZHMmJhelFwVElNSWJTT1QvQUxsSDloUWF6OW5Hak5hUm9DMy9BREIxWGxVdEkybFJqaWFEUk5DdGc0RXVsR3hSSUFCTXg2ZkZBeVc5djk0aEtSQ2psU2lTZUR6eFFNT25hS0ZNeTZRcFJHWkUvd0NmU2dKQ3cyb0FBUURFR1BTZUtDdmVXSlZ0S1ZKYkNCK0hqSHZRQnIxc0pVcENEdkFKU1JFbmllMzFvQXQxZFNoMUtnUTV1RUFIS2dZd1IvbkZCSnB6bzhFbFFVU283dDRpVG5rMEh5aWhHNWEwZnpTbElFQWowbjA3MEZVdnFGdW9lR0ZTQWR4RWdESng3aVJRQU5XWlM0MGtLV0M0b3p0Q2hKSDlvb00rMWUzYkxpanViamR4NmVnaWdSOWJzV1hGcUczSGVlYURPTlMwMVZuZEtTTXQ3b24ybWdyckNBb0lXSVBwSE5BUnNMZ29iU2lRWU9KemlnY2ROZkJ0a3J4Z1RqbWdZR1ZCeENWQ2Z3eVRRU2JSRUVSUEk5cUNjUVFQL3dEVVVESUVud2hFbU1UeWZ5b0tkeUJuSGx4bjE5NkNtb1R1RVFySUFvTWM2NXQzR2RWVTVCQUt0MjQ4bjYwQytMaDl6SGlPYkpBMmhXS0JyNll0bW5IRUx1djRpdUFrL3BRYUwwN3ByZHpxanJUMTBxMVpRbUZLUTN1T09Bbi9BUEluRTBHdHZXalNiQmx0bEk4TktRaUNpTng1SkhyNmZuUUg5RmIyMjBKQUlCVUZTWjdjL2xRTk9sSVN5MmdBbjhPU0p6UG9QNjBEUlpMVXBFcTJoSXdBT0FCUVdGclNsTW5JbURIYjVvS044dHRkdXJac1dFNWdDVDhVQ2JxU3hLaVFxQVA1bEFrcFBmMmpGQUJTOHBJQ3RvQ1hCLzhBMTdUajkvZWdtc0hnQXNCbGU0QUlDeVJ0NUlKTkJadWRpaTR0RVNOc3FLdTRFZnRRVjMwS0ZnVkpJS1loS1FkMEE0ejhVQzFxRnl0S25VdkoyZ0hDRWlRQkVINE1jUWFCTzFSWWMzcEFBS29uMVVPMktCUTFOS2tyZ0NDZlF6QW9GN1U3VkRvSWc3Z21jMENmZnNnSy9EbnRGQlViT3hjbU9jQW1QcFFNM1Q3aUZIYXFTamtiVHhRTyttcUpaMkRLWng2VUZ4U2M0aURQdFFTN1NzVFA1MERNR3dXb2drQThBWW9LTndrZ0ZJSE1na0gzb0taU1pNU0RQTkFBNmkweXl1YlJ4MjhnSlFtWkk0b01mdTNHRTNLdkFTZHVRbU1SUUYrbm55eSswVkxndGplb251UnhRYlAwRmM3a0c1Y1R2V2tGYml6azdqMi96TkJwZGk4cC9URWVPbEtVTE1wUnVHNlk1SHg2VURGcERwV2hLajVVbmNsU0o1Z2NlOUFjdEhsVzVEYnpoUVNqOGVPSXhIYjJuMm9Mckw3bmlrbDBTb0NST1B5SHRRVzFYaW1HNFFoUVZCQ1NRQUQ3aVRRVWRRdUZxbnhGUWxzRElYay9NZCtPUFdnQjNsc2toSjhOU1NmeEdTcFNCMkVIMi9lZ0NMWk8waGF6dDNFSmJVQWNEMzdTZTFCN2FLQXRFbExoSUNQRUFXbWR5U1FKVEJ6SHBRZDNRV2haSGlNdm9VaE8wQUtSRURJZ2pIdlFESDdzQ1czVUdGSklsT1VtTy84QTNRQ1g3MjNVRnBTRXlxUW5jTjBRY2ZYK3RBbDNsMlZQbkdGYzdzNTk2QUxxVytkdm1TUUo0akh6UUEzZ1M1d1Iyb0UvV1VwRGlvVkE3KzFBSFd2ZVFDdWY5M2VnT2RQSlF1NFFqZVlLc3g2VUdwV3pLVzJvUUlSSC9kQjZ0QU0rNWpCb09nREg0aitjMERVd2lXQW9pU1lVTTRuc1ovT2dxWEtNbWNwRWlPMzBvS0t3RWtpUG4rbEF1ZGVXejl4b0RxYlV4UDR6M0lGQmtETEtFdEs4UUR5NCt0QkxwS2xLdVFURUxVQkhhSjVvTms2VHVFcGFjYlpXcGUrZU1DQmdtZzFmcDFiYXJVS2NRMHpsTGZocFRKVDJqK3RBMFdhMXRQcDhpbHB3bmFyRUh0bnQ4VUJTU3BLd28rS1NrSklDWUFBK2YybWduMHgxZTlLa2hMWVY2R0FvY1l4UVRMY2NVaytJRnJjT0ZyQUtoN0FHTVVFWXRuWG1FcWJhdUY3VEJDVVFGay9QYklvSzk1YVhMWVEwdTNkbFJPVkRkaVRCVm45dlNncE9XNncxdVV4Y0pkS2N3eVNubmttY3ppZ0htM1F6NG9LM1d2NVZLS1NsUWpQd2NUeEhJb0t0MjRpNGJXbEw2TjhCSVJKbEo5NTlZNG9CZDhRaTM4UVBGc0trYlFyajJqNTlhQlcxSWh0c3FVRUY0b2tUek05NkJhY1J0TXBVbzRINGpNMEFxOGRXNG84bkp3VGc0NU5BR3V5VU9pQ1BpZTlBcWF4Q25sQXBtTzFBRGNDVUhkdEFCVnlNUlFQblErbk52SThkM0NrOEdnZXRvQUtZR1BRUlFjS09WUnp6TkI2a1k4b0ZBeldoVVlCUUQ3UnlPZVBXZzV1WkVsSmtqa3hRQzMxeXNrWUk3eklvSzkwZ0xzbjBrVEtUQWlneFZTSXZyaGw4SzJsUklTbnZtZ3IyNVV6Y2tnSlNsc3drRGlnZnVrdFJjYlNnSmplcFBoZ0F4M21UNjBHcDlPWFNnVUlTaHp3blZiVnFqSnhuNG1nMGl4VnZiYldpUXZZbVQ0Z1VTUWUvZmtpS0Jpc3k0NEZiZkRJU1RCQm1jNS9JOGZXZzhhdFZJZUJCRHBCTUJXQWMvcEhwbWdZckVLbkEycWdxbmRqNmUxQmJTeVBEQkN0K2R4MjVtZ3IzTmtEdWVjMktVRGdSUGwvcWFCZnUyMHJLbTBncENNYlN1VDhLN1VGWnBvT3VOaFhDdVFwVTdUSFlUK3RCUzFPelU3dVM1NGE5cDJnSGdEaUJQdDlmZWdWcnl3QURSU29tQkN6NGhKY0J3ZVFmYWdYZFYwN3dDbHZhU3BRbFFVTTRQdGppTTBDenFWdTRnQUtRQUNEd2NnZlhtS0FIdEtuU3BZaUpuT0Q3MEMvZnFCV29pQWZVNXpRS1dyRTcxRVI4VUZiVExYNzFldHNDQnVFajNvTlQwU3pSYVdhRUFrS0V6ODBCSUU4R1BReDYwSEJNVEFHRHlPUG1nNVh5TnloTWZ6Y21nYjdWS1E0cmNTMm1RSk9may81NlVFZDZpQVpNWW1RU1Izb0JqeVVyVUJ0QUhyL243VUVTbCtHeXRTaHVoUHJRWW5xQ1hMelhYMU5rSVVwWmlUQVQvYWdpZXMzbTFIWTQyNGtjcVFvSEZBZTZZY0tGbFRaQjJyRWYwL1dnMzdwV3ovOEE0MWg5UUJjVXJldGZIbVBjOXZiNjBEclliTGdEd20wd1c0M0QrVlU4SHZHYUJtMHUwQWJTUENDa0pUNWtqK1gxSEo5cUFneGJsQUdDaEpCVWQ4aFFFUm5QdlFGN1pzb1VCaUNBUkk0L3owb0xZS1NERUdPWW9LZW9YTFRWczY0NnBKUWtIQ1JKT0tCT1c0bDlUaVZxMmdwazk5eDU3ZHY3VUErMHVpNWR0K09vSllpVTdoa0FRSWo5ZnlvTE9ydWxhRlE2a0pWNWlZQWcvVHVhQURmSlAzZENrQmU2SUtFQXo4ZXhpZ1Y5WmVTaDRwanlRQkFreGpQNThmV2dWTHVYVkVLU29FY1NRWUhiNlVGViszTGJTaUc0akJQYzBDVnFJMnJVQkdTUnhRSjJzL3czc3ljZm5RWHVpcmZ4cjd4RE1JTUhNbWcwNUpHMFp3ZUJHS0Q0RlcrUWVERWNVSGk0a2VuekZCN0NmNW9uM0ZBN01LVVhTVmtiaUFwSjcvbDJvSTd0a0poTFlWdEhPQmlUUUMxdEFLd2xNU1RIR0I2MEZIVlYrRFl2TFFKS1VrK3ZhZ3hobExGeHFEaXIxOHNNbFJKMnBLMUg0QTcwSE42MGx1OGJMYVZKM0NJV21NZXBvR1hwVzFLbjdjbU5xd1lJVEdKNW9QMGIwdFlIL1NMZngwQWJrRWcvaUhPT2ZnNUZBMDJ0czU0MjFDUVY0VUlBSVNlU0IyOWFCMDB5MkRUSVdzWlZrRUFUN2dVRXpsemJJd29vS3VWQWlJSHdhRDVXb05iVC9LdUFRTnBKejY0aWdvdWRSV3Y0UTYyTWtBYnNrZTBVQXErMXEydUdYQTB0RzFwT2RzRXBQYnZqNjBDMnpjQmQ2a29RZkNVQ2RxVlFFU1lFVHljMEF5NmZRdThTR3dvUnVCTTVqMSttS0M1ZTNTRDRKZEFKTUhjdk9SZzQrbnp4UVZMaDlMclQ2a3Izb1JKQ216RzMzTWMwQ3ZxYTIxdlBBQUxnZ09LamNlM1BwUUwxNTRtOVpEYTBBcUpISDcvWE5CU2RRdExTa3lTTzhuOFFvRXJXQkR4S2pKa3hOQW05UkFKZGJKR0NKTTBFM1NkeVdyaFFTZnhRT09hRFVMQktsTW9VVkV6OUJGQk9ja1QzUHpGQjhwTWZybWcrOE1uL0FMNW9IZEtFaUZKV25Zcnl6SmcrdEIxZEFFRGFEeGdURWUxQUxXZ05rbElKM1pnRDlQMm9COTZBOGhiYW9JS1lJSi9wUVl4cmx1YmJVMzBLQkNpY0JJd0JQTkFQWGRLZ3BlODY0Z0w0STlxQisrekoxTnoxSlkyNVZ2M0pDTm9tU0FaaWcvVG1sc09LWktGN1V1dEVsUTI0ajBPYUFneStpeGxaVHRqbmNZU0V4SithQ3c5MU93MWJwOE81YjI1VUFaU2NBa244aE5Ba2RSZFRYNkwyOHRyQVhsM3FpR1E3Y05CN3dHTlBTUU5odW5nQ1VxVk1ocEhtSUdTa0dneGZxV3l2TlFkVS9xblZXdGFsZGtlY0c1TGJhU01FSVNDUUU5cUJhWjAvVXJVS05qcStwMnBJNEx4Y1IrUi9wbWd2NlYxZnJtajN6ZHRyQ0F2eGNOT0FTMitCNlQzSHBRYTcwRnIzK3RYalMxa0s4QkpXVUJKZ1IrMmN4UUZMMjZXNWNJUUhZY1VGRXJLRExlUWV3eUtCSTZvNmxjdEdra0tTMlVic285eUtCZmE2cTFYVWJLOXY3ZHhpMDAyMlVsdHk4ZkJoVGloS1dHa2pManlnRENSd0pKSUdhQlh2N1BYTlVkVTlxdDNkdHFjeWh0S2drd2VBU01mbGozb1BiUFJiNWh0QlkxVFVXR3dKVHN1VDVSUCswNE5CWWUxalc5RkNGYWs2blV0T1VrQXZvVHRXai84QVlkeHhRY2FqZnRYb1NXQ0NDUVpQSjlJb0U3cVFmK1F5bkVjRTBGdnBXMks3bnhZQktWOEdnMVZwSURDTmdBQkVDTVlvT2tqYWt5Um52Nm1nOE13UDZkNkRtUGNENEZBOTJRbHBZOEliRWphT1Azb1Byd0FHQU1RUGNtYUFSZHJJVkpBbE9KUGIwZzBGYlRMSnpWTDVGczBuektPVlRIelBvS0FSMXYwYXkyMjRwdTVTSDBtTnlaUDBudlFaNWNkRjNqYVE0NDgyNHR3NFNEazBFUFQ5eU9sdXFXTDkwT2kydDFmeGtvOHhJT1BMNjBINmk2TTZyNmY2bWFhVm8vVVduWEYwcElEbG80dndYaUlFd2xjRXg3VFFNM1VKL3dCT2FjVzYwcGJhWVFHTnVWR1A1Zm4wNzBHVzlSM041WTJyRjIyK3paT1hUMzNPeFRjTGtoekpXNm9aL2h0SkJXb1FaSVFudkZBQ3R0VE51bFhTUFQrbkwxTmR1cFR0NWNYeXlQRWRrdUY1UVFxWFNSbVZSNlJRSWQ3MUk4NCt3MWJPMkRSdTJ5UzNaMklhVWhVOEtVcVNaNXg2MEZmZmV0MjdMLzNwMHBkQkphZEFJVVFZSUJIQTk2QzA5cDQxZTJjc2xibXc4a0xhS3AvaHVEOEt4OWNHTzFBMS9ZUjFicGEvdm1tWG1uWGIrdnJhVWxsdEpiU3dzakJra2doV2Z3Z0djMEZYN1F1dHRTNmIxKzcwWlZqcG5qTXBTRkcydUZPQk1qQUpHTnc0anRRWi9xblVxTmVXdzNjclZwclNuRXBmZWVSdVMySnlyeStaVURNQVNZaWdhV3RaMDFMcVh0UHQxdWFUcGpSdE5IWXVsUW9xWC83TGx3Y2VJNHFWSDBHeFBBb0J1cmFoZHVydnJpNDFJVzE0eVpkYVVsS1VsSjI3QWprbFJreURqQXpRZmFZNXFkNWF1dklVMWNHM0tTdkcxUlNyZ3oveFFHR0hiZTRaM050bjhCOFJ0Y0ZKQS9mM29GZTh0bTlKMVp5eWJYTnU0MmwrMktoa0lWeWo2RUVVQ3pyajRldkVodE1oQTU3VUJYbzk4QzhTM3VoQ3Nra1Qvd0IwR28yNnQ3WUlIbEF3WW9KT2NaL3RRUnhQTVJ4ejdVSHhPVGdIL3dDVVVENVlUNENmS2xNRElTTVQ4L2xRY1hQaGtEdW9ZSjNSUCtmMG9BbDhzcVVFcUlKNUlGQlExUy9kMHpwZS91YlpXeTVYL0RRcEl5Q1RHS0FCcFRldGkyU2JseHh4bFprbFpuUGVncjlRWFIwK3pXcENKeGduRkFYK3lQUm1OYVM4L2ZNb2ZXWkNXMUNVNUdUSHRRUzlmL1lkYWVJYnJTbkZXUWNQQlR2UWsrNmVRUGNjVHhRSnR6YWZhTHBuVDd1bldOcnF0dzBManhCcUZuZHZ2and0c0JvQUtoS1FSdXlrSzQ3VUJqN0kxSzZtKzE2MHROWDFHK3ViS3kwOXh1MVJmS1NsU05pVWt0eHdrRXo3a2M1TkIra0gyTFRTcjlkKy9wS0g3aFIzSnZOUFlTSHpNQlFVSWdnZ0FRY1lvTTc2cjZVMGwzVlhycXcvMVN4UTZsYWd3TlBiVWxzS3hEYTU4dWNkNDdVQ2hyV2phWjkzUzB5M2QrR2hLRXBTdmEwSTdudVNjVE5BemRFYVBZUEpSNGFBNHRwd2xSVzV1S0FZeEh1Wmp0elFaaDltblJ1cTlUZmJIMURZZE8zU2RQdGJlNHVrM040cGhMaFp0eTRwTzFLVkFqZXJnSGtRVE9LRGU5VCt3WDdPdE0wZExmOEFwRnk3Y0JKbTdYZk9CMVIvM0dEdEIrRWdVSDVkKzB6cFpIUytwRnV5ZWN1ZE1mVi9EVThRWEVIL0FHcUk1eE1ISEJvQ3VuYVcxZFdqUWN1Rk1ocFNWUUFDRkR2TkFmdmVubUxrdXZsNEtkVWZEVXJ3dDZDTVFTSjVqME5BWDBiVGRNc0xPNnRYTGxjT3dGdUlSdEwwQTdVZ0hLQkJqdlFEOVhzbTBQQjIwYjhOa05xU0VwRUFKaUJRTGYyZzJUQ2RKNmQxQytXNmhwTndxMmQrN2dGM3dpVXJKVE9DcUNxQVlGQWszU1NMcTREU0xuN29wUzBzTHVHd2h4U0o4cFdCZ0tpT085QVI2U1k4WFZHa0tQMG9OZFEwbHRFSkdBS0Q1WGZCajlhQ05XUVQrUm9PQUQyMi9WTkE4MlNCNFoyL2lKeURJNFBhZzV1U29lVUQ4WW5pZWFBRGZwSUpVWnpKMjl1YzBIRGRsL3F0c2l5d2RybTZQUVkvNW9OVDB6UkxaeGJkbGNOSUZvaG9RVkptREhQc09NMEdOL2FUcFNyN1hob2VsRkxqaThOdHBrbjYwQlg3R20zOUlmY3NOUWJVMCtsd2hTVDdEdFFieUxkaStZUjRpUXZhaVZUMm4xUGMvRkFwYXYwODliWHFycXkzYlNyY1NrWVRPQ2t4N2Q1b0V6N1QydjhBN2E2aDZZKzBXM1pTcDdUWHZ1ZXROdGp6cnRuSlFseFVjd0ZGRTh5VVVHbjMvVUtHTEV2czNDRldqaktIR0hVRUZDMGtBaFNWZ3dlYUJZMW5xMnp0N2RibG80WDNWU0NuK1FuaWMrM3BRWms2emY2L3Fxd3BBQzFxSGtUUDRSZ1Q2d1BXZzBORmphZEhkSjMrcFh6cVdyVFRXZkh1WENZVTg2UC9BRnRpT0NWN1FCOUtDNS85TkhTNjlFK3o1ZXM2a2lOVjE5ODM3NVZoUWJKUGhqOTFmL0tnMVRxQzJUYzZlVktFN2VRUk80SEVmclFmai83VU5PUTlxT3BhZUJDbFNwc2s1Q2h3ZmJQNzBDOTBFNEx5MlF0Q1VtNGJHMVlLWktGREgwb0hDM2VYWm4rTGJCMlFmTUR6N21nZ2N2V0YzQ1UrRVVxTUZCZ0pnenlUUWVOM0YxcU9vSXQyV3l2eEZCS2lraFFTbWM1RkJSNjNaQytwMDJzSlV6bzdJdDRLWUF1RitaZi9BTWtncEUrcDlxQk82Z1FWdnNUSklCbjFOQjEwV3dvNjdsSlBiRkJxS2drUmtFekdQNlVFYXM4QWVuUE5Cd3BJZ2duc1RtZ2dVTXp4UU8ybUhhVlQvdU1rR1NvOGtuT0tEdCtCQU1aVnllUVRRQXI5VTc4Z0NZOVNmVE5CNzB1NlU2N2Jva0FPRXBQUHBRYXcrOFdMSFVIajVpMDMyL2NVQ2o5bkdoS3Z1dkc5WXVVbmF3MHBTTnc1VWFBbjExWW9zOWJzOVRaU1dsZUlwTHBuS2lNZ3pRTm1qM1lXMDIrUkc2TjhLa0dmN252UUZ2RVM0aVZMVDRaeWRwemdjSDlmMW9BdXRtM2V0WHY0VEwxdmN0bHAyM2RTWWNiT0ZvVU80STlQWTBHTXM2ZnIzUkRkeTFvbGc5MUIwb0ZyVTFZTDJPM2xnbmtsQWs3MGM0aWZneVNGRjNyTHByVWx1ZU4xQTFwendrbG05dFhtbHRxSjRnQWpBazg4MERaMHIxdjBObzdKVm9idXNkUzNZQVM1L3BtbU9xMjVQS25RbElHYzBGQyt1dFErMWJySFM5RHYyRTJIVGxrNzk3ZDA5aDBQWVNNRjV3WVd0UmtRUEtrRTVVY2dQMG0wd0dteUVJU2cvd0MxSndCNlVIVjRuZHB6NlkzeTJxQWUrT0tEOGY4QVg3TG4vd0J5WERxMGtBS0tWRW1jR2d6dHBGL3BPcS9mOUVJUmNqRHJSUGxkK2ZtZ2FXK3ViVzRLUnF5RHB0MHJidVErZzdUQTVDZ1Azb0pMbnFMcDBnaHpWTFVpSi9oSVVwUko3QUFHYUE5by9VaittMkRpdW1kR1hweTNBRXExalVranhqazVZdCtCN0tVWTc1SUZBdHZKUmIyNlVvSlZFanpLbFNpVGtrbmtreVNlNU5BdGF5UWg5dFI0bkZBZDZHczkxMDYrUjlhQjFXSkpBOWFEaFEybnQvYWdqVUJCa1o0K3RCRVVKSjh5VFB0RkE3YWNoYUFWRUVwVWpkaE8zRUEvV2c5dW9DRGlBWTI1d1FPNC9PS0FGcUtsS0FLc0U4am4xb0I5bzc0R29XenNnYkhFbmR4SHZRYlEyeWI3VG5tazRVNkVyVE9EK1E1N1VCM1JyVnUwWmJRaHFWSkVCWVR4N1VDMTFndjcxYlhTTjByR2RxVTVTZlFudlFBT210U0xWdWhDbHlvTGduZ1R4a25qbWdhWExzb0swZ3B6SUFrUjhUNlVFTFZ5bDEvd25GRmE5b1NObVRQYmIzQTk2Q3IvQUtHWEZlSTJFa2hSTzN6akk3bUl4eitsQnkreGZNSWNVa04zVHM3WnVXa3ZDWUUvaUUwQVhXaHF1cU5Pcy9mbjB0T2hYa1JMVGUwai9id0NDUFR0NzBEbDltL1RsbnBSZU5zMm43dzQyRktkeWU0NG9ORldTMjJuMzU5NkR5MlVIYllja0dSTTgwSDUwKzJ1d0ZzL2NPdG9TQWxRa2dSUDk2REhtV1V2WEkzQWdLSEE5S0F3bTFXeWx3TENWc3FnQUxBVVB5UEZCYllVaHM3MjJXV2w4ZUkwMGxHMzhoUVZ0VnUxS0lLZ1B3NGc3c2ZKb0FUcnhVVHU5VE1mcFFCTlNiY3ViaEpBVnRUM21nZk9pV2R1blNRUVZEdi9BRW9EeE9KOWU5Qkh3UDVoMklpZzVJa2dkeVlqMW9JVnBrNEovT2djTkhVcVlNU21lZWZ3ajlLQ3hjb01FSlRrcTc5ekhmM29GKzlVRWtJVkVLNGo4djhBUGlnRXZDWlA2MEduZlo5cnR0ZnNzMlYrOEdibGtRQ280Y0hhRDJOQm9pMVhsa3RTbVhBcGdqRzVPNFRFeFFJZDNiM0xiVjVmWGJnaDl3aENRY1JQTkF2NkcyRU91cWJqZHVuMFBlY2UrTTBEWGRzTFZib1VGYlFFYmdaNUpPZmlncDJGMjViM0tsTFNVeCtDSFFlT0pQNVluMm9IYlRYRzBObmVnbUVTQlBtbWVNNG9MZDR4YnYyNENrbE9ONTI1VUQ2VUNwcTF3eHB5Z0dOenI0VVFFUUNwYWp3RG4xekUrbEEyZFByVHA5b3cwNm9lSnREanNpUE1ybjRBNEE5cUJpZGRiVzBTaGFTT2YrS0R2YzJ5MXVLZ2xKeko3MEdEZmJsY1c3amFTVmxUYXdZQjdubVI3VUdNNzJoYVdUaVFQRlNTT3hsUGVnUDJhQzh4bURPZU1ISEVIL3VnK3ViZHRoS2xKVVZKSUFVbzgvNEtCY3ZpamVRQVFQVWlLQVlwVU5ySklBN1I2aWc0MDlRdW1kdUN1WTRvTkIwZTIrNTZhbEk1TUNKN1VFcStZSEhJbWc4SUcwQ0l4SmcwRVpCSG9PMFJRUmtkZ1BubitsQTM2VTE0UU80bEszRkpXRVFWVGlDYUN4ZGJBbFJVSXpHRTRJOS9VOXFBUGVvbFI0Mmo4by9wUUJuV3hKZzkvd0F4UVF0UzI0bGJaS0ZKTWdqc2FCMTBmcnU4WnNSWjZncFRxUitCd0NUOWYwelFEdFg2anV0VWVZRGNNMnJNclNDUHhLam1ndDZXNGxWMFZwSkU5ekFBNHgrczBEdmFQSmNiYVNvQlJKeUNZQ2xkbytPYUNzbEtIQkFTcnlLSzlxVTRJUGFQU1ptZ0xhY0M0QW9TdG9LOHh5QVRPU2ZjbnRudlFYZFR2ZnUxbUZCQ1FvamNKVG1CelBwOVpvT2VnOUROKzRuVzlUQnlyZmJObmovOW9PZmlnSWZhRG9tbzNPa1hGMzA0dFgrcUlUSWFLcERnSFlTWTNlazROQmhPamRjL2FKb3Q4NE5UMDIydU5NRGdDbWx5aDlBbmtLbUNlY0huaWdhT28vdE1VK3d6OTFLaXd0T0NSQkg2NDl4UVk3MTExYmQ2aXBCZVFwZit4a1JNZXZ4UUJyZThENkcvRFRoSWxWQTBhWmNsRExVN3dEeG1SSDE3MEhsOCs0bEVqQ1l4bkpvQURybThUTXgySm9LYmdVNmt0Tm5jNHZ5cEVVRFIwbjArYmRrUDNRejZSeFFOaStJRUQwRVVGY2drWUhsN1VISXljbkVUTURGQkdvWkk0STVpZ2hJSlBLdnBRTjFuRUZRU1NRbmFFbmlTUWYzOUtDMDZTbFNTbUZRSXlJNFBQeFFCNzB5bzdVTFRIY25KK3ZlZ0VQZ3FVTnBKQi9tSGVncW5CRVo5Sm9Pa1pJZ3oyRkJkYlZ0UVZLSlVuOFVIdUJRRituMTdtNFNvbGU3YnQ5WjkrMUEyMno2L0NXVUpqT0hOc1FmNzBGaFNvY0pRVStjYkN1U2tmTXo2SDg2QTdaSmJRZ3VGd0ZJU0NTWU9PSSthRDdUOU9QVUY4RXBUNFdsc0VCNVpKL2lxR1NnZXZhVCtWQStGOUFRaExXME5qQ1FuRVIvU2crZGZVQ2RvM1FOMUFtOWNzV1QrbHZwdTBnb2NRb0pUdGhRak9JelFmbVN6dERmYXRkTWpmc1RQbDdUem1nWE5WMDlWbmVMM0ZSTXdERXpRUVdqY0VpWUZBeDZVNTRsdUcxZVpITUtPYUNOeDFXME5xRWtKbEtsZW1Zb0E2bklCQU1keURRWCtsVUZ6cUczS1FZUWxTakZCb2lRRTQzWWptZzRnN0Q1Z0FjWmdVRVNpQ1QraVovdFFjS0pJa0hqc2U5QkdzUUpQUGIxb0lTQUQ1aDhSUU1PbjNHMXBLbEJlOHFoTWs1anRIcFFFM0Y0SWRKU1pqSU1ldkgrYzBBKzdDbDRLVHpKay9yUUIzMEV3cmQ1ZlQwb0tqcUlHWjQ1OXFENUlreVlIY2Q2QzB5SlIrQVJ6SE9LQzlvNnZDdlFncFNVcUVuSGN5UDBvSDIwWmorTHRFS0FTVWs0SHIrZjcwQkcwczFNckN4Q1Fod09iZ093SUdmOEFtZ0xPV3kzRXFRMmt1S01KRUNjbm1TZU9ZRkFZU3B1d3RXYmRnTklRd1BPWjQ5U1JNNU5BT3ZkY1RhQlE4UkNWQldDcFhQcDlNbWdrUnFEYW1TOWVyUTB3aElPOTF6Yklua3pCSTlxQmV1ZXJlay92U2JTODFCcTVmZDhxUWtqWWNmekVZVEppZ0hkS2RDNlRaYXpkWDE0OHliUnp4Rk55b2JVZ0FZUHZrbjZVR0xkZFA2VS8xUGRqU0xnUFc1TThZL1B2UUxKYjhGYVJDUURKT01UNjBGaTNkS0FGWUpIMG9JN2hhVnVKV2xVS0dDUjZFZjNvS1pTQzZvZ2d4amNhQmc2RVozNmhkM0NnZklqd3g4bWdkMUVxeUpqaWU5Qnc2TWdHSi9Nays5QkVwUG1VVWpqc09hRDVRODBEQUdCUVF1SjlaQUFtS0NCWU00VUI4MEJ1d2dnQUZTVlRIT0QzL09nSmVLZkxIUEl6Z25tS0NyY2hJSkVCc0hnWm1mNkNnRVhYNFFBRWc1TVVBOXhXWTdRQi93QTBIaVZZbWZmTkFTMDVndkttRjdSK1ErdEFZMTZ6T2xvdExnZit0MVFSdUEvRGljZmxRTTJqNm9ITEU3WVVsWTNSUEIvek1VQmkxdUNFcUtrcEpBU1FnWk1UTXpRTW1sT2p4aVNVclNDUmtaSm5nRDQ3MEM5MXIxQXJTV25Ia3BVdmJrSGpjQVB3RW5NOGVuRkJoYm10OVQ2cHFJZDB0b0JhQ1NDK1RDQWM4RHZRWDBkS2ZhSjFLNGh6VmJjWFRNR1I0cEtVZ2NTa2V2eDJvRHJIMmJkZXNJZFhZV09uTm9XMFFXeThRdFVFRGJCd0pCNytsQXJkU2FSMTFvNGIwKzUwNTYzWlVGaE8yNUswRUhrQ0JGQW9MWjFoQ0MwdXliU2xKaFc1UkhIelFVYmdYN0EzTFpSRVFCNGg4M3hpZzV0cng4cUplWlNBY2VSVS92UUVXV1ZLYlVwUXhnZ0F4bWFDbzRvdGhaSithQjg2UXRGV1dodDd3VXJmL2lxOVlQQW9EKzFRV2tFeDhEOUtEbVNnR09UM2pOQkdoUDRST1pqM0FuOXFENVNCeWN6bjBvSzdpUlBsVDJuajlxQ0ZRTWpQYUtBbmJMMm8vQ2RoSUpLaU9NNFBiTkFVd0VKVEtlSXh6SC9FMEVGMkJ1VWxLZ1JPVDYvbFFCcm9Tc2hXTytCa2lnb0xJM1lnR2dpUUN0WVNrRWs0b05NMG5RbE1kTXJlMnBDMW9Ja3lPZTM2MERxanBmOEExVDdOMldIRUpWZklRSEU5eVZvN0UrcEVqNjBHU2wxelJuSExSUkF0MVE0MHYxSGNmU2dkK21ic3ZXcVhFclNDRWxDZ3JzSS96ODZBN2IzeUF5cEIvbUFnUmdkeko5YzlxQVYxS3dOVmVLQUZxWVVxRmtKeW9BK3ZhZjJvRGZUK2pXekxEU2xOdExJUkN3RzBqR1lIeDN6bWdtdldBeXg0alN3bEk4eVRCVEFNY1JuUDVZb0YvcWJxdTdza0xjWU4wWEVFZ3BkU1lqaWZmNG9NOXZmdEM2dkxDa3R1MmJWc2h3RklEUWxCOXZXZ1N0UjFyVWI5SlZldUozcVVWUWxJR1NjejZmRkF2M0RiajVsWk8wR0JuODZEcHUwRW9TQmp1RFFTUE83V2xORWZwbjYwSFdpMkIxVFZHMlIvNkdnRnU0L1NnMFJLU04yMEZJRURIYnRRU2lURW5KOUkvd0FtZzlLSlNTQk9ZT0tEa296K0pSQnlJeDlhQ1BrQktrOXMvd0JxQ0VwbmFTSWpzUWFEZ3Rna3lVbjNJNW9MTmtOcWdCL041dlNnTHBLbHRubnlqUGZuMW9LZHlvUmtEYk1udmp0UUM3cytZa2tURXg2VUE1MVJKOW9PS0E3MExvNjlXMWhCV0ZCbEJIT1JQdFFiYXUxU3phRzJRa2xBVDVaL1dnY2RKTTZiYm1JbEFvTXorMUhwUm83cnRDSXMzVmJsYlIvNlhQWDJCL0thRE45RTFGelNiMHRQdVI0YzdWSjd6SDBtZ2QxM3hYNGR3Mmx4eHRTWVdJaE05L2oxb09XbjNIcmxQaUthM3FURUpURURHSjdFOXhtZ2FiVzdRMHl0TFhtY0lFZ1lnOEdmWDMrS0N3dTFlZVdwU2pDUVlTVkNaVjhkOFVBNS9wZE9wT2hMeWh0bVZPN1pjSTR4Mkh4d0tBZHEvd0JuT2xpM2x0YnhXbE8xSngyK08vSHpRWmYxQjBraTFkU2ZGSmtGUkJ4SmpKK25lZ1ZyblNWSkNTRXFTbFEzYmw4VUFoNGVHbFlWa3hnKzFBTlh1Y0lTa0ZTeVlTUFdnZnVuYkJ2VHJGRGFTbFR5Z0Z1cVBKVjdVQmRDVDRjUmc0K2FEdEFTcElsVzNCbU0rMUJPbE1oU0ZBaEF3TThDZzgyRGZNRW51TUNNZjlVSGlXd0VOZ3dTUWNSNzRvSTF0cURubUhsbnZ4UGNVRVRqQzVHMVJBSWs1UE5CREptQVJPMzZ6UVg3ZVEzNXBCSFkrdEI0K3JCT2VEenpNWm9CVnlTSjNlbWNkLzcwRk5GdXU2ZkRMWUpVczRDUlArWW9OdzZDMEFhUllKV3JhSGlKSkpnNTVvRzN3UXRBOFhBNHoyRkFXMGNnV3haeExaaVBibWd0WFZ1emQyenR2Y3RwZFlkU1VMUW9TRkE4aWcvUGYyazlHWGZUZHlxNllDMzlLVXIrSGNUS212OEE4Vi8wVjMrYUJmMG5YRkVGbDhrdUFZQ2p1a2ZIZkhyUU9WbHFiUkxZYmNLZ1VpU21DUVA2ZS9OQTM2UzRsVE82UEMvbUNTb2VhWTdHZ2E3VzRiVVI0eFNKSGxTU0Q3VUZseTZiQktncVFET0FQOC82b0ZmWHRVUTY5NGFWbENUR1VPUVZDZVFCeVJINzBDSjFNNndsUUlLUnVJU1IrSWJSR0orWXg4MENCclY2MHlIV2g0WkFKaFlQUGI2aWdRdFNkQzFLVkpPZVQ2VUZYcHgvNzFxcWtzcDJvYk8yZTVvR1JXcEt0bmdoY2dKVkVtZ0xXV3JnanpLSDUwQnhtN1ljanpBa2UrSW9MYmFreEtWUUlnZXMwRWdRRnBKMm5KQUUvd0NZb0pXOXBlQ1o4c1NTYURwTGNLS2llRElCTUNBZXdpZzU4QW5JU1JPVDJvQURIQW1BUjNtYUM2eVRzUVZBSk00eE9LRDE0aFF3QW4wUHJRRExoTzlRYmJiS2xrOEQrdEJvZjJjOUxiZi9BRExvSkpnY3F5QjlPOUJxMW8zNWUwSkdFampOQjNzU0dRU29BLzVpZ3FpNE5ycUNIVUErR2NLQU9OdmFnWkVrS0FJeURrVUhGd3kxY01MWnVHME90T0FwV2hZa0tCN0VVR0IvYVo5azExWWVKcVBTalJ1TEZNclhZZy94R3U4dG51UGJrVUdXNmJyamxzOGt1QlNrcFZHOUpoU1QzQ2hRYUgwdjFhQWhCWWU4WW9QbVZBS3BrNVVDQ1FNeGdlOUF6bzE5TFljS2JnRktra0RhY2M5NXp5S0R5KzZvU1dpMmg5YmdJM0svaVJnQ0lFYzVvRnpXT3BHVVBKOE5NdXFJa3FFbFBJd0pnWXo2MENwMUgxTTJ0b0l0MGp5TGx2dmllL3Z4UUpGL2RyZUJVVndrRG51UFkwQURVTGhSYlVvSHl4elBOQmQrejl2ZTVjTHdaRThVQkxxUk1TNm44Smd6UEZCVnQzbkZJQzJqQkFvTDF0cXpqSlRKSU5BWXQ5Y0I1VWNjWnhRRjdYWFNBbVZUSEh0UUZXZFpTZHBVdm55NUhBb0NMR29OT3IzS0FQbU1tYysvelFXTnpSeVRrODROQXJNSEE5cFB5YUFteUF0cElBOHg5dmFnNmJaWGNxOEpoSlVyMnovMVFOWFRIVEorOW9mdXdra25nakgrVFFhWGFzSlpTMm0zQ1FnajhNUVRIci9hZ0lOU2haTWlTWjQvU2c4a3FXcFNvVWs5aWVLQ3Bjc2t0UmhLVmMrc2VzMEYzcDYvOFR4TFYxZTVTRDVGSEc0VUJ1ZytvTXYrMUg3S3JQcWREdW82TjRkanJZRTdnSVEvSFpROWNjMEg1d2ZzYml3MUp5eXYyWExMVUdUNWhPMVh5aytsQmJWcUYvYmhLWEZmZVcwSENsWVYrWTUrb29LN3V0dW9KbExnOWhRVUh0WDN5Q1ZDZlNnb1AzbTRUc0p6TXppZ3ByZFU1bHc0OXN6UUM5WGUydEtFa1VERjBDaFRkbmNQRVFrSk9ab0xHdlBNcTBtVnJTRnlSRTBBelJuZ1dvSngrdEJjZVFGS252MzlxQ0JKS0Q1cE1lMktDNjFja2hLVXFJNXhRV21uM0V5VXE3d0tDNnhxYTIxSm5BSGYrMUFXR3NxQWhKa0R2SE5CYmFJVXBJUHJGQVcweGh5NUtXbTRKaUpIOHYxb05EMERRMjdka0YxQjM0bkU1b0c5dEFiUUFHMUJKeEJFbWd2dGtLYmxNVHhqL09hQ3ltSTg1bWZVVFFlY2pkamJCSW5FVUZCYXlrK0p1VXFRVXlCSXhtVFFVTlFTL2JPSXViUnNrSU84cUN2WHY4VURScE9vcHZXZ0ZqWThrZVpQOXFBaFFmVUNaOW9mMmY2WDFuWW54eDkyMUZBL2dYYlloU0Q2SDFGQithK3Blbk5kNlJ1RGI2N2FLTEhDYnBvYm0zUGZISE5BdnZwUXRPNXNnZzhRY1VBOWJRTThnOFVFQ3drRGFUSTVBOWFDamR2YkVraUFCN1VDNWN1S3ViaERMZTRsWmpGQm9WeTRqcHpwWkxUa2VPNk1nMEdldVBPWExpbE9MT3dtZHRBWDBxNENDQXFSUU16WlN0QUtRQ0Qzb09IVVNQTUJPZUtDb3RYaHFPMzJOQmRzMy9FU01DWlBIeFFUcTdrWjlCUWQ3c0NnZExHM1c4b0JCSVNUQkl4ai9POUJwM1IrbElza2VJVUJSS1o4eC9iMjk2Qm9hUWxieUZDRk5qemJSZ0EvTkJmV3Z3M2Y0WVRIWWc5OFVCQnNxY1NDTjNxWjVCOS9hZ2w4NkdTaFcxYVZUbWFEaDFLVklsYXduY0oyVUVDSVNKTzBpTUttQk0vMm9LcTJuQWwxRWhQaVlCU01jMEZSa3UydHdIQVhFdUlNQWVwNy9RK2xBMGFMcWFkUmFVRkpMZHcyWWNiUDhwb0NWQjhhQ25xRm5iM2RzcHE1WWJlYVZnb2NFZzBHS2RiL0FHTTZkZUZ5NDZlZU9uWEJuK0h5aFpPZU8xQmpHdWRJOVNhRTRmdnRtcDFyczZ6NWdjVUN0ZDNjRWhZV2hmOEF0VW1EUUE5VnV4NGNBODBEWDltL1RHOUIxblVrRU1KL0JJNU5BQjYzMVJXcWEwNGxPV0d6dFNEbkZBSmJhQ1lBK2FDUnNEeEVqaUROQTM2ZGhoT0JKN2swRnhZM2ZobURRVjFNQWpNaVpuUEZCejRTa0R5bUI2MEV5SEo1L1EwRXVEa0ZQMUZCdC9UR2pDM1lEemlGSlVjVFBQZUtCMjBnaEtkaWU0a3BBSkk5L3dCYURuVTcxYmFnV0V3Q2RwS3VKaWd2V2QwbGR1bGJxUURFa3BKajZmV2dMV1Z3MHRLWVZHN3pmQjRpZ3RLR3lFQ2RoN3pnWW9JSEFIU1ZOd0NEa2R4NzBFZHkwcFRyYWt4QndxY1J4Z2Vob09uL0FBeTAya25lVXB3VWp1TzlCV2RiV0pXQW9KeDVUaUk0b0tUNmJpMFVxL1pjVVhFR1EyRXh2OWlhQnEwblZHYisyQ3dRaDFNSmNiSnlsVVpGQmJjTzFZV21DRGptZzljVU5raUlQcmtHZ0E2dTM1TnlscFFNd285NkJGMWU3MDVwMHRQNnZiQlpJOGluQVpQZWFCVnZPbDlQNmdlY0NCYVBOekc4RUV4UVkzOW8vU1doNkQxTzFhczNLMWxLZ3AxQ2UxQkoxSDEybHpTVTZUcHRyNEZzaElUdS93QjBEazBHZUFGVWtxU0NvWlBlZ2tRbUlHZnlvSXdZY1Q3VURacGpoVTBrSy82b0NTQ01RSkhZaWc2Q2UrQlB2bWdqVUFjWXhRUkxCbnRFNG9PMHFNZGdPMG1nL1NiQjI3ZzRtRXA5OGV4L2VnTTZlRWJWYlNaRUVmNStkQUsxNUx2Z3JiaFNrclR1QlQ2LzlVRnpwTlFlMDFJa2gwZmlrbUk3MEJxMEtpdEJ3aURCQXpqMW9DYnU1QzBwQUM5NTcvdlFmSmJjUXBTWkFCUGxBNzBIZHl0U0ZJU0hDcmRoTWovT2FDQXNxVzAra0xCa0RNVUVEallRaytmWUVJM0VxR1NaNG9LaXJieEhXR0duejRieXQ1YktaQkE5UFErOUJOcVZrcXpUL3FGaXYveTBFVE9RdFBvUjhVQXZxUDdTdEE2ZVpTbTljZGN2WEVCYWJSbEc1WDFQQSthREorb1B0NjFWSWRaMHhtMnQxVENEbHh3RHRQYWd5cnFIcWZxblhqNG1wNmplb1pXVHRRVkZNL1FVQzdjMnhUc1I0cmpqNUVuY29tS0R5MnVMNjJXVldkL2RObE9WTFNzeFFVYngyOWUxRkw3cmkzVnI1VTRxU29VRTNrZlFXemdFWUE3R2dvTmJtbGtHQWtua2lndHFIOHhKSW9LaFZ0ZVNKNG9HL1FnQ3pKRW1KeDNvQ2NBbFdBUGlnNlJLQVFUajlUUWZLUURCQkgwRkI5NGN3VDJIMW9CcnJxVXJJM1JIYWcvVGRzaFc1eDFPNHlPQVJCSDlLQW1FaEtpa0FGS2lDSTVqMDk2QVZyVDYybVZsa0tUdFY1Z2N6UGVnNjZNdkFQRVpkSlJrQ1k0OTZCalMxRDYwQnhLRlR2UWZ4UUNjNStSUVduUEdTUzY0OGRxWmdqajVvT3JkMTV0YVZvV2tqQlVvZy9wUVgzbm0zUTJaQWpnK2g5LzFvT1czajR5WVdCZ2trU1I4ZkZCRStsUGpBK0tTVW1RcmIvWDBvS085Mzc2dHhjb1UyZ29RdUpCS2ptZlNndUI3ZHVhOHFsSlFDRHhLaWVhQkgrMVBvRzA2dTA1NHNicmZWR0VseHQ1Q2dDNHIvYVI2R2cvTjlpd25TWExocTlZOEs5WmM4TlRLaGtxOUJQWSt0QjlxOTI5Y3ZoMTVLVGRGTUJzWVMwUFUrOUFKUzBIUXZ6RU56TGp2ZFo5QlFUT1dnUzBsYTJ5bEIvOEFVMU9WZTU5cUNsZHRscFozUjRzU1FPRUQwb0Z4MXhkczhyWjVrcWswRjIyVTAvYkFKVEMwbnpabk5CYVhBWVNKSVY2RVVBcDFXMjVHUVA2VUR0MDJqYzJNRWU0RkFXVzJBdkF4N1VIS1d3dWNEM0lvTzIydk50eVJRZFBJQWJXZmJpZ1duMHFMcGdUNzBINm4wdCtiZGVTbDFLaU5xOGhRSngrL05CYVpkTzVDRko4eVJnQTl2NlJRQ2VyRzNneDRyYnBUNVNrcEFnaU81OXFBTDB4ZlBGM2Eya3BLRXdRb3o2NCtLRFJHR2tsZHJkTDNMUmNNN2RnTXBrSDE5YUMyMnNMUUNSQ1FTbE80ekJISW9MZmlMS3lyK0VVNEFqTTRvSmJkQzNCdVVoS2tvSkNoejcwSE42cE52YWtJRGFXaytZRUtHU08wVUVWMXFDRVd5WGJoRUVvS2tGSkJQSEo5cUNwWktTOVl0UFBQRkQ3eVNvVGtSemtmRkJKYncyNmhzaHdGQTNCWnlaL3FLQysyRjNKSENnREpLWWcvOEgwRkJqMzJ6ZEFLdm5GNi9wVHlITlRRbFJXa2lBcFArMCtoSFkwR0FMY0Nra0RkNFlQblVmeHJYNlVCVzF0QVV0cWNiQ25EL3dDcTNUd24zTkJhY2FLWFZvQ2tMdUQvQU94dy9oYUdNQ2dYOVNhUUd5R2dyd0p5dFhLMVVDMXFhZkRpWlVvamdVRld5UTZ5c3FRU0Q2VUJIN3o0b0FLb1VPMUJTdlBLNGhSTVVHazlGTklYYUF4SmlCSE5BV3Y3WUJCS2Nqa0EwRkJNcEJqeWs4eDJvTERUVzRFVGs4bnVhRDY0UW9zcTVCNGlnQ3J0Q1hGU2tFZ3h6UWZvY3JVM2ROcFVwS0hWZytISU1MSXlVeGtUSEEvS2dJdHJFYmtsdzhCU1ZEQlBiNFB2UVNhNDJYbU5qclFkVnNIOFFIZ2MvVHZRWi9wOTRxMzE1TFc4Qk80elBJUHZRYUJwdzhSaERxTnhRMjVDRUJXSTl2Mm9EVjBYRXVGTUJEUlNWb0pIOHc3WSt0QjlwaWQxeTg2Mit0U1NuYXBNd25kRTdnUFRrVUZ5MkY0bFRxRnVoVFNZM1NJVUNUeUk5cUNaMVRLdHdWNWt4QUNVZzVQZWdINjY3NG1uSXNsdDduWDFwYVNBWWhKT2VPTVVIMXlsdGkyTnEyaE8xS1lRRktoUkV4NVQ2MEV6eWxOSUlYdEt4Q1FwZlltTzlCYnMydnVURDdZY1daTWxDbzhxajJURkI0KzJicFFTQTRsS1V5dGFrN1NvMEdFL2E3MEd0aTRlNmkwdXdVc05xaDVwb0FJVVluZUU4ekZCbXRyZHBTZ3BZY0NuRkpDbjdqc2tlZ29KMUZwMjNFSHdyRVlCanpQR2YyTkJUMUZsd3VORnhzZU1yRFZ1bk93ZXBvRlhXV2dsMUxjaGFoK0luMW9JR21nNGlPNDdVRUw5dXB0SVdrWkh2UVVueXBhVTlpS0RVL3MzUXAyMENUQUhQelFPT3RXQ1JaQlNDbmNEbU9jMEN3MHlVbFc0QUVBanpVRXJJSVhIeGswRTVTVlNEd2FENVREWWlRbklvTmpoSktpKytwVGlUdUFFNEVqdjZ6Qm9MVnV0ejc2eWg0QUpkRUtVZ25uT1FPMUJOZWZkbW1VdHJSRzlDbU44a3pJa1ptUWZlZ1JPckxkeEx6ZDY0RzJIZ1FnK0dKQkk3L3BRSE9nYnhPcHR2Mjd3V3Jjd3BaQ1RBQkgvQUgyb0hDMmRKdEdYU1NRNGdmaU9kM3Y3Y1VIak4weTBXMnJaRGliaEpKVklUQk14QW9DZGswOWNPS2xTZzJEdEpNU0o0bU9mbWc2TnV3Vk9KVTZ0cUNVcVNrU2ZnR2dwMmpDVVBPYWd5NDQrcVBEQ1hjSjhUdXIyd1lrVUVUcVlVcDlhaW01WlI1Z0ZFcG4xSHB6UVdMWXVOV3hLMm1sV3V6K0lCeVZja2ovbWd0bTRLWEdrb0NIR01La2dqdElNVUY5U2l1M1cyeW9OclRCSXlTQXFZajhqUVIzZHNsVnVoTGpwVzA0QWxNcGtpY2QvV2cvTlgydWRDTDZYdXY4QVZMSUpHaVB1RlR6UWdGdHduc080TkFxMmpoYlEyNHRLVjNhL0t5Zy9nYUI0TkI4OENGUEpRcVhBUC9JZlBLZlpQdFFLRjI2M2NQTEtFYlFuOEo3a2V0QkpiczhLQTgzY1VGcHkyM0pDbzNFOXNVRmU2MFZUVnNYVkpBQjR6UU5uMlJ1QlR6amEweVV5WW9OU3ZOS0tyVlNra0E3Y3llWm9FQzhTcGw2RDVUM2lna1FJQW9KWkNsY2VZZHUxQkszdDIrYUorSm9QLzlrPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvU2Nocm9lZGluZ2VyLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELy9nQnZSbWxzWlNCemIzVnlZMlU2SUdoMGRIQTZMeTlqYjIxdGIyNXpMbmRwYTJsdFpXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9rMXZibUZmVEdsellTeGZZbmxmVEdWdmJtRnlaRzlmWkdGZlZtbHVZMmtzWDJaeWIyMWZRekpTVFVaZmNtVjBiM1ZqYUdWa0xtcHdaLy9iQUVNQUJnUUZCZ1VFQmdZRkJnY0hCZ2dLRUFvS0NRa0tGQTRQREJBWEZCZ1lGeFFXRmhvZEpSOGFHeU1jRmhZZ0xDQWpKaWNwS2lrWkh5MHdMU2d3SlNncEtQL2JBRU1CQndjSENnZ0tFd29LRXlnYUZob29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS1AvQUFCRUlBYjhCTEFNQkVRQUNFUUVERVFIL3hBQWNBQUFDQXdFQkFRRUFBQUFBQUFBQUFBQURCQUlGQmdFQUJ3ai94QUEvRUFBQ0FRTURBZ1FEQndRQkJRQUJBd1VCQWhFQUF5RUVFakVGUVJNaVVXRnhnWkVHTXFHeHdkSHdGQ05DNGZFSEZUTlNZaVFsY3NKRFU0S1Nvdi9FQUJvQkFBTUJBUUVCQUFBQUFBQUFBQUFBQUFFQ0F3QUVCUWIveEFBeEVRQUNBZ0lDQVFNQ0JRTUVBd0VBQUFBQUFRSVJBeUVTTVVFRUlsRVRZUVV5Y1pId2dhR3hJOUhoOFJRelFzSC8yZ0FNQXdFQUFoRURFUUEvQU04MmxMTVZZVEpreHdhNGVUV3pta3VRSWFGaFBsZ2xzQUUrOUQ2bGsxamZSeTNvbVNHWVFPS1Y1ZmdkWS9rNy9RYjdjc3JMTThaZzBZNUcvSXNvSkhidlQ0U1dhVjlHNFB5b3VjbDJ6UWluMGlCME5wVkx3b2lEOGVLVno4aFVHM1JQK2trc3B0a0NZNGlhUDFLU0J3T2Y5dFZyZ0RLVWdHWW5uK0NrZVJNS2cwRGJwZm0zRkp6Z01aeFcrcFJ2cC9CQzcwNFFENFNTUUY0elRLYjhNWGhYWjVkRVFrYk13VDg0b3h5QmNFRnRhRkh0d1VFTUlnbnRTdWFWN0R3dWpxV1d0cE5sWU0rVmxhQjd6OHFXTnlVWFlkeGJyUU50Q2hBOHFFOHNEVkhLU3NWUVFmUzJvdkxJSEJHUGRTSW9jdCs0WlJhNkoyN1ZwRkVCU0NSbVB3cVVWOEROTkVyYTJ3em1JSkJBRWR1OU10TFlOMkRUVDJuTWtIakJpVDhheWkxOXdYWVgrblJOM2t0aUZpUXNINTB5MTBaMndGM1NwdEMrR3Mrc3hSNCtXQzM0QmYwdHNnMjJTUk9BQ2YwckxIYXN6bTdwc0szVFVZQWhRVDNpWXBOUjAramJlMTJCT2dRT0g4TlRIQkhOYm5GcTRzRk5hWklhVmJheXFnTURQQk5MYmQzUTNYUUwrbFJYaExaQUFJQkF4eFdXbG9OdjVJZjBhK0dua0lNNThvb05OK1FuRzBJd2ZEVW1lNjgwL0tTVldMeFYyQ09pa0xLSVBXQkZGTm96U1pOZExDK1VBWkdSMlB6bzgxOGk4SDhFVjBwSkVqY0o5cC9LbTVKN0ZjR2dvMFp3d1JRVDJNejlhWlpOaWZUZEhQNkFsQXpLSkE3SEZENmlhYVQyRndrbmJXaWI2QzJCSVVaeVlGT29yNEV0L0pHMW9FVjUyZ3FleEVVT20waGxiUks1MHl3U1FMVnN6ay9EMXA3ZDBqSlA1QkRwbHBwOHBIY2tFZ245S0NpMis2R2NxWFFXejB0ZGcydHFOMDkyTVVqY3ZER1RwN1FLN3BOUGFlTGw2NWIzU1ZWVzRFOTVQTlZ4dTEyZE1KYU5MZUN5Q2dNUm5GY2JrcXRtcndpTjYyQXlqL0VIRThSU3ltcURHSUpnUEZrS29QcW9ra3gveFN0bVBXc2JXTUhuZzgrLzZWb3lZR2w0T01iYkFRcEpINEgrQ2p5YTM1QlFNSzdJd0M1TWNuMTQvTS9TbDkxRGFzTmJVNElYZEJnVEFuK1RSYjFRRkZYWktmREJMR2VTQ1IybjhlZnhvMkRpUmZ6T3BWNUJKbU0vR21wVUJLaUNydENtQVRPNHlaL25yU0trTTFZSkJ1VUh5THU4MGR4L1Azb0tLTS9nbXNyRVN3Z21EUlFHanlnTTBPcGlPeG84a3pVMFRDb2Z2SUFKaklvcDJDcU9oQjQ2WXdUOEtSU3VSV0twVVF0bmFwTWVYZ1Z1VldDVWJvay9uakVMN0NLS25ZT05ITmdMUkRSRVROVTV2d0p4UWRGVmNFbVk1UGVrYlppSlpSek1Ic2FkU0EwREtMSWdFYnZlaW0xMndVdkIzWVRnQXg4YW5LTmpJaDRXWUtHUGpTZm9NMGVkVkIzS1c1SXhUSjNvSEh5enhVUTJJanZRakp0N1puRmVBWkJNUk9KK0h4cHRkaHFpQURFeUpnMExTNk5YeUUyY2JsTW5OTnpGNEUyUWJRekJoOHFISTNFaUI1VGlULzhBdDVvMiswYml1amwyVC9qNVI3VWI4dGdyNEpXa3R1VkNpZmlPS0xmTFNEVmJZUUlBellCN2Z3VnVUaWJpbWRWQkpoRlBmeWlnc3N1ck04Y1FrSUZDbEI4UU9maFRmVThXRGdqcUlqd05vQlhrUitWYU0zS3JmUUpRU0NNRUJqTzRRYzUrRkhJMjJyTkNLUm5lbzJiTnpVbGpkVlNleHozTk5CNjJXaXRHa3R3ZDRHMHNNbUs1NVBaa2lJVHpiaWU0SUp6ajFGTEZXR1JCclFhNWtFTkJrR1JIOC9TaS9oQ280TGFoUFVFOFlNODUvTDZVaVZJWnV5S2lGVlZNQTRKekVUL3FpdmcxV0RpNFFDY1kyenVuSTlQNTJwdElGV0VZbENaS21TU0pNZmgrdEN6Y1RseFdadkxrRGpGYTNZVGhzRkJrRDFKOVQrbEZKZzBCODMrUjJnbUE1NDQ0aWl0R2FPQlBJbVliMGlNZ2VsQnN5Uk1wNVNTSW5ITVRTdnNKSVd6dVZnZmhSb0JNcVQ5NG40Q3NBN08yQ29BYVJnMXZJOFNOcTJEYVVkK1RtcHRCQ0cxT2Z3bW1oMVFzaUpRbnVlZTFVRm9tdG55NUIrdEJiMFo2T0czSTNZajQwZDlJRkhQTE9EOUtObW80VU1tR2ozb01ORTBYYUI1cDdtc3FUQTAyU0tqdUFEUlFHanpLUER6SUpFREZLTUNObmFKWTVNbkZCYTBnMVo1cmUxbEk3VTNnQjRCanhFOXZha0dvNkVQWmQyS0tUQm85c1lZVlI5WnJLL0FhWGtqNGFoeVl6M05QUXIrQTFtejVUSE9EbW10Q1UyU2UwWkpJQWo0VXNrbU1qd1ZZd3ZhbHFndllUYUpBQ2t3S05BT0N5TTR6K2RDdzBDdVduVGhjUkZhOWpLcUtYcVFtK055QUVDREI1eWE3TWR1T2hkSXZ0TUFDSjRPUm5tdUh2UlJoTHBXVHdUajVaeCt0UDBKMmNSUnZEUDUybnRuK2MwR3ZMQmZoSFdZd0FGek9mUVQyL0tnMisyWkpFRVJIemcvR3RacUpXN1NxTVo3Y2Q2WlVMc21MS2tTUWQzckFtZy9zTWdMcHRZL2ZJOVpFVXQwTlZrU3B6SVlpTWQ2YmxTTlZzamJ0NEVBR2UzcFcwQjJRRm9MR0RnZldsR09zZ0JJQmsvejJwaFNRVEJpUitsWjZBbFlXMGd6SXorbEl1eG1RMmYzbEl4NWhFL0dqZTBGTFFPMHZsa0R0eldpR1NHVVVRRGtIMHJMVEExWlB3eTBudDZpamJZdEk3NFNYUGhUVjVBY3U2WUlrcmsxazI5aHFoZndESllyV2IzVENETnNrNG1LM1ptVEFBa1pGYWhRaXBMZ0dUbmlLS1ZnRE5aeURuODRvU1ZHaUJ1SVNCUGZPUGpRU0d2WU5rVm9JRTRyWG9ORXhiSWs1R00xakhTdURtUndQaldlakxad1d5Uko5ZTlhSm1kdG9KTWdSNzA2Nm9WakhFNC8xVzZGb2k0a1NaNXJVcjJOc2dVenlBQjhzVVpWUUVkVWhUM016aU85Sll6UVMyWkpQbWsrdERvQnk5YmtHZVNKb1dNWnpyWGsxektzQ0FNVjJZNVZGQzhiTkhwYkk4S1RCRWZPdUtDMlBONkkzUWR6QkZqZ1kvTDhhWmlvRzRMTU9ZREdKOXpRWWFETGJKRGJ2VVpGSllhT3BhSXVZeE9jL090QzN0Z2xTNkpmNG9JSk1EOTZ0cENFWTh4Z21TY3hTWGVoNkpyNXNSTVR3SUVlbFo3MFpmSjBXMUxTQ09PWW84VjBhMzJDS2VZN1RQeS9XcHZRM1p3V2NpVmdqSHY3VmswWmtYVGJJUHBSNVVDZ2lJTUZoanRRY3JOUjNaa0t2QjVGYTZEVmdudCtkWkhsa0EwdkxleDZwSHJkb2pKNEk3VlJQc0RYUlB3NU1rZ0NuV3hLb2tiWjJZUHlIZXRLWHdaSTRpZ1RKSmd6UVd1eG52b0prcjNtanlZdkVIYzdxZnU5NkRmZzFBU3VjRG50UVgyTXlTS0NEa0F6VENoMVhiOTBFOXBvMnJvV2pyZ25pUG5RY3Q5aFMwQ3U0aUdFaWx1eGxvRXdBTUFnQUFBU2MwSElaSW1jamIzSTc5L2xSVEJSQWZkeEJFVHpXdTBHcUNvSjhxak1SN1RUSURPQllrRDF4QitIKzZ5WUdHWlRCM1JIWUU0cDIwaFVRUlFFSTgwWlA4L0dsdlF6V3dodEVFQWNkNTcwcmthZ1lXRzV5Um1ENzhlMUp6Mkd0QmtVRUFDRDIvd0IwOFhZR2p6VzJBWnZVZHFMVm1Ub3kzMml0T2VvU3RzTU5neWMrdFhpMVNHaWpVNldQQU16NlJQRmNzWVdxUUpPblpCMUQzR1JWSWpreDJGR1Nma1ZQNENpeXJSQW1EanZTMWJEZEhieXhJa3dLTFZHVEJvWTJ5WVBINFVGS2c4VGhCS0VySm41ZWxCT3cxUkZGWUNNek5Na1k2dTRqdVJIcFc1SnMzR2p5VzVZQVB6MzlhMzJNRlcwZlFEemN4UzZadWpsMjJXQWlRU2Uzd3JjV2xaa3dJM2VHQkdBS1ZvS0poV0t3eDJpc2tqSG1YYng2UlRWYm9IUjI0aEs0Sm5HZjJvVXF2eU4yOUhieHRXYkJhKzZvbkpMSEZJMmlpZzI5R1gxMzJ1MGczTDB5eGMxVHJqYzBvdnk3bXF4VW4zb3ZIMDN5VU91KzFuVkhjcXZnNmVCUGx0N2lCOFNhcEhIRnI1S2ZRakhzcm4rMGZVMlpTZGZkRTRNS2cvU3FyQkg0QTR3bzh2Mm82eGIyRk5XdHhmUzdiVnZ5ZzBmb3grQVBIQjlGaHBQdHpxclovd0R5OUdoWHViVEVmZ2FWK25yOHJFZUZNMFBTZnROMDNxVHFpM3hadnRrVzd2a0pQc2VEVXZwdkd0b2pQRkpib3ZGQW5qSVBFVXRyd1JhYUNoWVQzOTZMYThBb0xzQVVuTWQ0Tkp4cG11d041Y3ljS09EeDNwM1ZXWklIdDh1Sm4xbWthSFJLeUliSU14QngvSm9yUUdlMnFXSk1SK2Y4L1NpcVp1aWFXeEs0bkhwL0kvYXFOQ1dkMmxpNWlEN2ZuUzMyYWd3U0VKamc5cUQyZ3BiSldyVTdoenoyK0ZCZEJaSzViTy9QclBQTlowQkM3SkRBK2FBUDhhbld4d3R0VlpjaklwaFFyQTdHai8xekFxbDZFOG1TKzBGcTZlb0VvanNObzRNVlNNbFJTSnBkQ0ZXd0pCNTU5YVdMNG9uSld5YmpiNVZIbVBlWnBaTyt6SlVlVzcvNmtEdVN4L250UVREUnk1Ykx2aGdSUDgvbnZRa0ZFN1ZwdDV5SjcvdlNmWWNsY3RrS0JuditkQk5yczNZTUlDc0NCbW1UMGJ5U0ZveUFCTUNjSDlhTkFzSlpUYTRNWkF6V28xa2d3QWlsNlJtaUtrWTJpQURtYTMyWVNTSUN6TVZoWmlsazBubzFISHQ3Z01BOXdPS1ZkMEh3ZGEyR2lJbGFxMVFxMlYvVnVvMmVuNlZybDQrYUNFSHFmYXB0dnBkbDhlTnlaOCs2dHF0WDFmVUE2aGltblUrUzBwd0I2bjFOUHFEZGRuWmpoUzBkNlpvRUc5dHNxb3lUVWNtVnZSMFJWQ2VxMHhkblpsbVRYVENkSkVtclpYWGRIQTNSQUdmYzEwUXlXVGNhS25VNmNSaVFSM3Jvak1sSkN6YW05WklEZWRmUTFSd2pMN0NxYmljZTVaMUNSYkRXamt4KzFMeGxEdlpUbEdTMFgvMlorMnVwNlRjVFQ5VU56VTZFWTNqTnkzNmZFZTFSeStrV1QzWTlNakpMcG4xelJhbXhyTk5hMU9sdWk5YXVEY3Jyd1JYRnlhMDFzNTVRY1hUSENvWWtCbUp4R1pyUnBpUFNCR3lKa2oyTTVyT0lVd2JKdGFGbjd1SzFKRzdPMmxCYUIrSGFtQXdwWDcyWjlmZW04YkY4NkRyYlhhZHdtQjJyUzZNdXdYZy8zQVJ4eEZRa3Znb2dtMkF4R2RzY0d0WXlSSlJ0VWlERS93QStWQzI5Qk8zSlpnM0I5WXBoQ1BoN2dTQlA1ME93bk5zSUFlK01VNjJLdzd3RU1DWUhwUWxLdEFTc29lcWFhMjJvRE9SSlh2OEFFaXJRVnF3Mnh6UlhJMDZqelR1SkpQSnBWMEY5amRtMEg4cEhQb0p6NjFxc1RvTSttRE50QklYR08wVVBza0g3blRhVUV3b09QMTcwamxzWkxSMHA0WXdKT1FjWnJOVVpPemppVnlQam1uVWZrRi9CeGg1VjJyTEx6N0NrYlhnS1h5ZVVUNzgwYlFhQ0twTHhHTytLemtDandTQ1NPTVVMRFFBckJIdldhTUdLcWNIQUJwRkZkczM2SFFoYUNXd0JpbVVVWnNGcUh0YVhTWEwxODdiYUx1WnZXbVlZUmJkSStXYS9XMytyOVNlNjZrZ3l0cEJuYVBZVm1sRldlakNDU291ZW4vWi9xR3BncHB5cXRqejRybXlab0tSYUswWDluN0ozeFlhMldDM0dFeU9PK0s1WG0zZERGWHJQc3ByUXpGWHROTWtuSUZXajZxUFZBb3ozVk9nNjdUcWJodEJ4d2RwbXVySDZtRDhpT0RNeHE3YklTSFFxZmNjVjN3YWZUSXlWZGxUcWxhU2VlODEwd0l5UWpxRkF1WU05NUE0cXlSTmtDVmRDcndHL09qeHJvYTdXelVmOVAvdFUvUXRiL1M2dDIvN2JmSm1mL3dDazB4dUh0Ni9XdWYxWHB1YStwRHRmM0UvTXVMUHVWdDBGcEdHUy9BR1FjODE1TVBjMlJrcVBRV255amR0cW5iRUFyWWJKUGw5ZTlhbWcyY1pBSTRBOXUxQ3RCc0lnSWtFQXlhZndLSFVFOG5FY1VyN0NFdFd5eWlUU09xcEJYZG5icXFDVVhqMGp0VTJxNktJaGRRS2g3QUNTWStsSG94RW9RWUlNOEgxbXRlNkJYa2piQUc3MTdHdEF6UEt1VlBxY0duWFlHaGgxQVVuMEJ3TzlHU1RzVkZSclQvY1ViWmhlWmp1YTZNYTlvSCtwTFNLUlpCRGJ2L3JuM3FDMHRsSHNiczcwMnNjeGpHSk5CdmRJVjBPSzRhRlViZG95T2FiU0ZXeml6QllBRmU0aWhGWHNMMFR1QU9JVVRIYzByZmo0Q2tETmxpTXRnOTZDa3cwUjJZQXlTVDI3MGozME1naTJodUFNVDM3MGRJd1dJSmlUajFvdVhoZ29DeUNZR1Rqdlcwd25oYUJVRnBIdlFjcU5RVzJnT0NlQ1kvQ2d2Y3dkSGJ2bFFRUU1TYTZZYUVlejUvOEE5UU9yTTR0OU9zT0pKRFhJOWY4QUVSK1Awb0wzU2JmU096MCtPbHlMcjdHZERhenByYnBiVVhYRXRjdURKK1EvZXZLOVRtNXpvNzR4U1I5RjBuVFdWRkRYSkxDUnNVQWNWenlZeUcyMEtzV1h6WkVnN29NNC93QjFKTUlqcmVuV3p1UG0rSVB3b2NtR2pPZFQ2WkZzeGNhUk1BMVNNZ0h6YnIvU1FHWThUMkltdlQ5UG5vU1ViTU4xUFRGSEs0UGZIRmV2aHlKN09XY0tLTFZBSVNUTWR6WGJCMlFrZ0JJWU51NGlNQUQ2VTRvSndJS25JOWFlMTJLL2crdi9BUFNQN1EzTmIwKzUwblZ2dnZhVWYyMk9TYmZwOHZ5UHRYaitxd3JIazVMcC93Q1RaRnlYSStrQUJRQ3ZJKzlVSTJ0czUyZXdwTE1NZHFMMEJIUmIzSGR3Um1rYUhUSktzbk03Z2M0b2N2QnFKaEF1U2M1cG03V2dVZExIekFESEFwS0hQTmJKVVNNKzlha1k0MXRvQmt5RDZVZUpyQU11MjZRQWUrMGQ2elZCUjIyQ2R4T0RPSnBZZVF0RXJTZVpGQWlESFB6b1h2Um1HanluZHh0bW1lMDJMNUticUFDM0VnNEtUeVBVMTFlblQ0SVdWV09kTThPN0hoLzVMSXp4WE03cGpON0cvQURQdVV3eWdBRHNQZXRHK2haVjJlMU5sazFHd0taTUdRTURFVUlLNDJ3dlRvbFp0c3NwZGVTQkFOYU9tN04zUTFhc2phZHgzRDRkL3dDQ2pGY3YwTTlIVnNqY1JzSHRXYW95SUcwMlR6NkFZaWsydXhrZU5vcTY3d04yYXowRkh0dm5BZ21mbFdYdVpucEhyS3k1QmdkdlduUytSV3dkd0FvcEdEd1BwU3RJS0NXbEVob3hWSVJUZHNXVGFWSXJ1dGFvYUhSUGNBTHVmS2lUbDI5UGI0MDhxWDJHaEJ5WjhaNkc5M3FmMnBOM1dYQzE3ZXpIMEdZZ0QwRlZ6MWp3KzA5R0M5MUgzMzdOallpOEF4anQycjV5WFowbW1CQUhtSkJBQTQ5eFNXR2lZZmRpWkl4OGFtbFNDQ3ZrRVFja25OYjdHS1BxSGhBT1NPZU0wVUF3bjJndDcySlFmdlhUaGRNelBuZldOSndZUE5lemdtUW1qSmF1MU55RElFd2NjVjZVSG81MnQ3S3k5YkNraENDQm1hNm90dGJJeVZkQVhIK0JNVDNGVSs1UHhSWS9acnE3OUc2N290Y2s3TGJqeFYvOWw0WWZTYWhueGZVeHVJVnZYeWZwTTNVTmx5N3J0Z1I2SFBQMHJ4WGNsYUlkTWlsemZjVUFHREhIYk1VVTlHYTJNaGt0aHBKQlVjRTBqbFRHb05ZWU1TRmJjOHhpczM1WnE4STZ6b1VFWjVCanRGR3UwZ0prRmtuMDd6NlVQR3hxK0JtM0RLUWNuc1k5cUYydzFSSnJaMkVpSmt4VE4wRHNYZTF1Y2JTRFA0aXB0aklFMXZtVkIvRDFwUmp0bGR6NUptT3hqNjBWdGdZMjF1YkxBUVlIRldUMFRhTTkxVml0MnpJVWsyNU10SCtScStHVFVOR2NiWXQ5bnRiYUZvQ2RveGtpSndQOVZKeDB3UzFKSXZOTmVGMjk0ZHRvUEp4bWcvYW0wQmJaM1Y2Z0ZRN2xtSTJtRlA1VXNVMmhucGltazFZZlgyOXZuRG1SSE5LbzBxWVgzYUxsV0paa3dTREl6VkZWV0RZZTJoMkhjU0JrZW5mK2ZXbGswWklpTHRscmd0bGlXSEk0bjFpcHlrdXhsOEJMeWt1Qkp6M3JCb1N1S1E4N1QzK2YxTkdNVldqTnQ5aGJBVXFHSDNjVEZOM3BDdjdnMVJtTnNCZUQ4LzhBbXBzWkI3ZG9KYXlkb0FrazBiYVdqVnMrWS9iWHI3cmRVMlQvQUhMMHJiQjR0MngzK0pQOHhWSVIrcTk5STdNT091eksvWUhUZjFIVkxycWR4UWdtWXlTWnEzNGcrTUVpMkxiWjk1NkxDTGJkbDdTYThCcnlYTGEzdWRHVU1Xa3dDREhQL0ZUcHJZeE1GcmJTc3dSRTgvemlsV3dzamMzUTBTSUhNMDNGSmFGc290ZWpzM21CSU9QbVIvdXRGYTBZbzlmcEd1QVl4QUpQcFZFMGpHWDZwMG5ma3FZSEZkZUxMeFlra2ZPdnRQcEYwNU93SDFOZTE2V2ZMczU4aW95NzJ5RjN6SUk0bnRYb3ArRG1yeUF1TGdrVEhxT0JWQ2IwQlZTV0s1TzZqUXZrKzEvWmZyRjdYL1pqUTNEZGJjbG9XeTJNYk1iajlCWGtaSUxITnhJNUxiMGFXM3JGYTFhQzc5ektHbGlSaU81K2xja1hWMk80M1ZFeHF4ZDFBZWR6Y24wSHRSakYxdm9FNVYwV3FYZkEwN1hXYVlXWUhyV2F0MExkS3lYamVCcGJHNEF2Z0gySjVvT1BLV2pSZkdJMkpQRUVIZ1IzaWs1VWkxRFBoc3lFRTlwK2RCZkppZHJ5aURJUEZhN0EwUWJ5M0FUeEJKTkkyTXVnTnhHaVNERTkrS3lDRHRQTjFSeE9NZDgxUkt0c1Z2d09PQjRLd1JCYmEzWWo0VVcyK2hWOXpPZFZ1bEw2S0Yzd24zZ0I2bjFycndXNGFSblZtYzZUcmhxZE9XMHppMXNHMExjZ3RuMnBKeDRlMW03ZGoyczFuaFh2djd3RWhtbkpNOFk5ZlN0QldpVWxzam9OV0wxaGhmWXRjRWxmTndEMjlxWEltdElyRkx0bmhjT21kTHR2eENCQmc4Z2V0S2x5YlQ3QzlMUm9OUDFTVXR1TmhJTzBrbmJ1OWYzcEdrclNNay9JVzkxQnI5dUxiQllHOFR5eHppbzAwOWxPMW9WT3Y4TmdUZzVZRUgzaVBwVFJoWWszUlo2ZnExaittdHZmZFJlTGJRZ2FTUjYvblZJd2JscGFGNXBMZlpZV2RsOEs0S3NDSmtlL0ZPcVhqWnV3OXEwcTQ1Mm5PZUtUWVNWaFJ0VGFBQVRQNTFOcW1OMkkvYUJ4cGVtNmhoSmxBTjN1MlAxcEl0Mk9sYlBoSDJ2dkZ1dVpZZUdiUTJFZlA4Y1Y2WHBvTGgvVTdJT2tXSC9TbFQvWDZwVk9UdElIcUl6VS93QVZWcUxEZzFaOXEwcmFlMVpVc0FERWlSRmVGSnVxT2hiSDlKcWJUZjhBamFZakV6NzFOdXREVU4yMzNMeUpqbitmUDYwcWZ3WXFlcGRaMG1tSkR2dWFlQWFLaktYUnFFQjFheGVVa0JBTWNtblVHZ01YMWVyc21HRDJ3ZUltakdMTVVQVk5mYUlZU0lyb2hEWWpaOHYrMXJoN3JzQml2WTlLcUk1T2pHWDBpSWpiNlY3RWVqamFZQkFTN0xHR0hBOXFkclZpV1JaSVpRQk9TS0NBMGI3N0M2Z0Q3TnZiZjdxYWhrSUhvUUNCOVpyZzlWSC9BRkxKVDhHazBHby9xTEpXV2tFaGZTTWY3cmtsRGlDN0xmU1czc01yTVNRWm1lWmorZlNsVlMxWUpNc0xPc2U3cVVSNFZVSW1Qdy9TdHhTVi9KTnl0MFMxV3JZK0FuZTRHWVpqdkEvV3RHSG40QnkxUm90SHFMTGhVM0R4QU1qMEZjczZYWjFSZGo0YnltWWswclkxSGxVRVp3cFBjWXFmTlhRZUlid2ZEYnhMaWlBSk1tUHJSbjFhTXV5czFGOGhIa3pudWVhMFZyUVpGZnByODMwN2oxSFlDYTZvTFZFWk1ucWVyN05IaElPK0FEN0Q4YW9zUk41REs5VjExNjdmUjJVQWxQOEFJKzVycnd4U2hRYnRtSDZLN20rV21Bdm1IcVJHYXJranBsTldhSmJ0eTdaRUhiYkI0UGVUVUZGTHZzaTlqZlRmTmRJT05zc2N3Q2UwMGsxVzBQRjYyT1c3d053YlZMTVpJSXdCL1AycVRpLzBROWpOMjZMUWxDcHVSeWZqeFNLTjloYkZiV3FlZDZuY29KSW9TV3FHU0IvMTVXOFRzNE1jNDQvNXA0d3BJbkxiQ2FiVVhMMnFWbVZaZTVnQWNDS1oybzBqS0Nic3NyUFVMM1RyZ3VvMy9qS2phVE9QZjVVbVBIemRBbkxqRTNSRG00NnFCZ2puNCt0U2pIbHNadXRIQmNBdEVnbmRKRUFkcTNEVEhVdEdWKzJlc1lkTkozTVZXNGg5WUV4UDQwK09DclFJdTVIeC9yaHRYN3MzR01xeEM5ekgvUDUxMjRyajBkMEk4azdIZnN2cW42YnJOVmVzZ0ZsZ0VSUGVrOVZENmtVbVBEMnRteXQ5Y2JWYWRyMnUxMTJ5Rjh6VzlOcHplWlY5V0pJQy9DdkxsZzR1b3EvMWRGMDc3SmRENjdiWFZlTDA3VzN0UUYvOGx1OWEyTkhjZ1RCK1ZMbXdOS3BxZ3hkOUgwRFhhcHJlZ2JWSXg4TmwzQStvNXJ6SVJ1WEVkbnluVWFqVjlRNmlXRDdVYno3MndBQ2E5aFJoamdTdHRsbnJyblR1bGFWRzFaNnhkRnlkdHkyZ1JDUkhHN2tWREdzbVdWUjRqT2t0bWQxblVuMjc5QnE3d1gvKzNxVkFiNUVZTmRrTVBpYS9ZbTM4QXVtdHI5ZnFOb1ZtV01zQmlteUxIalFGYkV2dExvN2lXMkZ3NTc0cW5wcHB2UUpyUmluU1F3RXJFQ2R0ZXpGbkcxWXE4cXdNOGNtT0tyVm9pOUhwSVlFbmd6a1VLc05tbit5UmQ5TnJkUHVBQXVKZENuaklJUDZWeStvcE5NbGtUMGFhM2Y4QUNWSk96WUk4aGtqMXJsY0xJOWRGcDArKzV0WExkeG1PSkRISlE5L2ppbGNVbmFGYjFzZnRYQy9pYkdWNUFnOS9qUnFoSHZvQzNVeGQxdGpjRnRXN1IyK3BJQS9XdDlLb3VncHEwYWZwRjdkckxXMHlHd2NjbmFmM3JneXg0eGJaMVFlMGthaTBvVkN6TE05NjU0dXlyQ29TbDhnZ2tZZ0VmalNSamJlaG05QkwycFZWaGdHazhrOXFweGY5QmJLYlZYYmJXN2hHM2MwWkhwN1VZZDBqVFdySy9VWEFoTnUycFZpZ3pQcWE2Y0t2YklaWFNwQTMwbmhkUFcvY0liZC9qSHFLdXBYN1VKWGtvZXBXRWU1YVo5bTQyeDk1Z081OVRYWGcxQkJhZHMrZjlMQjMrSElnbkpPSTRxbVJvcXpWYWFFdVd0czdTVDdqNG11YVcxUkw3amRsSjA3dGRPR0xHRk16L0RTN3VrWnRCZElTeEdTbmxCRUgxaXB5U1QyRlN2b0M1Q1hHRFhJZzdjampPQlMzcEpJb3ZrbFlWV3RtR2xZTE1PTy81VUpOOWhSV1dOUTk4c3BWVnRidHdIRWZPcnFLaXJ2Wk52WS9vdFNxWFV1RmdBaE1qaitDb1RYMktSZERtbTFGaTUxdTZtdmg5S2xwcnJxcGlZVVFKK05CY2xCY05PeEdrKy9nMXVzNjhtbnMrT0dEYmtETEJrUkhOUVZ0OFlsVkhWc3pkbjdSNnJUbzZYcmhheXlidy9kV0FPQjdaSDBycGhqVEp6YjZHdnRKckxZNlk2MnlwdlhyWUZzZHNnU3g5aFAxaXB3OEZJSzJmRzlZOEcrU1BPV2dtZU04L2xYb1IyMGVsU1VkRzEvNlNhZGRkcU9vRmx0M0J0UkNyWjVtdlA4QXhUSnc0cjlRNFk5cytrMitqcG8rbDNkS2VtZVBadUxEaTFBM1RYa1N6YzVLVmxrcUsvby9RVVM0YnFkTXRhUlVIbExNV0k5OG5tdFBNNWFjckNhSHJpcVBzd0xTZ2VSTnVSRlJ4T3NsbWFNbDltZEVVdmdKWlJqRWdNSnlPSzZ2VVRVa0t0R2s2eHAvKzUyMXQ2enBqYWpZZDZsUWZMMnhuaXVTRXVEdU1xSHNxRSt6bHg3aGpwYWFlMU1rM0JsdjFybyt2UzNLeGF0bHJmMDl2U2FVamJiUndPRlVDS2twWEt3dEh5ZjdjWFVWN2dFWnIyUFJLeUdUbyticzhNL0JuSFBGZTlGYU9KdWhlK2ZPVzVNSEVZNC81cTZJeWV0a2g1d1ZCRXhnMU82WWF0RjM5bEx5SnF0VWwwWmEwSWd4QkRDWit0UjlSMG1pZVJXYU8xZHR1c0twSlU1eGlLNXBQUnorU3owZHFUS3M2Z0Q3cW1zNXJ3aEhIUVlPMXU0eFZtVmdJa2lKb1hlelZSSzJiZjhBVXNHQXhHZUpGWnQxc0M3TDNvdDhXYjl3T1ZpUTZtWm1ZQnJteXBTMFdpNlBvVnE2ajJneElLak9PRDZWd0tOZG5UZDlFV3VwOTcxOU9hYlNCc0JmdUkwcmJJWStzMW5UVklaZmNTMUVzcFZnRkpQUGFweFRpNkMzYUtsM1k2cG1KTUtNQ2VmU3UzRXEwem55YjJPWG44WHA0VlNJaWM5b0hlbmFwaXhabnVwN2k5blplMmYyOGd4bnpObk5kL3A0M0F6blRyc3gvUnVudmN0K01pRW8yUVdJQXhnL2pVOG1WSjhXVmtpeExibjJ2ZHREQjJoYm9Zbi9BSFNOcnVqUlNxbUVOeHJhaTAxNjJwSGFaQVB2QXBrOVdRY1JqZENsMHZLVGdlVXpTU1ZhYUJHeFM1cWR0eGtnT3luQk00UDY4MU54dmE2TFJ0SUZyVGNzZ01wWTNXRGJvNDIvOFZvZGhmUkhUbFNHRnZLQ0FZT00rdE0rOWl0NkZycnhkdzhLQmtkcWRJRmtybDV6cVFiYmJXWk5oenp4L3FoeDFzWkRLNjYvYzBzRlpzd0VRbk1BZHZ6cVgwVnl1OWxsTDIwUzZwcUdObXpiR0JzQUdLT0ZiYkZtbHBITlJyaGNkTFQzUW9TM2FRWndNU2VQY242VUhHbm9waS9MWmllcURmcTlSY3N1TnJOZ0hCUCtxNnNicEpNN09MNG0xLzZNYXM2ZnFPdXNpTjdCU1BsWG1makVlU2pMOVMyRFZvKzU2SjJlMnZpY0FTUjZqRmVJaXpSelVBTXFvb0Q0RXh4V2pGTURZcDEyMnFhQzJBUkJPNGdmeitUUnh4OXdHeW82S29XK3UySm1DQUtwbGpab214czNnV0JBaFRBNGo2L1d1Vktsc2RvVjF0OVFMaE8wRVR4TmFtRXcvWGRjRkREZEhzRFhYaGhZc25SOGkrMStwYTVjWVNUbmowcjNmUnhvNWNyTWR0TVNDSk9DZlNLOWRNNG1qcHQvM0VCSmtFUlBGT3BhRWNiQTJWZ2dUa2tjaU9mWDVWbUJNdWZzeGF1YWo3UTIxdEtXYTlhZmdqa0NUejhLam1hVU4rQlpxemNqcG1vWGNMZGdpSTV1TFBQeHJoZVNMWFpIaTA3WXpwdEhyMEEvL0dJSkgrSUJ6OWFYbkYrVFNnenphWHFUZmZzM1NvN2JZeFZlVWZESThXQU9rMXd1RWVFUmJQRzVTWXpSYmhYWmtONkFhaTFkM01yYlRCSU5zL3RVMjE4aFRvMi9TT3JXMjA2cGNSdktBSml1TExpZmd2am44bGgvV0kxc2huRzJlRCtOUlVXdEZtMHdUYW15RzNlSWk1L3lQRTBydDZHUzFZTFU2dTJTUnZXQkVaazFWVkppVTBoTkxpS2QwQnkzYzlxdXJFb1gxVjFUYVVFbURPQmdjWUh6cWxPaEYySWRTYTAxNjJZY2YyeGhUOGE3c0V2WUpLT3pKNkJqYTZaZEZzQ1FBdTdHU1JKRTg5NHFFMTc3WjB2Ym9xZFF1M1VLb0JCOHF0SHFCblAxcXkyckZMTldCdEt6RUVSazh3ZlgvbWtSTHBuYkFVWHlnSUQ3ZHhXZWM5djJvTjJGSlVGRElMelNTQTBSbjlLbTB4a09YRGF1aDJERFkyR0I1SHlwRzNWR2l0aXR5eHVzdW0wcm43b1B0VFhUc1ZiRTdsdGc4V2pCVWlmcFRwL0p1a2V0Mm1BVzQwaE53WEF6TVZuSlBUR1M4ZzJRcTBnbkhsMjhZbjFvS1dxSDhBcnR4OTIwZVlnQUFnY0NQYW1pdEc4bGJmMURRNnNOb1ppY0VIMEE5NmZqNUxZL0FqZXVNQTl6REtNQXgzZ0g4SW9KSnVqdnB4amFMYi9wNXJqWSswNnVUdE54WStOUS9FY2Q0ZjBCaGw3Mmo5RTlQMVl2MkVZT1ZFY1R6WHpUalIxTTVlMUliVjJyU21OODRQY3hRajhzRFFQN1RYN2Vuc0xOMVZnUkxHTzNwVkllNTZGTS93QkgxZHYvQUxyWXNqVUtSZEpBQytzVFZKeGZHNk11eldXeWJaRzRuQTVNZnoxcm1wV09WWFV0YnNSeHVFeE5OQ0lHejU5MS9XN21iSTc0cjBNT01tMmZOUHRBN1BmZi93QmhYc2VuVkhOa2RsSVFQTXdYeWlZazEzcjRPWjY3T3NRRkJERXdRU1RUSytoYVZXS2xUNFpZQW1SSU05b3FoS3g3UXViV3JzMzFZU2poaWU4RUdUVWNpdlFYdUpyVTZocWJsclpkZTR5b1FPUzRBeEhmNDF5dUVWc2hUZmt0ZEwxM1V3RnUrR2UrNHJIK3FSNGsrak5PaDIzMWkvdUlGcTJSSUJrazVuaXNzU0pPMEd0ZGZ1aGttemIyay9kR0tMeEppS3gvVDlmdHVvbEd0TVJ4TWpuc2FtOEREelphcjFOVlVOY1ZzREF4NkdvZlNzcXB0ZGttNnRZYmhRelJCVXgvT0tWNGZJNnkzb1FicXJYV2NDMmx0Vmt6SDVIMXAzaFVLczBjcmxaWFd1c1hCZkN1aTNFQWttY3g2L2pWSllGK2dZemJMTzUxZlJXTGFrT0daNU1iUlB6cWE5UEp2WUhsWWhxT3RiOUl1eTByTmdiMlVRUGwzcXYwUHVhT1IrU3Z1NnE4aitWeTRJbmNDSVBiOUs3Y0tTaWtqWGIyWjIzcVV0ZE9ieEhrRjVWQVlKSGFQbkZUbEc1MVJWL0lGbWU1ZnUzR0FLcUpnZHhuMC9PaWtra2tLblk5MHB5UXlQREV6Y2I0eng5SU5KTFFzbGV4Z1paN3FEc1BjZmpTZGFGVDJGdUVJcVpoZ3NrZmxqOXFUc3BRSzk1ZHhTSUt6ejNyTFlaS2h6VDNXdklXdWtBbG9PUjZWbXVQUk1XRGczTHUxY2JvRURqbjk2S1FXZ2F3YmdVdE9aQUVaejcwV05GRUdHMW1Fc0RQRzNkOVNLSGdZV3Y3blpwRWljQXlSNzA4V2tMdXltMUxKYXZPTm9hQjVRQkV3Q0ovR3FVMld4dld4Qy9JdTdSRFdvenRQZjIrVVV5bzYxSnRCZWszRHArcWFTOUpBVmxYM2lBS1gxRWVXTm9NSFVrejduMFhYM0UwdHNOT1JYek9TQ08wMVEwdWo2bG8wVzhDcktkNk9oaHJiZGlEK2xjY1hLTXJDejVuOXRkTDFkK29YTlBmdS8xQ0lCdHVXd1Z4N2pzZWE5WDBzc1ZXaWNyTy9aRHBON1NkUnNhelUzVEZreUZKbUtQcWNxbkZ4U0ZpcU45cWVzVzdoOE5HRSszZXZPK20xdGxMS1RxOTUyUmllSTRxMElwQ3RtTDZzdS9jWlB5OUs3c1FqTUgxZjc3Zzhudit0ZW5oT2ZJVXpEZE1uZ1ovT3UxTTUyaVYwTVFBc2dFbmd4aitSVkV4R2dGMGVVNFVBU1BRWmltaTdKTlVNYVdJaVNSNFVENGdFVW1RZVB3YVBUMkxodHN3WlJ2VlNaNzRGY3JrbVFkeDBPRkxnVGNZL3dBVEtzSTQ3REZiVEZiYUMyaGNYSWRHZy9kTTVrK240VWJFWjBQYzNBQWhCeVJ1N1JRTlF5THFCeGx0b01HREJPYUQ2TWxzT2VwT2JqTXBZS1RoZU1kcVJRMGtGOTJIc2F4MnVNR1VqSk80L3dBK1AwclBINUZVcWREU3RjWFNPaklBWTNHVkdSTXhQYmlsYVhKTVpkVWhMVXF3VlFDRkoyNEdaNUlwNHROMk5Ub0hldHRhS3VTTi93QjRBZm1hMTJHZzFwMFhUQldNZ3dCM0U0bjUwRTJGeCtCdlVhVTNVc05ic0k4MnhKWnRwQms5cHE4RzZHU1JpdEpwdk5aVmpMZWgrdjYwTWsreDBobGlpRzRzZ200TmdFbjFOQlhvQlo2QzJMWUROTzRxYzlzZ1JVMjdCTG9JUWtnSzA3WkoyNUpwTmlxSnlHdU51dU15aVFETkMwdWlxVFlWa1M3dWFSdG1ENng4YVdPbFFKVzJCTjJ4YXR4dVgxd1A1NjFUYkVvaDRpdXk1VThlVTUvNHJiRzBTYTY5b2lGWXFHa21UQjUrVkRzWmZJRzQ0STNiNEo3enRQNlVObTBCWkRjKy9PT1RIdjhBaFRwMEpkQ1hVTFJ1M0dMRHpiQmdDT1p6NlUwWFJiRjhsY1FxbzF6QUF6a1RKaWYxb3pkNk83R3VLc1V1T3JJN3FRUC9BRkE3ZnlLcWw0Rm05MmZZdnNQMUd6MUhwZHZjd0xLb1ZoM3I1ejFlSjQ4alIxd2x5alpyTkowdnFHKy9xTkoxWnRQYmdlWHdnNFA3Vnd1Y1hweHNaZGkzV05KMU85YUEvcjlBK0paOHFUOFFSK3RISE9FWDB4MnJSbUgwdlVtdStGL1cyazNkMVdhN1ZQSFYwU2FaZjlINmVtanRBWEx6MzdtUzExNEJQd0E0cm5uTnpkOUcwZ2ZWNzF0VWdIQW93VEZaaHVxNmpGdzdpVGdWNkdLSWttWWpxVGIzWW1ZbjA3VjZXTFJ6ektzTERGY0V0eE5kZmdnenR4SWphWVVkKzgvejlLWlA1RmErQlYyRzVpR21janl4L08xVWlUZXgzVEtFY0FNUXV6Z2p2dXBKdTBHSnBPbUFQb2h1a09CQkhxWUg4L1N1V2IyUmt0c3NWRnU0eEZ2WUFJRUt1M0lIeHp4NjBpZE1XUzFza0xaVlpkV21CZ1krT2FleEc5blV0QVhGWXFWSmFTQmpQenJOR1VnbHEwQnMzVGdFZVVVdE16WXpZdDIvRUczeXFRSnhOWVI5RDFzMjBIQlpwbkk3MU9VVzJPcEpFTlJxRmNGUzZnbklSU1NUV2pINUd0dm9RMUYyNWRZS2pCUnQyd08vcEo3ejdWU0tvUGJvR2lLdmh4ZE4xdVNaOTZ6dG9kYTBPYWE0UmFIaG9RaHhJWHpDVG5QdWFLUUwyRTFscTRMaVFGY2JCa25QRldqMEJHUTA5OWxLRjhrR0ZiMGdmdFNaSTJ0Rlk2ZXhncHZ1TGVNQTI0WWllQi9EVStiV2pPSlppNFdGb3RKREFyTEFtTWdUOGVmcFFhTWlmaDNDRjhPQXhPNldYYmpnY1ordEpmeUVJVGZWZ2R3SWpCRS90U3FnZ0RjdU51bVg3N2VWQjk4VWVqVVFUZVhqTUFUQ0NQMG82OGl0ZkI3d2x1Skk1a1JQSDVVMmhYWVpkSmNCVHlGZDBzTWlENkVjVm02N0Y1V0VYVDNReFVJVzc1Ny9BRXBMUmt3bHV4ZTJwdFM0REl6dC9rMEcxc2JzcitwNmU4bXNZRWVWZ3JGb2lNSC9BSFdVbFIwWWxhTTNydkV0M0NJREE0anRYVEdwS3pwVXRVaE8yc2hBeGhUd1NQbG1udW1aNzBXZlFPclgramFzT2ovMm1JM3FEK05ROVJnV2VPK3d3bjlOMGZjZnNoMXExMWJSZzJyZ014S2s1Qm5pdm1zK0o0NVZKSFluYXRGeHIvc25aMWwzeGZGWUU5aE1WR09lVU5JTldVbW82UGEwVzlROHNJNDcxZFpYSVdoTnJvc0FrdEdPS1pLd0dhNngxUXNTQXd6ek5kV0xFSTJaalUzeTR1RmpPTUd1M0hHaWNqTmExOTd3dm1pdTNFbjJRbXhUY1YzUU8wWk1HZlg4cTZTVEJ1V0JJVWtRWno2VXlFZTlBR1V5TWdZSGVhYUxFYW9zTk9IOFljTkNuMnlKNStsSkxvWkxack9pcUxsbGl0c200U3UyZm5tdUdicDFZdVZVN0dyYVhCZFpYQXl2QkpNRHR6V2JWRWxzYnRhY2tRR0FJa3lKaVA0UFNzOG5IWW5HOUhMcXNnYnd5STNoRjlXeGs1R0swY2picWpPSUZManlBd0U4WWlPT3hxbmV4WHJRVGU2eUR1QjdqRThla1VkZzBDdlhMekVLZDJSaVp6K3NVR0ZKSTdaUmdwa3llSjRuMm9XbU05RGVuc3MxM2JjemdBQ1JnVFRJVWhlQUgzaVN4TVI2MHU3S2FEV3JnV3g5M3NEakE1OXFMc1d0Z3RZOTVyMkwrbXRiVkFLM0xtMDhlbnBYUmkzR3htakhMNTdkc0hrRW44cXpWRmJMQ3o1N0txeGxuZFZqaWV4TmMwdE93MlN0Mjd6QWdONUliNW52Qjl1YVBOYUZDOU5lN2N1aTNkaGlrbmVNOWhJSjc4aWhKS3JBeTFjazhURGs3WkdDSjdmT2s2TW14TVdkckxKQk14SlB2M0g3Vm05REtXeUNNUTZyNW1FVG5pUjdVYU5aSkozd0JIY21JSWo4aEIvR2dDdzdQZERXOXI5OGJ3SkI3eG5pbVhRdWhtMVoxSCtMb0ZKd2Q0SWlmYWxhaUJzYnQ2UFdtR1M3dHlaZ0gxNzBqYVFVeEg3UTJMdGg3RjY2eWtNakljUmtjRDhUOUtFTmw4VSswWksrUVZGeDl2bDh4SDgrTmRLK0VkY1ZxeFlYVjNJSEVDTnZ1ZTVOYmkvQlRtbnRpNXVxMTlqR1RKMi9LcXFMU29oT1Nic3V2c3oxelVkSDZnbC9Uc2Rzd3k5aUs1ZlVlbVdlTlBzZkhsNFA3SDJqUWZiN1NhalJCL0ZDdkdWUHBYejJUME9TRXFhT3hUakpXaW82bDlxTEZ3c1VKWmpnRWV0Vmg2YVhrVnlSbE5mMWE5ZWNxWkNqQWcxMlJ3S0luT3lvMU40QTdyakQyRXpOWGpINEVjcTdLeS9xbXZZVmZLQWVPYTZZWStPMlNsTzlJcnRSWlpDeGNkb2orZktyUmxla1RmeXhRaHpjUGFSRThWVk5DSGtFcXF2SXdUdUdKeDNwdWhRSmdPdmwzQmNrUjZVOFJKTVl0a2gwMjVrSG5pbGt0R1QyYVhvRjJibCtBeDhOZ1FKeHdaSnJtbkVubWtYUnYyMVNkNm1lRkdSMy9IaXBOTnZRa1IxZFlIdEJJWVpDNE1BbVBXbCtpQjVld0dwTnU1NFlra1l3Umo0MDBZMTJJNTI5RUxwUVdpNUptNDNyQngvQmltVGEwTlZraGRXMlFQRUZ2ZDJHZTN3NXB1YmEwVGVOMkN2M0wxdVNwVUFpWlVrY251YTEzMk1vdEJkTXpzUjVqNGd5RE13STlUUXRHcGhyR211M0d1YmZ2RGtrajZVMS9KckEzYkYxQ3F0dEh3QllmbFJUVFF5R0xJS1dVZ0VNUkozQUxTUG9wcXl2MU9tRGFpNTQ5K0hCL3dBVWtFUlhSamw3VVo5bWFzQUNCa3dTUlBCelRTSExDeGNWR0VtZHAzRUE0QW4vQUpybWxGc0ZrZFRxSGJVMmJWdTRGUkJ0RUNPWm10anhxbTVDTjcwTUhUbFBEWkxvUkxnM05ubnZBSHlvWFpSYVJhV3dMcWlDRktwQWJmRTUvd0JVaVZ1Z04wck9uVG5helBlUWMvZVlSK0ZQeEo4d2FkUEQ1VndSSU9KOVBhdFRNNWhsMFZoRUFhNndqQThwNy9sUXFRT1ExNEduYThuaDNyaXVpcXJCVEU4d1lBTVVzWXVLb0xueTJPMittV2hMaTdmTGs0SEUvaFN5Y2s2ZlFGVFd1eHBFV3hhQ2gzNWphV01ta2F2YkNyOEZiOXBiU2FqcDl6elM2RU9NY1FjeFB0TkdGcDNaVEc2YU1Ccjl5WHlMYkRZVk9EOGE2b0sxYk8xU3JRZ1ZVRXM2eXlpSjRQTk03NlE2YTdCUFpKSWRURENuVWliUVN6dUd3cWNTQ2ZXbEZMTHBmaTN0VGF0SzBlSVFwQTUvazFMSzBvdHZ3TkQ4Mmk4dmRQMXRnbFhKTWUyZVRYSEhMQ1JkcVNFcnlYMUNvMkRPYXF1SWxzV09tZG1pSk16azAvMUVrTHhzUGEwcExXd29KSm5BK0JwSGtEeE90MDFuQWE0U09jY1V2MWE2TnhLWHFOb1dtOG80L0d1bkhPK3hKUitCRmpzVm9JSzlqMkpGZEs3SlBvRUJKdHl5NE9Sem4rUlRKa21nMlZGdHB4eG50eCs5RHV3bHgwRTMvRWNMTEtmTVFJeWZYTkprYW9oa1ZPMmFEdzdsMEJybmhnS1lnaUlqNFZ5OGtMZGFHYmZsSTIzV21jbllCbjJ6VE1SN0pYN0lLcTF5NjczQ0JBZzRnODBpeWJHNDEyS3NubVFNbkpQSW4weGs4VTZkOURMN25WdW9HRGdzdDVaQ2puSHFUNm1jMXE4QnNCZ2dBbFI3R1R1UE9mMnBnMkh0SjRWdE56RFlEdW1mZXRkZ2FIN1dwR0RhWml4LytndExMUWtZUDVDMnRZMTY0NmFod0FCand3RDhwNzBVdGUwTFRRYTRKMHpQYUFkeUlDRllNMFpPbGNtYUNiZFVVbXZPby9xbThPOHFyQWdCZllWYkZ1TjBVbEduUlJXd25pSjk1cEpFQXhOTzMyTzZTME9teGNXRGRWazNHRGpKeVpxRGE4QzlrTlJZWU1seEN6S1prQVp4eldpL0RGWWUybHpXRzBEYkFVREErNkFPT1RTNmlNV21uMDNob2lKYlVnZjVYR1Z1YzRnZTFUYnQyRlBROXA5SW13TmNaRlBxcC9XS0x5VVNxd2xuVGFhVkFWRG5KWnpKeFN2STJIaU1yYXRKa1c3ZTdua244K2EzSmkwSHZPNjJtYXljZ1NCdGpIeG91cUJGYm9NbHh2RWxYM1ltUVpIRkJ4Y2pXb2tIWUhhck51WU53Y3hubmlwdlE4ZDdGZFZjQ3FaOHBnakRIOVJRaTIyTlNNRDF4QXV2MVMyajVGMi9BU3N4OE1maUs2OGI5cU96SHRXeEs0VmRRRVVpQ0FXUGNuajZackpmYzZISmZBdmZHNG1ENFkvOVIyQUZORjBUeWRoQUFHQUVRZmY0MExKajNUYmhzNnExY0U3bGNNUGdDUDJOU3lLNHVJMFhUUHNPbzZhbXAwNHZxWjNEZElyd1l6Y2RIVjJaM3FQU0NYWVFRdjhBci9kWGo2Z0hFckIwb3F3Q2hpUndZL09xL1hCeEdkTG9pR0FZVDJ5ZUtuTEtOeERhdnA0Tm9ZTTRpSnpTckxzRkdNNjNwU2wxNUVBTUZBeUpOZWhneUN5am96OTRGNFJqNXA1T0s3b1B5YzhscWdFbGs1KzZJT2ZlckxSRjdEM1FWMm5iaFJ1STlCU1JkaGtxRytoNnhiZDI1YVlmZVVoV2pJSTdWc3NMcGtaN1dqWWFhMGw1TFpacllMQVRuUHBOY2prb3QwU2NXeTF0YURTaTBXdWFrcE9Cc1laL09vU3pTazZpaG93NDdZSzNvVkxyRis2RVVra1RtUFExVHRDODZaNjUwNFBjL3RGM1VRQUpuSHVhWldsVXZJcm5mUWEvb2JpTUZ2SUIzQUpuSHlyUmFsdE1OMTJqaTlJWGZ1RE93QXh0NzVvUExXckhqYjhEbHJvRFBhd2dWZXh1K1grR3VkK3E0OXNxc1RsNEZ0YjB4ckpJUkVRR0FEdlZpeDU5ZmFxUXpjcWIyWjQ2dEF0RnBENG84eXBCQkxGdndycCtvcUpPTmxwcEF4bnhYQkZyTWpqMC9ldVhOUFZJdGlqVHN6dXVWM3ZCeTVCY2JqSkdmZXU2RHBVQ1MyVW1sdFRkM01vSndTRDIrbndxazVDRnpac204MjlYVU53SUJFWTlxaXhXNkRMWkRBQnJvZ05KZ0dQcFI0RTNPbU1XTEtNTnUrZmw3ODVwZUp1YkRXTkpwbVhkZXVFQlQ1aW9KSDdVczAxME5HZDZPNm0xT2xZNmRtdGd4c1BmNG44b3JpZWR0MGpxaGhTL01LWDlVOWpWV2t2UENYTnhqd3R4RUFBZmpQNFZTRSthc0VzU1MwTFdiK3BkSHYyN2poWmJjSHprNVV4NjhZb3VmRjE4amZUVFNHTkwxdXhmMHhzNmxRTlpMTDkyQTJlUVR4eUt0VGVrU1dGcVZwNkdiK3ZTMWE4VXJiMkl2bUxPQVFRT0JpVFVmcVN2aWxzYjZDOHNIcU9yYWY4QW96ZlFPNVV5eUh5N1NBR0lKbjVZcDdsZENyRnNSMVBWTGQ3VVdkUnB3NXRLQ3B0a3hIck9jVXI1S1d3cUdxTXJyOVQ0M1VOWTRCQzNMa1pPY0RrVjJ3aDdZMzJkRUh4WEVTYTdjM2JXazduVnVlNmlPYUxqWFJUbFo1Q0dJd2NqQWlhRlVDVHNic1dYdWJSd0ZJejhqVTNLaGFOQjBib3Q3VnV2bGNXelBtam11UE5uVVNzWUgxYm95dW1pdFdMZ0xGQkU5NEF4WGpaSGJiUmRJWTFlaUZ4UVBNUVJrZkNrVWcwVmJkTE1xTnZQSTlLZjZocUdMUFRmREc1aEdZOTZWelpxQjZ6US93RDRwYUlqbko1bjg2WG5zS1JoUHRkb29CZFZJdUtOM0VBOWdQenIwUFNaTjB6U1dqRWFpeWJzaFJMeDZmR3ZZeHlvNXBMa2diYWFMTGtJUWNjL0ltbmprdGs1UXBCZXJXdkRzMkdCTXNna2ZwK05MZ2JjbWdaRWxGTXAvd0M1YnViaGxnQzh5ZTJhN0dsSlV6bTJpNHNheTgxMkVlUTZqN3JtT1B6NStsY3pqU0E0b3Q3RDZ0MFgrNkI2UTB4bXVlWEZiRWE4RHZTZFZxWHYzZE5KQ3FDelpnYy9uU1RhaWxNZmc1UGlXV3ArME51enA0MEZndU1yRnpEYnBpU1Iyb0tFcFN1UWlWYURkRjZuWjZoZU4zWEl3ZFJFQWtpSjVwTThad2p4eHVpa0V1VnlWbXR1V3JZdGtwZHVienRJV1RuOXE4bkhLWEtuczdtdmJyUlZhb0JkT0wxMFhib0pDcXB1Q1orSHBYYkJLK0thWDlDRW02dHBnTkpwRnNoNzF5SkN6dG5BQjQvV255WkhKcUtGaXEySmFnc3U4a0ZFSjJoUjM3VFhaalZvUmtkUGV1SnAzczJyYXRNcVoveEdSajhhTTRKdE5taTYwaU9yTWFxNzRaSlNmS1ZZakVlMVZ4cDhRU3F5ckl0MjFWNXlWQUludlNLY25LbVduaVhHMTJPYVc4SFZkcFNCek9PZnpxdXppa3FZZTUvYVhjNlc4TkF6N1V5a2tteWJpMjZSSFNhcTBuaStKWlhZSWhoL3Y0MGtza2JvYjZNcXNiVlJjOHBPeTJTU0VpU1FPSjl1OWVmbnpTYmFYUjJZY0NpazMyQTErcmlRRGhWaFFEQitOUmdqb1VhN0ZOSVBGdnN4Z1hibU53SW5qL2RVazZWZUVDaVdudXpwcmxsNEc4dG5qdHo5YU1vN3NVemwxcmYvQUhXOFhBYVUyZ0U4ZkN1MVg5TlVMNVlLMXF3dG0yTlFibDNiSklMa0ZTUDV4VFNpMjdpSXV0amRzZUxwcjZLemJRM3p6SS9ZMU4rMlNiTTFZajR6NmE4NVlibEE4MC8vQUxmNStOVmNPYW8xN0szZTF5UzVrc29mSHFlZjFyb2txUThGYkpXazNzcnJnQllrNEpNOGZRVWtuV2lxcDdMRHAyamU0d1ZGTEZzQUFTY25pb1pjcWoyeGxHK2plOUIreWJJRnU2Mnk1TENWdENJNUhOZVJtOWR5OXNHVldPdXo2TjBUcFZuVElyWEVWWTVyenBaSEpsS0xoOUFMVG5ZdmxJN2p2UEZTbE1LUUc3cEgzK1VCaEdEeDNvUm16Tkk2dWhMa0VyanRtanpBRy9va0JCS2dubVNEbitldFpzd2xmMHFpMndjb3VabHZ4Si9HbGJ0akdKKzJHaVQrbVVnaEFGS3FKNW1NNU9jVjFlbm43ckNmTHRWYVZkWWd0dU5nbHcrMk1pdmVoTDJXeURYdXBFdkIvd0QwWnJybnpsb0lrRHZINlVWTC9WcGZBa3Z5T3hIck5zU2xzSElJbk05djkxZkJMdGtjblNSV3NrWFYzZjhBcTNNNXgvdXVybG9qUWJwdTBYQ3JzQmJiN3JFd0FSMnBNbjJCeDBYdG5wdDI5dDhDOWFjR0ovdUFaQjRpWi9DdVp5Uy9NaFduMGkzMFhRTDk5SFIzS3Q2Z2pQcnp4VW5sUzZGY2Zrc3JmMlQvQUxRWCs4V0FnR1FCU1BPK3hkV1A5UDhBc3Bjc0JkMjBxb3lUY2lSNzF6NWZWWDVMNDhiZmcwT3NGclRhZTJ1cXZzVWlGVzAyN0hGY2VPTGNyaVhrK0twNk0zdmQ5VmV2RkNMUVZ0a21UQS9ldXlrb3BJaSt3K2x2QmJCZTRkOXk1TEVFU3ZwK0ZGd3VXdWpYb3E5Yy9pWEp0eXliZ0FKNUFBcnR3cml0a3BPOWhlbG9sdEExMGdibklNanQyL1dsenliZWg0TDVLM1gzeWJ3Q0ZTQXZjQSsvNjExWW9KeDJUbkpwNkJJb3VJakZWSTJyUHVSQXJrbTZrLzZucDQ2NHBNbTlsTnp1bUdKQUJIRkJaWktqVHd3bFlLN3JMam9mR1JHMmxSM0I5ZldxS1hjZms1SmVuU2FrbjBTNllHZlQ3YmxzTnVNUUIyNS9NaWt6TlJkcGdoQ3kwY2dCRkFKTUdmNTY0cmhXOXM2K0tpRGZSK0pkOE10TE9SRWtBRDM5aDNvODZWMExYeUYwblQwMDYzV3NsZVI1K0ZFOFFPVHhTenlPVFNrQ3ZnUjE3V2swamVDdTNhQ1Qzd0kvY0UxYkhibHNWcWtad1dwMVE1S1FHTWV4cnVjcWlTb0YxeFRiMU83YU1pSDl6eVQvQUQwbytuZHhvV2Z5TTZZa2RPdUpNQm5rd2UyMk0vV2xuK2V4a3JSVWRSVnJZQWJJWXMzTVRtdW5DMUp0b1Z4YVd4ZTNJMmdjcW9tVGp2VkpqUSt3OW83VHY1QmtLVE1kcTU4clVOblJCTjZQcDMvVDNvbHUraHZtRlltRkJIYWErZjhBWFoyNWNVZFVZcUtQcXVnNmFxaGR3QjdtUkpyendQWmJwcFJ0QkE4d01nK24xcEUvSnFDZjA0ZTByQUVCUmdLWUh5RkpkamRBYnVuMjNKWUFDdDBZbmJ0YlNwVldqLzJqQnppbVRCUkcvYmhnQXVSbitHZzNzeVJUNjRCVllLT1o0R2Y1elFZYVBubjI4VnJlazhRbU4xc0lESDNTVGtmU00xM2VrYWVSSUxYdFo4NDFlbkZ1NHZqaG1Da2phQjhNZjhWN01KMnFpVGNhMncyc3VwLzJ6VGJWZ2s4RHQ1akUvV2hqaStiRXlQUm51cDNpMnJJa0dXTVk5SUg2VjZHR05ST1hJL2RRSm9QbVBBVUtNZHlLZE1GYUJ2Yk94U1YycTVrQ09LZFNWbWEwV3ZUZGNBTnBtMndBbk1TZlgrZXRjK1RHK3lialJwT2xkVzFOaDJSTGx6ekt5bmN4ek5jT1RHcEt3WFRwSDBqVDZ5MWMwdHByS1M1VUJuVlNReGoxcnpuRnNyYWl3WFVMT3NhTGlXOXNDUUNJVnZqUmlvNjVEdVY5RmRkUzRiSThOQTJ6SkpFd2ZqVHFVZVZ0aU9McXFGYjA3U2hSVlVBZmVXTnhuc2FvblcwTFh5QVRTM3I2M0V0Z01DR1VBQ0l6MnJvK3BHRk5pY1cramlkT0tOdE50bmJjSUVjL0Q4YXI5ZFBhWUZCaVFWWHZXRllJcVd3em5FOGtZcC9EYThoU3ZURk5SYk4wcGRJQThRRnZMNkZqRTExdzFGSkVwYmRzaFpiWjAzVEU1SVNaR0NBU2YyRmNNMDNsbCtwNkVla3p3WnpaRFFBbTdQZmp0U1NTVXE4bFU5Yk8yZE9qNmU3dSs0cXJ0VVJ5UUtTVTNHV3Z2L2tXS3U3TzlKZFJjUzJZQ013VUgweDNvNWsyZ0pVN1JjTG9vMUxCd1FGV1k0MzU0cmwrcHJSbUR0YU5CcWJjTXhMQVNNNEU1K3RhV1I4V21LbGJQWFVmVG0vYkZ6Y0EyNkNJZ1JFZktsVFVxWTlHZnUyUVV1TGViaGl1VDk0R0QrbGRjWjlOSVdVZmtWRmxIdklpQmsybmF6Z1RqbVBqVmVUVVczc25LdkJIcUZrM2JlMjUvd0NScGFTZVBlampueGRnY0xWQXhidDZmVDNGRGVVQU52WVIzSDRVMXluSzBHTUZGR2QxMTliOTRtMlpSVHRCbm1lLzUxNkdHRGhIZlpHY2xKNjZKNmUwN3VvRVNRQmp0bWhPYWlyS1k0M28xSFI5Q3pYUERUQ2tRN3hQUHJYbGVwemF0bmZqaFdrZmNQc2IwNUxHaVVMOTBxTm9INyt0ZlBaSjhwV3g1OTBiQ3pZaGd3WVRFVDNHYW5ZZzZxb0JFajByUFJnTHM3RXFveG5rY1V0dndFRTZmM2dXR0NJQk5LK3dvT3R2Yk9KSHhxaUZGTlJ6RThkb0VFMEgyRXArcUtOb2phSU1uL2lzakh6djdaYWxiZHQwdWdOYks3ZUJKSkU5L1lWMSttZzNLME92dWZOcjk5N21rdDVMWEFUQXpLNDlhOXVNRXBQNEpONkk2b2kzMHF5QzI0Mm9CaUIzQi9hbmdybTJSbjBaZTQzOTRrU1NwZzU1NU5la28rMDQ3OXc3cGRPOTV0Z01JSk1rNEppcFRtb2xZSzBXZXI2VmU4Z1ZmTHRBRXNmd3g3VkNIcUVVbER3VnVxMDF6U1hoZFlMRThBemowcnBoTlRWSWxPTFR0bHQwYldKY3ZpM0c4R0JCYVB6NHJtOVJqYVZpUmo0N05oMC9XMzJLNld5RWxKTTNMaEtMSGVlRDZWNThvMHJzUHRiOTJ5MzBHcTFkNFhYdERTbFFRRlVXeDV2WE9hbTI2V3pPTUw2SGpxdFNtbHVhczN0TXBDK1MwYlhtT2VKajUxQnBTYVRLSktQUXBwdFpxdGRaTHQ0U251UmFIUGFUNlZSd2hqZElDY3BMWVY5WGFzRmx0bHlxRHozeWRxZysxVmpqbE9uOCtCZVN1aE8rMnBmVTNXUnJwbFNFRW5BK0h3bXVpQ2dvN0VsZmdyOVdsc0R3U1ZTMnAya3ptNU1mdCtGV2kzZGdTMFYrdS9wQTFyZmNFbEFZQ2tnWk9CVk1mMUd0SUV1S2ZZRFJvVTB0bzNCQWEzaHZYK0NwWkhjM1h5ZDBWVUVEZS9jVzA2V3dWRUJSZ1pPY1JSYVRkc0VrNnBIVXZKYTB6cVRKNUFqc0JVcFJia1pNVDAxNE5aY0V6bFc0L0FWZVVhRlVqWDJ1dExxTlpwTE45RUZtNHEyM0xFZ3EwWmFmYy9uWGx6OU00cVVvOW9wcEtpNGF4YnVGcnRrQUV3SkxDT2M1L3dDZUs1SXRyVEJhRUwybVZYZmRjVGF4QUozYzlvcWliYUE1VVVmVTlPQmQ4UU0xMUZZTUJIY25FRDJyb3hTMVFKT3hDeXl1OHNHelBsYmdlc2U5ZEV2YWhZcHRpbldiNld0ckVoVlVnejYxVEJDVTNTSGxVTnN5V3YxVjNXNmg0WmhhYVBMNmtqaXZYeFlvNG9vNDV6YzNTQldrQ0ZodGx1QjZBemlpM2V6SlVhajdNZE9PcHVBbGR6UGdDZmwvdjVWNW5yYzNIUjM0STZzK2c2RG9selVQYVhUS2JsMTJCZHpnTVBMMzRINlY0V1ROdW1ka2FTdG4xenBXak5xMUlBT1N4SUpqT2Y1ODY4Ni9CTjdMYXlCTUdSbnNlZTlNbUtHSUc3Ymx2ZWZyVFVBRTZzOFFCam4xb1Vhd1p0bFhBZ2ZIazRyU1drRkJYSTJrTUlQRTFyTUlhbFdVRWc4ZHpXZlprVXZVRllhZDl3SkI0SE9LeGo1bjlzUURyVkpWV1lXOFprS2MrdU9LN1BTOUZERWFzcUNMVnRHMk00YnpqUHFhOVRGYjIySmswaFhWTGQxV20vcDdLODNDU3hNQWNTU2UzRmRFR29TNVNaeVN1U3BFdW5mWmE2Vlp2Q3UzUy9tQVR5aUovd0RjL3BSeSt1ajBuWDgrQlk0R2krMDNTZFpwZ1dzMmRCb1VVeG00Q3dqM3Jqbm5oTjdia1dVR3V0QzNVT25JcWVMcXVwQjNNRHlXaTBUN2s4Zktxd3pQOHNZZ2NmTFpudGZwZEdkekwxSjhaODFvZnBYZml5WkUvd0FuOXlFMG11eWtGcTVidUh3V0Z3cUlsREJ4N1YyV212ZG9pcnZSZDlLNis5aGd0NmJiL2Q4VVl4Nk1EWEptOUZmdWgrMyt3OGNxZXBtdTBuMmd2SVFvdDZGZ0NCRzFiWklJd01DUHdyejNqcld5a3NjWHRtaTZUMTdUNmx5cjZDeFlJbmFGZFduOHMvV3B5eHBiZitCSGlmZ3NEcnRHcWxYc2xoSllLRTJ5UFhta1VMZHhBazJ0c2QwdXQ2YmUwNGV3VlpHd3lza2dmTDJvU3h5WDV0TTI0OWJRZC82TkxidWpXOXBPNEVZa2Uzd3FYQ1hWbE9hN2FLUHFmVGY2aytJaXBjd0dVb1puSE0vUEZkR1BJOFdub3pxYTBadlc5STEvalpSRndNTkdLOVBCbng4RG1uaWxmUlNhR2JpV2tZS1RzNVBJRTFzeXFUWjI0M2NVV0YyM2JDcXFrdUFNazF5Y24yeW5FZytqRjZ5VGtGRkk4b2dmUDhxWDZqaXhWRlBvQ3Rtellaa3QrSDRoajNrWXhBcCtjcGI4QVVBR3RWbk94QW9JSUVqdVJOVWhLdHN6amZRMzB1NWYwTzFyVjAybUF6M1huTWp2eFM1WXh5T21qVm8wbjlaYnZXMDFGMENiaUFoZHBKV2U1ajUxNWp4eWpKeFhqOUJxMVl0YTA0MUtrYWE1YjJrSGF5bmpPUjdjMEhOd2Z1R2NVeXQ2blkvbzlPOXk4TmlxaG1UbmpKOXZqWFJpbDlTU1VRVW83WjgrNmhxN3VzMVBpRnZKd21lM3I4VFgwT0RESEhHa2NHWEs1TWpiVUFuYVZHMGNqajRENlVaTVdLT0JEY3ZMYlF6SjQ5NlZ1bHlZNlZ1a2ZXZnNEMDFIdGh3d0FJMlNJayszdFh6WHI4cmJvOVBHcVI5WTZUMDVWdU40Vm53YllVU2V6TjY1NzhUWGp5bHNkdld6Ulc3UVZpb0JqY2Rzd08vclNMNEVaTm9EQWdubjcxTUFsdWtSajFwekJrQ2tna1N3QklIclRBT1BhZ25uNW1nNG1USWxWTERHRDZuMy93Q0tOSXdycUxmbHdRRG5uMnFiUVVadnFsMWlwOFFuYUFZa2lhQ2JvWkkrWWZhSHhOVHFoZExTank2MmxmYndZRS9LSzlEMDlSVkR2Um1ydlRFdGtYTlJjWkdNQnlCSUFIWUh0ejhhOUdPVjlST2VkUHN0dW1hZDJjMnVuZE5aM1VTSE51UW83U1RnVDhLaGtsNW5JMmwwWDdhSmt0ZUoxanFDV1M0TW9HRHVPOENPSzV1U3VvSU95djEvVnVoYVM5NGRtMkxqTHl4Z3MyYytwcThNT1dhc1cwaWc2aDlyZHlrYVBwK25RSEFkNFpoajVtdTJIb3IvQURTSnVhWFJuT285ZTFsMjJZdldodVBaVEdSOEs3Y1hwWUo3UkdlUitETzNybHdzUTVSOFRJd1NjL0QxcjBJeFJ6dHNnZ0dvU0FTR252M01WUiszYUYvTnBqdlR0VHNkYk9wS3FzZ0JpVDVSNkg4S2hteDJ1Y1N1T2RlMW1qUjBOa0RUcUEweVdqbWNmU3VLdCs0NmxIV2hrZFZ2SWhXNFVjN3VYQlBwL0lvd3hwUFJLY1d5NjZhMnExNkczMDRwNFlQOXhiUkFhUGhVY25HTHZKMlRrcFY5alEvMEdyWWkzZGUzYklYWXpFekFqajhxNXJTMmtDVFQwaHora1N4aTVkWjBYYUJ4QVVmT3ArOTlJZmxCOWltdld5dW9LeGVNRHNaL1d1cjAvSnc5MUU4bjA3OG1BNllxaGxKeVNwd1RBNWl1MzFEZDBkV0N1TmxwZEF0U1F4QjVKL0NCOWE0RytSY0gvVnNGSVh6UHp4eGloOU5lUU9UUjIxWmx3YnVISG0zT0lnOFFLRGw0UmxGMWJHYnRrdFpMV2N3QkpaZU8wKzNIYWs1VzZZWG9oWjBSSlh5RWpiSUI4cS96bW1sbFM4aS9jYlRTYW5VRWpaZGFRSlcycEFqMDlCWE84a0l0Tk5mMURmeWh6U2RNZlIzaGN1eHByWUcxVS95WTl5ZjJxTXN5bXVLOXpEVFprdnQ3MWxOVXcwT21Zc3R1TjVISHdudlhyZmh2cEpZMTlTYU9mUGtYNVVZcGlYODVZU3g0NGl2WU9MN2pMQWkwekxoUmdHTVZHN2RGRXRXRzZaWkp2VzJZN1JHNzRDYWxtbHBwRmNTcDJ6NlI5anVwbnAyc3NqVVMxZ2c3aC82Zi9VVjRQck1QMUZ5ajJkMEhYdFB1WFMrb2FiVmFWWFIwSWY4QXlVNC9LdkJsRnhkRDJYRTdyUlp0b3pEZndVWDhvVVJhNFZPd1NXTFRIdDZWU08wZ05qbWtSbklFd1Q1bzl2YjhLRDdNUHI5MUdXRGllZjMvQUhxbmV4U2JJTWpBNUdKeFROQVRBTWlxUUR0REVjZTFMUWJGdFRzMlF2ZmppbGEyTWpLZGRlM2FrRXo1Y2ViajBta1VISjBOZEh6dnJPb1FYZHVsRnU1ZUl6ZEpBQUh4bkFudDlhOUhEanBiRWxPeWpTOW9OSVRlMUZ3M243S0ZoWjdrZmxnVjFPT1NTNHhFdmRzUjZyOXViOFBiMDBCWUFVQWtLQjhLdGgvRGs5eUVsbFNNeHJlb2EvVzNEY3YzSDhFZ3d6RUlvK3ZOZDhjR1BIcExmN2svcVNrVmpYSEIycnFrVTdwOGlTUHFmMnJwakZkOFNUay9rcnJsMlRONjg3emhSdnorRmRDajhJaTVmTEFNNm1TSHVEaU9UT0NhcFRFNUw1Skk4c3A4VnpKQUVuQkZHdnNMeSs1TzBPQ3dNREI5T01VUThyN0RFc3lBTjVzUURNa2V4K3Y0VXFWRkw4bHowalZ0ZXNpM2NBWmxIbGFZSkE3Zkt1VExoNHZtdWpzeDV1ZnRmWlpEeE5vREx1U2UvTlJ0Rk9NbDJTdHBaRFlkclRodktWR2ZsVE55cjVRbkdMZndhN28vMmgxV2h1aHVvK0xxN0VSdlM0ZHd4R1Izcno4M3BZWkY3UGF4L2ZIeFpvTDMyaTArcEVhZEVhMlJ5d1FUOFFmalhQSDBTeHYzTi8zSXVXV1cxRUZwdFN2aGtsWHlUOTBwRmRlT1VZeHEvd0RKejVQVDVtN1VUNVpadXRhMWdkQ1lJSyttN1BNZHE5WExCT05NcGlrMDdOQ0xsdDl6dTNpbHBtRDdpdkhrbXV0SHB4aW1PNkd3bHBDWCs2NUJLakordFFuTnlmRmVDbjAwbGJIN051M3BuOFM3YVJpM21BSW1NOGsvemlvdHVUcE15Z21qbXExdHh2RHQyMlhheHlGUUg0Vm9ZWTdiQndndEIxMWQvVE9ROTF1OHdCUHVQV2k4TVpxMGlVcWkrZ1dvNjFxU0hVWFdDc051MGtmTTVwRjZXS2RnNWZZeFAybDY5ZmE0Mm10M3JoY0FtNjVKSkgvei9QMHIydlJlampGYzJ2MC8zT2IxR1hmRk16VFNsdG1kanV5Y2lZL2h6WG92Ym81T2dHbHNtN2V0S2NJQnllMU5OMG14STdZNWVYeFdGdTBwZ25FZmlhNTE3VnlaWHZSYjZIVEVYMEJqYUJBbjFISit1UGxYSk9XaXNUUWh4YVMzQ0RmRU5JeEdJay9HUjhqWEU0MlhVdkRMWFM5VnZhVjFmUVgyMDl5Zk1OMGoxeVBnUHhybW5nakw4eXNyR1Q4bXQwUDIrMWVrdHgxS3dMZ0grVnBvelBjR3VPWG8xSit4ajFxeTY2TjlydEJxdFF6M3RRTGJ1MGdYQkVEdG1wejlQT0txaFRjNkhxbWd2V0FiV29zbU1ZZWMxelNpMTJZY1hVMnBIaFhVUCtPR3lSSHYvT2ZXbWl3TkUxdkNWWjJRWjNDRGdBMGI4QW9YMUdwaElCR093SE1aNDU5YURidWdwSXpuWE92Mk5FaktMaWVLQVJDZ1R4d0lOYUVKU1llajVsMWJyOTdXYW53aWpPZk5GdFQ5MzNZOFYzNDhDaXJKdVJpL3RCMWRrQVJyL21Bd0VpVDdlLzRDdlM5UGd2ZEVwVHBHWnVYTGpzWHZPVkJJL3dBaVdQeHIwSXdTNkl5bUt2ZEZpeVdSWmFSRE9NQW5pQlZ1SExzazVVSmFnM3RScXR6bDNPNDVZeUIyL1dyUmpHSzFvbkp0OW5UMC93QUlsYmdFd0dBaWZTUGhJelIrcmZRT0h5QzFPa1JIdWJWaUhBR1BlakdkcFdCeDJMR1JJREVNQ1ZrWWpuOTZvaGFKV1ZsUnRYanpSSGJ0RkZzRkRWbjdyS3crOFpJOWNVR05INEMyU0JrQTdHbVFlK1IvcWxhc2VQdFkzb0I0VjZRekp1RTdnSmcvQ2cvY3FIaStMczFTS0hGcDdLN2JiYzdRVEI0eDg2OG1mdHVMMjBleEJLYVVvNnNOYzBpaFdoUTBEc004MEk1Ti9BSll0ZEhiSE93TXlzcDRPUi9xcXRXcklyVHJvbWQybHVpOEFGWWp6U0pWdmFtU2prOXJGZHcyditQNmxycDlaYXU2ZTNjdVhybG9zTUo0Y3huMStNMGl3OE5kZ25uNXUxb3cxMi90MU51NFFTRkI3OEg0L0N2UmxDMVJ4d25UdnN1T2kzOVBmUTJrRENlYmNRVjlEWGtlcGhLTHRucjRNa0pSOXVpK0xNQXErZWY4V2ppdUxpclpXMVNRMjVHcHNxbXJRbzZpTjZtUWZrYWwvd0N0M0RmNmc0dEM2NlFrMjdpWEVKQzh0NVNjOTZlV2E5TkMxVEczMGwyNHlzd0JjNThobWZsVTFtUzBoWksreEhxdWgxMmxzUHFYME9xRzBmZTIrV1orSHdxK0xKam5KUlVrU2FhVGFQbTlwTjJydjNXVTRKUG1IMXI2UFhGUlI1di9BTld5WlVlSGNKT1dPR21lUWFLN0VkZzdLcWlCbG5jeGdTWjUrWHRXbHNDZERta3RGdFlwV0puQlBFK3RjMldTNGxvTFpmNmU2dHNOc1dBaDJxSWlZR0NmWG4vL0FLTmNFazI5bEVSMU9yRnRiVjY0d2tIY1lNeDJBK01UOHo3Vm80K1RhUTNKSldUMGR5OExLM3JxaFRjTzUzT1NPOEE4OFFmbjhhWElvM3hYZ2FMZlk5cGJyYWk3Y2RXR3hIMkxQbUJNVDhzNDcxR2NWRkpGT2Rzc2tLbFFMbHNRRkRHWWxmaWUwRWdSNzFOcjRDbWd5WGJVcTFxNDlva2dBcXhBSmtmN3BKUXZ0REtUOERkbnEycnNOTnJXMzFIQmhnM05SZUdMOEQyT0o5cXVwMnlSL1dTcFVBYjBuZ2RxTDlOQjlJVy9rSnFQdGIxTTJTMTI2a043QmNlNW5qODZIL2l4YkVlUkxTUlFkUzZpYlZrWHRYcTdpczRsVUt3N2ovOEFpUHhxOE1OdW9vbThobTd1c3VhaFd1YW05L1NhS1NRcWdrdDhCL2tmYzExeHhLT29xMkk1djlETTlSNnBZUzh3MFduWkFUOTlqdnVOODY5REY2ZVRYdmYreHp6eUpkRmUxMTd6czR3VG1EM3hrbXV0UVVTTGsyRjB0cmRlSmNIYXVTUm40ZnJVOGs2VkJpdGw5cE5IYjNDL2RBSTNiMmIvQU9SZ0FlNXJreVpQL2xGVkh5SjNtOFFYYnJaTHZpQi9QV3FwY2FpQjdFZGErNjVxQlA4QWtDREh1YXJCYVRFYUt3anp6TFFSQmc4MTBKaU5IckRFTDY4a2Z6NVVXS0V0UWJnRURJK014V2ZRWTlqRm9rZG9NWmp2NzBLR3V0TVpTVWFGVXQyNW9KYnNMZXFMclI2dTROUERUMkJFNHgzcmx6NDA1S1IyK255dFJjZmdzSDF4dTZVaDdlM2NDZHlaay9ENVZ6UndwUzB6cWxsYmp0SGRIZDhXNFpkQ2V3UHI4TzFVbkhpcm9TRWxMVmx0MUd3MS9TV25WWUJBSE9RZlNLaGd5SlpLYktab1hEU0ZMS3VMU2szcmF6TUR4QU84Y0hqaXZSUytEeXB5U2RNejkxWllGbEFCRTdmVWVsT2JzUTBXcGROZmJjUDRja2drZWhIRlR5NDA0TlVkT0hKeG1tYXJTNjI0emdpNlFTSmtFNStGZVZreEphYVBWakpOV1cybjZoZUljRUhnZWIvbVpya3lZb2pwSjlvTC9YcVZCMjgrbHVEK0ZSK2sxLzJOeGlRLzdyOTBLbStERUUrbis2ZFlQTFpLVVY0RSt1ZFlZNkZyWGdJcEp6RTUrTmRQcGZUeCtwZG5QbVRqR3pGbTRBTUZaSWprOHhYdXBIa3liSWxsQ2Y1RlFNWTVFVVVLeUlqd2xMYm9rVUpNeUd1bEJ0N2tRQVZ4UHVTUGxYUG5yb3JEcXg2L3FnK3VVS0dDS0lKSTRGY3FqVWJIRjlYcUJxTlpiUlZtemJ5Y3dENi9VNCtkVWhIakJ0OXNEZHVpZHpWTUZOaFhiY1RERWlSdG5jWStOQlFWOGd1WGd1dW4zRlJISkxOZG5mTVFDeHdQeG11YklyWTZaWnRjVXFMYWp5eVFHNXdJVlNmUTVkdmlhaEZQdC96K2FRN2ZnaUxpaFFwa2IxV2ZhV3dEUHNKK1FyTzdzSzJBZlVJYnM3bCs2eFZpWUVERS93QXpSVWRCdllEK3FacnFXMVppNDI3Z2dJTEdEajRuR2YwcWlnbHNTVW4xWWIrcXVCOXdWTGw3QmRpZkphWGprL256NkR2UzB2NmY1RUtMcVd1c0c4SGU2MSs0Y1Q5MFQ3ZHlmZXVySGprMVZVSTVKR2UxK3NhNmR4M0VSdHllMzZWMjQ4YWlRbEpzcnNzOEtwQko3ZDY2TkpiSmJMRFFXUXpBUGprbnVlUDlWTEpPbG9wR0k5YVgrMHNobExtWW5nUiszNTF6dDdzcFE5cjlSTnRkTFlKQkxCbmtjRVRnZkFmaWFuamp2bXd5ZmdXdklFdFdiYXJ1Y3lTQVBrS2RPMjJ3UG9NUHM5ZU51OWUxOTFkSWdLK1FrTmNibkFBNDdjMU4rc2pxTUZmK0IvcFB1V2hTNzB2UnJmTnV5THpXMSsvZGQvTjJ6QXhFMDhmVVRxMjkvQVBvcXhlOW9yUXMyN052WUg4S2QvRXZNbVQzR1lId3EwY3p2ay9uK3dyeGVFSzZld1V1RzVkZGdnSldBdWY1SDZWZHp0YUVVYWxzaXhtNWxZTWJmTjZkalBlbnNXckdVSmNsVzQ3KzFhekpGbDBvaHRaYVI4SmVCVUErcDQvS3VmUC9BT3R0ZURxd05MSnZ5aTVmVEZiVE9BeXFoQUhmbXVLR1JOMGRza2tyc0liQUZ4dHdCd1pFUVRGR0dSMW8wMUh0bkh1QnJDQld1RmxYY2ZNU0JuZ0N1aUNwbkxPVitTZW1hTFFOM1IzYmpObVZjQUQ4RFR2ajhrdmQ4RlA0b0pkU2pNUVNzVEVaOWFzMHhGS0tSWEcyVHFHYmI1OGdBOENlOVp2VkdUZDJhV3padXJwckpEZVh3eEVHU2NDdkt5U1RrNlBZaHk0citnL1owMTF5bDFFWjFVU1FURS9PcFNhNlllVFFFcmRMUmRVcXZaVlBHZS80MHFwZER0dHJZUnB0SUlCVW5BSU9lWnBOeURwRlIxYlUyWHNzaXE3a0hMRTQrSHZYYmd4VFV1VDZPWE5talRqNUtJcU42cVNBb3ljVjZTNlBLazdZQjdyTGRZd2NIbjAvYW5TMVFuazVhdXNRVVltU1ltS1NYeU1peDZkZDJHNDI0L2VVZWJnNEovYXVmS3JLUmVqck1DZFJjSU13RldUeWVmOEErSnFianBJS1pEcHo3dFFYWUFBRXNmZ0IrOFVjaTl0R1hZUVhGVjVJM01UUGYxL2FoeGRHc3Q5TnFEWTArL2FvYWQweFBBZ2ZpU2E1NVI1U29aTWFUVmtXRVFaYmNxa3pnOXo5U2FrNGJzZFA1STNkVTdCeUcvOEFMZE9SMkFrWStsWlEzK2dlV2hLM2NlNWNQRzRDRVE5Z0R5YXExeFF0Mk12Y0ZuVEN6YllCbUVQY015Qi9PZnBTSmNuYkEyVnV1YTdjdEJWM3BZVW56SEVtWWsrcC93Q0t0Q0tUMzJJM29vcjl6SVVjai9LUGwrbGRrWS9KRnNTdVhYWWxSSXgyR1BoVmtxRWV5ZWtVWll3T3krM3FhV2I4REpEMWk0RlRjY1F4WmhISUhiOGhVWlczb2VOSFYxSjg5d255cnVQcjVqL0JRNFZwR3U5aDlFRGU4VzQ4c3g4cUR1V0pPUHBTNUpjYVNHaXJaYzlLWm51cDRkcmZmeUFlZG9qK0VuM3JremRPM29yQmZIWTNxTHZuVUZXdlhtSUo0Mmo0bnY4QWxVWXJUOElyVmZjcjFzYXg5VmVHNWdOeEIybkVlNS9XcXVjRkZBcVRkaUQzRDVoNUhLbVE0ZWVleE5kVUl0aVNkZGxWZjFaYTR5cVFRUVFTQkdEakZkc0kwamtuSzJlc0xQbE1nRFByZ2Z0UmtMSGJDMnQvaUlIQW5nRHRXVkR0dE1ZdDNUYlZUM1VoaDN6UWNFOURLZEdyMG5XYkQyRHZzcUdLN25FRVpIKzVyeTUranlLV24raDZjTTJLVVZaUFg2NnplOEJyTEtBR1luR2FiMCtDY2I1QzVwWTYweFhTM1FIdFNSdEs0YVk3OGZqWFpHTm5MTFE4bDd3N1Z2ekpCRWlXZytuNlZ6NUl5YjlwZUhDdmNWU1d5b1FFOGNTTVZWdXpuU085TzZlZFQxUnJMQndxeXpOQWtDUHo3ZkdreTVlR1BrR0t1Vkc0WFNtYlJ0bWRnMnFwd0IyaXZHazQxVFIyckxQd3hvNmRsREpDRXlmdkFmaEZUVGlaNU1qOGtCcEZaMVI3Tm93ZUlpS0xrdTB6TEprWGtGcmRKcFFqcGQwOXNjQkRtUVBTdENUdTB3dkprZmJNSDFZYVcwcTJyYUpLa0ZvTXpqajVHYTl6QzV2M1NPREkvQ0tabS94SURNM3BpQi9QeXJxV3lMRndoTjA4R1FNR0k5S2RzVkE3UG1jaG9tWTVpYUVrRk1hdHNRWDJra2JwbjNpcHlpRk04eDNXWHlCdmJ2OEFBMGxiQ0V0RUpadmtESWdaL250U1MyMGhnUmMrTW9UQUtpUGp4VDFyWUIrNWM4UzV0YkNLWk05Z0tnbFNzYXlhWERiNWpKMy9BRUdBS0RWaFBDNlhaVlVpUUMyQjN5ZjFvY2EyR3h0QU5OYUtuTnc1dUVISE9GcWJ1VENkYUxkamZmSDkxdk40UEJqMzlLSzl6OXZRcktQWDZ1OWV1amV4MnJFRWNaOUs2NFFVZWliWWhjWVcwQ25idkluaXFSMkk5QUZXT0JrK1VWUVVLU0NRQUJBRzM1K3Z6cE45akJMcmJkT0VCSlpqdmdEdDJINi9PbFN0Mkc5QzlsQzl5QmhSRGNjOFVaYVZnaVgxdTBiR2t0Mnprc056SGprNUh4d00xeE44cE5uUkZWb3V1bmdJc3FCNWd3TURNa0E4VnpaZHZaZU9qM2pwaDloY2hzQmV3N0UrdWFIRjlHMTJVbXU2bUxOeC9HdXZkWS80dHd2dGl1ekY2Zm1sU3BFNTVWRDdzejF5L2MxRDNRMXpiSkRiUkEvbk5lakdDaXFSeHltNU96eUlnWUJQVWlmeHBoQTF0eXQxWDh1R0g0OGlnMWFvS2RNdFRZTUV3SnRSakdCeURVVk5KL3FXY2JYNkhCYkJkZ0dCQUVnL2pUcVRGYVQwV3ZTOUdtcHMzaVZod1JJSjdIL2MxejU4cmhKYjBkT0ZKeHFpenVhQmZCdCtIYVV0YXkwaVo5Uk5SaG5mSzIreWs5eHFoWFRTV0FncklKSklnVEo1cnFXOW5OSnZwRWJsdTU1ZHFEYUpqYmJ4eWFEcjVEeWtPWHVtNnQ3b2t3dys4c0FqK1lybmxteHhTWlJZNXRsNzBqUkRRNmU0enVEZGY3ekRJSUhBcnpjK2I2anJ3WGpEaVdxUHZ0RDcwU0dNR3Vkb2VtRk43WVVJQUxIZ2MwbkVJVjdpcmFieFd1ZDFnTkFHUDV4VTl0MGhpbiswSFUxMHZTYjF3Rld1dVFsc0F5UlBmMmdWMCttd2ZVeUpQb1hKTGhGdEh6Vjk3c1dKSlljNDVKTTE5RHBhUE50OWd6Ym01dkJHMERrRHZUcjRFZnllSUlMZ0pPSXl2TkZ0QlNPQmJhN3laRzdnQ3Q5Z05lU1NrTXJoSTVCd0tXV2d4QkJndGhnY0FINFpwR3RoQ3FTZE9SaVdQWWZBVk4vbUc4QWJRQjFxaUlnOFIyRlBMOGdQSTdhY202MkpueWtmaWFsSmFHQjMzTHVXSUJZNUlqaWpGVVljMEFJdU5jYUlrZ2VwcVdTdWdvWjhUd2JRdUhOMXNpUjkzMzl6MnFWY25RM1JYdmNONlpZaWVlOG1yeFhIb1JpbDhoTWpFZmNCNys5VmlyMEt5cmVXdWJ2cDcxMEpVcUp2Wk1QQjM0Z2ZkeDNOSzE0TVJ0Z0ZvSndvM05UTUJJdnVlNlNPZTNwM29KVUJzdE5HbXhGdXZBUkVKZ0RKTVkvSE5jK1NWKzFGWUt0bGdCNFNBc0dEN0JIdGl1YStUbzZFdUtHdExxUDZmU2pjUUdibG80SjlhbE9IT1doMDZXeWw2cDFFMk45clRjazh6bkkrbGRlTER5VnlKVHlVNlJSTkpEbG9KOU9lOWRxZGFPZHE5bmhDdVprWWd4aU1jZldpbVpvTUZFOHdKL1dtRVlVR1ptUGNFZTlZVXVkT1ZlMWJiek51QVF6WE5OVTJkTVhhUkVwc2VWSWdDWUdNVlJNUjZMUG9qN2RjdG9sajRpN1FZa2Joa1Z6K3FYc2IrQzJIODFmSnBkSW90bE10a01HNzU5WXJ6Wk96c29oYzZheFpIMHloYmUxaUFSRUUrdnRWY1hxa3RTSnp3dDlBazBUYkF1MitRdkcwQ0FEbnY4YWFXZFBkb0toUXQxUFhYQnFMZm5idC9pQjI5Si9DdXA0WTEwY3Njc2hGTmZxSk0zbVBjd09QcFU1WVlmQlQ2a2hyU2F2VUNFOGE5UHV2KzZuTEhEdWtibklaL3FydHRBcGE2MEFDTmhrZktwOEl2d055a0R2OVpkZFBkUGkzQ0ZNU1Y0eGp2V2o2ZE9YUnZxTkxzejNVdGJkMVJVM1drVEcwNVBGZCtMRW9mbElUbTVkaVRPeTNWQ0h2Mi9HckplU2JHVUt4YlVyQ2tkeVRKcWNuSldNa2llb3QrYVE0YVJQSE5MR1k3UWpmUWtPeElJbmdETldqSldUbEVqYmJZSElQSmtqNS93QzZNbFlzUWQxZ1ZaaUJFNXozcFV0aEQyaUNiU3ZuZy9oTlNsNW9aQUxiTUx4WmVlODRxald0ZzhqU1A1bjVoUWVjZG81cVRYUVQxbis2d2duY3JjQWRxejBFZVFrdXFXNWhCbHVjZno4Nmcrcll5SXV3SUc4a0RNRDIvazBWcm96QThqZ0JRY251ZllmclRvVmxicjduaVhZQnlPdzlLNk1jYVZrNU1VYVFxa0hrSGtWVHlBR3g4Z1djY0g0MEFNbVdDQWpFZ0V0UGZOR3IyQzZQV3p1QUdETFpnUm1pd0ZyYWh3dDJOd1hhcWoxT2NrZTFja3RlMHRINUphblYzTDExN3JzQ0lnWTdVa2NhU3BGWE50MnhHOXE1Q2c0MmtBS2E2STQvZ201L0lqZnVHNDJUa2tpUFQvbXFwSkNXMkVWU05PQ0ZnOFFQZ2YxcGJ1VkZLcUpBTHVVczJDZmIycG02RlNzTk00QlBJKzk2VTZKeUNLNTN6QUkyL3dEcmlpSVAyN3hRRWJoSUM4ZHVhbEpXVWpLajM5UWR4VUVqL3dDbzRGRlJBNVdGdFhuVytMZ0pWd1F3a2M1b3VLYXBoVW1uYUxOdGZkTzFGWlR1aVk5djRLaDlHTjJXK3RLZ3VtMWQ5bUUzU1JFQ2ZqUy9TaXVrSDZrbVRXOXFXbndyajdRWXdTS0gwNC9CbmtsOGpYVWdvdnJLVG5tWTdVRzIwQ01VTHJiVUZRd0dlQjZWTnRzZElKWklMSXU1ZVkzQ1AycWNyRG9qcTd5V1ZXYjhnRDd3Z2srbU85YUVYSjZRRzZLZlYzdkd1THRYdzAzY01aWWsvREFycWhIaXFFYnNXUzB4dHl6aUo5ZUtwZHZTRmVqcVdJTzR5UTJaNCtsTTJ4VU4yVUp0aGQ3eC93REFITmMwbnZvc2tIYXlNQm51YlNJbVpINVVuSi9ZTkZmcUVDc3hMajVtYXZHVmlOQ3hZQzhvWThqZ1U5MmhlT3hNM3Y3bHhOZ3ptWjlLZEx5Sys2Slc3aE40YkJ3Q1FKOWFEam8xaE5PQ1NXSDN0dWU5Q1J2SVJDZkRsam45TTBqVnNZWjBWeiswYmhqamlwelc2Q2hpekl0c1dBZ21kcC95UDdWTjlqSGxscHVYQ1JKeVIzK0g4eFE2MGdzcjlUZjNFcWtCRnpnMTBRalcyU2JFNTh4UGZBR2UzRldFSTdkeklEd3Y4L1NzekFiaGdLWjVJSi9uek5GQ3NnKzRzcEdBQkFINC9XbVdoUWxyeXFydDM0SHp6U3Y0Q2l5MDJOT0hMK1RCQ3h6QS9ldVdmNXFMUks2NXFqdTIycHovQUpUR0s2STQ5ZTRWejhJR2lnM1lMQ1RKazkrY1UvNkMvcWV0b1hlU1FXOTZEZEZJeEorWkRCTWdLREh2azBpMk8xUkF6eVNZUGFLY1ZoUEtGWDBEUUkrVk1tSkpCVk80U0RqZys4eFRFaDFWTGtnRVJBL0Q5T2FrM1RLSldqdHNHZVY5aDYwd3RFMFhiY1h4SUlFZTJQYXNFZXRobXRnQ09NeFU1dExzckNMWTlwYk4xUm55a3pKSW1BRFV1VVN2RmplbkRCVzNYeGxqL2ovdWs1cGVET0RmazcxSzQxeStrWkE1N3dhRHBBallvWFpNS0lFL1Nsb0xJNnpVUHA3Q2xFM1hDY0syQVBjL3p2Unh3NXZmUXNuU0ttNDMzV3V2dnVrWjloK21lMWRLK0YwSS9rS3FYRTB5M250a3E3bFY4dk1SeFdmMkFpVjVXZTRvQzJ3dTBBaFJ0RThTUit0SzVWdGhVRytnbHBmSXBQbEZ2N29FbWtlUnZRNnhwQnJhMkF6Z1N2SUJNaitjMUtVcGFLS0lWdkFjc0xXcGNrQ0dZR0FQaFNYSlZhTlJWM1Rmdks1Tm9YUVJBY3gyL1BGV1hHTDdvV3JFN201Ym00ZzdTSVlBWlgrUlZFN1FyVkNkd0VYcElNSE9mYXJMb2srem9EQW82NEJnejNyUDROWGtMWWVMYktBRjVBQi9DZzE1TVNrdGRZUkNqQUEvS2w2UVJ5d29kbFF6c0VGdjJxVXJXeGtQM1YyMmk3aUY3SDErRlJUdDZHSzNVMzJjUnd1UUI3ZC8xcTBZVUsyVjkzaUJJWGo1MWVLSnM0QVNZQXdmem9nUFhTUW9PSW5BRlpHQTNGYjBraitDbVFySUVnYlNKQTVtUGFzQWtGWU1pQWVaU0lIY2Q2RjZzeExVM2g0UkNUdFBsRWVsSkdHOWpjdENMTTB0QkczMjlLNktKMkZ0amNWQkVINFVqWldLR21XTGhBNUpuQTlmK2Z4cWR0bHVLWFFCeVFWSXlDcWdtUGFtaWhKV2ptNmN3d0pnWlBOTlRGc211VWc1V1RTM1FhR0xCaHdER1NPZTFVZlJLdDBXRzA3aVBYMXozcVMyTzNWa1Y4dHlCNng2OFU0ckNyMllRRDM3ajZVQWxocDdlNGdiempFQW1XcWMzNUtZNytSL1RJNjdRR083elpaajVSVVpVV1YwRVc1Y0VuYVNTWk1BMVBnSGtNYWxDcnVSOTZrbExab1JkRlpxQ1dIbjhxSVN6R1l4M05OSHVsMnpOUHNyL0VhOExtb3ZtQVQ5MG5BQXdBUGg2MTAxeHFNU1BlMlJ0S0dPNTBZRThERVFEaWkzeFZBcHlZUHhnaGNwZzRtNFdPSS8yT0tIQyt4NDBnbW52bTJ2blJOb3lIdlNDUms0QTVta2xqNWRQOXY1b29wVnYvSXZkMXlLR0RzUE5uYmJhTVZTT0Y2RWxrUnkzZDA5eVUvdVRqa2tUUWFtdDZGNVJQUGZzb3k3V25KOHU2VFErbk5yWXluRmRIanFDOTRrWlhrS0JHWm9QR2tqS1RiQjNIbFN6bkpPSTdHc283cEJ0ZHNRQmFBb3puUDEvd0IxMEpFV01iaDRJVGdnWStkSWx1eG05VUNiYkJ5UHJQZW1vVU5wVVpnWUlPQ1NUZ0hGSkpwQlJiV3RsZ00yTGx6ZEpic1BsWE5LNU1mU0FhcTRicGN1NXdPRFRSang2QTJKRWJqSjR6QTlLdUFXSUpCSmJFbUo5ZjRLYjdDSGtPMVFlU280b2dPWEQ1eDZ6K2xCSURPVEJNOXhnbmltb0RBbm1KNDVqOEtZVVBhdVNiMXdqSk8xWlBNak5UYTZRZnVLWHpLaGZZSDQwOFVCc0hFSDRVd1VNV2dBQ3o4ZHFuSXRIUXloWXRBMndZSkJxVFJaSHJLazNFa3pqaU1MNllvUzBqSmZjaTZBV3lySXBFNGdmdFRwN0VsRkM2bmFDQ0RrbmQ3U0tvMVpKUGlIdGt4Q3d1SVB0L3FtUWtsUThiekdGdWZQNmMwdkVQTHd5TTdpVG5kSnhIenJVQ3hsQ042OEVBemdWcUNXR2pjZU5iQlVzSkkvR3BaRnBsY2VtV3ZoanhrSUNmNWY1SDYxQlBUTE5kRnBvYkhpMlN6RlF3WWdpQ1lwTkFkaVBXUzM5VGNmdWZOQ2p1VFNyNFk2NnN6T3Z1blpEa3d6Q2ZlTWt4OUs2OGNWZGtadDFSNjAzaU1pUEEya25hRDc0bjBwNnJvVnUreWVwMURaSWhSSWp2dHorTkpHQ3NhVGRVSzI3VzIwMTA3WjRRRUVqZk9USGNnSEh2V2xLNUtLL2lIakdvMldPbTZTSExMcWx2MzlZY3Jwd056a2VyQUdGSHhOUXllcmEvSlNqOCtQNmZQOUI0NEl2YzdiK1A1LytoajBPOXB0N1htMG1oUStiWUNMci9oZ1Z6djFrWjFTY3Y3SXNzRFc5TCs1eGJHaVZDcTZ1OWN1WVBtaFUvSTFua3l0M3hTWDdzRHh3NmJGOVIwMi9ldCtJdW1GeEJKM3BkQlBmMkZWajZoUmRjcWY2Q3ZEeThYL0FGS3A1MDE0anpGVHl0d1FSNjU3OTY3RTFrVi80T1dVWGpaMisyNmJpUUJ0a2x1VGowcFVxOXJEZDdRbEVsb0VSbXJMb20reVVrQUV3WnlQNTg2TkdJcUNNa1FJNzlxVnMxRGxpNExhQUg3a1lBeG1hbTFiQ0c4UXUyWUk1elNWUWJCbGtqTFlvMHpBYnR5UU9QaVRWRWdBR0xFOERKazB3cEM2eEFFRDBqNDBVZ01na2xWQmd6elBiK1JSRkpYR0tpQ01SZ1VGc0RGeTB3T1QzcHhTYjNDcktnaUJ6SHFhVks5aDZCTVpNZThUT1lwa0t6b1luQVVldFpyeU1ndHRXWXdWbHNqSEp4VTVPdGw0SzNRUzRtd2pkQTlnWjc4Zm5TcDJPNGs3TndXandoWWMrSUpuNUR0U3lpMk11dXoxN1VieXZtT01rY0FaN0NqR0ZDeWxlaGE0VzN1RG1Ua1JtcXBhSXRoOU93SkV3eWc1clBRRTcwTXlIdkZKVEJNUzNhYXl2c0QrQWdESzdTTXpFeEUxakJSY0twUFB4T1RpaVliMFdvQXZXbnpLc0RCeFU1UXRORklTcHBtaHRYa1pseUZNc0RqRXh4WEpUM1oxYThGajAzeGY2Y20zY2RRV003UklKR1AwbzZSR1Z0bFYxbTkvZFk5eTBnL0xQNTB1T05sSk9rWjNWN2wxbTF6aFFEanQvTVYyWTl4dEVKYWxUT0VnTEFJQUFQbU5HaldDMUxrTU5nbG5HQjY1NS9Lc2xZVzZMblRCVWRiaFZqYXNmMnJjRUFtNXl6VDdFOCs5ZWZPOXJ6TGIvVHd2Nm5aQ3YyL3lXWFRkUnNlNHJMczBnSGlYTFlQM3lPTTk1OS9mRmMyYUZwTy9kMGkwWFFHem9kZDF6VitJcXZic01jWSs4VDZlc2Vwd0JXbGx4ZWxoWGIvbjgrNEh5eVA0UXpkMFNkUHVMYjBkbXpxVzJ5MSs1ZlMyZ1A4QSs0NVB5QXFjY3J6SnViYSt5VGIvQUcvN0M0Y09sWURXTHE3WFR5Yit0czZmVFNGVmJOc2xXUG9DMEUvU3FRZU9VL2JCdC9kLzdmN2dhbFczUlczK2k5U3VGWURndXU1RXZydGNpT1Fva2dmR0s2SStzd1IvNDYvY204TTVlZjNLTzdiYlR1eUYwTzd5dEhBcjBJdFpFblJ4eWp3YlZnMHRiYzNTVlBhZnJQNTBiK0JFdms0aFZBR2xKeEFKNzFwWDBGQmJLQzFjM09lL0k3VWtuZWtZaGV0amRDbmcrWGFlQlJpOWJBMXNrMXovQUJNajEvMVdVVEFpNytYbWVaSHRUVWF5TzRSbjA5S05Hc2lKQkVlbEdoYk9STTR4em1zQTREQWllUkVUbjEvV2gyQUJkdWVnbk1tblNGWnkwMEV0RUFVV2dIbWxpMHpXQVF1QWJTU1kyNStPUDlWakIwc2lWOFR5Q08zSnlhUnkrQ2tZL0pKeTl1ZkRHd0VSelAxcGF2c3FtMTBTQTNxRkxnRC9BT1Y1cmRib2JiMVo0MkVVbVh1L0hiL3VoeWI4SVBGTHlEUUJzRnNjWUZOYlhnVjB5V3lBNGhqRFRJb3FRamljdE50SW1ZRURpbnF5UWRCTnhRT0NBQkk0TkFJWXFVTFcxM0FnRUVOai9paFlhQzIyTnhkck1Cc2tyNlp5WW9vRERJUXJNRkM0NHh4Ny9sUU1pMTBsNHV5eVFDVE1BYzQ0L3dCVkZ4TGNxbzB2UmIwYVFxRlJpcmtFa2ZDdWZKQ1RZNm1raWw2MnkyYjVQM284eERDT2VCV3dwektTYWpzb0hsdFJKKzlpVFhhbFNPWjdaSm9tSmphWklJNTlxRE1oVUF0cnBjbGtrbko5Qk5HV29hREhjdGw3cFZ0dmNzMnZFVkZWUVRPZHpNd01ENW42Q3ZQbTJrNVYvRWRrZkNOTDRHblBocGZ0aTU1V3ZOUDNRc0hKQXdBQkpqM05lVnptN2NYOWpwZElqMUxycHVkT3M2WHBTWHJiYXBGOFYyZzNMZ0l3Z0ErNG83S1BYSnBzWHBFcHVlWjN4NitQMSs3KzV1V3RDZWw2ZmI2VHBScnRadEYxdi9Edk0rSWVDVi8rUi83RG5nSHZWWjVubmw5T0hYbjdmOC9ieDIvZ0NYRldIdFhiak5wdFphVzVxTmJxanMwcHZBSzkxcGlVQXhidEx5ZUpNeVNBYVdjWXBPRDFHTzVWMHYxK1pQOEF0OEdUZmY4QVArZ3R5MXV1TDBmcG1vYS9ydFRQOWRyZ1pMSGxvUHArZUtTR2svVTVsVVkvbGovZzBtL3lSZTM1TkY5bHZzVG85UVB1RmRNZzJYTDRUKzVlWWNxamY0cURFa2MxemVwL0VNbDIrL2p3djFYeWFHS0s2UG9HaCt6WFNORmJCMG5UdEloQ2ZlOE1NVDhXTWsxNWsvVVpaL21rL3dCeXFoRmVCUHFmUTlMcUZZWHRMcDJCbVFiS245S09QTktPMDMrNHpTZmd3L1dQK24vVHRTV09tdGYwVjAvNVdSaWZkZUs5VEQrS1pZZm1mSmZmL2NoUDAwSmRhTVIxcjdEOVUwSlk2WVc5VGJIZFBLMzBQNzE2dnAveFBEa3BUMHpseWVrbkg4dXpKNml6Y3RNVXUyMnQzQk1LeWtHYTlPTW95M0U1V210TUN3WUhFZ3hKbjBwdEdhQWtzSk9RVFRVaFdTTGVXWUpqQit0YWhRa2dBRTVQckZMUm13TEhoNStvL25wVEpDdGl6a3JBRSttRDhhWklWa3JZeW81QlBITlpoUktZbmVRT08yYUJqc0I1aVFCa2J2WHZXNk1jQkR0dTk4KzFhdERKN0NLaFlBRWdIbWxiS3BXR3RXeEFKVnljSDRWTnNyRkpIYnFsV08xU1FlL3JRVFRDOUMvM2Z1ZzhRWkVWVlV5VXI3UkhleXRJTEtSM0ZOU0pXRXQyM2plRllJQ0pZcjM3Q2F5QXhoVm00TnU0Ky84QXFnd3BXSGVXdU9YWm0veTU5cUFWbzg3ejJreHh4Um93Y0FaQWtHSjQvbndvaWptbXRNVnVtU3JJRmdFWk1tREh3cEF5OEYvMHlHc0VvSUJQK1JnekFxVXRNWkpVVi8yZzNIVnFHWGFRZHJENFZQMC9UbzZNbmdwM1BtTGNDSnJxclJDOW5nRmsraTVNOXlQNStGSDdBcnlMYmcxMFhBVEV3SW5HSW90YW95ZTdMZlJzQTczUUJOdVNDUjZEL2RjR1dPcStUcmhJdWVyNnIrbjBXbzA5Z0tiK3FuZTgvZHRDSVgvL0FDZ0g0Zkd1SDAyTG5OVGwxSC9QL0IwWkpOS2wyRlVXOUN0L1gza3QzdHBUUzJsWXh2TUNaOWhuOHU5STd5MWlXdTIvM0hhNDIvNkNPcTFRNnoxSjczVmJyZUFqWkNEYWRneHNRZHBpUFlTYXZESC9BT1BqVWNLMi93RFB5LzAvdVRjdVV0OUlucWRaYzFRL3FyeUxidVgzWFQyVVFBTFpzb1I1RjlBU1ZYNEJ2V2xqaVVQWXVrbTM5Mi9ML3dBL3NNM2Uvd0NoYS9acTBkUFo2bHFTUUx4VVdsYmd5N25qNlJVUFZQazRROGQvc2pSMDJ6N0IwZlpwZEZwN0NZVkxZQUUvajlhOExKY3BPVDhsa3FWRm91b1ZiU3lSd01WSGlNQmE3djNFKytQcFdvd3E5cGM1Smt5SjdVMFFzcnRScGd6Y1lxaWtFVTFQU2RGcnJSVFdhU3hmVHVMaUJxcEROUEc3ZzJnT0tscVNQbnYydCt3V2wydmU2Uk5pNE0rRVRLTjdDY2l2WTlIK0t6VDQ1dHI1OG5ObDlKR1N1R2o1bHFOUGMwbDgyZFJiZTA0L3hjUVNQYjFyNkdFbzVGeWk3UjVzb3VMcVJBa1FlWmowcGlkbmpMVE9TRG5GYWdNamNDcXE1emtFVUZabUtYQUNEUE0xUkNNOEpBN3FBWWtjMXFNZFhJaFRCT0pJbWhYeVk2Q04wc2NBUVpHRG45cUZCT0RhQ2hpU0lKQnJCUWExZE1DSW40Wk5CeFJSU2IwRlJuajd6Uk1aUEZJMGlpYk8zZHhRRW1UOGZlZ3FzTHNBeTRQM2hCcWlvbTdEYWV5MXdHR0FJRXl4ai9rKzFGaWZxZDJOWnVRUjUwRWtBVEVmSCtSV0FOYVMzdjNFUGJUYVMzQWdqT1JQMG9TTWpxYldGd0JXQ25BWWNUSEg1MHJSUk5IbVU3RmJkbmlUbkdQOTAzUUVyR1VWbXRnTDkwRGJHQnp4UzliQ25laGxBU3llWWlSRThFWU1VRjJDU05EMHd6cHQzaXFvSmtCdmdLaE4weWlWb3JQdEl4R3R4R1dMZlVBOC9XcCtsNks1UEJUWEJMQTRPK0s3THBITjJ6endpM1NEZ0VnQ2VRQlNKdDBPMGxiRU5SSzIyVWR5RDh2VDhhc25iSlMwaC9TYWx2Qks1RE1DTWlKNHJueVJWMlh4c0wvVUZYM2JkeUtOekE5Nmx4MVJXOTJXbldOZW1vdVdSYUpheFpZT1pFQm1aZ1QrRUQ1Vnk0TUxnbmZiT2pMa3VrZ05wa3RxejNBSXVhaGxnK2dINVMzNTFuY3RMd2wvUDdBVFNkdjVHTlhjVVdkUGJWbFpkT05vS21RV0JMTWZjU2NmQ3RpaTdjbjUvd0NsL1lFNWRKRnBwZFViTEZWWWJHdTJiaEh0Sk1pdWFVT1ZQNFRLZko5TTBYVWtaRWhodEMvODE0czhiUjBhR2s2bWhWVmtEaWsrbXpET24xVWt3WitkSktJUndYZ1JqaXAwRm5HRzRTRG5nNG9XekM3SVludCtkTnlNS2FqU0M0Q0NySFBhbWprb2FpcTZuOW05TmUwaFMvcHJXcHRuSnRYVi9GVHlwK0ZYeGVybkNWeGxUL243aXl4eG1xa3JQbm5YdnNBZ1c1YzZIZnVCeEpPbXZpU0I4ZWZubXZiOU4rTVM2enJYeWpneWVoWGVOL3VZWFdkTjZocGJyTHFkSGZRZ3dZUWtINEVWN01QVVlwcjJ5Und6dzVJdmFLNTJPMGJqSGFQU3JFV0NMVEJnNGtDTTBiQWVZZVVrWVBNVnJNVFEvZStFQ1JNMEd3b2c3Z1Fkd0VZaWFJRGlrbjdrSDJHYUYxMkZKdm9tdTVDd2RHVXgzVS9HaGFmVEdxUzdSTzNjYkI1elBGQm9kU0dIY09oOGdpTVFhVldtVXROQWNpU0ZuTk4rb2p2d0Z0M3JpcU5wMkRNd1AwbzhVaEhKc2J0MmI1WHhiak13dkR5M0RrTVJISm1aR0I4S0QrQVdkU0FKdDdBMGJHQUlFbkV3TzAvdlF0ajBxUEY1YkRnR0FXRXl1TWpQcjJvcm9EMncrcVY3Rit3dHhDaGRRMGM0UEhGYnNDZkVLcWtXMzJnQmxhSTlCeFFUR2ZkaExWMExmZ2txQkVaN1RtYVZJMG5vdU5KZjJhZEJFQ0JHSnFNbGJzb25TU1lyMTBsenZCVEI0RUNlM0ZEQzBuUlNjVzFaUlhMbTFwQk9ET1BuWFcxbzVvOWtWdkxEQm03azh4OGFGRE93R29ZWmd5T2VhZUlra2QwMXphOGRwRUFtbHlSdERZNVVPTGNacmJ5UVBJWTl4VUhHbVY1V1NhK1hDazRBQWtUL0FEMHBGQ25SUnl0V0Z0M3Q5b0J5bkJNRDFKbWc0S0x0QWMzSUpldk1OUHR4dW1mWDYvU2hHT3pOMmh6VGF6K28wUGhzUE1wa3djNEdQMHFFOFhDZkpGWTVMalJvZW45YWExWkNhZ3NyeEFIYjR6WEhrOU1tN2lYaGxzdGRCMVpibHdMNGl5WWpQUHdybW5nYVZsRk5NMDJodk1Vbm5GY0U0bFVXdG0vRGM1UGF1ZGpVT0xlaVdKbjUwT3pORUJxQVc5UlAwb09Ka1N2NmhWdGxsNEZMR082R1lscE9yV0x0N3cyWUVnOEdxVHdTaXJNbW1XT3UwR2w2anBZYUE0R0dVd3crQnFVTWtzYnRHcjVQbG4ybzZMcnJHdDhJYXdKWXVEKzNkY0dOM1lOK2hyMi9TK3F4dU51TnRlQ1dXTXE5cGo3L0FOaCtyK1B0c3ZvN3JsdnVlTERtZSsxbzkrSzlTUDR4NmVyZHIrZlk4dCtpeWRvYjZUOWhyR29SMDFtdnVqVnA5N1RXa0NzRkU1QmJtUGhVUFVmakVvTzhjUGI4dC83RlllaFgvd0J5STZ6N0dhRzJwV3oxRy9wN2pFQkRxcllLSFA4QTdMM3JZL3hmSTl5Z212czkvc3huNkNQaVRFWCt6bHpwWkRhM1RtK21ZZFNkaEUrMlIycXEvRVZuMWpkZjUvdUdQcEZEdFdhSHBkN1MyOVBiYlRqUzJsakc1Rkt6NmJvL0UxNXVkWkpOcVRiL0FKL09qcWhGSmFRTHFkbGZIWmRmMHJRdUdDbmQ0ZmdzeEhvNkdQVDBwOEdSOGY4QVR5UDk3L3N6U3h4YjJrVjQwM1RnNU52VTZqUTNSSkZuVTIvR3RtUkgzaG44NjZQcTV2TVZKZktkUDl1aE9LWFRyOVN1NmowaTIxbTQ0YlMrSXNFUFllUS94RmRXSDFUVFMzWDNJNVBUcVN2ejlpZ3VvMW9iV01kOEd2U2pOU1BQbEJ4SjJicWxUdUE4UUVaNG41MFhINE1wL0lVWEFwRHdQS1lVTDdkL2xqbjFyQWRlRFc2ZExGN3BPbU40aTVaUTNMa0FoWW50QTdFZ0NLWHlMVkdjdTIxczZndVZBMndTcHlSMjIwYkN0Z2l6cGZONkZYZk1BNGprUlRKS3FBK3lWeEF3VjB3RmFDU1IrbFl3NHNnbHRzeUpIODljVUdGYk8ybExYaDNYMzdVamREcU5vZnUzYjFzcUxkeGdzU0FhVDJ2dEJxWHlOZGF2NllPcVd6dnVraWRvRXJCNzF6WUlUYnQ5SFptbENLcnlaTzhDV0lFc1ZQSHJ6WG9ubm9pYlVwdjRqUHh4UXNZQThCQ1NhZEU1SG1VZ0FxSldzQ2d5M0x0b0laQkI0STdVamdtTXBORVBGM1liY0Q3OXFYalE2a002WFZGU2VPQnlPS1dVTENwQkcxQWUwODdad1dCOVo1b2NhR1RENklhaTlyTGFhSkh1YWcvZHRJTnpNS1NmR01ibjE4aGpiZWpaYUQ3STlXMUtwLzNKN09pWGphM21jL0lZL0d2S3lldnd4ZFk3a2RVTUUzM28xZWcreXVrMGVrVTI3UnVQSC9rdUNmb09CWG56OWJPY3R1aThjU2lndWwxQnRLOXB5UWJlSjlhbE9ON1hrdkVzTEdxem5pYTUzQWF4dGRWQ2tITW50U2NBMmNOMUFCY2tpS3lUNk1IVFYyZFFvU2ZOOFltbGNaUjJFekgyczZCcXhaL3J1a3NWdUprcU9TUGIxTmQvcFBVd3ZobDZKVGpKYmlWUFJ2dGxxTklGdDlRQkM4QzRPSjlENlZiTCtIeG52R0NPYnhNME9yNnBwK29hRWc3YnF1SWlKQnJoV0dXT1h4UjBwSm1WdldkdHRFdUV2Wlg3b2NrN1I2VjNKcW0wdHNsT0RUVFhSMjdyTmRwRkNHNE5UYUE4UVdiNjd2bXJjeG50VWxpeDVOMVQrVi8raU50YjdBNm5xVDlUTnhrUkJjMmczYlRmY3V4NisrT2VhYU9CWUtUZjZQNENtbXRDbWp2dmJzbExWNjhsZzRYeEhrMldtZHA5dlJvcDhrRktWdGIrM24rZkFVNkZ0UnFEYTFST3Mwd0JBMnU5cnl1dWVUMlllOVVoajVRLzA1ZnYxL3dCeXA3TEhTdmF2SmNzL3dCUWx6VHRFS3g4cEJqdHlwOXhpdWVhbEZxVlUvNSsvd0RVYlRSVGRUdHZwSGEyMFhMTHhFbVN2d3J0d1NXVGZUSnpWYThDS0piVjJaQzVFL2NNU0RYUzIycVpCcXVpczF0bFg4MlF3TWJXNzg4VjE0cE5hT2ZMRlBaVGtiSFpneGdldklydFc5SERKVnRCUTdKZVloWXVOSGVDSi9laldnWHNkdDZ1OGVubXd0eTRiYnY1a0I4c2pJSHh4U1ZVckgwMFIzZjJVV1FRWkVEbGM5eEhQNlVYMkJhSmVJUnRBRTdZTXhQMXBrS3dqTUFFV0Q1VDI1RkJoUktTKy96Ukp3SjdSL3FnRmZBem9nd3dHSUhCSG9jVktiM3N0Qk90TWV2M0Ntd0YrVm5IeE5KU1lkb3I5U1p2M0M4bGkvYzk2dWtrU2JiRUNWVm5VbnpZSS9hbUJwYUkzbklSZ0FSSk5aQVlCNE1Gek9aZzB5RkR5clRJYVQzbVJTdGpVYzJxTnBCSUhZS2NnME9URHhYWUVsUklZRXRnVFI3TmZFaXdXU1dVNEV5SkUxdGd0TWU2Tm92KzU5VDAyanQzRGE4Vm9hNHhuYW95VDlCVXMrVDZPTnphdWltS1AxSktLUHJtZ3RkSzZIWVhUZFB0S0RIbmM1ZHovd0RUY244QjdWOHZsbGw5UytVMy9zdjBQVmhDT05WRkQvVDJ2NjNWb3FRWUlaMzdLdjZWS2NZd2kyUFpxeTIrMzRWckFHUFd1Tkx5RXpmV3RGY1VtL2F4Y1RrZG1GZFdIS243WkdyeWluMHV2TzZDQ0NNRUhrVmVlS2tGT3kwdGFyZEJCNDdWenVBeFo2WjdXcFdBZTBSNjFDU2xGaDBVM1dMR3M2UHFQNnpUcWIra01Tb3l5ZnZYVGhsRE91RXRTRWxjTitDejZWMTYxck5PSXVCcHFPYjA4b1BZOFpLU3RGUDlxZWgyTldyYXJUS3EzNGxsSERpcmVtOVM0ZXlYUXM4ZkxhTVJiYTdvR25UWEdHNCthdzU0ajA5SzlTMWsxTmYxSlJrNGRmc1cyajZsWjFRZTJ6YlhCOHlOOTcrZTljK1RDNGU1ZEhUREtwYUlhbTc0VEpiTC93RGsvd0RFL3VNeFM4YnVTOGRpVFhGbExmdkd6cVBGSGwzU0NBY1RYVEdIT1BFNTNMaXhtOWV0dnFkeU9FdUVFUTMzWEdNR294ZzFHbXRGT1NiRFhMUzM3Q0MyR0RLU0FaOHkvd0R5ZlVlbFRqTGhMM2Z6N2p0V3RGRGREQnpjMDdsTGk1S0x3ZmhYb3hhcXBLMGN6ZFBYWkpOWUxxUmVCM3J6UEgwcEhpNFAyai9VNWFZdi9VV2lYOHJBajBxM0NTRVUwOUVYSXZXV3lBUU9lS0t1REJLS2xzb05TTmwwa0RCRUdPSzlERzdSNStWY1pBMVlDMndHNE1Uek9JL2VyV2M1SzNjQjJ5Y1NOMDhSUThodlEwOXc3QkprRTU1d2F5MEZ1eVZpR2FKQVByTkdoVzdDMzUzR1NUQmlTZS9lZ0ZXR3RXOTZxTjV4OTdINDBqWlNLTEhwNDMyV0Jqa3g4Y1Z6WlhVanF4UnVOakdzdHF6V3p6NU9RUGMxbE0zMHlxMUxsN3J0dU1razRyck9NcmdRU1NvanZ6ejhxWXdRRGVucVFJajFvWFJxczhTdkF5Wjh4amtqdDhLWFl5bzhRSGdoZ0l3QVRXdWcxWjZQV1RtYUZtb0c2endUQjk2S2tLNDJEZE5vSms0NXpUV0RpYUw3RFdkM1d4Y1lSNGRsMmtlK0s0UHhLZFlhWGxvN1BSd3FkbTQwdGk3cjlhYkZnQU1jdGNJa1cxbkovd0JkelhpeW5HRWJmL1o2TkdwL3E5UDAvU3JwdElDTFk3a3l6SDFiM3JqNHZJK1VnSlV5MjZUZEMyQmR1NWQxa0w3ZHE1OG5kSVlEMUFtNExqT1JFZDZNRjhCNk1aMW16Rjd4YlFnejlhOUhETzF4WWtsNUk2TFZXN3gyNTNEc1RrZkdqa2c0aFRzbGMxK3A2YnFFdURjOWs1eGtqOTZDeHh5cXZJTGNlelY5SDZ0WjF0Z0JpcnEyZVpyejh1RjQyVlR0YU12OXBPajNPbWFnOVE2UVFMUjh6MmQyUGlQU3U3MDNxRmxYMHN2N2twd2NmZEVoMDNySTFpS0M4R0lLbmtmSTFzdnB2cHNhR1JUQWZhUHBpYTFUZTBZQXZxUHV5Zk5pdDZiTThiNHo2SHk0K1N0ZG1PdmlkVGJ0dnZ0WFZIbFpUQlUxNmtYVVcrMGNkKzc3bkZ1WGpkUTZtNnorRVN3aytsYVNqVDRyc0xuSjZsNEYwMVR2YVlYQWM1QTNURk84YVRWRTFOdEhPb1hRRXRrTXhKQU9HN3hXd3gyd1pYVlVPYURxVDIwUWx5ZHVKM1pQdFVNdnAxSnVrVmhscGJFdFRkQnZtNGpiVzV4NjFhRVBieFpPY3JsYUlNNXV0NGxzZ053VnB1S2o3V0RsZTBLWDJVWEN3QmlCQjk0NHEwRnFoSlBkZ3ZFbTM1R2luNDcyYmxyVEs2NHhETnV6N1RYVEZISk4yOWdrMnlKRWpqUHdwdkJKQlZmY3huazlvZ2ZHaWpXTUVxYmUxeEFCbVI4SzNreE93NXQ2dmV5aGlRWXp5U01mejJvUG9LUk1Ba2tLR1lBKy9OQ3hraXlzMjlvRndRQkJtTXlJL24wcFdNdGpYUzRhMXVJQXprRHVCeC9QYXVYUCtaSTY4RDlyRzljd054TnFKOXdUdWFoRHJZWmJabk5WZWhtZ0VaSW12UVBQRWd3TFFjY1pGTnVnYXZZVkx5cklqakhGSTAyT25RUUh4TUFxQ1R4TVVOb04yVEFVR0NRWUhFRTBqYll5SXJjR2R3SndRQVJBSDByTk0xa2Q3RWdTUkEyK3RHdEdYWjFsSVFMbG5IMEZCTzJGNk5MOWo3aWFlOWUzQTdybHZhTWZPQjlLODcxNmNrcThNN1BTUGIvUTJIU3RiNE9oWkZ3V1lsMkF6UHBYbDVNYmM3OEhYeThCK25nNnpXcXJTYlNtWFBxSjRwY24rbkg3bVd6VjZTLzRyWExqaUxWdkdPQ2ZUNUN2T2txcERsWDF2cXFsU3E5ajlLNk1XSm0rNWx0WjFMeEpEU1RPQUs3c2VLaWNwZUNqMUdyTnBoY3R5TGc0cnJqRGxwOUVtL0tIOUoxdTNxclpXOENyeE1Hb3o5TTRPME1zbklIcDlUYzBONDNkSXhLSExMMlA3R3RLS3lMak1aWEYzRXRIKzBhNnREYlo4akcwMXovK0k4YnNvc2lrVStzdGYzdkhzM1RidStxbVo5cTY4YzljWkswU2xELzZqb1o2VDExZjZyd3RTQ2w1ZU00WWUxVHorbDl0eDJoOGVhM3hscGdmdFJZczZ1eWRkcGwvdklESlU0WVVmU3psQi9UbDBIUGpVbHpYYU13K3MzMkhZNVlnZ1Q3MTNMSFVramljMVF0WXVRaXdUQTVxazFzU0QwUTFGM2RlbmFTRUdNOFUwRlVmMUJON08ycjRGdk80d1o1b09EYkZVaUoxTEVFZ3dCMnB2cG9ITThMNUN5TUhuK2ZXczQrQThpRis4R0RFbm1qR0xSbTlDWXU0TWR6eFZhSktRQjIzRW5OVVdpVGRrVm4wNW1qWW9STjBzY2t4UnMxRENRU1c4MEVZelFjaGxFT05ubEVRMlp6M2owK3RLdGhsb2tsMHJ2RnRZZ1ozSDMvQ2l3eEg3YmIxbUdiQjVBK2Y2VWxsS3AwTWRPdUtpamNIRnVUdWlDWmp2OFRGUnlLNVdXeE9vMGhuVmJXZFN6UWRnOUQycFkydkFaR2Q2bWY3amtnd1NmeHJ1UnhNRzdQZXVDNWRMTUFGVUdPdzRGSHBVZ0pFcmRraGY4YzhpS1J5SG9qY3RzT1ZFZXhraXNwQWFJYnR1RElqMVBGRUJ3RStwT0t4Z2lGeXA3SGswckhpSHQzc0xNZWttbGFxdzkwUDJMemdveWhwVnBubjRpcFRnbWlrSnVMdEdrNlgxRGFiM2lGVEkveDU3VE5lWmx4VlI2RVpjMW8xUFFHVy9iUkxaamVkOXh4L2l0ZWI2aDhYYkxRam9kNjUxaExWbndOTENXa3d1ZnpxV0hBNVBrek4wWVRVOVQxRjR1VXVMdGtpVG12WGhoakhzNTVUY3VoTUIzZmMxOXg3TEVWYTB2Qk44dmtFMm50czJick1QL3Bwb3JJMTROd3Z0azIwMXRCSjJnMFBxTm00b25hdE1UdFM5OEFUUGFsY2w1UWRycGtOVnBIUExnZHdWaWFhT1JMd0NWdEFWdjZteUFwdUxjSC9BTmMwWEdFdDFSbE9VZFBZbnJUYzFBQlhhakxrSHY4QVdxNDZpSmtmTG9GYzFtdUdtYXliaFpEZy93QzZkWThmTGxRcnpaRkhqWlZiN2lqYXdQQmdSWFRTZTBjcmJXbVRYVUZGNGcwamhiRzU4VUJGNG5jU2MrOVB3RTVuUmVPMkRXNEc1Nk8rS05rQ00xcU1wRVd1WU1BNC9LdFJ1Und1U1ZqazgxcU01QWlZVUNpaEd6Z1k1amozb21zbHU5NVk5K0lyQkNLUEtZSWdjZ1VMWTNGREFiYXFpRUJIQmpQdytGWU4wZEJCemlTRE9mYitmV3RzRkRLZ2JXQllLQ0NSQTc4eFNYYktwVWcxbDQzQTRnY2VrMFFJbll1SHcxRUR5Z255aUNaLzRwWnJZK04wZzJvTTNUaGVCeUswVm9EZENkOUFiajdqdUp4SU5WSWdBQXdPWUFiNm1pSHdlS25hRkxnbWZsUU15YktpcVdMZTM4K2xDL0FHZ0VXL01NZ2N4M28yd3FLWkpmRDI3UWk3Z1ptSzFQc0NwYVI0RHlIYzNKNG9OL0FWc2xaMnJjQVVuQU1uMXBaVzBNcVFUeGRvd1JPQmtWdUliRGFXL2N0WEJjUnM1QkJ6SVBJcWVTQ2txWlRITnhkbXoreld2dWpwdXBHNFNYQ2d4N0d2RzlWZ1gxRWVoanlYR3lxNnhxMk5wMDNCaUNQTU9mZXVyMCtOV21Sek4wVkduZHhjWkNDd2JJSU5kVW9xcklwdm9uZXZNcGhYSkVSOTJnb0ppdVRGM2RwQlIzSVBJMjk2Zml2SXJrdy9udU41WFpoSEpBcEtTQ3BNUFpsRERPOCt4NW9OSm10Z2RVeEJIOXk0WXg5N2lqRklGc1Nkb1BNK25FMVJJRHNFWEdaV1NNODB5aUMyY1pzNUUvR2lrWnNEY000aGFaSVZnR0Nnek5NTFNJTXZNdUtLRmErNE03WWltUWpvbHV4NzFxTnlPYnBXTTFxUm5JOE1RU2ZTaFFMUGJzRUJSbXRRZVJBR1RneDNyVUN6Z0VuNCt0RUFhMUxFak1IRUN0U0dUWTVwVVM0MEV6aWM0cWVSMTBWeEpTZXp0Z0FzTnNrYlNESUVpbWZWQWozWVJUdEcxWmtIMGdjLzhVRXZJemZnSmJ5ekVISHZRWmwwVDBzOGNDYTA2RGk4akY5UTF3eTIzdEJFMW82UVpkbGZmSlV0TWtpZVBqVlNJRkdXUFBtTXhNVVduNE1xOG5nekFBdDNpSjlLelFMK1NOeG11Q0NSUFlBVUVxQzN5UElvRWtzQ2VJOUtEc3kwRUgrVWJaN21LRk0xa3dHekpNQTh6U2pyc2lHVlFZSkxaaXR4Yk5hUkZTV0o5ZTJLTFZHanNZdExFYnp0QitkVGx2b3JIVDJXL1ROY2JLRzJjb1NlM05jZWJEeWRuVGl5VXFGZFpxU2Ixd3lHRGNlMVV4NDlJV1dTbUsrSnRLa1k5WnEzRyt5Zk9pVnQ0UDhBNUlFeHh1cEdtRjBHVjFJV1hCQUdmSno3ZTFDbUs2Q0plUlR0QndEL0FPc1VIRm1zNWN1cVdKRE9KRWdoZmFoeGFEYUZiamc3cGU1Ly9yL3VxSk1WdEFYdURoaXdId0FwbEZpOGtEOFMzLzdQUHZBelRjV0J5U09HOG1JM1NmVnFLaXhYTkM5MWhsZGdudkpOTWsva1NVbDhFYmpCdUVBNzhVVWdOL1lpMHhPVitVWnJVQnNFVDduMG9wQ1djN21ab2dPK2d6UkNkRVIyb1VFaVNhQUQyZUp4bjRVYU1jWHQ2eldvQVMyMFNSOGMxcUNPYVppWHdZUHFLVEowWHc5a25tM2RBOVJ1K3VLV0x0YURPUEdWRVpZQXdETTV6VEpDaDBNQmpPVGlqNUdWVU1kT0llNEJCQURBQUQxbk5DYU5COW5yenNYSkpIMC9hdEZhTko3RmRWSXVGWkJNK2tUVkJBTVJrUkJHWUhIdFdCMGVkZ1ZIbDh3TmFnTm9DSmtURUdqWXFUQ0lCSUpQSHF0SzNYUS9INUo3UU1BbmJ5ZmV0Ym9GYk9PNUk1R2VLQzBNUkFiL0FOcEE3RE5ac3lRZEkyZ0RIZmlrWlNLQ2xQS0drbVBXbHZ3Tjl5UkpkUUVuZkV4SEZKMDlsS3RhQWVKUHFURk8wU1RCTzVidEVlMU1sUUpOczhMcjdBQVdCN1JXY1VaVGZRZnhHOElaZHJnaUczbUk3MGxJWWp2Y0FrdXhNVDhhMUkyd2R5NnpFeVRqdlRLS0VjZ0xnZDJuRk9UWUk1QS9XaWhHUnh5ZnJSQWRCemcvT3NheUliUHRXTlpMY2NSUHBTME1tY1p2TEJKclVac0hPS0loMGUvRkV4SnNDQ0NEM0JFVUFrWjRyR1BlZzlUV01lRVlIYWF4amt5Q1RNbmlhSUNRbVQvN2MwQW9QcFhLbFJPSjU0cFpxMFV4U3BqZXJZazJtZmJNRlNRS2xqODBYelBhRnlmT1k3OGRxb2licXdvdUtwVWhnUVJIWVV5TTNReG9idTFqR1FJSmdVSjdEQUdkakVsNURlZ0Fvb0RWa3I1WCtwdVlPM2NmcE5PeEZvVmRnQ1ZueSszYWpRTE9zd0o5UVRtZ2JvNHAyOWdWWVlKRVZtZ3hkQlpDMm9Ca2oxN1V2Ykd1a0JZZDVIRk1UT0xuQUpJejhxQXlETGFmYnhqM05JNUlvb3M2NUNwNkdKd2FIWTJrYzNQNGJMSE9hMUs3QTIraUNYSW1mWHRUT045Q3hsUzJldDNRWFBBb09KbE96c2hqK3MxdWh1enBJQ2djd2EzWm5vTkNQWVlzTnJEQStOVHRwcWlxU2FkaTdYVjhFZ2d5VEV6NlU2aTdKT1NVUWU4TWNnS2ZjMDFFN1IxaEt5czFsOXpOWDBCbk1SOGdhWW1RWW1ST0t3R2UzRGQyajNyQU9FNDdRTVVhMFltQ0o3Zk9sR1I1OER0V1JtRGtEZ2dIaWlLZUJCaWYzckdPbWUvUFByV01jN2ppZ0U2QldNYzRraXNZNGVCNmZHc1lrRGpJd2F3VUZza0tPMzEvU2d4bzBnanZ1Y0FqbUJGQkpKRFNia3lMWU1nNGlzQnFtRWNtMmRzcnpudk1RZWU4VVVFWTBZQmR0M01INitsQ1E4RUVWWHVBbFdRQ1lodWFKbUxYRy91dU1FRWtpYW9JRElrNDU5STRyQXFqZ3llQkhwUVp2MU96bUNOeEF3SW9nMFIzekFVY2M5NkZHc2tUSnpqMW9CR0xRSlE0MmlQdlJta2tVam9tWklFU3hqMXBRN1p5NXRWWk8yU0tLVFliU0JFcWM0a2VsRkppdG9nektjd0k1TTk2WklXd2JBQnllUFk4MFJhMkZYQU9LUmxVVFZVbVdPNW9ranNLVnQrQjFGWHNKYkVXbkxLUE54N1VyNzBQSHB0aWpzRlYvd0QxN1ZWSzJjOG54VFJ4VnRsWkRIY2N3Y1JXMkJLSjR3QkFrajhxSUd5SlBhTSt0YWhHd1Z3QUVZeFJBeVd3TU1rQW1UUXMzRTQ2a0RrR2ltSzBFUkN3a1JGSzJpa1l0bnJ5QUpJK0JySmhuSFZvQm1JSGVtSkhJOWNDaVk5eDllMUF4NGZqR0t3UW0zeVRIZWx2WS9IVmtJOWhtaUljd2F4am9IdHo2MGFzeUNLUW9ZbkxUQWlsZlpTTkpOaE54M0F6R1FPZUtXaDd0azcwYjFPR1BKRTRrMW9oeVZhSUJ0d1VRTWRxYWhMc1BaYmFjZ2NqUHpyTkRKaHdqR1NKeVp4VHBBYkM5YjBWelM5UTFLYkZBRFRqMEpnR25qdEVuTFlrcWdndzhpSkpJNFBwV2NRcVJCbzNHU2ZtS0NpRnlSSzJ1VzhNa25qQmlhelFFMFRiVHNxQnl1NE1ZR2UrS0hlaHVqaFRhQVNBU1cybFFjZzhmRHRXNHNYa2lSdVF4UUJpWi95anNhSEFiNmlPczVNU1Q1cGcvTWl0d1lmcUlMbzlLMnN1UGF0M0xhdWlGZ0huekVkaGo4NHJOVUx5QkcwSE9DRGpzSzNSZ1RLRkJrU004OWpGR2pXaVRLRWFHVWhvQjdjR2hReWFQS1pISEhlS1hpUHlKN1VaQkJPUGFoVEJhWXg0WUNBczNsQStsS29zcnpTUkJkTXpJWFNDSmxleEVIbWpkT2hHa3dYOUpjY21ZQjc4Wm84a2hPSkZ0SXdNZDRvOGtLMFFiVHNXQ3prMFUwTFhnaDRjN1FUOEtJRDF1MlM2bzNKd0I3MEdnbzg5c2tpSVVqQkV6bWFJSHNJVmJhcEpFWWdBVWxJcnlkQTdsdHh1UWtBem1tU0ViMVJNV0UyR1BFY2dSMkErWGVqVEV0QzdvVisvSVlpalFDS0tETXNkdnJGYWpIVlZaQVpqSTl1SzNFSjBTRmdSRVRKK0ZMd0dVNlZFQkozR1RnUVpwdUl0bkF1RElOYWdIdHBDN3BFQXdmV3RSclBIRSsvRkxRZVZFbXVIdUFERmJnTThsN0pTV0p5Y2NVVkF6bmJzbWlpVE00NVBwUjRoVWlabHBLa25PVDNvcUlISTFQUStpYVhVOVBTOXJnL2l2NWdGUCtKeVB6cEpTYWRJMGRyWi85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL2RhVmluY2kuanBnXG4gKiogbW9kdWxlIGlkID0gMzAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFNZ0FBQUZIQ0FZQUFBRGt5UU1uQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFCSUFBQUFTQUJHeVdzK0FBQ0FBRWxFUVZSNDJ1ejlkN1NsMlhuZUIvN2V2Yjl3OHMzM1ZzNWQxUUVkME4xb1pCQWdRWkFFS1FJTUlrVlJvbVJabHUzbHNVY2FyV1ZyTE04c3p4K1d4N2FXMTR3OTl0Z2VSd1hTSWlsUkpDV1RGRUdUb0pDSVJ1Z2NxcXNyaDV2dnlWL2FlNy96eDNkdVZRR2lhTXNTeVdiMWZkZjZWbDBVdXU2OTU1ejk3RGMvajNCZ0Q3TEo3L0ozZXZDMi9QTzlnUWYyUi91emxOL2x1UjhjMy80Y2dPYjNzT2pnTFhoZ3dMSC8yUHNlSTJCQVJFRkJBeEFBZjk5ekFKSUREL0xBbTVrOUZraUErTDdIM0hmNEErQ0FDaWhuZi9yWjM0ZUR0L0dmTkh2d0Zqd1FsNXk5RHh3cDBEemRXMXdVcFBmby9Pcnh4K2JYSG8yVHRCTVpvNDBvU2pKWDZYMy9OaHg0ajRNUTY5MEFrZ2hJbjFrN3RyWnFtKzk5Wkg3NTB5L3ZiSFVXNHViYTZVN3YxRkkydld6bnVMSTFta3h2UnRsdjNQSDlyL2VubzczN0FLSUhRRG53SUE5cWVIWFhlL3dyVDM3Z2gxWWsvcXNkaVQ2UVNQVHdkcFlkTlVIYlJlR09kYVA0OFNMM1R6ZWkxck5MUzh2WGI0eTNyaEpVN3d1ekRnRHl1N3k1Qi9aZ2VCQURSQXV0ZHJjVEo2dWpJcmZ6YWFxcGpkUUI0N0xVWVpFVFc5RllPVG5mNkR3NTE1dHZ6L0lVZTVDUEhnRGszZkJaeXNWKy8ycmgvZmJVVlJnUmFVV1J4TmJRaUNJWlpEbXhBZThjc2JFWGx0dnpjelBQRSszLys0TzM4UUFnRDVycHpJVW93SmZXcjkyYTczUnVONklJQXh6dmRJbU5ZYjZSSUFocFpKSGd0WnJrcDFzbVdaNTVrQU9BSEFEa3dRYUp6c3EwRjNmV2Q1MXdmYkhWWWxwVnBOWVNpMFVCWTRSS2xjaENxTUp5TjJtZHdvZ1ZrUU9BSEFEa2diYTd6YjhzbTA2M1F2bkdRcU01OXVyeEdvaWp1aGFUaUVWRUpJNGpYSjUzTkM5UFJjWmE5RnZ5a0FPUUhBRGtnUXV4OWl0UkRpamZIZzh2SlpFZG9ZR3NxbWdZUXpPT2lLekJXRXNqaWhpUEo3TFE3SjFzcGMyV29uYzc3d2NBT1FESWd3cVNJRE12OHNLZEd6ZXJORmszb0p1VGliYmlCQUlrVm1nbktScUNsR1ZwRXFMSGx1ZVdsMmZnaUE3T3d3RkFIbWlBS0ZRaUVtNE1kdFpmbjQ2KzBFb2ExU0RQR1ZVVmpUaW1DbEJVSlQ0RXJFQTJtcHc0ZStqRWs0QTV5RU1PQVBKdXlVTXE1NnJ5NHQ3V1N3dnQ5cVFkeFRJcUNsSnJFWUZwV2VKQ3dGcWo1VFJMbUJTbnhKaElWYU9ETU9zQUlBOThIcUtxRmVDdjlMZXUrR1o2WTYzVDFJQlhFWmhMRTJJakpGWVFFWW84aTlJUW5WcGFXSm9Eck5SaDFrR2lmZ0NRQnpmTW1pWHFicWZJOXZaOCtVWTNqalUxaHFsM05LS1l4RnBhc2NXZ0lxcEdDM2QyUHUydUFVWVA4cEFEZ0x3Yndpd1JjVHZENFhSak9uNTF2dGNyaGtVT1FHUU1Jb0l4Z3FvU2dwSlBwdDNWN3VMaFdaSytYODA2OENBSEFIbGdQWWdIU2pTNFhWZSs1YTNzaUNnaXFFY1JCQldobVVSVTNoTXF2N3pVbUgrMjIrMDE3OHRCRHZLUUE0QTh1RjVFVlQzZ0x1L3UzSm1xM0Y1dWRhU29LZ0tLQVpvMm9oVkhCQlJmbGJFZlR4OWVXMXhkNUZ2THZRY0FPUURJZzUySFhPeHY3dTM1OG9YNVZqTllFVW1OSmJhR1hxTkJxNUdRUklKempuSThYVzFvdEhSZm1IVUFqZ09BUFBCaGxzdW5rK3pXWlBRS050bzUxTzNSamlJVUpYTVZrVEdra2FYeWpnaXpmTGkzZkJvajhiZUJSQTRBY21BUElrajJ4MDdjMitQK0ZZeTVGUnNoS0NRbW9uU2VvSUhZV3B3R3lyS2M4NVBpaklucy9hUHZCMmZqNEUxNDRNT3M2dUxPeG1ZcGVyVmhqSG9OR0JGY1VJd0lTV1F3SWpxZFpzWUdPWHRzOGNqOGZYbklRWmgxQUpBSEhpQitQQjBOZDExNUtZNXRrVnBMWkF5Sk5mVFNtSVZtU2pPeVZHV0ZPRDNiTnZFaTMxcnVOUWNBT2JBSHlxUysrUlh3QWc3VjZzM3ArQlVuWmpzeUFpSllJeVEySXJLV0pESVMxT095YkxsbEcwZU10ZmZUQlIxNGtJTzM0QUVEaUJnVkpGQVBMenJBLy9ibDF5N3RlbmROUk5TSWtOb0lSVEFDclNTaXdxdHp2bnRvYnZtNXVkNWNJc2orZm9nUkVWRjk5M0k1SExDYVBIQUFFY1NJb0NwU2Y3NnhDOTZjWFQ1ODhrU1NQdWxDTUlCa3JrSVFnaXFqMHBGWHBTd3NMRllqaWkvc0R2ZEdJbElCcnRQcWhHSzMxTTkvK2ZNSEh1VEEvdWhiME1CaXU0ZUlxSUlYeEdzSStlWGh6aXZlMml3eFZpSmppSzBoc29aZUk2R1h4dUs4azN3MFBkTXk2VEdrcGhJU0VWTzVTbDU0NVlWM2JjSitBSkFIMENJYnFZZ0VFZkhVOUtKaHQ4eXVsN0Rac29iWVJOcUtZbFJCRUNJeEJCV2REa2J0bGM3aVdVRWladVB2emp0NStiV1hEbktRQTN0d2JMMi9qUTlodGtTbEZlQ3U3MjNmM3FqS041MXFtUHFLM0h1Y0tsUG5xRFJnUmNpTElvNmNub3VpS0ZXSVZkV0dFT1RLelNzSEFEbXdCOHVPSHptQmlLaUllQkdwaGtVK1hhL3lGeVdLUW1vTkZrRUVJbXRweFJFSTVLR3lVVEJuajZ3ZVdaaUZXRllRQTNEazBKRURnQnpZZzJILzVrLzlSUTZ2SE1hSXVYL0xzTG95R2J3OHNlWm0weGpKTldqaEhVNEQ3U1Ftc1VhQ2VuSFQ0dGhjMmpuTWpPOVhVV09OTlNKeUFKQURlekJzcWRIay9KRlRXR05WVllPcU9zQmYzcnA5YldNeXZLakdZRVV3WWlpOVIxWHBKQWttaUU3SGs5NXlzM2NhNGU0YXJxSk1wMU01QU1pQlBSRFdpR0srL3ZvM0ZYUy9KK0tCYWx3VldTYnlkb21FVGh4TEs0NFJoRllTRTF2QklPSmMxV3RyOHQ0b1NkcUFRZXQreU41ZzcxMzVYaDcwUVI1QSs5enpuOGVLWVRBWlljVHM2NGRFcGF1aWszUEwzYVVrL1pBTk5Fc2ZxSUtuR1VXNG9Pd1ZCZUpVZ3VvNFdtaDlhWGV3Mnhla01tTGNiTWZrd0lNYzJJTmhHM3RibkZ3OVFoeEZpdHlkN3EwMmZIbTlNdHhJak5DSUxGWUVIenlkMk5LS0xIbHdHR05YMW5yTGgyZmhsUTBhakVpZHJQOTdmL0hmT3dESWdUMFk5dHpEVHpIZjZhbmNJNVZ6YjIzZDJoeFc1WFUxd2x5U01wY21xTUtvcUVqRVVPS3BpbUkxTGptMVAvNnVxbFlRV1Z0Wm85bG9IZ0Rrd0I0TUs2b1Nhd3pVYzFrZWNOdmo0VGhORzVjZFVrVEcwSXhpUEJCRmxqUXlwTVpRK3FxVnFqM2I2ODAxZ1VoRXJLS1N4SWxjdVg3bEFDQUg5cUNZc2pQWVU3MS9pU3FFL0hZeGVXVksyQjVWSllpaEVVYzBvM29kTjhab2taZkc1ZVhwbGM3QzNMNEhBVXgvMk9mVmk2OGVBT1RBSGd6N3BTLy9CaytkZVpoR25LamMyeEVKdjNIMXpkZkhWWFd4RElFMGltallxRlppRTRpTmthb3FRWGw0dGJsd212dUlITElzazYrLzlBMys2ci8rVnc0QWNtQVBoaDFaWEtYeVhtZE53NXBVYnJnM3FDSjdUWVhLaWlMR3pNYmZoV1praURCTVI5Tmx5bkEwVHBOb0JoQ3JxdEpxTk9tME9nY0FPYkFIdzdJeVoybHVFUVIvMy9CaWNUc2J2VEx4ZmxwNVQwQkI5TzZTYldKRTh5eTNhWncrTXRmcU5tZGhscGxWcytTMVM2OGRBT1RBSGd6NzFXOThrZVc1QmF5TjZpM0RHVWl1RExiZURuSGNWMVdhMXRiNklhYVdhRXVzd1ZVVlVvWUx2V2EzdXg5bXFhclpHK3d4S3JJRGdCellnMlBPT1hYZW9iVlZRTmpPcCt0SkVyMHVSb0tBTnFPWUpJcElZa3RrRFQ2VUdHUjV2anUvS2lKMjlwaklSbkw5MXZVRGdCellnMk1pc2kveWVaZTdkM3MwR0w2ZGpiN2d4VlF4Q0ZyVGt0WmtXQ29BMCtGNHhYak9HV01zcWpGMTQxQ0tNcGNEZ0J6WUEyTnZYTC9FNnZ3UzVyNGxxaEI4ZFhWdjYrckF1NGtWSWJFV3BCYjZqSzBoRnFPVDRTVHVwZDNqTm9xU2ZlWjNWVFUzMTI4ZGVKQURlN0JzYTdBN3k4VHgrOU85ZzN4eVc2MjhnYUNOS05KR0ZHRm5qSXVSTVJMVVJlVCt2WXZkeFVYcUtsWWtpQmtPQjZ3dXJoNEE1TUFlSFB2aHB6L01RcnU5cjJYb0FMY3hIZThNZzNzamltTXNTc05hN0l5QlVRUlI5ZUlMZCs3WTh0SHpkYVFtMFg0bFM5RURnQnpZZzJQbmo1M2kwV09ua2Z1azJvcXlLSGZML1BVU2hvbTFFa2NXa1RyRVNvd0JSYXZKdEZGbHhTRUVnMnFrcWxhRG12Nm9MMy9zZTMvd0FDQUg5bURZUW5lT25mRlFGVlJya0ZSb3FIYXk4U1VuWVRPeGxxYU42Q1lKYVd4cHhCWUQ1Tm1rc2RTYU96TTNOOS9XR1ZlV3pwSjQ3OE1CUUE3c3diQ2lLbm50NWxVQW5TWHFIcWcydmV0TEZLOG4xcEphU3p3THM1cHhSR3hFaEJBM2dqbmZUcHZ6Z0JIRUdtTk1wOTJSYnJmOXdMOXZCd3RUN3hMN2pWZSt2ditsR0hOM2lTcnA1MVBPcng1ZG5SZnpsQXNoTHJ5bjlKNHFCTXJLVXprSUlsUHBKRi9aM052YUFKd2dsYUkramlLOXZYN253SU1jMklOallzMnNYMWlyVUdsVlpwY20vVmNDYkRlTXBSRkZKTWFRMkhxaEt2aUFkK0hJMGM3S0k5U2N2VlpSVTVhbGZPMmJYMmR4ZnZFQUlBZjI0Tmg3SG42Q0pFbHFZcmxaTmV2YVlPZVdKTkZHTFJFZGFTZE5hTVF4c1RVRVVZb2lieFhEeVVyVVRMOUZQK1Rkd050N0FKQjNtVDEyK2lFNnJmYTNTQ1RjNk85c1RRbHZxV2pZMXhDSlRMMG5FaG0wckVxYmlEMS8rdkRKK1JsQUlsVTFrWTNFUnZZQUlPODIrNGtQL011Y1AvVG9QejFNRWFIWG5PT3AwOC93eVNlK2wwZU92WWMvK2RFLzkwY2p4QkpoWjI4WEVibkwvbDVsMCtsbWtWOVBqTWtOS3NhWVdxSXRyaE4zY1k1STVaSGpjNnNubVRVTVZkWDQ0SmxrRS83YXYvdi9QQURJdThsOGNLZ0dvZTZYN1d2MUdVSDJId2theEhrbldabHhmUGtVcDFmUGNXamhHS2ZXTHJ5alg5dlAvUExQMG1vMFZWVkRIV2FKQTZwWGhyc3YyQ1RlaTIzTm1SVlpneGlobTBaaVFpQ2ZUdGVxVVg1S3JFVFVhN2dHTUtlUG5aRUhtVlR1b0lyMXU5Z2tIN005MnBRcVZDSWl4b2l4Um94RnhNZ3MvaTU5SlR2amJibTVjNE95S2lTeUVhTml4TnQzWG1lK3M4eUo1VWR3cmtIaCt1KzQxL2Y5SC80VXQ3YnVTT1djbWEzVEpnNk5uMW81K2lFcHE4TUJ3UWVWMGpzMEtLUENxWHJpdE5PNlB0VDg2MW1lRlNKU0NlS3lJZzlySzJ1ODhNbzNEd0R5YnJGK3RrZnBTMUZWTTN0RVZRMHdZL21vSmNvVUZWVE5LQnZJcGZVM21SWlRqQmhwTjNyMG1zdE04NUtqSy9NOGN2d1JibXpkZU1lOHZtY2ZlWkpibTdjWlp4TUJyRUNhVldVNE5yKzBlRFJwUEpNN2IxVlZnZ2Fxb0dTbG8zUkJPdk56dzc0YmYyRTRIVTJBRXNHVlZlbS8rWUNDNHlERSt0OEkxMmNobGpsLytPR2xzMnZuMW1aQVNVRGJJclJSYlNuYUNCcFNGMXd5S1VaUjRRcXpOOTR5TjNmZWtsRitVNnl4Zk5lVDMvVXQzMVpFbUdzdDh2Q3hwM2pmdWUvNFE4aERJRElHRWRrZmY2Kzg5K1h0NmZpMU5JNm1UV09rRVJuRUdBS0JaaHdod2VPeTRrUzMwVmxDSkJLUmZRM0RCM3IwL2NDRC9OTnVEakdpcUFHUkgzdmZuM25pZXg3L3diLzh6TmtQbmhaalJsazE4Vms1TmFyYW9PNE4zSlVzQXpVaEJDbGNoZzhGNDJ3c3YvWFNiekViejVCNjVrOGtpUnZTYWZURUdNdm0rQWF4YmVDRCt3TjViUzlkZW8zaks0ZlpHZTRKOVFpN0JkSm1GSnVINTVZKzBvQmx4REIxbFV5ckN1OVZDdWUwMis0MG9ybjJHN2Y2NjI5b1VLZXFsWWk0cGNVbFB2VGVEM0hseHBVRGdMeUwvSWZNYnNqbzVOS1ova3IzNlBIbDFxRi83YUhWeHovOXpObm5IajIyZE13aVlacFhtUlJWWVdjZzJWZUlGV2FBOE1IWGlEQ3pCTC9PWTZUeUJjTnNqNjNCYlFIRGZHdUpOR3FRVjlNL2tKZVhWd1dSamFSeTdtNVhQWWp3Nk1xaHN4M2xQWmx6bENGSTZRTkJBODZyRnFXelVhdTV0VlVNZjZjbzhncWhGTVNoR280ZlBuNEFrSGVMSlZFS3FLaXFBT2IxT3kvTGE3ZGZmUFBJM0lsaHcvYStveG5OZmZqbzNJbVBuRmw1K0ptSGp6eHgrc0xSOHowTWJxTi9KOXozdnQ0TlBaUlpIb05hQkx1ZjF3VDFFdFFqWWxBTlBIbjYvVnpmZXZzUDVEWCtwUi84Q1FhVE1adjl2WDJBeExsMzlwR0Y1U09ubXUwUFpXVnBBQ21Ed3dlWWxCV1ZjeksvdkZMc3VORVhScFBSUUpCU2pEZ1JFMDRkTzZXWHIxOCtBTWk3d1o0NjhUNG14WVRDNVhmemtFa3hrcGR1ZmVQU2ZHZGxhNm03L0pEUjZKZ0pqV1BMN2JWbmp5K2QrTWpwNVljZWYrNmhENTg4dEhETVhscC9heThFNSsrRy9IVWROR0cvWEN5UzNBY2dCU1dObXl6UEhlTG05aC9NTGZ5ZUV5ZlpIdXh4ZTNkSFZOVkkzZnlMajYyc3BxZmF2ZmU1c2xvUUVhMW1YcVJ3UVRTb0pISENRS3JmM2gzdGJRcFNBWlVQUHR6WjJ0YktGUWNBZVRmWSswNTlrSnQ3MXlXdk1tYUxRU0tJcVh4aDM3anp6V3U5VHUveTZ0enEwV2FjSHM3TFNnalNhTVc5NDB1dHhhZVBMNTk0My92UGYzQnBkOXEvdWRHL05USWlncUwvNFovK2o1LytrNS80a3ovWTZYVDJYcnY2Nm5pbXZiR1BJRlZWUGJwNGtodmJmekMzOExQbkx2Q0xYLzBDUmtUQ0RDQkFqTEU4M0Z0NHZHUHNtWDNWbk5KNW5QZGt6bU1RMDEzb1hybXljK2MxYWdxaFNrU2NhdERmL3Z0L25MbjVGQ3RkanEwZVkzTm5EeC84QVVBZU5EdTMrakE3a3gwS2wrT0QvNVlxVGRCZ1hyLzE0cDNDVjIrZFdEbTIwbTMyam10UUU5VGpuVW9pOGR4S2IvSHhVMnVua3krKytjWG5LMStVQUNkWFRzYm5Eai95NTk1Nzlway9jV1Q1MlBqTm0yOWN6OHFwQWlwaVFnaGViMjVmbTdHRS92N2IxOTkra3pPclI2aWNvM0pPWnJzZXliRE16Yk9yUjQ4dm11alp5Z1hqZzVLSk1yZlVvN00wcDB0THZYaWgxYWl1RGJhL2twWGxXTURWSGZtZ1AvdExGL242aXh1eXVUV1NuZjVROHFMOEl6K3JkUUNRMzhYZTJuaWRFNHVuR2VaOWd2cDlMN0kvdnhRQXViN3o5dURtM3RVWGp5NGZUVmZuVms2MTRyZ1JVUEZlaWF5eGpuTHZpMjkrL2pmeUtzc0IrZWFWYnd5ZlBQcmNvVVE2UDNwNjVmUjNMSFFYYi8vT3hTKy9JUWdJQVpIUWJuUXAvd0REbEpYZVBKdkRQWmgxeFlFNGhCQTkvZENaSTZlT3JYMnd1ZHhMV3l2ekxKODZ3c3JSVlh3SU1zMEtpWXo0emNub2Q3WW5veTNxdlpLZ2lsU1ZOMVVWYkZrNVU1U1ZoTmswd3QyeXh3RkFIaHliYXkwd3lvZW9CclRtclZXcFNROENFQVJoWjd5ZHY3WCsrcXVIRmc4VmE0dHJwOXRwMG9tTTRFTGdwZHVYWC96U0c3LzZPYUNjL1R1bTFXVHI1T0tGOHlFM2p6YlN0di9LcFM5K3ZxaXljbDhGcW5UNUgraDF1OURwMFc2blpIa2hQZ1N6WDRuNzZIT1ByWDc0USsvOTRPTGgxWjVwTjRuamhMSjBWTTZSWlFWSkhJdEU1bzJMbTNldTNnc1RpVUJtSlcvWnIrYmQzMmZUUDRvZ09XZ1UvaDVlWkZLTVVKU2dRWVY3aXJGQXJ1aFlrTkhtWUgzcnYvN2NmL1l6WDcvKy9IOGJ4RzkxV2pHamFscTlkUHZ5QnZVd0lJcXFnUDNxVzEvYWVQSG04MzlyV3JyZDNVRzVtTVR0enV3eitFTnB1RjFhdjhrZi8rNlAwT3UwZEVZSjVBRDN0VXRYYmxTKzJvaXN3WXJCUmhHTlprcXIyY0FZaUVUbWw1cXRKNEI1RVhvaXpLdlNWZFhPN00rdXFuYUFKcER5TGVYdlAxb1dIVURoOTdiS1ZmVk5Zb3o2RU5TSTFVQXRmS25VQVhaZVp1Wi8vc0xmK09WWXJIenczQWYrdFJ2RDNmam03dFczZ1dKMmM2clcxYXowSDN6dDczeGpzWDNrMTd6cFBscDZiVkp6OFJnUjVOdlRqNS80bDU3anlsdGI3R3hQc2NiZ3ZjZUhBQnBROVhlL3NYZEsyb2lKWXNPYnIyNzlNNzIreVhoTU00bnJsek9UU0hqaDdXdTdsWWFiblVpZXJ0bE42bC9NUm9aS0E3NHFUU1RtNUZLN2UyaG5NcExGK2JSeitGQnJycEZHYVo3WnFXaHpOSmxXZ3l1M2JnNkJmUGFVc3d0RDcvTW9Cd0I1VUV4VkNjRnovdkJUM05oOU14UlZVV2w5Y2d3UTdZNjI1Vzk5NFgvNGhXNW4rYUZYN3R6NnlHaDg1Mlo5SUVSQURUT2RqUk9ySnhjM3N1SGkxbVRVYmtTTjdvaTdEVWtBdnZPWnY4VHU4Qm92dlBYMytQNGZlcHkvKzdlL1JoUlpscGE2bkQ2M3hDc3YzMlRZSDNQMlhCZVAwdDhyMmJnOVJZemhoZWR2L3grS3NiZjdJeFFOc3kzRE1CaE5SNWMzdGw3NzBJWEZUNktoVlphNVZLN0NHS0hiYnJLek44QkU5c2lqcDVjdkhEcTdkUDdNaWJsbjE1Ym1uNTV2bjJpc3pwL1BPNjIxM1oyZDRvMy8rcWQvN24vNlIxLzU3WXYzZXcrUk9rdzl0THpHOGJVamZQV1ZieHdBNUVFd0h6eC82cVAvVng0N2MwRlhsN3E4Zk9VbEhVMUhYdEZxZGtOYUh5cHpkV2ZEN1UySFl5TmhjM1lvWkJiYnA2ZFdUcytmUC9iUlB6M0lvKy9NZkhITHhxMzB2dkJLQUpycEhHZU9mb2dYM3ZwNy9OLy84aTlKTmkyWlRrclJvUHo2cndURWlCZ0RMNyt3UHJ1RmE5bUNwR0UxU1NNdGkzcGNKVWtqb3FqRzNYUlMvdE9CRDJSbHFhcDZsNVpVVmF1Ly80WG52MzVtZGUxTzV2MjVZWlpSNUVXZHkxdGhXcFlrYXRhKyt4T0gvK3pKQy9HSzFlWE95Y05QbWVPcmo5THBMSk0yMjhmSGsrcXh3VzZ4dUwzVC8wKy84ZFpMYjkrN1p6UVlZMUFOSWFvSnRRK1M5QWZGWHI3K0JaNDY5MTRPenk5VCtZbzd1K3VJaUJYRUF2cklzWWVYVHgxNitpOWMzcnE5c3p1NDlITlZOWEhVLzEreTFGM3FQblArZS8vRXFHcjg1S0RJMjlaRy9kRmsvWE9qOGEwN3M5Q2pGREZoV3V6eHdsdS9JQ0ZVcHI4N05lTlJZWXZDMmJMMGtYTWhyaW9mMVY5cjVKeGE1MEpVVmNIa21aUGd3NHlHRjJ4a3hGcGhPaW01OE5naG1zMklFeWNYMk53WWY4dHJldjZOdDluZjU3REdtRENieTdwOGU4Tjk5TUw1eDdOcGVmYjYraGI5OFZpMkIyTnU3ZXh4WjJzWHB5NCtkYWF4Mkc0dnBNODk4UU9jV0h1VUtPMUoxT2hpa2pZMmJabkJ4dkJVUStQZWphM2JyL2JIdzV4N25GeWhyRW90cTRyM25IdVVteHUzRGdEeW9OZ3JWMS9pUFNjZm94dlBjMm5qa2draDdNOWg4VjN2K2U3VFFSWStlMzMzeGx1Yk82LytMNm8rQnFKRzBtZytjKzY3UCtYTjRsOFlsVzRKQVRGUmYzZjNqVitiWkZ1M21TMHRBV0UwM1pTZzVkMDlEUkVTVlZLQlZLRXhTM29iMUozNUJDRkc3eWJCbHYxZDhhQzRLa2gzcmttakdkTnBwN3o2OGgwKy9CMW51WEh0V3pYUEh6OTVqS3dzcGZKZTJQKzVFSDM0MFllT24xNWFmQ2I0WUEwSXdlT3FranlmNGlwSG85WG11ZmQvbEpzM0ovTGE1WXR5WS9zS1YyNWY1UHJHbTNMMTZ1dXlmcnN2YVVoUHJTMHN5OFZiVjE3Sml0enRBeVRNa3JqbCtVVnViZDQ1QU1pRFpDOWRlWm16cXc5eGVmTnQ0NE8zczhNcVAvRHM5ei9ycFBXcEd6czMvOWV0M1RkZUZLRmhqWWsrK1BDblA5WnFuLzYvYkU4bmh4UlZFUkZyb3QyZDNkZCtaWnJ2M1dFMnNrRTk0V2kxWmxKUFJhU3BTbk1HaU9hM1BmdGdTYmczVWZ4UGxGZXIwalBvWjRTZ2N2VDRQTXVySFM1ZjJ2NlcxL1B3c2NQa2xaUGhOQlBBR3BGVVZlTmVNNTE3MzduVEg4dEszNnljUTRNbitNQm9takdZNU1TMnc2V05MYjUrOFd0VTZRNnRKVStJUm93bnQ3aDY5UldlLytZYjBtd3N4RXV0aFZOcml5czczN3owNmtYMlNlc2crT0IxbkUwMUwvS0RIT1JCczlkdXZ5b3UrTmxJZkYycVhlajFqbEUycXJMWWVnRU5EVVdTSTB1bmwrWjdaLzc0K2pnL1hKZUx0Yjd3TlF5OUwwYmYxaU9JRlkxRVNGVnB6TVpSMnAvK3pKTW5Menk2Y2tvRDdUaTFuU2pTdEN5bVZiOC82bTl2Wk50WEx3L3VYSHhqZHllYlZzTTZWS05TSlFjS1ZYV2krSjJkU1JBUlB2ZkdHM3JpVEp2cmx5YzgrNzduK05yelgrWFNuVTNwVDZiVUE1WDFKTEpDOU1hdDlWdWp2TGpSYVVSenUzMkhDeW9WaG5aM0hreENKSlpqSjg3eUU5Lzk1emg2K2pTOTlnSVNZRHJZNHUwM1gySDl5cS93NnBXdjgrang5eTZlWGp2NXh6LzQyRE12Zk9tVnI3MDBBM1VWUXBBc20vS1pqMzBQdi9qYnYzWUFrQWZKM2w1L3E5NFpxVGNOTFdDYnByVzZPRCt2ODRsT2dCYW9uZXNlZTJUaTQ4YzhlUzNSb2FyV1NKVk5ONzR4bm01dk1QdkwvZHUvOWhyYWFEVGo3ay8rMmZjLzlZRVBuM2x1ZGEzM3dVYkxudkZlVzBFMTl0NlRUZnQrTXQzTDg0bnJEL2FxOWEzZDh1YU5xK092L2VQZnVQTEZqVHVqMjBBc1FxUktycXFWQnFxdHpWRm90aU5FUkZkV2xqREdFTWV4ck8vMVJjSG8vanpXakxrazdXWXRhZSttWVcrT1lBeHgybUF4YnJDeXNNREZ5MWQ0OGlNZjVzLy8yMytaM3NJQ1JERlVEbnlBaGFNY1huNkk4YTJJbi85Zi9pZGV2ZkVWUGJmNnZ2UHZ2L0QwSDd1K2VmUEt6YzMxZlBZejNOTENvdkFPWnNJK0FNZy9qMG05SDZpcXJIUlg1NkxRT0x6U1hqejZzVWMvOXAwdlhmM0dyMWErSklrN2g4b1FFbEJGRENFNElWUzNON2RmL1VlVnp3dVFNQ3NEV3hGcEFLM3YvT1FqSi8vVmYrczdmdkxRa2RaM3htbHlXS1VSVjVWU1ZZNnlMSERWQklkRWNkTG9HRk4ya2taOHJEblhmTFkzMS83NC9FTG5VNisvdlBtcnI3MTArN2YyZHFkYnM4OTRXczhNVTFWRkNGc2JPYTFtcW05ZGZGT0M5eWJVSUkvdWhuWFFhYVIwZi96VEs1K2FYeDZmdXJQWGs2VzVlVUlRaHRNcGc5R0lzNDljNEh0Ky9FZUpyV1U2SE9ETEVxT2dKa0pDUUVLZzArenl5SkgzOGNxdEw4bWJONytlSGx0ODlIMFhqajEwK09ibSt1NCsrWVVBdmZZN1Z4VDBBQ0QvUW1DQ0hsNDRQQzlxandlbnlkT25udjZ4OTUzN3lQcVgzdnhmM3hBTnpjVldUNmI1Q0NOR0JPbnY3YjcxMHh1N3IxK2FSVmQxR1ZoSVZiWDVwLzZsRHozOVUvL0tSLysxbGJYZUIzemxrcUpVOVM2aUtISzg5K1NsSjZ2QW1EbWNlUEpRVW5qUnpDc2FtZm1GNWViSEhudjgwSlBMeSsyUHZQcnluZi9tMHB1YnI5MVhTc2E1VUxteCtpTHJpNnJlTFRKSW5YZTBWTFhUYUtTTlAvVmpIM2o4b3g4KzkxMkhWdDZmSERxN3pCZS8rSnNNdGpaeHdUTzNNTWVIUC90RG5MdndFRlZlb0FGOFBzV21EYlRNS2FZWncvNlkyM2Z1MEl5YVBIUG1vM3p0MG05eVkrdU56blJhdGV0elYydXZUNHRNRmhjVzlkeXh3MXk2ZWVjQUlBK2N6WUtERXlzbnVvanRUaWNsem5Ic2p6MzkyWi9xWi8zL2JuM3ZsbnZrVkZ1UHphOXdhK2Y2OVozK3hiOTdhK3VGM3d6cTk1dU1kVWlqcEovOTBhY2YvblAvK2lmK3plNWk1d05WSllqR0NFSHFrWEZMVGMxZVlDV2hkQm1sTDNCQW9TS1pGNm9BRWh1YTNhaTNWTFUvOWZqalJ4WmFyZmcvZittYnQ3N0J2V0ZMQmRVUUFucWY1MURWRnREK3NSLy8wWWQrNUVkKzlIc2VPM2Ywa3cwelBicSs5UXA3MlpkWmZuU2JKVEhrRTRYU1llZDN1SGI5QmZMcEZsbXhoMGlUYm5PVmhjNEtyZVk4NlRSbU5Cd3dHQTA1dkhhSTk1eDZIMTk0N1F2WFhydHhhVmpuV25YenNEOGE4ai85ZzUvaDUvOC8vd21mL0RQLytnRkFIa0FMZ0U3ZGRDcEdKbG5ocUx6bmNQZndZMy82WTMvMkozLytxNzkwN2MzYmI4cERoODV6YmptL3Nydjd4UmRMbHdjUlNWUzFNYnU1N2ZkODVzTHBmL1V2ZmZ6ZlhGenR2VTk5cllWV09xVUtsdElya0tCYW9DRkE4R1RsZ01xVlZCNnFNaENjb3FFTzVrMWtKRzVHdHRtTVAzRHUzR3JiV1BNZnZ2QzFHOC92bDFpQk1Hc003Z00wK2NoSFBuejRyL3lWZitkN3o1MDkrLzN6TGZmMDdhdGZpTzdzZmw0azJTUnV4VVN0Rm9HVXBBdWxHM1B4enE4eGVUTXdHZzl4M2pIWGJaT2FDTFJGSXpsT1cwOGdJcWdxMjN0N0xDMGU1c216NzgrKy9QSlZ1TXNPVTNzUlZkVy8rUXUvL0k3TVF3N0t2UDk4b2RWK0ZTdmE2RzlXangxL1QzZXB2ZktVTWRLb25HZStQWC9vMU5xcFk1YzNMamMzUm1ON2N1WEM4bE9ubmpoVXVPSFZqZjd0b2FyR0l0SjgvTnhqUi82VkgvbXB2M0I2OFpIdnJNYUpKUW9pS1ZUZVVEb0lDc0U3cHZtRXJKaFFsRG1WbTlhTFRJWGlpNEJXaXE4VTV4VDFpaXBTNW80cTk2dWRicU9iRjlYTGczNDJtWUhFMzNkQnhwLzYxQ2VQL01mLzhWLy9Qei8zekROL2JycjExYk8zci8xM3B0SVhzZWxVVEp3U21NT0ZRRlZsbEtYSEIwTlJlWEpYTXA1NitydU82YmlpY0JYRFVaOHIxeS96alJkZUlwOElDNjBGWE9Vb1NzZVI1VU85ZHFkMTZhVkxyMStqSG95c1JNUUhWVjNzTFpFMm1tenY3aHdBNUVHd3lFVDdBQkhBVnI2U2F6dlhyeTNQcjFiem5aV0hxa29hUlY3Wlh0cHVQSGJ5dEhFaDQvcHduQ1IyNWRoekQ3M3YvTkhsTmIvZXY5Vi8vOFBQbmZtTG4vMUwvOFl5cHorYTNXeEgrYTJ1akcrMHlBcWdWeEVpVDFsVlpNV1VTVEVocjZaNExjbUxuS0lJYUFWYUJuQktjS0JCQ1RNLzRaMUtOcW5FR2ptYU5xUDEyN2NHRjRQWGFnWVFGYWxaRXYva1QveklvOS85eWUvK0MvbGc2L0QxdC85TGJjNzNSV3hEM0F5Y0x0VGV5VHRQVm5uS011QzlZVGoxbEM1Z0ZJbzhNSjQ0aXFtU2p6eGI2MzF1YmR5aTAxdGdzYlZJTnMzVW1xaTd1cnpjdXI1MSsydmJlenRqWnRTbnFvUWJHK3Q2WkcyTjlhM05BNEE4Q1Bia3FXY1laZ054dnJyclVRYlR2ZXFWbXkrOVBzb25yeWRSR2hweHUxMTVtamJFMFltVnc4UlI0UHBnS0hrV3I1dy9mT0dwSjg4OGV1VGpqMzc0NDZ1ZDFXY0cvVHdhOUhNcHBwNWlUeWh1dE5pOUhYRE5DYlJMTWxkUnVnTHZBdXJCTzRlcmZPMHhacUZWQ0hXVjFRY2xVdkJlcWFxZ1plN2l1Y1gyQ2UvMWhlM04wWVpJSFdyTjZFUGp6VHMzbWovd3lmZC9wQkhyOGMzTkwyQmpMMEdhT05Na0JJTnpCVVZWVVU0VTV3ejlnU2ZMUFNKQ2NGQzVnSE1RaWtBeExwbU9LdkxNTUJrTldOKzZUcWUzVERmdXltUXlZYUhiVzRzYnljVlhMcjk1T1hqdmdVcFJMeUtheERIOTRmQUFJQStDblQ3MEVMdWpIWW9xdno5ZDE3SXF3dVdOTjIrK2ZQTWJ2N001Mlh6WldMdGVlWHhaU3V0UVo2RjFxTk9ScVMvRHh0NWUvcDVqcDg4c05ydEh4c05jeWpLUTU0N1JKS2NzcXpwK0c3Yll1d011M1lMR2dCQUNSWlVUbkVPZHc1VU9YOVZEOS90ZXc4MGU3d0xlS1ZYaFpUb3VOWTVzUjZ6Y3VuVjk3K1VRMU0xdWI0QmtlM2ZJMDQ4dG5qbCs0c0lUdTNzdkdPZjdJZ0ppRjhBdTFkOG5teklkZUtvTTBtNUtHUnpCQzk2RHF3TEJ4L2dTcHFPTWJGaFNGaDROSHU4THR2cGJOSko1R2xGRHN5eUxqcXdjV3Q0YTdMeHdlM3RqOTU3YWxmcTk0ZUFkbDRjY0FPVC9vQjFmUHNXMXJjc0VEY3cyQnU5dEc0cUV5aGZWcmQycnQ3NTU5VXN2WHRwNjgydFd6T1dzbUc2NnFod3V0eHRScDFsbEs5MU9VOVFtUmVISW5HZWNPT1l2TExKNllwWGQ5UXhmVllSSmc4bXRGakJCVzl0VUxxY29Tc3F5d2xjQkRiWGlvSHJGQnlVb2xFNXh2ZzYzeXR3em5aVDR5cGwySjVXTmpkRnZaOU5xeW16Y285NEV4SlQ1bGoxMzR1aUgxSlJkWTdmcTNxVTZnallJT29mWENCTjdLanhCQTFyWENpaGRJSGpGVjQ0aXI2Z0tUMVdBT2t2QVlheFFGRlAyeG4xYTZieWtKaVg0c0xpNHNMRHo5WXN2dnh4Q3FBQm5qUEd6d3NFQlFCNEV1N2w5alJBOHo1NzdvR3dQTjJaYmd6TWRjdlp2YUFtQW0rVDk4WnQzWHJqMnpldGZmdjNTNXV1dkxDNjB4dC81MUFlZnc5bE81YnhvZ0ltRnAzLzBDVDd4bWFjNGNiYkQ3YS85TnB2ckpUWnBZY3NVdjcyQ3g2R05QU3FYUWFWSUFPL3JoU252bGNwREhxQU00TFVPdGZMY014N21VdWFWZE5vcG8xSCtsZDJkNllZSTdyNWtQVjdmN0dkSGwvWDg4dXJhV1pQdWlNV0lFZkN1UU0wOFVlTVFLaVZPcHdTdnVFcnJYTVFwM29IM25pcDNWRVVnTHh6TzFmZUZOYlVZYUZhT0dFNG5MTFpYSlluaXFOTnFKN3VUL3UrczcyenRDdUtveCt3RDc3QkZxZ09BL0hQWXYvWDkvdzVLSUM5em1rbVRjVDdTR1ZEMkswWDNIMElMR2srS1VmanNkMzNmczArZGZmTFpQQzlzVlFVSkNsb0V1bk10anA1ZTVNVy85Vi94aS8vdzcvQ2wyNWRaU2xacE43b29Ccis5aWg4czRHV0kyaUdKTlJTdUJvWUdDRUZ3S2hRT3FpcVFaeFhUY2NsMGxGTVZwYmJiaVRXUlhMcCtiZS9WbWJjcloxN0VsaFdhV085T0h1OTl1TEZJMDJXRkdCVzhPb3lrV050RGFBQ0M5NDY4cUFoT2NXVmRGQWhCOFFHQzE5cVRsQ1VTdEo0aUVVV0FhVEZpT25Xc3pSOGlqWlBlOHVMeSt2TnZ2dmhLMEZDcHFwdUZXKzhvZ0J6c3BQOXpXSCt5eXlRZjgxZC8rRCtnMit4cDBERHpJUGo3Sm5STG9CUndxbG9kUHo3ZmV1aTU5WE5oL2pVYnA0cGc2L0ZGZ1d0ZnVzNC8rczgrejFkLzh3cWZlM3VUMTY5K0JTMi9qb2dqeXh6RFVjbnd5akxWS3grRjIrK2p6Rm9FOFJqanNPTFI0TkN5aEN3alRIT3FTVWt4Q0xoeGhISHp1R21uc2RCZGZjZ2FzNzhMTDlUTGtpWGdYM3g5OCtYTGwyLzlUaWlEYUN4YUJZOVdEamZlUnNLSUpPN1FUSHFrU1ZSdnVaalplRm5RbVNxVjdOZSs2eDFpVTMvemZjTHVKRGJzVEs1emRmMGFWcVNkMnVoQ3M5Rm9jbTh2LzZBUDhpRFppMWUvd2VXTnQvakZyLzBjMjZON3UrRGYrNG5IbVV4enBsa3BxaGpxL1lwR294RjMvbS8vN3Z0LzlJa25pKzhQalRkamFZN0ZUK2FSc29VeFFoUkJQbkxFcmRNY1hucUlSZHZnMDUvNUNNZWZmWmJMcjI3V2lYZndpRStReVdGOHRsQ2ZMSTBRMzhEbk1lVTRKa3lhUk5NbG10azV5dDFsc2tHYnlCK1dmRFJuSnNPdU5iUmU2bzl2My9vMkR4ZE5jeWVkTHZySWU3clA5aGJpbGdXMFVIeFdFbnpBbWlhK3loQUtDbGRRVllyM2d1NkhlTE93cTVoVVZKVkhadVFtenRmZXhoaUQ5d1Y3ZzVFZVdUb2hZdVh5RjEvOTJtODc3OGV6bm9pYmViWjNUam4vNEpqL2k3ZlZ0U2JUcjVkUUs1NUZxc1RHU3ZKdi84VW5QL2JNZStJZlFzdUd4aDZ6OWhMZGRJUG81aG55OVRQWWFvRVFoTW81bm1vL3lxbjVFMnhzdERFckhrbGlxaXpEV3NGWGpySnloT2tLWm5NUmFSUjRxWENWeDFZZWsvdlp6c2FJbmY2QXZBZzROd0Fia3pTNmh4cU54U1BjMjRXL1g2OHd2SDU1OTgyOTNleVZ3KzNvTy93bzRJczZQS3F5TGJMTkFjNEhLdTh4bFNPTVBVVUFpY3lNdmtLSkRIZDF1SXdtWUJTUmdqaUpDS0VpaWlJbXhZQTd1K3NjV2psOGYwajFqdXlrSHdEazk4SCt4di84VldhcnIwYnJiYi80dXo5eDlNZ3pqL2QrT0ludElXOE1YZ05pbEtpN1FYcDZBeFpmcGRvNWlkMTlMektacDZ3OGFhdEJmMzNNbmF1dlVYbG9KQlpRaWlvd3JUeTVPaUpyc09PRXlrZVV3WUY0UnZtUXpmRWUwMnlUNldRWHI1NG9pU2xjaFVIVjNSdlJsL3NlQU8wbGNkS1lhTk5PNnM2OGVzV0YvVHdqSjFRQlZ3WHdNTnpNdUxrK0plbWxkRlpiZ0tCZTYrNmlRdEN5ZGdlejd5N0dJTllRcHlLM2Q2NEZUTFJuakZUdlpKQWNBT1QzeVFTcDJkd2hqaU1UZitCOUo1OWJXRDM1ZUNFT3JZYTBrZ1V3Q1M0YVlNd0FzWDFNZTQrc2R4TzNmWTV5K3dqaWxtaTNtOWpJa2VVbHpnZVVXalhSSUFUbkdidUFpbEJvUlJaeUtwOVQ2WkM0bFRIWXZNNlJudVhIL3Z4UGtYY1crUC85OWY4R1Y1V1JHSlBjNTBGbUJOM1lPRGJtays5ZmUrK3hwZGJqTjIrWDNMeFRrQmUremlkRWFEUU0zWFpFdDExSDVsWU1FUWJYTDluSkhQRmNneUx6T09jSmxVY01pRkZFUUZBQ05YVlFvaWw1bFZYWE4yNnRPeC8yZDlYRGdRZDVseUdFT3Yrd0s4dU41c3BTNDVuRWhrNS9NbEJqQ2xGbnNGRUhNUjJNZGFScGhva0NKdG1oV3RqQkhtNVNiQjFtZXYwa1puQ2NoYVJOVVRrbVJVR0NvUXBnZytLOFVtbWdVRThWUE1FYVRoNWJvU053OGNvWUh5ekx5M084TlZDZ2liVTJxbHk0SHlBek9UbmlROHZOOXFtajNROU5NMjFNcDZvaWtWZ2pWRlhBQldXU2VUYTNLNW9OZzdYQ1pGclRzdm9RcUFZVjQzNk9waEZGNmZEZUV4bGI5MmhVQ1NIVUZPRFdFSW4xUlZtOWZIdjkxb3RsV1RyQUN4TDBIVWprZXdDUTN5L1Rld2V3MjRsU2E3SjJXV3lnM2xONndibU15QVpRTUNZaVRnNlJ4RG1xdTBSVzZMUXo3SkZMdEkvZVlQdm1BdXR2SHlKMTUrazBGeG1iZ0pNS1o0U3FjQVFmNmxoT3dLdXd1ZTY0a1F1TGM0K3hPZDdpci8xSC96TXVXRUtsUkkxSTFabDdNQVlyUXF4S2RPcG9iKzNZa2Q3NTVjVklWbGNibXVlZXliUmtmVFBuem1hQnFoQ3NNQnc3Tm5lbVpGbEpyNVdRUkxiT09ZcEFtZWNnTTVjUVBFSHJjRXM5aUFFYldUV1JuVjRmN3YzU3hZMnRWMmNEdjA2RWdLSi84Ny80U2Y3VXYvRzNEd0R5cnZFaklOYVlLS0MyY0VybElJZ2hzaGIxQWU5empJSXZjK0trUTJ6bVVESXFwemh2YWZjOGNuNGJ2N1RKNVRmZndtMGVvNXF1b09VQytBNlJNYlN4bU9BWWFTQ29JMlFlWDNsU0UrRWtKaDlPd1VZWVc3Zi9JcHRFOTRWWEVVZ2F4NUorNG9QSFBuaGtyYnZpUTZVaElNWXFyVmJFc2FNcG5YYk10VnRUcHRPQW9HUlp4V0NVTTU0VXJDMTJTR0tMalFMV2d5c2NSZ1NYQ05ZSTFwcTZVU05nbzBnaW0xUkY4SnVnUlYwT3J6T1h1YmttZi8zLysxc0hIdVRkNFVEdS9USE5uSi9tb2FpODRCV3NWWkk0UmRUZ2ZFSGhQQkVGVXVYWXVJV041ekdhazdzTTV6emVRNjhaY2VxOFkzUDFMYmEyM21EN2p1QUh5MFRGTWxJMXlJUGdxN3BaNkgzQXVRbSttSUtyaUVUUUFDWktNSUkzdnFqdWdRT2pxdkc1a3d0cnp6MXgrRHV6dkdoNkx4aFRvVnB2QTR0YXVoM2g3SWtHYjErZGN2Vm1Ca0FjV1p6enJPK002YlpTMm8xNE5oY1djTTVCNWJEdEZJeGdyWUNvMmlnV01lbkFPYmRWNXgxYTFjT1RHcHp6QnlIV3U4WjFDUHQ4dDdxelY1U2pzUnY3TUNOb1F4RWNWVkNpeHNOa2Jzek80REp6ellSR3lDQ3ZjSFFJSmlXNGpPQTl3WU9VMENCaVljN1FiRGl5eVIyeTZVMnlrYUtUUU5HdkdPMFZqRWNWVmE3NFFnbVZZTENJTmJTU05wMXVlMk5qKy9LbDJXY2Y2bFloNmZzZlgzbHlkM2R5TmdTSE5VSVVXZUxZa3NiUVRBMWxwVXduUWhKSEdBMU1wZ1ZKRWlGR2NKVm5iemhsT0JLYWFWenZqamhQS0NvRXhiWWFZR3FRaWdTdGd0dVpUS3N0YXRrRUwwSlFmV2RTTnh3QTVQZmZrWVJwNWx6bGRMZnlHbEJqUWxBcVYrRkNRYnU3ek1remY1S3ZmZVBudWJMK1RSWmJCZ2tPRFhzWU1aaW9iczByOVZKVVBHT1BVd3hSa3RDUVFFSkZNNFpleHpJM2I1a01TcWJqbk1rd1l6b3BjVlZBUlltYVRYcUxLelMySnJCVkMrYWdjSFMxczNaOHJmZnByWjE4UG9tRVJtSUk2a2xqUTVsWXhsSW41VHM3SmRuRXNiTFVabTlVVUZhZXlCcmlxQzQvOXdjVE5uY0Q4KzBHbG9EM2dUSXJTUkZNdTRFMU1VWU1sWE9Eb25SajdqSXRpb0xxZUZyeXdpdnZMSmJGZzA3Njc2TVBVYTNGTVZXSm4zbDY5ZVRxY3Z0RFBranM5UjdUVFpaTk9IZnUwMXg0Nk9Qc0RTdGV1M2lSY1ZaUkZZTDNTakVOWktXU1RRTEZ0QzdwaHFxZXZ3bytFRUpBWGQybkVBd0VBMnF3WWtuaUdDT0NzVUljV3hwSlNyZlh0aGp6K3MxYi9iZG5GMlQ4bWU4OCtiSDNuSi8va1ZiVHRxTElJQWE4ZzZKVXFzcXp2bDF5OGNxWXljUVJBbGhyU0tLSW5mNjBMaENqdUNwZ0RMaktzYjZiNDF5Z0VVdTljT1VjVmd4eDBzQkVFa1paK1pzM2J1MTlLUVNkaXBBem15eCtKMzZLQndENWZiQk9KeVlFbGZ0SUVhSk9PNG1PSGUwOTAyaEd5elU5V3kwdU84MUh1TkRrL0VNZjV1eVpKMG1TRmQ1NCt5STdnejVaQlZVbE9LLzFqb2RDV1NxaERQZ3ExTHZvczlIZDRCV3RBcW9CWDNueXJLVE1LMXpsUU1FYUN3S05adUs5OHMzcjEvY3VBZEhKdzUzVnozem44Wjg4c3RaNHhJRDRBTTdWOVFVRjlvYWVHM2N5Tm5jeXh0T0tSaHBSVm9FMHNZakM5czRZTVdZMkFsK1g3bHpsR1U0OWFTekV0Z2FKZW8rSlJHeHMzY2JXNkdmdmJJeGVCNTFKSThqOXNnZ0hBSG5RN2MvODZjZTRjWE1zMCtsZERmSjRmV05hUGZIVTJrUE5kdnFvRDRneGdnOUM1Z3gzZG00Unl3cHJLNmM1ZS9ZUjFsYlBzTk1mY2VQMkxhWkZnUXVHcXFpSkdlNk9tUmNlbHdmSzNKTk5ITk54eVhpUU1leFBHUTh5cHBPY3FxZ0lQdXhmOGdoQ2tzUlZYcnJuYjk0YVhBSGlIL2o0c2VjZU83djRJOE54YVBZSHRZY295MEJSS2xrVzJCMVU3UFpyV2JqUnVLU3NBdTFtakFab05ST2NEK3p1VFREV0VIeWdLTXZabmk0TXBvN1lDa2xrMEtBcUlFUjI2OWJtK09mN3crd21rSWxRd0R0dml2Y0FJTDlQOXNpeFJWb0xDVnZiVTRiRHU4T0tjZVdDSGpyVTdTd3V0NTlCVEVzVW5JZlNDenZUakpkZmVvRWJidzQ0Y3VRNFo4OWQ0TUpENzZYWE9jVGxLemU1dmI1T1VRYWNoendQNUxtbkttb1BVaFdlNmFoa3NEZGxaM3RJZjJmRWFEaW16QXBjNVFqZTQzM0FPNGQzRGhHcHBybi82c2JXK09xWjQrMmxmK2xIenYrcHhibk8rYjI5Z3VFNGtCY0JWUmlPSE5kdVQ3aXpOVVdBWmhMVFNDTjJoemxSSkxRYk1UNG9hUkl4bVZia2hTT0VnUE9PYWpZQ3J4NnlxZzYxckFGVUtaeStlR2N2KzhWcFZnMkFEQ2pqMkxxSEgxNWxhMnR5QUpBSDJTS0J6V0hHcWJVZWQ3WnptZFM2SFBzTncyaHJjem80ZldicGZCVEhaK3Y5Q1pGS1laSUpVei9sZDc3MFJYN2w3LzRtR3VEUW9jTTg4Y1N6UEh6K0tWcU5SYTVldThPZGpXMm1lVWxlQklyQ001NVdESWM1dy82VTRXRE1kSkpSbFdYZHVkYUFxN212N2o0aEJEVG9jRGoxLzNodmtOLys4VStmK3NoM2YrVDBaNDJKb203UHl2SmlHMVZsTUhIczlVdUdvNUtpY093T002TEkwbTdHeE5hd3RadlJha2JFMXRUYkx3akRjVEdiNksxWGNVTUFneEtDa3BXZWRzTmlCU1paOWRwbXYvaEhwUXZqR1VBcWEwMndJb3pHeFFGQUhpUjc0dGc4eTkwR3U1UDZVS1lHVnVkYjlIY0xXZCtaM3ArSFdDQ2FUaXVQeW1oaG9mMEVZaGNxcjFwNlpKcDVuQk82cTAxdTNyakszL21iZjU5Zi9lVmZvU2dxSHI3d0NFODk5VDQrOG9GUE1oa0VQdmUvL0NZNzJ4TTJ0NGRzYlBYWjJ4c3hHSTZaWkRsVlZjMDBGYldlZEZHOU40V29xRFVHRXlmZnVIWm4vS3RyUzJuN1QzL20zRSt1TFBWT3FEcnlMSmNrVmc2dEdyd0x2SDE5UW4rWTAyckcxR1FLT1huaGFEY1R2RmUyQnhtOVZrcFFpSzNCdVVCZVZKUmw3ZGswQkZBbHRuVU9aUzAwRWl1bDAyL3VUS3ZmckZ3WUFmbU1hRHMwa29oSlZoMEE1RUd4SXdzOTVwb1dZdzBiZ3h4VkZhL0lwSEJta0pXbXB2VlV1NStrTTFPWnVuTm4xTTh5djkxb05oNEp3Y3psRlZxV1FWd1Y4QjRXanZUb3BqRmJsOWY1OVgvNE9YN3QxMytkYXpldU03K3d3UFdyMS9uUzU3L0NqLzNRbitYTXlmZFFaRkNXOVhCZ0hlSHZqMytadWdHRFlvM1V6YnNRaU5QMHp1N1kvNjJkdmVtMTcvL1lzUTg4K2ZEUzkyVjVtUlpGS1VYdWlhTTZaT3YzQTNqRE5QTVVWYUNSUm5SYkNUdDdHZjF4d2VKY2c4bTBJaXNjdlZZTkdHc00vV0ZXRndrOFZLWE8xckZxRCtNY1lpTnpjMUtGLzJGOVVMeXhIMTZKNEZUUmJpZGxQQzBQQVBJZzJOR2xOcUtHL3JTUXpXRXVwZmRtcGpKbHRhYlYzTmZyU0FRYVVyY3VHa0NxU210amZiUTdIaFY3eHRyallPYUQxb0kzM2ltVlZ4cExLV3ZIRnBnM0NUZXYzZVR5RjE3a3R6LzNPYjc0L0pjWjV5WHZlZnhKM3Z2a3M1dysvaENIbDA0dzExeWlIYy9SYVN6UmJpMWc0d1pWcUFpK1FoQkNDQnBIVVY0RSszZHZySTkvYTNXeDBmM2g3ejc1UTcxMjhsQ1JleG1OSE9OeFlIdlBjV3ZUc2JIdFNDUERmRGZCdWNCd1hHQ05vZHRKR1U0S0JxT0NSbUxaSFJiRWtTR043VjBXbGIzaGxNZ2F2Qk9xdTRQc2dpcVRVUkgrMXAxeDhjcys2Smlac0tjSXdZam9hRksrSXovckE0RDhIN0IySTJZd3pXV1lWVks0WUZVMW1vRWk1WjRDVkJOb0FjMG9zbEZrYldvams5YWFIeEx2N2s1M2RyWW50OVhyR3NnS05jVmdUYnlRZTF3RXlXcURwYlVlRnhaWE9lUmlXaE9sbkJSODZaV3Y4NVZ2ZkprWFgzMkoyK3UzMk83djRyV0N0R0tZN3pLWjdsQ1ZVeVFFZkZDTXNXT24wYy9jM3M1K3NTajk5UEZ6UytmZTg5aktEMFpkTzFkSVRHRVNTbU81dFY3eDVxVStTV0tJWTR1MWhtNHJ4anVsUDh3eFJwaHJwMHl6aXUzK2xDZ3k3QXh5NWp0cFBSTGpQRlhobUV3cjRqZ2l6Q1o1UlhDVjZ2KzZWN3EvVWJpd09mTWVPZURTeUliNVZzeTA5Ty9NdlBMZ3VQK3oyMlkvRTBCbWVuNTN3eWZ1YVdza2k0dnpUUU5wWkVPdjIycDlxQ3FyRlN1Um5Vd3pVWUsxVWVJbm1kc2I3VTZlbisvWTQxYzNSNzMyWEpPa2s0SzFxTlNDSGFZaHJCK3IwQld3MHk3SCt6SHhhTXlvbURJc1JreXFnRUVSQ2JneXB5b2NWb0JRcjR4SGtkMHJnL25aMjF2VG42a3FYd0ppT28zcXlKTnpZV21sRGJLSUo2Ykl1NVNkMjF6ZmZaRlhyL1E1dHR6bTZHb0xBeXpNTlltczRmcWRJVm5sbWVzMlVJV2R3WlNneXRVN0ExYm5XemdmU0JQQkdNVzVRS3NaTVptR1VIbi82c0Q1djVVN3YwN2RGQ3dBSjBoSVkrcXA1bmRxNGVYZ3VQOXZXeU8ydUtBNFgrL0hoWHVKZHpKN21rQzgxbXNlbWt2TmlibVZGYk8wdlBiK3Q2L2VibGRoc2x3V3hmZjRva3dxSHhOaE1NWmdzUnFFNmZuVGkrWDMvY0NSMWovKzRoWXZ2THBEV1hyaVZrTFNTdXBiWEVCRG9Dd2RaVmxST1VkUWp6VWVReUNVanJ5c1prc1hnakVDcXFJcVBpQXZqM04rZXFlZi8rUEtoVXdFcTByeTNFZlhEcTBjNm5VYmpTV2NTOG15aVBGUXFhb0o1eDViSldsWlhubHhuWjMrbEVmUExJSkF1NTF3OXNRQ3IxemE0czdXaU1WZWc1V0ZKanQ3R2VzN3RUQm95OWJzSnQybVpaSUZ2UGNzZDd2RmJ1NStLZXZ2WFJGd1dvT2pBcnd4YUZFRmJTVnlBSkEvcW5aNHZzSHVaRlpkdWJjRUZkMEhqSmFJdEQvK3lOcFRwNWM3UDFHVzFXT1ZTc2ludTRlVGF1S3lyTFRqM0RVam9yb3hvTFBpa25qaWhwbDcvL3U2UFBab3d1TGNZWTRkNi9IQ3l6dThkWEdMTzFkMlVlb05QR3ZxZlR5RG9scjNLWlJ3dHlGdmpZaEJ4S0NxUVFvWHVBejZsWEVlZm1rMDhmdTZnS2lTSEQzYW5uL3k4Y05QZDFwTGMxNGJlSjh3NkFkMnR0Zng1UVJYVlJ3L1BrZTNuZkRxaSt1OGNIR2JNMGQ2czBsZDVleXhCVzVzanRnYjVzeDFVcFlYV294djdYSHR6b0FUeTYxYUowaUVaZ1B5cWRHVmRENXF4SDd4K3JCZkJjV2g2a1VrUk1ib2tmbEZ2VFBZWm4zZzNyR2YvMEVPOG52WTZlVTJMaWhlVlVvWDdqYjlaamxHQytna3NlMys0SE9udnV0OTU1Yis4bHdqK2tBcmpoY2FSaGZhTnNScjg0MjBsNXE0bTFvUlZDb1h4SG1WRUZSY1VQbmdoeGI1c1I5YkpZbUZKTExNOXhMbVZ6b3NMdmRvcGpFU0F2bkVrWThycWdKOEpUV0xpSXBha1dBUUZTV29sMXdEdDUzbmQ0cUt2NU1WNFdkMmgvNVh5a3B2TXFNZG1yMmsrRi8rOCs5LzVpTWZmZVFuNHFUZHJWeUwwYkRGN1pzM3lhWjd1Q3lIMHFOQUVsbVdsMXBNQzhlVkczMWFhVXdqcWUvVHhWNERhNFRiRzJQS3FxTGRzUFZ1U0ZhUkdNRTVzQ1ptTVYzVVJGSkI1UGFkeWVpTGxYY1prSWxJRlJrYmxqczlOa2ZEZC9RWk9QQWd2NGZGUnRqS0hGbmwwWEJQYkdZR2p2WlNOMTM5eENPSC90akRoN3AvT2tHT090Qld4MnB2b1NPdURJeEhKYWtZZW1uRVVxdGtYRlQwcDQ2TlBVOXZPZVhILy9naE9yMlk4U1NDYUJYc2xJWEZLU2FPV0YxcDBOOVo0czd0TVRldTdMQ3hQcURJUFhGaUNHSXZEY2JsMTBTMVVOWDFvSHBOVmJjcUgyNVZYdnYzZ2FLY2VZOElpRnV0S0w3dzhOR25PcjNlV245WWFWVXN5V2h2UUZsTzBGQ0E4eldubFNxVkN5U1I0ZnpaSlJwcHpKdFhkamswMzJKdHNVVlFaYkhYSkJ4U0x0N1lnVkRSYTFxMitwNVlQZDFtektHNU5TTFhsTUZnSXUxMjQweXYwVnpNcW1KSFpoUU9RUU1oQkgybm40RURnUHdlZG0xN1NwSVlDVUgzQlM3M3c2cjI2ZVhPaVdlT0xmelV1YVgyai9SV2tzN2ErUmFkdFVRUVg1OEFoYXhmc1hNcjU4N1ZLVnUzTTFyamltN1RzZENwQ0ZIZzRxdDlldk1KUzZ0cnFEMUIwc2xvNkRZaDlORVE2aEpxRXRHSUkxeFpNdGliTUQvZndKbjRyYTFCL3ZObDRmcUtEb0RKTFBIZFozTXM5K1A4V1pRUUFkRVRUeDVkV1R2Y2ZTb3JjaGxQVWgwTmR4a1ZPMGdFbElFUVNkMFpkNEhVMUNUWWxWZE9IR3JUc2NLTGIyd3h6aXFPcnJRcEMwK3pFWFB5MER3WHIyN2hLcVZsTGVOcDRNS3hOWTdNSFdabmR5QkJBK3JENGNWRzYrakdxSDlKNjRFRHE0cDdCNjZnSDRSWS95eDJaclhGNXFnMFlVYitOZ05INTZHMTdsTVhsanQvOGVUeHVVOC8vcW16clVjL2RaUzFjNGIyQXFSdGFIUU5qWjZsc3hLemNxTEowWWU2TEIxdUVzZVc0QVdYMVRvRmI3emE1NVZ2N0RFYUczcExTNWdZeW1wRWxrL3h6dU45VGVjNUhCVGN1Ym1OZXEvTlZrT3cwZVh0dmV5cmxmTVRZSDlrSXdPbSsvMkZHVUFVaUVTa1lhMXAvdmlmZU9yakgvemc4UitiVEpJb242U1NUWWNVeFlBeUgxTVZSUzJqNEdzNUJWRkJaaGQ4Q0VvampsaGRhSEo3Yzh6ZXNLQ1ZSdldNMTJ3WWNqU3VjRVhnN0pFanZPK2hSOUZRajdsUHM2Sm1WVXpqaTlmNk82OXdsMjFTL0tUSzFZVndBSkEvcXRhTUl4bmwxYjczU0lIV1FxTnhJdFhrMzVZMCtzUW5mL0twNkpudmYwaHNYQkc4Z0k4eHhNaitUSktyMStSTUpMUVhZcGFPdDFnNDJrRk5SRFp3eEdJWURncmVmT1UyYjcxeGplRmdRS3RuTVdrOXNldG1MTzJqUWNudDYxc3oraHlSVHEvcjh5bzhQeHBsMnpOQTdJTmlYOVpndjZsUXN6b0s3YlZEM2NXZityUFAvWm5lWFBmQ2FKQktOczdFbFNOOE9hVXN4cWdMUkZKZjd5RUllZVlKcFNkS1RDMnI0QUtSTmN5M1UzWUhPWHZqZ21aaW1XWWxWVkZDY0J4YldkUHZldUpKU2FPWW9uSVVaY1Y0TWxVTlJHa1NiMThkN240NXFCWkFpZUNkOTZFUjFSdUlCd0Q1bzFiYVRXSkdXU1crTHVrbVFNdUl0TnBSK3NrcXlKLzY4QTgrSFAvQVR6MHRKcXI1cVVTYUNDbENDdExFdXdwVnhVU20xcUhTZ0xHR3RCT3hlTEpEM0d1UWJaY2tHS0xJc3JzOTVPckYyMXk1dUVOUlFtdWhSZkJDV1FUeXFXZHZlNFNybktncXJWYXJsN2JTalkzTjRTWFYreFdqdnVVbEdDQVdJeTFWbXQvMzZRdlBmdC8zUGY1VFJkYnJsSVdoeUVkU0ZnT0tiRUR3SGxFbFZJcG83VEdDMW1RTFFzMjk2d0tVVlgyUU82MkVXeHNqeXRKaDFETVpaMVJCMTU4ODkralcrVU9IdThQcHhBd25VNHF5WXBybEJJOXBOUnJEZnBsL2VWemtnNWtYY1NJU3JCajkyRU9QY1hWbjh3QWdmMVRzMy8wcmY1N2YvUHpYdUU4L1BBRTZDdDIyTkQ3ejhPTXJULzhiZi9VN1pHNTFYdFJiak5hS3RPb0Z3WUpKTUZGS2tyUXdVVUlVV1pMRVlvM0RDQ1JXNlM2bkZGSE1lS2NpQ21DdHhZZ3dIa3k1Zm5HYnZhMGNrOFFvaGlMM0ZKbG5Nc3J4UGxDVnpoNCsxSHRvWWFtNWt4WDVScGI1KzBFUklYZm52MUtVTnRENUMvL3FCejl6YUhuK0Eza2VteEJVZ25OVTVRUlhUWEdGeCtjZU42cHdsU0pHc0xPbCtuMXlhaCtVb2doazQ1SXlkMHpHVTI1dDFwN0hlNyszVjRTZk83Rnk3UGFwNVlXSHM3eUlLaCtrTEV1TU1hSWVJbVB3Nkl0M3hvUHJNeTlYaVlnLzNGdlFwWGFYSys5UWdCd2s2YitMcFduQzRVUExzckc1S3lFRU0xT2tUWThkWGxscWEzTGh5UStlTUt2SFZuQ1Znbk9JQzRqMzFOUk9BbUtRdUFkNFJDY1lTVEhpc0xFbFNpcktvcjZhamp6VVlhOHc3RnpjSmJyVnArbVZ0Qk5UVkNWNzEzZXBzb3hEWjFmcExuVTQ5OWdTNXg3dDRyM1M2alJZUGJJODMrckcvN0lMMVh2SDQycjl6dTNKYTkvODZ2WFh2dkg4clpzaE1HSEdlUVdrSC8yT2syY2ZldWpRQjcxckpJSUJWNkd1cXZkcVE2REtQWDdrY0puSE5DM1cxR3U3U0VrVm9QVDE3b3FJVUJhT2pmVUJrOUZVeDFsSm1mbEpvMmwrY1hQb2Z2UEs1dWI1RDU0OU5VNlR1R1Vsd3dpa2NVUnVLa1RrMEZLei9Zd1IrWjJnT3AzOWJwSkVrYmpnMzdIWitnRkF2czMrby8vSC80bGYrSWVmWnppYXlFenNQZ0ZOclRYSlQvMkpUMy8wNVZkZWYvanBqendrY1N5RXNzQk54MFJZSWpYMTdKUEVXQk1qVVV6bENveFpRV1VFT2lhV09VemtDTEhRU0lSZU51RFFjWWpiTWY2aE9acDRtbW1EcENtMEY2QTlseExIQ2QyRk9acXRsRGlKTURZaGlpSkVZbkUrckJIays1enpqRWY1M29jK2RPN21heS9mK1BMZisvbFhmdVh0aTl1M0FSc25OdjNoSDM3c3V6dXQ1SHdJTlhGQzhBWEdKZ2lCU0pSWWxhTHdZQVNUR0ZRVWxRRFcxQjVDRlMwOWVWWnhaN05Qdno5VzV3T3Fxb1dHZjdqVHIzNjI4cUc4dEw3KzVyQW9yM2VhN1pWMjJ4TVVHVTl5OWdaVEt1ZWp4Tm9qelNSdFRvbzhtZ0hFYkkrSDRjamN3Z0ZBL3FqWTFldDNRRlVtazN3ZklMRXE4UTk4ejBkUGxubjFtY3FQNW80Y1NpakdFOFJCWkZNaVV1SVFVT09BRkRGSjNYQTNnU0E2dTh3VFZDS3dDYkVSVkQyTnVHU3hVOUJNRTZKT2cwT0hsMWlhWHlPT0s2eXBpRXdMRVZ2TENFaUVjMjZtWW10UXRVUTFTUy9ZaWs3SExMUWE4VUtuRTg2M2V2ck1ML3pzVzMvajlSYzNMejE4WVdYMXhMR2w5MXNUTmJKc2l0TENSREhXSzBtMFFKNzNRYUhaaS9BQzNramRITDFMYVYxTEFnMUdPVGV1YnJHM044SUFUbVduOG53eDkvNXZsaTZzQzBTYncxRSt5UExYRGkwc1BsVTR0YXExQWxhamtaQlBLeHFOeHBtVGMwdUhYdHU4dFFWWVZNMjR6T1VyVjkvaW1XTm4rUHJOeXdjQWVhZmJyLzc2bDluYTJVTUVvMW9QSVRaYmpjYUZNeWZlLzRVdmZQMjhaMGVLMFIxMmIrOUE2V2trY3pRNzg0aUpNSEVYNThHSG1yUXdrTTQyK1J4Z0VZMFFTY0drcUszb0xEV1J0TXNrMjBLTTBtMmtkQm9SeHFSNERiTlI4VHF0cURmM0xEN1VESVdSdFVRbUpqZy8yN3VBeW9OWW01dzYwM242dTcvL29VUGRlUDRySC83b1lidHlhTzY4ZHpVQnRjc2NWVmtSQUltYitHQ0lSTEROaU16WE5DeGVsV0xxOGFWblBLNjRkV09QOVpzN1ZFV3B4b2g0ek1WK1VmMFg0eko4TmFqMmdRcVJXRlhUUytzYkw1MC9jdVNINDhoMnJMRUVBcTFHZ2pxd3lLRjJuS3dCYjh6T25nbXF0T0o0Um1KeDRFSGUwWllrQ1ZldTM4WmF1eitNR0FQSjkzN3l3MGY3L2NGM3JtOXNkaHBOMWNsZ0tzMUdSalZ4bE9NUlJUV2wxVm1oMFppbjBwcVlOb3FiV0JWRURNYTBxVnlKU295UW9qNENMV2swS3hBaFNaUTBFZHJkRnRZS2xnaVhEUWpCRXpkYWVKOGp0Z2xZWW10UmRSaXBRQjNHSkVSWU5KU29WWXhSTVJaT1BOUStPdHdKbnoxN1pDRklSZXhteERvU1JkZ1FDTVdZc3VpVDlwcVl5Sk5ONjBxV0lyamM0eVlWL2IyY3ExZDMyYnpkeDhhS3NWWUN2RDNNOWI5WjM4MC9QK3U3VEdaSmQ2S3Flbmx6NjYyc0tOZU5rYlBHR05xTnB1Ukp3WFk1b29XMHU0M21VV3RNN0VPSUZLeUFKTmJLTzdXcmZnQ1EvZktQTVVoTjh5OGgrSDFkajZUVmFxU25qaDE1K3ZYWDMzclBjRGhFUTFNMk5rWXNyWFh4QnNSNThza1daVGttU2hld2NZOGtua2REUk1EaVhNQTdRMVhGT0creFZvamltRGhPVUNZMG9vUk9ZNGxXSzhJWVA5TTZkNkFld1pNUDFpbUxqR2J2RUNadW9lcUlvcGhheVRuQ0dvTXhpc0dDQ28xbWpHaUszeGp3aU1QMHJtN2JPK3M3SkswMnB0V2dTRHZZeFFVMEZ1SzRqUVNIa3pGM2oyZFF5c3l6Zm52RTIyOXRNUjZXeEluRjJxQlYwQ3VEWFAvekd4dVR6ODhhbENQcURyN09CRGlUbmRGb2MxeVdsdy8xZW1mSGt4eVpFV3BIVWF6dFJyUFpzSTNuVmpxOVgxMGY5c2YzaFZrK05ucmdRZDdwVmxWVkxiRjNyM1BlZVBhOWp5MjVxdnpFdFd2WDVxd1JxdEt4TnlqSmNxRnlRc0pNaHFESXlJdUNTcmV3VVpzNFhxYlVsTklIakJoYVNaTTQ2ZEh0cmhIRVlaZ2dCTHdFckFuc3kvU0oxcnZjU1hNUjd3TWhwRFFzeEhFSFZZKzZLU3FBdERCUkMydnFYUkFORU1WS09nbVVWd3VTTnlhY3FJSllwNVFEajdORFNxMDdkSForSG5Ob0hqOEhyc3dKWHFpS2dCb1lUeHhYcit6dzlwczdUS2NsU1NKRXNlQThtNFBNLy9jM3RyTGZDcXBEN25Ydzl4ZkpCYWh1Nys2TzNyeDkrOHV4Mk8vSXFpcEZMSjFXazZKd2VPZHBONW9YbHR2ZFErdkQvcVpBaElnTnFrNlNWcDN3SEFEa25XdWg3dWdhNnZHTUJJaVg1bnNuN3R5Ni9kamU5amJXV00xS0w3dmJqbXhVeC93aEZyVFdzcVJBS0VNZ0c0M0lzeUVTUlRUYkhSck5MbEYzam9XRk50Mk9raGNqcXVsdDRqaWkwUlFHTzV0VVNaTjJad1VrQmdJYWJGME5hOGU0UE1ON0piTDFZbTlWalRGUkE0T3JHM3hCVVY5UVhOOW04TkpOOG8wSmtnZXNLRWxxaUNSbU9IRk1NazhjRy96dWdHSXdacmVodEU5MHFZS2lrVERvVjd6MnlqbzNyMndpS3JSYUZvd1NZRzljNmY5NGF6di9sUkIwTkFQSEZLaWs1ck9UV1poVmxzNlYxM2QyWG4vMm9mT2JaN3FkNDN0N0F6YThJMnNta28wTHJIS29ZZU9qd092VVUyREdoeUMzK3p2dnlIYjZnY3J0dDRMalhsYU1KaXNyaTYwTFo0OS8vTTd0OVNNYWdxS0lWc3IxUzJPeXFTZlBZVzhNZzZrd3lXRThVU1pqbUV5VW9xcHBPRU14cGQyTWFCaElwQVRaeE9vZHBOb2xFazgxR1dDS090UXkxSVV6Y1I3ckhhS09NczhwcGhPcWNrUlpqcWpjbE9BcjFCZG9sZU5EUlRtWnNQdTFOOW43eDI4VGRpZEVxbGhYNzdpWEFmb2poeStGeUF2WnlOR2ZsR3oxcDhUYk9YSjVTSDVyeXZyTkNTKzllSnVyVnpicXNxNmwxaGMwWmp5dDlHOWYyNXorUGVmRDRIN1BJU0t1a1NSQlJHWWN1L1dveSsyZG5ZMUdHcjIxdkRCSHU1bHFNMDFZNkhRd3h1ak9hSlMyVFB4VWJHeGNWd2pWS01qZWVDaWZldTVqQnlIV096MFZBYXpVRlpuNDZTZk9IMnMzRzk5MSs4NkdqYXpGTzhFb3JOOGFNZHdxY2NZeUtaUTRGcHBwTFczZ1owdE1Zb1UwU1ZsYU9zTEMvRExOeEtKU1V1WWx2c3hwdEJZUUV5UEcwdW9kSlVubVpyZzBSRW1ieWQ0R2s5SVFOWmF3VVFNTkdVaEJVSXN4U3hndkdQRlU0ejViWDdySytNb1d4Z3FKRlNKajZvMlZtVlpnSjIxUWlXZDdWTEErS0dndHhCdyszTUo0OEJOSEt3cmtvNHJKNWdnTllDTmJOOUJGWEY3cEwxN2ZtUDVzVmZtOWJ3T0hCL1R3NG9MdWpzWU1wdE9ncWg3d3IxNi8wWC90NnJWYmV1UW9veXhuVkZRTXNpbURmRXFlRmFhYnhPZmJTZHJwNTlQSjdBemFTcjJYZDJBbDZ3QWc5MnkvOG0rQlJFU2lSeDQ2OWN5WHZ2ek53M21lcThISS9uVDJlRkpTNUxWMlh6WjBESlU2bExHQ2lZVTRFWnBOWVdtK3pjTENjdDJjQTZvcVE2cVNVSGxLTjhUYXBINlNGaUZFcUFzb1N1RUN3eEU0YnluTEhHT1ZORFZZNHlBMElRaW9VRTF5K3QrOHllVE5UWUlSSWd6VDNHTnNUYThTbkRJYU9ocVIwTzBtQklub05EMHJpdzBhcWFYeVNtUWpSaU9Qamh5dFBHWXZPQUExUnJRS2ZPMzJUdll6MDd6YW5GV3JhcW9leEtXeERkMU9vcGZYTjFqb3RQZnpCei9MU2NySmRIcTdQeHJtb3l4dkdLQ1pKclNiS2VxQ2RCcU5jNGU3YzZmNytYUlRSR0xBZUIvTTJ6Y3VoM2RhSG5JQWtHOEZpQkdSU0ZYdHd4ZE9MWFJhclE5ZHVueWxZVVFJczNFbkVjR1h5amozTkNOTE1YR1VXaysvMmxpSUd4RXRMTTJtSlk0RXJYSUtGeWdreDVvcGtSRU1LZDU3S2lkWTQ3QXlCbUpFd1BuQWNLL1BlRHJGbWdUdlN0SjJpM1p6RHJ6Z05VSzhFSm1FM1pmZlp2dVZMVW9mYUhkNnBISEtNTnZES21SVHBUL3lUSWNUamk0cFZSS1R0aVBtbGl4eDJ4S3dqUFBBem03SnJac0Qzcnd5WUtmdm9XWFFwVURwOWRXTlFmbmZEa2JsVGVwcDRiczhWa1lJalVha2pVYk12Ly9qZjV6LzRPZC9RYmtuSisyQlltTTR1UGpvMGFPN0M1MzJFWU5nalNWck5tVThtbXBabG0xcnpOcXNpaFVwV0IrOGJPeHNIM2lRZHpoQTluc2YwZnVmZWVMazF1Yk8rV3lhRzVCdnVkZUNnN3dLUkRGa3VhZDBOWVdJc1lhb1VJS3J5MkJibXdQVUJ3d0pScVpFalpyRXZKa2VCb25SVUtEV0VrUlJuNk1oTUprTXlQTUMxT0JjUm1xRWJ0cXBHZHlEMWtkUUVvcVI0K1kzYmpQYUdLSU55MXl6WkRpZHNqbXNhbGFUeXRGdUdrNGU3cUdsTXB3TXFhS0VTU2xFempBcFN0YlhCOXplR0xQWjk0eW5kWGhqY2dNVE94alo0aDl1N1dadmNvK0ZwQUs4aUlUbHhhWk9Nb2YzZ1gvLzcvd2M3ei8vRUM5Y3VhS2w4eDdVcWVLdmJlL2VWcEdOT0xKSGF2ZWlXR3VJbzRpOHFCcEhPdk9QdjdtOS9sdVY5emsxQVl1TWl1d0FJTy8wOEtybXJTSSt2TEp3OWt0ZmVINCsrSDIxc250NnllTnB4V2ppbUZ1MkVCdWNVOHFwd3ptUGpTeDVIbE5XQ1pWWFJ1T1M3bHlMZGxNeFZZbXhocUxhSnJhMWZFQ2Fkb2h0VEhBRldUNmlLUEk2RlpLWUtMWjB1bld1NHZJUitBSTE4eGd0Nkw5MmphMGJlNEF5MzdiNHdqRVlPbnFtWHBWdHRST1N0QzRiRjA0eEp1TFh2bkVOVmVYRVVvZFFlYTdlbkRBcExEWk9VQzB3dFE0T3JrOVpXaGxTeTVqc1N6UUhRRU5RTnJhbmQwUE4vZGlxcUp4YVl6UUU5WUM3dEw2K05jenlpeXVkN3VNaUdwVmxpUThlTVNJS2FTZEtuam5VbTErNXNiZXpOenVINzhpQzBRRkF2aTFCQjZLRitWNXJOQnhmMk4zdGR3WHFmWTQ2dnFySE5VckhhRndnc1NWcVJFaWxUUEtLN2ZVK1pWR1NOaEo2QzIwV1Z6djBGMXQwNXBUdW5LWGRGaG9wV0RQRlJ0Qk9CWkVLTDZBS1JWbVJWNUJFWVBFMDRnNUNSRmxNc2NIaHFna2hXSW8zZDhsZnZjbXhwUWFGVjVyTm1PblVzWkFvVVdKUmxIYTdudGZhbmFTVXdiSTduWEo5ZTh3Z0w1bm1HZGJCYUJ3VFJURlpYbEY1eFJnREtPTDh5anpSOTVkSis0MmRZdEtmdlMvN29wKzBtMjBtMlQwbTlxOWVmS3NHaXVwTStBRGZIMC9HcjkrKzlkWFZSeDc5WkJ5blN5SVRRRW5UbU1rMHAzSnU1WEJuN3VTTnZaMjNnVWhWelV4YlhwODVmb2F2MzdoOEFKQS9iRXZUbEtJb3ZqMy9pTDd2VXg5ZVUrV1JvcWhzVU1IT3BQenFRd0JHRFVVV0VBdHB5ektaT3B3cWU0TXgyV1NLR0dGOVk1djBja3B2b2N2cTRUbFdqblJaV0c3U2FGb2FEU0dKaGJ3cHFHWkU5YmtreTRRc1Y1cFJvSlhBYUhlWExKcGd0Q0pPbEtwMGhMZDJLRit2ZWFnQ2hsRlJjYWsvWmpHMXJMWlNpaERSYURYWm13cTVnOEhVTXh6dE1aeU1hUm5MdFR4d3MxOXdwR05wdGlLS0l1Q2RueTFGeVN5YVZJbGNlRzZsMmZxQnFmcnJXWm52ci9KV3hoanBOanRNc3NtM0pOTVhqaHpXSzV0Ym9mSStvT29WeXV0YjIzZk1lK3pFV3J1VXhoSHRSbHBQRnFnaUxzd3ZOZHJuUk9TTHFwb3A5U2hBWWlQa3dJTzhnOXlHTVlRUWhGcnROVUtJbm4zeXNVZmVldVB5MmVsMGlwZ3dFNStzZ3dsalFZSlFWWFU5TjIxYjRtbEV1OXVnMlc1UTVBVStlTlFMNDRsalkzdUhxNWQyV1Z4S1dUMjJ3TnJ4UmVhV1duUTZFYTJtb1Q4d05CcVFSRUpSZXFxcTdzdzNFeEJYb2xyUVNBVnJsSkI1eHE4UFNBdEZFb3VJc0ZVcXI5emFZcjZWY201cG5qaEphSHJJeTRwcFhwSVZCYnVES1R2RENTWlU5RXpFOXRSampMRGFLUEFoRUx6Rmgzb3dxdlNLUnpXQldGejRycm1rK1d0WlZReFFqV2NocUp2bWszK2kwclRZN25EVDdsSTV0MS9KQ3BmV04yNzFSOE5yU1dTT0owbENXVG14dHA1a2RwVnZSbEZ5dXBta3JXbVJqMmZsZGROT0czWEg2UUFnNzRERVl6WjdkVitDYmxlV0Y5THhZUHp3OVd1M0ZweXJpR01CQ1NoZ0NLZ3hvUFhPZUY0QmtjRTJJcnFMRGM0OWZJVEJYcjBvdGJqUUlVbFNwcE9TNFRCbmIyK01HeGVNM2g1ejY4MU51cXRkRnRZNnpNMmw5SG9Sc1JYVTE4MDlWSWxSekl3d3JsWlFydFZ4ZDN4RmNXZE1veEZoSTBOZWVDWjV3WTNORWFYekhGdm9FZ2IxTFYyNXdHaGFNcHBrbE03VFRnMXJUU2d5NWVaSWljWFJhMEJSR29LQ05SQkZnZ2txcW1oWlZrYzdVZnJweU5oWG5IZDNkemlHMC9FLzBmVzJ4aklwaXJ1VkxJRndaM2QzNTlMNitpdVBIenZ4Zm10TUxOUlNDYzFHd21SY1NLUnk4bEIzYnVseWtlL3M1eUY1VlVyaDNUc0dJTy9xbGRzMFRYSE95U3d4VDRIbU0wODl0dHhKR3ovdzhpdHZuQytLREd2MkNaZ0ZrYnJjWWxBV0RuVllQREZQWkd2WmdUZzF6TTAzT0h4OGprZmZzOHlqRDUvaTJMRTVWdGNpVm8rME9YTm1tZTk5N2xGNnZzdVYxOTVtNjlvZVc5ZUg3TzFNR0k4cnNpSlFPdXJ1ZHhHWVRqempzV004OFJSNW9DenI3cnhHbG14blNuOXZ5bUJjVUxsQUhCdTJCd1Y3MHdJYjFUTmRXZTRvbkdNNnpRbEJpYU1JTVNCNHlsS1loRUR1bE5nb0JJUDNOUXIzYjR1Z2lLcVlTT2lsbmRienczeDZtM3FQM1BHN0NHNWVuNVZvcGI1eExDS1JRckl5Tjk4NnNienlpY2swYStSbEFTcDRwK1JGaFRFbUJDTmZ1ejNjdXdWVWdsUkJOZlN6aVQ1KzdCVHJnNzBERC9LSGFiUHhFcmsvUVYrYzd5ME1oK01UZzhFUUd4a2xPQkdSMlg5VWc4UmFJVGhIV1hqYWFVUzdWU3N0UlZKcmluZmJFYzBHZUZlQVVWcWRoSE85SlpidFVTWTNibkxtOEJ5Yk95TjIraG45aTFPMjN4d1FkMklhaXhGenEyMldEOCtUUkpicHNHQThtRktWRlVrYzBXekVwSTJZdUpOZ3hnV3R5SkttRVhPUzRnSmMyZTV6ZlcvQTRWNkgxRVE0NzhsQ0xleVppc0g3VUpOS0cwdlBDaU5mc3A0RmVxWWtJc0VFaTBQclJTd0VBUTNPSCsyNTZLUFdSdC93M3Uydm52eGVwaUxpVmRVQjdzcm01clUwVGZZNjdYWXZxenpEYk16VWVhYVZaN0hSWEc1THNqWTdoelA1Q0JVZkF0YStNKzd1ZHpWQWpER282dDBFM1JpSmxoZm1qbWZEeVRIUlFLc1J5eVNyNnZqTDFNVFFJa29zUUFnMWI1VkNxMm13QnBveHhMR1FSa3JRUGxYd0JHTTQxVjNBYkk4Wk5UeFZrZEZMSTZLbEhzMGtZbmM0WlRTcHlFZWVVUi82MTBaczlQYVlXK3RnVTB0UmxFeUdZN0tzQk16ZDMrTmtrbkM4MldBd3lpbEtSMktFVGhLeFBTNndObWR0cmdNWW5DaVJNVXpMa3J3c3lVb29uZERHVWtsZzRqMkY5N1NvV0JTTEJWVHFwU210dCt2Zkh1VFRiL2pnZlYybytxZmo0ek1mK0FDLy9zMXZhbGFXK3cxRFA4N3ovcmdvTHJZYmpST3RKRU82TFFrKzBJb1NVbU5idGpLUGRSdU56NDN5ZktyMUlyeWtjU3lsZTJlRVdlLzZZY1ZaRG1KRUpGcGFXakFyeXdzWFJzTnhiM211b1o5Ni8ybm1PODJhUk5vSzFpcHhCSEZzYXRWWUkvaFp2TkZvR0JvdFE3TXBKQ2trVFVnVDRXalNaQzczcUZxUWhPbG9SQ1RRamkyTDdTYkx2VFlMOHlrTEN6RGZDM1JqSWV4VmJMNjh6YzF2YnJKK3BjL2Via0ZVQlhwRzZScWhxY3JsM1l5TmNWbVB2aWVXT0kxWm5lOFNSekZiZzVLdDBRUWZBbzAwd1VZV3NWS1B1emhEV2ZQV3NXZ2JkS3dsb0V6dzdJV1NRc0hWays4RTlHSmZ5NzkreTAyK3ltek82dmR5SUxHMTlGcXQvV0tmTXlMdXp1NXUvN1ViTjc2YXBra1JSUkd4alZpYm4yT3UwMUlRV2xIeW5yWE8zR3dRclM3M1RvcGNYcjV4aFo5NC84Y09BUEtIYVhtZTc0ZmNSbFZ0cDlXTTFmbWpPenQ3RW9MbjQ4L044YVBmOHpDOWRsb255MWFKSW9PMXBnN1NVY0pzMWRVcFZGb0RKcTg4YjcwMVpQdm1oUFpnUkxHM1E2dmRRTVJTWnBPN0RZVm1HdEZycGZSYURicXRCdDEyVExjRHZXNmcwNmwzVFhUZ3lYY2RrNzRqTFR4TFJqaWFKR1NGOHRMV2hFa1pVQ09ZWmt4dnZzM2hwUTZWZzh2clUrNE1Nand3OFJWWkNCVGVVSGl3WWtqRUlBRjZKTFF3R0FKaktrcDF4QUlXN21UaS9zc05uWDVKMFgyZVg2ZXo1ZC9mOWYwc1MrSW9VcW1ueGJ4QzVVUHdtLzNCNitNczM0dHRKTVpZakxHa1NZSVBnVmFjSEZwc2RZOEJWdXJ4ZHlzaWNtSnBSZDRKOWQ2RFJtRmR3VFdxS2t1TGM5MWlPam5VMzkwVlZXV1NGL3l4VDV5bXJBTC80TGRlcFNnZGNSd1JHWXVOekV5R1FHWUxURFVoY3hTbHJFUWQvc0Z2UHMrZ1ArSHNaOC9RYlZvaUUxR1ZCbDhXaUptRlNpRVFHME1uU1VpTXBZaGlDbHRSbUpJNGNqVWdjME9VeDJTVjUvWmVZSkJORVdNWmx6Q3VJTjJhY240NUpkT0FXRU9ybGJEWVRiaThPZUh0cll3aUtBMGJHSTg4VlNFVVhyQ2lCR2I5Q0lRMnFRb0Z1ZWl0QWRWRmxGNkFuOTNTL0Rlbzl6Nm1NNEFFUVVMYnhJeEQrYnUra3plMnRqQ3o4ZmY5UEdSak9Oakl2YnZkYmJjT2w1WFhhVFdWdk16RnE5ZEcxRmhlYXJVZnNzWjhMYWpHb3ZYWWlRK0J2ZWtmdml6MHU3cUtaWXlweDB0bTBtbEgxbFpPSkVaLy9NYjFHNHZPVzA0Y2FzcGo1N3BjT0h1Y1JteTRkSDJQeWl0cEhOT2ViN040YXA2MEZSRkhnbzJFNWJrdUR6V1dtUjluck1RRk45ZExIanErd09KY2srN1NCWFozSEZmZWZBV29XUXZWMXdIOVBtQWlZNGlNd1ZwTFpBMlJwUWFKaFZnaU5GaW1wYkJad01UVm9kMnc4SlJGU1RzSzJEaGluR1VZYXRyU2Z1RVo1QlZGb1lUSzRHZmNWb2pPV3A4eWk1Y0Vpd0hEYXlQOC8zdWk3dGNHVk0vN21oaDd5bDFGS0h3a2hvYXhtdXMvS1psMjhkYXRPa3UvVzh5cVo5dEs1K3dUcDA2ZG4ydTFINTlrbWRUYTdVcndpZ2FNTVdiNzh0N1c3NVRPMVJTcUltNVM1Q0VLd3Zaa2RBQ1FQMlNBUkNHRUZFZ25rL0d4OWMydHorSkMxMVVpNTQ0dDhkQ3BKdTEyaXd0bmozRGkrQ0xqMFlqUnFNQmJTKy9FSEduVGtNVEM4VTZQeHp2THlPNkFJc3RZN2dqenZTYk5WcGRITGx5Z05YZWVyM3psRzJ6ZXVsRVRJN2hBNVFKZW9YUjFuMFVBSDVUU0s3bFR5bERuRFJoRkxKaklFQmtoUmhqNzJudFpBbG5sQ0pXallXc0d4Tkw1ZXJoUmhkTERkRVl3blZoYi8rd2c5UTY2Z0lxb2loSWI2d1Q1NGtUZHJ6dDBuWHIzWThLc2d6N3JiZWhpMUdUT3B2VDk3NjVwL2tNZi9DQ1Zjd3ltVThOc3JpMHJTL3VlRXlmUExMUzc3OCtMMG5nZnNEYkdPNCtydkxGV3d2cGsrUGxCUGgweUc2Y0hRanROdFo5TkQwS3NkMEtZQlpqZ2ZjZ0tpbnhhY1hTK3daSEZJMVJaQzlmSk1FYjRybys4aC9jL2U0YXZmdTF0WHI4eG9MbllZMzZ0dzYzck83aHNpbEdMVjArcjFhS1llaTZjbVdkcDlRSkhUNTNnQzgrL3hVLy9vNitRaG5KRzZ3bXFBYWRLWG9hNklUbGpjL2Nxak1wNnlEQzJGb0pCTldCalVDczBvOEN5RWJZS1VCV0NDbHRUeGZzcGk3MW9Wb3BXbHBwQ0xKYTkwalAybnFEUU1yWmUzWjNkOVpGWU1XS3lLdWcvR2dYMzB3N2RuUUhqcnVjQVFpSldXeEpwTFgvNFR5OHdLYkF5UDgvVnpjMkFpS01PczZvckd4dXZIRjFZdXA0bXlSbnZBbGsrSlJBa3FDZVI2TmlKaGFVTDEvZTJyODZXMVF5STdFMG4venVxeWdjQStYMHpWWlg3T3VuR1dNRWE4VlBuYUhkVGpxNHMwa2pXaUtSUDVmb005NGJNTDh6elBaOTRoazhFSWRlSXBOWGs1OS84SXErOGVvWDNmczk1SklBdlBWRmppYU9ubm1WNTZTUmljcHE5RlI0K2V3ZzMzQ0UxRVZZOVZRaGtwYWVvRktOMURiWFZqRWhzSGZxNG9KU1ZaNUpWT09jSUlWQldqc29wOHlVd2hNM000RkJFbFZFZVFRZzAwOXJqcUVMRENGMnhETlVUUlFsTDNUbXlmSUp6bFRxVjdjeTcxMEZlR1FUM2k1UGdMbk52Mzd5Z3JrUnBOQVBIbkVtNFZ2MXZLMEpkV2Qrb1IzaThEek9BdVc5Y2Z2dkswNmZQdkQyWHRzNVlVeXZvaWpHNDROVUcwMXB1ZFI4eElyOFphcTlqVlZVRytmUVAvWXdjZUpCN28rNGlJaGdyR0dNNGQzeVZ3NGZYV0R0K2xqaktHVTh2a2VWOWRqY2RjWnpXQlVBVmNrbDU4dWdDYm04SDV5TU1scWkxeW9sSFBzcGNid25pR0dNOGo3Ly9ISis1Y1l0WHZ2ZzUxRnVLdkFhSWJ3VENURjVBUThCWW9heHFIY0pveGoxa1kwc3VTdVVna2dobkRaR3RPR1U4cGNKZWJqQW9qa0JXR3J5enM2NTRYV1dMalhDODFXVzUyNlBYYkpKVkhkSUVxWkRxU24vNHVXdmJHLzg0cU83T1FKSHRneU8yVWJER2FGY1NDbGNSL25jSTN2ejlMMytaRDV3L1QrVXEzWnRNN2dKa1p6UWFEcWZUcTkyazZYMXdCbFJpYTBpVG1PQTFXbXAyenJUU3REZk82N21zV1lYMUQxMGIrbDFiNXYzc1p6KzduNFBzZzBTVHlDNWxXYlcwdGpESGQ3enZ2Unc5ZFlidXdqeWRoWk1zSC9vb2kwdG5pS09DS2g5VDVsT2N5L0Z1eW53bjVvbUhWakMyeTl6S1k1eCs2bnVaV3pxQzZjNUJNK1hTOWR2Y3VIcUR5RVkxVy9yZFlLUnVvcWl2cVg2QzFoSUQrM3NuQmlHeXBsYWFpbXFscVVZUzA0aGpta25LWEN2bDFIeEVLelk0b01EajhQZ2d0VkNQTi9oZ0tJUFNhYlRvTk9wTnhtWmthRGZhZW1odWVmWHhrK2ZlMjJ5MkFuZUZiV29HMGpST3dzbkR4M2pta1Njb2dtTVlDbTY0LzMwSmM2L1paSlRsaU1qK0dxNzNJZVFiZy83YlJWa01uZmRTVmhWQkExcFhDa3lNbkQvY25UL0N2YVcxdStQMUJ3RDVRN0JPcHlOUkZPMkRBMk5Femh3L2VwcGdHOTRITlRhaDFXN2lxeW5xSjhSSmkrN2NFeXd1UGN2YzNHSGlXUzlFZlVVa1NxdTF6T0xScHpqMXhNZnBMaC9DdEpzTUpuMyszcy85QS83YWYvalRQUC8xcTdXd1R1RnIvUTJCb0hwWFl1QmJhczZtM2p1UjJaOTNRUkxiR2lneldiWTBpampValRtN0VHT053V0hJVVNyY0RJS3pUZGlnckEvNjVHV3RyZU5EdVIreVJRM0M4VVlVTldjQVVVR0NHS1B6Yy9Pc3JSM1NzcW9ZdXZ5ZjZiMHRxb3BIamgvWHlCaWRNWjQ0d0YzYjNycGNWTlZldlhoWXYrdzRpakRHWUl6dG5WaFlQczU5WXlmdkJKQWNoRmoxSnlCR2pEejY4SVdrR0paeWMzMmRpMjlmWVR5NHdNcmhOWXpKMFdvTFpaNUc5eUhtVmg1bE1yakZkTnhIUTRscHpuRzRlNFM1MWVQWUpBRS80YzBYWCtHLys5dS93aXV2YmJPOGNJeDJzd09qV200Z1NDMVVZL2V4TVp2V3JVZnE2d1Qrcm1zellJSVFHMU1UTXdSbWV4czFlSXdYanM0SnU3bHlaNmhVZUNvOFVUMDVWcSs2WXNpS2dwM0ptQ056VFlJcXpnZnhkYk56WmJrN3Q3d3pITHpOYkFCTFJEQmlWRlY1L3ZVWC81bmZ6OTF5ZzA2NlNpdE53M0E2OWZ0TFZHL2N1blhuQTJmT1gwL0VuQTRvSWFnRWxNbzdqSk81amszT1VSUDI3WVBrRDkyRHZHc0I4aTBDa2xJZkpERjJjUHp3aXQvZDJXSnZkNWZSZU1MaHRFdWNkQ2lIbHlGcUVyVVdzV21MbG9sSTJ5djRja2pjV3laZU9Jb1ltR1lEZnZubi9qYi80ODkrbVJDV09YMzBIQkdDK296WWxzVFc0b0tpKyt2bHMwRklrYnBwSjZwNEZMUGZvMURCeUQ1aUJEVVFZZTZTUGU5N21LTTlaWE5jb1VHbzhGaUVaQjhtSWlRYXNUc2FzOUMwTkpNWUh3TE9lOUlvV1Q2NXVQU2VOMjlkLy9vc09UYXFLdXZiRytKYzhjOVVRWnJ2TlBCQithR1BuK0huZi8wbVdWa1Nha3BTRDRSeGxnMjJSc05MeTYzdWg0cXFpbnpsUklOU0JZK1dtaVFtT3ROdHR1WkcyWFQ4YlI1RUR3RHlCMndYTDE3VXNpeVpjVEdwS2xwVlZkWnFKYW9LTy8waFdWYWh4RVROTHE3Y1JsMkdUVktJRTR3R01JcU5ESUpCZmM2Vk45L2tiL3owMytjWGZ1MGJQSFR5U1k0ZU9reW9ISzZzY0VWR0hJRzFCbGVQL2QydER0UktodnYzL2QyS3dkMVdYdEI2Z0JBRkl6VzdZaTN1WEt0U2dXRytwU3drTVh1RlVtbW9XUmVCaHNSWUk2Z2FNbGV4TVo1eWNuRzV6b0I5UmRCbU96WDI0WGFyM1oxTUo3V3dUYTJzNWRNMEJXQjVybWFwTjhiVUozYS9UQzIxVUtjUncyQmEwUi9uTE0wMStlOS8rUTBxRjZUeS9tNStKeUlocUJiWHRqZHZ6aDF0VkVWVlJhNnNTOTR1QlBLeUltNGtaNC8zbGs2OGxrMDN1YmVuTG4rWUlIblhBdVQ1NTUvSEdMTlBWNk9xcXJ1RDBYQXhiUVFCR1djRmVSbW9Wd2dGc1MzRWplcXZUWVJObTVoR0UvQlUyWWhmL3djL3ozLzZYLzFkWG54cmwwKzgveE1jWFRsTTVXWXk1YUpNeGxPS1huM3pHd1BCMzNVS3M0OWY3eDZEZlFLMS9STmg3djd2L2I3M3JOb21TbVJxcWJST0F3NTFHM2hWZGd2RjRyRUV2QVppWTdIQllJS3dQY2xZYUJVc3RDekJ1NW5jZEhKMHNkMWVuRXduMjBBVVZJMFJNWHZEb1FjNHZOUmt1NTlqcmNGSUxjKzJOdDlpWERuMkJsT3N0WXl5Q2tDR2s1SzlVUzZxU04zUG1JMnh6N1FlYiszdXZIbHNibUZieTNCeW1rMDF1Q0RlQ3diTFhKS2M2VVNOWjBWNFdaV1VlOUxXZWwrYjVRQWdmOURSMWd3Z1lhOC9ISnc4ZXpxTDQ2UUxVSG5CUkVsOXU5czJJaFZpa3pva0N3cEp5c2I2VGY3Ny8rR24rWmxmK0J4aVYvblFlOS9EMHZ3U3psZkkzVVVyUTVZVjlBN0hOQk5MVmJxNzRaR2cyRnErOW01M20xbjRaK3BPOTdma0pOeTl3YldlNTVxeE9iYlRpUG1XSXlzU2hsVkpDQkFJT0FJaDFBTk9FWmJNbGV4TUpuUWFEU1FFWEpWajR2am9vZDdjaVJ0Ym0xZG1GYVFvcVBySmRLb0FyMXdaWUw1dGRQRGE1dVJ1Z1lNWjZZUUlVam0vdjE5elYwSkNoQVpJRTJpdDkvdUR0KytzMzBqVW5oQVU5ZENNVTFCbG5FM2pkaHdkU2FPa2wxZmwvVkxXc2grbS9VR0Q1ZDIrY25zLzRSa21NdG5jZkcrUUpQRUtxcWlHL1VBZnNTMndFOVNYa0tTRUpPTEx2L05WL3ZyLzY3L2xHeTllNGRGelQzSHV4S21hdHRNSGNJNnFMRERXRUx6SFZ4bU5ocUh1NEZVMU9JSmlSQWcxcC96TWU5dzdFWGZqcXRscEMvZlFmTGNVckZKVG5rWW9TU1FzTmhJR1pjeE9ydmk3WlY5UGJHcEZxbGd0L2VtVTVXNlBKTEpVcnFLZE5sZm4yOTFIalpHdmhxREZ2WW9XZnY4WENmY2l3dnY3UjdQRWFEK3Z1eHNTMmRuWmlwZ3BkQmxEQTBncTcyVlNGRmZicmZZSEloTlpvd2FEZ2FBcUdxUVZ4WTh1TmR1SGIxVmxQbnZKTXZzKyt6TFgrMERoRHdJb0J4N2tIa0FDTUYwN3RESk1rNVNzcVBBQnFqSW5UZ3l1eW5BK0lsUTV3LzVGZnZtTGIvT2YvT2MvVFgrdjRrTlBmWVRWNVZWUVJiMUhnbEpYYVNxcW9zQjVqN0NBQm92SWZvSmRZOVBJdmVwVkxSYzlDN0gwVzAvaXZzYXo2TGRtSzNldmF5TlVxc1N4NFVpN3hiQ3FjRjRRQXBVR0lpeFdoRVF0RTFkeVo5aW5tNjZnZUsyS0ltcEU5ckdWK2NYbGpkMGROL3V4c1lLL0c5WHhMUUNSYjJ1eTN2LzF2akt3TVVZYWE2dmQrYlcxemhOcFpNOTRyNDJpOGhNM1VsYzQ3OHJnbzJhY0VrV0dFRHlWODhRMk9ucG9jZm0wYWJXSGUvMWhOTTZIKzFJVXhRd2t4VDhGS0FjQStmMm9aSW1JcW1vUUVkM2U3US9IK2ZUT3dueEhOKzdja3MzZElXVlIwR3cyQ000aFNRL3ZjdjdIdi8wTC9QVy84UVVXdWtmNCtQdWVvdHZ0NGJVZUY1bVJuNkFhQ0w3dWpxc0NZakVtcXBOenVVc1ljYSthcG5YcDl4NXE5d0VnNkt3c2JKZ05MOHE5TUV0MFJrdG9oRjR6WnFkd2RKT1loU1JtTXdzWTZ0SnZnd2dqOWNSd0dpeUQ2WlJCbHJIWXNWSjVUNXdrWjN1TjV0RU43aXJrSnR6clpIODdRTGl2REtzek1NUlNFN0lZYTBpT0hKNC92ckxTZVYrM2t6emQ2YVR2alVSNnJxeHdxcVZmWkxwN3BiQ2hValRVajBIRUlDVFF1M0RzeEo5OHVCTi94MlF5M2R2Ym03ejQ1ZGRmL3EzU2wzdjNWYmJ1Yjh6OHZ2TDV2dXRETEsxUGFCQ1JzTEcxazc5MTZmcVZSaHByMEVyV04rN2dxbnFuR3hWRUl2TEprRmV1VmxRKzViM3ZlWlp1cTRQM3ZzNFhRazFCNmtNdFc2QW9TYXVEOVZBNnhjYnhmUUM1THdublhtSmVOOUR1ZVlkdi8zcC9XenpjUFptemZvckNYTU93TTJzMEhtbzFHWllWaFZkS0FsWHdwTVppamRBZ3B2QTU2Nk1oYzgwR1lwekczaDZlYnphZmpxemRpeU01SEJ1eElrUnBZcElra2phSWphTklrc2pNUjVHWlI1SEpOQWNqcHQxSWtqU04ydFpJRkVWV3BaRTBHODM0a2VEOW1lQmNPaDZoWlZFZ2FtV2hmYVRSakpQR0ZsY3BmVlcvbGxDUVdvdkJZSVhFbGFPbnU4M3UwMGRXanRGOHFMUDl2aWVmZUxnL21YejlTeTk5OCtYWExyOTE4LzdjY2YreDF1SzlQd0RJditCdU9xUFI2QzVWVFZHVUljL0xiY1U2NTBOYTVFV3R6MUhFOVp4VThDU3RIbXVIMWdDbGNxN213TkpBVUsxREt4K295b0lRSEpHeE9PZEowb2lGMVNWTU04SEc1dDZRMFgxVkt5TjEvK08rSFAxZThsdkhWdmRpbVhyRDY3N29aei80bjBVNHN5V3MxV2JLOWZFRWgxQ294NFo2ZDk2SWtJcGxsR1gwczRLbHFFRndWYU5qdy9kZE9OWjV3bGQ2cFBKVkZNZHFJMnRzV1dtY3hJbHBOU09NU0VORUd1TnhxV2xzYUxjVG0wUldyTFVtc2hHa0tZMTJKS0dzQ001amswaURCcnJOSlRrOGQ1YjU1aHJCSzlIcExwZmVmb1BwZUV3TWtDUWtKbUpjZVB3Z1lmWGtZeHhlT2tXbjFWeTJSdjZNcTZvZlBMMTY4a3MvL1J1LytKKzgrdmJGYS9lRnhXRTJjS29ISHVSZnNGVlZkYmNQQWhyS3FncnRUbk1jK1NYLyt1dEtmNVF4R1U5cHRTMUptZ0NCeUNiTWQ5dE1wbE0yMXU4UXJ3WFFRS3ZWd1RsSGtVOEp6aEZaWVg2eHphbnp4L2pZeDUvaHhKbmo3RjMrSm5FYzFhTWt0ZCs2RzVQSnJESW0zMWFwTW5JUE1IV3hTd2o3ZmtYdXhUd3EwRWlFZHNOUTVnWXh5bkt6eVU1ZU1IR2Vra0NpQWFzV1l5QWxRcjFqc3orazIyaEpaQ05hU1hMT0ZqeVV1VXFzcmF0a1ZSWElNNGh0bVBVODZvcENVVllraVpudHNBU01NVElvREwzNVEvaXdCMVZPTTAyUU9KTFYrYk1jVzdoQWF2Ly83UDEzc0czNWRkOEhmdGJ2dDlNSk43L1UvYnBmWjNSRVRnUUprQUNZUUpFV0xkR2laSklqaXhJbGEyVEpaYms4ZHRrekdsbmpxWkZkMXRoVE5WVXp0c3BSOGxpMktWdVdocUlvMHFSSWlpUUlFQ1JBaEFZNmQ3L3VGMjg4YWFkZldQUEhiNS83Ym9NZ0pWRUFKQTdlN2pyVjczVy9jTzg1ZSszZld1dWJ4amp2UUpYZHJhZTQvNTc3K05Kem4rZnExWmRwdWc0bkFlOGNXL2RlUVV6R3F6ZGZaV08wd1lYdEMzbVZGeGNueGZqYnYvbXBkMzM4Q3k4OWYzc29EcmRlQXc4TGw3c0Y4bFZ1c1JoYUxJMVJRK3g5NkgwODNOemFhdk9pR04vWTMrZmsrSmlkN1pJOHo0Z3hFcjNqNHU0MlBrVDZyc1czSzNRUU1LMldSK3h1alhqbWJmZno5Rk5YZVB6cGg3bHc1UXE1Z2pHUmV1TTh0cGdRNDRLMVkvemdRWFZLSFZsN2NOMEIrdVhPRUsrS3lwMFd5OGlkUGFzQW1UVVVXY1JiMEpnSWp1ZEhJK3BsamRkSUlDYnpDQkorTXRJYzEzdm1UVU5WbEdTU21kQWI3VjJrVUtIWFNOZEQxR1NlNTBNcVdHc3lxU29MQWo0R2pGcFdiVSt4dThkMGU0cHJGbGhUVVZTV0M5TUhlZnllOTVEbjVaRHhYcDYyaW52YjI5eHo3Z0svWEdSODRYT2ZaK2thcHJ0N01BMjhjUE5YS0hJbGs0eWJ4NWZsMFF0djAwckt6UXRiNTcvdExRODgvQ3ZQdi9ieUc1eHhuZjlhdEZmZjhBVXlIbzlwbXVaTm02eVQrZUlrbjJ3Y1pkYnVycFp6bGllSGVIK2U2Q09FRnErUmpWSEZ1S3J3d2JHcVd5Wmp5OFh0alB2ZmNTL2Y5UDYzOGZTamp6Q2Fqb2tLVXA5QWpQUlJzY1VHeFhnYmpkZlR2Q2xuVzZaa0xSUWlkNFoyV2ROTjFpZEdPbmxpbXZuUElBSjZDaWdtWGtja016bkdHUFpHSTQ2NndLSnZjUVJLTW93bU0yQXJRbFRsY0xGZ2N6eG1MQm01NUJJY2RFRlBOZmRHSUlUQmd0VUlhZ0tTakYxd1RsR05PR000dnpmR01nTVRrOU5LTWViZWMyK2hMQXJLb2tERUVtUEFPNCtxY2p3NzRJMzlMNUp2enRpK1dITDdvR2ZqWWdINUlWVWVLTE9NRUJ5M1p5L1MxYTA4ZnU2ZGJJODN2dVVEVDczcnZjKy85dkx0TldaekJrelV1d1h5VmJ5K3ZEaUE2R05ZWmxsK1VPVGxvN1BGUXB2NXNmUnRTMWtXTktzRmJaYXpXY0xXeUxKUkdkNzd6QTd2ZitjNUhubm9mczVmZnBROEx3ak8wYzFteE9pNWZUemo0NTkrZ1YvNzdNdDg3Q052VDU2N09nelg2N2xja3QrV0dkREJHUFhPS25qZFM2MW5EcmxEY0Z5UHFtYmdraGtSTmtjWjg5cVRtK1Q3TmNvejdwbU1xTDJuaTQ1TVBWVmNjN1NVREdIVk5NeWFobEcreVVaZWNDdGE2ajZrekVTRW9vQVFVbXVYNTJtRkxZT3V2cTQ5VlpWVGJJd3BSNTdNQk1wSmp1dDd5bXlLWVVRVWc4MHNWVmtTWTZScE9sNjk5anpYano1SDYwL0ljdVgraDhac25MTlVtMHBWS2tZeVFvajBuYWR0T2xyL0t1ZktlN2t5Zm5qNy9PYnV1eTdzbnZzSHQ0OE9tbUdqSlcvYUNONHRrSy9PRlVJNE00T2tBcmwxY0xCODRvRXIrM3Q3dTl5KytUclhidDdnMGVVampLZGpGTU5xdVdKemxQR3YvY3Zmemx2ZjhnaHZmZnd5cFcyd1dZbXZXNXcvcHV0N1hyOTV6RTkvL1BQODRpZGU0TmxYM3NCa2h2YytmWUhOekNVYSszQWkyRFhQeWtBY1poQWo2d1gvZ0hlc1d6QVNSWDdOL2swdWJwSUtiYmczTml2TDVpalNPOEZnVUNQc1RYTG1MdWZHTW1CSkNIOU9qdFdCV3EvSzdmbU03ZkdZS3N1d1JtaGNaSkpsUkIyaURtTmFtV1daSWNzc1BrWk1jdkptUENtUWFVRVV4UTJGaytjWlZURkNSR2k2OW5SMVBhNHFiaDYreEJ2SG44TG1qa0l6dlBQa21XVm5zOElOTTVmckhhN3poTjRQSm4yTy9lVjFQYjk1ait4T3Q5LzMrSlZITHQ0K09qZ1JFWnZnb2EvTnB2Y3VVUGptZlhwNC9kcU5KdnNtYm84bkUxMDBYbDU0WTU5dnFtdFdpd1hHWmpqWFVGcjQvZzkvRTlaYXZCTUlHZHIxM0RoNGlTKzhmSjIvL3l0ZjREZS8rQWI0bkdYYk1LbW1QSEw1QWM3djNnUHhhT0NRbkJKeU1VUCtpRFdHRURXSkZkZkZNZ3psQ2RrL1E3eFlEKytxQkpFaElSZUtnUzhWaDNXeUVVc215cVZKeFVuYjAvdEFUa3ptMkdLU21RT1drM3JKL25MT1BSc2xtWlhrckJpSDlKd0kwVnRzbnRxK29pZ3dQaEExQlpodVRDcmF6Q1pVMzBBYkZBczRkUlM1QllXMmEvSE84Znlyei9IYzFWOWlNbFl5V3lBU2hwa3JZbFF4UHJKcSt0VFM2aDBhamxmbGVIVmJsdTJjQzVPTEYvWTJ0aThEenczZDZkZU1GdjhOWHlBaGhEZTFXTWNuaS81b3RuZ3hpcG1EM2JwMjY1Q2pvME95VVVtV2w3aXVJN2lXNEhwR280S21kcno4K2cxKzdsUFA4YXVmdjhyUmNTQ3E1Y0xPZWJaR0kxclhjMjVybXp3cnFHUEZoWE1YeWJObmlSaHNTTnFRREhCUjhYRjlPcVM0Z3pEUTR1VU9sampRNU5QSkVZY2V6ZHhocWxDS1VKV0d4Z0hScEZOS01qYXJpc3ZUd0d2ekdTNHFCVW8rbkdLWldLcVFjWHMyNC96NEFwdlZpRGZtUGFzUTBxcW9ONFRnS2JKMHN4cnJRSlFRb0NqU3FTS2taRjh4eVMrc0MzRFN6dWw4d3pqZndIdUhpOHF0NHplWTFVc0NKZFptNmU0ZWxnMHhHZFlSTzVlS2ZpaDBIOUkzVjNjempsWUhlbjc3NGpRVGM5bWtKOHZYbFBGN2R3WTVBenFKRUx3TC9yVnJ0NjltS2lkbFVXN05WaXNPRGcvWTN0bUdLdUpkVDNBTjg4VXhuM254R3IvOCtWZjU0c3UzNmJ1Y3ZhMDkzbkxmT2NhalVhS3d1NGJOY1ltSXhmYzliOXhjVVYzYW9nL0swblhVZmFDdUhYVVhhRjNFQlQzRlZKSnYxRnBoYUxnRHVDdXJFQ210cGJKbVVIdWxWWmhxeWpHYzE0NVZxL1JlMHJCamtoZUpGUmpaakRaNkhDSGRuR0V3dmtOWmRBMnZuOHlvQm5POE52amhJUkp4SVZJNVM1WUpOdXVTZ1hkVWpNMVMrSTVQSjRISkxVYVZ6T1o0NTVqMXg0enM1TlRGcFc1YldvMWtJYkpzSFJPYlRqR2JDU1lZVklSUlpsbjVnSXFraHdaZ3hCRFVjV3Z4T3ZjMlY5cFYzUzZHTGZoZHFzblhxOFhTMUZHRTgrZDNXbWxDZXpYTE9aclhISjNNYVpZbm9CVmlNdks4NUJjKzhSei83Ny8xODBSWDh2ajlqN0ozN3hhanNnSkp2cmRvaE9nSjJ1QmNpeldCWC9xNS80V2ZibHNPYnQxT0dnZ1g4UzdpdkE1M09jVEJMMHNIUlpYQkVIVmc3NG9oeitESVIwUU1PNFBKZEZFT0srS1krbnpmRDM1YlFla0lkRVNNQ0RtR09EQUtPenc5bm5DNiswbG1jcStmbkpBWkN6SDlPajFEZmdsRVlsQzhTNHVCM2lteEQ2enFqdHBGK3V1cHRTb0tnd2xLMTNXNGcwK2o5MXBpakhSOXkzSzJ3cmVCRlIzV0NNVzRZSlFaOE1tWk1pcU14eVhhT1ZZdUpJTzltTjZQRUNLcjVvalB2ZnFGVHp6NzJvdWYwNVNRRzcrVytlcDNDK1RPQ1hMSGtieXA1L2R1N3AwVVZjVnllY1MxMndjOGN1VWVpbXBNcGkyMkdGRVdVenFuUExoM2puUGIyeGhyaWRFamVDUzJlRmZqK3hvalBYM2ZEWTdwa2VWcWlZcmlRaVQ0aUtwZ3JhUzFhVHJIeUhUNGlSR2lCNGxyRXdmSWpMQ1pDNDBxaFUzR2NNRXJSVFg4Z2lpb0hWYXpDaExXT0doU0dBSzRkS3NQcHhPNGtETGZ6ZERDK1JDR3dDQkRPT08rR0ZYcGV5WHZVK2Z2UFloUmZBaEVGOWgvYlIvYnQ5Z3NEZjR4S0lkeWk5ZWVlNG1tRnphM2NpNWVtSEJ4YjBMckFxMExOQzRtTXp4clVpdXBFY0V3cVFwY2FQRURjOW01Q0RwbWQvcFE4R3FmdTNseXErRzM4c08rNnBlOVd4dW5mSTAxQzdWNi9kb3Rubmpvb2FlTzlvK2VhZHFsN0V3TEhydi9NcFBwRGxVSlpWRWl0dVJYdi9BaXZnL3Nqbk55MDVQNVkwSjdnTytQY2QwSzd6MGlockxNS1hOTGtRdERWelRjZHBIY1FwNURrUmx5bTlxcFBEY1lzLzYxUXA0Wml0eVFpVENxWUhPc2pITmhPaGJLY21BV1pzcTRVb3hWaWd6S25DRzF5aUl4YmJUTVlERzYvbmRtREZWbUlBamp3cEtwbkhMQjF2SVBQM0NITXhSTCtuT3NUWUl0R1lhZnlhakE5NHJ6anEzTmtzbDR4R1JhVVZVRmdzRjdoL2VPNlViSjdzNkV6QmlLektaVFFSVnJERVZta3FIZElDaHp6ak5iMUN4cngzemU0S2w0KytQZm9rOWZmc2J1YkcyNk53NXZmdnh3ZGp3SDJpSFV4OStkUWI0K0o0azJkZXZQWDlvOXpyOVVlZWMxdjdZLzQyUSs1OXo1bmhpRi9jTTV6V0xPVXhjM09EbGVNcmFIMEtkWU5vQzhnR3FjazJlV0dKV2lFTXJjNG1ONkpnY2ZrcHBJREVxa0xES3NGWHhROGt3SDRrdWFRV0loR0FiUUxzSmtKRlJsTVlCNDZWWWVGWEZva1ZMQjZlQ1dVcFlKZkxUTGpPNU0zTVlhMzFCVkNGQ2FaRmJuZ3A2S3JBYVZSckpWUEQxRklwRUlhdS9RWUtJU1k5TEFSMi9aMk41a2UxcFJGZW5XOGk2d2FqcU9EOVBKR1VLa3pDeFpiaEFqOUQ3UXVVQnVoWTBxeDFqbDhMRGorVmNPT1p3M2lMVnM3WXc1ZjNHRW1KVVlqWHB1WS9mcHgrOS81S25uWDMvbHFrQTJlQUdiKysrL1g2OWV2YXAzQytUcmNCM1BadGV6TEZzNHorNXMyWERqMWszRVpGeTd1YzlMcjkxa3ZtanhYYy9lSkVQd1lJUXNOMHdydys1bUFUWURZM0N1Snc1UFNlTU1aWjZsSHd2a0ZqS2JreGZaUURzSldJa0plSkJrMENDNUpwYXFEdmhDWmpFMllSVWhwSUhlRm9LMUZ1YzkzbnQwRUZyNWRYR1drcUxQQXFlSWZGaXZqUU9VUlhvMFNEUVVDSjVJSUdVaUZnak5VQ1FSeGNkSTd5dzJTemkyRHUxUFdSUnBvQzl5ekxna001Sk9KNFd5eU5pY1ZJU1lJTWE0QmppSFlxMmJudG04d1FMZU9WNjdQbWZWQm5iM0pqeDRaWmU5N1JIZHF1WG8rRFp1NHdtSzNtOWNPWC92TStPcSt0OVdUV05GMGxtV1lxenZuaUJmcXhicnJPQ0hULzdHNTE5L2VPLzg0dDZkMGU3VzJQSzU1Njd6MlMrOXdXelo0cDFpTWt1ZTJkUDJTQlZzTG14T2MvTGNnc2tRbXcrTlNub0dhN2lEVTJUR2tobWJmdTJBbEJNRk5RWmpoUmdpY1JoTzE2d1VJNGF5S01pTERJMFJFU0VPbnJ1REtBTmo3SjNmcDhsZHNTZ3NHcUhySU1hQnR5V0pZMlZNQ3Uvc1FvcERLSXhsckRrTDlTaFFZV2dITjE0ZGFDeWRpeGhqc0RITk1GM3ZHWlVGVmcxZWhUQXFzRVRHUTl1MHM1VXozU2pvblRKZjlDeFdQYTRQV0NPVW1XV3lVU1JTcEF0MG5lR2hSL1lZandyTzdXMVFaSmJsU2MzaXBDWTNsbFczSkRmV1hONjk4UFR1eHZiR3FtbG02emxraU5TN1d5QmY0MExoM3MzUnZlZFpmYmp5c3YzUWhZcmVSWUozRkpsbFdsV0VJZ0Y3azNIT1pKVG1BK2VVM0FwRkpzUVlrWmlZd3FOcUJOSGpmWWN0UzBLRUtyY1l6UWxSMSs2Q2FTNndpV0FsdzlQVkQ0NG1HWWtCakthYllJMTVuTEpOaGpiSERORUpxZDZTRmg1MStCaFB5WkNuaXE3MU55ekpVVDRHVWdzME1DaURSZ3dwRnlKUForVHBHeFExNE53Z2FyRkMzeWVpWUpWRHYrelpMUXc3MWpJZVc2clNrdVdDeVF4Kzd0QUlHK01DSm1tcGtPY0dZdzNXbUZNTDFoQVZIeUxFU0wzc1dNNGFnZ3NFbVhNNHZ5RWI1WlNpeUI2ODc4STl1Ni9mdnZINkdYL2x1d1h5TmJ3RzVhckpMbzd6ajFYUi9mQnFkbHhVUmM3Mk9NZVM1Z2l0aE02bEo5VjBXbElWR1dLVW1NV1VNS3RwWDJ5c1FhS0hJTmdzeDVxRVRJc0dkSFBNdk9sWk5UMXRIMCtkRnZQTXBKYkZlM3lJaURISVd1Z3RoaEFEM250Nms5emVqY2lRODY0WUVuSnVCMkRFRENCaWpKRWlSdnBjY0M3cFNCS2VJcWZvb2thU1huMk5Pd2hVV016UWJwVkRnY2laZnpRcUdwS2V2dThpZmU4WmpTenpveHJmZWtKbDZiMUpPZk5pS0hMSThqVHdPNThlTUZIQmRXR2czZ3hTNG1IN2xwS2dsYjczTkUxSGpJcUs1OWJKNjF6WXVJK3hHYWtWZStvbmtIQXN1VnNnWCtzVFJGVjFjQjNNcGxYSnBNb1pGd2tNSzNLTFJzV0tSWXd3eWpPcXZFcGFjb25ES2pUNStaZ3NIOFJPQVNNUml5RWFEOVl3SFJmMG1tNlVxQ2tJZE0yNVd0OG9VV1BhUG9tY1VSa09uZGhBN1U0aEFZSWR3TUFRSTBpaXZROEJwWlNEZWJiWGlITkp0MzQ2aXd6Z3M4UTdFZGNKamtsL3J5cUR1MVk0MWFISThEc2pDZUcyQ1dXa2JqeGJHd1c2N0xoMVZMTnh6MFlTdFd2Q2hieUxHQ09VaFNFMElRbktoMkxNZ0s3em1NeGdNb3NQdzZtcXlVY3NMd3U4YnlIQzRlSmF2SHJ3b282cXZWOTU0ZlZYWGsvWXFRWVJ1VnNnWDU4MWxvWTI2cThYbWIwK3l1eDlvOHkrbVdVN01IRlJKUWFmYmtxVUVQMndvalNZekNERGFXRUZ4RHZDZ0d2WUxLTlFwUmo4ZGtVS0lrcmJlOXF1eC92VUttVW1tY0tkYXRJRk1wc2xuZnRBaFFkU0s2STZMRy9YV2VkeUtxNHl4bUJSOGl5U1dZVXMvWGZuaCsvMkRrN0kyazlpM2NvbmV4TEJJbVJuVGUyR2w0K1JHQTBSV0MwREcxTWxGK1ZnZjhYNTgxT3lMbUNNa0ZrbHVNR2VwTEJvNC9FaEFaTkdCQU5NcWd5VEdlb3U0UHVBV0VGVjBxeFg1dFNyZGpoUk9ubjI2cGV1TnE3NFgyN1BEdWZEb2kySWlINHRvcVB2RnNnWkpIMTQ2YXozMXd0cjN5aXR1WStZZHZVaUJqT1FDSFVnQXZyZ01iNUxRM0dNRkVXSk5SbVpKTWQySHp4cURVWktWQjB5ckhYUnRPS1ZnV3lvTVo0aEV1bnBzTG1PWmd0RFZKdEdIU0lJZEozVlBKdzhNa1MxV1l3eHAyMVQxR1F2R2xXeG9sZ0wzdDN4UkRrOWtRWUJFOE5KNG9lQVVoMFd1d1lsUjNGQUtSWlJHWDVIVEROVUVObzJzcXA3OGtKWW5UUWNMRHVxellyY1JXSTJiT1NzNkhpYVV4U0dvMW5Ib3ZheTlvRDBVY21DSWxZb1JpbDl5dmtFcHZhdXArMzZHRU04Q0tGNmNkVzR2L25hNGZYUERobUlIU2tQVWU4TzZWOWovR05BMHVQdFpYZlErZkNjTWVhOTFocWJJc01HT29kWmt3YlRrenFFZ0laSUprS1cwbk1TL2hvRmphbmxVbnFLb2tBeVM5ZDN5WFF1Ukx3TDlNNmhSdkErREF4ZUliTjIrSUlVNTlNMnkyU1dVek1zZ2VCVG4rUjlBRld5TEdXQ1pIS25SVmtYb0F3NFNnd1FYREsvanNRM0QvcHJXcjJtMGdnRDVxRUR2akxzeVpKdmNIcnFxMEUwRE1aMFhRZXJWV0JuMjZKTnoreTRwaXd6dkFnN21aSFNHaEZGbkE4MHJhZnhnWG5iZC9ONWU2QjltS00yRkRiYnRuQkJOQll4cHUxWTMzcGlyN3BUN1BVbnZ2L3BMMXkvOFRjN0g2NHFzU1pwUWZ5NlFGNTU1Wlc3UU9IWGdXcmlVZXBaNjUrN0QxMVlJOXVHWWZXNlp0c095ajZESUhGd1BaR0J1YVFoa1RTTVNlUTd3TnFDZ0tWdFducm5rQkJ4TWVJMTBvZUlCcVh1ZW9MRzFCNE5kcUl4cHRNbHhJaDZUNTduUkkwNEZ3a0R6Y081MUliWm1MSUtqWVpoNVp4b0xBWkJqTkwzZ25OQ040Q0JrU1RCUGJ2OHNVT2I1dGVHYzl6QkxVSnFoMXhNaVNaWkpvYk1RQmRPT1RJc0Y1RzhpRmdSVHE3TjZOcU9hOVl3S25PZkZmWWdSRjNWcTY1Znpwcmp2blczSXZMQ2N0Vy92SnEzUzJzeXRxcng0eGVyeVkvRnByK2NXMHNtR1dWZXNic3g1ZEprSjcrMEVYYytjLzM2UW9tT00zSmI3dHIrZk4yS0pBeFBKUC9DNGVyVEQrNk9YeXFzZVpkWXdWb2pSaFRudytEQ0xzUVkwaW9WQnFPNEJBakdFQW5SNFlKSHJDRzZqcWJ4TEp1ZWxLK3BMRllkeTdZbkJFL2JSZW8yUGFXTkJURWVWU2hNS3JqZXBYNDhCSWNDczFXSzcwd1MzZVNrQXNsL0szZzlwYWNZdzVBeEFsMGI2VjN5eU9yd3A0NXduRmtER1lSczJGejVsR3N6bkIybkRxTlhGZjM3YVdPbWxVRGhVU3VJVmRHc2MxSDZJMkpocEF1ekpmWndtUmtSRzRYcnJmQUpIL1RFZSsrQzA0YVVaTFhPV010OTlFWGQ5K0crQng0K2pHMTMrZWpvaE1MbWFjbWdpR3EwMDd4NDRQTG16c1lyUi91dm40TDhFTmUrQW5jTDVPdHppamdnM2xpMDEvWlgvYWUzcStKdEZza2twTm5ENkRBMHIwVlBCcXkxOUM0UTZpNVJPQ1JweG1NRXI0RStPSmFkbys3Uy9CRkNvT2xyRnJXajdoVG5GRC9jMkRialZNV1gwSGFERDRiZUJkUWtDc2pTQXhMSTFqVENkUWlQS0ZIU3l0YzZHVENOZExxRkFFNFZKMEpQZG5yYnk1a0NDYVI0S2NFT01zY0JOWlVrMi9JYU56dU5YNFQ0K1NaUUl5VHpyNVFmWVVDbDdaUHArM29yYUJDSmFLOTNETjdDbWRmNnJ5NkE4Y3AxcjkxemNlL1hMMDQzbm56NTZodDVzMnFKUHEycWt5bURqTTl2bjl0NDVXaC92VU5RN2xxUGZ0MEhkUzlDcjBwM1hMdG4yYVVXWmN2MVliangwMXBWQVEySzl4SHZBeTVFZkZnWGhVSm1DS3JVWGFUcmxkN1ZxS2J0VGVzOXE4NVJUWGQ1NE9LRVpyNFlrSExCcTlMSGlFU1RHSzRNR3BGQmhxc3huVUJkU0t2aklydGoraUJtTUtNZlZyQXVKQ0FTbE03RDBRS0ttQ1VqaG1HZHU5YTNuMFk1eVZBVzYydzBVWVNvMXZSeTR0eis5U1ljdTBnRHJORDFEUEFtdmV1cHZndlFnSDU1WWNRdmV3bkpmQ0dxcWw0OVBQemswL2ZkLy9zMnhxT0xCMGN6NWljckZ2TVZpMFhOZkJXbXhsUTczREhIUGdVSUV4NTBkMGovZXB3Z1VkUENKbHlkTlY5NDEzM2JOd3ZZWW1pMVE0eHBpQjVvNGIxTEk2enpTdE1uQjhNUUZMVkplK0c5eDN2SG91Mlk5OHFpaTZ4OEFoSi85THZmd1hlOTYzNWUrUFhQMEM2YjFOL0Y5QVdzVzZjd3FPbWkzS0cveDVnNFdJbXlwVWtTTy93OG1zRkd5QS9DcXhqcGh6L3YxampRMUFPbGhVUXJOc0l3ZE11YlBYOXRvcXRyVkVUU2luZ2M1ZnFSQ3pkZEg1ZkFmR2lSM0QvRzh1UHNLMzdaenhuYUpRUGtuM3pocFdjZm51dzl1MVBZODAzZFNuT3lrc1h4Z3FOWlE1NVZPOW5PNkMyajhmZ1htcnBleDdUSjNSUGs2M3VGNFVQM3gwMS9jRkQzdi9uQTF1Z3hUZjQza3ZiL2laWGFkSUdtOC9RaDBubFA1eHdocHRIWFlPbWljckIwTEYzRXFkRDAwSWJreG01TTVETmZlcFZ2ZStjajNQZndnN3p4eGVmVFFDeXBsZk5CVXdoblNMUEZtbStsUmdrcVE3SGVjV0o4MHgwb2dobDhlNk1xVGxJYlZ1V0JONDQ5c1k4SlB6RjJDTVZSakpxaGFIUVk4Z014Q3E1TDM0MnhVUXNqdTJYV3NlanBodzFTeTUySWd0K3BRRTUvYnM5b1QvQUFBSUFBU1VSQlZJeGdrbkF3NlUwQytCak04T2U0eG5VblY5KzRlYTBOR2xldU41MExva0dKSWFBUzhrTE40enVUcmEybXJ1ZWNTYUdLTVg1TldxMjdlcEQxZ0hxSENDcUFGU0YzUWRrZTVac1hwdFczZXRVc29PS2pjakR2T0Y3MjFMMUxBSi9ycVB1V3pudm12ZWU0Q1Z4YmVHNHNQTXRPeVhPWTVqRE5oSzNTTXM2Z1ZPSDFtOGVJaGZlKzYwbGl0NlJiTEJORnhaeWhkUXhvK2RvSnhhNlhaU0tuY3R6VDBNL2hOTENTQkZQcFpoUXlTYlQzSWhQNklLQXBDc0ZZT3pDTGt3VlFhcmNHRitDb1pOWWdnNzlXT2pYNytyQnAvKzdTeGFOaHlPNEthN3d4RW9hb3RhLzBPcTFkRWRIcE5OZk5UWXNSS0xLY0lwOUk1N29FeFlvVUd0V2MzOXE5Y0xHb3Zwa1lDbU5FckZoNm56TGpKK05wVmt4SG43bDJmT3ZhdXFqNEdycThtN3VsTVF3ZjhkUjZLcWE5ZW9wRXZyM3NudHRmdFM4MjNzdXM3Zlgydk9ibC9ZWjVrMDRMSHlPck5uQ3dVbDQrQ2J4NENOZm40THd3dHJBN2dra0dWZ0tibXprWHoxVThjcytFaCsrcGVHaXY0SVV2dmNSTFYyK3k5OUFqakxjMnNLTGsxcEJaS0F6a0pqRmlqUjFDZGdCclplZ3Rrc3B2aldlY3RrdWlwOVFSSzZuYURlblBLdk1FOHVXMklFdk1yZE5iSVhsMUNkWmtHTW5RYURGaXNUWW55MHJ5dlBUcjZPeTFiZEhtS05mK3ViL3lqLzArTjQxbk5rdWJ1ODU1TmtaVEhXZ2lVVlg3cURGZVg4MCszUmx6ellvaE0wWWpTcEdsaEJUZmR2Y1gzanhtODJ3ZzNIOXQyNnk3TGRhWnF3VDZZZFJZUDUxZVBhNnZuaHRsSHo4M3laL3hNY3FxOHh6WGdkd0lzMFk0cUFPejF0UDZGSzVaV2FneUpiZEs4cmROd3FDeUVEWkdCU2QxNUtHTEl6WW5KUnNiRXpZMzlsREdtTkVtZXc4K3dNR0x6eFBjd0xXeWd4MjFwckFkVmNFUDhsdXJ3NUxnZEpoZTI1WGVvYUdzbXh3OWc1eVBjdUZJaGpsRHdLaEpjNHpvOEx4TWY3Y011STRBeHVia21RSHBuWHlaNWtKRVdQejl6L3pqRFhtYXRuVit2ZVBDVTdkdllJMVp2K2NCOENmMTRxamREbCtjaUR3cUlKbE5hK3ZNR3JxbU0rWE8rTXIyNXZiNDhQQ2d2bHNnWDhmTDNlbGVvaW9lNkZ5SXE2TzYrM3d1NFVoajNEMm9BN2RyMks4am5VOWJKNGhVQ0dOcnlVV1RWTllvZHFCeEl4RnJNb29pNC9pbzRZUDNYZUdENzdqQ3hzNG1rMnFIb3B3Z21VZDM5OWk4ZUk3RmpWdG9TT3ZrMHh0NW5WUG83a1NxcFZOaElET3EzdGw4RGovV3MrWmJlcWRBaWh4OGQ4ZWs3dFFjbTdUaWpXOGl0eXZHV1BJOFJ5VzN3cGViUkN2U0wzL1g3L2tIMy9KdW5ydnhDZ2ZMNHlqZ0ZmeWlhNVlMMTcxNHJoZ1J1d2FyVUZoRmpHanZlaG03K0k0TlcyMGZ3c21aT2VSdWdYeGRacEdCSlQ0ODBYcWdQV2pjWnpMUjUwNXEvY0N0UnJVYWpXUmpOQ1ljSFpFTmlIUW1kcUNhZ3pWS25pV1Nua2hTK08xdGozajBnUjFlT0tpNVZVZmUrcmFucVVaUUZFV3k5N0dXL1hLQ3VnZnA2eFozZUlJVmMrb3NFdUxBQjRORWtSL21wamlZK2VxQXo5d1ppVS81djBPOUpIUStzNEkxYVdsZ1pFMTdUN0xlZGFVSVdWclFucDRpU3A3bEtFVmhFbzllemc1c2xMLzcrWGpacnBLR1pUaTVCZkVoQnJjSTdsV2ZqMllDTzRVMU9CT3BNa1B2ZXMyaVhqbzMzYjN2MVlOcnI0dVNEUUdoWjFQcTdzNGdYeXNRSkVzWWg1N1padlhMUHR4K2JSWis4V1lqdDd3YXNWYTQ3OTZMdXJreFVSa01FTllNMnN5a0V5VExJc1lFaklrVXVmQzJ0NXpqcWNlVCs4a3ZmdTRGUG52akJwY3VYMkl5R3JHeFVWRGtCZnNIYzE0L3JObTQ1MEd5c2t3elFTYkppOHFrdVNPcEVRZGtleGpDMStjRk1kSEwxOVB4K3A0ZktGbERGaUxrRWhOcDhreG5JaXBuV3JPQjl6NUFHS28rRlpHMXArbnRaMXVzNmJtdDMvVjczbnZIN2RtaERuQjRWTlFENGFoclhsMEdkM09nbnVsdzJna0crbFd6VXdTZXlMUGNEdjUzWDdOVDVPNFc2OHZma0VUZmVGTVdYNGhvSC9WbFJWNEdhWnp2ejQzSG84bjVuVDJPWmllRUdGSjhXQ1prRm94TjVndTVOVlJGd2Q3T2xHLy81dnU0LzZGNytMbFBYV2ZSSzhkOXdPYUE5RVNTV2ZPUC85U3Y4N2YrdDkvZ25VOWNZWE5qU3JPWUlhZW8vWUNIUkFiSHhmVnBrTXdXVHAzaXo1d2ZaelVmY1poRmpFRGRCZzVYa2NMWU03OUhCMk5zdVhQaWNDY3NOTThzMXJqOUc0dlpUeDNYL2FGQUp5TDl4aWlQaisrTitSdS8rdHJ2NnYzZVh4eHpZV3VIUGpoaWpPdGszQUtiWjFlbVcyOHJsY2Q4REJJVk9oZHdRWEc5NStLVnk5ZHV0aWUvMWpSMXo1MkF6Ni82TnV0dWkvWGxUN1FRR1dWRys2QWFFcDE2N1lSN0c5emZCL24xR1BuNW13ZjdIMzM4L2U5OXoydzV1Ky8xTjY1SmtBSGMwMFRleUt4bE9oa3hLa291bjUvdzZLTVhXT3FZQzVzRmplUzhmakRuUC8vYkgyZVNDK01pNDlMV0JwLzkvR3Q4K3RWOS90NXZ2c3dQZnZPVFRDNWNaSFg3eHJET1RSaUpOY1A2TnFiTmxGaWhzQVlYZE5qUURrNkVwOXlPTlVWZVR0VzI0OHBnVFRLTk0yK3FLajA5ZGM3bU8ydU14TERDV084bHNUSGZoRzhFOTA5M1gyNk5weHl2Rmd5YnJBRDQ0M3ErYkwxN2VjZmsycXVUU1c2cEI4OWdZakRTK0tmSHR0dzlncFBCMmNUd05iQWZ2WHVDZklYci9vMkNQaWFxeGhuQWE5M2Y5c0MxcnU4K3Zia3hlZW55cFl0UDdkOCszTUdycWlKNXBrd21NQm1WVEVjVlpaSHp3T1VwVHp4eGlaLzRCeS94NnUwbFREZVpibFpVNDV5WUdib0krNnNXclhKMnptOXo2RHhLNU5GN3prUHd1S1laektUVEUvNFVFeHZFVFNxRDYvc3BZSGduVXBvendhSXl0R2E1Z1dXcmhHQ0d4djJPRkNvMVVFa0RjcHBKSWdFcm5TRHk2dFZaOC9kbVRUOFRhQkZ4bzl6R0Z3OXIzaml1S1V1TDkvL2t4Ykk5MmVCd09Sc0NHZFFBdVdxMGx6YlA3ZTdtK1hzbGhIRm1MSzN6MUM1SVZDUlRVNTI3Zk9sTEw5KzYrb0lnbnE4UnMvZHVnWHlGNjhJazU2UU5TVjJuYjZKSW5QS0pSQ1FlSEI3dlAvbllXMFpWVnJ6dDZQQW9FNUNna2ZFNGVWZVZlWTZJOE1pRDI5dzY3dmpaVDF5bHJhYU10OFpNcGpsNWJpZ0t3N2pLS01jNXhUaG50RkZRalhJT3VvNnRJdVBTemc1OTIwSHNVVWdjSzU5T0t3WTBQUXdiclhVTGRqYmo4TTUyU2s2RFExVmhWZ2VjWHlzUDE2dGhQZjF4S3BTQUlXREVVV1JSbGk1Ky9QbUQ1VC9zdksvWGJVMGZvcDdVUFgySVpKbkZab1pxbEo4YU9mempYTWVyT1plM0w5QzRkbDBnR1pCSFkremxjdkplRStPbDFnZUtQRU1FZWg4MFJqSFZkUFQ2cTR0Ym40b2h1T0hydVZzZ1g0L3JzUEZrUnBnVUJqOEUxRVQ5clVVU1lxUjM3c2JERHp4d29WbXRIcWxYdFlscWNDR1M1MG5ERHNLNTNZb3Z2SHpFelpWUzdtNnh0VlV5cWd4VlpTbExTMVlaeUFUSkRWbVJWSVFSNWVhcVlTdTM3RXhHdEYySGFLTGFPeGRQcGJGclZOT2VZaDVybFNCZmhsZWtJbGs3eERjdXNHb2hOOGxKSmNsN3oramVOU0g1Q1pIdnBNenpmcjhPUC9YaXdja1h1WU5nQjFYVnRnK29xb1FReVhKRFdXVmsxdndURmNsOU8rZFpkbzI0NEdVb2tLS0x3VHcwM1gxN3FmcFlDaW9WbVR2UHJQZElWRE9kVE9jejZ6NnhYQzBYZ3JnN20vcXZYcEhjTFpEZjV2SlJxWExESTF0akdoKzBDM3IySkRsZEZKM01adDFvTkxxNXQ3dno5R0s1dUJpY3gzbm8rclRGRXBTeXpIanAraHdtVTdZdWJER2RabFFqU3pXMmpEY3MxWGJPNWw3QjltN094a1pHTVJUSnlpdlg1eXNLN1JsbHlSSkg0bnFGbk1pUXFtbnU2ZnRJWnVVT1oyc2dMNnFjOFNJWmltb2R2RG1yazB6M1RnSGRPUzZUaEY0eEpwSmJUN0RaNjY4dDNOOC9YTmI3dkpsQ2N1ZVFTZ3NONlZ0UGxobE1KbHg1Y0l1dHJRbjMzTHZOd2Y1dmo1ZGMyajdId2VLRWNHWlFqekhLL1p2bjdqdWY1KytLTVJZdWh1U00zM3V4aUpSNUdlTWsvOVZieHdjM2h5SDlxOTVtM1MyUTMrRnF2ZUpWY2NNOGNzYnQvT3dIWUk1bnM4VURWNjUwUlphOVl6YWJqMFdGemlsZEgxRjFWS09jZVJzbzkzYllQVGRtUExGTXQzUE8zVk54K2FGTjduOW9sM3N2YjdPM1c3RzFzOEYwTTZmYVNQU0syaW12empxV2pXTXpGN0NHaUZEbUprbDNKVzEzWHJ5NTR0eEdtZGJWQStvdVowNFRYY3R1aDZIRVJlVmtsZkFiRWNVTUR0bDY2ckNpR0tNWTZiQUc2bkZsNXFWcVh0aVk1YlpwRzljTlJaRnhCODFPRWJpcWVCOEZZTFYwWEw1L2w1ZGV1TTE5RCt4eGNseC81YloyYzRlajFaeWdjWTFmNW9yYTdjblcxcDdOdmprRVAwMDRsZUdrNndoZXliSThiRjNjKy94THQ2NitkUFpVdTFzZ1g4ZXI4WkUrL0k3dnQ0WVF6TWxzdnYvNG80OXN4UmllV2l5V1ZoQjZyN2hnbUU1eVZuWEhhRy9LNDgrYzU0SEhOM24wNlFzODh2ajkzSGYvZmV6dWJGT1ZJOHA4UWxtTnFDWmpScU9jY2lRWUUvRWVyaTBDYjV6MGpJd3lHV1VEZ1RCNWFlMHZlbDQ0ckhucy9CZ2RWcjV5WmdpUnRkY3ZkeUlQUTRSYkMwOXVNcXlKR1BGcDJoOXNTeE9meTJIb29TdzUwRmlLMWJmczdFNCtzTE0zZWN2Mnp0aUtrWHExN0U2cDZyeFpveUhKNEFMcFdrZVdXZmJPYjJDTXNGcDJ2K1ZOdkQwL1puTThwZWxiUk1UbzBHYUpNZmtENCsxdk15R2NqNXBTc1c3M0xjRkhDcHVQTTVQZGZLTTcrTFhnUTNlM1FQNjV1QVJKMTltVFJOcXVDeTZFTis2OWVPRnlVOWNQdHEwelNPSktqVXRoZTIvRSs3LzlNVDc0c2JmeDhGc2U1T0k5OTdBeDNTWXZ4dmhnRUVyeWJJd1lDOGFpTWtKc1NaNkI0b2d1TXVzaVgzejFnSk9ET1h0YkZUYlBLSFBMSzRjMUw5MWU4VTBQYmRHNWxHOHVnM1orSFdpb1o5YTNRZFBwZEZSN1VNaU53K0FBUXhTRGtVQW1QU0tPb2loWWxoTm13U01haEJETDNKb3I0MUh4M3AzdDBWTVhMbXp1aVpGMnNXaWJWQ0NTblNrVVZKV3VkUVFmYWVwZXh1TUM3d0tqVVU3WCtUZmZqR0lKTVp4MTJpOWNEUGJLNXJsM1ZCb2ZTZDYrS25VZjZIeEVFQ21yNnNCUHNrK2NMR2JMTDhORDlHNkIvRE1xa0xMTStBcnlnMncybjdzc0w2NWZQSC8rNmFadXpuV2RJK2JJUjc3dlNYN3d6M3dMNy96V3A1aHNuOFBrRTBvN2hwalI5a29NZ29vZGFCOFpQb0IzU3ZTSzYxcDgweUloWUdQazRQYWN6ejUzaTJ2N05Uc2JGYU5SeVM5KzhZQ0RaYytIM3JLRGM4azBZVDFnMjdYbDZCbXpuMGhDNEEvckh1OWdsS1Z0RlVRUXhVaElSV0tFdGl3NWxwSThINFAwWXRjd3ZtcVZaK2IrMFNoLzUrN3U1QjNuTDB4M28rcXlhVnlyS1l6OWJOdEZqSXJyQTh0bFIyYU5GRVhHbzQrZTUvYnR4ZWtiNklKalVrM0VCU2ZyT1NSb2xBdVRyZnUzeEx5N2R6NkxLdElPNGF2T1JjYlYyQlNUNnRQWGptOWRQek9IM0MyUWY1YlhQZmZ0Y0c1bmoxWGRTSXp4ck9sMWNUS2Z0WHM3TzAxWkZJL2JNUnQvNUU5OVVQN1FqMzJRU3c5ZUlpL09ZVXhKWmpLNkVPaWNTNm85MVVTZEQ1RzI2M0Jkais4RFhkT3duQjNSclJwaUgya1hMVzdWRTRQbjFSc3pYcmxWWXhDdUhUYU1Sd1Z2ZTNqN05KTEFtTUdVYlNpUzRleGJPL3Rnck9IYXJHTzJER3hXQ1ExSmRQbmtCSmxac0tNSjEzeFBFMXFzUkZTU3ZXcVdHVEhHSUdJUUpDL0w3T0o0Vkx6dDNrdWI3OTdhR1p1K0QwZDEzWHZPQ0pwT2oxdE5rVzVsbFpGbGh0bXNPWFdCQk5pb0p0SzZibDNmdVVJMktzZWpDL25vUThIMTA0aXk4QW0valQ1U0Z0WElGdmtMVjVlM3ZrRFVyL29jY3JkQWZoZlhlNy81VWVxbWxjV2l3Ym13ZnRybFFBV01qbVlueTQ5ODc1UGJmL0xmK3ZDVDMvWDczMmJLMFlRUURHSktNZ01oT0xyZUUwUGFOSVdRZE8xTjM5SzBLK3A2UnR0MnJCYU9ldDdRMXkzdDByRTRyT2xiajAxVndHd1ZlZUg2a3M0cDczbGtsNzNOQXF5UUY0YXlNS2NnWXBKd3lCM0xvaUhGNTNnWk9GaDJiSmNGWWlMV0RHdGRoS0txdUIwakIxMkROYUFTVGdWWXhpU1dzakZDWHRoaFhzcXpzc2pPNys2TTMzZnAzcTBuSjlPeTYxcS9hRnNYdnZ3MFVhRHZ2SjZjTklNYnBaQmxkc2dPS1dsY0t5SWl5ZGVleXNmUVhxZzIzcFA1ZUY5dWhEb0VPWEU5ZWJRYW8yWnE1ZXFNOWxOZDM3VjhsV2tuZHd2a24vQ3FxcHk4c055OGRpenpXWFBhSzR2SUNKaHNiWSszLy94ZitON3YrSUVmZWQvM1BQcjRwZTNlUithZFF6QmtSdkMrbzIxcVhMUEN1WjdnZTF4N1ROYzFOTXNaVGROVHIrYk1UZzVwbHgxOXAvU3Jqdm50SmMyaVM0NkpJZEsxWFdwWmFsaTJnYU5sUi9DUmNaa2htVDNkU0ltNVkrWmdCdFZoYW1lVTQ3cG4xclRzVkRtcUtabktHa09lRnh4UmNMUHIwT0Zrc2RZa00rMFV4VEVrWUFsbG1WT05jcXBSSnVVNEp5dHNOaHJuOSs5c2o5OS84ZUxHZlZsbVRnNzJsN01CbEQ4bEZPcmdGckVHTllNUGJHOU95TE1LN3oweGJiTXlrTUpZbTEvYTJIdW04T0hwR0tNRVZFNTZSNllHNzZQczd1NkpWdG5IRCtaSHg3eFpaYWgzQytUcmVQM2NyLy83L0EvLzdTOXo2OFpNbXFhWE84WEJTSlhwNXRabyt5LytSei80L2QvNWZXLy9ZNXZiNDBzK1FCL0JHb3UxV1lwSGJ2dkJhY1Rnb3lQNGh0Q3Q2THVHMWV5SXZuV3M2cDZtOXJqRzQ5dElPMjlaSGE3d2ZacTArOTdobmFkdVBNc21EZUNMeHZQSzdTWHpSVWNwSktzZkk1aE1LQXRMbVJ2cU5qQmJlV2Fyd00yWjU5V0RtczNTVWczeHpsV2VNUzRMVGxTNDJnUXdWVEx0a1lBeDlvNzBWOVlGWWlqTGpLTEtLY3FNWW1RbEw2eVlkSXFOcDlQeUxUdTc0N2Z1bnB0VWkzbTczelRPZmRrOWQzb0QyOHhTNUJtYm95MTY3K2g5TDVJY2V2T29tbTBWNHd0VE1kOHFNZGhNREVzZktJMFJGNVF5SzJ5dC9TL3MxOGMzejV3ZzRlNEo4blc4c3N6dzFOdnVsMDk5NG1WWkx0clRJUklZQXhzN3U1UGR2L2dmL3VEdi83YnZmT1pIaXpLLzBMdEFVRDBOeXhHUlpCSGtBczU3K3VnSTBkRzdIdGQ3dXE2bGJoeE4yOU8wT1YzdGNFMVB0MnhaSHJhNHhxRXh0V0tkOHluRGI5N1R0R2NNNEJSczhQUk53OEZKTnhnNEdKWmQ0UHJ0SmRjT2UxNDk4cng2VW5OMXRtVHBld3ByQ1NwRVRVVEFXWXk4VmkvcG9zT0lRZGNoYk92TjJCcFZKTTB4WlpsVGpITHkwcExuQnBzSk5rK1NBSnNaeXNLZW0yeFU3N2h3YWVzeEVUazRPYTZQQnYyR3ZLbElGRUpJNzlmeDhnU1RpR01HU0FVeW1rNzM4dEdIY1AwME40WkY4T2tFQ1ZFTGt4ZVQzYzJYYnpYSG53OGgrRE5GY3ZjRStYcGQxZ3FmK0pVWDVmaHdLVEhxZXVZWUF4dlRqV3JyUC9oUGYrUUhQdlR0ei96dlRXN094YWhES2xpQ3JlTmdKdDE1aDR1QnRxMXBtem5lOWZUZGtxYWJVM2NOWFNPc1ZwRzJqL1JOUjErM05ETlBPK3NKM29FT0hsdyswTlFkKzRjZUgrN2NZNFVSTGs4TnBmVTBiYy9KdkdHNTZ0aWZPVjQ4YUhoajNuRmp0ZUtnYldpakowaGtFVHlMNEZsRlR4MEQrNzZsaXg0a0VMVkhqSklHY2pqdGtJWkNNVmFvcXNRZHl3cVRGSlNaVUJTSms0V0kyTnhvTWM2S29zd2YyTm9jdlhNOExtT3o2bSszclhOREFheG5kNDJxS21JbzhvTGU5MnRlbGdYS1VUbks5c3J4TzR6djc0OGF0Vk9WM0ZwQ2dCalU3TzN1OVNmYS90Sml0YWhGNUtzMmg5d3RrSC9FOVdOLzlpTk1OeXF1dm5KQTJ6cWpkNHBqSk1MR2VGSnUvaC8vcnovd3ZkL3k0YWYrUkRHeWw3enZ4TVdRMnFoMVBnWTV6bnVjRDJudTZGYkU2R2o3aHJaZDBYWTlUUjJZejF1YXVpTzBQY0VKM2R6UnpCeXU3MEVETVVaNmwwSjBaa2N0eHpOM0NnY2FVYzZQRE9kSG1tWU9BVFN5YkIydnpqMzdyYWNPUFpFVStXeUhpSVUwV3lnZXBaZUVTOWpUTmlvTjR5bXhTaytkVldUSVdEUWlsRlZCTWNvU1VURzNLZnBCQkxIcnVRVkpoV01vcW14N09xM2VzYlUxdW1LTkhCMGQxVWRmZHBLb1MrM1ZuWjM2Y0ZJM3dldGVPYjEzSXZJdUM5WkhSY1ZnSXRKNEw5dmpqZXdrTkw5MHZKcmRQc1B1L2FjdWtMdDZrTi9oZXZmN0hscGpDREtZOWhsVk1xQVVZUW95L2VOLytpTWYrdWpIM3ZxbnEwbCt2d3RCbzRxbzcxTUlwczB4Sms5YnFoZ0lvU2VFRG15RytzUVdSbks2dG1lMWNIUnRUSjVWYmFCcm9KbjNkSzBuaHNUQjhpNmtURUlmYUJZT295bGpJeFBsUW1XNHZJSGF3WE5FRXl1RlZiRFNNWVRqckUwWjFpSXNBU3NaeGtZWWlKQnJ3bUxhVXFYaUlDYXRpZWh3bWd4aG5CcUU2TVBwTm82Qnp4V0hYWEtlQ2NZYVFsQXlrN0JWa1hJank4MzNsRlYyWDU1bGYvVkx6OTM4cGVGRUhrQi9QZHNlbmRyQk90ZDFqWWFYbzJTMVJyOXBnVjZVVVc3cG5kSXQ2NTBybCs1NTlLWGJWNTlWOUN4WXFYY0w1R3QwdmZiYUliTlp3LzZ0T1NMWUdIVmRIQk5WSm4veVgvL29CMzd3WC9uZ255c254ZjFOMTJ0RUpiUU40aHpaZEJNVlE5dDFkRDdnZzhmM0R1ZVVFS0h1ZTZMM2VPZm9XcVZ0b2U4ajZsT2NkRFB2NlpvV29tSWw0bnpBdXpTSHJCYU91dkZrS0lVeGVyNnljbTRzWkJMaVdseUZTT3lDc1NkT1pJMmdpM0E2WkF1RHQ3Qm1RM3BVaXhJSHY5ODdhVmM2WkptYyttZXR3M3RDVE1sWUlhYkEwUkFUcHBNbHZwUnFxc3FpTW5SZFRIVTV0RjFpVVp0Tm44bU0rWGZ5M0Z4Njl0a2IvNnRMM0syenN0azF6TDQyRkhldGhoc21MMjZMbDgxRXVBeFlZeEZCKzY0dHAydzlnY2pmUXpVYjd1MS82bFBrYm92MU8xejNQYkRIOGVGU1RvNXJNenlWVG92aisvN2dlNTc0RTMvMk8vN044eGQyM3FwUk5CSWxvbVI1UlZHTkVXdHdMczBMcmUvb1hFTUlpdk1kWGIraTdWcFc5Wkw1ckdPMUNyUnRRTDNTdFlGbTdsZ2N0NFRlSTVyQ0xIV3dEM1hPYzNpN3BWMUZyRmd5UkRKVDFJSDh4VGFHbjNNeHZ0Ukh2blRjeGwvY2IyendtSXVTM0tqQnJER1J0WjdkREpGcktRV0VJWmZUREJFTURMdFptNXpzenN3ZmQ1eFdpaktqckFyeVloalNqY0hZdE5Td3VhQkdpREdkWm1hWThzV0lpRFdTNWRsV1ZlWnZMNHZNbnh6WEwva1FBNy9WbnZSMFc3aUtuc3ZWeHR0TGVJU28xQ0VnR1BvUUVSVmJWdFZpbm9kZlh0WEw1VmRybTNXM1FMN0M5ZC84ei84V3kyWExxeS9kbEpPaldsUmpOa1NHajFHbTMvbTk3M2prei95YnYrL1BYcjUvN3dNR0VWVVZSQ2xzZ1JpTHg5TjFQVzN2NmJzYUYxcWNheUJhdkhQMGZZZHpMZldxbzE0cHZrOCt1S0dQZEV2UDZyakZOMzBpSG9ZaDVETXEzZ2RPanB1NE9JNk16U2hhazkweXhqd2JqUGxiUjY3OXIyNDE3YzhldFBHWDl0dnd5MGROK0d3ZjR1Y3pNU05yelVPWWRiZVE0cU9ObUZPUjFHa1VtNXJoeHRmVFZtdWQvU0hyRTJUZHRRd29mWmJuMkNMRDVwYWlzSmdzbWR6bG1aeWFjVWNkakNVR2wwaGpKTkh3clNITGJWWGsyZFBUVVdHWHkrNlZydlA5bHhVSmE1YUNqekc3Yi9QOGsza0liNDAreUNKNDZhSmlWYVRYeU9aNFEvdktmSEwvNU9DNlNKcERSQ1Fnb3YvMVgvbHYrZHMvL2IvZWJiRytHdGRnNXltcHRSS3JPcURreXVTK0szdTdQL0pqSC83QlJ4Ni81Nk9FWUFGSlVoRXpDSTBDSWFTQjNQdVUvNUdaaWk1R2ZCampnNlhyRHFpYmhsV3RkTDJpUGtrQll5K0V4dUJYUFRxWVQydUlpR3BhRGZlK25pMjZYNnE5N20rWHhTSTYvY3l5YjErbzIvYjI4TVFjZ2tLU1kzb2Z3MnJaOS8vWlZQSkZudHZ2RjZPYnc3b29kZnZEa1pFaW96bU5qdzdyNklOQnFiak9YRmROVmhCVzhwU3VGUU45NzZsOGFxKzhpMlJaY3MrT1Fjbno1QTIyWmtOTGl1R0ZDRm1XTXR2TGFjWm1HRzBhOUk4YUlYN3VDemYrK3FydStZcXRWZ3oxN1hyeHVjcGtKekhxdVJnaW5VUjJwY0FIMWRWOHNUazlWMTNCeUtjMTNwbEQzdjdrMjMvWHM4amRBdm15NnkvODVSL2taMy9xMS9uaTUxNUx0T3RFdkN0RW1CUmxQdjNULzhiM2ZPd2Q3M3p3K3pYNERGWHBRK0pRbWNFNE56Y1dOU1VkRWFKUGNXYWhwMjNtaE5EZ2ZhRHZHOW82MERVUjN5dDlHK2hyajFzRXVtVS85UG5KT1RIR1ZDVEJSK3JhL2ViaGNmMVg2OWJmbUxlTEpiRGlEdmZJbjFsdHJ0dVNxZysrbnpYaFA5dlE4dldxelA2a1NEdzNpS25Fc0hadkgwUzVnMGN2Skl1Z2RUanoyV2dCTVpMYXNaaHdFK3NDd1FWaVZNSVFCeUVpR0R2a3ZhdVNwUnpySVRjeG5UNWl3V1RKTXFtYzVoQ3FpUVQ5RVdORWYvUHoxLy9hYXRXdlQ1SHU3Q3pTRXZaTk5xclZlU3F4T0EySklvT0s4MzVyUzBidm0wNm1QN2RjTEdwQnJJallOMjY4RWIzM2QxdXNmOXJyTFUvZng1VUg5dmlabi94TmVmM1ZBd05xMDl3aFUxVkdQL3lqMy9yZUgvclJiLzN6MDNGMWo2cWlrcndQallGTWtsYWhkZjJRUXBVR1YrODdOQVFNaHVpZzYycnFsYU5lQ2wwWDZEdVBheU8rQy9UTG50WHg2dFRLWFdNY2lpUGdYVGk1dGIvOGJ3K1BtMThERnFUNGdlYk1hODFEV2xNdDFnVVRGRnpuL1V0V3pDeXo1b28xYkFzaWI3Wi9rNkdGWW9oRjBOT0NXTWZDeWRvbyt4UXJIRElWaTR4UmxWTldHZXVWYnBhbkZzNFBCV0d0T1FVejlmUzRHZ0RDdERWVFVhb2lzMDlPeHVYcXhxMzVDeHIxYkt1Vk5DZkdtSHNuVys4eTNsMXhQaEJCU210Uy9tTEFHR01XYkpZZlA1b2RuYXpmaDc3djQ4Yy8vU3U2cWxkM0MrU2Y1cnB3enphZi9PWG51WG5qeElRUTEwajVCSmg4Ky9lODdiRS85K2MvOXEvZGUrbkMyeXdHSlVpTWZ0Z1k2UkRsM09OZFFJSVNYR0tjaW9JR0lmaVNycXZvMnNocU9hZHBBbjBmY0YwZ2RJRis3bGpOV3ZxbVQxSFBwL2tnVVRXcUxKYnR6MSs5TnYvLytCQ1B1WlBOMFFDZGtJQXgrY29CTmFjdTY3MzNyNmpLODVreDV6TWpseVU5NEFjL0xPNWtwUStUUnVKdjNYR1BYek9CZGREcEMwS1dXNG95eDVyMDQzUlNwTllxNWZBTXBuZDJ1TXNIbzdzd3RGM2hUdVMwR0JHaWorV296QjRmai9NYk4yN08zemd6andpUXQ2NEw1NmJidTZXUDcrcWN6K2NhcERJV1FqS3dHSTNIVk5zYnYvSDY0ZlUzN2p3c05DenJXaTlzVGxoMTdtNkIvRzZ1Yi9yUVc3aDI5WWpWc3BXKzgydUZYQVZNTHQyN3ZmZnYvcVUvK01lZWVmckI3MUUxdWRNb1FUMGFRd3F0UVdoZG9HNGFRdGNQV1lMSmlqMzRRTmZWOUYxTDMzYXNWblBxdXFIM3FUaGNHM0cxcHo1dTZWZGR3aGlHeEZ0VlJhTksxL3FYYjl4YS9PZkhzL2E1NGZSWURjWFJXekdoeXN1WUhOSVRHdjJtWStIT3l3QzVDK0U0aFBoeUpqSzJ4bHkyeGhTRDVsRFdqdTNyMzI1TU9oM1Qxc3FrNGhpcUtZWUF4bUJ6UzE1azJNeWVuaDdXQ3BsTjFXYk92R0xram1sajROUk9YK1BaQUY5UjEvcnh4cVI4WkRJdHI5NjRNWC9qREpob0FWTmwrYzZ1S1Q3czJuNVVhNlF3QmhPRlRpTjVsaGZacVByaTlmYndpOEg1OVlrYThzenFvdWxPWnlFUjRkTEZTN3p2ZmUvandZY2U1TlZYWC8zSzgramQwa2pYeDMveHY2WXNyYlNKaEhpV3ZqNytsLy9ZQjkvNytCUDNmNWRpeTlZUGlXTkJzWkloR0VJWDhLMGo5cWtkYXBvbGJWMVR0elZ0VzlQM0RYVjdSTjBlMHpaekpFWnNVRXhRb292VXk1NitkWGRTY2hqc2ZGSUNibjh5Yi82L04vZFhuenJUVG5XQU4yTGlKSy9pZGpYVjdXcXM4dVppV05NMDFxODFyY08wUHR3NHJMdS9YbmYrYjJqazlqcGhhcjFLUG1YYVJpR0VtRHk1Qkl5MVE0dTFEclJKMnZiZUIxUWtIVithRVBSNDJod05BMzY4NDRPcU1SV2VzWkJiWWUzMks4WmdDeXQ1bFF2S3c1Y3ViUHpSQngvWWZXejRISXAxb2N4OS93WkZjVXNGdFlvR1RTcEtqOUwxZlVuckh0K29wdVBoTTh3VWpBOXh2WE00bFFXcjZ2cUZ0ZmJ1a1A3YlhYL3BQLzdmc2JuNUhmVE9JeUlteHBpUjBoREc3MzcvSStlLzdhTnYvd043T3p2M3RKM1QwaGpwbWlWZFUyTXppeGhEN0R6U09YSlZuSUY2VmhNOTZNZ1R4ZEE3VDk5RitzNFRndEowa2VnVURZcDJnVmg3WWorY0duSGRla1NJU3QzMm56ODRhdjVCakZvUGJWVUhCQ01TalJHOTU4S1V3aFo4OFkwalNTMzdxVncxRzI2cThzeXJ5RE9UNVprdGZJanRjZFA5WE9QODdjMVIrUzhXZWZZNGd0VVlpV0tUTTJOTVpyaGlkR2lQQnRxSk1VT3hHS3kxS0dsZzF5SFJ5bnRGaldKak1nU09VVEV4Q2JkQ1RIaDVHbUhrdE8wS01ibEdSaVBrb3d6WE9jSHgzcWVmdVBpdmVoLytIMjljbTEwYkJuWGJCWGZZRWwrenhqeUdVM0ZCR1NlY1JWM25KSXZtd1F2VHZYT0hSd2V6NGZzT3FtcU1pSzdoVVdOTVBEdzYxRi83MUs5RkVaRTh6elVGaGQ0dGtOOXliVzFOdUhqUHRyejg0czAxRWJFUVliU3pPOTM0VTMvMisvN0kwMDgvL2lGUkpNOTZRdHNnc1NldmNweHpTQWpFR0RCNVJtRU1ialduSEJWcE10WUFFbGgxS3c1bkRVWU4xbGcwSm8yMmJ6ejkwaEU3UDVoYzZlbnBFWU1TZkdoV3kvN25Eby9yVjRZaHZGdlBHdE5KenNZNDU4Lzg4UHY1NzMveU00UVExNkVlNjhJWURUZEg5Y0NselhzZXY3TDlycXJNN2dXMmpMRG52TWFtOWMxODFjMk81dTBuZmE4bEtnOUZOVWJFcE5raGM2azRWQWcrWUsxTkNWaHJGL3ZNVWhZWitaQWtHb2NUeEtXK0V4OFVDWG9ISkRRUU5XS3loSU9FWVRObVUrZzhVVk5yRnZOa1BsZjNYVDdLN0hjOTl0RGVjemR2TGY1Nzc2TVRSQnJYOWJYR3E5UE1SdE5oVjlHeFpUSUtFZkhSUVF6M1pZSEx3STNoMUxUcHNOUEIxMHhERE5HTFNLanJPaDE4cW5yM0JQbHRybi93TTcvSmF0VVJZM0wxRTVGS1ZhdVBmZC83bnZ6SVI5LzEvVlZ1cStock5IVEU0TWlLZ2hBRGVWSGdXazhnSUZsNk9xcm1qS2RWQWdQcmpxWmJzbHEyZFAyUU91NE1Fako4NTJtWG5yNXhCQmVRcU1RWTFxQ2dSaCtrYTkyejEyOHRmbDZWRlhmeUFJT0NMcGE5ZnN2YkgrTG5mKzFsWHIxK25HNnhSTEdvQkVZSzQwdTc0NHZmOHZaN1BueHhkL3dkbStQaWZTSHFKRVFoc3htNU5aUzV3V2EyN2J3Y1IzSzVjV3V1Ly9CVEwxRzNQVVdaRXpYRFJJK3hhVUFJUTd1VWVGb1dtMlhJTUtqSXNKV0tVVS85dWtKVWJFamt5WDV3U2xFRFdVd20zeWs3TWJWekdZa3dHUWR4VmxaWUVOWGxyTTAzUjhXLytNU2o1ei8vK1MvZCtnS2krT0R6NDc3OTRraE1td3ZUMWNBU3NBSUJvVisxNTZ1dC9MRXN5NTczM3VjazZXNXpadGp2Z1Y1VmUxVTlDN3I4RnRPNWIrZ0MrYi85SnovR3YvZHYvaGY4N1IvL3VCaHIxay9mRXJUYzNkdmMraU0vOU5Idm0xVDVoZUJYR3JTVHBta0kza05RVEphaE1hTWZGS1dDd2JzZXRSV3FocmFkMDlRTFZzdUcwRVl5VlZaTm9Hc2oxZ3UrZHZTckhud1licVk0SkM4WlluQVNveTVtaSs0blR4YmRtMDhQSVJwamtqbVBLai8vcVpmbGVIRkcyWmlLWS9LVys3Y2YrYzczWGZrenUxdmxSNHpJWnRjSHFySmlNcDVva2VkVVpTbVR5WWk4S0VlQ0dWbHJlUHloaHEyTmlsLzQ1SXZzSDYrd0dLSmE3SkJ5dTM3SXJ0SHdKRFZja3hybGxNT2xNWUdSYTNRdVJ1NjQxRWVJWGhONHFPbW1WaEx1NDA4SGFPaGJ6OG5oU2x6WHF6QjYrTUg3dG4vazlSdXovMlEyYTJ2UWJONDM4M1BaeG41RXAxNmo5aUdJSkRkSWRXMW5KNXVqOTQveTZsY2JyYnY3ZDZiM1BidzN2ZWZjdUR4WFpCdm5Qbi9rLzg2blgzNzJ4U0hHbXFGZ3ZxSWo0emY4Q2ZLT2R6M0NzMSs0aXV2ZCt2UW9WYlg0Ri83Z0I1NTU0b243dmtWam00WFkwZldlb0JhdlBabWtKNmlQTXVnZUVtblBta1QzOXAyaDYxYzBiVWU5aXZndXBxMU5pQmdIb1hkMHk1NTIwZE4xanI1enhBSFY5ajVxNzN4YzFmM1BYTHU1K0NuZW5DWWJSbVdtVzlPU2IzL1AvZnpzcDk1ZzFmUkRwak9aUUtVd2V2S2g4MWUrKzV2dS85ZTNwOW5IaUZnZlZMZTJkbVJ2ZTVNWXZPUmx4ZGIyT2V3QUFIcnY4TjVqak9XcFJ5L1M5UTJmL096cjNEaW9zYmxCeFlJRU1nbEVZNGhXaDhTcjFGYWRLczFOb3BtSTZKdXlTZFo3NUtoRDBjU0JkbklucytmVVpVR0czZlBzWUVsYnQxaGpwRjUxYkdUMnZVODlldjRqdi9vYnIvKzhJTG1hMEZVYjVvMnRZdnhRSG5xbVJ2Q3RvV3NpYWp3YjBqMzVMNzM3dmorNnRjSGVKTXN1WkVIM1JHMzE4azFiM0RzZVA5dzk5SmEvOHV6THo3OSs1dVE0UzIzUnV3VkNVc1JkZWVpaWZPNDNYNUhoR0NoVXRYamk2U3VYZnZpUGZkY2Zyc2JaZll2NkNDTkNDQVdaaVJpanFIZTRvRVNUcHhNRmcvT0J2SndnbWpPckYvUXUwSFlSNTBaNEo3aHVqamhGWGFTWk81YUxmcUN2SzhISGxJRWVJcjBQRWtJOFBqeXVmN3JwL09Gd2NweFN3SHNYdEN3TXE3Wm5WQnJ4UHE0akN3dUZhbWRqdFBQZEgzandoN2NtNXR0anduTFkzdHlTN2UxZCtuN0paTHJOOXZZZXpqbThEd2xjeUN6V3dQN0JJU2Z6QTY1Y3RGejZ0dnY1OVdjUCtkeEx4NmRld0NKaEdNcXpZVG0xdGhGS1lHQjJ4dlFCSVBnNEdENmtPOTlvd2tRVXdVZEYxcWZNSUNvemt1SWM1clZqZWJJYXFHRHA1R3BYM2VhNXJkSDNQM2psd3JFSjJ4ZmVlbkh5bmlkMndwTWo4V2hRS1RPRDY1VmJSMDQyTmpKMmQvTHo1YWI5RjZJUld6ZGVjaU5jdngzajhjS0pTUHp1eTlYR2padGJPMy8xYUhhOERrdGFGMGpnREUzK0c3cEFYbnQxbjA5OTRua1NuVVF5VkF1ZytNRWYrc2piN3IvLzNEdTlhMHpRaUdxR2hqN2RxMUdJWFUvblBORUdUSllSUXNUMUFlZGErdEN4WEIyeXFtdmExaE5EVHZSQzEwV0NpN2plMDZ4NjZsV2ZqR3pUYWdrWEFpR3FhbFNXZGYvVGg4Zk5id3lGMGF4SmQ5YUkrcEF5em4vMTh6ZVlMVjFpYzV4eFZQa0RIMzNrZzd1YnhlL3JPMWVGb0V3bkk3WTJ4NnpxR1lhTUlxdG9tbm9BOXZLQnRBaEh4eWU0L3BpZHFSQkRoaXNNNzN2cmViWTNTejc1N0Q3THBzZEl3blhFSmw4cWkwbDJKWnJBd1JBaVdUUkUwWVJBU3RwT21Yam1vVHc4Q05ZNzZiV2MwQXdEdmdUbFpIK0pYNXZLRGVtKzNnZWFWWGYvM3Nia2o4ZGxkWDdYeGlsZEozV0lTY1ZvaFNvWDdqbVhNUnBsNUtXWUdGUUlVT1dacm5vajEyODNKbEZuTkJ2REgzcm04b1BYUDE2dmZ0eTUvcFIxOEdVbnlUY3VVUGp3by9meXN6LzE2eXdYdGRHVWMxY0JrOGVmdk8vQ2ovN1l4MzdvZ2Z0MzN0MjBNeEVUMGRBU0pYbm9oTTVERkZSeWZCU3liSVBlQmJxdXdZZVU1VjJ2Wml3V0M5ckcwZmM5YmQvaVhVZ0Zza3BVOXI1MVp6Q1BTQXhSZlFqU05PNkYyd2VyLzN5KzZGODlBd2c2RWJRc3JIb2ZFUU50SDZWdXZTRUp1Q3BnOHN5amUvZCs1RDBQL0drcjhyYXVjMlJaeHQ3T0xrVlJFcUpoYjIvdjFENnVLRXFLb3NDSXNGcXRhSm9ab3pKaVRDcjRrMFdQWUxsMGFjdzl6MnpoZk9UV3RRWXhtbHFvQVd3VFl6QTJVVW5NTUkrazllOGRCNVhCelRSUmI5Ym0ybEZQamJUTm9GY3hSbWlYSGJldW50QzFEcEZrSzVUbDJhRHA5MW5mdHJ2MThheWN6eGNjcjNxcVhHUTZLU2h5Z3dLdEM2ejZsRVdYZVJVaklqRWlWOTl3SEM5QmpDWFBNelNHcXNyS3krT3Q3UzllUDdoMVMrN3cyZGJ0MWpjMlVQanlpOWNaalV0SkJnSnFSU1FIaW0vNTFtY2V2Ty9LdVc5eXNUTllKWGhIMXptSTZiZzNSVVkySHFWZU82WVRJZnIxMDlYVHR6MXQzZU43VDNEUXRUSFJTWHFsVzNubVJ3MWQzU2ZHNnpyTUkyRUlFb0w2cG5FL3QzL1lmT25zN0NGQ01FYjBJOTk4RG9EdmV2K1ZkZHN2bW1hUFVvVHliWTlkZXVmMnh2Z2RJYWFXYURxWnNESGRKcXBsT3QxaGEzdVhhanhPa2RGUkFZc1BrZG5pSkNIbWt1TkNaTEh5aUtRWUE5MjF2UFg5ZS96QkgzNmNEM3piQXhBeXVqYmd1aDduM0NBakRqaVhsSTlyRFV3SWVwcFZFcjNpUTNyRk1BUUJ4VFMzclNNYmpBRjg1UGlnb1cwOXhocnlJcWVvQ29weFNUbXRLTWNsV1FHejJQTHBnNVg4dytzbmNyUHVxZGIwRm9GUmJuQjlUMWYzYUJQd0s4ZkpMSEQ3Sk9COFRGRVdZUWhrZFAwamw2dnBqeng0K2NxNTRSUXV6Z0NKMzlnenlJYysrbFkrL290ZlFJY0IxeGpLMGJnczMvR3V4NzU1ZTZPNnAxa2VFS1FqUm9NUlMyYUVxR2JZM2FjZGZ1OWFmTmVnZUx3WDJpYXdXaTVvNm1OODV3aGRJTGFCVUh1Q1U1cVRqbWJlRVZ4QzNCa2tzOE5hVkoyUG56NDRhbjVTVlJkbkJ2TW9JdnJRbFIydTM0YnYrWllyZlBJTHQ2WHU3aGpXS1ZRWGQ2ZGJUejUwNFR1cXF0enUrcGxtV1NZNzIzc0puNGlSeVhTQ2lNWGFuS0tVMHhYdGJMNmc3MnF5U3ZCQm1jMWJldWZabkpSMGhiSjdwV0NVanlqMmR2bU83NytIY3hlMitNV2ZlWjdWS25FalJlNFkwbGtiMHNsaUJHUGpRRTB4U0VqelJsWVl4S2FUUk5QL0lRN1JjUktVZHVseFRTQXZrK3ZpZUZ3eG1oYlkzS1lCZmxnWjN6cW9jU2VlS3p0VG5qaS9rVFQySWxTVlJkVXlyeDJyT3JDeG1lT0RjdnNrMEhSSzFJanpqaXpMOFNGZ3JCaHB1Mis5TXQ3Ky90Zms5ZjlLVmJ2aFBWMUg3K2szYklIY3ZINGtJc2FJcE1pdkdMVjQ1TEY3ejcvMW5ROThJR2hybEtBeEdNbU1SV3hBZlUvd2lnOEJIeHE2ZnVpUlE0UDNqaGd6UXRjbHQ1S3V3ZmVSdmxkaUh4R3ZkSXVlWnQ2aUxxWitlODFvSFZvTkY4TGg4YXo1OGFPVDVzVmhNRDlkNjZaWk5WSGZzMHk0ZFZRVG94cUZUSVFTcFhqbkV4ZWZ1WHh4ODczZXF6Z2ZaSE82UVZHTWdJQ3hscUxJRVdQSXJNWFkvTFRWN3Z0K09EMlV6aWRxZldZdElTclZlY3QwY3dybUhxS3o5TTBON245Z3hJYys4aUNmLzh4dGJ0NmNvMFB5MWRtdzlYVWtiVlFseXhPQ2JtSkMyS01Hc3NLQWo1QmJORWFDVDFFUnJndFVvNHpOT0Vhak1oNFhWT01ja3hzMHBxRWZKbXh0amJpM2pYekhXL2E0dkZjbFdUQ1FtZVNvUDYxeXZJMllrV0ZWUjI0ZGg2RWR0c2t5YVpBUkZFV0dSSmY1dHQwUmtiR3FOcnpaTXVnYnMwQys5L2UvaDcvN2R6NkZNVVpVMVlwSUlVTDJ2bTk2N01uekY3WWU2M3d2WW0wQzc3eEhCaEZVakFYT05ZUytRYnN1dFVhK3hzYU12bDNRekdlMHk1NnVEcmcyRlllcTRycEFzK2pwR3pjOFBkZGV1VW9FRFJyanNuRWZmLzNhN0JlSHdsalBIV0ZVNWZIYzNwaVhYajBHSUgveS9NQVlIUGhpU2prZEY1TjNQWEh4T3pMRCtkbHlRZkNCOFhoS25sbWNTN3J0ekZyUVNBeUJyTENJWlBSOVM0d3Q0MUdGRUZuVkN4RElqTVVadzJqVG90RVNUVWJmbmRDdVRxaHJ6L2J1aUdmZWRRLzVzd1d2djNwSXMraVJzL2pJTUh4b0hBeTVjMFBNQkhFQkd3MWlCODM2b0pSa29OaFlnYkswV0ZzbFZXSnV5SE03aUs3U3FWTldPZWZPYi9ETzNTbVBuNXZRdTBneGJNWjZUV21MNDFHR2xta3RkdU00VUhmSlpkK2F0RktybXg0amhqelBxRjIvLzhySjdlZU1tREtpSldnenZMZmhHN2JGaWxHWlRDcXA2ODRBbWFybXUzdlR6ZS84Mkx1LzArYlpWSDJkTE5kRFA1Z1NwTTJmYUVkbEZJcU1SVGNudUFYV043UzlTWUtudXNNM0VkOE9La0VmQ1YyZ1dYVDBkZjhtVlI0eEVsVFZCNlZ6NFkyRHcvcC84VDZlckZtNncxTXM1cmxsUEM1T3YvWXZ2SHhFNTRLb1lrVW9WTWtldVgvcnl1VUxrM2VIMkZ0alJLdXlZalFhcGUxUDhJZ3hLSU4wbHpSa1o5WXlheG8wT3ZLOFlMbnE4YzRQREY0aGxqQWFHMExvOE4xVm1tVkx0MHF0NG1vVjhBRXUzYjlKVVZtdXYzNUN2V2pUZkRIOEV5bVQ4NGtrVXFQQnBBeDZrd2lRSmxHeXlBYnhsRVJETnZnS0I2K244bHhyRGNaQUxpa3dLUGpJNWUwSmozaWxhVDBhSU9ZcDZUY1ZWYUlMQngrNWRleTVOZFBURTg2SHRLYk9zMFNsYWJ1ZVc4Y0hlMVYwLytyak8rY2ZQWERkZjNscmRyVGlqSmZ3TjF5Qi9PdC8vbnY1aWIvemEvUzlTMHRFa1VKVnpiZDk5Sm0zUFBiVWcrL0pKTml1YittNlpkcXVySjB6aG5SWmEzSkNBSFVlWHk5eGJVL2RLQ2NMWmRsQzZCWGZSVnl2bUpoQXdyYjJxVDJJWjZXcnlVMG5xcllucytadjNyeTErUFNYZzRKWlpuVStiL1hTeGVucDE5OTJRWXhKU2tkVmNtdk42SHUrK1pIdkdZL0tCNE1QYXJOY3RyZExpbUg5M0hZMWsvSDB0RzFDd1EvTGhNVmltVnFYdnFmdkIwb0pFTEZJcWRqTUVMMG5PRWZmYVlySERXSGdqaVd5NWVaV1JaYnRjdlBhblBtc0p2ZzZrUzdYeGc0RDFkMHJPQ3Zra2xDU2JNaGhWeXVJQ2xtUmdLZ01DRFlsZTZrcXhvQWFrR0g1cWhIT2lWQnBPaFdjU3dCdFZpWUdjZStVb2hCY05GdzlqS3kzeFRHbXdzMEhJendmSW5YZlVYZUxzWkh3K0VaV2p1eG8rak8zWmtlM1JDUWIzQi9ETitvSklpR2tMRHhWellIeWZSOTQvTWtzaysxK1ZXdm92UkJDc3ZmWGlEb0hBWXlVdEcyZ2JXWXNqMjZ6V0hTc1Z0QTFnYU9GMHZvN1NaOGFGTmZGb2VWS29PQmEyeDJUNUZWUnBHN2NMOSs0dGZqSk0yemRIdkRXbXJpN1ZlbkpyT1c1Rnc3T2Z2bUNua1lEMkdjZU9YZi9wZk5iM3lUWXdoakJvbFJWaGpYWk1CczVzcnhJN3VsdG43QUdIMGtOaXlERzBycWV0aDJzUmlOa05pY1VJY2xpQWVNVGFTcTUvYVJaQWlDejBIY1JZdzI3RjZka3BlSDQ5b3JGVVVNY05sVEpPV1VRbGNXVW9WamtCbE9zZlJxRmdCTE4wSGF0eVl3dVJUaWsrR3NaYkZSVGpXNE1XN0RNQ3NVa0k3TkNDSVBPSkFxdTk5dzhqaHpNUStMNER5ZFIwL20xNkFRRExMdUdYZ01UTEVhekRkZjdyZUg5L2NiZVlpMFc3VnB2bmdFMno4ejBrY2Z2ZnlKMjlUajZ1UmdUeUsxQmdnZUpyRzdmeEhVOTQ5M0xyQmFIckU3Mk9abDExTFhTRDZlRjZ3S3VqNFJCYUlRWXV0cXptbmNKTU5SNHVqOU1rUWRCWXVUMmZObi81SHpSM2VBT2xkMEJNVWJWV3dlL1ZTSXFna1JWSTBNMjRPTVA3ajJVR2JuWHV3N1ZTTVFnV0Z6d2VOOGpDRDRFK3Q0Uk5aSmxHZFltZVcxWmprQmJYRy94RVFxYitCODJMMURUSllKeFNFOWZOR25PRVJCckNIMUlXbldYVnJvQ2pLY2x4Z3JMNDRiVlNjSiswaTY2SWk4c0d0TlRQZ3BFSy9SQU1iUlNtRUh2SGd6ZXAvZlJEMGg3REpFaVJFWUtvNkJNWEtRUGthMVJRWjdKc09UUXdhMEZtazU1ZmQvVHVVaVdEWUl0a2lWcWlCSFJ4Q3BldFRVU1liSXhvY2p5dnEvWGJoSDZqY25GK28vK3loOUd5VGs4V0dDTW5BcUtQdlRocHk1ZDJOdDhkRktJd1FxdWQ2Z0sxZ3I3THh6ejJaOTRqV0E5OXo3bG1ON1RVVGN0eStPSWp5Ulh3YUNvajBoSWovWVlRYXpTdDU1dTFXRlBJOUFHelVRU1JiaTI5Ly9iNjlkbnY4d2RUYmtEUWxsa09wM2tITSs2VTdPRXN3Y0lxRkd3SXJhNmNzL3VJNW1WVFIrU3NqWnFSRldJb1Z1dmt3amVEN1FRUTFFVVpEWlJna2t4STJrRDV4VTFRbEdVR0Nub213N2ZwVFcwOHhBQ2VKK0tSUWIwekllSXpTMVdrN0l5czRhTmFjVzR5cG1kTk15UGExeC9URGkzd2NiV2hLeklFSnVTb1hLVC9MWTBwbFpPVHFWZWdqZENIZ0xGc21janQrUXVrRFVwTGk2TGlsaGhQQ2tTeUM1Z01qQWhnWmRSbGVzbmdWVS9KQUVQbUZDSXcxbzVScXkxek9vVnpyY1V4dWhrTkpWbzVHYnR1dHNEYnZtTnljWGEzQnp4SC85SFA4blF3NjhMSkh2bmV4NStvRExobmt3VWNrc0lGajl2bWUrditOeFBYT1hsWitlSTdiajl5b0p6RDQ3WWVuU1VQR2piU09qakVLT1dJTzJ3Um8xZHdIZWUyS2RZTTFrL2hZZTMzdm40MmF2WFp6L2V0TzZRTXlwQmtoNUpaY0F2dnNLMTNtQ1p5YWdZYlU3R0QrZDVYdlF1REUvOExyVW13WlBuSTV6UDBuK1BhK2VTMUZxNXp1RmRURGdNa29pVzFpQW1JOHNLMUEvK1BFTTdJNE9WcVpMYXBQVHp0R2xLTkpOQTFLUkZ6OHFNdlhOVHFsSEJ5ZEdTbzVzeit0YXpzVE9sR2llVHVXQWhHSENrQjFHYUw0UmdoSHpsbUZ5ZGNTN1BHSTh6UkJVZk5Wa0taU2tVb1Nnc01TUWxZVlN3VlpJb0x1ZUJXM08zM28wUDJ2ZjA0QktUWE93YjEzUFV6RkJWUm1VbHVhMTAyYmUvY2RqTTlvZnQxWnB5OG8xVklDKytjSXZwdEJSVlJQVlVWbHMrL05ERkIzZjNwbHRpT2oxNW81WmJ2M0hFNnRveHI3Mjh6N1hyTTFRVXdSSmM1UHJuVHJqMThvTGR4ellZbnl2eGFVOUxOdlRTRWtGOXBGazVWdk1XNTMxS2RHSXdmMU1sd3VHdHc5WGZ1TG0vZkg0b2pGUEVYRVJpMDNyR28veE5YL3RmK2xNZjVTLysxWjg3SzZjMTR5b3ZnSW1xRUlKVGpTS3FHV0lzSVhRWVcyRk1taDI2dHFNb2k3UU9kWkcyVGQxRTIzaFVJMGlCeHBUeUpBU3FQQWR0V1N0Ums4NWpjR1pNM3dQRGFKRThlNUhUNVhVNnhaVEp0R1N5VWJLWU5Sd2RMS2dYRGJ2bk41bHNqVEdrRThDSUVKd2tQa0NNRkFjTjQvMFZtOGFRMmRRdW1qemxxL2hvcU51V012T1VSVWFSbWZSMUlBUThTczZObzU3Wk10QW5KNWlrdERmRDF5ZVE1NWJEWms3dEdzYkdzam5hSkNLM0ZxNzU1VDc0bWpkSHVIM2o0Q0JaYnZpN2YvZlR2UExTNFpxRGxnSFoxbFkxMlR1Ly9YQVd5L0xhSjI1eTdkUDdoSk1WK3djenZ2VHlDV0ljRzVQVU5tbFU4cEhGTlo1Ym56bGllbmxDZnMrWUlFTGZ4L1JobWFRem4rMnZPTnhmb0Vhb1RPSTh1UmdWSVN6cS9xZXYzWnoveXBzd2orUmV5NmpLV2RVOWg4Zk5tNy8rekhCK1o4TEJTYjArUmN6bGk5dFZWV1NqUkZreHhOQmpyQkJqUUVQQSt5YTVHL3BBQ0dIUW5FUzhjNGw2YmpLQ0twbk5pQVFVOEFHYXBrWkg0QjNrVlJwK293NEtRU3ZZM0JEYmdPOERyZzkwblUvNithakV0ZFBuOEJUS004dUZpNXRzYkZVYzdTK1ozVmhRTHp1MnprMHhPeE9NR0hwcktIMWt0TCtpdkxXaXlBMjFWZllQT3haOW9FOWVRV2lNSEM5V2JJOEszdnZZWmNiakNTcjVNSmozckRySDY3Y2Jtc2FqTWl4RFl0cGFCVFNaMWFFczJpV3FrWEV4SXMrcldIdjN5UnZMa3kveEZiTFcvLytxUVA3di82OC9SVllLdi9IeEYvaWYvNGRmWWJsc1QvK2ZLcno4MG9HNFB0akJEQzRIaXZkL3kwTVhkL09OaDIvOC9BSFhmdU8ycXUra2ExZnNuOHdRRXhpVmFkMFVZaUIweWloUEVXVmQ1em01V2xQT2V2SnpJK0pHampGQzMwV1dpNTZUa3hyblBDYkxCczRWR2pWSzUvVzU2N2VXLzFQVCtzT0JqTmdDVGlHbVIvbFh2ajcxcFJ1bnZycnJBdG5lcU1iVHljYlltT0Z6bGJWbGlJQUVuS3NwaThrQVRxYVdvMWsxR0pza0pNWllqQzNTeitNS0h4VFZER01VVjJjc1pzcG1scXg1ZE5qK3VFankyd1djVnpxWE9FNitkMGtrTmJqR204RkZNUTZ0Mk1ha1pEb3VtWFVuTEE0N1RwYkhkTXVXN2ZPYlhDb3k4cE9hNDVzTDVtMVAwenRhNTRsNG9xWnRWbVlNNDZxa2RZR1RwbUgwZXM3ZTVwaU42WVFzbjVCcHhodTNUemhaOXFCcENSRUdRVXJmQld4bTBCZzQ2WllzKzVZTVE1V1BRT3p4d2kxL2NkRTMrOXp4Rll1L3B3dmtML3psSCtiVzlXUCsxLy9wVjdoOTZ5UVIrSDdmdS9tRm4vMnM3Ty9QdUgzakdPZkNPc3RjQUlLUEVrTmN4eGRVd3lxOXVuLzczaXU4MGwwNWV2MkFqYkhJOFdITDlWdkgrT2paSEJ2NkdHajdtQnFJR0dsOFpEUXVjQ29FOWNqYzBTMDh4YmtSMmJtU2VlTTRPVzVvdTNYWXBoSmRNamdMcWpjUFQ1cS90bis0ZXBFN0RpVU9pSmsxNmtQa3kydzM3MnplbXA2NmRYS1dTRGNxVERtcWloRWEwT2pGMkNLWktzVEJDbXNJM0FuUmdFYUtMR2ZSTmVBVlZUT2s0RnBrYUx2VERXNW8rMEJWamVubURjMTBvTXdNZzRjT3F6UmpVNzZnYzRHdTYvRnRuM2hWSnExVXhWcU1VV3hJNjlzUUZXTU4wNGxoMHdsTktLZ1BITTN4UGw5YWRqUkxSOU1GTWh1b3FoVEZZSTJrYmVLZzlmTStrdWVHWmUrNGRyS2s5NUZGMDRPY1VOaWMvWk9lM2tWQ1NMSmdNVUx3Y2NCQUxLM3Z1ZDJjb0JvWjJaSWlHNmtuUHJ2ZnpqODlGTWR2Q2Q3NVBWa2dHNXNqMnFZbkwwN1ordkp6UC8xcEVXUFFxS0txNXRUYjdMZmE0R1FENzJaamQyZG4rNG5OUno0UWIvVzdsWTBzNm9ickIwZDRBdFpFZ2lUbWFXNlVwR2xLam9GSzhvWEtNa0dqSWJoSWZYMUZ0dWhwQzVpZDFBa3RIcDY2UGtiRUdyZHEvZDk1NmVySno0YW9xek9ZUnpDRHA5WHVWc1hSclAySzMzUHhabHNhQVNnS20rZFpWa1J2MTg1cmcxMm9BaGt4OU1UWUVSVm1zd1dqeVFaWmx1RjlSSW5rUlVGZWpQRitoY2txZ3Urd1VlbGRSS1NqOFVLeHE3aVFUZ3NHYWF5c3RlU3FCQi9vbXo1RlY3c0FBbm1lWWJQa3NoaWpSYU5TUk1Wa0JpTks3SHRLYTVtVUJRdVhjVzNscUZ2RnhwUks1SHVER1JKNjgwbFNiV1lJNHp5WlF5ekZNMjhkRjdZRUZ5TVc0WEMxd01lQTBZeGtmeFhKaDBIZWhZaWdIUFl6MnRnekZzdldhSU9pS0E5dnRQTy9lZEtzcnA4cGtQQjcrZ1FaajB2KzdYL3R2K0FqMy9WMm1jOXFzZFpJakNyZVJ5dWlCc0dRQm5DYmJQK3htdlE3YTIrb1hGVW54dGp4RDMzYmg3L2prYTNOajNXcmxiaDJ4U3ZYYnpHckY1U0ZnQ1FNeE5xMG1qV0RVMGMwU3RjSHJCM3NiRFRGczRXbzZMSm53eHFXUHJFTWxmVGtWRU4wTG43eTZzM0ZUL2dRNTJlM1ZpTEU4M3Rqbll3TGJoOHVmOXZ2dTIyN1UwdWdPLy9OeDk2SFVPWWxFWU5WaTVJUXMwUU1OQVBqMXJKc09wcW1UMXVtek9COGVpSVhaVW5icnNpeW5OYTVCT3hoQ2RGalk4YnlhTVY0dThSNzZEMTRyeml2T0ovU3J1SWRhOVJFYStFTzRvMDFpS1k4RktjUkc5T2FWelNTaFlCeGtYUGpFUmNmUGNmdFdjMXJ0NDVZTkpIZVdTWTJrcGxJVTN2S1NyQkZ3YlNzbUU3R2JHLzByTnFlb3Nnb2NrdU9vZk9lOFFqS0xOS0lIVnhUQnRaQ2dHV29XWVFtRlpxcHRMSWpiZFQveW8zNjVKTkRhRS9IVjRodCt6MVRJSk5wbFd3OUJiTE15cy8vekdkbGJTNDlBSDQ1a0tIa29KbHFLb3oxV3RRWXlVZWpZcFFWK2RqaHEvYy85dFJqNzduL3lyK2MrYkMzZjNMRXJ6LzdPY1o1eWFnMDlIMGNOak5wVGRoSEtEVHBOL3JXVUJUSkVmM1VvTmtJZVc1eGZZQVlPQ2NaVm9RajlVU2lCcFhYM3RoZi9uZjdSL1hydzFQcTlNTlFSYmMzSzkzZXJIajU2dkZ2Ky8wSE5iL0ZVYUJ1bmV0NzEwOUhZNUJTZStjbHN3RlZtM0J5a3lJTkZFZGRlMDVtQzdhMnR0SkpnQ0dxVWhRRllrcFVIU0VPQnRNWTJycWhMTVlzYmlnVW51QWh1UFIrQkRlRWtmWWU1OUo2VjRjb0Q5VmtLdWRWaDQ5akVFcDVnK2w5NGxlTk1tZ2RPZURiRHBON3psVlFucXM0WG5hREFYYWFHL3ZCT1Y1VldkUU4zaGgySnlQdTM5bW1DVDA5QVN2Q3FNaForSlp4R1ZnMmlXb1NWTW56aktBOTgzNEZLSVhKbU9aalFjekpRYnY0ZTQzclQ3amphL3g3czBBMnQwYk1adzFWVmRCMmJrMEZzREhHZkwycUJjbzFNM2Z2M05iNHlvTjcyL2ZkdjN2K3dxWHRTK2N1VE05ZGVXanY0dm1Ma3d2TUZ0UG14YU15TGkvZk4ybXpCNGdkcjExL2pYLzRoUyt4UFo3eTlQM24yZGtZcGExUVRNZno2WWNmTGVQS1FnYkxsV044NnRFM1dGSkpKTVpFb2RnbU1Wa1BvTDV4MHZ6RTFSdnpMdzF2L3VtZWZXMTNHenpVcTkvWmZkemE0b3d0NktsK05haUtOMkxaMnRqbThHZ2Z3UTZob1NFeGFjV2lhckMyNFhoMnlHUTZCWTNrdVIyQU15RXZTcHBtanNaQTV6MGlGdWNkSWgybEdUTy9WWk50R2x5ZnBNVmQ3K242TUVUTHhRRVhrYUdsWERzMEJ2Q0R5RHRLd29GOFNQU1dMQjN6NDhIUnBHNTdOQ3BsWnJpd1dkRjd6NnJyeUxLSzNybFRFNzB1QkdnYkRyM0RoTWpteG5nQWRHRmM1U3hXTGVOS3FjcUliNFRjR0l4Ulpyb2txR2VFWVNzZmExVlcwb24veEZHMyt2eHdlclM4T1kzcTl4WlF1SngxYVREdWc4U2dSbEdEbnJvR2pvRHFiZTk4Y09kREgzM203UmN2YmwxNTZMRUxqMSsrYitmSnplM3lmRldaaWRpWXhhYlBWcDk1M1hiUDdadW12aVFyTjhhM2g3eDAvU1dlZmVrNXlnd09Wd3QrNWJtR1J5NXQ4Y2lsWGRDTTNFQ1dDWmtJTVZleUFvck1rcHVrTnBRVUNwZ2t0UXJXSmdPRXZ2ZTZqU1gwZXZ6cUlyN0dIYVhhcWYybEttS015QnMzNTlvNngyWTVZZDU5WlFmeW8va1NFVGxyVGFPa0lCcUpDcVBSU0xhMmRsa3NqdFplSThRb3c3b3pZc1RTMU1jczUxdE1ON1lUU0JoMWtHVmtpT1FZYTRuT285RkRoTVZ5UlZsT2FEdVBRWEFCbXBXbnJaT3ZjSXdER1RGTHN3YXFwMklvVk5HUW9yQVpNQWhWQnUxOXBQVVJDWkZ4bnJaODNnVXlhNUt1M1JoR1JZRUxnWEZaNEgzQWE4UUZqd21HUmVjNFdQUThZNFR4eG9RUUhWbG15SzJsRmNlNGluUStRNk93YUd0bXJxWkEyTXBMS3Ftazk3by9rL2FubDY0OTRjMUpWRy9Tby8rZUtKQ05uVEg5eXVGY2tCRGlhVjRIZ3c3YkdKbjgyLy9uUC9STjMvekJKLy9BdzQ5ZC9KWnFaRFlVSjBTMVBuUkVpYlRYRml4KzZZWjJ6NStnMDh1RWJFZmIrZXZ5L0l1ZjRkWDlRNVkrNldPcVhHbWQ0M05YanpoZXRUeHlZWWR6R3hPeTNMSmNLYXRXcWJ4amM2b0pDOUJrZ0xacWtvTkpXVm9HaDNKc1ppVDZ5TG5jM1B2TmwzZC85UHk0eWo1NWJmL25JYTV0UUZPQWMxVHZmWXlsTGZUOFpQTzNMWkFzeTRoM3pQOFUwTHJ0dXhDMFU0MzRFSFE4bm9yM2dicGVnUVFRaDBhWDJoNU5nTm5oOFRGNU1jRm1hWU1SQnZGUW5vL3ArMlNnMGp0SERJRzI3MW5VanJJYzAva2VIVVBmcDdranBkMG1UZm9hWmc4K3JWWmxiVEVWVTVISUFDekdlSWQ0dUZSTDlFSFArU0NUSWtPc3dROG5UKzg4MWlRamJHTU5oVUFXa3dSWEJXWjF6L0dxNDlMT2lFM2crcUxqM3IyU3pZRUxsbWVlWlJ1cDI4aXlyOGtWY21QWW1XNFRlcU5ML0NldXR5ZWZWVlYvQnZmNGlpdjJmNjRMSkJ2SU5qNnVWN1NueFRFQ3BxTlJzZm1YL3NNLytsMGYrNzUzLzZ0YjIrT0huWXNFNzRjUHFGY1JnN3ZheXZ4bkQzQTNSZUxvZm9JdE9McDlpK09UQTZJcHNEWkhReURQMDNyVERwM3pHd2MxSjR1T1J5OXRjOC9PRnIzTEJsS2NzR284a3lFTG8yNDZWazB5ZlRNQ1paSGpOZEwzRUx5UzVaanRuS2ZmZW43eTV3cGpxazljTy9pN0xyclRETDZVZ3huSWpQMXQ3UytIelNxcnVqdlZJZ0Y2Y0x4b2V1ZHFBWUp6bU1KU1ZTUGFycVB2L09CRW1pZ3JJU1NZWmJFOFpqclpaRzl2TCtXWWlJQkU4anduVWhCSnczdmlYd2wxNitsZFQxNEliZDlCSWFlUjBPdkpROWV5NFdFNmo4TXlRUm1NR2ZSTmdrTUFGU0tORVk0MFJFTHcwenpQZllqa1JTRVdhTnMreVlJbFVlVW5WWW0xQmpYUUI5Z2NaMVJGUm1tVTQyVk5uc09WN1JHYjB4SGowbk4wc3VUV3ZLZFhoeFZobW8rSnpsRGtoWjRmYmM1ZjJqOW9lWE5jeEZjMGp2dm4wdFZrZDJ0SzAvVllLN2d1U0l5L3BUZzJxbEd4K1gvNkQzNzRZOS8vQSsvL2MrT3hlYkRyT3hCRGJqTXhSaVdZS04zcnJTeit3U0ZhRnpnN29RL0tyUnRYdVhielJlcnVCTmM3dGplbUdHTlRVQ2JKSVJ3aVJaWm9JZnVMbWxuZHNUMHAyQnhuWUpOR0ljOGl6bm1hTHVBODVGbjY2TnMrSWhtVU9aU0ZXWHRIYVo3SjV0NjRmR3BhbHZXMVJmTlNUQ3VwOVR5aVVWVTc3M0R4Szg4aTEyK2ZyQXZsMUVVeGhERDZ3TnNmZVAvMnh2anh0bHNoSnRsQ2wyV09kNDYyYTVKb0tZWVV4Z09JUkpyZU1aNXNJY1lPUEtxVURCVlY2SHBQM1hxYU5oS0NKVVpoVVhkSWhBeURJd21nZWpkc3JsekFlWTkzZnRDT0JFSVFRcEJCTlpnV0dzcHBFSThhQTlZUVFRK1dYdi9ldkk0L2EwTGNzWVM5Q0dSNUpyYXdDZTJYWkpVNkhWVk1xcExGcXVla2RkeTdOK1g4eHBnZ1VGaWhHQXl3RjNYUDdYbkxyRzQ0cVZzQ1NtRUtka1liaEFCWnpDU3oyZkdTN3VPcnZqMCtTeEw5NTc1QS91UVBmaXRGbnZIQ2E3ZVlUa1o0SHlXY0tRNFJ4c0RHZEdPMCtlLysrei8wKy83QUQzN2d6K1dGdnh4RHdJZ1JwUmZuVmpTSEM5b2pSLy9wQnFrem5CUTBUY3VOTjE3a2pSc3Y0ZHdTN3p4TjIxTVlPTCszdzRWejU0alI0NEtqZDRsMlVWV0dvRENySFkxcjJaaGs3RzVXakhMQjlaRjVIWWdEK0oxblFwRUx2U2E2U1c3WDlHb3dSa1JRclFxWmJoYkZXNmZGcEgxanNYbythdlIzaWtTMWovNGZKMGR2amVlVXpzZnNIWS9mKy9ERnZlbTdGS3lxa1N4WjJwRFpITytUSGRHYVNLaWFES2U3M3JGYTlrekdHd2tGOXhIbkl5RUVOQnE2dm1mVkR0dWs0UVNhTHp1SUZoTUVMd0VYVXpRMUllS2RKL1JEa1FRaEdjVU1xVHlEU0YxU1VXQ05oS2o2V3R2SG56aForZi9tY09GLzlxZ05uMis5UGw5WU96WG9oZDY3QWhMdVpFM1NlaHd1V3JDRzh4c1R6bTlWNU1aUVp1YVVFbStOWUkwWkl1OEN5NmJHbUlCRXk5aHVVT1FsTXV5b29tcDAwZi9xc1Z2ZFBDTXg4UDljRjhqTzVvanYvdGEzOHNiTkU2N2ZPaUdFS0Q3RTlRcTNKQ1U5YlZTall2UGYrNy84MFBmKy9oLzRwajlyN1BKZUY1YXFCbEVOZEc2SmN3MXU1Wm4vZW9zOUVacFdXYzBYdlB6UzUzajk1aXYwdmgwSWRUb2tKMEhuT2pZM3h1eHU3N0pjMVRqdndhUU5WZ2lwZFdxaVozOWVVK2FXclhGSkRDUTcwamhRd0FjSEQxQ3FVVTVWNVlseU1lQWxHbFNLb21Kak9obHRsL2t6cGRqWjlXWHpwYUR4YkRyVTcxZ2cxZ2lEZStmYXdUM2JtcFFYSHJ4Mzd3UGpNcXVjRHlKRXZHdFJoYW9hRWRYUzl0M3dCSWNZazl2SVlyVWl4SXlpck9oN1IrOFYxd2RDVEl6WHJrdTJxS0REVGVxWXIxcUNBeHZOOFA0RW1xYWpienBDNzRtQjA0RThxUW5CV0IxOHMwQ0V0dXYxcC9aUCt2LzBjT0YvdXU3aUsxRlpBRzBkOWNaeEh6L1Y5dkc2aWVIZXFyQjcwN0pLZXpoUnV0NnhiSHNtcFdWM09tTFpkQ21HT2t1T0oyVnV5WWRja3AzSmlDckxrbkt5S3luekNUNEU2Q0k5UVVkWlVSbkRsMjcwOHkrZW9aZDh4VG5rbjNtQmZPUzlUN0N6T1dheGFubnA2cjVjdjNVaXk3b3ozZ2M3ZUJXVklqSUdObmIzTm5mLzRsLys0WC94dTc3MzNUOVdWbHlPWWFraVFXTHM4VzVGREk1aVBJSlpTZmRGanhHTDg1NnJyMzZPRjE1NURoZlNrN0xwQnQrbFBIMzdSWmxoczV6TVpsemMyVU4xMEU5STJnS2hTUVFWZ2YyVGhtWGJVMXFERVpNMEljUGI2bjJTZTVZalF6V3FNTWJnbk1mYWpHUVVYZEY1cjIxYmp6TE1neUhrejk1dVZxK2tSdVFyUDhIT1hsV1JFVUlVU2NyVUhNaW5wYmx5Y1cvelF6dGIxVlI5bTh4MGpFVXhoQWg1WHBIbEZiMExOSjFMOUc4VlZDT0hKMHZ5YklReEZ1ZlNTWkptbFhRQ2RLNm42MzBDS0dORTFiT3NHOXJhSTMzYTdEblgwZFIxeWdSUmMrclVhQXpZb1IwMVlsQnZsbjJmL2EzOWsvNi9XSFQrUlZYV0lhU25mTFNnMml5aVB1OVZYcGtXZG1kVTJIdHlhN1BPQjJaMWoxakQ1cVJrbW1lb3NSdzNMZE54aVpXRTZhUUZRYUs2aktxY0cvdWV1c25US3Judk1ZQ1RTR21MUEtxK2Z0TXZ2aHdrL09mbkJIbnduaDMrbTcvOHIvQkx2L0VTYmV2bDJ2NkpIQnd2WkxIcXJLcG1Pb1MvaURCUlpYTm5iMlA3My83M2Z1QVBmdWYzdlBOUGo2YmxKUTByUXF6RjlTdWk3d2pPSlJ2K1lHaytIOUVUd2VTR0c2Kzl3SmVlK3dKMTUwOFpxZXRjQ2ttc09uYTJkMmphbmxzSCs1UldtSTdLcEljV1F5UW1ocW9JTmt0K1dMZFBlbzZXTGFLUlVaNVJqVEx5d2xJV2hpTFB5WXRrcTVQYmtzbDRteXpQUUFJSFJ5dHVIeTFsMVhwV0hkMnNEYjkwdTEwOU41d2cvOGdDeVRQQkJSMDA2YWxJem0xWHU5UFNmbkJjMmQxUmFRakJnQXpLdlpoRVRWbFdZbTFPMnptV1RVUG5VdHl6Y3oyM0QrY1UyWWpNWnZnd3NINkRHK0FkUys5NlZrMUQyNmRNazZpUnR1MllIVGQwcTRBTkZsRnplaG9iU2RvTEpBbWk4QlpmWnlmTE92NzFnMlgzMTJyWFh4dUtZc0VkRmVWWkhoUk4xRnZMUGp5Ykc4bmEzajh3cS90eU9pNTQrT0kyOTEzWVRLSXpMRlZWcElKZWI4ZzBVZC96M05JNno5WHJIbzBaYmV6eE1aQmphVkVDS3BYSjZrWHNmclZUTnp2VFlvVi81Z1h5bC82TlA4eDgyZkRGbDI4d0dSVjg2ZVZiOHNMVlcrdFpJeHN5eVV0Z0RFeUI2VnVldk8vU3YvTVgvdkFmL3M3dmZzZWZzRVcycXppQ1h4QjhNMlJxQ0VGTkV2L01GZitLSlRNRlI3ZXY4ZkZmL2tVTzVzdTB6dFRrNnBIMjdjbEx0c2d6c2d6cVZRTktjbVJ2T25KcnFQS00za1g2RUFpYVFMRzE0ZG1palJ5dU9qS3JYTmliVUJYSjdNeVk5Q0dOcWlrMnkybTdqdUI3Vm5YRHliekJSOVhHbTNoOTduNzZ4Zm54LytRMExIbXpGOU52ZS9sd0dqOTRPcWd2YXFlUFg5bDYzL0dzZVhCelVpUitHTU1Kb2hGVml3K3BXSEtiWVcxQjAwWGFMdUVPemp1TzV3MUZYbUZzTXNhTGc4K3VTQ0kwdXBDTXJqdVg1Z3czcFBNdVRsb1c4dzdmS2paa1pPUXA2NzBYUW1zSWpTVjA5bVRsd24rNVg5Yy8za2Qzd0oyTXhSYm81YzdEWWIydzhJQjJrZnF3RGMvMVBpd3ZUY3NuSGppL09icXdOVUZVTU1Xd1hQQ0I0MVZESHdKVm1TZENZNHdVbWVYd3BPUGFnU01RNktNbndhSUdpNUZXSXB0WmxUZmEvOElpdGplL0VzMzluMDJCQ1B6dzkzK0lsMTY3eWEzOVkvblN5emZsNXVGY1FvaDJYUmlTOEkzcFVDRGIzL2JoWng3K1AvekZQL0tqSC96V1ovNUlYcGFiRVlmdlo3ajJtQkFrZVZVRmg0YVVBeHl1WjhoK2dlc2JQdk5ySCtlTjJ3ZTB2YWZ0M09rS00vaVFFbG1SUVd1ZFVHRVVnaXE5ajZmMGtZMXhSV2JzS1hYYWVhWHUwb1pHRUE1V2pxYnRxVEpEVlJXTXFnbkdGSFI5ejdKZXNGd3VUblhvdmZPNGlCd3M0NHZQSFIvL0o4dlF2Y29kazdoLzVBeVNWdDltc0V0Tko0Z1BzWGpiUStmZVZSWDJ5Wk5sTDFzYk9XVnVpV29ReVpQUUthUlp5WGt3SnFNb3F2UjlOQkZqSUlTZW81TVZSVkdSRDI0b1BnVDhrRjBpbUVIdmtiUWY5Y3JSTllIZzEybThTdHQ1bXNZbGpYNm5FSVNxekxVbC9LMmI5ZUovREJwUGdObVo0dkFnTVJ1QWY3bmppYnQrbWFERUlzOFc3NzY4ODRHTEc2TnplV1p3UWNuTGJKRG9DbEdnekd6S0tBeXBUYlJXdUgzVXhkNlZEZEZuVGZCaUI0dUlTakphZFJSNVVSZ2puejhLcXk4TXhmRVZIMUpmVXh6a3V6NzROdWFyaGs5LzRWVzZaTFBEai8va3grVTN2L2lxdEowZnhHaDZtcWNuSWlOVkxUTnJwdC85d2JlKzdacy84dFNIM3ZmUmQ3L3J5bU9YbnU1OVA0cSt3ZnM1b1p2aitnYWtTT1pydmt0OWJoRENBZVFxM0Q0NDVBdXZYR1Z0RUp2bEtZRFNKZW81NGp5NXRkU0RXM3FlV1lJbTJvVE4wdFlsYUNxVXkrYzJHVlVGUjNYTDhXSUpzYWRwMXl3VDRiWERobm5qZU9xK3lJV3QxTmE0NkNoenkzaFUwdFFPTjdpa0xGby92N2FzLzlvOGRDOE9IMGcvekNCYWtOSHhPMU5PTHAzYjFPdjdzN1FpVm8wS2RlM3Q1KzdiM3ZqdWc2UDV4ck12SE1yamoxbzJOM0o2NXdsUkNDR2tCME1NK0JBSkhxYWpFU0tHK2JMR1dNRTFEYTljdmNxNTdWMDJwdVBURzM4OWw0aWFaQlhtVSs5bUphWGY2RnJPaWtuS1N4SHl6RklVVnJkMkszd2RWM0VlYSs2RUFQV0F5NnlKb3lKajBmUnE1RFJkTjRSMWdtaHF2MnhtVEwwekhiVmxtYWV0MmVDcmhSR3FjWEp5Ny90QWNBRU5TakJvMTNzNVdMbm5ZbG05TUkzRjl5eGNuNGZCNWR1aWpEQzY4SzNkbW13OFVickNOTDU3RTB2NmExb2c3MzNxTWw5OFpaL1ZJT2xVMVR0L3FTSS84MHVmTlNLSXFsb2Rub0pEYU0wWUtOLyt4SlhMSDNuL0U5L3oxdmMvOVB2ZitlRjNQSHpoMGhYVDlBdFZWblRkTVJJYmZML0N1emt4V3NRcDNqdE1OVVk3R01WTlhOTndjUE02TCsrZkVIemtua2xCVlJhb2F0SXlxdzVQeHlHd2RsRGFSUWJkc3dnNjVQU2w5RmZZbVZaTUp5VzVFYUtmWWFXbjh3SWh0VlhMM3ZINWF3ZmNzMXh4Nzk0bWs2cWtMTE5oa085b09zK3ExM2hyNlg3MlJyUDhCNW9jL0U3VmhBYWpFL0ovWklGWWF6RWk2bFdqaUhoVSsvMjVlL203SG54d09aNGNicjcwNm5WKzg5bWJQUEdvWVh0ckF4bGFKaCtTQnQxN242eDdncVd3c0x0WjBYdkJTTTU4c2VLMTY5Y284ekhuZDdmSk1rdnZIRzNUc1ZvMXJCWWRYZTNSa0hRazJNZ2RJOFZrSVpSWndWakxhSnBqY3lIUDdEakxiSFErblBiNTFob3RjNnM3RzZPazV3QW0xbXFielBUQzhFVHZCTXJEcHIveHhyejUrRFBqN0NsVjhpR1RtcUpJckdRaTNEeHVlTzMyVWg4K1A5VnBrY3Z6TjVjdnZiQmMvbmNYSjRVNVY0MC9XalIxM3BFY1h4eVJDWmtlK0U0YWwwOE1FbjdIRS91clhTRGJHeFZGbnJGc2VuN3AxNStUdEs0TnhocGpvcW9oR1o1WlRYRmh1U2FTWWJVeHFTWS8rRDBmZU04NzMvcmdqMXgrNnNJN0gzblhnNVBKNWg1MVg5T0hsWVN3Z2xnVFhFc01IYW9kd1FkaTN5T3hwSGNLcldKbkM3NzB1ZWY1K0c5K21oQjdiaTRjczlieDJCNk1SMFZxZEFmckY5RjFVbExLbjdDNXBRK0IwdVNKTWpJa0ppbmdlMCtXVzg1dGpPbnFEcU5LNWlOMUYvQXhIZDlkQ0x4eVdOT3A4dkRGYllyYzRJTlBCUmlWbzJWNDl0cXkvaHVkK29NekE2b0g0a2dzQXpEOU8xNjV6WWhSTllXWjRRQzlmdnY0bXZPOGNmblM1WHVtNHcydTN6cVE1MSs2eWU3dWludk9ieWJTNGhDUW1jeWswMFlxREdJbWF5TFR5aklxcG95cmdzUGpKYTllZllQeGVJcTEwTllkcTJWRHUrcHdYVExkTmhZczl2U1phMFF3Wm1BY0c4WGFGQVVoU202TlVaZnNLbFJFdE1welhiVWR1OU1oZ0dkb2JRR21SY2FxOTFHSEl2RlJWOC9lbXYvTWxjM3F1OGRWL25Dd2tycmJRZkJqckdpWkc1NjdQZS9lbUxjL2QyRmFYbjMxc1BuTkUrZWUyeUxlRTZ4NUtiZjI3VjF3R2tFQ1VRdGJtRTNKWHovb1poOXZRKy9Pc0hpL05sdXN2ZTBLSStCOHBDd3kyVCtwSlVTMTNnY1ROV1l4YW9GcWlVaUZ5RmdUR2o0R0pxTXkzLzYyOTc3bHlULytMMzM0ajN6Z1hZLy82UFpETzA4Ly9MNkhpMnE4aGNhQWp3MjlYeERja2hoYVhOZlI5OGZFMEtEUkU3cUFHZ3RHYUs0MmZPYnZQOCt2ZmU0TEhDeFhpQ2pSdzFHanpIMmt5aE92SjhTMG9VcThIVHVFVXNvd293VHl6QkpqY2lneFdYSUNEQzYxRDZNcVkxd1U1RmsyMk9iRXBBRTNTVHlscXN4V250WTVwcU1NSzBhYjNzdkJVbWV2SGZkLy9WcTMrSGs0WFhIMmdNOHdtb3RWaTZINVI1d2dPNXNUVHBiMStuUzJJcEl2NnRiZmUyRnI0NkY3ejc4L3l6SjdZVzlYTnJjMnVIVlkwN3RJbmlWMmI0d2VZKzJwQlpFUlFkVWxnemxOODhTNHNHeHRsSlNGc21wVzNMZzFvMTUwdUM0TjZFazBsVEFWWTgzUVpDYnZLVlhTNHFPMGcwdzVndUhXck81K3NmZGhBYlFpdU16YStNU1ZpN3h3L1k0aG5odld0THVqWEJxWGd0MEc4NVRzcFBYekN4dFZ2RzkzL1A0OE01bk5qUlNaWFh0MWRXM3ZsNi9mYm43aDVVWHovN3k2YUg1aDRmMXJRTHZ5L1ZHbFdjd0Q3K3FpcndTSkJqRzUySVVUL3RxMXNQZ2ZuWWJteTlEMHIxNkJmUEJ0OTdJMUxmQXhKbmR1RitWdzFvaFAwVis1cXVhcVZKS0tZandRREN0Zys4cWxuVXNmZWQvalQzLy9oOS8yQTkvOXJlLzhZMjkvK3RFUEw2TGJ1dmZ0RDhoMGEyc0ludThKb2ViLzE5NmJCZG1XWG5WK3YrLzc5bkQyT1hsT0RuZW91blZycmxLcE5FdUFTaE5JalFBWkE2SzdCWUhEM1hid1FIc0syMkdISGUwSFAzWDQxUSttMncxMFJKdHVFQUhZWmhiZDRBNDBnV2lFSnRCY2sycTZZK2JOOFV4NytLYmxoMitmdkZrWGxWU2FHbFZGcm9nVGVXOUc1cjJaZTUrMTE3ZlcrZy9CemZHK3c3WDdkTzBCdHBrVHhDYWxQcThRRlZrOFUvUGwzN25NWTA5Y29YWWVwUlZ0YThrMEdJa3NPMkduOGVRYUpvT2NNak5rV21PVUlzc3p0RW5ndUxJb1FJTmJlZTcxc2pKWjNpZFJUT2ZsVVZsUUdJTUxBWlNRRjJtM0VFSmFpaldkNTdCdU1VcFVaN1Y3ZHQvKzFyUEwyVzhHNGtGZlBaS1NDVW8yR0xCR1NWU1IrdXNreU9Gc3lZTjMzYWFPRnJYcUNSZ21Sc2tIUmNHckg3anpCNHpPSnRZRkJvT1MyODZkSWM4SHRKM1FkQW0wbUp1aS81M1NwRXV0MUI2ajRIenkrMmlhanJxMnRLM0Z0bzdsb3FOcExjN0g1T3ZSSDAyVG5GRHEyMEtNaUFTeVBDV05qNkswVmtwcHVsblQvVW5ud2dIUUtZWEx0SXAzbnh0elpXLzJOMkVDU3RINjUvblhLQUdsbGRxL3VGRzl1c2pOK1ZubkwzYytQTHQzMUQ3KzVXdXpmL2ZZenZ6M3I4emIzMnBqdU5vZlcydWdpVEhhbWU4dXI1SEhnQndHZUVwZ3A4SC94aFdaLzNZZDNSSFAxMEwrOXBoNC92Yy85VVkrODlnT3I3cHZrNy84NGphN2g2MktFY1dLd0hTejZTNkJnWWprYThOcTdYdGVjOSs5cjMzd3dnTVAzSFhtNGMzSjhDRURkMjV1cnQ5OTl0eFpNMXUwa3Ardm1KemJTRTBZSHNLUzZCdUM3ZWpxQTdwMkIrKzY5QlRyTjc1U2Fwb3JsaS84N2hXZWZteVhyRFNNVEVGdEhXdkRpcVpwY1psSEt6aHNJMC91TjdSZWVHQnJTQ25RZEpIUlNqNUdhYnozNlVwbGZmSmsrdmhPUlJmVHNzMGwvcmJKRFJlMkpreGF5N3l6ekUzSG9YZjB0b1hzSFBtRGFUMjlVcG5CcGVjVzd0Y3QvaG8zUmVJOEVBMUthcHhVNU94Sjg2S3UvOFh6Ry9Mc3RUMkpTT2lQSXU3SjUzYWVmdmJxL2ljZnV1ZjJ2eGVqUW1zVVJDWnJGVlZaY0RndGFkdTJwODZHWTUwb0tVcUNCSFFJeWFuWGU1Wk54MnpSc2x3NnVqYWVjS01Ga1pCa1BsVmZPL1JLZnpmMVI0aWlzNDY4TUQyQTB4aWw5QW5tVE1LTFBYRGhBaDkvN01yZitOM09qUW9HbVdhdmRoSVQycllEMUZmMkY1Y3VYcS8rK2FRcTd2N2l0ZG16ZTR0Mk91M2NQQ0NyTjdrL01ZMWEyVDFubmZqMlNUbjZCWVVhRkppUkFWbUkyMEdPaVd2ZExWeVFieTFCem0wTStXZi80OS9oeC8veEgvRCtQM3FjUEZQS3VhZ0ZWbEtlaFlKU29CS1J3WjBYemt4KzlKMXZldk1qcjduM1J6YkgrYXZYSjhPenpvVTE3M3dSSWd6WDFsQktjN0NjcXp2ZWNHOC83KytRMElEVXhPanBHa2M3M3dQdGlENXhEbEFLclNOMk4vTDR2OW5tOGxjTzhSS1JvS2lxZ2l3M1RCY05iWklnWkRUVUZBWE1ySEJwMmpFUGtRZlhTMGFaWWJuc0NBcktRWjZJL3IzRnNlbWxZeVFrVFNqdms2aENXM2RrdVdHWUQxaXJTaWJEQVd1ZHhlMGRraHVMRm1IdXpONHNxRi9kcWYyL2g4VmVnS3UzQ0RXRURDMEZ1U2dpVjVtOTZIdnduNzMzWFh6ODgwK0plSWs5YmRmdUhTM21UMTNlL3RoZHQyKytPeStLOVJpbHgxS2w5OHBrUEdLOHRrYmJPbzVtQzZ4dDBWclFPdlprcjJTYlZwWTV6aFhZS20zR1kwaVlZOWNkTzJFbGd4eTEyc2lvWXlKWFVsNTB2VW9LR0Ywd0dBdzdZK3FZZnUxMGNsSktNeGlkKytySDlTcW5NRnFXTGxKYnYzb0E0S0xFRDM3bHhrZjZaMVhXSjhDcUYvUHlOeUVqeHhZUkVlbEFURU5VSjFDNzdzU0M4QVhSdk45UWd0eStOZUtkYjM4ejcvbWZmbytkZzZXeTNpdnJqMFhZamdsTUFvTTdiOXZjK29sM2YrOGIzL3k2QjMvaTlxM1IyNHFjclhKUTZzNEd1czVLREJHZFpRd0dKVjNib2thSzhkWVE3MXU4V3hKY2c0Z2xTc0E1d2ZrT1RLU1pSWERDWUZPeHZPNTQ3QU03UFBXRlBUd1JUSnFMZHk3MGZZT25xa3FLUWNrS1B6Zm9MSHJxMko5YlB0YzZYbkdtNHV5b1RENTRtVWtFcUxCU1lGZEpmS3hIdk1hUXBqWTYwNmhNOTBRalRhWVVCWnF0UVFYanlNR3lRMXA5eVJJL0ZwRG5nRm0vSUd0TzNoU05Gb05pbnQ0REx6cit5Uy85UDRRWXBlY2dlUkU2a1BLemoxMzZxd3RudGo1OWRtUDlCOHV5MElOQmtUd3hFdWNZcGFBWUYyUlpSdE8waEJpcG13YnIwaEhNZTVOMGNJc2g0NUdtS25NbTQ0cnB0R1YydEtTdE83eGZiY3FQQjVONHYxSXdUSDFKbGhkVVZTVkZrYU9VY3BKQW1jZHZRSzBWajErKy9OV3B4UkdHdVVLQmFLMWlqTEt5TlF6OSszVmxUYkNpQzV4VVFneXAwQ2toVFVwWGk4ZVZIc0VxVnJ1V1lMU0pLd0pMQ09GYnF5QWI0NUlQZit3VDFKMVhuZldxRjBRdzNEU3dId0tEZDM3ZlF3LytnL2Yrd1B0ZTg4cDdmNkpaTExaaXRHcFFqWEErc0Z6VUtJa3FCby9KRFpuUjFONHpPak9rS0JSZFd4TjlpM01XRVl0RWg0OE5aQVpuQlQ5TGprMVdGSS85NFE2UC92VU9YcDNjaXFjRzBZZklvQ29wczR6T3A5MkhqUUZyUFJ0RFRXR0UzVnI0MG8yYWU4OEk5NTBkSjJaYnoyWFEvWEt3dFFIZE41K3BMZEZVZzRKQm1hRWtzbmMweDZEb09rY3hLTmdjcjdIc0l0cjRwVTNuN3ZwRXoySDdtN2d5UWtDK2lTUHVTa3hhYVNVU2o4ZWk5cWtyTjNZKytQSFAvc0Y5dDIrOWRySTJ2bTI4bHFyR29Dd3dXYzdhWUVDV0p4Q2ZDR1Nab2NnTDJqWmdiY2VOdlJuV0xxa0dHVTNkSmxpT2g3WjFkTTVqZytCaVNJREgvcG1yU0VPT1BNOFlsQVZabmxNVTVxWUdzYVlSNFdTQ2lCTEZiUGJWaVdHZnVUN2wzbzBoNTBjRjA5WngwTGlUOXN6K3hGRk5UcjU2SFg3SmxDRkQwK0hGS0sxODBrQUt0K3c0anJIR0lhYnAybVF5WVRhYmZXc0owcmxBYTMxYTh0M3NOVXFsMUVoRXFvMjE4c3cvL0xGSGZ2Q0gzdm5tbjc3cnp0dGVPejJhbGEzdFpIMTlTQlJSdHUxUXFXWVRZcUF5U2E4cEJFSHdSTmNrZ3ppWGpwSFJPVG83d3dXWGx1dkJvcXNBR0M1OVpzYlRYOXpIYTBsKzQwUnNBQmRENzRNaGxHV095VFI1UHlGQlp4VDkxS29hUXBaMzdNMGpYOWx0T0dnRDk0eHp0a1lEVkdhdzBhT2lSdnVJNm9XUE01TjBZU1hDZE5IU3VTU25YeFpaRWt6cjVVVXJrN05XbWhsdU9WczFqS3ZreUZCUmxCS3Qwcy9xQ045d2dseTdNZU4xOTUxaGI5cks5c0Z5TlJKdFJTaXU3MDgvODhERjBhY2gvdWorMGFHWnpqTmkwSWdZc2l4SDYzUTZNVVl6cWt4UGQ3V1V1ZWZNZWlERUROLzdlOHlYRmhzOE5uaGNTQ29tdG0rZ001VmNxNG9pb3l3eU1wUGNZNU11VjdyZXFYSG5NTVI0a3B3a1NzR3lmZUYrNjltam1nYzJoejBybWVleEtHLzVVdEdKaGt3bEdVc2NLNlduMTIvZXhaWGxvUnphbTM3cjZpWUNMdzFnSkhKTmhMUHdWWlBqUlNmSS9YZE1lUHJhakoyRHBXcTdvT0pOWmNKQmdxSEw2UFd2T0hmdiszNzQrMzdtTFc5NjdYdHZ2LzNjMldYZHltSytZREtwbENJZFQ3b3VIWmxXRVBFc00vamc4ZDdoWE1TRmdIUVdiMXU2MlBXQ3oxa3ZIWk1ubEdtaEVUVERPMHZZTUxSWGFwUVdsb3NXazJVSlFxTFNCVEdaUm5TR0RhRUhzd2xWV1NiUENkMWpHNlJCTGVER3RHUFdXQjdZRk02UGkxNVZBYkwrZ2hiR0pINUNibkFTYUp4TFZGVmpzTlpUbUtUZDJ6WXRUU3Y3VXlzZjZjZTVxeVl3YUZUTTBES1duSDI2YjQwZXNEWmdYanZSV2tsSVZjUUMzZEdpMjN0dVovNkI3M25vL0p2V2h1WU8xNytoaTl5UVp6bkdaSW4zSVFFUlM1YkJvRFNFa0JGallGWUxiZWVTaEkrS0RLb01reHNtNnlYZUt1cEZoMjBkUm1sTVAvbGI2WCtGRURHRklodEU4a3hVNStURy9tSHprV1hiTnFzRUVSSHhNU1M5cEs4UlR4M1d6MHVFVzhVVTFDM1pJc0NFa3BtazY3clhMWTRaaitwNVdTYkhLc0lBZDN3OWFNK0xvcjVtbWlMVE5KMC9LZnBjcFFXb0h2K25QL3JhZDd6dERmZjkzRDEzM3ZmR3pjMk53bHJQL3Y2UlFpS1pVVVNmcklHZGRZbVN1Zm9CbGVyaDFlQnRKQVpGUFZ0aVk0dXJEeW1Hb3lROEVCSmVxSE9CNkJWS2hMWGJCcnorNzk3SFgvM2JaOWw3NmlCQkhIby91eXhMSDRzaUxWNnJxa2dqU2g5UW1XSFoyblFzMElaQnJwa1VBWUxpeUFxZjI2MDVQN2Zjc2FZWkR6S2lrSFllbWNINWtKclBMRDJCUTBpSjdVUEVhbzJQUVpvT3U3MlUzNy9tMncrZFFLa0dCVEhybjRnTjRTUy8vSnVLRUlWbmQyWVlyWkp1UTVyNHRFRHgySE1IbjN6d3pqUC81dDQ3MW4vV3VsZ2trVUZEa1dkSWNBUnQ4TkhnZk9MRmROYmpmYVJ6bmlJdnlJc1JkVzJaakFzRzVaaXU4NGxFTlcrSUhuUVBseisyZENBMTZtWUFnMGxBWnlJbU0wb0YyYkV6OTJpSThYbDhpNmF6OEszOStqZVBtLzExckcvcDQ2NHNEMTc0ZTVBWG1GbDlGZVRDMTEwQ2JvNlFHSEZCbFBOeU1qbldnTFdmL2NrMy9lQVB2ZVdoLzJXeXR2SHFqVFBuc3JJb0NDRXdteThZRHpOTXYwdElZTFl1Q1FqRWlQT1c0V2hFa2VkMHJhT09IZVBiSjNodkNUR2dZdEptRGQ0UmZNQzVHZDVicklWb29hbUZiSkF6dWpDaFhnVGN3aDM3NHlXVEdKUEkvMGF6dWJHR01RcnJVdzlpTzNlTVRaSmVFQzdQSWprSzd4VUhMckt3a1Z3cGhrVkt1RHpQRXA4Z0JIeHZQcG5HMGF6QWZlSTk2a2JOcDY5YTk4ODk4UWEzbU9JWUZKYUlmYkYzNTJ2RTVkMDVrMkhCc015d0xweDhzS29ZUlRXZDN6MjNPWHE0eVBXZDNpZnB6UkRDOFJrblNwYkU1a3hCTmR4Z1VLMHpISjdoek5ZZFZPV0V6QXd3dWt6NldUSEpISzdBaVNMMGU2cDBiMDBCZ3pFTUpvTEtRQ210dE5INEtFL3VIN1YvVXRkMm4rZHJUM0V3WC9CU2lLOWJRYW95Wi9kZ29hd0x6K09GSzlUNEg3M3ZUZTkrMit2ditlK01VdmY2bUlCNTJpaGNtNHd2amNrVDRLOVgranNXRm90Sk05WlpUeWpTeFZjdW8yc1hLQlZTazYwQjM0RWtBNWhvTFRybU9OdmgyNFFZN2F5Zzg0ejczM0VYVjhjRmx6OTNEVHBQVmdqUnAyWnkwWFRrWlU2bStpVHRiSHFqeEpoc2lvMmhLQklYME9TcDF5aXNNSGZDWTRlV3FZM2N1OUc3TDJtRGk1RzJjM1N0UmVza05aTmxSaG9yNnJDVzUzYmIrUDRPL3h3bjFSTWg1dWh2MTBQek9HYTE1ZXhrUURVb3Fac3VDdUxTdGxvVnoyMVBuMzMyK3Z6WDMvN0doeDdNOC9LTTlXbkphWFJHbm1jSTZhaWx0VUhyN05qanc3bmtwNmlWSnNzeW5QY1VlWVpXaGxBbXB5cnRMRm9nR3doWkNVVUZKay9hWUVrMVBoMjdnby9YbHJXZHJUQllmYVhqcFJSZnQ0TE1sNTJLSXVvRTlYVUlqTjc3cm9lLzl3Y2ZlZkIvWGh0bUR6ZXRaMzNqdkZwZkg2ZUw3QU50MnpBYzVJUVFpUkc2enVGczhxTHdQbUt0SXk5TEJtV0ZEMEpuTFV3aVdXR0lQalhzTVhUWWJvRnQ1emdiYUZxaGFTSnRJemdicVZ2Qjk4TFNhMmRIRkpNaHpkelNUQnQ4VFBwTHRuUFVuYVh0UExXMVdOOS9QdmpFWjlZSjlLWlU4cU1vQzBVbVNUVW5DaHpheU53R2RCUzBUemJPcVdGTm9ML2dnemlQMmx0dy9VWXJ2M2dnN29OeWt5blg5V0JFcWNpay9TWWE4cThYZGVjNXQ3V2U0UHlKQ0hhc1IyeTlPcno3d2wzbCt2ak13NHFpVUltbFM0d0pHcDdXRjVyWU8vazY1d2k5VEpEMG1EVjZ1THVOanRZdGFQd2NsVm55S2xJTW9TaFZncHdvMWV0a0pSNjVnQ3diOXllWHI4OCszbGVQUmluMWdndTVsMnlDOUtPRWxaL0dBRmk3NytMVzdlLzdvZGYvVitlMzF0N3ViS3RpVk9ycytRdXNqbGVDb20yVHp3UDlJbW01N09oc2h6R0o3TkoybGhpaHFpcWM4MFFmb0JMTVVPSGFCbXZueE5qaVhZZHpucTRSbG0xeWM3S2RFS3hnKy9sN1V2eUxxTExBakNxV3RXVTVYV0pibXl5OVlxVHpIaHRDMG56cXo4MnRqVFNkSUZHblRiR2tVWEZSS01wY01UQ0tUQWx6RzlsdWtzcTdVUkZKdlNZaENMTWEyVi9LY3pzMi9PSUIvbzhGT2NsNWNLc0Y5SUNNN2p1UUlPa2gxdkRnM1JmVTRXd3BuSGhDTCtvbVhOM1p1M3I3dWJQM0R3YUQrMElJeXZ0a0tlQjhTRlZlNjBRWldLa2hTbEtGajVLT2tDNDZMRXRhdFNEb0ZwVHZxYlFyQnFGQ1ZQcXp0ZUc0Ri9SUkx1MU4yOTg4bkRaUDl4Z3NxNVR5NitzRGFWdi9za2tRZFdJaldRSnJXYWJYM3ZmdWgzL3MxZmVmK3dlS1VJbEVRbFJzYnQ3R29CcjBPcXlXcG1sN2hHY2FLNFlRYVZ2WHovRURJV2hhNjQ0VFJHUG9va1ZWYzd4YjRteE44QjNCQzg3Q1lpazBkYVR0Qk8rRWFBVUpNUkdCck5BMmdhWUp5VEIrcmFLMlFqMXJDY0VqV3FGelEyT1RZSUdYSkV2amZJSkR0QTFZQzduUjVFVUNKdzZyZ3JWeFRwNUhjb1RnNE1BSis1MzQ0R0tuUmVYelZ2dGR5MThjeFBoUEY0U1BTRm9JTGsrQTMyS09saEpEazlCZDN5RmUvK3RRU25GMTkyQ0ZQVitOUlBXeWFkc1k0ODY1amZWWEdxMXZpekZLaUVHbFRidkh1YVFqRmxkeVF6M0d5bnFIVlRWeFdLT0hnYnhJUHVaRjNrOEtiNWt0YVowMHRCYTFZenpNL2JJTmYvVEVzL3QvRUlJc1YyTnVFV0xYQlhrNVZaRGpkYjFTcVRGLzVEVzNQZlNldDk3NzM0NnE3TjRZa3hoWmpEQ1puS2NjbERpZnpyRDFNb2tGWjFsT0NJTFdocTcxT091aDM1UXQ2eHB0Y3ZJOFMvcEtMaEN5R1NacmNUYkJTcXlEWlNNc2wwSmpKUWtvdTBod0VkZEZiQmZwdW9qckF0NUZtcVZsZnRTdzdEcHFGL0FkZU51enowVGpRL3Jvbk1aYkNENVZPQmVndGNtcmJ6SWNVQlNHSXNzWTVEbWxVV1FxQ0FHYW9QLzZLTVRmYjUzYVhnVDUxSlR3Q3kzeHMzMUR2cmdGR1NvQzhqQmJiRk4veDI3aXhmTm5XTFl0Ty90SHErSGdTZktQM3RrL09CU1IzZEdnZkVXZVoyZWQ5eEpDVUt0bFhqTGdOQlQ5dldyamtsalZtRFZMVm1yeUxQRThza3hUbGptNk1Fa1R5NGJqZDRsUzZUcnVUMXNHaFhsdWU3Lys1WU9qNWl2YzlINzNMN1hqMWRkTGtMOVJQZkpNajk3N0EvZi96SU4zbi9reEg5Q0tvQlNDdFo3aDJoYlZzTUk3ajlhYXhhSWx4RUJSRG81SHVzdDYxU0FMMWprNm0xQ2lrOGtrS1NoMjBIUkx6S2pGV21oYm9lMmdiaVB0MU9OZDhxcndiY1M3U09zaXRvMDRGeE4zdkhITUR4c085MmJNRHhaSjcwa1pYTkMwTmJnT25OVUVuNUxEZW9paWpwZExzYTlHWU1oTnNoSW9jb05SQ3EyaVVqRUc2L1Z2VFNYOFRrMzg4NGI0MFFEWFRpQklqM2NlT1ZwR1pHS0o3SHdIa3dQZzh2WWVOdzZtQUV6V2hvUVFWVC8rUE9ZNFhOL2J2NDV3YlZTVjkrUW1QNStBS2twRlZnODVsWTVUZW83WmFLZ21VSlRtR002dXBQY0d5UXd1Q3JaenVOYjFja2RwcW1XTWtxNkxibDdiMzcyMnUvaTN2US9LQ3RZZmVBbEc5aUlxeUVxREtiL3Y0dVpkcjd4Mzg0ZThENW5XcWtkS1Ixd1FtcmJ0aGNNaVdWRlFsQ1ZkMTFzU3gwQVFoVEtHS0lyZ0E0aW16SE9PNWkzTHVxVWFsRWw2LzJqSXJHd0paYUJ0MDNIS2Ura2Z4MEx3UXRlR1ZFRmM2ajJpajdTZDUyaC93V3gvem54YUUxei9WRE9DREJVaFU3aGFDRFlrcjRwRTRoZEJsSWdpNzU4RUVvWHB0R1d4QUpQQmNHZ1lEQkp2WkZCSUU5djRMRkZXZkk3RkNScXBYejBsRlVvTVNpcXlieGhuOWEzR2NGQVFZNVM2aWFGUGttTkhuczkvNWVrL1c5VHQ5TFVQM1B0Zm5OMWNmeGRLbVJBampXdHBZMDJuR29hVGpIT0RFVmxwa3YrNUU1UkswSDlFUDIrbGZhdzIzNnRISWlKbHFUOTE3ZXI4ZDZ3TDg1TUlnaGNDQTc2VUs0ZytrUndqby9YYVAvenhOLys5ZXk2TTNxT05MclMrcVlBaFpCZ3pZRHhlQjZXUkdGTmozblFKQnliUTFBMGhSS2J6R2M1WnNpeEhJbGdYbWM0YnhxTUs3d1BSRzdvR3VyekQyVWhuQlIrU3VhUjF5WmJZdTRoclEyOUlHVmd1SFVjSFN3NzNwdFN6SmQ0bFdJRlNpWnRoakdBeVJURlU2Q0paTVV0VVVZblNzUWQrcW42QmRGSTB0d3V3M3dhWnQxNkZFRVBqOUY4ZFd2bWRqbml0VDQ0YWFOVXhiVlpGaGVyOXBSVTUrdXZ5Tzc3OUNWSlNGUVZCSWlIRzFVQnFKWWdnaC9QNTdvM0R3eTl0VHNabnRkTHJjemMxdFo1bGpnN1YreEUydGFkcEVxY215M1R2cFo2V2NncFkxSWtuZ2swTHp5Z2lJcUtzaTAvZk9HeCtmdStvL1ZML0FHbGV5dFhqYXlYSVNxWS9WejM3N3pXdnVPdmUvL2dkci9yWlFSYnZTNHl5bFlaMzM0Ukh4V1I5RTZVTUlxdGpWcUxJaWlTOGo4a01zL21TR0FMYVpMVFdFU1d3czNlSWN6QW9COVNkeGJjYVczdXNjZ1FSbkJOcy93cGVDRFlkcDZ3TjJDNnduTFhNanhZMDh5WFJwN0drMGVuSnAxVGlNcXpjQ3RQYzNyUSs2azhFeXcyTk9xZkJDS3FuWk41RXhYVkU4VVRWeHRoTXJYemswTVZmbUV0NHRFK09rMFNia0VRWERBTXlYTzhadStRLy9MUm0yWFQ4cnovMzAxeTljY0QrMGJ4L1BCMi9Ba0JyN1d6M2NQcWw2emYydjlDcFptODBMaTRNcW54Tlo4bkNycXN0QnpzempuWm51TlluaW9ISXNRelF3ZUdDdHZHWWZwL2xFNjE2T2EzdEwxL2FYbnhRUkJZbkFKcitwVm85dmxhQzZCTzl4d2dZLzVjLzgrNGZ1ZWZDMmZlR01COUVTVStWSUxxMytWSTQ1MWdiYjVJWE9TR2tCT2s2eitIUkVWcEp3dXA0SVViRjBXS0prb0Jna2c1dURPd2RMWHZGS1FnQnBFM0NDVjRsc1FIbmhPZ2wvYmxMb3NudDB0RXVPMlpIUzVyNUV1ZDg3N0M2OHV2anBKeDRPaUZvVFJUemxiM0cvc3VaZFgrZW9ROFZhcUpRNndxbFlvSk40Z2c0dkJMWTkvQ3JEZnhmRGZHeFc1Nk1YcUZpLzg5ajBBbloyMXNxLzIyRlJLSHVMR3ZEQ21NTWRkdWRyQ0lCaUsyMTgzbFRYOTY5TVg5VW9hNk9KNE83aXlJN0czeWtXYlMwODFvZDNKaXh0ek5uZjNmS2RHL09jbHJUTnBiZG5acDIyYUJpSVBnZ0F0SDYrTUZydTgydk5hM2I1WG5TUGkvZDZ2RkNDWEpjUFhwSXlmQXRyMy93N3ZlOTU1R2YyNWlzUFRTZEhoR0NKOGFBanlzK010Uk5TOTFHdGpiWGtSQ1QwNm95Yk8vdTB6WU53Nm9rZUtFb2NvNFdOVGNPRHNtemdycE40K0MyOCt3ZHpkbVlqQWtocG0ydUx3bEI2T2lJTHNFY2pyRlBYV0ErNzVqUGFwYlRKYzZGaEE5YXVVR2hqaWsxY1lYZU5Jb1lUTDJjODRIOWVmdG5ubmlqeG44VzFPY0VkaFdNRkdvVFJBc3hCdFRqSHZWTEMrTHZCR1NIbThqYzR5bFZ5cnRlTkJuNXRzQkl2dFY0NXRvTmRnNk9lT01yN3lPRXlLSnVFQkhwYmFibEJDNUtCT3pCNGZLeXMrR3g2S01YN3kvT3A4dEJVM2NyckpXS0llS3NvMnM2OW5hWHpJNDZob1VTbmZqcE1VUSt2MzNRL05POXcrYkpXNjZSdnhWaytISkprT090dVRGcTdaRlhYL2poVjk1LzhhZlcxemVLZzhPWml0SmdzaHhVa1F4U1NOcExOL2FtckU4MkV5ZWpaNTk1NTdsMjQ0Z3l6NG5SMGJRT293eVhydTJ4WEM0cDhnem53WmlNbzltQ282TUZrOUdRaUtKdU9xUUZvd3dPai9YSnVONjJnWHBwV1V3Ymx0TUZiZDBSWXp4dUpoVWFyUktUTUFsSWE0elJFc1ZRTDlSbjloYnR2N0xCWCsrZmRFdEwzRzZKbi9YSXB3MnExbWdSMUNkYStEK1d4RCtYbTJxQWRiLzg4MEFzMERMQVlMOUxINUlYejIweHIxdUtURk8zamg3bkVVOVVrbFdpaCttc3ViRzN1L2pyZXRFOUtpRnNLaVVUUkJVb3BYdmxkTEZPMUhRbXNqN09WRFhRU3BRNldyVCs5Njd2MWYvc3htSDc2SW5xMnIzVWoxWXZsQ0MzVm8vUm5lZkhGMS8vd1BwL2JadlovU0VhOG1KTkVUc2tKcEpXZ2swcmlpeWphV3NhcXpsL1pqUGhySHlnTEFwRTVWeTZ0c3R3VUtUbTE5YVV1ZUxLalNreEpGbjhFRFhHWk56WVA2QnVXNFpWaGZPZXpqcmNJcUpjRGtBSWptYlpNVHVzV1U0WGRLMDlGbzgyUnBQcHBGUFZlOGRnVEhJcGlzR29kcTRQRnAzL2hXbmIvSFhmUnh6M0VnTFdJWHNkOFM5YTRvY2I0b2Rhd2dwVGRYTDVGektsWTZHTUdKVGtLTHJ2MHZIK3BlMDlEcVp6ak5ZSmlZeVFhZE5EeFkrcnlXcjZGa0lVdTJqYzVXVVRQdVdEUEFaNnFpRFhDWDJ6ZnpRTGoxZWxNYU5LYmJ2QVh4M003TCsrdkxQOHpYbmpyM3lWNUlndjllUjRvVEd2N2hlREE2UDE0RjNmOS9BamIzajFuYStiejZjOCtkUmpxaHJlenJtdGlrRnVRVnpmbEVPTW52R281TXIxeTV3L3U4VjRORXhhc2tweGRuTkMwMXEyOXc0NHQ3bldKNVRoanJPYlhMNXhSSXlSTEFPVTVzem1oR3M3Kzh5WEhmZmRmUWNJMUUxRFdQUWVFOE9TVXNBMWg5VExHdS9Dc1dtOFdna1JDTWV5TkQ2Q3F4WEtabEdqL25UV3pUOTV5MUl2bktpYVdVQ3lnS3pZTTZ0Ky9aZ21hOUJ4cUhPR0twTnR2M3hKM09URGVmbzV0ZGFjSGEzTG9xdWxkcDJLTVlvOHY2SllZTkM1MEhiVGNGbE51NCtPaDlrOTYxWDJ5b2hxanhyMzFHWW1GNi91aGYxcDdTODVMd2Y5dFRtcG11aU4wWEUwS3BqTjJwZDZmanl2Z3F5cVI5YnI0NDd1dXJCNTlqLy95YmY4by92dnZ1T1ZXMXRiakVkRDFUUUw1a3RQa2EvZTFEbENrc0hYS3RLMERUdjdOYmVkUGRNL3hwTlN4ckNxT0p6WFBIZjFPbVd1Nkd6eTZEYW01UEwxWGNxaVNIeUZHQ21Lbk9tc1p1OXdUcEhuR0sxWkxCdnF1bVYrMk5ITUhlSVVnN0trcWtwaTZQdVB1REs3MTBqUXRBMTBjNE54R1htV2ZXbnEyLy96cUc0dTgzeGRxdU5qaHJxWkRLNGYzVDVQQ0NCVFdncGx4Q2hGcGpUTDZGNVNOMXRFR0JYSlJUWTNHVVpwUXJwbzhVUmZjdExRc3UxYzNKNDEvdEY1NDUvMEllNHZHdjlFM2NVck1UTHZrK0ttaEpGU1hpbGluaHM1c3pWODJTWklvV0FvTVB5Wi8raE43MzdrZFEvOGpDZzl6SXhSNCtHUU01dGJETW9pK2RXSlQ5cFVTU3lLRUR4VldYSmxlNGVtMDV6ZG5QVFFrOVNQVklNaDAzbkRsWjJESktLY2xXaVZtSDU3Und1VWltUW04ZktMVEROYkxyaThzMCtabCtSNXdkRjB3V3k2Wkg5M3huU3Z3UzBGNVRQRTVZalRSS2Z4amNiVkNuRVp5bVprR1BJOHErdm8zbi8xYVBwbkovcUo0eW1VU1p5emt3SUFKMTlSOVZ5T1VtZnl0cTNidWRiVUhJVG1KWG5EbDdiRjl2aTBVbWRrdVRvV2Z2NHEvWWs3VVVGUExrU1BKWE1TQ0RGZEsyTjAzRml2T0xzMUpBUmhQdTllVmdteXFoNmx3UERpK2NtRm4vdXBkL3czNitQUnEwTHZlaHI3Yy82Z3pCbVB4bVJGaVhQSjVER0dnRklRb3FISWhVdlg5cG1NTnlqeXBCYU9NbGd2aktzaExpaWV1clNOU1lLSURJY1ZnMEhGd1d4Slp3TmFaempuR1JRWklvSEwyL3RNWnpWTmJlbHFpN2VlNkNKdGE2bVhIVjNqRW5qUks4UW4vVHl0RTdqT0dJMVg4cWtiemZKWFcrZHVuRGhhdWN6b21Cc2pKaXFTakFGZjlaV1dmb3FJWXJ1dG1jZVgvbzFmenl1Q1JPNjVmY0s4Y2RpYjNncFJLVVQxRlZXdHFxbEtGYlZQQ05lLzBnTkdxeENGcUxWaU1pN0pDOE9seTBlOEhPSnZKa2h5Y3lyL3p2ZTk0ZzF2ZWNNRFA1M25acjJYZU1RNWk0K3hOMy8wRkVYaWN4Z05YZWR4UGlGV2k4SVFROGZsblJsYkcxc015aHpyMHloM1VUZVVlYzVvdU1idXdZeFp2VUNoR0k5R2pLb0JpNmFoYmxwV0FxeVp6akZLY1hnMFkvZG9UdHU1SkpjbWtLWHBWQzljbHBaWVJxdWsyNlJWOGdDSmN0UkU5eHQ3OWZJVElzZlNPMVlwRllabHdibjFNZE82VFRUTXI3RTFUVUpLRVN2aFpYSGoyK0N3MGVOQ3NsTHJLd2lESXNkb0xiM2xicnhsZi9LOHlwcG5Xb2FEVEtwQkptMFgwRm9sdFJjVXM1ZEI5VGlaSUN0UTRzcEZkdkt6Zi85dFAzNzM3V2ZlRmFQUDBMcXZBb2xwaGtyZmxoWi9rVHhQOXNOYWExcmJVVGVlTXRjczZqbVh0NmVjM1RpYlVLS2RXeDJHS1l1TUlzdUpvcGd0YXpyYlVtYUc0V0NBQUhYYjBuWU81MlB5em1zamVHaXRvd21XVGdJK0JIckdMRjRpUVpMaHZJOFI2NEpJRk16QWZIS25YcjdmZW4vanhIazVBTkg2SU91amlzUDZhNE1KVisrUWwyTzAxaDhuQjNDc281VWdSTWUvL3Eydi9tc1ZXZitBYXJ2a0pWTFg3bVdUSENjVDVPVG1mSEJ1YzNUYkR6M3kwSDlTWk9vaGF5MWxXU1JMTFpPaGRaN1U5bFF5cHd6ZUl0RWpSQWFEaWtGUkVhTEJlbzhHRG8rbVhObWVzYmt4SVRNYTMzdHpXK3RZTmd2S0ltZDlza0huSTRlektVb0poZEdVUlFZaVdOdHhORnR3TUsxUkxobkttOTQ1TllwZ1k4REZudDNYcy8wa0NJVXhxaHFWMjdQUS9mekJjdm5sUGpscUJkWm9IVWRsSWRZSHBuWERhZHlNRUdPUzYza1JYNXRRMmNtdDZ1VWFKeXZJU3NabitKYlgzdm53eGJQNTMxL01EczVNNTR0a0l4WTBXaG15M0NRcVpxOXFuamdoQ1VMU2E2NmhDUXlIUTBRcHRNcTR2bmZJcGF2N2JFN0d5Y1RHTzd5ekNkdWpNNkwzRkNaVkZPc0RuWE1nU1pvL09OZGJEQ2RucU5VbzE2aWtuWnNyUTZseU1qUkdKOXUwc3NobE9CejRtS3Zmdlh4NCtJRW94K2piVGtGWXEwcTVzTG5PL254NW1oR244YUwySU1jalhpQzc4N2JKeFRQcmd3dDVsdURxemk2NFBsdFFGRVBXTnpZWUZDVmxybnNickRTRkNsRVFJbHFsSGlDNmhtRlpjZHZabkR5dmVPS1piVDd6K1VlNTU2NkwzSDUyZzNabHBLa2doRURUSkh0Rmd5YXFISWtLbzhDWW5CZzBKaGh5ZmJQQUp4UnBMNWk4S29OYWtSZVpGSG1tc2pKN2RyZWUvcEVQWVhIckFxdnBuTng5YnBNbnJ0MDRmUWVjeG90S0VMMUtrT0VnSDV6YkdMeXlMTXd3eGh4Rm9Cb015REpONXhvTzk2OGo1QXdHQTliSEUvSWk3UzVXcDFVZklrWVZrTVZlbWxKeGRyTmdXQTE1NnRKMW5uam1XYnk3eUpuTk5YeElLaGtKMStXVGZJNlBPTzlaTG0zeTRPNDgwYWRwbENKVmxkaHI4Q3VSWTIrUHpHaE1ybEZLcXl3M29RN3UzeDBzbGs5eWd0R21sSXBWVWVDODU0T2ZlL3owN3AvR2kwcVFrOHhCYzI1ek9CeFYxVU5HNTlvSEwxb1pGV0x5NE1oelJXNmdkWjc1L0pDajZZSkJOV0U0S0ZrYkZrUVJqRTdrSnNTZ1RjQ0lRYnpINk1oOWQ1N2p6UHFRS3p1N1hOL2RZMnQ5ekdoWW9YU0NxamdKaEg1a1pLMWp1V2lwNTIwQ0xwS21Wa3JycExDSU9zWmZLYjJ5SVU3QXlhRGtDNGQxL1VIbnc3R2JLc25UVDRvOGw3cnJUdS84YVh4akNhSVN2VTZmMzZ6VzF5ck9CdW1aWkdwbExCOGdHa0kwWkRxU1Z3b2ZBdFA1THJ0N3duZzhZV3Q5UWpYUVNhUXNKclpoNlArTGxWSGplSzNpL2x5eHZUdmp1V3ZYR0ZVanpxeVAwelJFS1lpUnJuTkpiOWNualYzZDQ5YWpSTFNzK00rUTFLemlNUjlhSW9oaGYrN2EvM2R2UG4rS214QUl2eEtNcm9xQ285UDdmaHJmWkEvQytscCtkbFNaTTZrUFgzay9xSlFrU2dpU2hFTkZBS1daakN1cTBqS3ZwM3psYU1iR1pFUTFHREljRkNoMVV4ZExlazlBaWFCVXhtMW5SbFFEdzlVYk01NTQ1Z3JWb0dLeVZoRkR4RnFmRkV0Y09GYXhVU3BOclNTcG1pZkpEcDJTWkdYUEVxT0lDK0Z6TzdQcHgwVmsxWGM0SUdiSk9KTHJCd2VuZC8wMHZ1RUVXZlVoeWprWkh4NDE0enozaUNqbFEwQ3BESlNocW5MS1BHMjVZN1FZcllpU281UmhmV3dvY3NkOGRzUzFuWDNHb3dtM25kMGdNNFlRTkNGNmxFNWdqZ1QvMFJSWnhsMjNUWmdNQjF5NmRzaFRsNDRJSVFsRis1WFFYSkJqSlp2VkFFRDFXckRTWjJxSVFtc3RTc3U4ay9DbnJmTTN1T2tlNUxWU3NjZ01hNE9DUmV0TzcvcHBmRk1WUkFISzJsQk01MjAyS0pNOXJ3K1JFSlBNWitjVXcrRWE1ellIREVxZG50bytKQzFkU1JJL2swbEdVYlFjelE3NTNHTUhuTjA2dytaNGpGSkpHeFk4V1FaZGw2R1VBMUZVcGVHZU85YVpyTFU4Yy9tQTdSc3p1dUNUTTZ0S0l0TzY5eFBVUnFGSW8yVWt1U2pGRUZFR3FyWDhtVmxULytXSm81VUR3bmhZeVBuMWtjeVdwNzNIYVh6ekZRUkFGWm5LakZZcTlxWXhXbWVNeDJQV0pNTjVpM1dPWjY4ZVV1YUdjMXNWUlM0Y240TkVpQUV5clRtL09hQWFSQzV2WCtPcDUrRGVpeGVZak1wZXRVOFR4YVlxUUVhVVpDVXdLRFFYenE1aEc0K2JKdFppUUFna1V6elZnejZVU3FJSVdoTEVSSUVNSzlOMCtEOWV0dTRhTjhGMVFTa2xNWWdVZWNiTzlQUjRkUnJmZklJSUlDNUU3Mk1VUXNibTVua3UzSEV2dytFNlNHckt2ZXR3d1hKOSs0Qmx2YUNzY3BBT0NhdHRkb0FZaUVvb2l3RjNYOHc0T0Z6eXpKVXJqS3NCNTgrc1VWWHI1RGs0NzFIS0p3OFE1VEVxMlpwdHJWZUVHRG1hdDVpb0tOTHUvRmc0SUFsRzlEcE5DakZHSVlaSEQ1djJ3eUxTblJ6cmFvVTBuWHNlbk9JMFR1TWJUWkJqakUzcjVHQnRjdTdvbmp2dnJ0WW5XK1JGUmROMnZZMkJBWlV6cklhODR2NHRyTFVvbFp5RWduZUlXQmJMSmN2RkVYV3p4RHFMOWJBMkhKQm5HUWRIY3g1OWFzN2Eyb0s3TDV6dFpVa2pXcHVrSk80a2JkKzFacFRuVUVGdEV4NHJKeUYwbGVxOUtRQnQwblFzTDdSWWlaOXVyTi9oQkN4YksrTDU5U0hYRDVjOGZtWHY5RzZmeHJlVUlCR1FMQnZ0MzM3YnZYdGJXK2N2ZE5aSjZEb1ZndkQwczlmWm54N2h2RU1kMDFnRHllTE5rS21jOWZHUU01c2JiSjdkWXRndXFadUc2YnhodVR4Q3hMTzVQbVJ0bVBQa3BTTzI5Mlk4ZVBkdHJGVUR0TzZoWU1yM3RTR2QyZ3BqeUVwRnJUM0JDVVlwZXNjdHNwVjRzbEhLRk9heWovSGpQc1NUdlVmTXMweEdnMXhPYi9OcGZDc0prcXBIMGt5THJRdE41M3lUdHVQQzBWSERaNy84QlBubUFRKzk5UldzVGM2amplQ3NwV3RxT3B2ZXZMT2pLYnM3Qnp6K3hhYzVPejdIbmVmUFV3MjIwQ1pTVlp2VTlaeTJYWUthOHNCZE9kdDdjejcveEROc3JVKzQ4L3daakJhMDBzbWdNc1pqdlZldEZjTThJMmJRZHFIMzlFaUs0b2hRbEpsa2crSlRzOFBsb3llcXg3RlJwcExUbzlWcGZCc3F5SXBOdDNjNG15L3Fkai9MREU4L2Q0TlBmZkZMUFBDR3dQZCsvd2JybTJmSXpHMzQwTksyQ3hScmVOK2h0VWJDR05mTjJaODVubnB5bHllZTNXVVF0aGdOMWhrT0NrYlZoTEljMFhYckxKZUhYRkFaNDJIRzAxY1B1TEUvNS82TFp4amtXWUtVcE1ZN05lTW02eG1MYVpQZWRvbWhhREpGT2NoWkcxZmJpK2cvdEtqYnc1T1RxeXd6VW1RWmM1K2QzdVhUK0tiakpOeGRBOW15NmN6RDk5MTE3OEhCNGkzUGJEK3Azdmo5T2QvejlrMlVpb1NnME5rVzNqcUM3L0Nod2Z1V0dEeGRNNld0anhoVUJWdG5NcXBKcEZNTG5yMjh6ZTdPZ21GVmtmZEdLMWxlVVJSckdGTXdxZ3JxdHVIeTlnRmQ1NUpzcGsvYjlMUTlUOHRCclJUR0tQSWlBNjBwaTV6eFpCaFVZVDcwOU83dWJ6a2ZwdlFDMGtxcE1CbFdyQThycnU2ZFRxNU80MXRQa05VZUpCTkZkbkN3S1BWZzlwb2YvcnViWng1NGVDTlorb2JrSjZFWjlsN2ludUFia0JXSktpQXE0b01sT0EvUlVFMEtObTdQOEtiaCt2WWhYUjB3T3NQMGVLc3NLeWlMTVZVNVFJbmx4dUdVL1dsRHBucWtjRklnUDhaWmlTUmxqanhQUFpESzlPTTNsb3Qvc1Q5YlBFVkM3Qjc3Y3JUV3lXUTBaSGJLOXppTmIyT0NhS1VvRG1hTG83ZSs4MHoyZlc4NS8wWXY1Q0dLQ3FLeHJjTXRXOFJreVlqR2VTVGFudUpxaUNHaWxkRFVubVVkOEJHS0ltUHJmRVcxb1ppN0JkZDJEbGhNYmJJazFnb2xpandyR0E1SGFBV3orWUxkNmFKUHBPUit0RklSVC9BV1VFcUpNYXFlQi9zcmwvYjJQOGhOVWJkT0tSV00xZ0xDZEhtYUhLZng3VWtRVGlSSUJ1ajF6Yko0N2F2T3ZLVWNaSnMrUmtEakE4UVkwVmxGVkFvaUNBR3RBa1UycEcxbVhMMHlvNjRUd0RBdEd3WGJSVVJwaG1zNW03ZG5MTjJjWjU2NVFmU0NNVm1mbllZaXI4aTB3WFVkZTdNNW5Rc1UyaVRsL1JVRlZDRmFFYTJFRDE2YnpYN0YrbmhFTDhTZ3dHZkd4STFSUmQyZFFrcE80OXRmUVpSU3lWRnF1UXpxN2UrNC9lM1ZXbmFudFNLaVVGbHU2R0lnT0FGS29uaUlnV3B3SHRzTytlaEhIMk0yN1RoL3ZrS2IxR1RiT2lUdUdxYVBFQUFBQjE5SlJFRlV1a0FNUXA0WnRzNE5xZFkxczJiQjN2NlU2SVE4eXhJZFZ3emVSYUx6ekp1T0xuZ0tZK2lwMG9pZ291YXh2YmI1K1duVFBjTk5kVVNuSUFRUitjYy8vazcrOUxGblR1L3VhWHhiSzhoeEZRRnkyd1g5eGplZmYzZzRxVjZsRVMwaXluZko4V25aT0NRNHhIZmtXcWpyZFQ3dys1K2hhV3BlOWFwMXRFN1lMZTlCWENTUzZMaTkzam9oUk1veVoyMnJSRmR3OWZvdXZvbGsyckJjMWdRZkNVNFFHeFBiMER0eW5aRm5Ca0V1ejV6N3BiMWwvUW01U2FYdEY0TktCRTZUNHpTK1kwY3NWc2VzR0lYeCttRHc2dGR0ZlgrV3F5cUl4bnV3TGhuWkJPL0lNdUh5Y3pOKzdWYy9TUWllNzMvSEJTS2V6Z2xkSFFsZHhCUXJPSHJDaFNDSld1SjYxNml5ektuV01tYXpodENBYzU3bHNpSEc1UE5CakdpU1IwaG05TEpUOFRldXp1ZS9GMkpjR1daMmdOTktSYVdVR0oyOHVrL2pOTDVURldSMXpDcWNGZithTjV4OTQyaXR1QmdDUkZHS0NCcEYxd1krOVpmYi9QNXZQODdhZU1DUHZPZCs4dHpoWXNUMERZZ0dsRW1KRVVsOVJHZGpXcnA0d1VXSUxpVFFZYVpwNTRGNjN0QzFEa1RJc21RREpqR0NxTmlHOE9FRDEveXJ6b2VUSGhSV1FSd1BLemJIUStxbU8wMlEwL2kyaGI3bDcwTENCRHFsbGI5eWViYjkySmNQUGxnVUprUlJTa25FNk9TSC9kRS9lWTRQL083ajlSMTNUdG9mLzhuN3lNcU9vQ0s1VnNuNlFDdFVucWl3eGlRRjk5WUtSWlVUWTJyZW80MTRHMm5iZ0xPV3JFcWozK0JqYis4V0dGU2xhSk9oY3I0MEM5MHZMenQzalp2NlZsWkJORXFMOGxHTTF2aDR1amsvamU5Y2dzQ3hEcHQwM3NYdWlTOGYvdVY4WnI1U0ZnT1VSbVpIbHYvdkEwLzdmLyt4eTA4ODhNck5KOTc4dGp2ZFl1bXhkVVN2QU9tOVRKTHB3WVNaZ21icENGSHdYY0IxQ2NNbFBsazZleHZvR2tmYkxpbUdCcE1saW1BNk1pbXl3bHlyQ2Y5eUdkeWozRFJvc1VESWpJNXJWU0Vpd3BYZHc5TTdlaHJmOFFxeWNpRHFnTzZ2UHJuOTlCTmZQdnFvTVViMjk1ejg0ZTk5WmZxeGp6NzNrZTk1OC9rdi9mQjdIcnlnVkxZMlh3WU9aNTVwYjlVczB1OHVlZ2ZKWnVtNWZHV0pSdEVjZHRpRnczZUIyRHRKdWM3VDFSM3p4UXd2SFZtV1FaUTBzVUtzVmVHM0Q1dm1ZeUxIWGgwckVlVTR5RE1aRHdwbXpwN2V6ZFA0anZjZ3ordEZBT1ZjbEkyenhWd2hELzdaaDU5NzVzLy83UEt2dmZrdHQ4L2YrdFo3ZmtTaXVTTkVVY2IwSHVOT2NGWUlNVUhSQlZDaWVPekpROHExa2tJcDJ0b25RQ0lLQ2FtaU5BdExQV3Z3enFGVlRuU0tadGtoQ3U5VStNT2R4ZXhYVHZRZHE1RnVORDNMc013eTV1MXBncHpHdHovVTEwaU9sUVgwWUR3cDE5ZEcrYXVuMHpZKzhyWTc3My9ra1R2L0I1eSszeVg5aENRbWJSVGVDN1pOS09Dc1VBeUhHVmN1VDdtKzEvTEkyeTR5M1c1NmlHMDZodm5PczV3MkhPNHVXTXlXZEkwajJBSFNhVnpuWXRCOFpLZWIvKyt6dW5tS201NGVLNTY1R0szRmhYQjZGMC9qUDJpQ3JENS8waWQ5Q0F6ZSt2MzN2TzdkNzc3bm43aGd2aWU0U1BTaVloY2dDSkpyZkV3OWhVVEJCK0hHOVJsZmVteVhONy96TG9iQXdXNURieHVJN1R5MnRqVExEdHM1bkhQTURrVmlrNnRCa1VkSC9OQ1JiMy94b0Y1OCtVUnl0SURQc3l6bW1SSHZQUFkwUVU3ak94Z3ZoQVUvMll1c0xMYjBZbTczTGoyM2VPTEN4Y2xybFVpQkRhSkJlUVhCUjd5WDFIeUxjTEMzZEovOTdFRzgvWUZKcVd6SFp6OTV1UisvOW8xOFRES2xXbXRFb2pTMTRHb2poZEc3VFhCL2ZHRHIzMXk0YmdWQ1REZ3I4QUt4eURJWkZCbjc3YWtJdzJuODdmUWdYeTFaMUkyZFJYUDUwdXhMMVNDUDQyRnh0OUY2SklrQnFHenJzYlVIcFZqTzIrYnpuOXYrUWlnRytsV3ZHaytlKzhKVnVzYW5jdFhEMTQxT2lGeEJwR205cjZlbWxhZy9Yb3Y5Rjd2dDRyZmE0Szl4QW9SSUwvNEdTSjRaak5hMDloUnZkUnAvK3dseU1sRlUyenI3ekRNSFg2eG4zZFBEVVhrdUs3UGJFR1dDaTRTSUxCZXRQUDdsYXgrZnV1THAxNy9wdGpjc3QzZUw2ZTR5OGNlMUprbGJKWnRtSDlscnJQL0U0VlErM3JYcXc3UFkvdUxNZDErSXlLSlBqSnBqcTdSajhYaWNENmZKY1JyZmRRbHluQ2dpeU03dTR0TGhVZk1ZY09SdE1NQzRhVng1NWJtOXYzN2ltZW43WC8vSWZhOGRtZTcxMTcreUF5aWxsVks5U21NUVliK3g0VU9IQy9mcjEvZnQvejN2L0lkYWNaL3lFby82cERocHUreFZ3bGk5NUQyM1QrUGwwNlIvdGE5Wm1lemtRS21VR29oSUFWUm4xb2QzM1hYWHh1dWljL2RlM1o1K2VuaG1mUGlxaDg3OGIvdlAzWGh0dmJDSG9MWkRsTlpIdVJLRFBHNjlQTHMzczUrelhnNjU2U1JyVC96NTJHazFNMXB5azBYdlBlNTBTMzRhMzRVSndtU2pwRzI4c2wyNGRicFY5QWx6OG5ONlk3TmFPN2RWdm5sK3NDeERWQWMreUEwZll0ZjVPTGRPam5zS2JqcXBXbTU2a29lK1VrU2xGRVdXeWNVem16eTdzM3VLc1RxTjc4NEVlZGVQM01lbi91SUs5ZExkV2sxTW54am14T2RXL1BiVnYyOU8vRDJlU0F4L0lpRld2dHp4eERGS3ROWmtXck0rcXRpZHprL3YxbWw4ZC9ZZ3pnYnFwY1A3ZUd2VGZ0TDkxTjlTRlZhZlgxV0lsZUpoYzh0eEtweW9HdHphWjRRWXFidlRMZmxwZkJkWGtCZngvU2MvM3ZvNm1WQXY1Smg2ZW5ZNmpaZGxncnpRdjdteUZsZGZKUUZPaytFMFhqTHgvd082SUczWG5RV3ZmUUFBQUV4MFJWaDBZMjl0YldWdWRBQkdhV3hsSUhOdmRYSmpaVG9nYUhSMGNEb3ZMMlZ1TG5kcGEybHdaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPbFJOVGxSRWIyNWhkR1ZzYkc4eU1ERXlMbkJ1WjFJUTVEQUFBQUFsZEVWWWRHUmhkR1U2WTNKbFlYUmxBREl3TVRVdE1ETXRNRGRVTWpNNk5UQTZOVGtyTURBNk1EQ2YxSmxGQUFBQUpYUkZXSFJrWVhSbE9tMXZaR2xtZVFBeU1ERTFMVEF6TFRBM1ZESXpPalV3T2pVNUt6QXdPakF3N29raCtRQUFBRVowUlZoMGMyOW1kSGRoY21VQVNXMWhaMlZOWVdkcFkyc2dOaTQyTGprdE55QXlNREUwTFRBekxUQTJJRkV4TmlCb2RIUndPaTh2ZDNkM0xtbHRZV2RsYldGbmFXTnJMbTl5WjRIVHM4TUFBQUFZZEVWWWRGUm9kVzFpT2pwRWIyTjFiV1Z1ZERvNlVHRm5aWE1BTWFmL3V5OEFBQUFZZEVWWWRGUm9kVzFpT2pwSmJXRm5aVG82YUdWcFoyaDBBRFF3TkRGcXJoSUFBQUFYZEVWWWRGUm9kVzFpT2pwSmJXRm5aVG82VjJsa2RHZ0FNalEzRkM0Vmt3QUFBQmwwUlZoMFZHaDFiV0k2T2sxcGJXVjBlWEJsQUdsdFlXZGxMM0J1WnoreVZrNEFBQUFYZEVWWWRGUm9kVzFpT2pwTlZHbHRaUUF4TkRJMU56Y3lNalU1UHVmRGt3QUFBQkowUlZoMFZHaDFiV0k2T2xOcGVtVUFNVEl6UzBKQzRmdXljZ0FBQUROMFJWaDBWR2gxYldJNk9sVlNTUUJtYVd4bE9pOHZMM1J0Y0M5c2IyTmhiR052Y0hsZllqZzNZelExT1dNME16UTFMVEV1Y0c1bkVaYVh5QUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvZG9uYXRlbGxvLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDMwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTWdBQUFFNENBWUFBQUFldmJ3ekFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBQklBQUFBU0FCR3lXcytBQUNBQUVsRVFWUjQydXo5WjdDbDEzbmZDLzVXZU5OT0o0Zk9BVUNqdTVFREFZS1pWTElreXpKbE9jaXlaTm1XN1pMdkI2dW1QT1VwdTFSVE5hcVptZzhPZCt6cktjOVkxK25hbGkxTGxtbExGa21SRWhOSWdnUUpnSWdOb0hQM3lXbkhONjB3SDlaN0Rwb1VKWkdVcUxHazh4UU96a0Uzc0h0anYrdS9udlIvL28vZzBQN1lXS2ZUSVlvaWZ2UkhmNVM1dVRrKy9PRVA4OHd6endCdzd0dzU3cjc3YnZIeGozOWNWRlZGcTlYeUR6LzhNRTgvL2JUL2VxKzF2THpNVC8zVVR4RkZFVC8yWXovRzkzM2Y5OUh0ZHZuc1p6LzdSK296RTRmSDVuOXUrOG1mL0VteUxDTkpFcndQWjlVNVI2L1hvOXZ0OG5mK3p0LzVYVi9qWjMvMlova2YvK04vY09uU0pRQk9uVG9sckxYY3ZIbFREQVlEY2NjNUVOYmEvWis5bEJJaHhOY0N4QVBFY2V5WGw1YzVmdnk0cjZyS0cyUDQwcGUreEFjKzhBRWVlZVFSL3VFLy9JZC9KRDUvZlhnRS8rZTB2L3QzL3k3UFBmY2NaVm1TSklsd3poMEF4RnFMdFpiaGNPam41dWJZM3Q3K3VxK2hsT0tIZi9pSHNkYml2UmY5Zmg4cHBYanh4UmVGOTE1NDc2WDNYZ0lLa0ExUURnRFMyQUVvbXU4ZThFVlJ1QnMzYnZnYk4yNDRJWVNQNDlocnJiMXpqdkY0N0gvcXAzNks4K2ZQODdmLzl0OCs5Q0NIOXZ0dlAvTXpQOE5IUC9wUmNmbnlaYUlvUWdoeHh4a1ZKRWxDVlZWWWEvM2EydHB2K2UvbjUrY1pEb2VrYVVxcjFSTDlmbDhVUlNIMkFlRzkxNEFXb0gwQWlMb0RJSGNDNHF1QWNjZVhGVUlZNzcwVlFsakFTaWxka2lTKzFXcjV0Ny85N2Z6S3IveUtQL1FnaC9adHNUZmZmRk84K2VhYjlQdDluSE1DUUFnaDdyalJ2WlNTMmRuWk93ODBBTDFlRHlrbHhoaUd3NkVjRG9mNzNrSUJFUkFKUWVMOUFUZzBFTFZpbFp5Yzc2U3RPTmFEdkhMWE5vZGo0NXdCREVnTk9IQTFZQUdQOTBaQTdiMnZnTnBhVytkNWJxdXFjaC83Mk1mOFhYZmR4ZVhMbHc4OXlLSDkvdHJ4NDhkWlgxOFgxdHI5VUVnMElkRCs3WTBRZUNHa241dWI4My8vNy85OS85TS8vZE1BSERseWhNbGtnclZXRkVVaHJMVjNBaU1Xa0hoSUFCVnIyVG0zMkR2NnRwT3paMDdPZDg3MmV0bXhkaEpOZXkreVF2ajZGei8xK245Nzl2cjJpei82OXJQMzMzZDYvdkc4OXVYcnQwYXYzOWdjckQ5N1kvUHFxTWkzZ1Fxb2dSSW9nRm9JWWFTVWRtcHF5dS9zN1B5aDlpS0hIdVIvTXZ0N2YrL3Y4Vy8remIvQk9YZVFKd0F5YlhYbFEyLy84M092UGZmSlNYLzNqWkgzd29OM016TXpmajgvK2RtZi9WbisyVC83WjVSbEthcXFFdDc3L1ZBcUJsSWc4eEFmNldVejMzSHh5T01QSFp0OWFybWIzUjlwc1pTMTR0azRTMktFd251SDE0SjNYVnpxdmVQQzBxWDdqczk5b050T2prbm4vYWxldXJPemxRN2ZmV2J1dFpXeGVlMzZ6dmdyWDc2Kyt0THVwTmh1M212dXZmZk9PYis3dTJzUFE2eEQrMzIxeGNYRnI4cXo5eFBvWXljdkpBODkrbDAvdm5MMThtLzJkOS80a2hBb0thVXZ5NUxMbHkrTE9JNzl6LzNjejdHOXZYMlFmSHZ2b3dZY0xTQnJ4NnI3Z3c4Y2YrTEpzL00vZUh4aDZvazBqV2ZTVnFLYzkrUkZTZWtzVGtHY2FzWjV5Ymt6QzQ5R1Vqd2NLUjJyT0VYbWxZaTluK3RvTWRlZFNVN2RzOVI1LzlaaXE2K0hremRlYy83L2V6MHZudlp2NVRCZVN1bWRjOVo3ejN2ZisxNCsrY2xQSGdMazBINXY5c3d6ejZDVU9qamtRZ2p0dmVlZDcvck91Nlk2MmJ1VFdIMzh6b1I2YjI5UENDSGNoUXNYK1BqSFB5NEE0WnlUamVkSWdBeG9QWDU2N3RTZmU5dlpIN2h3YlBiUHBhMTRhVklicVpMWWswUlVreEtrSXJjMVRnbWtkZGpTa0VWYVo2MkVXRVVvcTRobXAranZYRVVvU2FzVk1TNXMvTmtYcmk2dXJtMHRUa2tsNXJMMHhsWmUzQUNNOTk0NjU1d1F3cDgrZmRydFYrQU9BWEpvMzdJOTlOQkQvUHpQLy93QlFBRGRlQUVlZmVJRDM3ZTFWWFRqaUozbTROZk9PZnI5UHIvNGk3OG9oc09oZVBubGwzSE9xVHM5UjZ6bDFOOTR6N2wzdk8zVXdvK2VXSjU1U3JkYmNWR1VLRzhaNytXaU5pT1NiZ0pTSUtYR080OGZsREIwbEtiQVRSbDBLMEZuWFNhakVlREpJczNlc0JRZmZ1WXkxMVozRUhpY2t3OGVhNmZmczF2Vi85NWFXKytEQkhEZWUxRlYxUjlLaE1qRFkvay9oLzJqZi9TUG1Fd216TXpNaUNiL1VBaWhBZm5JWSs5Y1Ryc0w3MWxiWGNuWFY2OFZBVGpzSisrc3I2K0x5V1FpblhQN2dFb0ZkSURXOTkxLy9JRW56eXo5OUdLdjliN2Q0U1MrZFgxZDdLenZDZThGc3BVaVVrMXBha3ByRWNhUkdvK1pHR28wazhvZ3JFRkxqYXNyaHR0YmROc0pwZlY4N05tclhGblpSa3FRQ2lTdW80cnllNDYwc3JNTmdPUG1BcGE3dTd0ODcvZCtMNGNBT2JSdjJiejNQUFRRUStSNXprSHpMaHgyOWI0LzhhTVA1eFhuVm0vZnVMbXpmY09Da09BUHV0Lzd5YmozUG1ueWpiYUhMakIxL3VqMDI5STR1bWRuVXJJOW1JaThya21uV3VqWk5yUWpvbTZHVHhKVXFwRkpoSmFLRnRCVERpY3Mwc040czAvZEg2RThqQ2NWbjN6aEJwZFh0b2xqaVk0VlNndWl5S044ZmQrQ0V0K2Z4VkczQVlrV1FzalJhQ1ErOHBHUEhJWlloL2F0V3hSRlpGa212UGRDQ0hIUXlKdWJYODdpenRFbmpHSEp1ZXFXcDVLaEh4TEFjVWNpZjFDcGFpZlJ0QmJNekxiVDJXNFNQK0FsY1dtdDl5RGlWb0pJTktOeHlhM3RQdmw0VER1V1pFcVNhRVdzMnJRN1hWYTIrMnowQnhTVElSRVNMVFJwSFBQaWpSMWV1THlLbEI2dE5VSkpuQVdIOTlMYk9QYmwreGRpOVpFYlZUMEVZdWRjTFlTd1gvemlGdzlLMUljQU9iUnYyajc5NlUvenBTOTlpYnF1OTNzZUd0QVBQZm45SjYzdWZtQ2NGNklxSnB2Y3dadTZBeUJ4azR4bjc3NTcrYTVIVHkzOGlCZmlaRHVKdXQwc09WZGJhTVVkc1pmM2NjNnhPOGpaSEk3dzNqQVZTem82SXBLS1ZwWXlPM2NFWXp4Nk5PRE1zVVh5blFIR09qYjJSbHhkSC9ER3lwRGFPckpVb1dLRmxKTEtXWVR3SWtxa3Q3VTlQWk5rVDIwWS8xcFJsQkdnaEJEU0dHT1hscFpZWDE4L0JNaWhmWFAyNUpOUGN2WHFWYTVldllvUVFucnZsUkFpOHQ1SGk4ZnVQcS9UM3FsaU1pcHRQZXJ6MVp3cDNRQWtBenB2T3psLzhsMW5sdjlXRXVudlYya1V4VW9naEdSNmVwNUI3dERGSGtOeUp0R0UyZW1NdWFsWllxVW9Sd1dUY1VsVldreHR1YjIyU1RXYW9DWDBwdG9NSjRhWFZ6WjQ4ZG9Pd2poYWlVUkhBaW5BMWpYT1dyU1dJTUJZcDlQSVBkbVM0cGNMbU96bklUUkVnTU1jNU5CK1Yvc3JmK1d2OFBERER4L3dxeDU3N0RIcXVoWmFhOUYwdmJYSHg4ZU9uVWptRnBhZlNySld0eW9tWmpnWTFJQzhvN091bTdDcWZYeXFOZmNkZHgvNXlYWVVmOSs0c2xGWkdWK1VOU0NvaXhJeDZOTlJncVdzdzkxSGp6QTcxU1ZKWTVJa0pzMVNva2d6SEkyNWRmc2FkYlZIbGttODh0ellHdkVybjcvTWk1YzNjTFVERDhaN3ZQZVl5bEFYaGtoSmxKS1kyZ25uRWI0cTd1MW9lUVJRSXZDK2hCQkNOT3hnb2lqaWd4LzhJUC9rbi95VFF3OXlhRjl0UjQ4ZVpYRnhFYTMxQVR2M0YzN2hGMFJabGhoanhCMjlEM1hxN01YbGhhTjNQelFjNTZJb0NqY2NEMnpqT2U1azRHYlRhZFQ3c3crZS9ndExzMU0vTURZK1ZuaThGQ0pLWTZ3VTNOamN4STV5VG5jelpKS2liTXhldFl1M0JpOGpmTzFJbFVTM0Uycm5pRlNFc1BEYzZ4dDgvTFZWaGdJbVdVUStxVWc4ekRsUFdWb2tBaDFKcEZMVWxhVzJBbU04c2FZMTMya2R2VG5NWHdTaUpwOHkyOXZiKy8wUTMrbDBXRnhjNU1pUkk2eXVyaDRDNU5EZ2d4LzhJTTg4OHd5LytJdS9LTWJqTVVvcEFMR3pzME5ES3prZ0Rpb3A5WVg3MzNiQmtKeWVqQ3AydC9iS1FYL1gzaEZpS1VCM0VwMyt0U2Z2L3BObjUzby9QckcrSFNVUjFJYWlza2dNZFY3U0g0OFkxQk1XbDA5anhrTW14WUNrSzJsYmliZU8vdDZBV0V0d2xqS3ZFVkx3d2h0YmZHNDBZdnBQbkdWcHFjTmtXSlB2NXJpTkNlN3lEdld3UUJjMWtRQ25ITTU3UEJCcHdQc0k2NDZFU3BhdmdOaDdiNnVxUWlubHZQZitFNS80aEw5OCtUSkNDSC9zMkRIcXV1YklrU05FVWNTenp6NTdDSkEvanBhbUtTZFBuaFRQUGZjY3hoalJzSFQzK3huN09ZVUc0aVROa3VPbkgzeHFzMTkxaEJEZTJHcTF5UHVqT3dDaUVVTDl4R09ubjdyLzJNeGZLNnlZcVNiV2x4WXhMbXFzdFNqdjJabms5UE1oVHo1Nm1taXhoeHNWcEhnRURybnZpcVRDQ0NoTGczUHc0clV0WHV4NlRuL3dBYkxaRER4SUlWQlNVUmVXdmJVaDVVNU8rZVlPOWRWZGlsdDdPQU5hQ1l6enZySk9SY0tkMEZxMTY5bzRBZGFIVXJaeWdSMXNiOSsrN1ZaWFY1MlVrbE9uVHRIcGRQelMwaEwzM1hmZklVRCt1TnJIUHZZeEJvTUJWVlh0RHlyZHlkS1ZoTDVCNUwzWGQ5OTlZVlprQ3hkMlZ3dlZhU1dnSXFGMExPK3NZT2tvVWkwZG5aNzBSOGVHdGNNa3FiQk9vS1FHQktYMXJPMzFlZVRjQXFkbXA2Z3JnNVlDdktNb2FzWVdwbEpKRkZKb2xOWjhaWE9YNjZjempyL3pPSEVXWVdvWC9rQVB3anAwSXBnNzJVT2NuTUkrdEVpeFhaQy91Y3ZrOVczR2w5YXA5MHE4dDBvYmM2d1ZSVFA5MmxnUHB2bi8yNmZHRys5OTdad3pRZ2g3NWNvVm55U0oyOXZiNDQwMzN2QlNTbzRkTzhiSmt5ZDUrdW1uRHdIeXg4SGUrYzUzOHZUVFR5TkNacjZmUTZnNGplWGo3L3lyWjZ1eXRzOSs1bjlmb2FHaUh6bCs5M0Vya29XeUdwQW1NY1l3STJYVXV2TTFUVlg1Ti9jbXI4MUZyVnRTdUZNbU53eEx4OFNBaWpMV3R2YzRkNlRMaFpPTGVHdVIzaUU4ZUNHUlFtS3FHaXRBU0VFa0phOXVEcmgxSW1YNUhVZXhCbnpwa0ZLQUFPZEJpc0NaUjRKM0R1YzgyVXhDKzIzTDFQZk1NWHpzQ0wzVkljWDFIVkZ2MW90dTNGKys1OVJpL0lISDc3bjNTeTljWFgzMnpaVmJOSFI0NzMwQlZONTc0NXd6UlZIWTY5ZXZPNXBKUnFXVWI3VmF2UHZkNytiZWUrL2w1Mzd1NXc0QjhrZmQydTIybUV3bSswUkNEZWdmL1d0L2J5cUtsdi9HbFRjdWZ3Wllid0NpT3pQSFQ0d0xQMVhYeGt1QnlMS2tGYWRwM0x6VVFkUHQyZFgrMWZ2bldxL01SZkpVSENtOHJSaU54Mnp0OVJtTlM2SmpMVjY2ZElzNFVTek45ZWhOZHlpTnBTd05rZmY0S0VKcXhlYk9nRGNUVC9yZ0FzNEN0Y1A3dC80Z1YxdXNGS2hFb1JGdkZacWx3TlFPcDZGejl6VEpQZE5DNTBkcDcvaGpQeXc3UC83UXNZVjRjVzcyMk9vSDdyL3grUmN1LythLy84anpuM24xeHRadElCVkNsT0JMNzMzcHZhK0ZFSVl3cWVpMnRyWmN2OS9uL3Z2dnh6bm5EejNJSDNGNytlV1hSVm1XKzk0akFwRUlLZVR5a2J2ZU96TnovQjNQZitHVEh3VmEzdnNvanFQdTh1bUg3aDhWcHUyY3h6cFBuTFpVa25ZaTNtb1VXa0RkM0I3MGIvV252dFJxUisrZGlrUTIxMDFFQ2Npb1JHSzV1YjVIckFYdFZER29TdWFHWTNydERDVVVpWlRFV1VKL2xQUDhhSUorNmdpNms0RVFsTTRnbkVjcmdYVTIwRW0wUk9EQUM0ejFDQWxDaFRjVGRTVmRGWEU2N1hEKzZBeDMzZGVkVHF4NFh6NGNNeDd2MGNrNDllNUhUejU4MS9IcDczeiswdnJuZnZrVEwzLzAwdTJkVmNLZ1ZRbVUzdnV5Q2NQTWVEeTJnSDMyMldmNTNPYyt0MzhwSEFMa2o2cnQ3ZTBocFd4bU5FUUVQbm44eWU5ZVdENTJ6MDhOQjJPMXRucWpJUENvNGlScGQwVXlmYmF5YUNFRVVncThJRlZLWlJ4a0JONEJ0WGV1ZW5sbjh0ekp6dlF0T1N6UEpWbUVxR3Z5MFFTc1pWREMzcDVCTDJVY2Yvc0Myd0pPWEs5WU5oS2RhS3JLOE1wa1JQWHVveVNMN1lBL0w2aU5ROGNTTFQxS0NVU0RTd2U0WnFBS29MQ0cyVGpsb2ZZY0YxclRISTlTWEY0dzZJKzQzWit3dXpjQTUrbjFPc3pPTDNabjVoZWZPbmZteE1NUG5EdjJ0aGN1clg3bTVhdHJ6MzM4aTI5Y0xZd2JOTjV6SHl3MVlJcWlzTTFsd0IzZTh4QWdmMVRzOGNjZjU5bG5uMFZLS1p4ektpVGlaRktxK05HM2YrOTNFVTg5dUR2YWZ0UFlZbjkySTFvK2RyYm5oV3pIa1NKTk5Vb0lWQkxKT05MN2liMXZEbzBEekxNM3RxKys3OVQ4YzExdDd3SmtLb1NncmttbHdPSVplMGZyL0F4dVBxVk9OQnRaVGZyaW1DeUh0ZDBoV3hjNnBJc2RYR0V3Q2thNUlSS2dBekFQanFWU2drUXJ2UGRNS29QMGtzZDdTenplbXVGa2xESVpqbmg5YlozTnpSMnN0U3d1em5EdW5oT2tXWnVxTXRTMXhTTklaOXF0ZHo1NS90MVBQbmJ2RTZ0cnU3ZS84MjMzZk9McHIxei9qUTkvL3RMcm82THFOMEFwN2dSSzgrWC9vRUdpRG8vd3Q5ZU9IVHRHVVJRaXovTW10QXFjcVFjZWZQTGtRKy82a2IrMWxZdXprZkoyZStYeVYxWnV2cndGUlBjOStoMW5abzgvL0IyajBrK1h4alVadmJjcjExNzQxUHJLYTIrQ3FBaXo0RTZBZE42TFhydFZuK3JGajB2cHA3Uld2cXl0cUNwRHBCVHQrMlk1OHNnU2NhTFFVcUs2S2ZtNFFxM24zRDZSb3U1YndFOHMxbnZRaWlpU1JCRmdQTXFHUk4xTDBZUmJIdTg4eTJtTDk4K2U0ajNUcDBncmVQM0tMVjYvZkpQZDNTR3pNMjN1T25PRXBTUEx0S2VteWRwZEJBNVRsbmhuUlpKb3BKRGduVzZuZXViWWZQZitVNHZURHgvcEppZE1hYXJWdlhIZkJ3N1huVW9yWDJ1LzNhOGZlcEEvTFBZYnYvRWIvTXpQL014K3gzeS9jaFVCK2ozZi9TUHY2bGZSZzJ2REFmZWRuRnE0Ni93akR6MzcyVjk4dzN2bm5Hak5Ua3JmR1JVMUNFOVJXZkJlUXp3SFRiUVQrbkxXUXlYQWZQYnEyZ3YzOUU1ODVtUkwvWEJ1akdyRkVSckZzS2VJN2wvQVpwcTY4dGpjZ0xEb3FZaUpIcEJkT0lhTU5YVnR3cml0Rm1BZGJtTHdlTFNXcUVpZ0kwVmVHWHJFdkdQeEZCZlRIbkZwdVhIMUpsZXVyK0JNenRIbEdVNGNYNkxYNjZGMWpKY3hTa2ZvU0pPa0NUcUtLY1pqeHYwaGsxRXVodU9DemEyQkg0NnIyTlQyM0YzTDdiTUw3N243cVlzblp2N2JSNTY3L2o5VytwT1Y1dlBLbTg5dVh5QmkzM3Y2UTREOEliZmw1V1dlZWVhWmc4NDNFQjAvZm5xTzF0RzNydzNLN3JBMGZtSkV0SHp5M051WGoxMTRadlhXeTZ0MVZhcnhNQ2V2RlhFckNSbTVkWGduMnFGakVaS1E1cURVQ01wK1h1WFByQTAvbEI3cDNoMmIrbkZwSGJXMVRNN09VWFpTVEE3TytjRC9rbUNUQ0gzWEZIR2ljTVlpWWdITzRmQm81VkVkamRRQzR3RXBjY0p4cGpmTjl5eGU1SmhzY2YzcVZWNTg2VTNHazV5VHgyZTU2OHhwZWxOVHBLME9RbWlFbGpnWFFqVHZEZDdYRFBmMjJON1k0ZmJLRGpkdWJaUG5OV21rUlJ3cEVBSXBwWnJ1SlhjOWRkL3kzeng5Zk9yeDI3dmpYL3Y4cSt1Zis4cVZqVFVnRXBEN2tLTlVUY2psdnQxQU9RVEl0OW1NTVlMQVpOMHY3NnI3M3ZiOWR4czE5V0JST21yckdFOUtmL2JvcWJ2UFhYamlnZFZiTDIrTkowTXhHdVYyVWtkWUlPMGtPQVFvdmQ5d3V6TzhjTjVqQVB2TTljM3JDNG44MWNjWFdtZktialMzdHBReFdlNmdLMUNwUkdrSkhuU2tNTjVUVHFWb1k5RTJlSXBJQ1dJRnJvUWtWc2hJZ2draDFobmQ1dDN4QXR6YzRKTlhiek1lN05IcGRubjA4UWM0Y3ZRSTNoUW9yUkZTWWF3bmlkdGdLaWJESFhZM3QxbTV2Y0hLeWc0YkczMzZvNUp1SzJKNVBtVzZrNklqUlpwbHhHbExLQWs0bnowU3lYZU5KL1VENzdoNDh2UC80YU12L2Z1UHZuRDlLejdrYjlwN1pKUE0xL3Vmd2JjTEpJY0ErVGJiaHo3MElhK1V1cE45RzAwdG5UbFhpM1NoTkVPOGRhSW9LcCtrVSttWnV4NTQ1T25mako4Vkl1NTVST1k4MUtYQnR4TlVrb29vN1hTRlVCS2MvSnI0T3h3TzczbHVtRi9qNHV5YVdjam02dW1VUkVraUtaQUlmSk5vNzlmQlNpbW9ja01hU1JJdm1VNlQwQWpVbmpUVk9BbEtTTzZ4TVErNk5xTnJhN3o0NmkyaVJQSElJeGM0Y2ZZaW5abEZ2Q3N3NVFRcEpjNVo0a1NERUt5dnJQTG1hNWU1Y24yZGZuOUlONHM0Y1h5V2gyZTZkTnNSY2FSUlVpR0VJRTR6b3F5SE1SNVQxMkkwR1Bva0thZk8zNVg5aWIvNEFYZnk3aU5Udi9Sclg3Nys4YXNiL2JXdnVTU3FiMmZ5ZmdpUWI2Tjk0QU1mK05xRVVrb3BkYmZUTzZiak9MUFdlbE03VVJTMXlDdkQ4b2x6RjZabmppelhWYTNyc3BKQ1JqZzgxbHFQU0dqM0ZvOUdVUlpYMVhpZlJpWHZ5RzJVVG5YVWZXVHhIWnNMNlZscFBWbGgwVm9qMlM4VkI1QTQ3eW1NQ3pxSkU0UHRSRGpwNlRwUG1raGE3UVNwSk1MREExWEtrU0dzYisyd3NkWG4xT2xGTGo3d0FQUEg3a2FvQk84TFhKV2psRVlvalMwTGRqWjJlUDNWMTFtN3Rjck8zZ0FkQ3g2OGVJTGpSK2JwVFUraGRJeXBEVXJHQ0ttb3l4Sm5MVlZ0S2ZJS0hXWEVhVmM0SXJKV3lvV0x5Y1dacWZieGt3c3pUL3phczVmL3hTZGZ2Zlh5blI2MEFZWTdCTWdmWHR2M0lISjZlaTV1cDFtMzlPQnNlSjdqMHJJMXlKbWVYWm82ZXVLaGUvZEd1NXZXbW9uRHRlM0VVcmRpUEU2Z3UwZTBibmVxYXJSN1IwNnpQMUdvejd6djVGUFRKM3AvMnZTcnJMWWVwUlMyNWRGZTRMMUFLaEV5bU9ZazFjNGpTbytLSFZaSjlpWUdqd1lwaUNVOHBsb2MzNnU0Y1hPWFNWRnkvNE4zY2MvRkI0bXlHWVNLd1pUZ0hWNXF3RkFWRlZmZnVNTGxONjR4R2czSkVuam8vaFBNemMyUXBURktSYWdvd251QjBoRktSbFJWalhHSzhTZ0hDWkZXYUMyb1NrdXIyeVBKTW9yQzBKdWU2VjI4Si9xdVdLbkZkcEw4cng5NThlb1hyWFYzNWlEN1pXQi9DSkEvekVpUlN1YTFrODQ2aEFpY3B1R2taR2RZMEVsNytzUTlqOXg5OHpmLzNTMW5pNkd6MllJRHBKSlk1NFZPdW5OUjNKbGpzbjY3YVRiNnBzcVRuSGg4K2U3RjgzTS9abk0zWDVmR2d4RE9lVXJyd1hxOEJlRTlVUlJPbEJBQ0lUeldlSndEVDBqSUo3WEhZdWw1d2FMMDdHejJLWXNKOTE0NHc3MFBQZ295Q3p6Z2VvS3ZLM1FjWTYxaGIzT1ZyYlVOZG5aMzZmWVU4MHRIT0hsOG1abnBXVWFqQ2ZsZ0Y2RU1Xa1lvQmZsd1RGNE5LRXVMY1JJaEk0eXhTR21weXB5cUNGN0ZsbU9jcVhIZVUrWkdSc2dISHpzMjkzL3lkZjMvK3JXWGJ6ek5ieFhWL24zMUpJY0ErWU0ycVZGYXlVZ0psQWlIc3FvTXU2T1M2VTR0bDA5ZVBJdjNYekxsY0VJeXpWUXZvOWROUkZrNVpOenB4ZG5VTkhzb1FqTk5BcEZVb25YNjdVYy9xQk45ZnJnenhsa3ZwSko0QjZaMlNPUEFPSkFncFF3TlB5RVFVbEI0TUxuQnRqVE9RMjFDd2o0dEk5SUtkcTJsTzVWdzh1NjcwSEVMNXdWQ1dJU09zYTVtZmVVMm03ZXVVd3ozOEFLV1R4eGxidms0YVJTakJPU2pQbkdTRWMrbk9PY3dkVTJSRzZwYVVkY1c2NE5UczZiQVZCWmJneFNPTXEvWXkyczJOdnFzck8yd3RqTm1hQ3dENzZVVC9vR3BoZVM3SXkxZnFvM2JyK2J0ZytJYjhTUy81ZmVPVDhVY240cjUvSTNSSVVEKy8yQyttU2R5MWxiV08xc0w3eEhHSXB6SEMrZ1BTemFUQ2UzMjNOekM4dm1qcGh6c3BSM2xqeTkxeGZ4TWl5c3JmUisxMm1sMzd1U3h6ZFV2eDgxRFZvQSsvdmp5dVdncWVYdlZyNVhKRGJaMk9OZWNBK3Z3MW9lZWhwSklKWWtqaGNIaDZzRElyY2VHdEdNZ1ZwVFc0MnJMRVpYUkVoSlQxN1I3R1ZFVVlmSTlkTklHRk1KT3VQbkdhOXk4Y3Awa2h1N3NBa2ZPM2t0MzRRVEtXOHJoTnVWa2hLMHJWQlJSR3lpTENtTTh4WGdTY2lHbnFDcUxjelZhaHM3OTNzNlFLOWRYdWJIZTUrYnVrTzI2Wkp4S3hId2IzOHZJaFJCdVVvdHF5NzV0NXN6MGc1dHY3anpyUGU3T0sraHJBUE8xd1BCZjcrZnBUUE5QZnZBMFQvelRsdzRCOGdkbGYvM3YvVXYreGYvanJ4TEE0UjNnK2p1YitkN3V6czNadHFuVFJPdktWRWpuS2ZPS3dUQW5tMjIzVHAxNzh2U1ZOMTljeitidUx3U2tpWmFpcWkxUkhDZHpSODdmZCtVbCtiSFFSQWNWeVdqcHZ2bDNLS21PMjdyRUdZZTNEcVZrK0ZtQWlpUmFTWlFVWVMyQ0RmbEhJTWtLYkdYSlJ6V2Q2UVRyd1ZqUERKbzZMNmxxeTF5YWhDVGZHN3dwRUVvejJ0MWszTjlodWhlVFRNOXc1cjdIU2RJZXlBeGJqMUU2SVdsSENLR29pcHd5enltTGtySXdUV3J0cU1zS1U5YU1CZ1ZyTzMwdWIrMXdhYmZQcHJUazdRaHhiQnFWeGhBcmhBRGxJS3NkTG9zUVNwNWRVdUtuVkt6K3hkcXJXODk0NS9kN1RTVmZUVXU1MC9hQlpMK21oK0p1N3BYK2UvLzMxL3hoaVBVSDZ6ZzQvL0I3eEJzdlB1MmJXODU0Nyt0YjExNytTbXZ1M0hxV3hNZUwwbERXRnU5Z25GZmtaU2FtRmsrZnNDOS9kbFc0YWp3WVY5bnBFSTRKUUUzUEhUa1R4NTNacWhwNGdPTVBMNTdwTHJiZmovR3BMU3pXT1pKV2pJNFV6bnBzYWFseWc0NFVPcEo0NHpBVGkzVWVxUVZDQ0ZTa0tFZUdQSzhSU2hLaDZYbE5mN2lITVk0a1M0bVM5djdpQlV3NVlYTjlBMnNxa25iRzBidnVKVWxiZUZjMTk3Skh4aG5TUzRST3FlbzF2TTl4eGxCTUNxUlNDRy9aV04zaGpkdWJYSE1GdDZSaGQxcFJMYy9pWTRYeW9TWHF2VWY2a0Q4NUFUSldDQW5KZElaUThsRWh4RS9yZHZMdlZwNWYvWml0YkV6Z2NKbWdvT0x2cUpJSVBEancxbnNzYi9HN0RPQUdoYjJ6Tys4UEFmSUhFbGZGTEorOHlPdHZBY1FDNXMyWFBuM2wrTDBmdUpSa2k4ZXpKS0kyanNvWTh0eVQ1eVhkcWFXbGhlV3pzOFZrZmJjMDgzT0RjUVVnalBOMHA2WVhPdDNGWXp2Ymd3S0JuRDQ1OVpEVSt0eGt1OEFXQnEwVVdTOUZaUkV5MFpqS3NuV3JqN1dXNVhQenpNeTJRQW1VRnMydUtwQktVRTRjdysyU2JENUJPSWN5c0RjbzhONkhFcTYzQ0JuaGhhVHNEeG4xOTBpem1LVFRvVE05SHh4a25WUG5XeUExTXAzQ21KcHlQTVE1ajNPQ3FqUkVXakxzVDNqbGpSdThtQTlZbTR1WlRLV0lMQ2IyQWxFWmJHbXhsY0ZHQ3RFUUxtWERzSEhPNHlzSEVoRjNZckR0ODg3eFV6emczSzNuVmovaG5XOEJsUmJZSkZKb0tVUlJPMitjOTFJS1d4bC84QndnVEJwN3FQd2RZTGt6MFQ4RXlMY1ZJSktxckh5Y3RFU1pqL1k3M21iOTFxWE53ZmFOTDg2ZlhIeUhqbFRtclE5RmZlL0p4NFdmYWsxSEMwZk9MSzlzck85YTQrejZYcUdMeWlLVkltMjNXNjNPN05MT05tdFR5NTJwemxMN2ZYbS9URWRiT1g1Y0UyVUpVU2NsbmtyUWFZUlFrblM2eGNickc3engyV3NzbkpuanpIM0xKRW1FejJ0azVaamtGWFZwR1cyVnlKNG1pUlE0aUNLRnRaNnlLUEcyd2xtTGpGTHl3cUMwd0hsQmQzb2FwU1Q0Q0s5cWhLL0FHMXdwcWN1YUtzOHB4bU1tNHpIalVjN2xhK3Q4WlhlSDIzT0t5ZW5wQUFMckVUNFVGYlJTcUFqTXVFWkxUeTNsUWU5R05DMTBHUWQ2REFwVUp5S3o2VEhnSit2U0tuZHQ5OFg3RnJPanAyZlNjNzFNSDQyVVNNZWwzYWlOMzh0aW9mY0tjMlYxV04rK1BTZzNYbDNQTjMyb0FsYU41OWtQenc3Nks0Y0ErVGJiNjEvNUZFTEkvZktqYVI1Ry9aWFAvc0xIM3psLzlyMlM3dHNsSGlrUUVrRlpXekV1S21hUDNuTmk1ZmFWNTQwcHpMaUl0UE1lWnl4Sm5LUXo4M1BIY3Q5V1UwZW5IeHZ2VkJlOUFWZDVoTkpFdlF5eUNLdkQ3U3NsWkwyRWt3OGVaZjIxZGE1OStUbzJyem4vK0dsd1lLM0gxbzY2TWhTNWcyMU5NcS9KRFZnSFFpbVVsTlJGanRReGVNbGtOTUtabXNwSzB0NDByaHdoNGlsazJpSFNHbHRPS0VkOTZyeGdQQmd4R2VYY3VyYk9hN2ZYZVVubkRPK2Z3bWNKMm9DeUR1TkRzY0JKRWQ2VEZOQ04wZDdqdmFQd0h1azh6ZlF2WGdxVVZqanJrQnFTNlJRWjZiTk9pcDg0UDV1c3ZLdWpIdFNSYkVjeWZQREM0NVhIUjdGRVExVjdOOWd1N0tYYmcvTFRYN2d4L09SbnJ3MnY4ZFVhY1FkbDQwTzYrN2ZSbnZ2TWY2RTdzOFRlMXEwN2xuQWlRZWpoN21yUjdzeFg4OHYzUElLVTdjcTQvWmtrcElRMGJVVjVmM05raVdTY1RYV3N0VGlna3lWaVhMdzByMmYybmtwbXV3OTdJZU1vaWhCYW9Wb0owVXlLN3NUb1JLT2tRTW53dkwwU3BOTXRiR1c1L2RvSythUW1tMnJoYWt0VldJcWlwc29OWm1LUXZaaHo3UzdUbGFNb2M3cTlqS21wSG5IYUJTbFl2MzJiY2pRZzZVMXg1T2d5UWlhSXVCWENMQ0h4dGdRWDhxckI3aDR2djNpVmp6ejNNdGZQSk5pTDh3aXQ4Q2FzMmhGZTRuelRseUY0Q3VkOVV4Um9PajE0dEF5L0x6emdIZnNqWE9GakRjZ1JXczZLU0owNjdtd2FXeS9yUUJZSVluWUM1WVFRU29vNGtxTFRpZlhwSTkzNGlkUGQ1SjZsZGpSK2RUdS9iZDFCZUdVUEFmSUhaT1BCMWx1SjRsc29FUWdSN1cxZDN6NTY2a0puZXVINHcyVlp5NnF5NGNFTGlPTllLT0VZRDNkR1NlL0lkRkhWUWtoSkpJVWFGNWRtVEdlbkU2V0pTTkk0Q0VnamlHSk5OSk1TdFRTeU9WQ3FPV0RlZWJ3VWRPYzcyTXB5NDVXYkdPTlFPcWFjVkpTVGlxcXNLQVlGVm5uT0g1dm5qRTdaR3d4cHRSSVdseGVRT3NJWXgzaXdUVjFNbUZsY1pHYnhHQ0taQW0veDFRaHN0VC9Fem5nNDVKT2Zlb0VQUC84SzdzbEZXaGZtY2M3aGJLaWdPUnNVR3FVUURYcy81TlhlZTdRUUI1UmxKVUNLb01ySVFkTHVEcFkxZ3NkNVVGcFNSaEg5MnRNeWhrUTBja3JOaCtvZHdndVBjVTB1VTN1RjVWU011RytwbzFkZTJTeXVON25JUWNKK0NKQS9JSXZpVEhnODNydm1vUWxabDJPZlpVbi8xRjBQUGlCRnVsaFV0YmZXQ2UvQ3ZIY3JhOGZqL25hSmJxVzFGVXJIaWxoNkJ2bUwrSFRieDBrc1ZLU29mVkFkaWRvUmVqcEJhZ0YrbndEV3hPNUNvRlg0dGM1c2gzS1FzM05yTzNpUFVVazFLaGp0amRpOXNjM2c5cERqZDg5eklXMlJqd3U2M1JZTGl3c0lCUDMrZ0x5L0E5NndlR1NST092aTZ3bDRoNnRIQ0tueHBnUnZlZUhMci9LZlB2VXMyWGNlWS9taG8zZ2JCT2JNd2JWTzR6MzhRYVVKUExMNUVnVDZydUF0RlJYWHFGRWVLSWs1djE5Y0M2VmdKZG14c0Y1WTV2RzBBT3M5Vm9UdisxZVU5MUNWVHV3T2ExOVZkcVlkU1RsMjd2TnJvM3JVQU1RQzdoQWdmMEMyY09RQ2RUVW1MRjk2UzVsOWMvWE55YWt6NTFsY1B2MVlZWHhTVktiQkQ3UTdMZUhLa2JNSUthSXNzdDZqSkJoNUNaSHRDSjNHb0JWZVNtUTNKbDFzMGUybEpFcUVYb2l4N085SmNLVTl1STJqUkJGSEVjWHVoUDVtbitIV2dPSE9pUEhHQ0xOYlVxMFhHQzE0Nk9nMHVuYTB1eWt6OHpNb3FSaVBSMVNURVZWdFdEaXlpSlNBTXdpVklJVEFPNHZKaDJ5dnJ2R1J6NzVBL1dDUEU0OGRwVElWRGtGbEhNSjVsQTlDZENCQ2g2anhISExmUytBRFJIemovVVNEQ2hGeUVkL29BOU9VZ3hWdmhXbVJsZ3lSYkJuTHJLMUpuTU0xYk9aUW1Rb3o5OFBjTUM2dGFHdEZMNDJHRzBYOWlUZDN5aDNlR3NvNjlDRGZUcnZyZTA0UmQyTHluWUtzUFUxUjdHS05FVzhGemtqdnZjeEhPN3Nueno2d21IUm03NnBxcDJ3emRhNlZGRmtTcVR6UG5kY0JJTUpickg0RDJlc2paQ0FXNmxpUmRtT3lia0tpRlRpTHN3N3FabHhYQ1p3UDRndElzRjVnQzBzOXJwZ014Z3gzeDVqYzRFMXp3Mm9ZRHliY2ZYU2FvNzBXRGxoWW1BM1NwR1dGclV1a2RDd2NQWUtPTTJUVVFlZ0VvUVRPMU9BTW4vL0N5N3lpZGpqNzNpUGdIWGx0bVJTT3VuYllNSVZGcE5WQnFPV2NiOGJBZ21mQk9SQnY1UjJpR1JNVGZwLzVLWkJDTnNBSlRBSG5ITFczR0dkUUVtcVZVcHVVU1IrR2VVbW1QSXFneUZMVmprbHBpWVJncVIwak5KZWYyeHA5N01aZXZkY0F4QUR1c0lyMWJiSno3ejdHcmFkWE9QYSs0MnhmMnFYU0szanF0NjZ4dHhpbzl2cWJMK3g4OFpQLzhiL2UvKzYvZHJHVnBPZU1jeGpybUJRVnZTVFJRbWlVRXQ0YUliekxJUjZqVTBWVmh0czNpaVVxVTBnTlJWa2hyUVByc1EwWlhncEIxSFNqVVFwYldDYmJZNVNTSksyWVZpZkMxQlpqUTF3ZnhRcGl4eGV1clhQdjRneG1WREljbDB4MVVweXplQythRy93Z3VVSkVHYTRlbzZLRXdjNHUxK3dlSjk0NVJ4STVqSUVJU1NRZEtFbnBQSU5KalhBV0lSUyttWElNb25ZZUlUeGVOaEdVb0tsdTdXZnNIdXRkWUJFN2o1WVJyYmhGSis3UWlqSzZjWmRNSmt4SFhSYXpPVktUc25OemsydHZ2TXJubnZza3g1T2NFek1aMWppVWcvbDJSQ3RXakFxM2NYVzNHdkUxNU1kRGdId2JyTE9RMFpwSmFDMjEySHhwVzdqYU1ydzlFdDU5MVVhby9TOGhoTkF2ZituRHQzb0w5L3o2cWZ1L1o5bllxRGVwTEhsdWtGWktIV1dhU0lPVW1NbHQ1UFFBS1JVNkVkUVdpRFV5a3NqOUE5WGtybElJRk0wTkxZSjJMaDZxUVVrOUx2RUNJcVZvdFJMcXVzWlloMUNTSkk1cHRWT3VUOHJpMWMzQjRQNloxdXoyN2xCUFQvZENpS1ExV1pxR015UWtRaW1FU3BBb3FMWjQvZklWekNuUDlHeEdXYjRWRGlrQlVrdVVnMUk2Q3V2d1hvWWVSNU1qaE1SRElpeU5Wd2tWS3VzdHRrbk1PM0diayswbHpzNmY0ZVRVY1k3MWx1Z2tiU0tkRUNtTlJGSVZKWFZWVTFVVjIybUhWcVRaM2h2eDlET2Y0dDVCeVlQTEhlWmFDZDFFb2FVd2c4cGV1ZDJ2aDNma0g0Y0ErZjIySC91L1BNb3pIN25KMWs3QjdaZTJ4V2dycHhoV0lkOFVTUHhiYytrSVlueFltUloyREZxKytMRi85WFNuTzNkMDl1UVQzMTlVZVl3ZTRoS0l2SmNxbFpoY1lNU2J0QmNzQm9WMG9JMUhwWUlrRWdqbnNkYUhJUkVsUW1HL1lVbjZoZzNtaktQWW5TQzB3TmNoNWxkYTR3QVZDNUlrSmtsanNrN3FYTzIvOE13WGIzejU5THZQL29XdHpkM2xvOGNXaWFLSU9BMUh4MW1MZDZHMGl3Z2N3ZDJOYlc3a0czVFBacGphWTUzQzRTQjBKRERPTWJFaHAzQU9uRGNjNE1BZFZQc1FUZFBEWWxETzAydDFXVzR2YzJIaEhPY1h6M0dzczBSSHR4QlNraGNUOHNrWWFUMVNTMnBUWTF5TmNWWEkrWnB5M3Ztelo5amEzdUpMTHozTFhkTXA5OHkxZkN3Rmc5bys5eHMzQnAvdy9rQVU0ckNUL3Z0cGNhcWF1RG84MzczYlk0UkFPT1BFQVNqQ3VZMkZFTEgzUHNHakVTUnhPK3JOblowNk5YKzBlOC8wa2V4a05QY2JNOUhDanAyZG1ZRHNvNVRCNWxDWEVhcDJ4UEVxOVZwTnJRVjZPaVZLTksxTTAwazBWV2twbXVRbWlGRUxuUFdZL1lxUmcycFVZeVlWVWttVWxFaXR3cTVCS1pCYTBVb1RINmNSa1ZiWFY5L2MvdVhydDBZM0x4N3ZMYjY5SGYvUTdzNGc3YlJpbkt1b3locFRHM1Jkb2hJSDNpQnN3YVdyMTlsc2o1aHJUVkZXQkprZ0w1QmVvRVE0Z1E2UEk0QkF1bEJsQ3ppVENBbXhsbmpuY2M2eTFGbmd3WVVIZUdEeGZvNVBIYWNidFJFSW5IZFVkWVYzanFxcU1IV05OUVpqTGRZYTZySmkyQi9RMzl1bHY3dkg1dVltdzhtSWswZVBzcjU1RENFblB0SENqNDE3ODdNcm8zLzVxZXVETjV1UXQ3N0RneHdDNVBkcVdTZkNCSEYvZnYwL3ZDRUd1eVhlZWVtODMvY1ljZk9WRVBaa0pLMzVySFBrZ2RtelJ5N01QclI0Y3VyUjZabnNiQnlyQlNWRUtpQXk5bVdWK1JCaVZKWEh5RER5ME9vNWxEVGtlNFo2VUZCR0kvUnN3dFM1ZVZwVE1hWXVpSVFJZ20vT0k1dVNxck9nR25uYlltZUNzd2FVd0JzTEFxSllJNTBpVGpScEZvc28wY1ArK3VRL2IxelplOEY3ejMvOTFPWC9mR1NoTjdPd3RQdmRXczFLVytUQzJ5cGNzODVneTM2UTlCbnNjbVZyRlgwaEN2UHZzZ0ZoMDkrUVFvUjhTRXJxVUxiQ0dvZTBvY3FrSWxCU0VFdUxsRFYzTDUzalQxLzhTeHhQam1LckNtc054aGpxdWtJSU1NYmduYWN1QzBiREVlUFJtTHF1cWF1S3NpaW95cHk2cmlqTDhPL3JTSkdrS1ErZHU4QUpjYzJQVFhIbDE2OE4vdW5QdjdUMWpBaDhySUszK0ZpSEFQbTltdGFDaytlbnVmcFNXSUN6Zm1zazhGNTZmNkIvdGI5NU5nSFN4WXN6aXljZlczeG8rZDdwOXk2Y21IcThrOGFMd29uRUd5ZFVDSXU4c3dCU09CZTRwMEdSM1NPMVFscUxpa0duSGoxUkZMc1RKdHRqYm0vbG1BZVhpR1l5bEJRWTY0S2VyOWd2cFhxY2NOUmpRejBwUVltbUpCdG1STHlVUkVLUXBoRnhHdFdUUWZuTHQxL2UvRlh2L1JCdzExYjZlLy82djcvNEw0VFNyWGRsMlR1bFEyTXRSWjRqa01oaVRFdEt0dFkzV0JudDBFdmJHT3V4emFZNGlTVlI0bUNWUWxDS0R3bVpEd09Qb1h2dVBFcExraGdXT3ZQOHlZZi9IQmZuSHlBZkRwaU1oMHlHZzhEd2RaNjZyaGdOaHZSMysyeHRiRkZYTlhWZG9iU2cxV3BqaktHcURQbWtZRExPR1E5SFRDWTVkVmtUUnhrak1idis3TFhYL28vLzhPTFdsd25BS1BocXpTME9BZko3dEtTYmN2bUZiZkFJNzVBZXJ3NjhoZ2o1Qlo2a05aZk9QdlJEZDcxOTZlTE1EMHd2Wkk5MlcxRlgxbElLSk42N2d5ay9oUmVoTWhOR1lOMStCNHltOWs5b1pNUnRqYWxDQjV6U2tlOU11UG5NVFdiT0w5QmU2bUliVXQ5K2VkUTFSTzl5V0dDZHhTdUpyeXhTQ3JSV09BODZWc1JKWkt2U2ZuYjEwdll2RktOcXF6azBGbEN2WHR1KzlOOCs4ZHIvMm1zbmt3dDNILzJBcTNXeXRUMWljUTVhM1I2dUhMQzF2a0xmRzZaVldLOVExQUx2UWprMmRMdERtZFc3WnVjSXdhdVVGdXJLNEtXbWhTYUpOTys4NTN1NHNQUW9lSS9TZ3JyS3lmTXhIaWp6a3JXVk5YYTJ0cW1yaWppTlNWc3BrZFdVZWNuTzFpNUZYbEtWQmM3WjBMRzNnVzhDbnRwWkx0ZXQwWFA5OVBZZFlWWDl0UW42SVVDK1JXdDFJMXpocVF1RHMxNEdvcW5YZDNpTkRFOG10V2hmZk8rSjh3Ly9xYnYrYkRLWHZrZW5ha0Y1RDFaNDV3VmUrRERZNUJxbW5KUUhtV3B0d3EwYWFVa3FZM1NxMlBVNWc4cWhGQ1NKSnRlS09nOE5ORnRhUnBlMzhjYVRMUFZRZUt5eEdPZUEwUGVvQmpteThSNm1JZjdKU0lIellYN0UrMHZiTi9yL2F2ZjI4Qm93Sm15cHRVMjFyZjdNODdkZUcrYjFQLzdKSDNwaTU2N2pzMzk2dHo5cDl6cVJUMXBHMUdYTnl1b21JMnR3QW93VEIrM3VmUTlCUTEwM0RxclM0Y3FnU1cxS1N6NnBFUUpLQWIzWm96eHkvRDFFUXVKY2lhTkNTczk0TW1aOWRZTzluUjFNWGRQdGRlbE5kWmhNQ3ZKeFRsWFVsRVdKTVFaVEc2cXl3dUlZbGhOMjhqMTJ4MzFHMVlSeGxXTnJjMUsweEYxYXlPZU5QeEIvT0p3SCtiMWFtbWtlZXNjQ1gvejRHcTdpVG5EczV4bHRJTDMzYll1bkgvMkJ1LzdVc2ZPemYwSzE0MU4xNVpTclF4L0FPaTlFbzFWVkdJZHM2ckxXT0lRTExOcDlUb1ExbnJxMlJBMlZZcWFiVVl3cmpLNkpFa1U1bG5oandqaEdhWmpjR2pCNjh5alpuS1oxY2gxcmc1cGkyYyt4eGhMV1NUVitTUWlrbG1IV1Fvbis3dTNoZjd6OTh1YVhHMkNNZVl2K0xadnYvb1ZMNjlmLzBiLzl6UC9uci8vd0U1TUh6czcraFkzdFVUZk9NblFyWVhkWXNiSXo1aHdMNEFYZWh5a09aMzNUUFpkNDRTbXN4VlloZEt3dFRFWWwrVzZKcWowUjhQYVQ3MkdwY3dTSHhYaVA4d1lpdUgzckZ0ZXZYR2QrY1o3WnFYbHNiYWdyQThaUlZoV2IrUzVyb3cxR3d6SERuUUY5SmxTUkphOHJLbHRockVFS2dVZ0V0YTBTbDNJeXppSmxKdVZ2SDBZZkh2bHYzQjUreHhHZWUvcGZrV1Rmai9OZWhQVGdBQnhaQTQ3c2ZYLzJub2VlK3NHelB6VzExSHJTT2hGWHh2a29Jb0REQzR6ek9CUDZFOG9IZFpIYWhqQkl3TUYzSmNNYXRieXNFUTBhcFJOWTU4SzFIaXVra3BpS2ZlbE9iR1dvTmxwVU94MUVidzBWR2F6MVZJTWNJVU5WU1VyUlVGWEZmaldybk96ay8zSGw1YzJQRW5Sd3gzZkU1TzZPeGlaQzRLL2UzbDMvSi8vK3MvLzZKLzdrUTZPMzNiLzhsOUlzV1dobGkwelA5RENYYTRxSkpXNEpuQlBFUWlGbDZJWGdISkdUdEpSbkpHdU1EZU85MG5tMEMyR1FyeVdqblpLWHIzK0ZuY2txMTdldWNXdnpOcXNiYTFUYkZVZDdpNXllblNZVkNlTjZSTDhhY1gxNG0ydURXNnlPdHhqbVkvS2RDZjNiZTdUbU8vU21wcWhHQm1jOFdxcFFIYlBPZStlRlRmeWpyWVZzZVhLOTNCWUM1ZjF2RmNRK0JNZzNZVUxDMlFzL2dyTmUrSkNNNzRPakJiUjFvbm8vOEpQM2ZlQ1I5eC8vaWFtNTdINjhKL2VlUkF2aHZLQ3lvSkM0Mm1FTzBPQnhYaEJHSVh5ejdpemN1cmp3NjdLcFN0WFc0eXFETlJZdEJiV1dDQ2tPYm1sdkxNNmRCSDBjbTQ4WjM1Z2lXcnFOblZnd0JxVmwwNHdUQjZkZGFXWE11UHJOdFV2Ykh5ckg5YUFCU0hFSDNlTE9PVzN2UFU0STNOclcwUDNqLy9DNWYvY1RmL0xoZGFuVTMraDAybWRQSHB0aDRibklsN2tWTGhORUtrSjZSYVlWcFhTNHVvVENvdkVCbU1iVGx0Q2FibE8yRXFySzRRdlBoNS8rQ0srLytqTEtHalozdDdoV3JaRzJXang2K2lIZWZ2WnRIR2t0WWt2RDFzWW1iNzUraytjM1htTnR0SW53QXVra1dzVkVTWUlwVFdoQUNVR1ZWM2pqZzVTUXNjTGt0UmRLSEpmU253UmVhUW9yOG11ZitTRVg2NXNKcjFvUjI2dGpVWlZXZUlkdVFxb002UFJtMDltLzluOTkrNSs3LzUxSC85YjBiSHBYRkNvMHdyajlabkJ6NkJGRVNqT3BIT1grSkNGZ1NvZTNBUXg1RmNxZWxmVVVkYUJVNEFnQXFCM1dPa3psTUlXaEd0ZlVoY0VhZzZkRkZIMFhabWp4cHNSTlVrcTNocTBIcUVZZ0dwcTViaUdheEpYWFYxN2UvT2M3Ti9wWG10QnF3bGVMUTMrdHJLZUhBQkpqdmYzU3E2dlhRRjZYVWxUdFJFM3ZWcU11cDFLUnhpMFNtYUpsU3FJU25CZVVwY1Y3UzV4SzBqaXNZcWhLcUF2TFltdUpSeGZ1NDVIZU9SNmF1WWNqYXA0bHNjQnNQVVhQdEhuLy9lL2h2ZWZld1Z3MjJ5Z3hHcnlIaGRZc3B6ckh5ZXFZamUxdDlzWURCQUpiVzB4bDBGbU1tZFFVZzV4NlVsS1hocnFzUTFIQWV5a2o5ZUo0ci95S2Q3NytlcGZDSVVDK1FUdDZwc2ZOTi90VXBiMXpqVUVLZEhvejZmU2YrK21IUC9qQUUwdC9ZN29iTFVhaDNpL3FCaEJoSkVQZ2dGVEZLQmxSVklIN0pCdUc2MlJjb1pVTWg5ZzNxb2NlTUNIMHdIdnF5bElXbHJxeXVNcFNEQ3VLVVlXcGFwelZ0RHZ2d0kxbXFFZGJDQ0doam5HVlJ2ZjJFTm9kNURZcVVZRzBXTm1OelN1Ny8zN3QxZTBYbTN4amYrejBxNXBsZDNxUU83NE9xajB2WDk1WS9jeVhyNyswc3oyKzZ0dSt0WER2OUpFc2JhbEV0MGxVaGlBS0JFa0tPbE1DSFVVa3FXYXFIYU1qZU9MTU8vbVJoLzRNOS9ST0lvY0dhWnVKQUNXUWtTSnhtbklueHprWDZNZzBnMVV1aEczek0vTWN5ZWFZRVczY3BHYXJ2OE5vTUtZYUYzaWxRdGc1THJHMXhWdUxNUWJuRE41N24wMW5id3czOHk4NjQvWlh3WDFWbWZjUUlOK2dkV2NTOG5GOVoyaVZJT2pvU0xiLy9OOSsrUHNmZXMreC82V1ZxY1ZJS2tyakcwbXF3QnhWSW5nRlk2R3lua0ZSVTFxSDh5R2ZLRXpvUjZTeFJxSkNwOW1CZEJCTFNSckZDT2VaVEdyS0lvZ2FWQk5ETmFreGVZRzNMZWFQL1ZuODVBaVRyVlU4TmxER2hZSzZnNGhCdGZmQ1U1Y0NuV29mUlJxL09ycGNYUnU4VUZSdTF4Zzc1cTFwT3ZzMVh1TWd5dno2Z0JFeUwydngwdFd0emFvclJ3Ky83OVRqU3FmdFNLWW9rWWFxbGQ4alRpcVUxRmlyaUxVbVZvTHpTeGY1NEdNL3dYVGNvNnBLcXJxa0tISnFVOUh1dENtcm10TFdsRlZCZjJlUE1zK0pFa1dybFpHbVlZcHhaMnVUcTlmZjVNYnRhOXpjdU0zTmpUWHl3VGd3ZkFTWTJtS0xDbWNNempxc0RkaFdrU1J1SjFjRzY1T25yWEg1MTNqT3d4emtHN1VmL3BzWCtleEhiaUtWRU5ZY3FMUW5lTkxIMzN2ODdDTlBMZi81aGVsNDBWdnZqVU5vSWZGQ29LUU44dzBObmNJM1VxQ1Y4VTMzWFJJckJTcVFESldRMUEyNHZBMEMwNGxRWklSd0tGSUNHVWRNeXJBQ3pkUUdUNC8yekhkZytsMkdLOWZ3UWRrR3NWOHl0aGEzdlFpZENhU3JnZEtobFlpR09aM1IrUDdXWXJRMFB4TjllbnRnZiszS2piMFh3TytESTcramVuV25ON2xUTUxzaDVudUx3T0N4VGtsMkt5ZHFVMUV4b2QyR3dvNnhha1RrRlZXdFVFS2hFTFRqTGsrZS9oTk1wZE9NeHV0azdaU0Y1V1dVVWd3SFF6eWUrY1Y1ZWxOVGxHVk9NY3JaWE5sZ2IydUhpNC9jaDllYXozL2hhWjU3NVFXdXJ0MWtZekxBU2xCSkJHT0JxV3BrSVRITzQ0dTZVUThYU0MyUVNoR2xNVkxLcjVVdVBheGlmZlBaT2N3c1pHTDk1bGpjMFNWUGVqTko1L3YrMHJrZlgxaks3aGNXVWR1UUVDb2xLS3dMVTN3eWxISzFrT1JOUHlCV01qQmNYUmdmelpRS3MwQWk5RWFxT29SVWtRZFRHL2JLRUVaaFBhbUtLWVJEU28vVXl5Uzk5MkIzSmFQTk41dE5WaDd2ZzFBT1FvSHkyRUpRM3I0TGZjUkFlek9vdkc4TktBWWpwYUpvdWFYNUlkMFQ5OC9jdC9STE45WkduOXJhR2QrNlkxVjFjVWRjZnVlT2Q5Mzh2RStsMFlBc0pzYU1KOFlKVTRXWXplZTR1RUk3TUhpOEUwUkNnb016YzQ5eXJIY1gzaFRFU1VTMzEwSXJSVm5reEdtS3F5M2p3WWk2TEZqWlhPT05hMit3dnJsTzNoL3p5dW9sQnBuaCtWZGVaRElxeU9LRU5FbXBmYmo4NHl4bHROZkhHWTJwRExhcWFiVVNWS3hSV3FLMFFpWGFtY0xjdExVcnYxNFA1QkFnMzZETnptZmtvNXBtcmswSlFldzkwVHUvNitRRFIwLzMzbE5iZEcxQ0loNHJNTTRUaWRDUW0zaUhhZFo1YUJ4Q0NDb0hrUlE0WjBQS0lab0dXak9TcWtYWUJZaHp6VTVBaTdBT1p5eVZCVzhMRUVzSTlYN3ExWXB5OXliTzI0T1JWWUVNSENrRU10RUlJYkI1aEZnL2p6eFdJckFONDFkUmVVOVZHNG1RRjdxUi9PbjdUM2UvYzN1dTlTOWZ2Ykw5VEczc1BpVy9hZzdRbmVDNDgydWZVaFBYeGtsYk9xejNPQlZFcHpFZXIwSUZUM3VITVJWTHZaTThmUHo5SkRMQzFqbGFhV1M3UTVTMlNUdGQzbmpwVmI3MDRwZDU2Y29yWE45ZFpUdnZNNmtydlBXNDJ2UDZwUzFhc3hueGRFWmx3aENXUWxEVkJ1czlhWlpTbFVYSUFIMXdlbkU3UmtjYUtXVUlOU005R214TVhyZkdtY05HNGUvQi9zMC9lSjY2ZGtHV0tkVExvemhSMlpQZmNmeWRLcEt6M3VKVlVNeG9IRTZZNEt1c282b0ZXc2lHL2hGV2txbHd2K05rMElKeWhQMWlTb1RWT0U0SzhvYWpwRHhJNy9GU1luSFVkVWxWbjZNdUhxZGNHV1A2cTNodkE1aThRNGhBOHdpcWhBYWNRdWtJWXlwc0lSQjFCTDVHT0VLbldVbUVjOElMVDFsVm5UanlUeTUwNDRYNDdwbGZ1TG82K2UvYi9jbFdBd0NIUUNxZHpBRXozdGtFSVRMdjNKUjNkaDRmNkJwNzY1Tnp0OTdzSjBmbVFYY1VVU0hvZFNOVXJQQk9ra1lnbk9MZUkwOHltOHhpcXNtQmJ4STZ4cGlLNTEvL01yLzBoZi9LQzY5ZVlqUWFIOHlFS0ttd3hpQUZHR1BKQnlXZHVSWXFVaFNqSEFWNDQzQWlYQkt0Ymd2dkxNNFp0SVlvaVpHQlJ1OVZwRVJkdVJlRzI1T1hHMERjMmZNNTlDRGZqSldGUlVnaGZHRG9ha0NkT05OYm1EL2Fma2dJRWNkeVgyYWdVY3Z3VUZ1UHNTQ2N1RU41UTJDdGE2UnJRUHBBMjk1L0NKWHpDT01STmhBTlN4ZlVPMXhEL1ZZU1Nuc2Z4ZUF4aXEwQ3FqRWVSMUZNbW42SkJLbXczaUdsUXNvb3pIbkxzSTlEUkVPa0dpR3N3Q1FLVDJEOGV1K3gzaEpBNHFtTU9kdEtvNTk2NEd6MzNzRTQrOUR6Yis0ODc1dzNPczdtc3U3c1R5SEVROVlhaWZlUjl6NXp0bTdqZmVXY3JZYnJkZXRqLy95bFhtODJJMjVKcElMajkwelRXY2hvZHlMTzNEWEZ5YVh6SEd2Zmh3aHZONFNDVWpHZVZIenM2Vi9sVXlzZloyOXVRcktjVVZ5dk1ZVU4vWXZLNEd1THR5NklMZ3dMaHRKRDdURFdIR3pnRlJKc2JZaGJNU2hIVlZwMEZJTVVFRFNLaFZES21McCtwcHlZUWVNaDc1UWVGWWRjckcvUW5uamZVYjd3aVpYOU15NTlFMkk4OGQ1anA1S1dQaExKWmxsbE14V1Y2aFRyb0RRNVNnaTBoR0ppOEkyTXpYNldLendZNjRpYXAxRTVGMXE1M2xNYkZ6cS9CTnFKeCtKOWk2cDRnTjNOYytTN0JiNHU4ZFpoYmNIQzBoVGprYU1xeXlabjlsaGJoWkt1VjRGU0xzR0lOWndkWWFzT1lycU4xS0d6N0J1UFo1M0Y0NFNVa3NyNXFVN21mMmltTFJabk85RS8zQnBVS3pySkhsUng4aDFDcWtWcHJmZDRzUysyUUFNMDV3eFY2ZGxhOFFjMDl4c3ZyZU85SVc1RjlLWUZNNTJyZk9yZVZSNTY4RjRXWm1lNDkvdzV1cDAyWDdqOE9WNFl2UUF6a21RY2svVmloaTJOSFZYWXNwbXpENTN3VUNXc2FzeHUyTVlyVFBEUUVCcXNpTEJYUmNTU0xJdUNWNUZoMDVaUUVpWGtUVGUwejluSzVsK243M01ZWW4yalpxMURSekowejkvYU02aVBuT21kelpKb1VYalpEQVVGTlEwdEZhT2lDcU93WG9SVkJJV2hsZ0tMSUZZeTFPKzlSL3ZtQVRTcjBXb2I2Q2ZTQ3B4emVPUHd4bEtadTlqZWVwemhacHRpbElkNWp0cXhPSi93MS8vbVgwWW5VL3lELytjdnM3dHhNNFJiM2lQMkZVT0V4OW1hc3RwaTdGK2hXMFhoZFhzWmRSU2h4bVhnU0RZTVlPTkRMcFJJeDNoU2MydXI3UFFucGdQTUpIRjJieHlsTTg0Nzc2d05taVBlaS8xNnI1QWlyRlhiRjhCVENvRkNPeGUwcmlKTm5qdkdnNUtiTjUvbXYvL2FyNk9Wb05OdWt5U2E1TGhrN3U0Wk92TWRldlBkb0RNOGsxRnM1cUhYRXpiOUJDK3hMLzlUV3laVlNZd2tVakZSSk1NbUxjQkxUeWZPMEtsblpNc2dBbUF0N1RTMjA3TDc5STNibTI4MG9WWDEyL1I5RGdIeU85bFAvcDFIK2R3bnZvelNXbGhqN2h5WmpYdWRaTFlkSjJsaGJKallhOVF5ZHNzeG95TGtzNkdjMjVRV214UTY5bEJXRmxTb2NPR2JHOUdCYUNTVnBYRm9aeWhxejJEd0FJTzl4eGxzU3FwOGhLa01GQlhlOVBuTFAvbDlmUENIM3NYLysrYyt6ZTcyWnBoOEpVS3FzUHRQS0FrNlFyZ0p3OGxyZURYQzVGMWNaUkZLc2hOM0ViZEhMTXlxUmo4cjBNK0ZrdUNGdUx5YTI5Mnh2V0t0TjFMcDJTaE9UeXV0SStrZDNqbU1DY1d0TzFRand3MHRCRUtFaFo3R0dmWTFYT3Jhb3BSQ1JTa3lVempieHBpYTdiekU5bk5ZYzd6eHhYV1VFa3d0dGNoNk1kbHNpMkluZE1GMUZQYWJoRG1BTUFLZ0k0VTBrakt2VVlsRVpnbTJVVWNwamVHWTdGQWxFVVc1eTJ6U3BxTmlzaVM3dkxOZS9HcC9QQm5jNFQxc1lBZ0k3OThTMWpnRXlPOWszc1B5MGJPODhkSjE4VFVsempoU0lyRUU0WUZtZVJPandqVGlHODBPanNwaWpRT2hTSFh3RXJZd3hGNlRKQm1qZkJ4SWl6NlFGN0VDYjJxODhSVDVFVFkzNzJKNzh6VEYyRkZYT2Jhb2tYV05INit6bFZodVZRblB2YnpPaHovOExNNFV4RW1NakxySXBJMU1FcEFLZ1dOci9WT01xK3Uwc2hoYm1hQjRVbGs2eDZkWnViUkJPbmJFU1pDZkYwaTBGOXplcnZ6V3dEZ1BIZTg1cjZYeWNaSWVpNktZMmxSNEVUeUNrQUg2Z1pscmNTNTRzS0JPSWxCU0hpaWdlQi9XWGtNRlZRaDNRQkJGQ1ZHVTR2RjRGOERYMzZ6WVc1K0FIK0tzUVFoSEZBZXRZYTBoeWpSSlM5TkpXL1I2YlVibEVBRVlaNm1jUlF2RmtXU2FaVEZOMVBXYzZjMlNLdTM3UGkvWHRnZS85b1V2di83U0hld0JFMm9tOG9Cd2RnaVFiOEFlZTk4TXI3MjRKbnhRRlpCNHJ3RFY2czdIcU5aMGFjMUIxOXdMaVJJU2hhZHVWQkt5U0dGa2tPYnhsY1hXRm9Sa3JqZFBsS1JNUmprbXIzRmFoVU5yYWlvenhlN2VSVzdmT01wd2tHSnJneWxycUEycU52aDhpNTJ0WjlucGFuN2xOeDdpdVk4OHkvWFhMaEVsS1RLYlFiUjZSSzBXS282UjNyTjErM05zNzMyQktMTmhRckZwbEExM2N6cWRtR3g1aXMzYld4eGIxRGdjc1pKczdkV3M3ZFRDQmZiNXU0Q0h3TmZBclBlT1NHbDhuSVVSV2htS0V4S0JzaWFFaHM0U3RJUTliai9rdzRjOGJEOEQzczlkOEFjLzc0c1RDeW5SYVJaMmVqVGV5bnVIc3haVG04RHBHcFRvcUdiVXF1ak90aEJTVUZtRHJDVkw4UXduMnZNc2RhWkpsV2FveHR6SWQveU9uZGpkVWY3UmE2OXUvSEp0N1FGaldZQk4wOFNmWEY3MGI5eTRmUmhpZmFNMk5YOFhSWEViNzliRG1saUVFbExLa3cvKzRHTWp0L0NPMnI0QlNJeURXQXJha1dLVUd4SWhpVlFZR0pMVzRYelF1RUpJb2tSVCs1clJJSENMaEFSckxKTThwdDgvdys3V2cyeXV0eG4yaHppZjQ1MEFZOUhPNENZYjdLNS9ucTI5NTRrWHZwUHRTemZZM2I2QlRqcUk5Z0swMnVnMEltc2xSTXF6dmZvMGEydS9pb3hHU0tYUlNwSzFFa1FrbWQwcW1COVBXSnBLcU9Rc1UxbkVTRmh1N1BUWkdCakt0d3FlTGFBbGdOb1pjQm90TlltSzdpZzhoQTZSVmhxaG9UWjE4Q3hlWUt3SnZDOWo4TmFFQTAvVEZHMm1EUGVCNGZkVEFCK0FJZngrMzE0Z3ZFYklDQmszRjVLemVPOFpEY2VVa3dHblQ4MHpuL1U0MlZzbWt4SEMyeERXQ3NGMk9YSlh5NTFobmJ2UGJsemUrNmZWYm4yN1lRcnN6N3U0ZTA0ZTk5L3g5c2Y0eC8vMkZ3NEI4bzFhVmZTWURJL2kvWnNpa04yZGFuZG5WVy94d3VNcjI5bnkwdkNxYjdlczhLNFJEL0NHVEVzU0ljaXJjQ3ZHU2lQam1KbHNsdEZrUUdFTWU2TVJ0WkhVVlp2Qk1HTm5iNEdkelNQMDkyYXBja2RaakxFK3FOUUs1NUE0NnNGdFJxUGJESTR1a21RUHNjaFI0dUUyb3IyQTd5eENraEJGbm5hblJScVZEQWVmWldmd01XUThKbzRpVktKcDlUTGlUb3hXa201ZUkvZHlJcTFJc3hnQm5KNWJaQ2puR041NkU5K3N5VkFIWFVDUHF5dU0wcGdtaFBFRVlRWXBRdjFJQ1JseWtFZ2VLSTdvU0RlU3B5cVVXZ0ZuYktPREZieHEwQ3plOXlaaDVjRUJKZC90Ni9idTF3bWJUbE1UMmtrZDA1YUNKNWJQTTkzcWhDYXB0MWhiSTRYQWV1dTBrVi9adlRINnBjSDY1TFA1c0xwTllDem5RQ1dFTU41Nzk5clY2LzVQZitEZEhDYnAzNFQ5bGZmL0EwN2Q4OGhYSlcxU0tUVTlsU2Fqd1YwOC9SbEh0NzNON0Z5ZkpLbElZME0zcnBCRTVHVk1WYVVJRkNjV2pwR0lMcTlkdThwS1g1TFhMY295WmpLT21ZeFNqR25qak1QYW1zcGFqQSszYUZDYWM5anhMbFBwaVBkOHovdjQzTTBZZTMyRnFCaGcyMjNvenFPMEpJNGdqUVJwbkRNcFA4bWdlQWF0S3BJNFFrV0twSnNSWlhFUWJoTmdyYVYwRUx0UWVURE9VZllIdlArQmgxbnBHeTY5L3VZQmh5UnErdk4xYmFsOWdmY1dKWFVqR0IyVVM0UlVZVWxvbzJTU1JqcHc0dDFCK1JqWlpPdGVTb1FISlNLY0RJdUJYQk9XZWU4T2NnQnJBN21RcGtJbWhXeENyaUExcWxUbzVVUlNFUW1KTVRWYXFVWkFMNGlXS3FtTGZHQS92djdtM3NkNGE0eDRzZzhPS1lWUGs1VHhKT2YvOXMvLzlTRkF2aG43b2IvL2FiNzRuLy9QZ1JJYUJvM0VxTDl0dHJkV3Q1TFpleGx2bjJLdE9rYmFFcFIxQmJJbWtwT3dic3hFMUpWQ1NVR1dSQlREa2xGK0JpY2pwRkpCc05rRVlxSFNGYzQ2VEZtSHBMNlpFL0Y0Ukprakp6ZDU3d2Vmd0tZbjBkZStndkFDTjNNVTFXcWhsQ0JORkdta2tIS0xXbjZhMnI2R1VocG5JSW9qV3RNdFZLcURBcUtXS09NUWhjRjRSOHNMMm1GN0QzWXl3ZDY4d25kZU9FbXh1Y0Y0YjNDd2x3d1Y0NFhFbWVCWnZLMUNWVlFJYXNKNmdscUdBUzduZzd5amlsUTRzRXFobE1JNjAzU3lKZGpRdHhNNlREWHU4NGU5bDFocmlYU0UweEYxWFllR1ppTnd0eCtGV1ZPamRFUTVHWkJvVGFSVkkyb05SVmcwUkxmVm90ZEo3YVdObGUybVdwWHZlNDRtOTNCWm12cDJsdnJ4SlArNlorQVFJTCtEU1NWQXhRZi9MRHpPMlpyKzNzNnRhSHR2WW12YndVSHRKTVo0akZXWXVoMlVBdkVvZ3M3c2VGaUhZU21sbXpVQk51alFOdEw5Wm14d1ZhQ0xvSUlvcmJjZWFRMWlza2ZheVhqNVRjL05HNi9nNHdUWm1TYUtBL2lVZ0ZScnBMNUZybjRENjljd3hqSGNHV0s4SWVrbWVDVkMyVmVHMEVRV0JwZWJwakhwQW52TGVZU1FiS3lzY1BxZUxqLzQzZS9pRno3MGNXeFpCY3BMSEJPbkthYXV3eXFDL1p1K3lTR2NONkh2WStDN3owbk96bWlldmxxeVBvSkpLUm5Zb0dhaVZQQUVTa21VMHRBb3JRZmRxaGpyTEVwSGVCczB1OFQrcVcrcVM4NDVwSkFINFJyT0lrUjRuVWluQ0tISVVrV3ZuWkpHbWlUUnJxektFVEFSVVBpbXJDdUVzRW9MNGtqNXNqeWNTZi9XS0NaNWhYWDcyd1A5L2hvMVY0NDJiNWxxc29mTU90WTAwMmtOUTBISjBQNldUYlZtUDRtVit3ZC9YNFRaRThoV1RiZFphTmswOTRKbjhjSWl2RVhGYlVxNlhMMDVRYldET0VLU3FDQVRKQVZKNUxIeUVrWHlXVVMwaHhoSVJoc0RxbkZPMXN2SU9pbGxaWUswcUF6TzBCYUd1amFremNxejJ1MUw4b1NjWXVmV0RVNWU2SEg2NUZGZWUvMWFtS213Rm9FamlwT21xbVN4anRDMGRJRURWdGFPdDUyVS9PMTN4U3kyTk45L2oyZHY0bGdaZWw3Y2RGemQ5bHphTk95V25rbEJDTWxDL0lSVUNpbkRkNjBETFVTaVNHS05jdzdqNmtDbGFmSVFwVFJDU2FTQU5FN3B0YWZJWWgwb1BjNkFOMWpuaGJIV2pmTmlDRlFJVVFXQ0dsWkZFcUh3M2U0eTdSYnNYWHJqRUNEZnJPWGpFbU9zMzFmWDM5OTFQdDY1dm1tcTBYclVhaDhYS3VoWDFaVkZLaGxVUXFSQ09oZDBjcHZHbVdzU1RxSENVa3B2SFBzcmxGU3p6ZFZaQjhiZ2hRTXA4RXBqUkFlVVFpWWFuV215TENhSlFyeXZSRW1WZllFcWVRRkJ5V2lsWVBmcU9tWlNFYmRpaEJKVWRZaGw1RDdOUWtvWUZtQU1Vb2U0M1hoUExBVW9oVUpSV2N2bWF5L3ovZ2Z2WldRc2IxNjVnYkVWK1dRUExRTWJObElxY0tpMFJLTXd6bk5zeHZPL3ZBK085U1RqMGpQZkV5eTBGSGZOd0R0T3dMRHdYTzE3WHQ2eWZQaU5pcFcrWTF3SEVUbG5UVkNKbDVLU0hKeHZRS01PdGtVNDcwS2pVV21zTlVqaHdWbU96YzB4MDIxUlZTWE9lNUlvQnB5djZrSW9GUTBxVSsreXY5VldDT2U5OTZheVBzb1UxMisrOFR1ZWdVT0EvQTRtaEdDNDloV0VsUGd3VUc0QlY0M1h4OEpWNjk0NFJGWHhGNy92QWxmWEozenk4MjhpWkNzOFdBRXlhbFFBaEdob0hHR0pqWGYrZ0VRb21zVXUxdGhBQVRud1V5QzB3Z1ZoQmFKRWt5YWFkaXNtMVJHQ01aUG8wekQxR3RwWXRpN3RzdjdhYllSM3BKMGtLREUyVlNXbFErNGhsRVFMbUZLYUtGSjRVMU1iRzk2UGxrZ2hNQ0tvcm9pNjRwZ2I4NDRIN3ViYXlnYTE5OWphNHFRRjRTbEYwT05XVW1LbHBqYUNlMDhLSHJ0UG8zY2RIUzJ3dGNDRmxJcTZGcVJhY0c1R2NyUXJPVE9qdUxSaCtNVFZpdGUzYmFBS0E5NjZBMjFoNzMyWVBUK1k2VGNoV1ZkaEhFQjZGVGJ2Q3NDSEhmSEdHdkNXT0ZJZ1JiMjZ0L2ZNeXZidWFrTWpjWURMc3BpSEh6ekQ1NTY1OUx1ZWdjT1IyOS9Ccm56eDM5RTcrakRsYUFQdjdNRWtZVjJPOVBGNzMzVXg3UzA5WEZSV1BITHZJbzg5ZG95UGZQUS9zLzM2WjVGUmlsUnR2QlVVaFdrVUJKdnVtR3RDS2lGbzlIQ3d6ZDQrOXN1YVBzeGpDeVhSc1NiTll0cWRpSGFXa01ZUzRodTR6aWZRTTFkeEU4UE5yNnl3OXVwTnZMTzB1aGtxQ29teGtLSkpra04xU2FjUmlZZGtwWThhRjJCRGVUb2N2bEJsOGszWUUwbkZaRy9BWENmRlpEMXViUGFSU1JiMmVBZ1ZGRVNhUW9MM0RtOHFIajAzeGNLcHA3aTYxNk1zSnZUaU9sd0V5Z2M1TGdsMUxTbHRJRGpQcDVLek16STBOQ2Vld3J3bHZMM2ZUUXdWTGZGVk5DbmZjTi93RGxkT3VIRDhHTWZuNWhqbEU2dzFWTlRjcW5mRVZ3WTNYL25zaTYvOWJ6ZHViNjAwbGF0Q0NGRkg3Y2o1R2NuZXl1aDNQUU9ISHVSMys0QzgrNjBNRkdkdHpIaTExNGtLWTlMc2wzL3pNbS92VDVpOSswR3V2dkpwZGwrOXp0dSs1NmY1d2FmTzgveHJHN3h5ZVJ0VDI0TmtVNnBReWJIT3Y3V0lSb293V09RSnQ3OE9YZW8wMWJSYW1peEppVlNONkR3SDB5K2d4SkR0MjJOdVBIK1RuZHZiSkpFaWJxZm9XS04waU9lRkZLR1pwd1JLUzJTazhOc2o3TTRJVDZEUnl5Wi9jTDdKTTZ5a0FtSWg4VGpLOVZWKzRQSEgyYXJnNW03ZFZLTnNXQzlnYTZ3MVdPYzRmZXc0QzhmZnhSdmpzN3kyOGdhTCtTN3ZPNXV5NXBiSkdETWp4L1RraUNpYWtHbE5LU1IxYmVuR2t2ZWVpbWlMaXMvZnRtelV5Y0ZxdFgzdnU5OXRieWhkWVNjSjRHeDFzS0xOV2tQbGE5YUtYYTdVVzM0Z0NwR1BxemR2cisxcytwQjNCTDZWd0hzbEdMamlHM3YraHhENDdlMEgvdW8vNHZuUC9OSytMc2xCNUFXSVRpcmRWRHV4ZVc2cFNzOXpsM2JKNHRPY2YrL2ZvdWh2MDUyWm96T1RjdmRkYzl6Y25qQVpWd2dYa25WSG9Mb0wyWVJmc25FdXF0RzVha1pDMDBUUnlTS3lMRUhyQVhyNjgyVHpWOGpIRmRkZTJlTGFjOWNwKzJPU05LTFZUdEZwak5ZYUZZV05zUHY3eEtXU3FDaUVXL0ZlUWVRQ0RVUTBJOEJoTTV2QTJyQzMzSHBCN1MxQ0svSkpnYjE1aFI5NDJ6bCsvcG5iR0dPYnJuZG85RlZsU2JmYjRrOSt6M2V3TUR2SDVUZGZaMjlyZzJ6cEFsOTBYYUx1TXRpYTFVZ3lINDg1RzYyZ04xOWdWZzVKbENTYUJIV1NFeG1zdEFVYmU1STRqc01tSzJjRGRhWFI4bnBySEszWkwySURXZEpJeTZ1RG0xd1pyN00xM3NOb0tkSjJncS9jYmoweFkrNVlxUVo0S1lUZitmTHVJVUIrcjdaNjR4V2lKQWxyOGNKejJSY3MwRXRMUnhmYTNWYTdQNnhJbENET1lxeHp4TE1ucVdkT01Sb1ovdTJIWGdNVHhLSlZyUEhPSVpVTUF6OHVKTzlTQjZLZjg0QzB6VzV6UVpwb2V1MFVyUnh4OXpLZHBlZlI2VHBidDBaYytzSU4xcTVzSUoybDAwMkprdEFwMXpwVTBZTE9yd2hhV0RwVXZJZ1ZLcStSZStObVk2d2ppYUt3QWRZN2hHK21LVXhnR2x2aHNUWXN4OWxhWGFNb0JMV1ZsTllSYVkzd0lRZFpYbHJpeVVjZlpLcmI0Y3FWTjloWVgrUG8wZVBNTGl5aE94MGlIWUdPYUhWN3pCdy96a2c2N015anhDdWZvYlg3TWtKVzNGZ3JLRXJQMWMwQlpUNkNWcGNvYTZQajVDRE04azB0TWF5QWN3aUN0cGZCOFVhNWdoNG9hbTlCSzZKSUlhUzBTTG5udmQrbnNsc2hoSS9ha1I5dlRiN3hDT0lRQnIrOVBmZnhud09kNGVwS05BdFBGYURUbURUUitVeVdhZEZwSmRpcVFpdUJUeEtrTW1qblVFWmpCWmpLNFBDaC9vVTZLUEVtU2JPdVVBZmRLeVZBTzRHV2tpeE5hQ1dhTk51a3UvUUMwZFExSnNNSmw1L1o1UFZucjFFTUpxU1pJazdTVURXTE5MR01zV1BMdU1wUkxVWFd5MEtwV1Fsa3JGRks0cTl2NDBZRlR0bXdQOTI3TUEvdkxGRkRPZ3dqd0I0clFrZmZTekJXc0w2K1JYK1E0SVdrVWdydjRjVFJvN3puN1k4eDFXMXovZHBWZHJhMldGbyt5dnpDSXQxZUw1U1ZnYVhsSmU2NTUyNkd3ekZyYStzazZYRW1KLzhNU1hxRTI4OThpQys4dHN0cmU1YVZRWUVIaWtGQldReVJXWWFVR3EwaXRJNUlrelJRN0VWZ0hWZDFTUzJna2lZczZKR2hxaVlFNEJqZy9Fb0REb01JQlJaVEdQKyt2LzgrUHZGLy84UWhRSDR2ZG1LNnk4cHdncXZ6L1hCNFg4MGt1bmhQZFB6TTdKdVAydFk3NmJkaWpJUTBpeENSWWxKSGpQSUtaU3kxRDNwWGdTN2hEOFp4amJBSEt3Q2NjemdKVWlxVUV5aWw2RTFQbUo2OVJXdm1GWnplWU9YcWtEZS9mSXV0Nnh2WXVxYlYxdWhZSTdTa2svV1lqV2FSdVdLd04ySzB0YzZ1R0RGOXhqRnpiQ3FVU1JPTldSdWdWM2JSNnEwOTQ4WllhaHJhdWZBb29ZSjNPZUJFTlp0amExQTRNRFhHUzZ5b09YWmttY2NmdkVpbmxYSDcxazNXVmxjNWZ1SWtpMHRMZExyZHBoeXJtSjJaNWVMRjh3aXBtYXh0b2JXaXJrcDJkdmI0NkgvN01sZGZ2TTJ0bllwK1pkOEtaTDNEMXlWV0tLeHkxTEpFU29WekRxMURuMFI2Z2JVVktvS2tGUitFcnQ2SFM2RXF6ZnBnYTNLTnI1a1VkTFg3NW5MUVF5ajhWcnQvY1paK1ZaTW9LWEpuOStmUUl5QlJTbVFQUDdEOHZxY2VLRTl1TVBIRFlWdVlUSlBFS3ZRVHRDZUxGWGxwR0hyZVNpNFBac3ZEd2F3cWczT2Vzbko0NDBrano5ek1rTG5GRlhwekt4aXh4dWJxTHRkZTMrSFdwVlYyVjNkUUFwSkVvUk5OMW02ejBGbmdTTEpNYkdKS1NsUlBNeGdOMk8yUEdlOFd6SjJhUWJVajNLaGk4dklXTTFXTnlCcjVVY0Q1SUUwa2ZhaEdhUmtLQi92TnkvM1kzenBQS2l5cGpKaFVodFBIai9LZXA1NmcxMm16c2I3R3p2WTJTOHRIbUY5WVpIcDZGdThjQXNIeTBoSW5UNTVBQ01YdFd5c1lhMmkxMm14dmIvUHpQLzl2K2NJem42YzI5ZGQvQ00xU1JkRk1XenJyR0UrR0NPR0o0NFRwcVhtVTBzMGs0MXRsWWU4Y1FtaUVsS1VwYmI1ZjJoVUlyeEpGT3AxK3c5N2pFQ0JmeHhJQ2wyZFMxcUtvemY0azZyNE9iM3pxV0hieWljZE9mcy84N0d5eXV2M3Jmbkh4U1V4K0F1ZFZpT2VkWTFqV3hGTFNpaFJsN1pxS2kwTXBDUjVHazdEOVNQZ2FyY2UwT2hzc0xxL1RuZDdHK2dFcjYzdGN2YnpGMmh1YnJGL2ZaTFEzUWdwUG5FVkVXY0xDekJLblowNHpHODhnYW84UmhxcXNHVmNEdHZNK29pV1pYdW9RZDFPYzlleTh0SUhhbXFDbVlIK2o2RDYvVEI2VVVVTm9KUnBBMkVaY093aExDR0xwU1NVc0x5N3dyaWNmcDlkcHM3dTd3ODdPTnJOejh4dzVjb3hlYndvcEEzV2sxKzF5N3A2N2laT0VXN2ZXcUd1RFZJcXFxdml2Ly9XLzhNd3puOE9Hc2QzZk91ZTZEeERya0ZIbzN3akJ3UXJxdXFybzkzZHhWVW1jaE56SldCdldPVWpoblVjSUpYYXQ4V1B1a0VrVlV2anVzUzZqdGRFaFFMN2w1aUJ3YlhlQUErRzhsOXl4RkVkSjBYcjhvZG52dlBmODJlTTNiMVQreHQ2TFl1N0NHcE9kZTdEbEtaUmRRREdISGtFZFM0U0lxSzFIQ0lPeFZhQ3R1NHB1YjQ4NDJtRnVac0RzekpEY2JiTXpISEJqZGNEcWFwL05XM3RzMzlwaHNMN0xlRGhCSzBHVUtOcTlObmNkdlllN1p1OG1JUXFpRFZnR293RnJ1N2U0c242TE9uWXNuT2d5ZTN3SzUySGwyUlhLcTMyV2RDTnI2L2Y1VFEwWjBvc2drZGpJREFrdmtONWhtaHZjTmdzNHZhazRmK29zUis1L25GNDdaV05qamY3ZUh0UFRzeXd1THRQdDlSQVNxcXBrcWpmRnFkT25pT0tFalkxdGlxS2dMQXVVMXZ6YXIvNTNmdjNYZjYwWjEvMmR6SU9wY0lWQ1pXMVVGSElScFNPOENFeGZhMHBVVjJKOG9NSVRHQXRDZXJEV2I5YVRlc0xYQ0RFb0pROURyTitMTlorbWFEWjJLeUFTZ3BiM3BLZE90dTk2LzN0UGZXQnU1a1Qwb1k4OTR6ZkxUYkxqWFVUcml4QS9DNzZEczR2TVQ3V1pWSjY4ak1oa2doRjlFSDFpSlloalJ5dDFLQnpqdk9iSzZvamJXME8ydDhhTTl3cEd1eFA2YXp2MDEzWW9Ka1VRZ2tnazNlNFVGMDdkejkzemQ2TUpzcHJidTN1c3J0NWlZN0RGMXJpUDdjRENiSnVaSXoyc2tLeC9lWlgrMVYxbVBDU3FhVlkydDdOb3RqL1JyRjFRemlNMG9mL2ltaGFnRjFqdlVkNlJMcDNnZ1ljZXhhUnRkcmEzR096dDBwdWFZV0Z4aVhhbmcxYUtvaXpvZExxY1AzOHY4L1B6cks2dVUxVlZtTVdQWXo3NTZVL3hvUS85RnlhVGI3U0taUEUyeHhZQzd6TjBGSVdSWkNFUXVDQjhrVVFIVjV0b3ZLR1F3cnJjYkZmakt1Y09RVGdWU1IrVVJnOEI4aTNaT3g2OHdPZGVmQzF3RE1ONGJRUWszcE5wS2R2bmpuZWVXSm8rY3Z6RzlWMXUzTGd1eEtoazdmTzNtWHJpT0JxREZidWc5b2pTRkIwNzRpVE1KeVROZmtGcklTOEZhOXVlN2UyQzdkMEorYmlteUEyVGNVblJMK2h2N0RIWTNLVXVhcUpZRWFXYVkwc251WERxQVk1TUhjVlhodEZ3eUkyYk43bStkcFZDNWZqTUl4VE10Qks2aTEwcUsxbjk0Z3JGMm9pMmg2NkdOQUl0R2tIZGd5R2s4RGZKL2h0MENLVXhQa3hJV2p5WW10YVppMFFQdjVjQ3hmYkdHb04rbjE1dml1WGxaVHFkRGtwS3lxcWkyKzF4L3Q1N21KcWE0dWJOMVVaRjNSSkhNYzkvNVFYKzB5LzlNdHY5MFVGNDl3Mlp0L2g2Z3ZVZTd6T1VEa2ozcnNZNWkyelkxdnRNaFNEdGc4T1QzNUdnTysrOWM4YVJ6YVNIQVBsVzdFZSs5NzE4NWRKVjBqaWlxS283ODQ1c3NaUE5mK0RzMG8rZjBjbWZmdlhqMiswNm5aRGFLYndZMGYvU0dwTk9ST3RVRCtHaDlwNnRmazZrUWhkYmFjY29OeFNGWnpTb0dBOXJKdU9nMHU1S1I1WFhsSk9LOGU2RXdYYWY0ZTRRVnh2aVdKSzEyeng0N21FZU9Qc29tb2poY0kvZDBTNmJvMDIyV3R2WW94NHpjZGk4cGplYmtrNTNtT1NXMVZmWHFUWW10QVIwQkxRaVNLSVFZc2ttNWZCM2dFTTFTb3dJZ1pNY1VQR2RzNlRMcDBnZWVBZUZpTmpaM21CbmE1dXA2ZW5nT2RyZE1BOWlhbHBaaXd2bjcrWDA2Wk5jdVhxRHFpNEQ0OVlMWG43MVZmN2RML3dpTzRNUlVidUhtWXp3dG15NG45K1lYeGZDZ3dnckhMU004STRtTDlQQmMxaUhiNXFpV3NxQk0rNFdYeTBuU2pXdXZYZUhIdVJibzVRb3hlcjJyaWpyK2s2QjZrd0lrVDUxZXZGZER5ejEvcUpBZEtXSlNHalJtVDFOVVV5WVRQcjRWd1hqcUNidmVid05XcnRhQnBuUnFvYlJzS1lZR2t4cHd1S2IwbEFYaGttL1lMUTNKaCtNR2U5T0dQZHpkS1NabnozQ21ST25PSGYyUExQVGN3eUxBZHZqTGZicVhYYk5EcU9xejJobmdNME5PcEowWnRvUVJXemVIckYxdFk4YlYyUUNPZ1R2a1VWaE5lRSttLzVPZ0hnZnBnbGxzdzFYTmZ3dFoydW16bDVnOXJIdllHQUZ3OTF0aG8zbk9ITDBHTjF1RHltRHRJK1VrblAzM3NPWk02ZlkyTmltTEN1MDFraWhXRnRmNWYvNHBaL241dHB0WWgxaG5jS25BcHY3Um1QNHQ4dlN2em9mOGJaRytBUWROZXhlNTFDUklHNUYrTnFDbEdFZ0xGVGZSdFdrWHJzRElBY2dlZjBqVnc4QjhxM1kxdDRBSWNTZDRuQXhrSjZZYmkvZlBkUDZmb252aUxUclpad0lVMVZJRVpLVG1hbFpsRkFrVjJwdTNWVlQ2b2I4cHlWQ1FqNXhqSWNHVXhoOFpaaU1Ta2JEQ1dac2NibkRqaXl5aXBqdExQUEkzU2M1ZnV3WTAvUFR1Tmd4cVBzOHYvTWw5dloyR1E0R2pBY2ppbUdCSzJyaVdKTk50ZkZTc1Rjb0dLenZVdXdFY2VjVTZNakdleVFRUnhESXJXK0pJK3hUeUp1LzN1TFFlSThwRGJNbjcrSFl1LzhVdTZWbFovMFdvOUdRVnF2TjR0SXkzVzQzSlBwTnYrVGVjL2R3N3R3OWJHL3ZNUmlHRU1yV2xtSFY1OW50VDlON3hITC9oV1gyVmdwR2F3WGp2cUFZZFRFVGp5MUt2cUU3M2RXNGZJeEZvcE1FMFNnbmdzY2FoNG9sV0l2UUVtOTlQbGdaN1h4Vi9xR2xuMTNLMkx3OVBnVEl0MktmK09KWFJHMXNtUGtNQ3U2SjkwU1BISmwrMTBJV1A0NFg2RlpiSUJTdUxodUJaQkZVeVNQTnJJbUpWejJYdW4yS3pDSHFJSlpWRlJaVFdteGxtV3dYZFBVVUQ1eDlpQk1MSnpreWZ3UXRGRW1Va2lZWkcrTXRYbDkvaldzYmIzRDcybTIyMXJZWjc0NHBSd1dpS1JQSFdVdzgzOE9qR0k1S0JsdDlpa0dKcjBOWlFRdElmSkFpNmNZUXh3RWMrOExhK0xlRTNyeDRxeUp4c09tanRzeWVPYy9TazkvRDFyaGthM09keVhoRW1yV1lYMWhrYW1ycVFPK3FxbXJ1UFgrT0J4NjRuODNOYlZaWDEybTMyMFE2WWxRTmVIcjFvNnpJTjVrNjNjWllUKzlNaTJLbklwOFlhdXZKdDhZTXJ1NVFqV3FLY1VteFY3eEYrZjh0cTNzOCtBcGJUQUxqeDFxU2RqUGpRcGpEd1h1VUJLVmxiU3BUSHZSQXBQQjR6OUtwM2lGQXZoVzdjTmRKWHIxOHcwc3BaQk5leGQ2akx5NU9uWHhrdWZkbllrRm00alNzRVN2R2VHT0lHa3E1TDNPOFNIRXF4cTNWZEsvWDVFY001YndLS3UyRG10RjJ6dDdyTzN6L2s5L05qLytsdjhxeEl5ZUlWSVFBU2xOemZlTXFuMy85czN6NjBpZDU3WlhYMmJrWmdHRnJpNG9sVVJLUmRETjBIR0V0RFBacVJuc0R5bEYxb01xNDd3RlNEMTBKclVpUVJwNVlFWWEycEdna2R2YmJ6WGRvVkIwc0FuVXNYbnljSSsvNGJqYjZZOWJYVnBoTXhuUzZQZWJubDVpWm5nSEM4aGxyTFBmZmQ1RkhIMzJFM2IwKzI5dTdHR01ZRG9kMFdtMmUzL3c4VjRyWFVVb2hRL29RcGhxN0VXbXFTTHluTXhNemM2Uk5PYW9ZYjAvWXU3M0hjR01QTTdKNDA4eGpxY0F5RUVvVHhRcnZJN3dTeEdsQzJ0WkJoQ0pTelhJYzVhVVFIdXR1dTdBeGFuOEd4RnZydmYwbXUraUhBTG5ENGtpTDJ0ajkwcTd1dExMMDlHejN1MWIzSnZjT1lpVzYwekdVT2RLSFVWRmIxNkhwRmtWWTY4bUxuUDZrb0I0WDZJMmNhbDVnajZXUWhjTzBlWFdiMTlJMytmSzVMelA5Z1dtbVptZTR2bk9OTDd6K2VYN2o2WS94M0hOZlllZm1EdldrREVJTUxZM1FLVUpxalBHTVJwWWlIMUpPYW14bG03MkZkMXl3T3F4c3l4eE10U1M5R0NMdjBRS0U4THpWRG54THZsd2N4RmNDN3dSSDduK0M2WWZmdzgzTlBmWjJ0aGlQeDdUYkhSYm1GNW1ablRuSTFVeFZjL3JNYWU2Ny95STdPN3VzYjJ5Rjl5QUVSVkh4elBybnVGUjhDVitDRXhhMGJMYjRCa2FCY0VHRU9nenZoN21ZS0l0SU96RjVYMkp6aTVRRUdra3FpYk9JTkV1SjJ3a3FVaWdwMFpHaXJNMGRtMFhEL0l6dzJIcFNyVGpyaXpzQkF2RHFGOWNQQWZMTjJvOTkzM3Y1MHFWcnpUWTdmN0FjcHR0S3UxdVZ1K2lrYloyZjZyQmRsR3hzN3FHRXBKVkU0Qnl0TktIWDZXQUliajh2SzRxaXhPUWxabU9NdVFiK1ZJZnVmTWJSeDVkNTV1WG5lTzEvZTUyQldxVnphcGFQZmZwalBQL01WOWk2dG8wdGFuUXNTTElJaE1ZWXFFYWVhanloeW10cVkzNXIyTkgwdklRQ0dVTmtvS3NnVnA0SUgwSXIwWVJRalVDRWFHWlB2SCtMb3VGcXo1RUxqekw3dHU5Z1pYT0hyWTFWeXFKZ1puYU8rZmtGcHFabm1nbElpWEdXMDJkTzg5UlRUMUtXRlZ0YjI1UkZnZk9lU0N0MmQxN2xsWjB2VWJVOW1aUzRTWTJMSERSSzh2djczd1BsSmdCRjRnUEQyZHI5S1dTVURONGpJRmxBTTVJc2hFQm9xS293QnkxbG9QYnZyOE5XcVM2MzEwWnZtc3JXKzlJd0V1RXQvbHM2SDMvc0FhSjBHTnMwem9acnFHa083ZzVHOGk4OGNhNjZaN1pOWFZXOHNUNUFDN0RPVUJwQkVvZTZhVC9QcVowTFk3bUE5NGFpeWhrWFk5eklJcmZIMks1bVpybkYxR05McUhiRWYvcU5YMlR0OWk2N3QvdTR2RzRvOEpKSkRyYXVNWFdKclVQeStWV1RRbmN1UVFzNDRvQTFBbVFTT2hGbzUvY0ZDZmZuamU3SXd1L1l4T21Ea3NuQ3hjZklMajdKemRWMStuczdGSGxCZDZySDB2SVJlcjBlM251aUtFandMQzh2OGRSVFQ0S0huZTNkZzZHdnFuWjB4UmFQTCt6aHpSS2YzTnRrblpKV0xLR3dRZEZlaGNNc216MFFZZVZDMkNtQmRkamFZUGRIYUp1clh6VUpvUkNoRWVpdHdla29ERlRKTzBTemhVQXFJVVFrSjY3MmEzZDRqd1BaSU9mOUlVQytXYXVLRWhWbVBVSzIxNGg3UEhSeTZjaENHcDJ0eTVLdFFjSGVwQW9QVTBnaUxZaWxJR2lpTzZRV1ZNN2lQV1N0Q0VzYnRHUXlDYkw5Y2xDUmJ3eXgwbU9sWUt0ZnNXTXN0Uks0Umc3SE5jdGZmdHVMem4vTno3NDVQVElrNXJFVG1Ob3p0SUpJK0VicC9VQVg0cTA4OTQ0R29VQ3hkTi9iaWM4K3pOcjJMcFB4aUxxdW1KMExucVBUN1dLZEMyTzdRckN3TU0vYm4zd1M3MkZ0YloyOEtGQlNrcVFaa1YzaFpIS2JWSGcrY09JWUYrY1crSlhMVjdoVUR5aVZBQXRPZUZUVFk0RWdhT0ZFbUdaaTM4dmRzWVRBZXc0bUl3L0FMUUxJRUhKZlNRUHR3MzZRcExJc1ZWSHJXR2Zxcm5XMTgwVmpuWk5TZUNrbGo1MC94ak12M1RnRXlEZHJrOEdJMFhpeXYzOXdmeUJLM3JVd2ZRYnZUNVRHK2RJNmtkY1ZTbmlTT0FrNlZNRDJZRXhSNVJ5Ym02YktEVUtGaEJvQldUdkQ2UkN2MjdLaU1BWmZsVWdIVXpocUMzdFZPQ2kyMmNxelg1UDhYVm9DQjR1YWZSMkVJUkpnUmtMcEJac0ZKSW1rNHgxUkUrSi9GY1lhaHJHT003cG5McExQbm1aN1l4TlRWeGhqbUpxZUNkeXFUamRJcDBZeFFnaGFyVFpQUHZFMnNpemoxczNiNUhuUmhIY1JzdHJpWE84YTJwYzRJbTZ2YnRMTk12N3loWHQ1WTZmUEYxWnVjNFdDTFdjcGZWam1neE5vTGJGU1lKb3dTaXFKVXVLZ3VyYnZaY0tBV2VDRkhTdy8xU0h4ajQxanlpcW1qV0JHeFg0aGlWTGYxYWVUU0dFYWFySUFueWoxTGNWWWYrd0I4dmlaNDN6cGpldE5vSXNBTDdWU2VyYWRua3NqMVprVWhySzJaRm8zQ3lFRFRWd2dlSFY5bXhhV3hha2VhUktGdUxvS3VyWE9XU0twa0JxS3ZFUkpoZGNSeGppazl2U2NKY0lIY1VVWjlCc0tDeVAzMWlZWGRRY2U5djlaOEZiNDRTMDRHL1EwYStscFJ3SWhQTHRXTU9VRXFRdmdrL0tPQk4wTFZOeGkvc0duR0daelRQcERCQTZwRkwycGFSWVdGdWwyZStBaGlpS1VVa3hOOVhqb3dRZm9kSHFzclcwd0hJNmEyWFNQR2E1eHo5Uk5aanFDd1NEa1BiRlc3UFVITEMvTzhNQ3hSVTYwVTI3djdmRm1mOFFia3pGN3J1YTJxYkRPVVRsUEpVTGZTRVpCZmNVU2NoSFZ2T3ZhR25BUjJvZE9welNXdUhETUVERkh6SHlTa0NXS1NBbGlSZlhxMXVDMVNXa21nWDNpblhmT3I5OWU1eEFnMzhvSE1EVk5xOTFDN0E0T1BQdkZ1MDUxZEJ5ZnU3eStvMSs3dmVYWCttT2tnSWtOeXVUVFdjUnNxdEJVT0R3ZmZ1VUtkR0xpTEtHRllPbElsMlNwdzE1cG1kemNKWTRGTVNtWmphaktBaE1KdFBMRTJsSFdQdEFuSWtGbUlhazlicit5WklOZnE1bzNwcG91cGlQbzl1ZDNnS1Z3VUpXaEFaZ2JSK1FGSkpDcFFDOUpWQWl4Wk5SbTZ2d2pqTm9Mak1majBEd1VncW1wYWVibTVtbTFPNEFuU1JPTXNTUkp3a01QUHNqczdEVHI2eHVzYjJ3aWdObzQ4c0VHeCtXcnpLY3Axa1ZJQlVWWk1OVk9LSXVjcXpmV09YWHlHSjF1bStQV01xc1M3bS8zeUkzaGVwRnplenptVWpGa1d3cE1IRkVrTWExdWlqYVNZbUN4dFVjbmdtNHJZNnJkSVVHUldFR1NlMkxybVlwamVsbEVLOUVOTmQ4TFozMS9ZMjl5Mlh2dmhRanJxejB3cWMwaFFMNFZpNDZmSmU1OENjVGF2dnErYzFVMTliR1hyczVlWGQ4MHhsbmRTenhUTFdpM0kwN01kRmhvSjZSS29JaFpHNVc4bWhpbTc1OWovdDVaZWpPYTdreE00UlhGU3NXbXFoaTh1WW5ZbnBEbEZ1a2R2VmlHeVRqWGlLWjVqN1VlcWFBWGdYR2lTYkFsV2F6eDNtTnFoekVlS1QxNTZabDhuYUtXdXlOWFdTazkyelYwd3VvUmxqUEIrUk56VEoxOW1CM1JvZHpyazZZeE9vNlptcHBtZm02ZU9FbHh6cElrS1ZJcVptZTdQUERBL1N3dUxyRFg3M1B6NWkycXVpWk5VMXl4UTNmeVBITUxockxVcEVJYzZPNWFaNWlmNlZIYkFhKzhmb056WjQ2UXRETHl5cElKYVBtWTVWNkh5a3p6N3RtS3ZieGtrQmVzVE0xU0ZoV3hsMnh1anRqZUd5UHdkS0tJUkNoODdhaHRqVmNlRlFsYWlVSXJUMmxxcEJDK3BTVTdSZkh5bFozUjFlQThzSVEwNTdkcUJ4MEM1QnV6eTI5Y0lsWUhMVE1IY0dWMVk5TjcveTkxN1A5TUpuaUhFa1JUblpTTHg2ZVpUbU9VYXdRTnJLZWNidkhBOXgzandnUFRwTzBnYXVZcVQzL29HQXBCdFROaDUvSXVybStiWGtIWWtaNUlpRVhZVXhoTFNCWEVrVUFyUVcwOHR2WUlIYmF5U2lISW90RHdjOWF5VjVkVXZ4c3pBOGhkOEN3ZVFIYTUrOFREYlBxTXVxcG90ek95Vm91Wm1WbDYzYW5Ba2dXU09BRmdlbnFhSjU5NG5LbXBIanM3ZTl5NGZvdlJhSVJVaXZYVjI1eEpybktzM1dldzUwalRMQWk0eVRBWEhzVUpTcWVjUGpuTjhMVXJmUEx6ci9INFEyZVptKzB3R1pkTThwS0tzTE54ZGlxbGt5anlXQ1AzS3Q1WTNXTllXV1JsNkZVTzcwQWJpNWZoOVNNZDV2YmpXS0dBMmxxTWN5UmFDdVBzNU9yVzRLUHJnN0xQdnBLSnh6WGFmTjlTRHZMSFhqaXVHM2x1clcySXdXZ2lHcHBKVkZzcmpYV2JwMDYwRjRxSmZXUnhLbzBlT0ROTE40bHdKaXgya1VCZE85empTOXozM2tXbTJvSldyRWlVQUs4cHl3anJGZE56YmRKdWh2ZWVjbERpYk1nTEtnZTVoZkVkMzBzVHdpRnZRelZIaWxDbjhVcGdwYUQyTUtrZE82V2wraWFhd2xOVFU1eTc1endpenZET016YzN5L1QwRERPemMweE5UUjMwRXJJc3ZNL3BtV2tlZXZBQjV1Zm4yTm5aWTNOamk3S3NNTmJRMzl2aTdQU1E4MGNGZVY0d0dZN3BkRnVCMVZ2VmdNUjVRWnExRVVJdzEwc1pqSEtlZmZFYW8zSEY3SFFuNk8yYTBOTlFLaWpMMTVYaDB1VU4zbmhqbmIzK2lEd3Z5S3NLNHgxSnJJbTFKSWsxdWltbkE0ekxtc3BZWEZEMUVsdkQvTVdYMWtZL3Y1dlhtd1NodURLa2NNSjNZOFdndEljaDFqZHJtLzBSZHhBd0R2SmZwYVF5bFZ4c3BWRjY4ZTQ1dXBtR3VtbFVBYloydEU1M09mditSVlFIYWl0Skk0V3JJL3BqUVYxYU9pMUpkRVNUemJVNWN2OFNLeSt2Yy8zVE41aHNUM0RtclJOZUU3VDRjdy9qM0pPRk5nZXBnMVI2ZExNalhXaUZFdEN0QmZuWWh6MGl2NE1KSWVqMWVwdy9mNEZXMWlhSkl4WVdGbWwzT3JSYUhkSTBQUWcrc2taQlpIcDZta2NlZVpENXVUbTJ0clpaV1YybktpdmlKS0hlS2puWjJlV3h1enQ0QTVOQlJCUXJxdHF3TURWRlZSdWNGNWlpWmp3YUVjZmhlRDF3ejFFaVlYbjIrZXRjdXJ6Q3d4ZE9jR1N4UnhwSDFFV09OUmJuTFZKNWFsc1RLWW5XUVlqYTRxbnFHaTBGTlliS21JUG1UbEhWZU9td2xSRkRZOHYxc2ZuVWpiMThoV2E5QVdDbHdNMjNOYmNHMWJkMFBnNnBKa0xoTVY1SW1nbWhVSkhYV3ZzTDl4N05XcXFVVTRuQVY1WkdFQkZmZTBTcU9QYmR4NWc1M3FMSUt5SXBNRFptWnpkaXNKZmpnRllTb1lVRTYvSFRLYWVlUE1ITXFSbFdYMXhqNVVzckZEdEZFRWFRUUFKZVF6R0dNaXhZSXJXUVREeFpiY2tpUjlZaXJGU3cvbURuT2wrbnVlNmJXRzU1ZVpuVEo4OFFSVEZKa25EczJBbmE3VFpwMWlLS29rWVdWQkxGTVVKSVptZW11WGp4UExNek0yeHY3N0MydmtsZDFSaGpLSW9KUjFvN3ZPM2NISzdLS2NxODJUcXI2ZmNuek16OS85ajc3MmZMei92T0Qzdzk0WnRPdnFuN2RrSTMwTWlCSU1BZ01ZbEpGS1hKSG5ta0NkcXh2UzdYdXNxNzlnU1BhLytCdFhkL2NOamF0Y2RCMG1oSE14cUtraWhSbENoUkZFbVJFQW1LR1FRSUVFQWpkdTZiVHY2R0orMFB6L2Zjdm9DbzhsaWpHUkpTUDFXbnV0RUo5NTd6Zkw2ZjlBN2JhQzN4enBCbm1xb3lMQlpOdEVvek5XZFBiWkJJeVhNdjN1QnJUN3hJcDlmaC9Oa3RUbTUwNktRYXBhSktQQ0dRWjBscnlCbTM3TlpabGxVa1E3bmcwU3FPS293M0xCWWwzbnE4VU05Y25wclBXUjhXYmVZd29oMEFLaUhDbi9aNi9JVXZzYlkzUmlScFlES3RoUGQreFVIUDdqeC9jdjAvK3cvZisySGZ6TytvWm1WY1JyV2dPMmM4by92WHVPMERwMUF5OHFHOTY3TS9UdGlaMXBUT1ViZjB6MFRGNXRYYTZBS2I5bEtHcDRiMFQvUUpJbEJOcXVqL3ZiSnphb09GZ2NUM05hYWphUXJOc2kyeEd1dVpsWUhhZncvQWEvdFhjeWs0ZnZJVTU4L2ZqWktTL21ESXVYUG5HSTFHWkhtTzFocnZBMW9yc2l3alRUUFdOemE0Ly81N0dBNkhYTGx5bFd2WGJ1QmFYL0txckVrVzMyRXJ1Y0haYzdmalRJWDNEbzlpTXA2eFdOYlVqV0ZqYlJEM0ZqN2duYU1xYTZweVNaS21LQ25vZFhLT2J3MXgxckczTStIeTlRUEcwd3BFSU5FSnp6MS9uVXRYOXFPM2UzQUlLVERXeFNFR2pyS3VxWTNCQjh0c3NlUmd0c0FZaDFaNnV0K0VmL2JNN3ZKTDNMUlhNd0xjcU5DaFNDU1R5dDNLSUgrYTgrM25YdWJORDU1dEllQkNDQkZFQ0lUelo3Y3lJVVN2cVMyNjlUa1BJZnBvQkNVWTNEMGk2eVY0NHpCaHdIS1JNcG5QQ0NzdExPdXBqY1g3cU1nUkYxZU95amlrbG15Y1gyZDRvcy82Yld0Yy90WVZwcnRUdlBDUVIrR0ViSlNSOVRza1dxT3pCTjl5TEd6akVBdERVVm5NdU1ZdW9tMzBTdERaU2NtcFk4YzVkZHM1dlBjTWh5UE8zWDQ3L1Y0UHBYWHJYeDRYbm1rYTNhNDIxamU0Kys0NzZmZjdYTHAwbWIyOUF3N0dCeFJaanZHQi9lWVpQbnpPWTJlS3ZiMDlOb1lGV1phUWRRUFhkNmJZNVQ0N3UvdDBNOFZ3MEc5RnMrUDNyRVJHbnFXQVIwcUhUbEx1T1g4YzZ4elhia3hveW9wdmZPY3laZVg0em5kZXhab0tWRFRvMUMxSzF6cVBjNDZ5Y2dqaFVVS3lyQTFacWtJdlQzM3R3bVBQN1ZXZmJZT2pXalhvVWdvL3pGWFk2Q1M4T3E1dkJjaWZ1c3FTOHZVUFlsa1VhYkpZTEJMdkxDM2tDU2RpRlpDT01qYnVHVVVYS2RIRjFIME9GbE9jOTRmYmFvbkFlRWZwZkFUbEhlSm5CVUZHcFVXZGEwNC9lcEsxMjlhNCtLMUxYSDNwS3NZMTBBU0NoVFJKeUxzNWFTOURwa25VMFUwVU1vc2VmNjVxYUtZMTVkNlN4ZlVGZHRwd1luaVM0OGRQNE52ZHh0bHo1K2ozK3lpcElubzNCTEk4Sjg5U3BGUWNQM2FNZSsrOUc2VVVMNzc0TXN0RmlURU5zK21Vc1oxd1dUNVA3NDRiNVAySDBUS2hXazZRbTBNSVVCU2FPKys1aHllZmVKSjZQbUYvT21kdGJVandVVUsxS0ZLY1QrTG1XNllJTE11eXBsdGtQSHpmYVpKRTg4SXJPNVJMdzlNdjN1RDVxeE1TQVlWcVNGWDBYUFFCakFFcDQ0NG5TUVcxZFNndFE1NXFnWlFYTDA3TUw4NGJ0OU1HeDhxNU5vUVFlUG1nWnEzNDAxL3pXd0VDakFiNXlqaHlOZTlsT01oem9LTmxOTCtKYmFIQXUwQzJudEZmeTBtUVRFckJsY21NcFdsYUg1Q1daeUVDV2doc0MrMDJMZDRxV2hpM3JENGlMaWtmWmR6K3p0c3B0anBjZmU0UzFhVEVUUm9xTlVkckhjMDNKU1JGU3RMeVo2VVU2S1NERXVDdHA2a2R4ZldVNUZvQ0liQjE3QmluVDUraEtEb3hPRnB3VnBaR2dlczB6VGkydGNYcDB5ZVp6eVBjeHJkODdhWXhLS201TVA4MjVwNUw5SHNGbFJEY2VmSTJybDk3aWNWc1RMYzdKQVRCK3NZV1o4K2U0NlhubnFhcGFtWmx4YURid1psV0x6b0V2TFc0RUcyd3RSSXhDeEs0KzdZTitubktiLzNCMHp4L2NTODZQNFJJL1cxOG9ERUJLU0lqa2xiOTBYbElFa1dlYXBFbXlkNjQ4YjkwY2RvODA1WlZoNzduV2FMOFpqY040MFhETjY4c2JnWEl2MWtLZVkxK3V5QUtmNGpsb3NSYUczMzhWbEtjUURySzBZbkVPeGd2TGZQS0FJSTgwVWkvQXF5RXd3c25SS1N5eWhZSDVWM3JlOUVxY2ZnV2lyNSsrd1pwTDJQL3BSdnN2N0RQNHZxaXRTNklFQXlkUlhpa2xDdnpTNEZLSkVXZU01eG9tbDBESWJCNS9EaW5UcDJtNkhTUWgyUFJRS2Zva0xZQnNuMDhabzdaZE03dTdnRlNSdk5NclJYZUJTNHVuc2ZmZVpuK1dzTFNHVzVRY1kvS1NaS0M1ZXlBQkE4cXczdlkzT2d6M2x6bithY3ZzTFNDQis0OVJ5ZkxXUzRycksxeFRTUjJTU1d4cnBYbUVaS3lkRnk2TW1YdjZwanRYS0s3RXEwMHpqa1d0WW1hWWdoVUt4d25CS1E2bWdpdGRZdG1ic092UEgvOTREZmF4bncxMXJWU0NuK3NsL0dtMHlOKzY4a3IvMlpJaTF2UkFmZy9Ea1BJczB3NTU3VXpVZWpaaTRqY0RUNmdjMDJTcFZTMVo5R0VWdnpBSTZRbVNWTjhNRmdYc0RMQ3JGZmN2ZUFqNkM2MDFzYWhIUmM3RnpWd0FUcGJQWkpPU2xLa1hIdjZLdVZCU1Zvc1VLbkNaUnFWK0JnY1dpSVU1Q0lsZlRsaDl0d0NwVFhIVDU3ZytQSGpGSjFPaE9DSFFKTEVqSkZsR1VWUnNEWWFjdTdzYlN5WEZiUDVncUlvTU1iZ25NTWF4ek1YbnVUNjFqT2NPOUVoZUVFVkhCZm1WN2xQYnJHNWZSdmozVmQ0NVpXWEdmU0dDSjNndmVYWVpwK0xneEV2dnJKSG1tZ2VmT0J1aEVxUjBwQVVPYll4VkhXRGRRR2xOTVlZdnZYVUpUNzNoOCt3WEphTXVqbTZoY1A3b0NneUZTM1hoRUJyaFJJaU90bEtGWHBGNWhvdlB2UE16dmhqNDlLTWovUWV0cFg1Q21WdHdwL0YxYmdWSUlCS3NqK1dVN3gzd3Zzb0ZXcEQrNjZIVnVSQVFrQmhiSlM4OFQ1Z3JNUFlrb0Nrc2c3WFRySGkzRGhtQ1d0OWRKTmFHY1I0d01iZ2NFY2tjSkp1d3NaZHgzR05ZM0w1Z0hwZW9yT0VySk1oQ28vMENrV2c3N3R3QWFhdnhGSnMrK1FKdHJkUGtPY0ZNbjZScEVsS3AxTVFFSFE2SGJZMk56aDM3aXlUeVpURllobUR3am1VVWxSVnplLzg1bS95a242Qys5OXlFdVZEaTd5VlhHejJlR0Y1bFdPak5YcjlJYS9hcTF5L3NjUEd4aEJyUEVwcHp0OStnc3ZYRHJodzRRcWI2d05HL1I1S0NxUlFhTzJRQmtMdDJUK1k4cVd2dmNpWHZuS0JwbTdvRmhsU0tsSXRXNDVISU5HdTdWMGlsVTFMU1pva0lVOFNFUVJQZmVQUy92L3l5c0h5WXJzK0tsZU51WkxDK3hDQ0VPTGZPSHZjQ3BEMm5MLzlCRi80NGpPdjZVSFNSS1ZheWd3Qkp0eWNoMHNwQ0kzSEdzK2k4VFRXSTRrZnBIVWU1Mk45YmIwamVJbHhnYm9OREdqTEs5L2FJYlMyb01yVGlrUjcvSXI2b0NXajI3ZlFXbE9PRndUcjhNc0dseWwwSmhneEpMMlFzZmZLQVVXM3c0a1RKOW5jM0tJb2lrT011OWFLTE05UlN0UHBkdG5jMk9Ec3VkczRPQmh6Y0RCR2EwMVZWWVFBU1pyeTdTOC96aFBQZllHNy9rOW42ZVc2dmR4eE1tSHdmS3U1eXUyVFB1dFNjTnZKVFc3czdtR01vZC92azNXSGJDcUpENEV2L09HVFBQSGtDenp5NEcxMDhnSm5EYWF1c2JYbnl0VXhuLy9TODN6cnFWY0FqOVlSYXliYWNsT0p1Q1FVVHJRVzB5dFdyZ3laVmlMQTVXZDM1Ly9iUy92TEM4VGdXTGFMUVNjRTRjd3c1OXg2enVkZU9PQldCdm16eWlEeWorbTFpa1FuVWttaERyM0FnMmpwT2JDNFBLZVpHVkFhMDNpYzhRZ1hEbUhwa2RVcXFMM2pKZ0t5UlhxMVVCSnZqN0NDMmc5aUJSaVNJbklpc2w2R0d4YUlFRENsSVZpUEtDMmpmQU8xazdCL2VVeW4zNHZCc2JGSmx1ZXQ0V1VnejNLRWxDUkpRbjh3NE5TcGs1dzZzYzE4dm9RZzhON1ROQVpqRGJaeGZQMExYK0M3bi90TlRyMS94UHFaUGgwVlBkaDlpUDZDemdxZVgrN3htSHlWdjlRN2haWXc3T1JNRjNIUDBTbFNoTTY0OTc2N1dKUU4zL2ptOHp6NzRoVnVQN1ZCTUlHeWJMaDQ4WURQUFBZc3o3OTRIZkJSQmRFRjhpeHE1bW9WS1FYTytVTnkxMHFxU0FzcGtPTEtpL3ZMLy9HYmx5ZGZhTXVxK2RIR1hFQjQrYUFNNjUza3oreHUzQXFRMWZyNWRXZSttTHJGVXR2MndZLzFONzBFcTUyU3hhdEx1dmNjeC91U2FtN2lsQ1ZSMFh3bUJMeUx1S3JveEJUeHBDNzRtN3p3RUkxelZnMjZiRDNVWXpNYU1VcklTQ0tLamFwQXBZck45QmppY3R5NTlJY0R0aytjWkcxdG5TeExZM1lEZXQxZXRHS1RrbDYvejRrVDI5eDIralIxSGVFV1NtdXlMS2NzbDFqamVPTDVKL2pFcDMrTi9yYms3SnVPUnhNVUpXbGNaRWttSWlvdWhDQjRZckhEYldTY3A0TnJETUlhOW5ldUU1eGx1SGthMDFUY2U5Y3Blb1htODQ4OXllN2Vnak1iUGI3NTVEVysrY1NyWEwwMkJoblFXcElrR3FWRTFDeHV6WFlDWUYzY1BZV1dwcXUxQkNFdVg5aGIvbisrZVhYeUtSZkNLampxdHU5d1FvaWdwUWpXZTc1K2VYb3JRUDRzVDdETHd5Zjk2dlI2M1VRbkpNNEhMSUowUmNRUUFWZFpkcDY2d2RycElWNkJrOUFzRGFJVDhEcE9hbHhyYzJaZGlCT2NOakJDSzBBZ1JLeXRoWS8wV0djOVFVU1JoZEI2R2NaK1J4QjhKQkJ0NmczRWZzSml0bVF3R25MaXhFbldOelpJV3RZZkNEcDVUcGFtNUVWQlVSVGNkdHRwTmpjMm1NOFhlQjlvaktWcEdrTHdlT2Y1MGplK3hPOTk0M2Z3cHlUWnU4NmdPcHJnQTVXSnJyZGFDaUp3T2FBUVZOYnl5ZkZsZmlJN3pqbVJrU2dOVXJDWXpZQWJKS21tbms3WUdDU2NPN1hCYjMzMk8vekd0V2VaVEVycWd3VjVLME9VYTBXUmFWSWQ2YnhTUnFGc0tXaU5ld0txWlJnQ3U1ZG05YzkrNWRMNGQwTUk4OWRuRGlsRkVDSHVQWHo0czcwYnR3SUV3SytBYkRjOWpySXMxWVJhTmRhalluTEFPWUZ0bjNNM250Nmh1bnNEazJUeE45T0FNUTRFdU1aaWZhRHg0SnpIdUp1VEs5RmFRUWNmTVZXSmFyMDUya0RCUndGZFo2S2twd2llYnRKaEl6dUczWWZLVll3MjFqaXhmWUxSMmhwcGtzYXNKQVNEUVIrdE5VWFJJYzl5enQ1Mmh0T25UakdkemtBSXJEV1lwc0U1UzVia1BISHQyenoyOHVlNXZuT05SR3B1Nzk2T3hPTjg5RXBQVld6TGxJandGWHlzWStZWXZtajNTT1FHbXlxaEdBd1FJVEFiNzZDVXdqYVd5NWYzbWV3dHlMeGdzak9ucWkyTkVDd2FqNWFCVHJCNEdaQWlJVStqVjJKakxTRXVpV0xaYXdSTFUxM2ZyOHpQdnpBMXZ4MUNXTFRCVWJaOWh4VkMrTFVpWlhkUi95a0I3YmNDNUgvM1hMdGhPQ0tqQnNCMHVtaFMyNWlWRVlMMThRbm4yOFZHdGJlaytleUxoRGVmZ1U0T1N1SkNYTnA1SDNERzQwUHM4R1VRR04rV1VLdnBsbytOZTlUeUJXOGpZWW9rbG1RaVJEeFRSMllVZExCamdmT1c5WTJOYUZZekhLQjFCQnltV1VhblU5RHQ5RWpUbEtKVGNQTEVOaWUydDVtM2s2cW1hYWliR3VjZDNnYWV2ZllkSHIvMmVZcnRuUFg1RnZNYll4SVpTRlZjZHJvMkdLS0toVVFoNDg5YjJNMU9hUGg5YzRNZjBldmNxOWNSUXBEbEdiczcrNHdQS3A1Ky9qcGZmL0lTMTI2TU9kYk5NSW5FV0V0akhFMElOTll6THgxTjQ4a1NReE1FcFhGNEgzdW9FS3U3Z3lYaFo2L1U0V01CcHNDTW14TXJGNThyZ2QxRkhlN1k2UEhpM3Z4V2dQemJPQWZ6YWtYYVh2WFl3VGx2dFZaT1M0VjFoaXJPZW5FK29DVklKNWg4WjRmWnVLSDNqblBJTkVIa0dpL0FDMG1RVVdrai9tTys5Zk9PWFBhb0Q5WENLSnh2WlhzQ1ptRlFtVVoxRXBTRTNCYjRhVTQxTmdqaDJOamNaUHZFU1FhREdCd0N5UEtNVHRFaHkvTkRDTW1aMHlmcEZCM0tzcUtxYXFxNndyVjRwdURnd3RYdjh2WHg1MkZRVTlpVTNucVg0Q3hGb2RwcFhRd1FFd0pDeGJHYUVwSk14ZWxiQ0pIK3U0ZmpVK2FBMlRUbDRYVEFZbHF4dDFQeTRzdTd2UGpxUG92S0VLUmtiaHFxc21sN3JFQXE0c09nTVo2bGlUODZvRGtpaHBkb05YRlMvc3Y5eHYxV0lNeU9aSTRWbE1RZlRmdi9Ob0xqVm9DMHg3bFdaZkJvM3k2VlRUUjJCUXF4SVM3NWpQZGMyNnU1c2xkUzE0N2k0cFNUeTRxdGQ1MUhoQTRpMTYxTnNXZ05NRmNxaUZIa1RBdUJxUXh1MlJCa25JelpKdUJFUUxjcWIwTEN3UFV4TDNnVzEyYWtXY2JXc1dNY1cvbHhxUGl4NlNTaDMrdVRKRWxjQXVZNTYrc2ptc2JnM1pJc3p5aXJLZ1pHaUpPekYzYWY1WThtZjhCY3plbDNjL0NDK1g2Rzl3V2Rib0pDdEw2QUFvL0FCUUZCeEI2dHZiK3hSNGpsNEo0MS9QYnlFczh1Y3padk5GeDdkWS85L1NYVGd4SmJOYmlxQVd0SWxjQzFJM012QkE1SFVJSThVUlNKQnVGd2JZK25FejJ0Z3Z6RkMrUDZJNlgxKzIxd0xJOEVSM2g5VGZ4djY5d0tFR0ErV3lKZW0wSDhsV3ZqNlhxV2pWZWg0MExnWUdGNDRmS0M4ZEp5YWl2bmprelFFNEhseFgzMkhnOTAzbllIK25nZjY2STBTWEFoY2hwYThabGdmVnoxdHRtRUZpRmNleGYxY1JOSm1tZDB5dzcybGNEMHhweThVN0IxN0RqSGp4K24wKzBpWmZUeTZCUUZhWnFTcG5FN1BoajJPWDNxSk01NmxtVVpGNWlscDI0ZG5rU1FmUGY2VTN4dC9IbVdhb0YzRXE4RjNWNUdaNUJTemlGTEpKbVVyYkduUUltSVBmUEI0NFZvVFdwRVZFb1JZRjJnbmh1dVhWN3k1UXN2VWwrZXNONTRSbDZqVEZST2ROYmhHNHZ6Z1NTUmRGUGQzdXBvWTVBbXNWSDMzdUZDQ0ZMSXFrSisvTVdkNWNmbXRSc1RSVnNPZHgydnp4eTNBdVRmd2FucVpyVmNpMFIvQ04vNnpxdlRlMDZkMzlHdFVQTmtZZm5XQzFPbWk0WVB2bm1UUng3YW9La3RPNWZuTkZjZHl4ZHVzRk43aXZmZFRUN01jZFlmd2tkaXJ4Rlg4c1o1dlBVNEpiSEdSV1hDdG5sUGxhYXpYN0I0c2FTcERMMStuKzN0RTZ4dHJFZkdYOVFLcGNoenV0MXV5K1ZJV1ZzYmN0dVpNN2dRa2NOQ0NPYnpPVW9ydE5JMDF2TFMrTHQ4WS9xSDFIS0o4cExXcUltZ29MZFdJQmlRSjFFZTFMZEdPbElJZ20vaDV1MU9Rb2xBUUZJYngvaWc1dXJMVS9aZW5USGZtYksvUCthbGd3cTVoQzZhVkVBaEE0V00zMk9tRlltT28xMkppTkFTS1ZBU3JCZEJCaGlYN3NKM0Q1YS9PcTN0d1pIZ3FOdStJL3k3REk1YkFkS2U5NzNuSVc3OCtoZXBJMzRuQVA1Z3ZLalgxa2RWdlp3eFhWUjg1NlVKTzVPYXUwOFdiUFlTamcwVko4NTJXTjZYOGFuZnFwbGRydURGSGZhYlFQR3VPK2h1ZGhFdWdQVVk2d2kxUXpieFNXeWN2Mms3RUNHczVEb2p2NTR4dnh4VjNYdURBZHNuVHJDNXNVV2FSY2FmbEpKZXYwZVNwSFNLQW1Nc3g0OXZjZHVaTTVqR1locERWWlhNVzQ4T2lOcFpMK3cvelRjbWYwZ2xTa0tJL21TSmtsSEtNMENubTVFVm93anJDQUxWdmd2T1JtbFE1K0oreHJmMWpiR1dHemNxZGw2YWNIQmxTajJ0S0dkTDdLekJMenltZ3RvM29DRE5JVWtnU1FRTFllaEo2Q1NLcmtnSVNSVGdFOTRUbkJDTDJuTjExcnc4cSswZU41V05tdS9WYzl3S2tIK0g1NzN2ZW9DZi94ZWZDUzJvMTRlQW44OFd0VkJxRERJOC9jSllYTHhlY253OTVkUm1nWFdlNlo3bHRqc0szdlJRRnlXTzhac2Z0N3h5YVk1NitRYlZzbWI1MENtRzV6YWlqYktOdXhDenJBbXBKa2hKYUNKQVVpdEpibkxVSzVMRmZvbFVrdlhOVGJhM1R6SWNEa25TSkM0S3BhVFQ3Y1Nza2FUTUZ3dTJ0alk0YytvMDViTENPa2RUMTNHNUpnVk4zZUJLejQ2N3dqY21YNlNoSkJIUkVWYkoyRk8wZnhTbEJVV2F4SUZkaXp1ek5rU3p6RGFBZmV1S3U2dzkrOWRLZGw0YU05OWRVaTFxNm5sSk5TK3BaeGJYYXFwSFE5QzRoRFZFZFBOWWUwcHQwUnAwSWtrekJWT0x2cjVFTnA1SmhPVStoeFFMZktpKzM4RnhLMERhYytYYUFYVnRncFF5eEVFOHp2dGdwclBsaXhkZUhlODgrY0xrV0pZS3pwL28wTTAwUHNDeWRIenJxM09PYngvbjdXK1ZwQm8rOGlzWHVmRFNnbXgzeXY1akpkWHVnbzBIVDBhMHJndUVWSU1YQk90d1BrSXR1bFdCdUNSWVRrclNQR056WTVQajJ5Zm85ZnRvclJCQ2tMYWM4aXpMeWRLY3BtazRlWEtidSsrNmkvMzlBNFJjb1dBajQxRkpoWmFhYjE5K25CZDRCcXNxdElnKzdpdi96TlZRTzRwUUJHUWlJeFNtOVMyVWdQVWNRdlNkaCtYQ2N2M0trdkhWR2ZXMHhqcVBOWmE2cktqbU5lNUlFU1NPZUMwb0VlM2ZkSXRDOXUwb3JOcXJxYStWNk5xUkFrNkl1Uk5jOUQ2VVIzcU9vd2llZitkSDNRb1ArTlJudnRsK3FHTGxicXVBYkhkL01kK2RMWTVONTgzZFo3WUtjVzY3SzFJVm0vYU5ZVXE1TUhqUjRZNjd0em05N1RtMmxmSHNoU1VIRTRzT2dkMkxNK1psUTJlckV6MUZHayt3TG1yTkdraW1DVndHTXpkMHVoMjJUNXpnK1BZMnZYNkVpZ2dFblc2WExNOHBpZ0tsRlBQbG5QdnZ2NWY3N3IySGNsa2pwRVJKaWZPK2RaWDFCQUxQanAva21mTHJOSlJJb1ZxUDlOQ2lmRmVCRXNkU3hucWtqc0xiU3NURm9Hd3Z0dzlRMXA3eGZzM3V4VG16RzB0c2FUQzFwVm5XVkxNRmk4bVNadWJqdnZXSVNXZ0lNWXZvRk5KTWt1UUpXaWRvS1hFenovSmFoVy84emUyVGtxOEdyVDVST1grUjE3SUQvZmZyYnR3S2tQYXNEUXVzODZJRmtHb2czOTFmTkRvSkQrYUpmT1Rlc3dQUnpiVklwVUFFNkdTS2ZqL0ZHd05CTWx6cmNjZTVsUHZ2NlZLYXdPNis0ZUVIK3J6M3dZUWZ2alBoK1F0TFpnM1JTcTFSRkFjRjRWb2dtSENJcVRwMmJEV3BpcGtqTHdxU1JHT3RvYXBxaElBM3YvbE5uRGw5bXRrc0xnRGpFTUJoclVXSzJLRFEyZTRBQUlBQVNVUkJWUGcvY2YzTGZHM25NUmEyUXNqWWphL1F4Skxvdm52b1h4TUNWZU5KRTBHdm8xdFR6NXVCczFoYTlxK1hUSzR0S2FjMXphTEdsQVpiR3VyWmt1VmtUck93K0FyQ2lsYlRVZ0traGlTTEw1MUtralJCcTRScXgxTHZOakZGcmNBTUFGSThVUWwrMC9nd2JnT2tPWkpCdmkvblZvblZucE1uaGp6OTdMVlY2K3dBSTZXd1JaYUZFOE9FVVM4VkF0QWlic0dOOWEwa3FHUC8yZzZYc3czdWZYaVROeitxZWVMRkpla281Yi82TDg0aU81TC82WjllNHVzZmY1V3pkdzdvbk5uR2pCVm1ZUkJLTWh5TjJENXhndEZvalN6UGtDMENWK3VFTkkwZTRQUDVuTFcxTlQ3NHdmZVJaems3Ty9zb3BWcWNWcXZ5R0FSVlhmSDF5MS9tV3dkZnhsbURiQnhCU1lLTDM1Q1E0UEhSZFFyQVI3SldzMmlna3lKRkxLVUFxc1l4bnhsbWV6WFZ1TUVzRGE2MjJNWlJsdzNOdktTYUxXZ1dGbHVCTjNEVXhrcXFtRGwwQWpKVjZDeEZDVVY1cmFiY3IxazlpWWh2ZGtCZ2RPQ1p5dm9EVnFxSXJVYVovRDZta0ZzQjBwN3ByQ0pQRlZYamZDeUhzU0ZnNzduaitQWGpYZTlzWS9UTnVoMmFPbkxOeHhQTHNVM0ZlR2VQWjUrb0daeFo1emMvZThDamIrbnhyYWNNRjU1YjhzWFBUemkvbWFLcUhIOGxhZmtYQ2FPMWRiWlBiTlB2RDBoMEV2dU5OS1hiNmVLY1EwbkZlSExBMnRxSUQzN2dmZlM3ZmZiMnh3Z0JkVldScHRuaDRtNzNZSmV2WFAwaTM1MCtTZkF1V2dsa0N1ZDkzUDVyZ1dwaHl3RVo5ekFCR3VPb1NrUHcwVXJPZWFocXgzemFzQnczbUZrc3AyeHRjYlVGNjZKWXhLS2tYRFRVaTBDb1gzdURoWWkyRERvSGxVdDBxbEZlVVY2dnFTZm0wTWptY0dRWUtmeFhiZkIvNU9Qa3l0S3lBd093Q2R5NFZXSjkvd1BrK0xHZVdDeU5DRUZJSVlRR2t0dE9yWWxUVzkxM21xcGVFMUtzUEd0d0x0QXRGTmFCdFlIMTlRUnZHdVo3QzNxWjRPVVhGM3o3aVFYWExpN0p0TUFsbTFpOWlRdVNMTS9ZMmpyR2lSTW42QStHSkcyMjBFbENubWRrZVd6RXgrTURici85SE85NzM0K1FaVGtIKytOREZPNEtMU3lGWUZIT2Vlemx6L0xrd1JQWXltQnQzR1cwalVkckJTaGFGOXdXZE9oaTVxa3JSN1ZYb1lNakgyWE1GNWJaMUZCT0xXWmhjWTNER1I5THE4ckV2bU5lVWk5TFRPTndWZlFwdVJrZElCSlFXVlFnVVZxaWFrRjF2Y0hPN2RHZ09BUlVCVmdJK0lpRjN3dXZCU1A2ckMydjZsc1o1UHQvbkl1RFRpR0NEeUZZd0gzM2hiMVg3ajgzL0dxYXFiUEd0RDJLakZ2eStkd3k2S2ZzN2x1MnB3bWRnYWVzREkvZTFlUEJzMTE4OEZ3ZlN6NzdiY2w0Ti9JNnV0MkNZOGUzMmRqY3BGTjBVRnFqdFVZbkNWb3Bob01oMCttTThXVE12ZmZlemJ2ZjlVN0tzdUZnTW41TlNlVjkzRkl2V2ZDVnExL2srZXE3RVRtOGpKZFFlQTlTb1hWRUJCc0xQa2lFRE1nUXJaYTlqZi9XcVBZc245cG5jcXFIclh6c0tScEhzQjVqUE5hNDZHWG9BN2F4MFNyTitOaHpoT2lSR0ZwZE5xSGp5NjlTd3hLYXNjR2JjT2gxNG0rK3dqQlZZWmpwejE1Yk5CODdNcjJ5Z0pkU1JGVkU5MzNyMFc4RnlORWpwWXp3MENNN3NXczdzOFh1MUh4eHM5djVZSE13MjFBeVhnWXBvYXdkZzA3Y2pGKzVabGkzZ3YvcDF5OXhhaXZqdnRzNjlIb2pIbjgrNWZxQkkwMVY2OTUwbk5IYUdsa1crdzBsWmZRL1R4T0tvbUIzYnc5akd0NzF6bmZ3d0FQM2MrUEdEb3RsR2NHT0lTb1FtclloWDlvbG43djR1N3d3ZVliRndsSE9HK3B4aWJlT1lxdEhVbWk4QzhnUUNNNGRhbmFwbHF4bGpTYzBqa2JEeWYyYXZTOWZROTIxanZNdEt0bDV2UEg0eHRFc0dreHRNY2JoUXBTTDlxN2w1N2ZOaEpDeDl3RG9GU2xaQS9YRVJCUkJHeHlXUStjNE9oTHg2Q2l0Qm11ZFAvcmtDd2NITWxEN0VBd3RqUDM0SUF0M0h1dnl4SE43dHdMa0IrR0VFT1U0clhXSEFlS2RNOCsvTXZsTzc2NytkOU5FdmNzYkYyUkFDQ0d3THJDc0hJbVdYTitwT2I3Wlkzc3Q1ZE5mbS9ERWl3bWJteEtoQTUxT3p0cmFCc2VPSDZmZjcwZUNrNHdTUGtJS2lxSkRscVhzN2NXTDhONzN2b2Q3N3I2SHExZXVzcmQzZ0RFTmFacWhsSXhDMGpybDJ2SXFmN1Q3UlY2c242ZWVOT3hkMk9YZytvVEYvcExlOXBEaXhDQ1dNOVpqMjRXZ0ZCNHI0L1k4MklCdEhNNTZGTkRWZ3M2VGUrenVWZFIzRFBGRkdzbGRiU25tVzBTeVdLbTB0RGJOdnJtWlBWQ1FGcEtOZm8vYmgxdnNYWnR3eWUwZWxsUkhGeG9iQ2R5ZUNVNFdldlpLNVY0MkxoaEJPQlNkSmdSL2JWS0ZkOSsxem1QZnh6dHhxd2M1Y3VhTG1xSklzZFlKZ1pDdHJIUXlXelQranRQRDlTTGxMZFk2dlhKNklyVHdkeTJaTGcycGxxUkZ3YlY1ajQzTkxYU1MwT3YzMk40K3lmRTJPSFNTSE5vTmREb2RlcjArWmJsa1BCNnp0cmJHQjk3L1B1NjQvUnhYcjE1amQyK2ZOSTFOdmRZYUtTUmFKMXpjdThRbnYvc0puci95Tk5NWEQ3ajZ6RFVtMThZUW9EdnNzSG4zTVlxMVF6RzhtNHZCUUJUUzlpR1dUOVl4TW5EUGdlSFZDenNvNXpubElGeVpZWllHYXgwR2FFcERNRGFxdDlRRzAwU3ZkbGNGZk4xbTFCU0c2eGwzYkc1eTEvQUVmVlVRQk96TTU1Z1d5N1dLbzIwRmR4V3dsU25XUnYzTEYwdjM2MWVtMVE2d0ZGQkxLZXpKVVJHbXBlWHBLN1B2NjUyNGxVRmVkMzc4ZzIvbWM0ODlGY2FUaFNkZ2dIbytMOHY5dWZ2RzZIaDZVVWh6Sjk2M3F1eFJsTHF1TENFRXZ2NkM0NFlaTUJwR0I2bCtmOERXOGVPc3JhMlI1emxTS1pTSVFtNUZubE4wQ3BabHlXUXk0ZmJiei9Hakgvd0FhNk1SdTd2N0dHUHBkanBBbE81cG1nYnJQQzk5OXp2OCtpLy9QRmYzWGtHVURyZG8wTUhUNnllRXMyc1VXd04wcXFNQlNldURMdG9OdXhFQ0hXSXZZSDFnMUFUdXVGNHlmMldQNmJKaWJBUm5OL3VjYkF6WnF4T20xckNiYUpvaXBjNFZoa0RUR0twbFE3UHd1REtLZVJkRHljWmFsMVA1QmtQVklWYzVXaXMyUjBQNit3Zk05dy93YlZsMVhNQVpCWmtnNUZrcWtqeTVNTit2RGtlN0lXYVBNTWgxdVB3RGNCOXVCY2pyVHBwSzF0ZDZqQ2NMTHlLSjBBTDI4VzllZXZuc2o5LzFqRkRxRG1PY3RDNlFTa2dGekNyQmpickx0YkxBQlVHV3hSSHU4ZVBIR1F3R3BHa1dqZTViN3JYU1VUUjZmLytBcHFrUGcyUFE3M1B4MGhYcXVzWWFHK1ZDMjlGUWt1Vjg1Yk9mNGJkKzRXZVpYNytHYnFWTGszWllKZlpyUkhtRGNIV0NPN2RPZmRzYWNwQWpNMDF3QVMwRFNzVEFFQUZPMW9GalY1Zk1yMDFZR3NPd1NGa0dnMFhRN1dhVWVIenBTV3ZEK3JKaDM4S2VDb3dYTlZYbDhDWmUrR0pOMHU4VW5FeldrWlduU3B0Mmp5TXBzb3pqd3lGWEoxTXk3emdsWUIwaWtsZ0tNZWdWNWNUeGxlZDM1cFBWYUpmb0ZoMmV1VHI3Z2JnUHQwcXMxNTJYWHI3QzlSdXpRMG1tOWozSzZ0cHc1dVRhb0ZlSXQxUzF5UVNJVkFxbVRjYUxzeDc3ZFk2VW1tNnZ5N0ZqeDlzUjdvQWtUWkZTSW9WRVNZVlNHdWM5aThXY05ORzg3UzJQOHU1M3ZaTTBUYmw4K1NyVDZZemdvMm1NOTdFb0tjdVNML3pPSi9udFgvd0ZscnMzU0ZRY0VtZ2RMNXZXa0taUUpJRyt0ZlNtQzRvYkUrU3lpYVdRaWxuTGU5Q2w1WjZEaGhPWFp4eGNuMGFmY1NsUkNESWxVRUl5R3ZUUVVpS2tRcW40eW1XZ2FBemR4aUVhOEU0Z1dwOTNOUXNjN3cyUlNyRllMS0k3cm9pYVdrb3BwdU1KMjlheUxrQXB5QklvVWsydmwxKzhidm0xNTNZWEY5dlJiaTBFSnBNaURMU2k5T0ZXZ1B5Z25EZTk2YzF4ZzF3dGtSSEV1dkpOVDRRZ0JYSVhnamgzc3Yrb3QvYVlsb0pKbGZQS3JFdmxFOUlzWVRRYWNlTGtLVFkzTnltS0FxMzBvVHFKbEFvcEpjWWE2cm9pU1JKKytJZC9pTGUvL1cyRUVMaDI3UWJqOGFSVlY0blFFR01hWnZNNXYvUFJqL0FIdi9vUnpHeE1va0RKTmpBVUpEcUtPMmNwNUNsa3FhVFFrbjZBL3J3bTIxdlNtemVJMHFKczRQNjVJN3M0NWZLTk1WS3JDRXowa0NlYVBFbkpsRUpLZ1plQ1JkWFFPRTlqTGRQbEVtTWN2VUxUMTdDZVNmcENJSm9BalNNWVM3L2ZpNWRLU2JxZGJyU3VGcERONStpcWd2YnJUbFBvRnhsRnIvamFsMi9NUHpGZW1qRlFDa0dORU43NjRBc2xmeUFDNUM5OGlmV3VkLzhJQndmN3ZQdmQ3K09Ubi93NHU3c2gycUdIdyt5aFFrQUtJWkpYTG8zM3B2ZHRmbHVML0o3TGswUlB5aFNQcE5zdFdGdGZaMzFqazM2dlQ1cW1pSmFaRjBMQU9ZY1FEaUVFVGRPd3NiSE9lMy9rUFp5LzR3NnFxbWIvWU14OE5zYzZSeW9UeXFxazErdXhQNS94cVk5K2hLLy8zaWZCMUtRNlpnNGw0a1ZUYlJiSkVsQlNrR2xKb2pXSlZGRVZSQWx5cGVpVURha1RqSUppT2ErNU9Ga2lsVVN1bnBBaFN1eG9yVkhlMHhpSHpoT2tUbWlxaHJLcVNaRFJWSlJvT3BySVFLRmhsQ3ZtWldCUkw1anMzU0R2alhETzB4aERyOXNsQ1pyK29NZnVaSXlVVWNvMDBTb011bm50bFByMmxYRTFYZzI1UW9oMC9pVFg3RmYyQitKKy9JVVBrQy8rNFJkNDA4TnY1cU1mL1JlaWFScWNEeXN6VDAzck5nVVVJWVFrU2ZQK3E3dEZrTWl3S0FWYVMvcTlMcHRiVzZ5dmI4U3NvZU9VQ3FKUTNHcC9zWHFkUG4yYUQvM29Cemh4WXB2SmVNckJlQno5eVBNTUJLUnBScHJsWEhybEZUNzNzVi9tcWNjK2kyckpSMG9leVI2NlZSdlNrR2lKbHBKRWFWS2xVRkpGNTE0cFlwWlFrczFlUmwwMVhKbVVwSW1LNGhMR0VSSkJZeXpHUXplTERySkpxZ2xlMEM4eWhQZElINWd0bHZRU2pYT0JoYkZvcmNqemhMS3hkSEk0ZTd4SEowdTV1bWh3WHRNMERRdWkvS2xJVXdRQ0xRSjVKdWhrcVJpdWR5OS8rdXJzNjQzMXEvV0lFMEtFem5vUlRqeTZ6WVZQdlhnclFMN2ZaMjF0amVQSHQ3bHg0N280T0RqQWV5K0pjSGU5Q2d3aFJDK0VVSnc3ZC9zOXc4SHdKK3RHdno4RW4rUkZ5bUF3WUdQckdLUFJpRFRMVURLV0p5R0FzeVlxSmtwNUNPQzcrNjY3ZU8rUHZJZGVyOHZlM2dHejJaeW1NWEVNS3hTZG9ndEM4c3lUVC9MeG4vMm5YTC93SkZMNHcwSll0c0dSS0VpVUlFOGo0U3BSQ2kwVnFWSUVCRm1pb21laUQrd3ZERUpLVHZRRHIrek5hVXkwTmhOS1lhMk5aS2JnV2NzVFZLdVRHeHY1dUxYb0Z6bmRMR1c5VTJBOVRLdUd4c1RmcTJwSGtpYWMzdTdUeVRQS3lyQ1cxaHdzOWpHTVNOTUU2eHhKWHBBbW1rd1pra1F4NkdRMHAvdnUxZkd5UHJJaThZQlhtV29GckxrVklOK1A4L0REai9EcXF5OHptVXp3M25QbHltVXhtODBFSUVNSVI3TkdCK2dNQm9QUjJkdk9mVGpSeVU4VHVBdUI3blI2ckc5c3NMR3hRYmZiSTBtVDZHR0JSQ3FKTWVad00rOWN2SkJ2ZmN1ai9ORGIza2FlRit6czdMQzNQeVpKSXVmRFdSdkhzQ0Z3OGNVWCtkUy8vSGwyWG5nU3JjUGhacTBWWkVTMWZVZWVDRklkZ3lOUmlrU3F5TE5valRTdXpCcHVMQTNqeHZIQVZwK3JCM05tODVJaVRlS21ITTlvT0dDdDM2V3BHMHlJWTJGakFrMWowZTMvVkVwSXBTRFBjcTR2R2lvWFNKS2NHK001blV3d0dPUUVCNHZhUlFrakFsMWxLZWM3VEtvbCtYQXRxajBXQ1NtT2JwYVRqenE4c3BibCtTanY4UnFZWTJCeGZSRjRpRnNCOHYwNDU4L2ZTYWZUUVNtRjk1N3BkTG9LakpWNVp3cmtRQUVVeDQ0ZFAzWDJ6Tm1mQ3Q3Lys4NzVrVTQwdlY2ZnpjMU5SbXRyZERwZGxOWW9wVnIybjJ3SmlkSFd6VGxMdjlmbmJXOS9LMjk2NkNHa2xPenU3ckovTU1aN2g3V3hwSEl1YXZZKzg2MnY4M3UvOVBQc3ZQbzhLdlVFenhGMWM5QUNNZzFaSWtpMEpFMFMwalpBSklLNThjeXNaVzloV0JoUGc2UkljZ1o1UVdVYVRHV3A1b2FzazlBYmROam9GUXg3UGNyRVVWWUxISTY2Y1JIRTZCeXQxaloyYWNpemxFSktsQlQ0TEtVcFVvSnd6QmMxTGtnNi9RaS90ODVoblkrcWpNMkUrYlVGVGRFbnhaQ2xtcTEraCtVbzU1cnhaSzFReHMzd2lLcjJ6LzNPQzdjQzVOL2wrWm1mK1ErNGNlTTZseTlmNXNhTjZ5S1NqNFFNSWF6SVVmcEkxc2dIL2NIYXFkT24zOTdyZFA4OTc5dzd2UTk1bnVkaHVMWW1OamMzR1F5SGgwNU5XWlloRUJISEZYeGsrWW1ZRlU2ZU9NSDdQL0ErVG14djB6U0cyV3pPZURLRkFJbE9RVURkTkFUZ0cxOThqRS8reS8rRnhkN1ZxRWZiYnIrbFhNRkUydElxaVVZeWVaS1E2cmdOR1ZlV1NXMlptSUJYR3E4eUdtdVpMdzA5RGNmNlBacXFJVHVXc0d3YzFsczZpUWJ2Q1ZXRnFTekxxc0hoU0Zxam9FWGRVRnZIc3JiVXBhRklVMjQvdHNabzFEL1V6YjAySGlOVTVLL2dvNXBLM3NrSkNIUVFPRjhSbGpWMlVaSjNCSU9pUjNlOTRKczRuQXVaTHBMZTBjOUpFTC9QSDZUejV6cEEzdjJ1OS9EOGhlZm9kQXFFRUZ5K2ZFbk01M1BobkJVaHNPbzFVaUFYUW5SQ0NQbUpFeWZQbnR3KytkTWhoQjkzMWg4WFVvVEJjTURtMXBaWVcxdWo2SFFpN0VOSzBqUnl4VTFqS091SzBETDg2cXJtekpuVC9OaVAvU2hiVzF2TTUzTW1reW56K1JKbkhjNDdjSkVGYUl6bHNkLzlKSTk5NHBlcEYvc29GVEZoY3NYS1d3V0hoRFJwK3d1VlVEbllxeHJtSmxBRndkSUdEQXByQkhYZFlLcUdWTURwZmtHUktMd1JqUEtDVkR1eUltR3QzeUZKRk40WVpLYlluMXNxM3lDeURLVWpUTjAxaGp6UmRKSVVGVHp6c3FMSStsUmFNMGN4NnZad09rcXFhcWtJSW5xa0pIbENNSUhGMG9KeDlEcUNZU2ZsMktqTHBTU3dZenhya2s3U1RkWTVRbzhQSVB3UHdHajNMMFNBdlBuTmozQmkrd1RYcmwzbGwzLzVYd210RTZiVHFRekJpN2JYT0d6RWdZN1N1blBYK2JzZTduVjcvN0Z6OW9lOUQwbVc1MkU0SEltdHJVMEdnMkVFRE9xNHo4anpuT0ZnU0ZtV1ZIWDBPdmMrR3NLODZlR0hlT3RiSG1WamZaMnlMQmxQcHN4bjgwTkhweEFDVW1wdTNMak80Ny8vTzN6dEQzNEhVODJqN20ySXlvcHFGU0NBYnB0emgrQ2dEbFRXTUc4Q0I1V25EcEFrbXJrTkdHc3B2Q2NYTVJWMjA0UXpheDJxMnFLRUlzc1Z3VVRwbG1WaktFTEFXbGpXQmlVazIrdnJxQUNOc1hSa1NxNlR5STF2aGF1RjkweVdTOUtpb0pPQVZ3bEZvcUpOQWh6YVpNL25EYk85RWxzWmVqa1V1V2FyM3lNWlpueW5xWEJhMFQ0RDlORUFFYTEzNFUzVTFxMEErVE0vLytBZi9DTmVlT0VGK3YwKzMzM21HZWJ6dVpoTnA2MEVOYW9OanFPOVJyNjV0WFh5eFBFVEg4aXo3S2VzTWVlRkVLTGY3OGVzc2I1QjUwaldrRUpTNUFWcmEyc3NGZ3RtczJua09UaEhudWU4LzMzdjVZRUg3c043ejNnOFliRllVbFUxODltY3FxN3gzdFByajlCMnpLVW5QOEhqZi9BN0JGUGpXbzJzcEEwSzFmNFloS0FPZ3JrUjFGNVNCNmdjekpyQTNJSW1NRFVHQ2ZTQVRtdDJLUU9jV2U5d1l0aGxPaWt4MXRJcCtoU3BwbXFpYlp4UWtocEJiU3k1bElUU01uTnhRcFVtbW1HL2czVVI0UndFMGVVcXdHeXhvSEdlTk5GMGlwVEVXUlpWZ3hlQzJhUmk5L29jaktPVFFTZVhERHM1VytzZHZtbHI5cTBqMHhvRVVpVXlQUklnU0NsRnBqSmhNT0ZXZ1B4Yk92L0QvL0RmOGJmKzFrL3grNy8vYVl4cHhHUXlFZjZtVXNuUkNWVldkRHFEODdmZjhZNUVKMzlUS2YxRFRXT0tMRXNaanRiWjNOaGtNQnFTNXhsSzZjTStvOXZyTVJnTW1FMm56T2F6ZHZ0ZTArLzNlTjk3ZjRRSEg3d2ZZd3hsV1RFZVQybWFCZ0tVVlFWQXJ6OWl2bitaTStMem1NbFRMT3NHWVdKOWthV2dWZXVWSVNVTkNpczFKZ2dXeHJPMG5sbHRxRzJVQTgya0lFV2dDZkdiRW5IQ0pZamtxRHRQcktPbFpGRlZMQnFMeWhJOFVGWU52VTdHVElGR01OS1NwVXRZbERWT2VOSXNRUkx3VGF0VWpTQlJra1Z0bVMyV3pPc2FxUlN6ZWNuVjYxT0tJa1duaXZHa1lueXdCT3RKTkhReVFTZE4yQjUwMlZXZXJ4OHNFRVZHOEQ3Z2cwb0wzZUdtZlpHQWx2bDRxOFQ2c3oxdmYvc1A4L0xMTDdLN3U4dXhZOGY1NWplL0tmYjJkb1gzZmlYanM1cFF4ZUFRSXQvYTNOcSs3Y3h0ZjBVSitkTk4wNXgwdU5EcjlVUWMzMjdSN1hWSlZ0QjBvaFZ6dDlzbFRWSU9EZzZvcWpMQ3hrUGd2bnZ2NFMxdmZaUlRKMDlRMXpXejJaejVmTms2eDNwTTB6QWFyUUh3elM4K3hzNnJmOENaRC9UNTBsTVRiTzNwYUVVdjAyZ1ZNOGJNUTJrRlhpckt5bE1hUzJVY2piV3ZBWWlsQVpJUURxY01zczBlUWtBL1VReFR4V0pSa1d2Tm9GdWdFODFrRWJQSks3c0xSdjB1cWRLeFgxR0tmaWZGaWppSlVqWmdqRVVsaWtSRTcvVGxzb0lBdlRSREtzbTF5Wno5L1JMRUFscnBJZEhxWUJVWjlBdk4xcUNMN2lYOC9zNCtsWlIwVi9wZExoQldUcWNnZmxEdjFwK0xBUG5LVjc3TWJiZWRSU25GN3U2T3VISGp1dlRleSs4MW9lcDB1b1BiYjcvakhaMjgrRW52M0Z1TU43MGtUY053T0JRYm0xc01oMFB5Vm9OcTlUUkxXL3RrWXhyS1pSbHhVdFpDZ0VjZmVaajN2UHRkWkhsR1hUZk1aZ3ZtOHlXTmFkb2xZQ0RMQzVJazVZdS84M0VlKzQxZlltc0RQdTNXY1JQTG1mVSthTW5TZW5aTHc3eHhOQ2FhN25oNERlYWw0Q1liVHdHSmo1TUdKZUovaHhBQmlRQ05jSHoycVV2ME04WHhmc0Z4TFZuTEU3UldqRkpOMW1ndUhaVE1xb1k3TnZ2STF1WWdWNUxLTzZRUWpMb0ZRc1lTckxhT3RCV2V0czR6WHpUTTUxR0tLTElMMi9HMmlKaXdYcUVZZEF1T3JYWDV3c0dNaTh1YS9qRGlzMXI2cm05S1UvRjkxTHo2Y3gwZzczem5POW5iMitQQ2hRc01Ca05tczZsd3pva1FnZ3czdCtHSHZZWVFvblBtOUptekd4dWJmMU1yL2RlYXV0NVFTb21pMDJWamMwTnNibTdSNmE2eVJseGRLNlhvZGpyb0pLRmNMbHZyc29CMWxyWDFOZDcrdHJkeXo5MTN4M0pqTm1jMlc3QllMT0ltM1RnSWtPY2RuTFY4K2pjK3doOTgvSmNJMWpCZUtKNStaY0hjT2c0cXc3SnhWSTNEaVFCU0loT0o3aVdrSWFCTWUvRjhJTEVlNlVJTERtdTM2OFRsb1NRR3g2cENLV3RQV1ZVY0xPSFZjVWw2NVlDdFhrYVJLalo3SGFhVjRjTDFNYlVMYUtXNGZhMmdxUnRzaUlMVzNTd2xDTkJCNHF5bkxodjI1aVhUZVVWVlJ6OTFiOE9oOFNodEJrczFkSEpCUDlPTWlwVEh4ek1lMzV1U2RQVnJ4cmxDb0xKTzB1VUlZRFlPTDJTNEZTRC9obWRyWTR2MTlYVW1rd21BR0k4UFZudU5vOXZ3d3lhOEtJcisvZmM5OE1PcFR2NSswelNQR0dOVW5oY01oa1BXTnpjWURVZXRYYkpxdlFNRldzV1NDaUdZejJkeHVpSUVwcW01N2JZemZQQ0RIMkJyYzVQSmRJcXhsdVdpWkQ1ZlJHS1R0WEUvSWhWWFhuMkpMM3o4Ri9uTzE3L0l2S3FZVnA2RENtYXVaU01XQ2ZteGd1RmFUclpSa0szbGlFNktLbEpDYlduR0ZjNUJxQXh1djhUc0xMQ1RKZG5jeHZRbzQ2NkU5bklLR2QxMHBhRFYwNG1PVGM1N0xoOUVtNGNMMTJlSEpodE5nSy9mbVBMU3ZHSWpWU1FoMEZXQ2pVRWV5V0RHMGpTV1pWWFROTkVCeXJldGlROGNMaE5YTm5YZEZBYVpZcXViYzBONnZyWTN4OHVvQjd6eVlBa3hLd3FkNmF6bGM5M0tJSDhXSjAwemZ1N25mb0YvOGwvK1E3NzgrSmVGZFhiMUVGMlZWQW1RQ1NIeUVFSkhLWlhkYy9lOTk0eUdvNy9zblB0UVhkZW5oWlJoT0J5S3RmVjExdGMzYjA2b1ZEU1RwSFdaRlVLMkxMNG81K2xjaEkvY2MrODl2Tys5NzJIUUg3Qi9jTURCZUJLZGFuM0FXdE9pZHoxbFZYUDE1UXQ4OC9jK3dvMlhuMmE5bHlLbFpWSFZnR1N3WGJCMi93WnI5MjB3dUsyTDZtVTRJYkZCVURjQlgzdHM1YWpubG1iZVVNMXFiS0dwTXFpU0dtVXR1b1RjUWVvaGI4VVRWUHVFRHVLSTJvaUkwajh1RHNwb1ZpOGlqUS9yS2VjVjR3Q2JBaW90cUpvNjJzWVpHNmRwL3RDeG1wYTVlemlNWFMweE94bjBDOGxXUCtkYUx2bGl1V1NaQ1ZKMCs0Q0pGZ295dW13RlU3czZCTUlQOHAxN1F3VElqLy80WCtMNjlldGN1UEFDUC9kei94dHBsb21kM1IwUlFoQWhCQlZDU0k1T3FFSUkrZmIyaWJWNzdyN25ROTc1ZjMrNVdOd0RKRm1XaC81d0tEWTM0alk4eTdKMnppOXY1bjRmQ0VRTmE5UDZEVnByV0Y5ZjQ0ZC82TzJjUDM4SElOamQyMmRuZHhmdkFscnJ1UG1XQ3B3UGFaTHk3TGUvTEo3ODNLOVQ3MStsa3hmVXRVRUZTV2U3eHdOdlA4bkdXNCtUSGlzSVdtRjlvS29DdHZiUkM5M0hac0w3cUVnaUc0ZVkxYkJvY01zSzM1aW9LeFdpUHFjTWtQa1dIK01qSkVWeTh5bHZRN3pRb1JYQlhWSDMwblkwWElpSURsWU8ra0tnZFpRWHlyU2tiT0xmc3l0TGhEYUQrSEJ6ODMwek9BVERmczZsUWM1WG5hSE9NenBad05jRzJZcGtIenBCK2lCSWlOTDF0ekxJbi80ODlOQkQvTzd2ZnBMM3YvK0RWTldDeHgvL29yRFdDdWZjVVVoNjNyNnlmci9mUDNQNnRqdVBIOS8rS1dmZGp5M204NEZTbW02dng5cjZ1bGhiWDZmYjlocENDSlJVTGR2TzN4UjNKa3I5dTFhOS9NVDJjVDc4NHgvaTVJa1RIQnlNV1M2WDBTREh1UWdWTndZcFZaVHlFYkw1MW1PZmRrOSs5bGM3d1M0QWliZU9iQzNuK051Mk9QV09ZNlRiWFJvSFZlT3BhMGRsYUJYZ2lmcFZMbXBXMmNyaFMwdG9MTktIS0p6UU5KRnYzdElsZ2dDbllCbWdkUEdTcCszbGQ5eTBKZlZFWDhIc1NMTi85TlVFUVNvQ29sVTk4YTFQaUpjU2E2SUs0eW93am9JbkV3VjVCc05jMGwvdjh1SmFqMWVVUUpIUWFYVzA3Q3FxRUsrRi82ODJqRWVtV0xmR3ZQOEhqMUtLN2UxdG5ucnFTZUdjRTlaYTJaWlZSOEdGSFFUWmd3ODhkT2ZXNXRhUFcyTS9NSi9PN25UT3lVNnZ4Mmc0WkcxOWsvNGdrcGxrU3lXTlNpR0N4clEyWlcwbUVVTGduS1BiN1hELy9mZng4SnZlUkwvZlozLy9nTElzcWV1R2dFQ3BoR282UndqQmNMVEdZakcvOGZuUGYvNnp2L2VydnpCZlYvV0hScDNzdHFKUVl2ajI0K2kzYldLUEZSZ2ZhRXpBZUhCQlJHVkdGM0F1Qm9scFBLNTJCT1B4bGNYTUc4eXNwcDVYbVBreVJ0Q3FnVkJ0enN6YjVud0J0b3EvdlR4eTY4U1JKWkE4OHNFblI1cjhsVmVJRDJDYmFCRlgyUkEzK0NLS1U2d0NROGliYk1hdWhsNnU2QjdyOC9LSkVWZFNSVks3Vm91cjVjUFU4alhkdVZRU0tVVHdYZ1FoUlFpdEZxa1FBdS85VGF2aFd3SHlKNSsvOTNkK2htZWVlWnBYTHI0aWxzc2xkVjBmSGQwbVJQeFVFVUlvZXIxKzd4M3ZlT2Y3aTd6NHFmM2R2VGRWZFpWcXJSbXRyN0cydHM1d09LUW80alJLQ3RFaWNDVktxUWhOWDBsekJnOUNZb3hsTkJyeW94OThQK2Z2UEU5ZDFVd21VK3E2eHZtbzdPR2NaN2tzMFVrU3ROTGk2dFhMTDMzcWR6LzVTeC85bFY5K3doaWpON3ZKeGJ0dVYzL2ozZytkZWpoOXg3WmNDQkF1WU51SHYvTUJiMkpnQkI5d1RhQloxVUpOd0Mwc2ZtR2djZmphNHFvR3U2eXgweVkyRGpJK0hrUUJNaGZvUkVKWDBPdzZ3dkttOWkxRTllY2dCV0hsdXR2ZVZkMk9aV01HamVvVWRmc2x1R2pNaUdrQ2lSWklMUWd1Q2o4a0tXUUtpa1RRWGU5U25SeHhlYXZITk5WMGZNQmxEbWNkdHJKNFk5dkl1eWwvdXNLVnFFU3M3bDg0T3NtNmxVSCtoSFBublhleHQ3ZkhpZTF0WG43bEpmSDhDODh6bjgrUGNqVldPNDNEdmNiNTgzZWV2UGVlKy82V2JjemYyTnZkM2JURzB1MTB3M0J0VGF5dHJkSHJyN0tHSk5GSnEzdGJ0MERCSmtJdTJza1ZRV0N0NWRpeExUNzBveC9nK1BIdHVCUXM2eFpEeGVHVXlqbFBwOVBCTys5ZmVQSENNNy82YTcvOHYzN21NNy8vYkp2Vmt0RkRhNHQ3Ly83ZHlmRHNRSlFlbkZteHphT3BaM0RSNGl3NGtEN2FFR0FDcHZhNE9pb2VzdXBIbk1mVkJ0dTBLb1dCd3pwSzVRS2RhYlJXWkdsQ25Ub1cxeXJDd3QrY0ErZVNrQ2pjd3FKTU9KVCtkRzBmSXgxSUphaGRXMTRSczVscSt4dENhMzJ0NDZTc1NLSFRUNm5PYlhMMXRuWG1lWW9YTVpVTDV3bU54TlFTYjBNN1ZqdVNRSWhJQWFHVU04WXRnaitVbmZ1QjdFUitvQUprYlcyZHlXVE04eGVlRjBSOGszd2RmbXBWUW1lblQ1L1pQbjNxOUErTmhtdC9aVGFkdmExY0x2TXN5MWpiV0dkdGJWME1SeU95TEkrWlFtdlNKQ1ZORStxNm9XbWF0dFlWTGRjaUVwdVNKT1hSdHp6QzI5NzZWb1FRSEJ3YzBEUUdZeUxyenhpRHN4NGhGRW1pcWNwcThzeDN2L081Zi83UC85bEh2L1hFdHk0aVNBajRlOTU1L1BUNy9wUDcvazczUlBmK3N2RkNTVUdtWXFZd1ByN3B6Z2VzRUNRaUV1QjFpQlRkeG5xRWNkSHR5UWRjYmFKTGJHUHh0cjFMN1paSFpwQWtpaXhOMFduVTl0VkpiRXdXTjBwQzdTTU11Qk50Rk9oS3hOeWdXbCtPVmFBRVlzYXdvVjA0MGtKcjJ4NWp4VWZKVWhqMU5jbEdoK1dEcDVodUQ2aUpkVm5XWmtqaFBFRkdKMXdxRWQyazJ2SXB0SDd3UGlDRUVpSFV3Uno1RWdnaGhDekx3bXcydXhVZ1IwK1NKQmhqZU9hWnA0VnpGbXZ0aXNSMEZEOVZBRVczMiszOTBBKy80eTE1V3Z6TnBxNS9hRDZianB6M0ROZEdqRVpyREVlamRuU2JIS0p1ZTcwdUJCaFBKdFJOaFd6RjIyU2JPWnJHTUJqMGVOYzczOEY5OTkxSFZWWE1abk9VVW9kYjgrQmh1U3dwaWs0UVFvaTl2ZDFybi8vODUvN0ZQLy9GWC9qa3djSEJRZ2loUWdqaC9GczJ6M3p3UDdudjczVlBkaCtwYlJCSjYwaWxsY0FTYlpWdFM1QVNyVkZOMGdhTWNwQzBnUkZjekI3Qk9GeHRjWTJKR1VYRWQwU25BcDJyMWdvNlJiU2JjS1VrM1VHT2M0Rnkwb0RTOFFVRUxmQkNFWXh6dWpLTjlpSHpJTDJJS054U1FGZkdabDRCbVlSVXhaSktacEtrbHlKUGpOZzdmNHp5WkI4VlBFa0E0UVZhZ0E4ZTU2TkJqNURpVUF2czZBa2h0Sjdyb1RLbDNUOFNJQjRJSzJmZ3Y5QUI4aC8rUi84Qisvc0h2UGZkai9EZi83OS9qdXZYcnlPRUVJdkZZVG4xeHpiaFFMYTlmZUxZZ3crKzZhL25hZnFUWlZuZFZwYkxrS1laRzZPUkdJM1c2UGE2WksyaVNKS21EUG9EcEpRMFRjMWlzYmlaT1ZhN2pqYXhuenQ3RzI5NysxdlozTmhnTXBsU1ZkVmhYYjVjTE52Q0NBS0U1WExwTGwyNjlJM0hIdnZjUno3Nks3Lzg1YnF1eTlhNkxRdzI4djZQL1ovdi9ldmJ0dy9lVVRkT0pJa1VlRThUSXJZS0Fva1NXQ3RSTW1DREk3am96T1NiZ0cxQnJFS0lRK2lJYXh5bWJyQXRBaGNaVFRlelBDRkpWbkNZRUplRE9vcGh5MFF5R0hZUk1xT3MzYzNpUlFoc1QxUENicGlVWHlsNm94OHE2K3JZZUR4R3RDUGpSRUxlTnV1bGdtNUhrcXhseUswQjZzdzYwMEdCNmFXb0VFREphTWJqQXRJSGhKYXh0Mm9EUkVweE9Hc083ZmNWWlZjaENMRnNTbk53TkRodWxWanRlZktKcDNubzRRZjRiLy83LzQzSlpDS2NjNUV3Y3pNd2twdnpHZkxCWURBNGQrNzJCMCtkT1BYdldldCs5R0Qvb0tPMFptMTlYUXlISS9yOVBubGV0RndOUlY3azlMbzk2cVptUHA1aFd0YmVTdGx3TmFYS2lvSkhIMzJFaHg5K0NOTVlEZzdHYlVDWjZMM1JUcldzY3hoakdlK1BtK2VlLys3di9mWW5QL0Z6WC8zcVYxNXUxd2toaEtCMUt2Ty8rUThlL0N1M1A3RCtFejRFRmFUQUEzV1E3WUl0VU5xQWRWRm9RZnY0aERiQnN6UWUxM2lFOHhTcHBLNmd0QjVmVzd4eG1Eb09CU0NxcDZlNUpzMFNsSXJjbEJXN1NyaEE4QmFacGhTOURLRUQ3cURFdEk2Nks3TlA2ZjFMUmlYZjJiN243aDhPKzN2Y21NMmdpZVhiVHR0VGh3eVNVY0xnNUlqKzlwQjhVSkFPTW5SWEkzVEV0cVNad2dVUTNvRVNTQmtROW1iakgxek1oRDdFNXY1bS95RVJzSmpkV082L1BrRCt3bWVRTkUwNWR2d1l6ejMzbkpndkZwUmxLWS9ncHhJZ2JhZFRlWjduM1hQbjdqaS9mWHo3eDRzOC95dnorZndZQ05YdDl4a09Cd3dHUTRwT2h6UkpvL3BmbmtmMTlEUmxQRDVnUHAvalc3ZWwrQUNOUDNvZjJOelk0SjN2ZkFlM256dkhiRGFMWEkwUU1IVkRWVlVzRnN1b2NaVmxHRk55N2VxVm5ULzZvOGMvOXR1Ly9ZbGZ2blQ1MG8xMkNlMVg3K0dQL3AwN0g3cjc3Y2Qrc25aaDJGaVBkVkFSaFo1U0pTaHJ6NnlKSGJCMWxtVVZrSjc0NVBVZ2JVRFdEdU1kdG5hRVpZUFpYMFRyYU9jaCtLaUZwVlhyUmhVMWdFSnJueUNsUkxaMnRFb3BaSnFndlVOTHNNUW5Pa0tncEZoUzJXOUxvZWl2cmZXc00reG1DYjROa0JWOFJPU0NaS01nRzNYSnVqbEpxcUtGVzJ3azJ2SzBYUlltRXVIam9sTUVVRVJsbEJCQ2EvYmprRG9HY2xSd2tZQ1l6NjdOVnlXV0YwSzBuS3UvZ0ZPc0QzM294emdZSC9EMDAwL2pyT1hiMzM1QzdPemNFTWFZMTVSVFFvaWNxRUdWYm05dmI5NS8vd00vTHBGLzB6bC85M3crbDJtYTB1djNHUXlHZEh1OVEwRm9yVFNqMFlpMTBZaW1hZGpkMzZOY0x1TVR0d1VldGpOMnRGWTgrT0FEUFBMbWgra1UzWWlsYWd4MTA3Qy90NDhROGhBejFGZ2JkdmYyMk5tNThlM0hILy9pdi9pWHYvU0xmd0RNaEJCMUNNR3RzdDFkajJ3Y2UvakhUdjJrVGVTWlJlMnBLb2NNQXBGSmxJeDdEbHhzWkUzcnE1SFpnSFNDMmtRYkFodEN2TWl0RGxWb08yTmhQVmdYRlJDMUlrMmpXbU5RRXFsVVcvZkg3MHRMalNnVVdpVVJCaElDQXQ5bVRVbUlHL1pMMU81QzB1dWZsMElvSlNXcTFjbTZPUmVHVUFkTVpiRzF3UnBIVWtST2pIZHh3eSs4d0hCek54SWc5bGZHSTMwN05xNE56cnFXNk5GYVZiZEVMUTh6Vzdzbyt5UHdTcWxnclExL29VcXNlKys3ajhsNHpLYy8vWHU4NWExdkF4REdHSzVjdVN6NTR6STdSUWdoNy9mNy9mdnV2Zjh0L1g3L3J4RjRkMVhYUTYwMXc5RmFHQTZIb3RQdFVPUnhwNkdVcE5QcHNMYTJUcFpsVENkVHhwT29HSEp6ZEJzeEVkNEgrcjBlNzM3M083bnZ2bnVaenlKUFBBZ3c3ZGkyMXh2RUdqNXlHMEpUMSs3Wlo1LzUvTy84em0vL3I0OS8rVXZQQ0ZnaVJOVzZUeWtCV1ZxbzdMMS82NDRQYlp6cHZYdFplNkZFSUU4a1NTTHdMZEdwYmxXZlpQdktoY0JJZ1RHeDczQTJYaXhqUE1ySGZpSzQwRXFXUmpTZmtvSlVxeWlRMEFhSWtBSXROQkJIMVNpSlN1UDZ6MVVPYXdJNlRYSGU0UUpCUXFPYyszbzVyNjZ1bng3K3FOSmE2eVFKVXNqWHdqMEVVRU16cmxoMkZ5UkZndEJSZjFYbVVmTTBTSWx0UEtxeWlGVGhsSWlEQlJmYXZzbGlWNU0zUVZ3T1JvMndvSFB0aGVLcXEyMkV1NGViSlZZTFFQM3pIeUNEd1pCLytFLytNZit2LzhkL2d4Q0M3enoxcExEV0htM0NWNXZ3QXNpVlZwMkhIbnpUbmNlM2p2ODFhOTJQbWJvNUlaVVMvVUUvOVB0OTBSOE1SS2ZUamZLWUtrNXZ1dDBldytFSXBTVFR5WVRKZEhLNEJoUHRDTmUzZGUzVzVpYnZmZTk3T0gzcUZOUHBqT1d5YlBXcjRsTXgxUWxvZ1hVdVNDRkZXVlVIMy83MnR6NzVyLzdWdi9qRlo3Nzd6S3RBRmFBa09pQkpST1FxUGZxK1U3Yy8rUFpqZjEwcjBVR0xJRUdrbWNZRU9DaWpZcUZ6QWVzQ3hrRmpJNlRFdXJpUTB6clNYb09QVDN4blBkNDRYR2tRVFVBam9uZTUxbEYvUzZzWUhGckZ3QSt4UVNZUjdhL0ZoYUMxOGQrU1FpRlZ3Rm9uWk9CbE15bi95UHZnT3NQQndBY3ZxdVVpam1MRmtRMWlPM2p5Qzg5aWI5RjZtaWdJZ3NRSFpCNTFRb01RSkM0Z25ZOUlnTXBpS3hjTlB4c0h4cUZDUUNpRmJHbTdRZ2hVb2F2SjFmbFQzb1h5ZGRQbVAvOU4rcy84dmIvUDh4ZWU1NC8rNkhIKzcvLzR2OEo3SjRRUW9xcXFGVVRrNkhScWhaOGEvZkFQdmVOSGVyMytmekNmemU2MTFxcE9yeGQ2dlI3OWZsOFVuYzRoUkNUNmJ2UlpYOTlBU1VsVjFTeVhEWTFwMEZyam5NTTdGNFBEZXpyZEx2ZmRldzhQUEhBZldaYXp0N2VQODU2bWFlSUZhckZZSVFTODl5eVhTNyszdS92MFk0OTkvbDk5OUZjKzhwbTkvYjJ4RUdJWlFpamJ2Z01nSlpDa3VjcmY4NWR2Ky9IaE1MdWpiRnlRU2dnWkZFaUZ0eTdXRHUybjMwWnEyNzNHbXNTN2dLa2QxbmhFRUNnRXRyTFVreXIrdUt3eGl6SzYzMlpSTUVLczhPMHlOZ0N1TWRpNkppMHlkS0lKUGdJS25mT0g2RnNSbGRiSFlWYitxMlphdmFqejlIalc2NDY4YzhJMFZRaXVuWFRKMXdZSUR0ek1zRWhuYldQZWxxays5aDFKSW5GUzBNeE0rMzZ2UEF3ZHBtb3dqY0VIU0xPRXZNamEwVHBDcDNvK3U3WjRtV2kxNXRvZXhLK3RyWEZ3Y1BEbk0wRGUvNEVQOE9YSEh5ZEo0dFphYXkybTA0bG9zVFd2MGJwdG0vQk1LZFY5NElFSDd6NTE4dlJQSkVueWwyZlQyYVpVaW8zTkliMWVUeFJGaHp3djBJbUtUTFc4WURSYXA5UEo4YzR6Ylp2d0xNdFpMajFOM1VRTWd4Ulk0eG1OaHZ6SWU5N0ZIZWZ2WUxGWWNuQXdqamlxc1BJV2g0QkZDQkhTSkJHTk1kWExMNzM0K2YvZlAvLzVuLzNTNDE5NlZnaXhCSTRHUnlBYXhTWWhvTjc1NFRQMzNQUG1qUjhqK0NSSUFWYlFUUlFteFBMS0IwRnRvM0pJOEFMblZTejVRamdrTmhuakNUN0VVYWtEV3puTW9zRlVCbE0zTk1iR3FWZWlFVHFXVlVySlE0b3JXc2NTckJXdXN6YVdWc0hGQyt0Q0NFTGl0UGVmcVNibE4wTUlkZG90T25tdk83U213WnBHdkdaeUpGOEw0Z29HNmxtTnloZm9GV2dyQkhTV1lCb0lpWW9OdnZmSVZCTjh3RnZmVHJEaVF3Y2gyNy9tZ3k0eTRYeTQwU3pOalpnemcxVlMrVTZuRTM3NnAzODYvTS8vOC8vODV5OUE3cnJyYm80ZFA0WlNtay84MW0rSWRreTZ3azZwMXdFTEN5bGxmc2Z0NTgrZFAzL25oNU1rL1ZGbjdmbW1hWkpldngrNjNhN29kcnRrZVI3WmZTTFdycDF1aDQzMURkSXNaN0dZeHlaY0NJbzhKMksxcWtNNm5aQ0MrKzYvajBjZmZUTnJveUg3KzJPcXFzYlo2QXpybkNOTlV4YkxrcnFwUTU3bFRDYmpLMDg5OWVUSFB2b3JIL240azA5Kyt4SlFoUkFXc1JvL25GaTFtMzJTck5EOWQvL1ZzeC9XdVR6bFF3Z0NJWlJVNURyQjFOSGV6Tm9RbldTdE9BUWpFaVNTQUNLUUpSQUtqZlJSYU03VS90QVRNRmlIQ0lFMFRlbmtHVUZFWnhuVkxnT1ZWbGduY0ZxaXVqbFNxOGgvTno3Mk5TNHUvOXFGNUpOK1V2NjZNMjRHaE83YW9DK2x6RTFWWWVxS1F3bkhvOEhCVFNod0tBUDFkSWx1cDRHK0JTSktMU1AveEh0TWFSRlJvejJPbTQzRG16Z1ppMVlPSmdKRWk4UTNTM054dVZmdUlIQ0VTRk5aWmY4L055WFdQL3hIL3hpdE5mL1QvL2ovWlh2N0JLKzgvSXFRVXJDM3Q3ZmFhZWp2VVU3bHg0NGRXM3Y0NFVmZXM3NjI4WGVXaThXOXpya3NTZE5RZEFvNm5ZNG9pc2pmMWxvamhDQkpva2owYURqRSs4QjRmRUNTSkhRNkhjcXFaREtkMERRbVFobENJTTl6SG4za1lkNzJ0cmZnbk9meTVhc3RnMDFFM29ZUTFIWE5ZbG5TTkUxUVN2dHIxNjQrOGZIZi9OZy8vZFNuZnZjYnkrVnkxb0poVjViRUt6dHZjU1FMSm1mT0Q3YVBuZTQrSXFSTVJJaHFoQzdBM0FScUw3QmVFRzFwNGlXTHdlbFI3UzJVYmVPcXBjZG5LajV4NnlqS0VFenNReVN4cndnaXhBd2lCUjZQVUxHZVQvSUU0VHdpMFFqa1lhUHZqTWUyZEZoQ3VPNFg5YitxeHN1WFZ6bGllR0o0ck9qM3MvbDRIS3d6SXF4TURMOVhnTFRNUkx0d2xNa3l2cy9lZzB2SnNvVEcrWmk5bE1BM0Z0dUNLNXN5WXRaRUt3a25wVVFvS1ZTbTNXSy8rbkk5clN1Qk1JRmd2ZmUrTE1zZnVCSHZ2MUdBL1BmLzNYL0xmLzNmL0QvcGRyczg5ZFNUb2l5WG9tbWExYkp2bFRWV1cvQTBUZFArL2ZjL2VPL3Q1MjcvNjFtYS9kaXlYSTZrVXFIVDdWSjBDbEhrQlZtV281T29KYVoxNUZkMHUxM3lyS0F4aHVsa2dsUXlDcVV0SWtmY09SZUZvNFZnWTJQRTI5LzJGdTY5NTI1bTh3VzdPM3ZVVlUzVE5IUjcwVFhKV1lkcEREWkNXcGF2dnZEOEZ6NzI2Ny8yODQvOTRSZWVJUzZURjBlQ3d4NXBJUFhSTXZIRFAzM25Xd2RyMlIxU1NBUmd2YUIyMFcySE9GekZoZGhiU0I5aXFEakFPVWpVb1ZLQmxJSWtGUVNuY0ptaVRpVktnR2w5RUlXTUdDWlBpRWhrcVE1TExaMXBjS0VWVFlpVE1PL2E3QkgzRUJibi9yRGFtWDBsQkdvQW9TaDZ4M3ZIRVNFMVRTMXNYUks4KytQOXgxSDVGT0k3WWVhV1NpNmpuNGlJcWRRMUVxa2pnc3ZaNktudXlvYW1yUERPdFlFZE4vNHlsb2JYNjFuell2Qmh4ZHR5UU9pMGZveHY2QUI1NElFSEdJL0haRm5VaXZxVlgvbW8yTnZibzEzMEhaMU9aU0J5Q0xsVXF2UG9JNC9lZStmNXV6NGtsWHF2TWVhT3NxcGtYblJDVVJRaXozT3lMQ1hSS2JMbGhCOEdScDZUcGlueitZekZZb0dVRVJ0VlZlTkRXUFJLQXZTZWUrN2lUVzk2a1BXMUVkUFpuUDM5TVFlVFNXdDdwcWlxbXJxcWFKb21OTWFFM2QyZGwxOTQ0Zm5mK01Sdi9lWW52L3ZkWnk2M2pmaXlMYW1hVmZQWVB0YU85bEhwdlE5dmJ0NzU0UHFQNUVVeU1NYmpnaUI0aFFqKzBJdGNCbkZZdWJqUVRwdVVRR3BKRUJFNjdvUkFKUXJod0NsUGtpbUtRVTVkcE5TekVxV2pXbnlXWlljWFdDY3FLcENzbG9NRVhPUGJVWEhBV285ZDdTcUV1T0tuNVNkczR5YXJXY0h3WkhkamRMeHp0dHdmNitWOGltbWE3eTI4czhxWGtrT0YrV0FDWm1saTJTc2s0VEI3cUVPY2xiZXhRYmVOaVNQcWRwZ0FoS1JJUkROdnZycjN3djZGTmppTUVNSzNyL0N6UC91emI5d0FFVUx3bmU5OGgvUG56eE5DNE1hTjYrTEZGMThRM3Z2VlBrT3RsbjBoaEE2RTdPelpzOGZmL3ZaMy9LVkJmL0JYbEZMbmw4dGxJcVVLdzlGSVpGbEdudVdIKzR6VjNxTFg2ekljanVLeVRzQmlNV2V4WEpKbEdjNjVReGpJS2tDMDFqejZ5SnQ1MjlzZXhUbkhqUnQ3bEdWRlZWWnhTYVdqcTFOZDF3Z2hPVGpZdDk5OTVwbXZmUFhyZi9Sem4vM3NaNzRKeklVUVpSc2NUZnVoT2FXVUh3M1htQy9tVkZVWmV5a2hFa0pJNzN2THNkdTZhK2w5VlcwUlNEd0NLUUphQ21ybnFRMFk1Mk9KMUlaWEFJUVNoQ0NnZHNoRW9aV2tzZzZDUnltQlRoUnBKeUZmNjFBZUxBaldrZVFKblY2R0M1NUFWRGxFdFBUWkZWN0x4Z0J4Tm1DTXgxc2ZoSlJHR1B2SmFtLzV6SkV5VVcrZlgxdnZiNlRyeTBuSmNqcW1xY3JYTnVmeWo1ZFhoOEhqVzh5WWFxaGpIVTJhcFVnZFM3VGdQTTU1bkxIdFVqWnBWV0lpR1YwbWVsRXY3TGVyZzJxMnl0QkNDQSt3czdQenhzNGdJUVEyTnplWnorZGliMjlQZU8rRjkvNG9kaW9IOGhCQ1hoUkYvNUZIM25ML3ZmZmM4ek5TSnUrcXltWEhoNEJPRW9hZHJralNDRDJQSG42cUpkQUl1cjBlNit2cktLbVlMMllzRmtzRWdqeU5ISTY2cVEvZjlDUkpXQnVOZVBDaCs3bnR0ak9VWmNuK2ZweFNTUkV6VWFJU3ZBOVVWWTNXT2xSVmRlM3BwNS82blYvN3RWLzUySXN2dmZoU1cwb3RRd2pWNmdPVFV2cCtmK0RQM240bjE2KzhHcHFtbHExaWloYUNWQ3Fabkx5ei85YThyN2ZyeWdXZENHRzlieUVha1hXOUd1MmE0SEV0V0UrSUNDRVBJV0FRWktKVldWanRRTnJwcjlTU3pxaGcyY3RwNWlWcG5oQmtpTUdHUU1sb2F4djFxUUxPZUh5N1c0bTAzUkJuWk1ZOTFlek5QKzZzVzdhbG93VFUyc24rc2JRbk5yT1JRT1VyR05TUm9EajZvMzNkNkRmRWZ0NVdIbWhhODA5d1JoN0tzanZUa3FSV2NrQ1Jxb2xLRTRTU2w1YTd5eWVQWkdrcmhQRCtCdzJBOWFjdHNmYjI5b1NVVW5qdjFaRXQrQW83bFFHZE43LzVrVHZQbmozM29lUEhUL3lFVnVyTWJEWVRTbXVLVmNiUStoQWJ0UUtucFVsQ3A5dGxPQmlnbGFKdUdyUlViS3pIRFhtMzE2WFg3Y1N5cXlqSXNwVEJvRSt2MjZWcEdzcXk0dUFnTnV0YUtZS01ld0NFd0RrVGhFQmN2WExseWM5Kzd2ZC85amMrL3JFdjFYVTlXd1ZIKzJGWkJGWko2WlZVNGZ5ZDUva2Z2dmJWOE1GVXRzSVFzYWNLUGlTbnp3OUhaKzhlUENRSnNrZ1ZqWWZTQm1yWDhyaUZKSVFJSFFrdVpqa2xBUzhPamZoUWdpWmVacXlMVUpHb05CZ3hUa2tpU2JJRVh6V2thV3lBVjBNSTBjcTlCeDl3Ylhma1hhQ3BYWlRsQ1VGSVJFVnRQbDFQcXl0SHBuQUpJSXBCT2tveU9ra3ZNRHJkWXpZcHFLdnk1cHB1TmF1VDMrTUN5QlpXNHNIWEhrTkZjRDR1RXR2UHRLa2JmTlBFbll3U2VCSDlFM1d1alRQK0szdlA3Ny9VZmoweHF3VjgrQUhXL2ZuWERaRFZaRXA0Ny9XS3dMU2l2SVlRMHZ2dXUvL3NtOS84eUYvdUZOMzNKa2x5anpFMmpWTWlKWFFTczBWb3g0NXBta2IwclpKMHUxMU9iRyt6c2JIQmNEZzRuUE1QK2tPU1JKTWtDVm1la2JZeW9BUXcxbUNzWmQ0MjRzWll2SE9VWlltMWpxSW9xTW95K0lBd3hwUlBQZm50eHovem1VLy93dWNmKzRNbmdGSUlzV2gzRzZzcGxSL2txVi9yNXRUb1VKVVYvOW1wZFFxZE1MTkdRSkR0N2tQZjgrYU4yN2RQOXg2U1NJR1NXQmQ1RUo2QVFHSmFjSjd3RWNVYVdtVzFSTVltdmpVSXBiYU9ZRU1yS1JUVlRQQnQwRmdmWVJ2aUpnSTVoSUJTSXZMbVZ4S2pJVGJreGdhYXhxL1VEWU53L2t0bVd2MSs4S0ZxczBjQWtpUlgyZWhZY1RycGtJbmMwenZSWlRnZXNyYzB1Sm05V1dxRjEyV1N0a3hjeVpxdU5MZXM4U0RNb1g2dkQxSGtJdlphS2tvcHlkakVpMFJmbjd3Ni9Zd3B6YlI5enkzZ3ZRaUJ2UDBxMzRBQmNyUjlheDFmdzZIR2JRZ2hINjJ0cmIvNTRVZCs1T3h0NS82NlV2cFIwNWlzYVpxUVpSbkh0cmJFMmxwazltVlpScDVuak5aR0hEOStuSTJOZFJLZGtPYzVlWjYyQWdxU2xyOS9xSHpoZmNCWng3eHBzSzNXYlFpeHIzRGVrNlFwemtYckFXTU1pOFd5UmZFR2pHbGVmT3FwYjMvMFYzLzFvNTkrNmVVWHI2eDZqUkJDZlZnRGc1ZFNoQ0xWbk9nbElaR0NiNzN3TEV2alpBZ2MwZllWYVpMSjlOSDNubnhQVnVpMTRBZ21DT0hiRWJJaUxyaWQ1S1pjcUpTVVZWUWdWQVM4ajZXUnNZNm05aXVLMEVxbk5tcjkrb0NyTEs0eWFLMVE3Y1FxQkg5SVFvSjJrUjVhOVpOMjJVZ1F5QkN1VXpZZnE2Zmw1ZmJhclJqc1luQ3NLR1N1emdXRlNBc1IwbjRxK3R0RHlrWEovTktVVUlXYlFmSzlic0FLeU5qMlBzSkZ2b3J3RWVqbFdnS1lUR053dEhwalFlV0pzMDE0ZlBlN3UwKzNnVkhIbmloNGhJaksyMi9BQUJGSDJqYjV1bktxQUlvUC85aUh6OTkzL3dOL1oyTmo4OE5abWcyVkZLSnBHbTQ3ZTVzNGYvNE9OcmUyeU5Jc2xxOEJnb2lYeWJWcUw0SUlYVmlXTmNHWEpNbXFaNmppay9jSTJEQzBUOHNWUTgyMkJqUnBtdUp0M0tJNzU0Tk9FckZjTE9xTHI3N3k1VTk5K25kLzd2SEgvL0JKWSt3Y09OcUlyOGFMUGtCd1ByQXpMZG1abG5MbGtSNElvdFdGVG9TZ0NDRmtKOC8ydDA2ZEh6d2NFTHAyUGl5TmJ6TklxMTdvNG1XdnJjUFkrUFZLMGZKQ1hBdjlicUpRVlJvRW5nQmV4QWE3NVU2RXhsR09LMnh0NmZiVGxzZXlNZ01WaDIrSlhRRWNtN2hmYWZzWUwwUDR1cGtzdjkxK24yMGpUQm9DWXV2MndTanA2aFBPZTFRbVNYc0p2V1A5NkhickhNdTlCYjRLaDVKQ04yZlJONE1tY0RQRGVCK0QxQVVmUjlFQmxJNWlHS0ZkQUFrdFJkTEo5ZzVlR3YrdXJld1VRVTJJNVZXQW9HeEx6MzJEbFZoSEEwTzF5NzVzNWNMMHdBTVBiUDJuLzVmLzlBUDMzSFB2M3hnTUJnOWxhYXJTTk1OYTEvSXZJbWJLR0lzMThkME9MbEMzZUttVmFucWFKRmhqb202U0FHdGQ2N0hkc0xvWlVxN1V3SDA3NW5WNDU4bnlESzBUUWlBSXBVaXlUSXhHYTJKM2QrZmd3b1huZnZPWGZ1a1gvOFdGRnk1Y09iTGJXRFhpYmpWN1AvcTloaEFrQXVuQzRiWjhOZGJOYVBYVlR0N2VQemNjWlNlZEQxUXVISEhZOCtnMkVHYU5wVFNldW1tRHg0SnJJai9DTkFIYmVLU0xDRjFQMVBEMUpzcmorTXJSTEtMTWo0eXNPMVpzUVZTcjBkbU9YSTBOVkUyN0dIUXgyeXA0eGMvS2oxV0w1cUROSE0xUkNHSjNMZHRLY3JWV09VY0RpRnlURGp4ZDA4ZVVEUURWdk1RdEhhRTVzZ0ZxcFg1V1U3T1ZNa2xZOFVmc2F4K25Rb0NJTzQrUTluTk1aZjlnL05MQmswQkRvRnBoc0E0M2c5TTNWb0NJSTRGeHROZm9DQ0h5RDN6Z0EyZi84Ly9iZi83M1Q1OCs4K05WV1E5TlkwTlZObUkydllKS05IbWUwNWlvUk5oaXNscGtyVUNxRm0zYVhrM3JIVlhkdEkyc3hEUVdZMXVFclhleHZISU9aMTJRVXVJSkZFVUhwWlNRUWlKa2lEVjViWmhOcDlPTEYxLzl4cmVmK05idmZlU1hmK2x6MTI5YzN4TVJtbDZ1cGlaSEFpTzg3aUdnVzU2UEZ0RXlReDlaREtZaDBBVTZiM3JIaVlkMEl0Y2I0NElBa1NjS0lUek94T2JiRVora3NwWDNONFlJTS9FQlYwZkZrdURpcnNEYlZzSFJ0azJKQjF0WnpMVEdMWnZvTnRXeTc2U0tUVG5FU1pYenNVOHhqY01ZUjRqYm1qcVV6U2VYdTR2bjJxdmQzQnpTeHBGWlV1Z1RNcFZiemRMaFBBSWxZam5VU2NqWHVuVExxSURZNklwbWFmRDFUWGptWVpTMVg2NlFiWWwzTk5IckZ0YmU0c0pVbmdxaDFJdmpsdzQrM3N5YTZaR1N6d29wUWo3TUtQY3JmcENQL2hOS3F0ZFlsSVVRaXJ2dXZIUHRwMzc2YjcvbnpROC84cE41M24zcnpzNWVJaEFoU1JKaHJTWE5NOHF5cE4vdlIyS01pL2V3YWNHQjdUS0ZKRTBJQWNyU3RDSURtalJOVzlWMEY3T0VkUkFFeGpSSXFWWVp4RGRORTZSVXZzaHp2MWdzeld3Mm0xeTlldm5WNTU5Ly9za1hubi8rNmE5KzdZKys5ZlF6VDE4SDZqWTRxdGVWVk9GN1BBQldPTEVFU0VJMGJWS0RMRW5YdXVtd1NPVElRVkhWcm52MmRQOVJJU21RZ2x3SU1pbFpHbjlvTytEYlhVVndVZHBIUVNSQzFZNW1acU1nbkkzYVdMUlpVWVNBRWdybHdTMHM5YmpDR1VlU3F3amFYVjFLQVlIWXJGc2JHK1JZV29YZ1BHem15VjVZMXQrZU9iK3FkZzVGMTl2c3FFV2VESzFITlpaUW1aaWZFaTF3aGNaMFV0SnVqbmN1d3U2ZEovaFdYYVVWcWx2cC9jclg5U0lyNWRiVklsVHFCSlZxc241dTdOSitldnppd1hQdDUzQVQxeVlJK1NnUGI1UUFFVWVxVFJYcmJwSEZoUi9aVC8ydHYzWFhYLzJyZitQdkZVWG5MeGxqaGszVGlPRm9SS2NvUkZNM3pCZHp0TkwwZWoyVWprTEZkVjFGY28rSVdsT0pUa0tTYWhLZGlLcDFXekxHa3VlcjJJbmNiZWNjd1h2YkdOTTBqVjJVNVdUeC9IUFBYN3A2N2VybDJXeTJHSThQSnNZMDQrVjhzWE5qZC9mU3pvM3I0MWRlZlhsc3JTM2JqN0lCNmhEQ2F1bG52OGRHUEg2UGtJZWJTcDNGbmNmN2E3ZHZkSStmV2V1OGFTMVA3dGpvcENjN2lib3RKRXBWdFF2SjU4Y25ibHdvUlhwYkJ5OWd1WkZTRllwYVI1Zk4wc1BTZWJ5VUtORUsyZHBBc0NKS2lFNHFtdHBUcldpdFBnYVNWaExwQk0yNHBKcEVCWGFWeENWak1BN1N1TmR4UHNTQTgrRlFVOHQ3UkM5VjRhZmZjbTVMRy9ldS8vVVQzM3h1ZjFLK1hsbFVwNFhPaTFHMmFWdGVmR2o3QjlyR1B3Z1JsVkdrYk9mUzdTUEZIa0dpeVp0THp4VThYclRvZTkvZW5yaFpsMlNERGttV3ZMRC95dDduWE9ObVIrQTdUa2dST2h2Rm9hZklHeVdEckZaQ1dnaVJoQkFTcWFUNkwvL1JQL25odDc3MWJmL1hMTThmTGN0S0RRWURScU5ST3oxeWxGVVZkSklRZ2tjS1NWM1ZLS1dFMXBvMHphSTFjSmFqdEJLaGZhNU54aE9ubEdycXBtbDJibFRMOFdSOFlJeTlhcTJaeldhelpqYWRUUFlQRHNiWHJsMTk1Zm5ubjcvMnlzc3Y3YzNtOHdrRTQ3MTNMZDExdGVWeWdCTkNtQkRKVE9iSTV0Z2xTUkt5TEF2eitaelc5bG11QUpRQjh1MSt1dm1PTzdidXVtT2o4K2IxSW4yNFNKTjcxM3JwQ1NsbDZrTVFDQ25LMnFDMXBKbFk3TDZGNTZvb2hOQlJ1RVJndWdxemxWSm5Bam5JS1pLRXZlQ3B0Y1I2MGZZSlVGZU9ldGxRRzA5VFc3ejFwRnBIRFZ6bnNXVkQ4QjZWS1pTUzdWZzhFcVpjaUtRcjU2UGduRy9oSzg0SDNueG1KTzdmSHFTSlZqL3hVKysvNzhJLy9ZMXZmTHpOL2l1QjBpUWZwTDE4bEo0M2tmVFhvb1lqc2FwdUlvYktHb2RwR3FweGhkbHpyeTFLaitLeTVjME1Fa3ZsK090cG9wQmFvN0tFckpjdDZ2M3lFN3ZQN0g2M3pSeDEvSnp3T3RjQlJKaThNbjFEQllob044WktLU1hlK3RhM3JmMmx2L1JYL3ZKOTk5Ny9IOWQxZlk4UGxWdGZXd3VkYmxla2FScVUwcUkyRloyaUVFR3NjTldTNEQxSmt2aTZycHVkbloyRmxOSmJZK3FxcnFjSCsvczN4cFB4N3JWcjEvYWFwdG1yNityZzZ0V3IrNisrK3NyK1U5OTVjdGRhVzNGVGZOd2VhYWhwU2YwcmduKzdjd3VIejdnUWdsdjllb3VqQ2ttU2hNRmdnRlk2TEJhTG96VGZET2ord3g5OTZEMXZPcnYxazZHdTdzK2tPTk5VSmpPMW9aNDJRVWl4V240RjZZbkI3WHdVSzNBUkdrSWRFS1ZISGpRa2wwcHlKWEhka2daQkVJSHBSc1pjU0dhYUNFRUpNVWpNb3NhV2NUamhsVUsxMnpmdlBDcUpZRXl0RkNJVnJTQ0R3THNXK2VFOTFzUlhZejEzSFIveC9ydE9ZSTBoVC9YV1crN2UvbXMvL01DcGIzNzVPNWN2SEhub1pka2dHNmxPZXI2MjBXcFp0UDJNcVQyMnNSRW1ZaHpWcEtUWmFlTHovdWhwYWNQQkhlM2NXbG5URUVHWEtsRWtXUnFLVVZjb3JaNjkrdXplNTRJUGk2TzlSNGlZckRBOE8yUitmZjZHQ1JEUjdoN0VlOS83UHZsMy8rN2ZlOWVKRTZmK2l5UkpIeVdFWWEvZmMxcHBseVNKODg2RnVxNGgxQmhycXVsMHVuZGpaMmM2SGg5VVRkTTA4L2xzenhqN3l1N096cVViTjY3UEVjSTFWZDNNNXJQNTlSdlh4eGN2dmJwdzFwblhCWUUvMGp6NzF3V0NiMHVrbzMvT0EwRUk0VU1JaHo5dmZ3eHJhMnVoM1R5SGMrZk84cld2Zm0wbEc3NmF5S1YzSFJ0dFBIenV6TjllNzNkK1lqWmRrT29FMjh6eGJoRUVRU2dod1Rpc2liMlNieXdZMy82UGFSMWpJbUF3K0hZMmJBTXllREtsR05RT2ZYMUszaGpTUkREUE5Udk9zRmhVR09md3dVY0owc2JnNWMxRmc1Q3hLVWZHMGE1c2xVQldPbDNldHB0c0Y4VVlIank3d2IzblRuS3d2MC9kR0FiZDlJRVBQSHJ1Ujc3OG5jdFgya3NwdEJSWlhpUURJMVVtM0twSGlzU21wcktZaGNGV2NlSm9aK1pQM2ttRUk0OHMwWDU2Q1lnMHloSHBSSk1QT2lMclpjdjU1ZG5IRnp2TGkwZDZEOXVpY01KeWI4bnczSkEzd3RGSEVUajlmais4NzMzdnYzZlFIL3pWdmQzZE1KMU9QeitiVHB1cXJ2eGlzYmh4N2RxMW5mbGlacHgxQVlTcjYycDgvY2IxNjVQSmVGelh0WEhPdWVWeWFjdXlORWN1L21zdTlaRzMyZjhKcjNBa0tBSVFwSlNIc2pEdHI2LzJJZUhJaXhBUEowNmNvQ2dLbm52dU9mckNrMmtwS3V1UGlweG43engvNnY1RUpHOWFMaHcyNkNDREVrR25xS0tsTUxRalZwMTZoTE80VUpNSTEyNlJBejQ0bXRKaVhJUHhJWHB3ZVBDcUp1UXBWaW9xWStPT1orN1lTRFA2UGpDdUxBY3FNTmRRYTRtVGdTQkRxem9TWXJDMHozMjFnczZMdUlTTGZVYzRIQXAwUnltMmNCaHIyZGpjNE1iVmE0VE1GeWMzdSs5LzIzMG52dnJWWjY1ZUF2eGR3L3plQnhMMUg1a1hwNlA1VmdjdkpJME5OQXVEbnh2c3JLR1pWOVRMRWxlNmZ6MTJlTGhaZnEyNDVsazNEOFZheDd2YVBiYjM3TjduZ3ZOVjIzc1loTEE2VTc3WUtNTHN5b3lyWDcvNmhnbVF3Mis1MysvemhjZStjUEVYZnVFWC91c2JONjRGYTEzaXZWUGVlMFVJamppN1B2b1dIZUdkeGN2YlFwZmRpbmdXVFUzRDBjd1FqbVNHbFJiU1lRYjRYcGZlKytoS29aVW1MM0traUl3NkFLMTAyTm5kZVkzRTVYZzhaajZmTTVsTXFLYjdCQ0VSK05WZ0tkRks1bWMyUnZkbldwOHcwVmxHQ0tWSWl4eWRwN2pHVWxVTnp2a0lrUkd4cGRkSkRBNmxOU0U0ZkZVaHJFTllRekFXSzl0YXZscGdoYUJxR2haVlRaRmwyTWFnbEdTN3lOa09NS2xxeGt2TFRIZ1doVUlsb0ZPTlR5UmVTWVNTdUhaTDcwT0lkUFpEdm5rZ3lSVER6WnhHUU5uVTVGbENwOWRsV1M0NE5zcmY5UDVIYnZ2UWt5L3MvR3JWV0RmTWVHaFFObThKajE5S0pqcHdZOVJIbkJwR24vUjVqU21iS0k1ZG0wUDgyTC8yOFRFL1NLRW9CaDFCRUM4ZnZMai9MOHY5Y3E4Tmpob3dBbnpTUyttZkhqQzdQT09OY3ZTUml4NnVYTGtTcmx5NXNudGsvSG5UWVZnSUtlSUpSeTYyajFyRTRmRENyMHFlVmJsejlNZlZiclpWNmd4Q2lLTy9GMHNLSVVMZE5LOFB3bjh0dFBIcVhMcDA2ZVkzbUdaUmg3bEY1QUxwMmZYKzZPUmEveUdFbE1ZMkxVekZvclVpVlNrR2c2c2FISkFxUmVNY1FVaFd6THV3MHRaTlVxVHdKQ29CYWRBRXRJcE50ZldlcWpGTWwxV3MweEUwTnU1MmJJRGN3OGhDYmp6ZHBVTW5rclYrenRnMFRLMkJrMzM4ZXRGaXUrTEVhclgvOEM3UVg5ZmtIUlVSdzlMVDFEVkZwNkJjekVQVDJQVE9rOFAzUFhqNzFqZSs5dXpWcXk3NDI2OHZ5MjVXQzhTc3dqMjdoOS9zb1c0YlJXczI3M0VyYWRNL3hWWmJKSUxPV3Blc1d6VE50UHE5OFlzSDMybURJL1llYldsbEZpYndCanY2ZFVsemhlWDBSeVpCelZGczFHc0NoUGFTRXk4OHI1RWU0MmdKUkZzcWthWnBLSW9DMDVoRG9XbHJiWmpQWnhBQ2Q5OTFGMy80cFM4ZGNsQ09YbnpyTFBQNS83SEc3c1ZydXpqblpTQ29kanFuSDdsdCsvYjFJbitrcm0zd1BtQ2RGYTZ0VytxbVJDVnBITU1xMVk1QmlTamRWZ1d4YVJxQ0NMZ1FZZWhLQ2xTZUhycFVhYTNKcFNSUEhjTnVGeUVGcHJIVTFqQ3JHMlpWdzlKN2xtV0ZiZUh1ZGUzWVd4Z20weVdwTmFoSlNmaWhNMWdwQ1MwZzBiUzdqN3luNkF5U0tLanRIS1YxZExFb3JjbXlURFIxRlFaRmR2YmRienI1N20rOWNQMVRqUSs5ZWRXSXk3Vm5VZ2VVRDhoclU4TDFCVW9JTWlsSUFJU25zcTB0QXYrYVdqd0swcTJFL2xZL2lNQlRCeThjZk1xV0VkcHpPTlpGZUZWRUN2V1ZQN3I4aGcwUVh0Y0x2SjRkRUZha3B0Yzk5WSthbjd6R0NNVzUxK1pycFJSbFdWS1djVVR5bHJlK2xmTzMzODVIUHZyTGg5djA1eTljK0o1WjRVOXo3anQ5bk85ZXZvNFVRb1NBbElKVVNxRTI4dlQrNmNGc3N4R0N3YUFuTUFKckRQVjhpVmFLWHA2UlNCVTMvVlZEbGlTSUVCMXBoWVF3aXpEMVBFbnczcUdGd0huSFlsbkYyYjV3SkZLZ0U0MFBucnpJTUxWQlZWRWVkZFN6ZEtjcEJNSFYyWkxnRElsekNHY1J4ckowNEs0djZWeWJ3NmxoM0pxM1pqdENDdm9iR1NxUk9PZVpMR3V1SGN3NWZtd2RaeTFKbGxJdGw4SmFtOTV6ZXUySGJ0OGVQYk8vUCs0c1pHQm5HUmN3dVJRb0FnSVhuYVdpSm5ZMFhHay9mTnNHU1gza1NSbStCL3hkclVuNngvdGtuZXhnZG5uNmErTlhKaThmZ2JrWUJDN0wwNkR6Sk16MzU3eFJNMGo0SGtPOTE3NFhVaklhclpGbEdaMmlRMTFYaC9SWXBWUzQ4TUlGVnZqQ1ArbHllKzg1Y2VJRWcvNEE1eHhYcjE1bE9wbXdXQ3dPLzh6MHo5QWJRZ2pRVWduWE9sUDVFTlRXY05BNWUyempmRmxXTWgwTWdoQlNoSFpTaEJDb0pJbFNvYTJxWWRTSWkxQVNMVFhXTmlzL2I1UlNlR2RwdktlcUcrckdrS2I2RUU0alJJaEtqVUtTZFhKVW5rVXdabG5Senkxbk5vWk01bk9NTndSckl3TFpCdVl1K25XSVNRMWJEbWRXUW5BdUJrY21DUzZLenBYemhtZGYzT0hCelJGZ0l6NU5SRW1nVVMvZHZ2L2N4dDJmdnJ3dlYzaWFMR0tIY0I2a1VvUVFxSjA3ckxWWEU5eWNtNFlzcHEyVlhqTnlGQ0I2a0cxa0lldm13ZGJ1aWYwWERyN1ovak9IeUFXQkNHdkRFY1BoZ08vdVAvK0dDeEQ1dWhMcmYrY1Z2c2VKbmc3T1JhQ2ljNjc5K1IvZmtscHJ1WHIxS3M4Kzl5d1hYcmpBczg5K2wyOTg4eHYvVnI2eHYvOHpmNGRMZXhPYzk4SkhyeEVOcUkxdXZuSDc5dVlEV2FjcnN5UVY4MFdKTVphcWJFQXBaS0lQYmRtMFN0QTZpVXU2V0lwaGpjVzNoanQxVmVGczdGL0txcUlvVW5TaXNNNFJRc3Z6TUJaYjEzUkdJL3ByUXp5QjJYTEp3bG9tVlVWZFZTZ2g4Q0k2UExsd2N5Zm55M1lFMnppYTJwSG1rbUtnb3lBREVVMlpab3JMKzNNV3l4b2hJa1JFNndSamJFaWt5Tzg3UGJvM2FEV3dSOXh0SysrcGdTUkp5WldLamFZNHdyb1ZOL1VhVm05Y3AzMWxSM2FGbVJEMFJDTFNMTjJmdmpyOXZXcGFWMGNnUzRjY29vUHhoSmRldVNnazhMZi94bDk5UTVkWWYvS3d3bnYyOS9mZk1OOVltaGZVTGdnZnQrZUhzSXQ3VDI2ZHluV3kzWFM2SWtod2pTZlJPcUtPQTlpcUpzZ29zbXhOamRTYXRGWGxDTjVoblNXRVFKcG5TQ0ZaenBla2lhSmZGT1NkbE1ZNnJQT29MQUZyOGM2U0ZIMmM5MXkvZkozeHdRRzFjM2dCQjVNNWRXUHhTbUNzWTFXUkpqTDZtTWZSY2NCWVVJbGtkTHc0N011VWluN2phWkZRaWdYVGFjVmdrR09jSTBrVHBvdTVzTTZwNCt2RjJVRXZFOU9ES09adFcyeVhKTklLQkNGU0RjUFJubU1sdEhEVGh1Mm9yNkdTRVI0ekVBV0Rxa3QzV3FpbUtPNTRmb05ucnUvdHpiZ0ozN0dBcjZvS0pXWFlXRjlic2ZULy9BWElHKzNzWDd2Q3h0cUlxOWR2aUhBa2c3enA5TEU3czI2dms5bEF0WEszQlJJbGNaVmhZUzB5VVNSRlJsVTFGRklpMHhTQm9LNGFacE01MW5zNlJXUkVHdTlRYUdRUzlXY1RBVXJuRVd4cEhUck5LUG85ZG5kMnVYSHRSbHdmU0pqV05WY1Baa0JnV1hza2dhWmRRVFFyU29hTWpsRE9PNGFiQ1RxUmtSUFQ2cy9IMWFjazdhZVVWZFZhSkVpOGt6Z1BkZDJJMmFMYWN1M1ViVlgzck5DWlBuZ01OMjJoT1Z4M2g5ZlUzcklGcmlVaDBtZnpWSkZtR2YzUmtNRm9TRTQya2ozMU15Y2Z2bi83eVZjdS9yTm5Ybmk1RWtMWUl4Tk5BdGpSYU1RYmJZejE1elpBRmxjdnNwaE5oVmlwSVlKYUgvUjZKN3ZGZmNHSEhLbWliRTBySmVTUHlJRnFwZWgyTzJpVmdMTTRaMG5UaE1yWnlGVkJZT3FLeWpwQ29oRUtGQkdTTHFVaTBaS21yRWs2QllPTkVjYlV6TWJUQ0l4U0NvOW51bXhZbElaQ1JmNnEwb0txQ1pTdHk2d1FZS1hFMlVCL3FPbjBkQlMyYm8xb2JpSjhRUlVKeGtiSWlFcFNralJCU01saWFmanVxd2V5WERaL1RLUkVjZE5OdWxxVmRFZDZFTTlyUGRaWHBaOExVTm1Bd2NCMEdSZVdBeWRVb29vdS9zUDNibTkxVk9DZlB2WFNLODhjSGZxRUVQejEzVjMzMUhQUDN3cVFINFR6MHN1WEtLdUdBQkloRkNISWgwNXZIVDk1OHZnOU9rdGw2aDNsTXVyTkxscEl2aVlnQXVTZGdqUkp5THM5cXNXQ3VxeXd4bExYeldzb2RWSkcyWjY4MnlITmttaXNHU2NVSUFTRHJYV2tnUG5lTkFhaml0QjlCRXptRmNJN1hGdXlOQzV3NEdPZ3FWYVBNNlNhWHZDTStnbFdDbGJVdXhZWFJHZ1Y3TXZLc0V5aVdEUlNSZTBzQ1M5ZW12Q0ZKeTZEOVljWFg3d1dXb1U0TXFWU1I2QVZSd1Bxc0lkc2h5L0tPb1NORTc3SndZUk9ucUd5bER4UGs4R3cvOTQ3MWdlamM2ZmYrYysrOE0wbmZuODZtMGRZVVFoK3NWajZwNTUrNWxhSjlZTndudCtib0xScWRYV0NCRGd4Nm00SUgwWStCRXdWclNtY3NRVGpzQ0xTWTlNaVF5aEZYVldrQVhTVzRLeGhPWjJ4S0N1Y2MrU3RiSkVueEwvdkRHbGVrT1Y1SzQzajZHNTI4UWdXKzd2VXRjRzIrSEpyTERVaEJtK0lxRndwQmRjTTBRMnE5Zk9UZVVLcUpOdnprbm83eC9xYndJVVZHekdWVVdiSTFBNVhPRXhqU2JLQTl4SFAvdXlsTWZzSFN6TCtPQm5HOGxySGc5Vm1lUFZyK25XNG9OWGZUOXJYYWtFV1FtQldWdml5UWtraEpuc1RuYVg2TGFQMWpXTnYyam8yK3ZKaThVdldoeG9oREs4UkVIcmpUYkgrWEoxd09PaU5qc2FBdXZlMms4ZWFwdTVVeTJncG9FUjBWN0xPNFkwbDYrUWtxV2E1V0ZDV05WVlpZdXNHcVNUZTJVaVZVQkpqTFo2WUVWWVp4ZHFHWnJta1dTelFTbFAwZWxUTEpTcEowWjJDdE1oSnNoU1pLQ2JMaXJLSzJVaHJjRnJTQklHV2tYMGFBSlZwMXZkbVpNRVRrbFkwR29FTUFSVjhxKzBiT2YzU2V4SVZsZDJqNXdsVWplZlppK05ENHRZcU82Z2pDNjlWY0NSSGZsMGNDWTRWY0Rmd1d1MVZlWE5IaUJRQ3JUUzZWWnh4empGYmxGeTlmT1hNM3NXTDc4eVZMRmJKUzd6ZTh2WldCdm4rbmlPZlJ3RGtWcGJjRVl3ZFZJMEwxam5oZ3dmbkNNNlRwZ21wMHN6TEplUHBuQ1JQeUpxR2ZxOUFFREEreW5tdTVHMmNoN0pjUmplb1BNRlp5SHNwb1RHb05PWDZ4VmVaN0IyUUp3bFZiZEFpOHZ5YTRMa3hYVkkzamlLQlBGUE1ncUFnTUltTCtFaFdLUnM2dHFHOFk0alhpdERZVmxwSVJPblAxZ0xCVm9ZOENJcFU0YjJucmlMdi84bVg5cmk0TXo4TWhLUEdMQnhaQk1vajQ5eWpCaTZydjZlT2xGclprWit2eWpNWlljWUFGRWxHOEk3R0Izend6anEvc3dpSDFadDRJOTZoUDljQmNpUTQvQjNiV3lwdDZpMlhLR204RUw0VmZ6Q05JZE9hSWt2eHpySmNSdE1qMllJRmhBODBWVVhUZ2hlZHRRZ3BXUzRydlBma2VZYlNPajVwRzBQU0tYRGVzcHpQVUVyUXRBdkVsV2kyY3g1VEd6SUZlU3JSU2pKZlJCKy9La0FYNkFub0JvZnE1TlFibldqaUtTSlJYclEyeTFwSGJGaFRXZFlDZElzazBuNnQ0OGFOQTc3eTNXdVVObDdjNXNqbFQza3RoUHRvWTc3S0d2cEl0bkZIQWt1K2JtRzJTam1KMW1ScGdTU3dLT2RJQWdLbVRvcW5nZzMyc0cyNkZTQS9ZSkZ4QkVXOEtFdnpxVzgrL2ZuMUxGcy9OaHpjdDc3V1c4dTB6QktkRUZSVUhWQTY2dVVxbVpLbENTcU54ajFhS3dTUlF4R0V3RGlMRnBvc1MwZ1NIVjFkcXpJNjdDUUpzMnMzd0hteUxLV1JBYk9zYUpvR2F3TlZaVm9GeUFoeHI1MW5ibHZOckJBWUNzaGxIS242dFFMWHkrT09oR2hyaFFzSXJWRktSS1dVcGFIcklHbUo0Y0Y3YnV3djJaOVdyNEZaci9vSXcrdlVLdHBBV0ZsbmRZZ09RYlFjT0hPa0ZMUHRudzFIK2hnckpDbFFOY3RZNmtWY3BwQ0MyWTBRWHVHUFV4MXVCY2dQVUlsMWlDSytQcG5Ydno2ZC80RkdYRGkvTlhyclQ5eTE5UjlYczhuWjJpdHlxVmdmREpGSkF0NHo3SFVSQkRwNWhwYUsydnZZZXh5NnVYcDBSOVB0ZFVoVGpmTU9wWE4wcDhOazc0Q21xdW5rR1VXM2c1L04wVklRRXMzU1ZPek1Gc3lxaGh3d3dsTTVjQllXSWFBRGRDUm9GVFY2M1lsKy9QSjlHNXcrSUxRazBUTHlRNXhITEMzbkJoMkVnTVpZc2tUeDRyVUppMFZ6Mkp3ZnpRNytld1JNZGFRWE1VQVRBamtydk5iTnZ1TjdNY2hqU1JYeGFFa0xYWkVJa0Z6enNOL0dSSVFXK0JDR0VDYTNBdVFINDdTYUFJZFp4SVB3VXBadk85RmI3NFZxWSs1TXVEcmVGOHZTb3JpT0RZSWlUVmp2ZDlnYTlUaSt0VTZ2eU9PSEx3U1ZpN1RZVGxIUTdVUlhwMlhka0JjNVNWNHczWjlRMXhVNlZjaFUwelNSMUIwRUJDa3hJVEJlVlBHeXRkT3JlZU5wZkNRb25sRFFWZTJIMHM5bytobkJPRlRyYlNpRWlCdjBkdHBWVjQ2OGRxeHR4QTArd1BWRncxZWYzOEViRjVlQjM2TjNXUFVmWGtiT3ljcUpha1VjbnhPbFhaSWpVNnVVMXlxUit2YlhVcWxJWk95dlZobExDdUhLRUY1ZCtyQzNXcU1nQ0RvRU5vRmJBZklEY0pTS09scXZMYmx3OXgzcmJkNHowajh4bmk1NjFyaFFTSW5Ya2lEaXNuQlMxa3lxT1pmSGU0UVhyNUFrQ1p2ZG5FeXJLR0dmcFBSRUlIY2FLaGRkbzRvY1V5NnB5eVZCdHZxNXdWR1g5YXJVbzNHT1JkV3dMRTNzQlZKQmtnZ215NmpiZTFzT21WL3RPUVRtZUErVEtFVGo0dUpReHVCSUVvVVBVZmFuS2cxbnZHVFlTYWtiUzZvVjM3eXd3OFZyMHdoZlA5S0VyMDdSVHA0TVVTTzVjWTZGTVlkQjQ0NjhhbDdybzdPUzE4emFuemNJS2dKOUJDbmhVTzlNQ3B4UzRxSjFoOTZPam9BWFNnYjNCbEF5K1FzUklBK2RQOGR6cjE2aHJOM3F5U2F5TEZkLzk0ZnUrM0MvbWQweFg5WTR1eFM5TkdXUVo2QVZzN3BtS2hwc0t4a2JwTUhhaGl1VEpkYTNuQmd2Y0Y0eTZPVjBPem1aMXF6MzlpTzhYUXJ5YmtaUDVVanZZaU50WThsaG5XTmFOalNObzVORXFaejUwbE43T0puQ1FMVXdEd09objFJZTYwWU9lc3M5RjZ1eGJ1c0hVbHNQT3lWM3J3MXdRRlU3NXBYbEd4ZDJFRzJnaFNNWGU5VjNGRWtTQTlBYWt0YVFrL2JpQnlLSlk2VTh1b0s3aHlNOVNrMlVxV3c5Y1JBK1VIblBTTGI2cG9IZ0NZMFQ4aFZ1Q2dkNUlHZ3RFWTViQWZLRGNFYWpFZkxTMWZhQkxCUWhpTHUzQnFQdFBMbGZGaHZKaWJRZmt0NVVJQUpOWFRGZkxpanJtbDZoeUpLY3lyaG9ueEE4amJWeEllYzlqZkVJNjdtOFA2TzhNWTl5akVyZ3BDVFhrbEV2STg5U1Rnd0x0a1lkVkJBb0QwMWptU3dybFBEeHFld0RTeDloN1lXNlNha1ZVbEtlNnRNVUNhR3hzWjRYTjFYZHJmVVIrVHR2dUZNbW5Ocm9zcXdOV2dxdTdDelluMVNITTlVVkpYUjFKeE1SQTZ6eUVYRFptSVltaE1OR2ZHWHljblFYVW5MSXBhWmV5USt0WkZQYmYzY0t6SDJnVUNxczVja3JvVEZmSEJ2M25SYi9hRVZVbXZHWjFyeFVON2NDNUFmaHBOVWlxZ1JHa3F3QzVFaXhWczZtbTQzeExKb2d0dFpHakxZMnFWM0RZckZnY0gyWHZmMTlsR2g5TzBKZzBSaU1kZmdRZlFiamxDdXdRV3l1dlkrUGFSc2N4anIyeDRiR3c2dlhaQ3lIcEdTUUtFS0EvV1ZONWtGWjZPU1NKTUN3TFFQdHFvWWZwTlQvLy9iZUxOalM5Q3JQZk5iMy9jT2V6cFJ6Vm1YV2xGS3BKdFdnRVFsclFCU3RsbTNBZ0R1Z2pkMWhvc01kQVVRUUJCRytzaS9jZ2R0MzdiNGcyaDF0ZHdkeWcwUTRFTEl4TmtZeVFvQWtiRmtEbW1xZXNuTE9rMmZjMHo5OHcrcUw3OThuVHhXNG95MVZZYWx5cjRoZGVTcnpaR1ZHN2YvZGEzclgreDRaNE52a0dpdFpVamJKRnJadG1wVFVCOXMxRDU0NFN1TUQza2VLWHM2TDE4YnBrT3ZRcmxvT04rcXExTjRkakpQYWhVc1hONDg0RnFQY3RnTk1mL0dnSksvMWxCSUVuRUxNQzRJSVRmRE12YWRXbFRZdm5Dbkx6MHgzOTdjT1ZXc1IwRHpHNVJUcnV5V2VlK281WXVncWkwNlFlaWk2V3MrYmdZdktiRklUbXByNVpNcG9kY2pHMFNNY1dUdENOWjF5NDhZbSs5TUo4N29oeG9qMGUzalY1TXNuMElTQWF3S05hMm5kelgyQU42bFhrRXdJVVdoYWg0K3dQMDFOT2NCZVRHemRRWUNoS3BMQmJqQ01Na0ZNWkhKeVNHMkZ6Q3NtUzdwWTFnZ2hScndtd01TOWhvZUhJOVpISlR2ekNpTlF0Wjd0L2VaZzhyUm9wQjJ2UE9ySkRwVmNoemQ0aC9rZml4L3RvUnJKeFhnZ0NaTkw0b3dOcmFYSVN4VFlxV2JNWGN1Z2FlNHVCcjIzYkdYMlM4NkhBNjJDeFNCZ0NaRHZrcmpnSWliTGhCQU8yQmFyUlRacUdsY2dRbEhrS0VwMERmVWNXdStZejJ2NlpRLzFNQ3FHRE1vQng5YUZxSjdkNlJ5VmRKODZuVGZNcVJIdkdQVHp6dEVxMEVpazhVcVJHV3h1R1BZTk1VU2FPblpNWDJIU0tGVUR6a2N5SSt4NUtESkRMeFAyVjNLbUc3MGtMVzlUdHNxTXBBVmwxLzNPZHl2dUdBdHZmZE1HTTlja3MwNmJTcC9TcGdjWXZmbkFMMEFRRDAyeUR2Y2tsbGVLRVpoRGU0OXdxSThKaDM0TzBpMUszVFNFRU1qemNyRk1WTk8yZHVaY0htTDB2RkxLU2E5WDlSSWczelVqWGw3TmJaRHM3TnJnTEtxamtCeGdrN2UzUnFKR2lKSEpaRVkxbmxHN2dHU1dvcGVCTWZUTGd0UEgrb20zRlZ2MjkyZHNlY2hKWEs3YWUxcnZFQlBKRllhanRKZG9uR00rcmNrRXlyNGxvclJlTVhieHNBbVZ3dkhjRWdyWU96YkFHdFBKeU5EcDhTYXh1aXkzekNwSGI5dng2TzBuaUVUbWpjUEhpQmpMYXBreEdoWlVTRkxmZmhVSTdDc2U4RmR1eFRtMDQ3QUhEYnNjL05QelNrNVdVS1UwU2NmWFIwV0RUOG92SUVHMVZXRXZLcUhqSDM5UExnaHZoVDNJZ2h3bjNlVFVHdlJZQ0ZyT1hTQWFvZC9MYWRxSUxZV1Y0WUQ5cmIwRHEyV2JXelFxODdxbWFSMjlNa2VyTkdydGxUMk9IY2xTMzZCSzR4M2o2WXpHT2ZJaW95aHpHdTl4YlV1UkdVcWI2T2RWbXlSRCtwbGdOUzNvK2tYR1dtSFlXYkhFVVprV2d0M2pGSHl5VTdDWlpUWnUwS3NWUDNEbmJSeGY2N0U3bmRPNHBFZGE1SmJOdlRsUFh0ckRxYjZDV3JLNCsxaWN5UjVtOFI1ZS91V3ZBRTNuUzNMb3Z4RjVwYUFpVVNsRktZeWg5WjRtQmpVZ1h0bHVvbDdzVmoyTC9vTk0wb1hrRWlEZlJkRUpSeHpzdDV4SzQxVmpqTkhVTGtyakFyazEyTUpSVFdZWUl3U2ZtTEo1bmxGMUV4ZVI1QWJsRzhlc2NSU2pNdWxrb1lrUkhBMGJxNnRFWUdVMEJBSmIreFBVQlRUUHFYM3lRV2xieGFoUVpwTE9hMFZaelMwTU1yWkhCdFBWK1VZTlNPelUwZzN6L1pwc3MrV0RaMDl5NXRpQXZWbkZyRW1TcUVXV2dQekZaemJabWpTdnlBaUxwZUJod0poRFpWTnhDQ1QrMEw0a0hBSkg4YXFNRXc5QXB4QUQyVUkzckJPTGQzQ2hVbDQ2aENrVjBCTVpjc1V0cVNiZlZmZzRMRThFa0djaXZnMFNPeEgvR0FOMUNEQ1pFOW9XWTB6YVBRaUpOaTRrenBOR3JKcmtmZUdUSDJIakhhb3duYzJvMjBCdnBVZlpLeENna0l3eVdyTGVrRVlqMWQ0WW9xQW13NUpHck5oaytsbUtjcU5VMnR3d2lNbG5PVUNTK0FtUjhaV0s0Vmg1L0lHejNINTh5TTY0b25LcHRESkc2SmNaRjY3dWN1SEtQajM5OHlWNkRsTkxPQVNZdzhZb2h4dnpSVVo1TmFIeDhFT1R4c2lKYnU4MExpeWZ2UXAvNnBUZHptYk5BOUhJOTI2WmRTdGtrTmpWQ3lHSTNSZGptdEQ2TEFsQ0ovcTRENUdxZGgyZFBFMmlUTFRKOVNvRW90SGt3d2VZWHBZeWg4SjhYak1lejFCcjhMVWhpaUV6anVtOFltYzh4dVRwVmwxUm5JL3NWNEVWU1NMVVdaNjhDVDJSWFhWRVoyaEo1UlFod3R6RFRzc1oyK2RkOTUxbVk3WGt4djZNeGlYYWUxUmxiVkJpSmJDNU5TVnZBeHZjdEpaU0l5bDd4SnQ3RHZpejVNV2FQK3UxbHgwQ3p1SExRM3U0eENMUlkzd01kTWZuQXJ3YzRZOWFaY3BOODRSb2dlWjd0QXQ1d3dKa1lSeDZjMGlqN3ZLNHVYSlhGdWMraGtFYm9nUWZFSk8wdlVLRTJqa0thOG1Nd1dZUjMwWTBCR0p1YUowbno1SnZCNW9lUUtjeDdUK2NveDl5K25uT1pEWlBybHBkNmVQYmdFaGkzdFp0WkxVVW9rbG1PQzRLVjJLZ3FTTnJXY2F3S0lrVEQvdWVvN2JrM0puVG5ENnhpc2xnWnpySEdpRXZMQzVFMW9jbFJpSlhOaWZzNzFhVVVZbWRMZG9xNll4M3NRbWY2TTE2WnlIK3FZZDZpc1VPWkdFL2F3NHRHZzliY2ZVUFpSdERVbHhwdTl3aE1CUDQxMlBsVzl5MDEvWmRMNkorQ1pEdnJuajA1QnBQYlU5ams1YkFYcFgyMnF5NmV2dDZNYTBhZjl5RlFKWlp2SThFV3ZyOUhzWWFmRWc5Q04yMjJHU0dRQ1NxU1NldW1qS0FEd0hUQ2VkSmpBeUxndmwweHJSeFpJVk5CcVYxaXpYZ1cwZmJwbmJZV2lIUEJCOFVoK0Y5ajc2RmpmVUJzL0djK2JpaENRMGJKd3RPSEIxU2xwWkFvS29DMWhxS3dxQkF2NWZFczY5dVQ1aE1hNHg2Tm9ZRzc5SkdYanB4cThJYXBJMklpMlFHY2l1b01UUVI2cWkwbW5TQzIyNUg4V3IvaWZyUWh3MmtqZm1CNFFpUW9mTUlWeFg2dWZDbENuN0xLeE1PVzYyQnRucHo0YmdFeUhkSnJQY3NuZTNHWWwvbTkweDVKUytMWjhxcXVUdHF4QnFUbkp4UTJ0WmhNcE0rVjIycXhIdGxqZzhPdkJLTTBvWklKb2JnUEM2bXpKQm5XZG9sK01DOGFYR2FQTnNSY0cwNnNtcDlvSTdTZldJcm1iWFVMakFQeXZUS0h0VzFNVDRrN3RiR2FvOStMOFBGZ0tzOUlTaTlNcFYxQ3padlZUZU1weFh6eG5ONWMwNWZMTDFSd1h5ZVREaXozTkw0aUl0Q0pnR1R3YkF3NUIyUk11LzFjRkdwWGFDSjRGU29tcFltUnBvUWI5cDJIZHFKNktGbW51N0hRV1kyalpqL2Mrcjh5MWE1NXVCYWg2dWFUdEY5a1RqMncvZm1jMlRmcUFDNTgrUVJ0cWExTkQ2SWRtY05tM3RqWjJMY0xJUWl4cmllaVF3eEl0cjVLSUtrTWEyMVpGbVNLS21hTmxISmM5TkpBNlVzNG53aytBU1N6Qmdpa1dsYjQwTEVJampuMHU5dEhhaXcyeVJIMjFFdWFmUHRJaE9UWVVScHZhTU5qdENSSkdNSEJ1Y1RWVDR2TEdVdncxcGxmenBuYnpwSEZaNjRQS2FaZSs1ZUg1Rm5HVVVtRFBzbGVXYUpVZG1kdWFRa253dWowbEwyeTZUZGxXVUUxeEtkWTlUTDJSajBXQ2t5MW5vOWVsbkdrZUdRZnBhVGlkQ3pGdWxPYWc4N3ZCckFHRE1kOVlyUFRsci9SSVJkRW85eDRVVWZyYUFyRm0zMGUvYzVlc01DNU55eGRTN3Z6eFozRWdjbXBTOVA2dDFuOStzL3ZmL3NTYnZSazdmTjZzWjIyZzVZWXhBbFBlU1pVTFdlRUJYSlRXZFNtYnc2Z2xkQzZ6dkFKSmNwNmE0U1E0aUVHUENKQjVaOEJWV1oxRXF1MExmU2pZZUZsVkdKS1hKVUE2R3pYVXdOZUFRajVIbkd5cWlrS0F3dXRPeE41a3lyQmxWNDRmcVVweStQdWUvb0NyZXY5SWlhOUx4NlpZNDFoaUl6REhOTFA0ZEJZU21Mbk16S2dTNS8xQVJ3NTBKeUo5Q0FhTG9oV1NseVZqTExSci9ISFVlUHN0YnIwOHR6VnNvQ0RSNGJsUkt3eHVTbE5VOVBuZjlhQjQ2RjNWb3dFRWNXSFFoTTQvZnVjL1NHTGJFVW1MdDRlR2pqU09SVVc2dmVtRFhOVXpQcnJsUytQaVBCV0NPV0dIT2lTU1REbloweDJJeHNVRkJrRnU5Q3NtQzJnTVpPMlVRUmpSVFdZak5Ea2VVZ2x0WTVnbk5rSm9QU1VydUlpeldEREJxdlNCQldCNGFzWDdCbkROR2xjZytSem1yWmtPV0dzbWZ3b1dYZXBQSk5Pa2ZjS3p0enZubGhuN2tHbnJXT1lXL0FzYXpIS29MNlFCc2kwNnBDUTZCZjlCSVQyS1FyeE5tOFFqRDBpenh0KzF1UGN3N1hSRERKNldVMnFjaHpJY3NzbWNDSnRTTWNYMWxoZDd4UDRSdzFEVWFoaWJHTXJWdkJTRXZVQXlINGhRMTFscHdkdnFmakRadEJ6bStQS2JLTTBzcENmK3BnMGlsZ3p1L1ByMTJiK3krZUdKYnIvZHpjaVJHN041bHBBR3llRVZYRldFT3ZMQkJyOERGNWM0U29oQmh4SWRJMkxsazVHME5kSlJFSEh5TlYzU1lBeFZTS2pldklaaDBaU3RyLzVUWnR2NHVqNndSajB0MTduaWVGeGtJb1N3c1NtTmNONDNtRDY4eERYVWhVK1l2YkZkZWo1L2hianJMK2xoUFV0Njh3djIxRUhCVmszYWQ3b1JCZFFDSmtXVWJaSzdFaTNYUlB5YTNGR0FNeFpSSmRLRXQybDQ1Qytyc0Q5UG9scld1NWN1MDYzbmswYXVmQXk5Vkc5VGRta2VlNDZTYmxTOUErcURXdzVaY0ErYTROWXd4blZ0TnRoMWVWUTd3ZzlWSGpYaHYyWWxZOGRhVGZheUFiaUpnTkpkckd0OWpDeXNMVU5VYVZ1bmJFa01hKzg3cWhiVjNLS3QzdXdwaWs1Vkc3bHJwdWFOcmtRbHRYZ2QwcVVuV0tKWm1rR2NCb3JVOXhkSVhHTzd4NjJ0amlRa05RVCtzY3RmT3BiTW90Mm5rVUdvUWJPM011eDhEUnQ1M210dnRQc1haeXhHQ3RoMTN2MFo3b003OTloRHN4b0QwK29NZ3R0Z2xFRjhpUzAxeVNRbEpGUTZJNkYzbVcyTUsrTyt1MVlMTjAxZ3ZDYURpaUxQTWt1bDBuWmtFQTlSQ0Q4TGs5K0VSSUE2NTZzZnNJZ3E0QU8vRjcveGw2UXdNa3hNamFvRWltbXlTdmFIM2xya3kzNSsza2hYSHpEUmYwbXdGemZ1cmpkU04yd3hoVElralROcVpxRzIyODE3cDFUT2V0VkZXTEM2RWpGTjVzY1RRcVRkMmlJclF1NGp6VURtNmsyeXRXSmFXdndzSkRienZIMjk1MUgrdHJRNG84V1JyWWJzeThPRWlxZzJmZWVxcW1aVEtydWJZNTVmem1uTjU5UnpuN2pyT01qdlRvajNKNnc1eGVMOE9XbGpqTWlVZjYxS2VHdUxOcmhEdlc4QnNsMFFDekZqK3RpY0duYkJjQ1daRXhHUFNUWlVOVWJKYXloN0ZRRkRuRFFSL3ZXM2IzSi9qUXNiUUVhV0JyRHY5MEJzOTA0S2dBMXl0dFBIRjB3T2JNdlNHZW9UZThMbFlaSXkvTlcrNVpIK2ptckdIdVF6eTBYSTZBYjN4d1Qrek92Z284MGJObWRLeVhuU3VObkQ0K0tONnhXdGo3aDduYzVWdzE4Q0dVODNscTNGMUlzcC9XR28yeFlkU3prb25nbk1kWXdTdTRvRFRkM2ZaUVlFdGhYYUFvYy9wckkwWXJBMFpWdyszMkdLZE9IV0ZuYjhMMTdURTM5cWJNNnBhb01Pb1hoQmlTMFY4UjZhOHB4KzVZWjNDMHBNd05nOXlDeU1GTXRTQnh4M0lWNG9vUVZsYmc3QXJ6T2hBdjd4RmUza2V1VCtEQ0h0WUxUZFhnR2s5dUJYb1c1d0pxT21FSTc5amEycUh5MEhyRkN1bWtOcG1UZkhrYStTWTNWVWdEUXN4R0JjTTNiOEQxMlJJZzN3dng5TzZjTTZ0RDNuZXk1TE5YbzlwRzRyUU4ybG52SHViekZRaE5IV0oxYWRidUF2bjVhZnZadmpVYngwcjd5RWowelJMOHZWWTRKU0tuWTlTTlRGVGFOb29QVUxlQjBDa2pMb1pGUWFIUzFCTTAzWTFHRHpoejVqaTNuejNLM3M0ZWJWM1RWQTJaTmF3UGUvU0xuTE1uTmhCckRoeW5ydTJPRVJIbVRjdm1mTTd3WkovK0lDTTNRcG5iWkJQZHlRWXRDTXdpc3RCVkp3cllnZERlZlFSMzJ5cHU3Z2lYeDhpa1JhK09hYmJtbUwyS3ZBNlkzQ0F4b2lxNE90TDRaTk5XbUxTZGp3cDVQL2V6VEw0WTl0c3BldFB2WGtSd1RWQlpLOTh3ejgrdG9LeklwZkdNZno2ZWNmZGFqeU85WE5mTGpLdXpOcm9RRDNaaUNnNmw1dWJSWEJaVjg2a1AwNmtQbDBoNmJtc0ZyQTNFM0ZzS2QrZENUK0YwVkQxandXU0ZIYTdlUHJxalg1bzhOSkY2djBHYlFLK3dUTDFpZkNRYjVOejVqanU0NzhIYjBTYlEra0RWSk52cHRnMU1xeHJUVGJNbXM0Wlo3UmdNQ2x5TWpDY1Y5dGlBN1BTSUxFdTlRcDRsaFpMa001Z09tVHIzRUxLc3M0NE9pVHVXNXM0R3pTM3h6QnErRHNqcFZaaTF1QnR6MnEwcDgrMFpNcDVUQUNGWFRCM3BpWUx6UktkRVJYcDNyK3VndEhQNTZ2VVdjS29hRUtJeEVvZHJKYy8rMnhlV0FQbGVqSmYyRTNuaThidU82TGoxdWgraldKRVEwd2xHNTB5b1R0UHpkT0JLMVlHbWpqQ3U0VXF0OGRsT05xb1FHRmhZQTNxallYNzgwYjkxMzgrZHZHUGw0Zm5NMGV3MU1wMDZiR2xwbXNoODdDaXlqS2RPOWhoUHJuR01ITnRFamtyR1lHakpCc0xSdFJXTU5jem1MVVZoV0hFRlVXQlNPMGFEa21rOVNYOWlic2l0d1dUSkt5VFQ1TFlyaWFpY0hCaFVpSkp1MkwxUHlwRzJWRElmME9SbGdCaVF3dElPQytvd29BcWUxZ1FLYStqM1N3cE04a3QwRWR0Rzh0d3dldWg0bkQyLzA2cXFFeVFneWNrMitHL1RSM29Ka08rZStMRjdqM05qN2dnUmNtdDB2Y3c0MHN2ajlWbkxidTBXUjNjTHF6NmpyenpLZS9YTEtPeDd1QUgwOS9lYUs1ZWYzZnZva1R0WGZuNTBjbkJ1OVhSUHk0ak1Hc1h2dEt6ZVpvbHRaTjlGOXVvcHZvbDREejFyc0oydHdSQkRVSmpOR3phOFlSU2dETXFxV01aVlRWMEtneUlkWUJrcnFBaldwSG5Md3FvN040SnFVakF4Sk1jb01jbEdyN0NDend5YVJTU1hKSGthMDBkRDFHUVJuWXRKazduTUVFMjNEemxlSXRabzBjdUl4bHlyeCsybGpnN3RSU1F1VEZ0M0xrL2ZVTStMdmRVQTh2VDJuQXZqbXFiYktVemF3RSs4NVNRM0tzZFc1UlJqMUZpTEdCTVZpY2JZYUswSkloSlUxWFhMTUNjaXJZaTBYZitTNm5BbFhQbld6aFdiMjJ1akUvMkhVVlpOVk4yOFBOZkpqUWFiWlJKQ2NxdzF5UzRFYTRWYWhCMFhjRWFZRXRscFBWTVh1T0lETDlZMUw4NXFYaGpQZU9MU0p0bXhnbE52MlNEUG9KZForb1ZCVEhvYkV5VmRzSjA4ejhLRTJ4L29YMm1uZ0tqRW9JU2dlQmRScjZpTCtMbkR6VnNrUm93MUdHdXhKRFVUc1dtUm1SZVcrYmo1eXVVbnRuN2J6ZDBVcUFUNXp6cEZMd0h5UFJ3TEp0MVhybzNacnJxeHBFM01rK2c5UmxXalJvMHhhcFpsMFJnVFk3THZEY1lZTHlLTERmMUJvd3JvOWVmM3J3K09EdXFWRS8yM1ZCTTN1UGoxN2F1OUU2T1lGMWsvZHNxQ1lxRFY1RzRiZktTZE8yeHVzVWFJYlNSMi9tcmRXSlh0dlRuVC9TbDN2ZTBFeCs4WVVWZ1lGQWJUVWVtTkFVUVhSaHo0cUlTT1NPQTdBcVdoRTRBSWl2Y3hhV3g1UlgwRUgvQzF3ODBkNmdNMk05ak1rSlVGdHNqQUNHS05pRFZ4dk4vODl1WXoyMS9XcUhPZ0ZoSFg3L2ZDbSs0N3g5Ym05aHRybDhZeVhobmVFOTNOOWUvQzl2MlJSeDdSZnI4ZlJTU2NPM2N1dlBXdGJ3M0hqeDkzWlZrdXppNHFFaGRwRXRxdzk1WGZmUGFUTDM1OSt6ZWUrUHoxUDRxUnJ4V0RmRUJNRm0rTGtzWVlTVjdzM1NMdm9LNnpnckZDa1J1eXpCSWJCK09aMzFqcGJaNDhNNnpLUWxrcmhYNnVHS3VVaGFITURkWUtOaE95VEpCdTZoUTBiZmVsby9BTGlmOGhjS0RZZUpPcEptaU1lT2ZTM3pIYzlMMVZRS3lnUm1adTJyNFVYV2dobFZjaUVvOGZQOEZQL2VSUHNzd2d0MUM4NG14VmxhcXFjTTZ4dTd2THovN3N6L0x3d3c5ejhlSkZCYlJwbWxlY1ZBUVg0K2F6ZTgrMSsvWFhUejEwL0QxaTdIM3FOZlhPU0NmeW5CN1NhdHdTMjBqZXMrQWpjVkdzK0VpMU0yTjJlVyt2dmpyN2d4TW4rMDgrK3ZqcEJ3YTVaS1BDWWlRcGl3UzU2WTFZR0lQditvRVlsYmJybXpVcUlYVGZGeUVHaUNGNVRjYzJFdHRBUFcxcDU0bnpWWlk1R3BXOHlERFdvTWFROTNQRW1oZTNMNDcvOVhSemRoV29SS1FXa2JDMnZxYlZyT2FGRjE1NFF6MEQyUklHLy8vaTZ0V3JCMS8vMGkvOUVsLzk2bGU1ZVBFaXYvQUx2OEJYdnZJVmZ1LzNmaTl1YlczNVZJRWxiTFdUVnF0TS9NN0Y2WmZMUFhjdTcyZDNaNE04TjVsZ2l3dzd5RFN6b0xVSGF5VkdJVlplMjNrcmJsd3gzNWxYczYzNU0vVjIvZG5xV3ZYMVV4ODQ5WUdqS3lZVEZTMk5TTzNUTlZqUlhZUjU3OG16SEN1Q0dzZ3l3WVNiMnJwdGpCU2FSc2pHcHVsWGpKcnVrYnQwYWF6QkpDNGFOcmVJTmVsbHVpdksyaiszOC9MZVZRNmRqS2lxWHI1MFdjK2NQZk9HZTkrWEFQazI0aC8vNDM5ODhQWGYrQnQvZzBjZmZWUy84cFd2eU03T1R2cmN2eW14cWRWZUUxLzYzTVhmWERrMStzYndXUC85L2ZYeWNhTjZkM0F1bHdJalJvaVNoL0xZeXRYWjF1Ukl1emNmK0ZrN2JzYk5OK3R4K3lmVmR2TlZQL1dUb21kWHpqMjhmdWNnRjJNME5lS1JsQVZFaEV3TU1hVCtTVFhsS0kycEo0a0IwdTlKeThmT2FQZG1ZeS9wdjJjVy9WZU0rSU5qc2c3dHhxaFI2bmJlUHRPTTJ3bHBNUmk2Q1paNjcvbkM1NzZ3Qk1neVhobC85Ky8rWGY3aFAveUhQUEhFRS9xMnQ3Mk5wNTkrV3F1cVFsVmJPckVJTjI3OHpyaVo3RHpIMDJ0bjF6NWQ5TXc1MzlZUFIvejkzb1U4R3c1MmVwZW12K05ucy90ZDBOdTE1WFBOWHZ1MWR1TDJ1L2VvdjNhOHQzYkgzYU03YzJPTUtGaFJDcHRLdFNvRUVFdVJtMFNuRjRnb0tvQUkwU2dhRWxYRUdLRU5TdHNHUW5jaHFYa0dwVkpMTjI3dS9BOUZKRTI4WWlUTE1qR0djYlZWbmVlbUlFTXd4bWc2Tm50anhoSWdyMEg4L2IvLzk3SFc4dWlqaitydTdpN2o4VGp1N3U1eXFOeUszUmpZN1YvWW53TFBTQ2FmTWJtTVZLUGx4c3p2dDlNNkw4d2ZSeUdFSmk0azBETVIrcXJ3NkFkTzNiRzJWaDVkWFBVRkJXdUVFcUV4aW9hSUdpRzNIWVhkcFAySVNFUU1xZFRxOUwwV2pFM1Q3VkNpQ0cxbnhwbm5HU3BDNkd5eE5VUnNic21zSU1La25ya2JoNloyVVVSaXY5L1hxcXJla08vdGNvcjFHa1VJZ2N1WEwvTkx2L1JMUFA3NDQ2aHFOTVo0WTR3VGtacDBpanJ0WGhQMXVoZXFlRG5XWEl5dFhoVmh4N1Z4SnpSeHIvdWVPVkNyNHZLZXpSNTc3OGxIQnIxaUpRYlVtclNiTUVCbWhDSXpTWkJCa3crN29DVHhGVTFLS0IzTlhSSUdVRjJBSTVWUklTclJKWEVma1NUdVl5WDltaGhEbGxzMWlSdDJhYnc1dlFZM0Y0U0R3VUIvOUVkLzlBMzd2aTRCOGhyR3B6NzFLVUk2dFZWVjFmdnZ2MStIdzJFUUVTOGlqWWhVSWpJVGtZbUk3SXZJZVBGU1pVeTZxNWgwSStOMmtYM3Vmc3ZSWTJmdU9uSi9abk9iR3lNZ1pFaDN2SlVvNkZWSXZoM3FBZ1RGU09vdGN1bEd5V2xWbm83SHV1d2hDblhqOFQ1MGw3aUs4eDRmMHdHVnNZYTh6REFpWXEzNHR2WXZUVzlVKzNTT1VVQXNpa0tuMCtrYjlqMWRsbGl2Y2Z6aUwvN2l3ZGZ2ZnZlN3Rhb3FuVXdtWXRJRjBtTHljM2o3Y09BOG9LcUxuMTg0TVpzekowNE9mL3B2dnV2eDlkWCttNkxHdENNaDdWT3NkQWNwb1JQSlV5Z0dPUnJBeDFTQ2hjNFpGMVY4UWdaR2t0eVBENW91SlR0RDBPQ1MxNllnNmM2ZXRIUTAxaUNabWMzMjZpYzU1TlNtcW5FOEhsUFg5UklneS9ndmorM3RiYXFxNHV6WnMzcng0a1dHd3lGcmEydHhPQndTUWxKRWlUR2lxbHkvZnAycXFnNU1aVVVrRnpINXovejA0NDg5OXVqR1QweUs3V0ViaytGbnozUzM2eUtJR0RJRFBRdno3bUdQQ0JGQk5lS2k0a0xxTzR3Ull1QkEyOHVGcENXNXlDYTY0Qm9lK0VUTGdTQ0ZHS24zcjB3dkh3SjVWRldhcHRFTy9FdUFMT08vTEg3N3QzLzc0R3NSWVRhYk1adk4vZ3hmNldkKzVtZjQzZC85WGVrQTBpbnJhTytlZSs0Y2ZlQUQ3L2xRUHJ4eWNpZHVxaGdrK01RUXRDTGtSbWdqdUtoWVZVb1IybzVodVZDV0RCRnNwem5jUnUzR3ZOM1YwOExMOEJDdGhjNHcxSkF5a0dUZHprVFltKy9WdXd1QWRPUGRDUERwVDM5NjJZTXM0enVMQmR2MXo0dk56YzNFbFVyTlFpWWlwU3I1dTk5eC96M3ZmTmZidnUvVXlwdEVLc1JIVDJsU2FaVVpTeTcyb1BFV0VtRHlqcWpZZG1mR3FvTFRKRDJFcHBFdHNidjk3VUFVUThTNWxGclNYMEVQOUhnUlVheUpydllYUWh2R1FFUUl4cGpZaVlPL29XTUprTytDK094blA4djI5clpSMVlVTWJ0bnY5M29mZWZ5OWJ4K3VERTdkYytZeHZYZnRuVFNOZzBWSjFMVXZvcGFlc1F6em5OSm1GTVppalNXcUhtaHkrWmpFcnJzbm5zT1grWXN2RjFZMzBtM1RNNXZVN0swMW1oVlc1L3ZOaFdibUpxUVZ5eHVTdWJzRXlIZFpmT0FESHdCWTlCNmlxbDMyME96eEQ3Nzduc2MvOUgwL1lrSW9NbXZrd2R1L240ZUdiME5pOTRUcVRUWnlhVTJpbHlpSWRzdSttQ3lYSlNqU09lZ3U1Z0xlSjRFNlkweVNUWTFKU0U1RHlqRFMwZHZGR3RTSWlCRlhUZHJ6dmczdThQWjhZMk5qQ1pCbHZMNXg3NzMzSWlJU1kxeW9laFpBK2RmKzh2c2ZHNjBPejZwR0NKNlZzczk3N3ZodmVXamxuZUFNUVZNUkZHS1NNUVhCUjZoOW9HcVRxbU5JdjVVYzZVQ1RITEVPekhCaUlpdFNlZFFGdlBmRXprdFJURHJHTWtaRVl4eTM4L1pTbHpPQ2lFUnJyYjc5N1c5ZkFtUVpyeTg0NXZPNXFPb0NITG1xNXZlOSthN2o3Mzd2VzcrL2IyVmdGcDVRMGRITGU3emo3SWQ1OTRtL1RMOFpFVUlncWhBeCtFQlNjQXphS2Fva3NUbGpPczVXVktLUEVOTHlVRFRaLzJxTXFFYUlJSnFVN1ZXVkxMTVlJMm95VWUvQ3ROcHZ0bElybFRSU2I0WCtZem5GK3E4YzYrdnJzcnU3ZTFnVHVnVEsvL0YvK05HSGJqdHg1RUd6K0FDTHJsdC9RMkZMN2p2K0dLY0daM2htKzA5NWJ2SVVJVFpVcWhUV0VnSlkwamhZRkFwSnNrT3BkekVva1JnRE1jU2JYdXFaUVdNRWxRVTlKbWtOZDQxT0RMclZ6djJNaGFWejl6M3orWHpacEMvajlZblRwMC96NjcvKzY5UjF2VEJ2eW9EaUxXKythLzBENzMvc2g5WlgraWRaT0NtclR5ZUlKb2ZvTU5weVpIaVVkNTM5SVg3dzdGL25aRGhOZldORzI3bFA1VWJJSkUyMzBtVmlsekdrYS9DanBsOE1NVzNYWFV4WGhhcGtXWWJOYk5mRHExaHJ5S0pjRDNWWStIM0VSUWI1K3RlL3ZpeXhsdkhheDgvKzdNOENCK05kbzZwV1JIcEE4Wk0vOFpINzNuejNIZThpSWlwWjRxcGpJQ3RTcVJXU25RTEJZelZ3Mi9xZGZPQ3VEM05tK3c3YUo2Y1VWVVJGOE4ybnZER2RQM3JVcEVEUjlTQ21Xd3pHbUpyejBIYjBrcXp6WXV5dUhjVUtaOWZYVDl4NTdNaGhLME5WVlU2Y09MRXNzWmJ4dXBSV2k1SFNvcnpLVmJVWURRZjlSeDY1OXgxckcrdkg4VjVGTzRtcnJBOWkwSGFLYUFUSk9sMGZBNjdpOU1aUmZ2S0gvM3VlZmVKcnZIanhXL2hWdU41cmVjYnY0bUxpVm9raFhRNzZRUFJKR0E3U1pqMVpOc1FENFdwcmtrS2NDSnFKNFZSZWJsenBGWmJPc2ZaNzNmdDhDWkR2OHJoeTVRcEZVUUFZVlYxTXJvcDN2K3ZSMjc3L1hZOThpT0F5TVRtWUxvT29ncThPeUZzTFV3RU5iVWNQVVVabHhtT1B2cDI3ejV6bG1XOThuZFB0akVlT25PVnFuUFA4N2pVdWpQZlk4blYzUVpqRXNKT2xRMW9VSmhLanB0R3VRT3pRZVc4MmtudXkvdlEvZWQ5eWFHMEM4T0tMTHk0QnNvelhObzRjT2NJblAvbEpxcW82R08xMnU0L2lKLzc2WDMzdnh2RmpkOUdPTzB0Wm14cjA0Q0g2cE1vZUF4b0R4bVJvOEYyWmxPZ25pbUU0V3VIK1J4N2wwb1VMdlBqTUN4d3RMUStmZllqNVVjZXpXOWU1TnQzbnd2NGVlMFhMdkxWc1Z6TkVMRGJQa1N5aktISjZXY1pha1hHdU4rTFJ3U3AxQ09OeFZYdDRoWlVoNzNqSE8vanlsNys4Qk1neVhwdjR1Wi83T1Q3KzhZOHpuOCtsNnoweUVTbFVOWHZvTFhmZDlxSHZmK3dqbWMxS3hHaTZXbkxnRDF0cEJtSklFeTNGSkNPZnRrWWtXUzhFNTFGTlVrQzMzWDRHMVBEY2N5L3lqYSsveEtrVEd6eTRjcFQ3aTNXMnpRYVRwcVlaZVc3MHAvZzFoenRhMDFZTnpqc0tnYlhjTXJKR3JIZGN1akY1OXFXcmU5VmhjQ1FydWpkK2xiVnMwdjhDb3l4TDN2Lys5NHNraGVrMDJsVXRnT0t2LzVYM1BITHkyUG85SnFxSUtRU3hvQkVORGcxKzRiT0FTRHFGMWVqeHJpV0cwRW4xTkxpMklmaVcxalZVOHpsckcydTg5WkVIT1hYYkdTNWYzZVdQLzhPVFBQdkNaWHpqV2M5N0hNbDczRjRPT0VwQlBnL2tNOGVvVlVZUkpFUWE3NG5BckhhNzQxblRIcDVncmErdjgvZiszdDlibGxqTGVPM2k2dFdyWEw5K2ZaRU9MSkFyRk1lUHJhMi84NjEzdkRmNmRrMk5TVmQ5SGJsUWJDL1orRVFQSkhBRTcvQnRpM2NPTVJiblBLNUpEdWN4ZXJ4WHZIUDRFQWh0NE1USkRWWlcrOXk0dHNYekwxemd1ZWV2c2JFMllEUXNJVWFtczRxcVRvYWovY0lRTlYwWkZtSXh4dFF1NnBpTzRtNk1VUkhSK1h5dVAvWmpQN1lFeURKZW0vamJmL3R2ODlHUGZwVHVkaUkxNTBLSlV2N0MvL1NqOTkxK1l2VFk1Zk12eWNxeEUyUnB2cFNhY1RGcEQwSmFiRVJYSjRkYURjUVkwT0FKUG1uN3hOaDVsN2hBTlo4bnJwWUtycW1Kdm1WdGZjaTVjMmU0TnVoeCtmSVdsNjdzWWtVcERlVFNxVE5DcC9FclJCV3FZTVl6WjNhNXVRT0pJcUtUeVlSTGx5NHRTNnhsdkhaeCsrMjNpNnFhR0dNRzVDamw2ZVBybzNlKys0RWZ2UFBlTzg1c3Z2eU1Odk5abWxiRnpsVTlOS25NNnNhNnFrSU1BVkhCbU81K1BNdVJqc0hyMnBhNnFtaWJocmFxYUpxS0dEeHQyMUJWRmQ2MWJLd1BPWGYzS2U0NGU0cGVyMDhJaVJaZmxBV1NXYUxKY0dwb282V05aaktwMjMwT2pYZ1h2Y2ZaczJlWEFGbkdheE1YTGx5US9mMzlnOTVEUkVxZy9QQ0gzbjdIZzNlZWVNZmErcnBkSFFnWG52b0dhbXphZFpnODdUMjZWMXlNZDVPQjVvSEFBcHBFSTd4cmFkdVd0bTBJM3VPOXc3VU5QdmcweGcwZWMvUEFsNkt3RElkOUlvYTZDVGdQVVMxR0xHVlJNT29YNUVicnlieWFrOGpERVZVVkVheTlOVVE1bHdENUM0clBmLzd6ek9memc5NEQ2QlZGM3Z2TEgzN1ArMDZmWEg4VHdmRG1SeDZTYjMzeFAzTDF5aVhJVEhwN2JJbGtKWmlDMk5iRW1KaTZNWGhVVTRNZVFraGZBOEY3Z2srL0ZydmxuM2N0d1RtYzh6ZVBwcnJ5eTdlK1Uzem5adDhqaWhBeG9zd2F0Ly84NVoxeFYxcEZFZEVqUjQ3b3h6Lys4U1ZBbHZHZHh3Ly84QThENEwyWFJlL1I3VDN5di9uZmZlaUI5LytsUi82S1ViRkl6bWpqR0VlTzlQaVRULzgrVFQxTmZiRWRndVNvcjFJV0NTSFpIUmliZ0JBanh0aHV1cFdzRURSR05DbytkRm5FT1Z6YjRsdUg5NEZFeEExb2ROMzFlaEtwdGtZVytsY3M1QmRiNzI5YzNaN011N3dUalRGNjdOZ3h2ZmZlZTVjQVdjWjNGbGV1WEdFNEhITGJiYmVKcWtxTTBaSzI1cjNSY0RENHFSLy8wQThlUGJKeU4rU0lXTElZZWV6dGIySDcwbm4rOUUrK1NMU0tTbnA0eFZna0t4WVZGZEVIUXZEZFdqdlJSb3pZNU0zdVFycW9WY1U1UndpaG81TUVtcnFoYlZxcXFxVnRQVEdFTkU0bUhVMWxtZEFyTElOK3JsbG1ZdXZEdUdyOWdxaW9nT1o1Zmt0czBaY0FlWjJqcWlyZSs5NzN2cXIzb0ZEVjdDZC8vSWNlZVBqUmU5OXZmWk9KelpPR2FIQWMyVmpqUGU5NU0zL3diejdOdDc3OHB3Z09EWW13S05hbVJqMHFNUWFzemJGWmppNTZFMGtxSk1ZWXZQTjQ1M0hPMGRRdHppV2Y5eEJqQWtaVTZzWXhtVmEwenVOOG9Hazk4N3FsZFNrekJRMnVhdDEyMi9yMjBCUkxOemMzbHozSU1yN3ptTS9uZk9sTFg2SnBtcHQ3RDZVY0RucUR2L1ZUSDM3L2taWGhuWktNTnhLbHhNMUFEUTgrOUdidXZtdU5mL0gvZkpJYjEyOGdlWmttV3Azd2RKTHd5Y2p5SGxsZVlteEdDSkdtcnFtcktna0MrOUNkenhwQWlGR1RRRnhNNG5BeFJwcTZKY2FRVEhkSW1yNCtSQm9YYUYwUWpYaW5jYXFxQnpRVFZlWCsrKzgvdUJ0WkFtUVozM1k4L1BERGZPeGpIeVBHdUJCUkw0RGliLzdVZjNQdlBlZk92RDgzTnUrSUd4QmFva3NQckdyR0QzN3dVVzQvQnIvemlYL0RlRFpObTNTVkJJeXNJQzlLeE43MEpRUkRjQ2t6V0pPUjVUazJzd1NmVG1tZDg1MFFYT2NWNHNLQksyNk1FV3NOMWlTcEgyczZCOTNDdXYxWlVuSmZBTVFZbzVjdlg5WmI1VDFjQXVSMWpLSW9VRlZSVmFPcW1TcEZtWm5lRDMzNFBYL3ArUEhWY3pGMGFsU2hUU1JFbE9oYmd2Y01oaXY4MVkrOG5kMHJML0E3di9FdnFlb0trK1hZckNBcis1aXNSTVNtamJsemlmRHJBOEZIZkpjOXZBc2djdkR2Z25TNnZLYkxSaEhuVTM4aVFKWWxHYUhNSnYvMVBMZUV1QkNwN2xTRVZMWFg2L0hqUC83alM0QXM0OXVQWC8zVlgyVmxaV1hCdTFxTWR2Ty85SDBQblh6ZzNKbnZLOFFVM1pFR2hCcGlJSVpBY0MzZTFZQmxkVzJkSDNqL1cvamFsNzdFSC8zK0Y5Q0Y3S0VLeHVhSXpURTJUOWtqS29qRkIwZGRWN2cyalhVMUtwazFaRmtpVGFocTZqRlEydFoxb2xxcHZNcHRFcXpPczJTbE1HLzg3cVd0eWNJNTZJQ282Snk3WmQ3SEpVQmV4K3hSbHVVaWcxZ1J5YXcxK1ljZmY5ZDk1KzQ0L1lBR1QxcE9kK1dWVCtWVjdJQ1N1SW1XMDZlUDhLSDN2Wm5mLzlSbitQSi8rbXFTNHUyMjdERkV0THVjYmR1MkU4NDJuVU90d1h0UDA3VEVxSVFZMC9RclJxd1JxcW9saEpqcXZzeDJ3RENVQ3lQUnFMUSt6cmZHMVppYkZnNHFJdG9KZE44U3NlUml2VTd4MGtzdkVVSVFFVm1jMUJZYmF5dkZBdysrNmIxWnZ6ZUlWYXVobVVndUZtS0R4alN0MHM0Rk4zYjNIOVlXUFB6V3U5amRtL0liSC8wRVBXdDU0T0VIQ0NIZGhrUk54TVFFbHFSMWxVN09VNE1lTlNTOTN0Q0pVb3ZCKzRCM1BvMktZeUN6S1VFNEg3RTJPZUhHcUJpYnRkT3FiUTVsRDEzb0NTOHp5REsrWTRETTUzTkV4QWhrcXBxZlByNjJjdmIwMGJzUUVXT0UwTXc2eFVOTDlENGRRSFdXelltTjY5SjQxeFM4NDdFM2NkdUpqSC95VHo3R0UxOTdzcE9FVDl2MkdDRkdRZFVjYk1tRFR3SndSdExQRlVXZUJLdWRUMk5kNTNHdFA3ajdEU0U1NFlhZ1ZLMm5EVXFJc2QzZW03aXVNbE1Sd1h0UDI3WkxnQ3pqTzR0UGZPSVRNcHZOSk1ab3hFaW0vWWdtd1FBQUUvZEpSRUZVcXZMV0IrNDRlOWZaSTJla2JjUWtWUVNtKzl0RWt4RmpJTGlhdHBrUlhJMFlrQTRBWU9rTkJ6eitBMjlsWXlYeVAvOHYvd2QvOFB0ZlFMdFBlc1VRVllsRXhBaVp6UkN4QjU2RGVaYWw3K3VZdnNFbHpTeTYwVzZpbDBoM1Q2dUVvR2tyanhJVEFVeEY1Q0I3aU1nU0lNdjQ5bU0wR3JHL3Y4K2l2T29hZEhQaXhNWXAyKyt0YWVlRFZnN1hDTDVoUHRrbDZ3M0FtTzZoTnAydXFHS3RvU2g3WkZtUDFkVlZmdXl2dkoxM1AzS1MvK3VmZlp6ZitJM2ZZVGFiazVjbDF1YUFSU1E1MUJwcnNEYkRHRXZVbTRkV2FDcWg2anJSVHRLV2ZxR1p4UUkwYWtTWXpPYk5wR29kc0pnbEs4RDU4K2VYUGNneXZzTlBIbU1JSVFoZ1kxUXJRdS83disrUmU3SnNVS2FobG1LeWt0WGp0elBkdmtaVFEyOTA5T0FxTUhxUGMzTkNWRXozTGhreHJLMnY4VU1mZkpEVmxRR2YrdFJuZWY3NWwvbmdCNytQZTk5OEIvMStueEFDeG5pUUNDTFlUc3phQlk4UEVSOGlNU2kra3llMXhpWnBvTTdnVXhXS3pMSTdtZUx3MGNla3BLaXZ1a2RmWnBCbGZGdng4ei8vODRzdlJWV05DQll3ZDk5NWF2M3Q3M2pvbllYWUlrbFZKZlpKMWx0bmVPUVVkVk14NnhhQ05pdVJ4UTVSdFR1dDljbEJxaGhRbEVNZWUvaHUvdHFIMzhydTFoWCs5My95YS96cVJ6L0prMDgrVDlhTmFsT2ozNGs1cUhSOVNtb202c3JoZkRnUWtyUEdKQytSRUNueW5GbmpHTTltcm5MaGZPdUNPelRtdmVWaW1VRmU0L0RlczdLeXdtdzI2L2hYa29HYUgvM0llKzljWGQ4NEl4aEJEN2tIU0ViZVcyWHQ5RG1tMjVkcFdvYzFGdTk5UnlHcDB4V2lHa3hlSkx2bnNrZlJSczZlT2M2SGY2RGs4dFU5dnZuMEpmN1pSNS9sZ2Z2dTV0eGR0M0hIbVpOa3htS014ZG9NU0JJLzNrVmFsNFFmY21zeEpvMTVRNHpNNm9idDhSam5XczZlWFBIWGE3OUpjck85SmJQSEVpQ3ZVLyt4dnI0dW01dWJDMWtmQzlpSDc3L256cndvMWhkYWNHbWxiUk1QeTVSa1pjbmFxWkpxL3dadVBzYVdBN0p5U0dDWHBwcDMzS3JrYjk0MGpoQWl4dWFzcnEyeHNyN0JtKys5bTUyOUtkczcrOHltdTN6ald6djBlZ09LTEUrYXV5RXdtMVRzNzgvWW4xUkk4TGdtRURRUW9tYzhuOUw2aHZWaGovVlJTYStYSzIxWStCSEdXeFVrUzRDOHh2SGdndy95VzcvMVd3djJybFZWdXpycUQrNjU1OHpkL1R3Zm9DZ2E1YVlaWU1jK0JFUXlCaHUzRTFhTzQ2c0pvWjZ4a3Bma3haVFFOcGlzU0UxNTA2SnFHSG9JblNWb05ac3lIQmFjT0Rwa1ozdk05YzFkOW5kdXNMTS9vL1hLZk41dzVkb3VlM3R6MUllMDc5QkVkZS9saHRWaHh1M0gxbGdkbEF6S2pGNlorODNkblcwZ0NFUkUxQmpEdVhQbmVQYlpaNWNBV2NhM0Y1Y3ZYMlkrbnk4Y2F5MWc3enA3Y21YOTVORTM1Wm0xMmxhZEdMVk5kK2V5c0hwYVZQb1JteFhZMFRvaEx3bjFsRklEV3Bia1JZK2lMR25haG1ydW9IYUk5OVJWelh3K281clBhUnVIc2JDeFBpQzNRciswdEszbnhuYWtXaWxSNzZncWoyaGdyVmV3TWlnb01zdW9selBzRmVTWm9WL21VdVEyN2t5YmRMVWxSR05NakRIcUF3ODhzQVRJTXI3OStPVmYvdVVGT0JZalhuUG4yZE9qdkJ5czZVS2huZndRS1BUZzFQWGc2ODU0MEFwSTBVc2pwcWpwNEtsdG1VL25OSTFuTnE4SXpsSFhEZlBabkxacGlESGlXay9iZW93eDlNdWNHQ0xEWHNuNmFFQjBBYXVCWG00cGl5eVJFak9oeUcyaW5waWNvclFZYStyeHZOMm5jdzRoMlI1bzB6VExIbVFaMzM2MGJiczRKam9RcDM3em0rL2FXQjJOVnBBTWthNG0wcTRJaTc3TEtLVGRoL29EOWZaRk15OGlZTUJYRmZWOGtyNU5BMDFkNFYyZ21sZk1wOU9PUkNpMHJldWtnQlkzSU9udkZudzZvakppa3ZPdFJsUU5nNkpJaEVZckZKblZZUzluZjlaZTJCN1htNlFkeUtKUjU5Lzl1MyszQk1neXZyUG9aRGtYRGJwNTdOSDczM1RxNk5IYlVRTzJuNlJETlNDeHUyVHR6RFhUc1licFFKTU1iUTQwZVVNZ0JrK1dGYWo2Sk42Z0VlOGRUVjBuNFlhb2liRFl1ZDZHN2paZE82Q0VwTmlPRVNHemhpSlBwVlcveURCV3lETkxsaG5LSXRQem01TnZucisrZjhPSXhKaGNwZUt0T01WYTdrRmVaNndBa3VWbHoyWkZqa2luUGhKUTBWUzVhTHlwNEg3bzhWT05CTi9pWFVQd0RXMVRJVVlveWg0aWFTcDFjN2tkS2NzTWEreUJLNExOdW8yOFNPSmtXVU5aWlBUS2dyVlJuOUdneC9xb3orcXdwQ3h5ZWtWT25tVVlZNlJ1UTNWNWUvS051ZzFld1VsS2UvRzIyMjY3NWQ3QVpRWjVmY0VCWUNUUGlxYVptWjJYbmlLVEdoOEMzam42Z3hIRzVoUmxqN3cvd3VROURCRnRLNGdlMzlab0JHUFQzYmt4R2FoREVMS3NJTE9XdXJzZzlLcGtlVm9NT3VjeEluZ2Z5WE9MaU5BMkhsM3BVMXBEOUFGaVpGUmErcjMwNjhaSXloNjVaZGE0ODg5ZDJYczJwdExLTCtSK2poMDd4dVhMbDVjQVdjWnJHOVgxbCtMelg5alhabnBOVHQ5K0pHbFhoY0QrdmpLdldqQVplWjZ1QkswdDhENlE1em1qMFlnOHo4bUxFcHRsQko4YWRVWEo4Z0pyTS9JOHB6RU95UUw5c28vVUxkNEhzc3dTUXBZR3lkR1Q1NFpCTDhlSzBGUU4vVXpvWmRLSjBLVXNrMmVpdzM3bW5yNjY5N2tuTCs1ZUIxejNDc1lZZmRPYjNuUkwySzR0QWZJWEd6cTkvcHdPNzNzTGQ5NS9qckxmeDdkTnV0UHdIbFZ3dnFXZVZiaDJTclZmTVozWHpPWU9zWDFDTUt4dHJITDAySEhXMW8rUkYwT2lXbHlvNlEySHRDNWdiY3RnWURGV2NLMGp6eXcyeXpxZHJFUk83UGR5Y212UldFTndGQVpjU0RlS3ZkSWlvbVRXaUF2eDhoT1hkajgvcWR5c0E0Y0hvbk5PUC9HSlQ5eFNUTjRsUUY0dlJLUXg3MEdEWUF4KzljaEdMQWNyVm9NREVUUW8wUWZhTmpLdkhiVUhad1UvS2hnTitxeTBMZU9kTVczMDdOM1k1K3JGQ3hTOUlVVTVaTFM2d2VyYUN0WVc1RmxCbHVjWU1ZVGdzVmxHVnVoQlF4NTlKUGhJcnl4dzRwRkJUcU9PeWJSQkZRYTlqRHdUSkUyMjR2Vng5WlV2UEhQdCtRNGNyWWg0RVluYVNZNHVlNUJsdkNZWTRlYVphdHdlTjllOEZMczJzOGVpUUYxVmJOM1k0OFo4d3N5MjFIMElvNHpXa2tRV0tvKzFrY0dSaktNTVdQTktPNnVwNnhybmFpNi92TWtMalpBVmlRSnZCSW84dzVvTVJNanluSFphSTZJWUs1aXM0MXdWbHRDQzgybUxuMldkVVNkQ2tSa0VkcCs3dHY4bjA4cnRBVzMzQ25tZTY5cmFHcHVibTB1QUxPTTFpeWlTN3BpZXZqQyt1Ti9xNXJFc1A0WllMbTdlNEx4dVVaMklTTjlRMkI2cUJoc0ZGeUp0R1dsczRJbzBQRlZOV1krV1kwWEdrYXpIc2JMUGNGQ3pzMXN4cTJkY3ZyQkQ0NFhCWU1qYXlvak1KdG1lb3N5SndaUG5HYmE1ZWV2dXZaSmxscktJQjBJTnhvQXg2TFQxei8vaEUxZSt2c2dlUUJBUnZlMjIyL1M5NzMwdkgvdll4NVlBV2NaM0Zpc3JLOVIxcmQ3N3FFb0F3cGUrZWZIR2ZPNHVpY2dEKzF0N1hKaHZNNzh6RU5XUXg0eEFzbEN6R0dKM3Q1Rk9ZSVUyVjY1YXovWGdzVlhOeW56T3NjYXlYbHBXalNWRG1GV096YTB0Ym14dTArLzNXVmtaTXVnVlNYblJncGlXNEJYdmt2NVZrV2NZVFRzU2F3UVIwY3lhNXZucmU1L2IzSzl1aU9CVkUwQlVOWlpsZWN0dDBCZXgzSU84eHZHTHYvaUxuRDU5ZW5HaTZvSHc0b1d0dmMzTi9XY2FIOTMyL3A3dTlpcm1JV25qTmhIMkp5MTFGUWtLVFF6TXZHUHFQUE9RZEswc0JxL0tPUE04bTgzNVhESG1NNHg1T2xSTUxZeEdQYzZjV0dWOWxPSGFPZWN2WE9hSlp5NXdiV3VmV1pVMiswVlJrQmRKVEM1ZEd5WWxFekdpMWdqejFsMzQ4a3Ribnd0Um15NTdlR05NVUZWOSt1bW51Ulg3ajJVR2VSMWlkM2VYd1dCQTEzOEVFWHlJV2ovNzB1WUxiM3U0R2wrdGRvNjZvNEhLUlhJclpDSm9DSGhSb3ViNFdLV3hxeFUydCtkc0RIdkVrT2dteDRkRGZKZ3hNNTRidWVkeWJERlJPZTRzWi9PQ1U4TWUvVjVPV1dUczdNNjVjUGthV1phek1ocXlPaWdwaW96ZzBwQkFqRUhTOGw2c1JTOXN6Zi9UODFmSGx3Q25TaXNpd1JpakowNmM0UHIxNi96bWIvN21Nb01zNHp1UDdlMXR6cDgvcjExRU5JMUtQL3ZGWjU1NTRibnpMKzhVWTZKTnRLdTVkeWpRWHhsQWJnZ3hrdG1NWGw1UVZWM2ZvRW5UeXNmSXBFM2ZuMXREYVpLYmJVWGthV3Erd0pTbkJwNHd5RmxmNlhINnhBcDMzN2JPcUdlNWNXT2I1MSsreHN2WGQzR0JkRUc0MElWUHA3YlR5L3Z6L3ppcDJybEFRN2M5MzlqWTBBOS8rTU8zaEp2dGZ5N3M4cEYrYmVOYjMvb1cvWDRmNzcwc1dMMUEvdUtGRzc0L1V0ZS92M2pZRlF4ZFVIVlJSVlhvWjMyQ1JwcmdPb0VGNGZLTk1TcVJMQ3NJUGhJaVZDNTBQSzdrSCtpRDBycElqaEFWcnZpV0xRMmNIQTA0MWlzbzhvd2lOK1NkaU56VzdvU3QzUm5UcWlVemxqSXpPaWlOVEozNzZoODlkZlVUVjNmbTI4QjhVV0lOaDBOOTMvdmVwMS80d2hkdTJmZHptVUZlaDBoK0hFR05NWkcwYUd1Ynh0Zi85Ny84OGgrOWRHbnZpMkpFWFZSOEZNWnR4ZHhWRkxZOEVGRHdJYkEzcnJEVzRyeDJvQUd6WUFFRHBSVnNsb3BrTllJVlFUMWNiR3YrWUxiSFhpOWpkZFRqK0xFUkd5c2xHNk1lcHphR2pIcUc2enU3L0lkdnZzRHVkQ1o1YnFZdjNaajgrMitjMzc2NkFFYkh2ZEt0cmExYlNrVnhtVUgrZ3FJb0NsWldWdkRKWmlCbEVjRTI4OERSTTZQeW5nZVB2aTlDN2xWd1FhbGNRejh2R0dSOXJGVTJ0OFk4ODhJTk5rNzBpZEZnNUNhUjBYU05Rd2hLeUNLTlY2SVRiQlRheWlHWlpkdzZycmNOZDR5RzlIeEVRemhRY1RjaXFmRlV6M1RlVUJUNWsxOThjZlBYWDd3MnZ0WmxqOW9ZNDFaV1Z1S3BVNmY0M2QvOTNWdjZ2Vnhta05jaFpyTVpmK2Z2L0IxT25EaVJ2TTdBb1RSQTgvelh0cjYxZlczK2RHNEYwYWdod3R3SExvNjN1VEdma05tU2l4ZjNtVXdic3R3bTM0NkRxMXhCU1FvbExpcXpKdUJWaVY3eFBvbkdxWUlHNWZ4a3h1Zkd1OHl0eFN1TVZrcUd2WXk2YXZIT2MvcklrTEtYVjkrNnRQTUhuMy9xMnN0ZDlqalluUC9Jai93SS8rQWYvSU5iL3IxY0F1UjFpbmUrODUyc3I2OGpJZ2RsRnRBODk5V3RTK2VmMi8vajFzZm1ZSEFxd3FUMVhKcnNzRDNaNC96NVhUMTJZa2lXR3hwaW1tb2hXQUUwZVFoR29QWktib1VRTmNsZzV3WlFva0JoRFM5TkpueHBQbWF3UHNKN1pUS3VjSFZESnFxOUl1UFkydkNaSnk3dC9sRUljVTdYbkt0cUtJcEN6NTQ5cXc4OTlOQVNJTXRIK2ZXSnBtbTRldldxeGhqVkdCTVdBSEcxbi8veHYzcnhVenRYNWw4dXJFaHB3RWd5cnVtWDhNemxLODJMTDJ6dkhEbldpNHFReDZRU0pNYlFldkF4WWtrSThTRlNab2JDbU80b3RsTml0SUtSOUwzZjNOcm1Cb0hKZnMzMjFnUXJTci9NWkRBbzk1KzVOdjcxSnkvdFBpODNhU1ZlUlBUMDZkTTgrK3l6dDVUTndSSWdmOEh4MHovOTAzejk2MS9uSXgvNWlKSXNsRVAzS2QyODhNWHI1NS85MnRidnpldXcxNnJTQmlVVHhlYXFGODVQZHZMQ2J2VUdHZE85UUpnckVpS1pNZmdBR2hPeE1DaTROaUtpU1UrWEJLSk1oTUphQ2lQNGNjT05GN2Q0OHRrclhOL2NSNUtVcVE3NnVkK2Z1ODk4L3Btcm40K3F0VUxWbFZkQlJPSzFhOWYwb1ljZTRqM3ZlYzhTSU10SCtmV0w1NTkvbnNjZWU0elJhS1NhemxZZFVBUE52LysxWno1Nzhmbjl6eURxVmFNV2hWQTEwWDN6ODllZU9INnEzK1o1WnVvcU1BdVJpWVA5bWFldEkwUkRqRWxiS3pobDVwVTJwdHYxTERjUWxObm1tSzBYdHRoNmZwTm1YTEZ6YlovcFpFNldHKzJYbHRxSEwvN0JFNWQvOWZyZWZLZHJ6QnZBVzJ0alVSVFVkYzNPenM3eURWd0M1UFdQZi9TUC9oRmxXYjVpNUN0Q3ZYOWxkdVB6di8zU3g2Wjd6VlBEWExBV2Jtelc4NTJYeDArdm4rZ1h4bGp5TExrOXRVSFozNnVaN3RYTUtzKzA5a3lhSk4ramRZRGRobmF2WWVmeW1KZS9kSjRMWDN5SnZaZTI4TFVqUm1VMmFiQUNSV2FZMXY1TFgzajIrcTk4NllVYnp5Mm1Wb0RyeWtEdDkvc2FZK1JYZnVWWGxtL2VFaUN2YjN6d2d4L2s0WWNmNXQ1NzcrWG8wYU1Ma0RoVktvVHFpYzljZk9xNUwyMythZzQ3Vmd3WG50aDdlblc5bUp5Nlk3UkJTSXJyQ3pxNldBdEZ4dHdGcGsxZ2I5YmlLbzl2QXZzWDlybis1Q1lYdjN5Unk5KzZSRDFyRUN1b0VVeEVqUXRZSTdGeDRVLy84T2xyLytzZlBubnRhNlN5YXI2WVhGbHI0MXZmK3RaYnloeG5DWkR2Z3ZqR043N0I4ZVBIYVpxRzdyWTdUYlNVT1VGbmYvaHJ6L3o3aTgvcy9kcnVUcnQxNWFtZEx4dy8xZk9EbGQ2Z2FvTmk5RUQzMDFpREY1SkZzdzlNTml1aVF0MUVtamJRekJyY3BLTHNGWlRESG9pb0VVRkJvd3U3dTdQNjAvLzI2NWQrK1lzdjNQaEdCNDdab2pFSFlwWmxUS2RUM2QvZlg3NXBoMks1S1B3TGlLZWZmcHF6Wjg4eW1Vd1duOUFIT29yTnhMV1hMMDJmMzV2NmExZSt0ZlhsZXg0NmN2ZnhjMGZmUDUxRm80ZzRiMmhEVEtQY2hUT3RjMnhkSEdOV0NvcWdUSy9PbWUzTjhMT2FzaXpvOVF2Tnlnd2Y5Rks5Vy8vYjJZMzVKNy95MHZiSG43OHhlVUZ1Z3FQcHNrZnNKbGM2SEE1dnlhT28vNjlZc25uL2drSlZhZHQyY1dWSTE3QXJFSzU4WS92YWxXOXNmeElvMy9uNG1ZZXNTSnRaR1RTdGFvaFJRcWR0bFZzRE1kSzY2SHdiSnIxZXZ0cmNxTExaMXBSMlhLa2dZbkpETlBocTdyNDB1VkY5Yk9mbDhWZGkxTDNGY0VEVGoyMzM1MGRWalIyeDhwWW1KUzR6eUgvbDJOM2RYWHk1MkE4ZVBzczlVRTV2QS92OWpYNVo5b3NUWW1RWXZKb1lZa2RZakVTVWF0N3VYWDk2Nnd2SDNuTDA5UHp5dUxmendnMmlkNUtYV1MyWmZYbXkzL3lMclpjbi8zUjhiZll0VmNaZHI3Rm95QmRsVlRqMDV6SWVqN2x4NDhieWpWb0M1THNxNHF1QUV2ZXVUT2ZQLzhjclg1M08zRk1tczlNUVZVTFV2TlhZZDVraUdkVGJ6WlZMWDc3NnI0K2MyN2hyLzRXZEU5T3I0MDJNUE9tYitLOTJyMVgvZE8veS9QZDk1VGU3VW1yR1RZYnVnVW9KdDZqZngzOXB5UEovd1gvMS8vOEhWZ2trVmVzUzZBTUZNRHIxNEltN2pyLzV5SnZ5NC8zNzhyWGlybEdlSFo5Zm1XOC8rZW5uLzdlVGo1eDRwTjZjbk5zOXYvdVZ0dEdubXBtLzN2VVdmbEZTY1ZQYkt2SksrZEFsT0pZQStaNEpjd2drdGdOSDJRR21JN1ZUREU0T1YxZVBEUWY0YUcrOHVITU5SV05VcjFHclF3QndoOHFvUDg4QVp4bExnSHpQZ2tSZUJaVHNFRWprVmYyTEhBSkY3SUN3ZUwyNngxaUNZd21RTjlSN3NRQ0xQWlJkekt0QThtZjZsME0vRjE4MUNGakdFaUJ2eVBkRi9wd1hmODdEcjRkQXc3TEhXQUxrVm03b1gvM3dMNEh3T3NiL0M2eVBSU0RHdk1ZN0FBQUFSblJGV0hSamIyMXRaVzUwQUVacGJHVWdjMjkxY21ObE9pQm9kSFJ3T2k4dlpXNHVkMmxyYVhCbFpHbGhMbTl5Wnk5M2FXdHBMMFpwYkdVNlZFMU9WRXhsYnpJd01USXVjRzVuSlhIR0ZnQUFBQ1YwUlZoMFpHRjBaVHBqY21WaGRHVUFNakF4TXkwd09TMHhObFF5TXpveU56bzBNU3N3TURvd01JMWN3bUFBQUFBbGRFVllkR1JoZEdVNmJXOWthV1o1QURJd01UTXRNRGt0TVRaVU1qTTZNamM2TkRFck1EQTZNREQ4QVhyY0FBQUFSblJGV0hSemIyWjBkMkZ5WlFCSmJXRm5aVTFoWjJsamF5QTJMall1T1MwM0lESXdNVEl0TURndE1UY2dVVEUySUdoMGRIQTZMeTkzZDNjdWFXMWhaMlZ0WVdkcFkyc3ViM0pubkwyNVNBQUFBQmgwUlZoMFZHaDFiV0k2T2tSdlkzVnRaVzUwT2pwUVlXZGxjd0F4cC8rN0x3QUFBQmgwUlZoMFZHaDFiV0k2T2tsdFlXZGxPanBvWldsbmFIUUFNemt6ZTRPV2ZRQUFBQmQwUlZoMFZHaDFiV0k2T2tsdFlXZGxPanBYYVdSMGFBQXlOVEo5WDlCZEFBQUFHWFJGV0hSVWFIVnRZam82VFdsdFpYUjVjR1VBYVcxaFoyVXZjRzVuUDdKV1RnQUFBQmQwUlZoMFZHaDFiV0k2T2sxVWFXMWxBREV6Tnprek56UXdOakZOVHRnZkFBQUFFblJGV0hSVWFIVnRZam82VTJsNlpRQXhNekpMUWtKa0oveW5BQUFBTTNSRldIUlVhSFZ0WWpvNlZWSkpBR1pwYkdVNkx5OHZkRzF3TDJ4dlkyRnNZMjl3ZVY4MllXSXpZV014TVRoaFl6QXRNUzV3Ym1mK2N1YmpBQUFBQUVsRlRrU3VRbUNDXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9sZW9uYXJkby5wbmdcbiAqKiBtb2R1bGUgaWQgPSAzMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVBvQUFBRmZDQVlBQUFCblN0SFVBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSVdYTUFBQUJJQUFBQVNBQkd5V3MrQUFDQUFFbEVRVlI0MnV6OVY1U2xWM1llQ0g3N25QTzdhOE9iOUFsa0pwQUFFbFVBcWdwVktPL0pZaFZOVVNRbFVxUklpYVRZVFdta3RkVFRQUS96TVBNdzg5QXphN1ZtVFM5TnM5V2FrZGhTeTVBdGlpSXAycXBpZVE5dkVranZ3a2RjLzd0ajlqeWMvMGJlRENSS3BNZ3FBcWk3MS9vUmlNZ2JjU1B1L2IrejNiZS9UZmplR3YwWkg4ZVkydFNtOXBkbTZuc0ljUG9PbjA4Q25LZWduOXJVM2poQXA3dDhGQk1YdlFiSVhYVk5nbjRLOXFsTjdYVUk5SVBlV3dDUTQ0OUVrTlhuQklBSVlBWXNNeXh3eCtXbTNuMXFVM3Q5ZTNSeEFPUUJBRVZBd0h6bjg0N1JTd1RMakJLQW1ianM1TU5pSlpBYk4zM25wamExUDRmSjcySStQdmJhQ2tCRS9vb1ppQUNFaCthQzJYZmRYMSs1ZHlXYXEwZXl0dGt6NDFCZDBlMklZREowWnlVSXBXWDg4RnNXOFBKbU9uMzNwamExdnlLUFRnZHljUVVnSkVJTVJzeEFjT1p3UFBmZmZIcnAzTDFINHJlSGliaUhDUUlHdTZPdWZ2WXp6d3llL1gvK2g2MlhBRWdDaUNkQ2RlR2g3OTUrb3NXaEV0TjNibXBUK3lzTzNXa1M1QUFTWmlRQWdoOS85OHc5LzRjZldmcmtBOGZpajg4MjVURVJDY1h3QVhvNXNoODlmamcrdjlBSy84WC82ZGR2ZnBidXpQT1pBWFlNM2hscUJKS211ZnJVcHZaWEZMcFBodXo3SUFjUUEyajh2Ly91a1hmL25SOWErUG1IVHlTZnFNZHlCUTVrQ21hWE9ZWmxTS1o0cnFHT0xOV2lvMmxmWG5ucXhtQ3JPakR1cU1KM1VvTWJuUUlBOEpHejg3aThrMDNmeGFsTjdYc005UDNDR3hGaUFOR2gyWER1MS83KzBZLy84THRtZnZISVl2QzRCQkpud0xBZ1loQ0VvRUZmMG1Bb21VdEFqOEo1YWFQd3lSdTk1M3VaU2FrSzJURnV2UkdZQ1B6dVV6UDBsZXNEL05JN1YvSHQ2NFBwT3ptMXFYMlBnYTZJRUlJUkNVTHRmLzc3eHovNjhiZTNmbkdtS2MreWhtUkxBQk1SQTBJQzJVQmliMXRpbUNucWpRUnQ3WklVcEpaWDJtSDNUMS9ldXpqaDBmYzl1eFRFaFhiNGF3OHZVcWdFdm5tdFAzMG5wemExN3lIUUpRQWxDQkVEd1lQSGt0VmYvZlRTengxZUNCNTNCZ0lXSktRSGVKRVRkcmNWdXRzU2tnaHBCdHpZWkhSSHpLRVVTVHRXczBsSWw1NjVPZGlvOG5VekJqcUJrR3JubUlGaGJsQTZZSkNiNmJzNXRhbTlocW0vWktBVEFITHN5VER2ZmJDNVZBL0VFWEtRa3BsSkVhd2g3SFlJVjY5TGpFWUNrZ0h0SERaN0ZxUGNJUXdsTVlObm91QytkeDJmL2RGdlhPMnRuZDhZM1NSQ3d1eUI3cGdkTWNSemEwTmVhSVlRTkMzT1RXMXEzL1BRSGI0UUYvN0NSeFlmdm0rKy91R0E1YXd1Z2RGQTBxWExFbGV2Q1hRSGhLeGtiUFFOcnUxb2RJWjJud2VuSkVFU3laazRXRmxvQkZ0ZnVOUzU3QmlPRG9Ud0RPSkNXNHdLQ3plRit0U205ajBGZWpBRys4KzgrL0FURFZYL1FIOGdrNTA5UlpzN0VyMCtvVWlCVVc2eDFkWFlHcGg5cHBzZy93TWdCSUdJUTBGSk0xSkxjVWlYbjE4YmJsWjlkWHM3aEFjN0JvZ0lQQVg2MUtiMlBRTTZWU0FQQUlqWnVMWjhkSzcrV0RNSjV6Sk52RHQwdERjMDJPeHFyTy9rMk91WHNOYkJWU2dWUW9DRlo3NExJcElFek5iQzJTUVE5bVl2ZTJHelgrWjBBT3hTRUx2cUIwUkt3azVkKzlTbTlqM3g2T01XbTd5d01lcnAxQzVldWpHNC82VnJnL0NGYXdPK3VwN1I3a0Nqc0l3U0RNc0VnRUVna0FCQUJDa0lSQVFRbUFBeFV3K09oa3BzUDN0cmNMa3d6bUJpeW8xNVhNTUhsQkM0ZDdHSjNWRXhmV2VuTnJYdkV0QW52Ym9BRUpUT21RdmJvOHVYci9XWHI5L3EzdHZ0cDFKYjczRkpFRmdJRVBseE5sR2hWNEJBZ2p6L2xZa2M0QUlsb3BsbXVNVGc4eSt0RDNjT2h2Q29HblpLRXMwazRSVG9VNXZhOXlCMDM3OElDRFZ6U1FJMzVoVk9TL0FxTTROSWtCQUNTZ2hJUVZCQ1FGU2VYSUpBRllMQkFBa2l5OHhSRWl3SUpiRFR6MS9ZNnBkWjlaQXgyQjBST0pRU3pWalIzcWljdnJOVG05cDNFZWdIUVE4QVFlRXdESUFzSkQ0TmRtMGlJaVVWS1NrZ2hZQ1NvbXErRTZRQUhBT0cvRW1oQUlTQkJCT3dOQnZmU3dMYjUyOE5YaTZOR3dQZEFtRGhlWFpvSnlHbVFKL2ExTDY3b2ZzazRDZUJML3NPMXlOQ2tVaStqOWsxSElOSUNrUlNRZ21CVVBxZU9oekFBbURsODNUSjhHVjFJbGFoa08wa1dOREdQWFZwYTlTcGhDcjh6RHFSRTBTODJJeXdNNXlHN2xPYjJuYzdSNitDN2xkNWQ5bXp1RmFYUkRIeFdjczJJWktzcEtCUVNhZ3FUM2NFWDNuSDdmazFjb0FnVU1uQVhEMWNtSzBIeWExTzl1M3RRWkhpdGppRkE4Q0ZkbHhNaFNtbU5yWHZ1a2MvYUdQUUN3RFVON2pTbGxoU3hHY1lFRUlJRWtMNi9Gd0lpT3JSNHlvYmlFRGo0WFJCcEFsWWFFWkhqWFUzTG15TVhpNnQyMWVpWVlBTE0rMnZUVzFxZjVWQUJ3SENBVGEzdUZrakhCWndKeHdBSVNRSkpSQ1E4RzAxNFQyN282ck5OdjV1OGw4WGtsUmFPblZoZmZESC9VenJDYS91UjJhVWhJd0NzTEhUZDNocVU4TjNYKzU1SEVOckFJS3JNTDd2Y0htdHhQOThSTGhaSVlxSGgxSTZJVWtJRUJwaGdGZ0lFQUFtQjhjQUN3SEREQllNUlJZbUVCaG0xaFhHamZYbjl0VmxHWEJlZjJiS2Y1L2ExTDVYSHAxZjQvOVZ6dWdvWURzaDNNL096dHJLczBzNTl1cSs3RTVWK083ZE5TTVVFcnZEY3Z2YlZ6ci80Y0xtNElKMVhGUUh5ZGlyNzh0RUMwVmdPOFg3MUthbXZzc2dwd212VG1QUFhubGVzYUh4allENDErZGgvaDRvWDVCQ01BaWtDYWhMaFlBQlpvRUNEaEVKMUVEdTZ2WVEzN3plZWZiNVc3Mm5DMjFEOWdNMENyZmxwSWtkRTVFREZIRVloeWh6MzI0NysvQkRJQUROcEk0b0RPK3NHQkxCR0lQbm4zOGUvWDYvNHMvZmVVaU0wNGg2cllhSEh6NEhwUUxzZGJ0NC9ybm5wbmZTMUw3dmMzUjZEYTlPRENCMVdJc0lJZ0EvYXF3UmpvaGtvRUJTZ0lUWUI1aHpqQXViQS9QWjg1dmlwYzArTW1PZkJtRWJ0NGt6Ky9QcTQ2ZVNRa0lJQVdzc1FJU2R6UzBzcml4VEhJUVVoQ0ZKS2NrWEF3VXBwWWlJYUhOems0cWltQ1QrM0Y0MjRkRlBZUlRTNnFGRHBJS0E4anlublowZHpNMjA4WTdISHNhMUc3ZW1kOVhVdnU5eTlFbUFUK2JyKzBBcUdiU2g4YjhyNHVVWm1KOFlaVG5MTUFCSkFSQ0JsYUIwbVBQbG5XSHYvUFp3YzNkVUxqUGpKQVQ5UTFMMGIxaTcvd1JHQ0M4anZSKzZNd05HVzRlSmdwd1FBdGN1WFlIdzNwdXN0ZnVIVU9XOWlZZ29ERU13TTFYL2NMdk41MGRqVVphYXYvV3RienZuWHQzR2swTHdleDUvRkc5OThENzh2LzZYZnpXOXc2YjJmZVBSLzdNZVh6TUt4N2dTRVpvS2ZNYkFrUU56cGcydTd3N3AyVnZkM1l1NzZlY0hoVmtDYUJtQUJHT1JnUHNnaU9Id01nNXczdy9FRUFTQW1KbU0xa0pyTFp4endqa25tRmxXbDNMT0tXdXRjczVKNTV6L3lFN3QvNzl6eWptVzQrOXp6cEZ6anBpWjhxTEVyZlVOWWpDT3JDelQzRXdiekl4ejk5MkxTOWVuWG41cTMzOUF2Mk1wdy9ncUdBTVc5SW9VcEMzenFGZVlyMTdjU1hldTdPWExuY3hJYlZHSG9FTUFSeE5SUVF0RUowbUtEVGkrY3BlLzUyQUlMZ0JJWmxiTUhFeDhESmc1Wk9ZQWZzUTJCQ2dFT0t3K3I3NjIvLytTbWNYNHFnNFJnSm1ra0xTMnVZVVhYcm1FZHJOQlJNRGF4amFVSkRRYk1ZNnN0TEV3VjhkZWQ3cUFZbXB2dnREOW9JM3phajMrbkFHN28vbkt5T0ovRkxsdEdiWlVXRDdFQUJIanZTUnhVZ2FCc0tVbUpqQ1lOWUZDZG1oQzhoRUE5U3A4bndSMWVjRFRUMjZRa1VLSU1lZ0ZpSVR2MURNQkVGWG9mcmRGa05aWCttQUF0c3kzVjBjNVp1dU1jVklLWjUzakYxNjU1SHprejNET2E5MFJFV1phQ2VJb1JGNU1PZmxUZTNNQ2ZkS2Jqd1VmeC9tN1pZWk5MV3RZWkFCcUFGSUF2OFpBUW95M08yT3ArZ2toZ2JwSnN5VlVHSkhPc3Fod2FZTUlocVNBMVlZcVR5dXJ3MlNjcUZjcXRhVEdvWHF6MFpRclM0ZUNxOWV2UVp0OHYzSi81dlE5MGVsVHB4T3VBb0wrWUtCN3ZYN1o2ZXpxdGJYMTBqbm5oQkNHaURVekREUHI2cm1NdGM0Q2NQNUFZTXNBZzBIV09kYmE0dHJOTHVkRmlWYXpBUUxRR3d5bmQrTFUzblFlL1dEYmJiSllOL2J5NDU1NEhjQUZBUCtNSGMreXMyZXFpSndncU5XZVc2VFRiM2xYWXJUKzJBdmYvS3pWWldxa0NseWVwbjlpOHZJU005OFY2TXdjTGkwdGhSLzd5RWVXN3p0OSt1emlRbkxzcTkvODdMVlhMcjk4YlpUdmNTaG0xWC83RC83UDczM2IyOTc1WWNnd0pFR3lQeGpjdkhuajVzM3JsODV2UGYvTTA2ODgrZXdMcjF5N3VkYnY5UG9teTdJeHlIVVZSV2dBaHBsdDlaeU9DRzQ0S2x5YWxpeWxJQ2tsU3lMMFJ5TXNMODVpYzdzenZSdW45dDByaFAwVlAvZVk0THJmVzYrODhMaUtYZ1BRcVBMaVg0SEVUOE1oUnVWbWd5akN5cEY3emRMUmszVGoyb3R1Yit1R0pTZ2lnYThLb1g1ZHA4WFRWdXU4OHE2b3ZMejZ5SWMrTlB0VFAvRVQ3L25RaHo3OENVRzloeS9lL0xkMVJKMysrdmFORjBmNXNEZzY4N0hvOFlkLzRaNzU1U1BMcVBycCtTakZ6dlZMTGhFYVVTZzdYL2pLMTcvNjdQbVhYeXJLOHVyekw3Nzg4aDk5L3F0N3cxRmEzQTN3NDRPTGlDd0F4OHlPaURpSkl4aGplSDZ1RFdzTXRuWjcwenR5YW0rYVl0d2RWaEhnZ0RzcjVqenh1UUJRQUpnbFFXOGhRYzBLNkhET2NyK3owOTI4Y2FsTSsvMjZJNnRJc2hKS25WQlI5RmFoWkdaTHZRSHYyWk1nREpMLzdyLzk3eDc2NVYvNnBaLzVvVS84NE04a2NYam0yUmYvZmJpWmY0NWtzNXMwRnZqSUEvZCs1TVNqRC96YzBabkdrUVpiQXlLQi9sNEhheGRmUW1CSE5OTnFVV2N3cUEvNk8yZWN5OTh4MTY0L2tVVEJhUkpBczFIWC9jSElhR1BHMm5tVDlOdzdjbjRpSW1Nc0JCR1VrcVNVaEhJaGNqTWRzWjNhbXd6b05VV1FncWdleUNwSnZ3UG9rNFU3Q1dBWERBYmpPQmp0TVdoSUNLRUNaUUhFYkIxVUpEVWJUcTJ6Q3lCM21BMWZnK04rRUFUSjMvdDd2M3J1SC82RGYvaXJaKys3NzRPQ1VidDU5VHhmV3ZzOWNxb2dpZ1EzazlOOFp1RnZvUjJmQnNNU0VWUGFIOURPemF2VWpva2FqVHA5OVp2Zm9OLzY0OS9nUC9uMjcvRFZqZlB5d3RXWDZqdWRqWHRhemVSZHpWcDhvaGJYb25hellZdWk0S0kwNDlCZFlaSjRjMENrb3l3TkN5R0luTUFEWjJ0NDM0UHplT0hxZE0zVTFONGtRSmZWQ0tvVUJPTVlUSGZONThjNWZRbmdXUUFEQUhVUXVpQmNJTUs4aXFJWkVMRXREVm5ORzA3YnArRzRibzFwTzJNdkFGai9wVi82NWZ2L20zLzBqLzdtMGFOSDM4SmxLWWFkTGw2NTlFWFJjOThtRWhaeDNLS3pLejlKcTYxM0ViTW1ra1JabW1MbjVtWFVsUU1EK05JM3ZvRFBQZlZiU0k1dDA4TWZXS0Q3enMzZ25uTk5IRG9kSVdyb3lManlaQlFHajRSQ25JMENjU3lVUWpBaEwwcGpjRHN0R1hjRi9CL0luaUdvdFdFWkNscGREbkY4UHNHTFZ3Wm94QXE1bnM3V1QrME5EblREZ0hGQVlSbmoyUk8rVFhCNXJZR1lDeFhnbndQd1JRQ3hzL2FzTTJZRXhnc1FHRkJJZk9UazJmYngwK2ZtYTgyWmZoSkYyWC8xeTcvNGthTE0zblhyMW8xd2ZuYU9SbnRiOVBMbTd5RlgyN0FzY1h6bVhUaXo4RWt3TTRRa2xOWmlkLzBHRWlyUjYrM2hjOS8rQTF3YWZBNzNQdzZjUGxkSGF4Wm8xSmpxaWFEMmpLTFZvekdPbjQ2NXRjQlJYSmRIR28zd0xVcktjd0hrSVNtRk1kWU5qYS9HcXdtZ1R6THp5TEFGR05qZUs2ZzcwR2pHQVFhNVFTMlNlT0xlV1R4NnJJbnpHNlBwWFR1MU4xNk8vbWUwU1FvdEFlZ0MyQUdRZ2FDSjZNTWdLZ0IrQVFKekJIckg3TUpxODU2emo0clpoZFdWdk9qY3U3Tzlkdm8vL3Zadk5ELzcyVCtrUWFlRFF2ZVFOMTRFNGh3eHJlTCs5c2N3azZ6QU9RUElBTHViNitCUkI5M09Eajcvek85ajBQZzI3bnVIeE1Lc2dvS0ZJb2VBR1NKM1lNMElBNGQyazJuMWNJd2pwMnBZUGxKRGV5NmFWWW9lWWtQM05XdTF4WVg1bWJJM3lMcldPcHA0N1cvejZSazBHQmxzZGdzNEJvMEtBMlpRcUFST0xkWHdndzh0b0pOWm5GNXE0TXJPbEhBenRUY3YwTWZYNUtCSmpZaCtFSXJhQUsvQVlnRVc0YUMzUnp2ck44cFJ2eU4zZDI2dXZIVHBwZHB1WjVmVzF6Znc5VzkvRXk5ZmVSbTlZUSt6Q3cyY25uOGJWcUlIRVFRUmdsb0RnOEVBZzUyYjZPNXQ0V3NYL3dSdThVWGM5N0JBdXlaQTJnSFd5MVZIQVNPTUdUSUMvUHdOd3pxbVFEbHF0Q1FXRGlVNGRMSkdTNnZ4dkNENW9NMXgzMHlyRldqTEcybVc2OHE3MDRGQ25RQkRNSHRoSFNrSURORGVTT056cjNSb3BSWGpmL2lwQi9Ccm43OCt2WHVuOXFZQU9rMkU4SGU3eHFBdi9lZDhBb3dGT0lRZ2dKMUROaHh3ZDJlanRHVWhITE93QW1pM1poQ0pHQmN1WHNXdHF3TWtZZ0h2Zit2SElWMGRTYk1CSnNMVzVuWGN1bkVaTDZ4OUZlR1I4emg5bjBNdEpNQXhTQkFVTWNMUVFjcHFMeFJWcy9QQ2I1eHdSQ0RCRklTTzJ2TVNSKytOZWZsb0xGVk1LMlhLWjAzTzdiSjAxMHBqTkJoQkpaYzN6dUhGaEpjWERKQnpUTG14S0kxRHBoMys4Wjljb1NpOExaRTkzVTR6dFRlTFI1OHN6QUYzaktPaUFQQXlIRGJBV0FDd0NrQ0RjQXNnaEtGcXRtYmFRdWVXeW1HQnR6MzhDUDdSci96WDJCNnM0OXExZFVnWDQ3SDdIOFh5NGpLU2VoUDkzaEJYTHA3SHhiV3ZJVDV5SGlkT0d5Z2lhRU53TENBRVEwakFXY0pvSkdDWklDUWdoWDlTUXdJa0NVSUJyQUFwSEtMQTBleWl3ckhUTWMrdWhIVVFuUW9RejIxdFpSZTBOVG44VHZsSUNsTFZKaXJKdDBHL0g5WTdBTVBDRUFnd2xpRUZVU1FGbGxvUit0TzEwVk43azRUdUJ3RS9lWlVBcmdKNHBjcmZud1B3bjZKWVhvbmljQlZTempydGNPYkV2ZmlwSC81Um5EcDFBczljZmg0N1hRMFdOVVJSZ05XbFZRZ0swVXN2WUtmOEdzVEN5NWcvYm1CSVFkdHFaQmFBQTZFMGhEd25XUGlOTWdJRUVUQVlCQ0VaU3JCZkdGa0oyWXBxdTFTUUNGcGNVbnhpTlE2T0w5ZU9IemxVbitzTnM3VmlZSVcyWERnR0ttbXNVQkFGb0FOZ255amVDVUZnWmdxa1FEMVM2R1g2amhkTUNBa2hGZGg5cjZ2MmR4c1JxRXdGOEtma3RKTXdCZnAzdm9OZXk4dVByMTBBNTRsd0FjREd2V2ZuK05pOTh3OTNkNGJMMmpqODZpLzhJajc1MFkvajEzNzluK096bi8weVZGeUg0UURuWDdtSXpjNHJXRDYxQ3l4K0E2NXhGV0diUVlHc1ltZS90bFU3UW01RXRUWUtVQ0ZBa3NDRzlvR3R3SWlVUXlJZEFtSTRFTFFURUJKQXdjQzNOVFd1V015Tm9JNGx3ZkZQbmx0ODVBZnZXM3pveEh5eVVvOVZZNkVaUkFEY0lMZUdHUUVSQlVSM3RPV3FhVG4vVVZ0R1B6UDdlbnpqMTRwSUVCRzlGdERwTzF4L1hrUWZ1T2kxZjRhUUFKamczRi9HODAvdFRRcDBmSWNiWWJMZmJsR052cnpqZ3ljZVBubi80bnR2WFI4ME82TVVOemR1NE9WTGwvRFZiM3dUNnh0YnlITURSVU04OHM0QUgvbDBoTmFSWFl5eUZQbVFBQ01nQTQ4cWF3RG5wMUY5NkM0QUlSaTNON1l6MkJFQ1ZSMEtFSkFDa09SL0pRZUMwd1I2VXNNOVoxQjJISEhteUkyZ09NTkNMT1d4QjFZYkQ3L24xT3pqN3pzei84UVQ5ODY5Njk2bCtteWgzYUNUNnNJNGxvSW93SjFMTE84WXZ5VWlVWUZzUEhzUGZtMUFpZTl3MFYwaWlJTmYrODk5LzkwdjV3ak8vWG1lK3p2OTNuU1gzM0Y2V0x5R3FUZlk3OHNUQlRvMzhUV0x5VEZVcnpnam1GV05oRXJhY3pGdmJnbGN2SGlWcmw2OUNWdGExRnN4SG5oc0ZwLys2OHM0KzlZbUJJVklPNEN6UUNBWU5nU3kzSStWRWdDbGZFaE8rMDlESUdJNEpuQUZzVklUWFBXdmhnbmtHSkFFS1JqOGlrSCtnZ2FYL2pZdE5WQmFSaisxWUdaWkMyVWpVbWdtb1RpODBrenMzT240N1UvY00vdkpyMS9wL01IdlBydjEyWXRiNldaaGJBQkd3VDVWS2VHMTdQMHdrSmZJY1FjS2xRd2lubGdlVHlBU3VEMkNPMW53dkgxZytqRmNybjRtMzViY3ZnMUV2dk5udkNyQ3FqYmNIZ3dueGxPRjMrbDczY1QzKys5NUxRRGYrVGNmVFBHK1UvbzM5ZWh2Rk05T1JQRDcxdTU0LzBVVjVnWUExTXFSMmJlMDVodVBIVDgxRng4N1BvUDVaSUU2dlNIbVZrSjg2cWRPNEdkLytTaE9ubTFBTzRsMEFMRDFhYVNNQUNjSTF2cENXeUQ5UGNpVzRISkN0Z3NVUThCYUFWWUVad21XeVpOKzJIODlMd1Z5TFZBNEFicm1ZTDZsNFlZT0lJYldRRDl6eURVamtBS2hJZ3FWb0VENlk4VUM1SmhqQ2JGMFpxbngyRHZ1YVordFJUTGI2SmZibzlKS2dNWTgrckVvNXVUbjRvRG5IK2Y1azQ4SkRueC9jT0N4azE1VEhyaUN1L3lNZzcvUDNYNkhnODhmZklmdk8vaWNkL3RiNVg4bW9oQUhEZ2Z4bjRrS3B4Nzk5VnFjYzh3a2lOekVjcGRKb1VnUVFaVzVGa3FGV0QwNmd3ZE9MT0E5SHpxSzV2RUI3anZiUkJoWjlQc01reEpnZkRYZGdtQzFmd0lWTUVJNEJFUXcxanMreDRReUV5QUJrR0s0Z2E4dHNTQmZJUE5aS0lpOU4xZTdEdnJwRXJabllkbVh6b2VGUTFZNEtFa0lBNEtTaEVnUkFqa2U2R05Ta2xCb3BrSGg0bFlZdnVPbkhqMTg5dmg4N1RkLzU5bk4vL2p0cTcwdHkvdFRjdnZUY1JQWDVKb3FkNWZRMW9QRWovU05QVDBUTS9PQkxiVUhQT0U0VFpBSFBQUGsrK0lPZk8rcnZuOGk5UkJWT01IZjRYdGZDN2gzZS94ckRVYjlXYjMrRk9pdk82UXpvOTFxc0hOTWcrRm9VcDZacXFxMFlNTkJubW9CK1BCNTVmUWVqaHlLQWRsRWYrQWdoNEJKQlZBeWxQT3ZocXdESkFGMi9vNHdrdUFIWGNkNU9oRFBNQVFZeGhKTTRSVnFiVlgwcGhCZzU3MDh3S2kvWEtKY04zRHNaWFRTd2lFdkhKUWl4RUZWeVdkQVNFSVkraTN4RElJU2dGSkVVUWlNTWtlMjVQYmJqczM5M0hJek9qWGYyUHFOcjk0MG00WGpQQkRvS1JVYVoxM2gyTm95ejNTZWp2UUU2QThDaGtBa3dVeVY4Q1VSQ2JCekRrSUFibjlMTGVQVmpNUko5UjFaUlZBUVFwSzFsb1VVN0t5YlBGd21BVVlIb2dSQkpJajNSWHY1dFlBdTdsTE9QMWlFdFhjQnZEM3dkWXRYYXlCTWdmNUdzRHd2NFp3YjY2MVBudndTaE1DVUxFa0x0Rm9DeDg3RW1GMElZS3lENzF3RExnVnN5ZnN5TkVHTjlndHN6aktjQmt3aHdEbURGQ0FWRUNnR1NVYXVCVXJ0dWZuT0NZaUtURk1PUFgrZkJDRmVMMkd2RmJEYXdUSmhWRGhZNTlDSUpVajRTS0F3RGxFZ1lBQ1VqbEdQSmNLS0wrZDE2SWlTUk1Cb3g2UGNCZmZNMTkvNzgwOGN2YWQ5UmV3OXN5dExCNUhGWVVUR21NSmE0L0pzZEduejVwVS95UHE5SzNlQ2dnaGcyNXBmUERHN2RQZ3hFRFdJZVNpa1pBZ0s0RndtaEloTFl6cUQzYTJuTzV0clc3aVRzQ1FBY0JnR3lVUG5IanZYYkxYbnRHUEYxZ2hteENES3d6QnNnTjFnN2VhMTV5NWVPSC85Ym9YVXhTTW43NXRkWERucm5KVmhXSXNBU090TUNIQnFpN3k3Yyt2YU43cWRuZTJKdE5KQlVLMDF2M2dxQ0dNRVVrSHJzcS9MM0ZscnMxR3Z1d3ZtY2dMUTR3am40T2VFT3lYQjZmc0o3Rzlvb0JkbENVRUVJWWlzZFZWSVNBcGdGWWRSK0xGMy8wQnk4cjZhU0pPWFlZSVN4aEVDWWhBVGhsc1d6aEtDQUxDdXVvc1ZVR2FBWlVKVVpZQkdFOENBc0lDdFBxY1NTSE5DYVh5WUxvZ2dsVDh3TEFBckNlSEFRRjB2WURMcjliS2NMeWMwRStWM3dEdGZaaEtDb0JSQmtJQnhRR2tKVE1MWDZnWEJ1cW9hcFFRMTZnTFdzamdVaDhkKytSRTY5cnMzWW54dEt6YURVVjdHdFRxRWtnaVMyb2NjODdrOWNmT2ZEcnU3TDkvMllvekc3TnloSS9lYy9jVzU1Y01mRDVJYW1Ud1R6bG9meEFPV0hST3B3SmxqcC83MDJrdFAvZFAxYTVjdVRZSWhVREorOUxGM2Z2aVJ0Ny8zbDZWVXExbGVzTllGSExOU0tuQ0JDa1U5U2Zqa3lUT2ZaK2YrNmFWTHIxeVk5TVlMaDQvZjkrRGIzdityN2RtRng5SmhEMEdVU0NHbGNNN0NPZU5Nbmc3RElQaG53MEgzTjR3eFhnQ1VJTnVMUzU5b3ppNzhUUlhHYzNFUW9TalNVWjZOakxIbWhySDJueFdEL3BNQWhKUUlHczE2V3dnNUdQUkh1OGJZOUVEdUR0eVdML3UrQXJ0Nm8vOEJEQWgyKy9wdzQwS1AvSnVmL3VGN2YvempQL2FXTlR3WnY3ejlISnNDcEFUREtxQklHVVhLRUlMaGJBVlVBc3lJWVIxVnBTNUNDYi9TeVkyang4SVQwYTBCeW94Qm9RQkpUMXVUeHBObElBZ29HZUY2Q1Jwb1pKcmhlTHppSFhDTy9mOExyNTZocElCalFEdUhRQ2wwVWtJbk5iQkdJd21GNzg4TElDOGQ0c0N6Y0xWbG5rK0FIenhrT0JqZDZ2L3JwNis5c0RadzNiaVdISjVkWEQyOWRQaWU5N1ptNXBQZXp1WnY2VEpmRnpJUTFtaWFXem4wWSszNXBZL3ViTjhzeU5GNlBocGtSaGNsZ0VBSWFmSjBKRmFQbjFrOGN1LzlIMVZDTklJdy92VjBOTndob3NBNTR4Ym1GODZlZXVDUlg5Yk9Mcjd3d3BPM0J0MStidGxhS2FWa1poNE4rc0h4azJkbUgzN2tuUjk4L0gwL0VNbGE2emZUTE8wcEZVb2hsV292THY5OGMzYmhiZGN2dmREZldidCtWUVZoeG9TMk16b1FTaWF6eTRkWEd2T0xQM2JzOUFPOVlYL3dpbk9HczJKMHVyMnc5UE9tS0JlSDZlNTJMcVVpY0dDY2JVQ3AxWHByWmxRTStodEJJRnlySFgrNFZrK2VJSktEcEpFOHBVdjM5WDYzZjZYSWl6Mjhtazc5ZmJXQjh3ME5kUEl4TzFYYWNKSUlBVE9MKys0NU52Y1RuL3pFeHhabjUrNS82Vm9mVmp0UzdGY3lHd3Zvdm9FejNtTTZBRTR3V0JLY0ZEQ1dJQ3pCbE5VeFV2b1lnVVJWQTNDKzNjYWljaEVHdDR0d3psUGhhbHNhNG1hTzRjaWl0SXdrOEtFNncyY0dxdUxFc3dXQ2dMdzBQUXQwTW9ITmJvRXNMOUJPQk9DQXJQUlJaMW80QkZLZ05BNXhJR2lyQ3pSalFZOGVhaVFMSHo3Si8rSXJhMWRmM2trUGQzYldvcVRlNEVaei9tMHo4MHYzRnZsd0VNUjFNbVhoR3MyWjVlN3VocnAyNlh5bTgyemRqRWEvQStCV2RValdJZkdPWG0vcjdjWVZpN05MaHg5ZlBIcnlVTnJ2N2NrZ0pPZU1hRFNhOHpjMk4xZHVYSDR4MzFpL2NUWHI5ZjZFSFY4YlY5QkZLTjQ5S0lZZmJDNGZiVGVhYzQrdkhEOXp2Ti92WkVvcG41TkxlZlM1YjMyT09qc2IyV0IzKzJ1dUxMOENRS2xhL1hSamR1WUhvbHB0Zm5aKzVjVE04dUZmaW1xRFBXTkt1TjMxWnBhT1ZvYWR2ZDJzMS90ZElxVE4yYmxIWlJpZVVKS095MENlVFJxdHQ5VWlPeHNFNG0vcFVzOUNXRnRydHQ3WGFFUzM0UGhmN21uOUc5WVBCUEJkY3ZscGUrMzFhdTk1eHlPNGZtdWphcWVSVjNZRkloQmlJaVQvOWQvNnlRKzg3NTN2L3FtbzFtcGYyWDZhaC9rNmtSTXdMR0JTQnowd1hsK1NxNlhxOEsyeFVnaG9KaFNwUTU0N09BaGZoWGRBV1RKMHlURFdkM1ZaaVAwSyszNG1MQUJsSEpLYkdkeFdnVnhQYkk4UUZWVldlUmFkcnhzeWdrQUNNc1JHMTJDOWs0Sk5pYVdHUXFBSW0vMFMzYUVIdWhDK0JCRXFQd0ZqckM4RzlqTVgxTUpndFYwTFRsN2VIS3p1ZFljMXJYTU0rbnVVcDZQRXNXczdhOXJXbERPOXZXM1oyVjdIc051SnBaU1JrT0lMYk4wVkVLVWtSVXlDUHVtY2ZkUVlJL04wUU1SdWxwbFhnekJjbFVxdERQdmQxc2F0YTdoNTdWSWdCVmJESUw2c3kvS2JSRFFRZ1F4VXBENWl0SGw0bEthMHU3c2xqQzdiN053OENUR2JwNE9aM1kyYnRMdDVrM1NSdDBpSXlHcjlGU0hWV2p6VHZvZUFUK28wcmVYcHlGbHIydG9VeTg2YTVYVFlueGwwOTZTMVRvS2hwVkxQUi9YNkI2U1V4N1V1aFdVVE5tZm5EOGR4OEpac2xLOTJPc05Yc3JUNGszcTlGcllhcmJObFhxNE5CNE92TWIrcVN1KytuNHB5YjBpZ256eDZCSTFhUWp0NzNYSCtGUkJSekl6Zy9ZOC9jdUtIUC9xaG56MXo2cjZITlF1K3ZQMHM3UTQzWUl5QVlZQlRBMWRZRUFHNlpPaXF1cTV6aHlKM0tBeVE1ODVQaEJIQldVQ1hEbG83c1BOM2kyYkFPTTk1WmRBK0g0VUVJZWdaaUNzam1OeEJCZ1NxUUNvRlFRaFVuL3MyWGhRckdGWlkyeXV4MjhzUVM4WmNFa0JLd3ZYZEhJUE1ZYjRab1JrckJKSVFLSUlpZ2xRQzlVaWlYVk9vUlFvRXlPVm0xR3hIS3VxSkd1VHNJYkttNUd6UTYxcGpSM2s2TElvOHkwaXFPRXBxbEEvN1ExM2tMNEhvYWJaMkFDQUNzNFBqK1RCS2pzMHVyQ1pnamJUZktmSTB6Y3NpSDZTRHJyWTZqNDZjdUkreVliOFk3R3hmZGV5dU9HZXZBbERzV05yU3Jrb1pIbHM2ZkN4aFY2Qzd0eld5eGc3QTNNL1RJWko2UFdvMFdyeDk4OW9Pczd2QTFyN0k3RWlQUm1FeEhDNnBNSnhYaW9LMDM5RkZuamxkbGlCQlpFdU5NaDFLQU9Tc2VhYk04NXJPODFYclRHVEtNaUJCU3lUa0RJVXhLSWpXblRVdlJnR1dTYWdWSjROU1JuRmY1L21HYzA3ajFlM0RhZWorZXJXTjdWM2tSVEZaelpYajhQM3NxWHVYR3ZYR2lhSTBLQjB4WEVqR0NqQXpGUG5DbTNHQVNTMjBBU0Q5djVXbGd4RUVGL284TzRnRVVEQUVIQVQ3b3BrVC92dWRZeEFzbUFYQ3lMZWpuUUNrYzZDdEFtWmdJSVNYeUNJSmhFcjRKUTZWKzNjTUNDV3hOWERZNlkxUUZnVm1hZ3BKSUNHa3dGNnEwUjFwMUVNRmJSeEdqaUVGMEtvcnhGSWdEQVJrdFhqU01TTlNFb0VpZk9EK0JSdytUUGpNTGRiUGRPMnpaWlovbzh5S2pBREJqRUlHNFFlWGo1NTRiRzdwa0FXTE9JaWlUNW15U0lNZ1ZHV2VaVnFYUzFGY0srSjZncjMxSzdkNjI1dWZNd1pyUkpRYm8xVnJwdjFBR0VjLzlOajdmNGgyTjI1eEdDWDNTU25tZ3lBTWg2TmVxY3R5b2RtZXo2TWt4bzBMVDYxM3Q5Wi9uMFI0U3dwUk1uaG02ZGpKVHozdzlnK2VYanA4eWtKUVM2bmdSMEVpTXJyVWc4NFd5aUtsWVdlams0K0duMkdTdDBqSVZ0SnVmWHo1K01uVm5WczM5cHl6RjFVUUxoWEZjTnV3VFVFdU1ZTmkwNVpGV05hVHhiRFpSbXQrN241VFM0NW13OTA0NzNWRWUvN1FZekZUa0VhRFo0M1dJMTlwdVlOWU15M0d2VjV0dDlPRE1mdGptWUtJeHF1UmdzWDUrYVVnaUZxakxJY01GRGtIK0hVcDN2TTZLYUNsUU5ZM01NWjVLU3ZETUVxQWxJQndGaW9RZnE0OEFFSnhld3JOc2Urdmt5QW9DU2hKQ0FRZ2lFR1NvRElIMVNrQlpnZ3BKZ3FHWGlvckx5MENJcEFrREVjYUc5MGNvV0RNTlFLRXlzK1hGOVppdTE5QWtmKzhuMmt3Z1BsR0NIWU1SNHhDKy9LZ2M3eWZBaFNsei8xUE53U1MxUkxOQVcvK3lWYnhkRnJhYnVYQjB0MWIxeTZGVWFTT25Ycm9rVnE5L2RobzFDTUlBU0VrWXFrUUU0SEF0cmV6Zm5IejVyVi8xZC9yZlI1ZW93OEFrQTM3WDFEUjA4T0gzdjdCbjF3OWZ1OVpnTTZxSUlBZ2dUWld3Y3hzZElsckY1L2J2SGI1d3IvS3VyM2ZCekRXdmlKcjdaWFZvMmYrd2FGalo4NzBlenNyUlQ2Q2N4WUVoNlRSUkRic3J1OXRiUHhHT2tyL0VFQVBBRWtsTWIrMCtqY1dqeDZQQVhyUW1PSmNuc1UwNnZlYWVYLzBNaHgrVHdYcVhCQUVQNWozK2pCWkZyUm41bVlnUXdnWk0wRUtZMjNMT3RzQ3NJWURLN2FuSHYzMVhZVWJIOE4zY0xhRkVNSGMzTUp5b3pIVEtqVWprb3pTV0pUYUlSQUMyanJrSTR2Q09PUUdLREtIVkR0WUFESmdLT3NnblFJSkJyVDM1bGI2RU4wd0lLVUhlS0E4eUVNSnozOGZ6N2JzYWFDbjRRVHQ1K1VZNS9qR1YvaU5CRzd1WnNoeWgvbEdnRGdnQ0NLd1kwQVJkZ2NGaXNJaURpUzBjVERNcUVjS3BYYlk3bGpNMUpTUEVDUkRRUGlVWU9KbDBLWERZcUxVRHoyNC9QaGlMUmo5K3lkdi9VRW5MVHRFRkRqckxtNWV2ZlJQYktrL0ZNVzFPTTlHNU1CdzFqYUNJQnl4WXdWMm5Ud2JmcUcvMTNzU1FINEFETGZXcmx6NG53aGlMUWlqKzRJbzZhc2dpS3d4Y1ZKdlpOWm9Ua2Y5ZEhkcjdhV3MyL3NxZ0c3MUtoQVJlTEM3L1lVWHZ2NjVjbjc1eUJQWmFCQWJVNDZzMVNIQWhraTRVYjl6T1IybGYrb1BCd29CTGtmZDdtOXYzN3plWnNMREJKTEc2bmxURnFGSnk4dXVOTDhKNER3SVIxMDFacGdPZTdCbGl2Yk1JZzZkT0VlRDNnNFhuWTNGc0ZIN0Nhdk4vMmgxbWVIVmlydzhCZnJydDYxV3JUUytUWllSUkVLSUlKWXFWTVlZY0ZFUXJBQnJ3TURDbEl6UjBHQ1lXWlNwUVo1YmFPdjh5S2tWNEVDQURRTldnbU1KT0FHcmZBdE5TU0FFUXpMZ0hJRWo0ZVZibWFCQjRNeEJydWNvVWdNWlNraXZGZUZwS242Uk0xUW9zTmtyME9tWG1LMkhTRUlKTU1OYWhsUUMvYlRFenFCRXBQemJZcHhER0VpRWlsRGtGb0VVbm01TFFCSkVDRU9GU0RtRVNrS0FvQ1REV0l0Y2d5THQ1dDk5YXY0SDRrQkd2L1BNMm4rOHZwZXVBNUJHNnhjM3JsMjZzRTlHOFZkUWhiUlVmZXhOdEovdVlOYXhjNk9ibDE3NjV3QmFGYzlveks4ZnMrbks2b0NvOG1BZXYxVUVnTGJYcm4xMmUrM2ExK0dYZE9qcWV5ZkpMZFhZRDJjQVNKZkZ5N3ZyTi84eFNUa1BoaUtpQmp0T25MTTVnRDBBMHBUbWFnSzUyVnlZWDg2ekViSlJIM09MeDlGc0xXTHQybm5TV1ZaWEt2cUVVT3B6MXVnYllCWjNJZlB3Rk9odm9IWWJRMGhybVJ4ckpLb09nb1RWakx5d0dBNE5PcnM1MG1FSlcxb1k2OWxzVWdvWUpSREVFa1lRVkdFUmNBRHJKQUptaExRUFcxRGdSOVVjK2FKY1dRSk9Fc0tlQnUwV0lQSzg5VEFRK3kwMVgvVVVXT3ZrNkk0MEZob1I2ckhFbU9XdEJLRzBEcHY5RWxKS1JLRkVWdmpVSkpBQ1JXRzl3QVVCbVhWWXFOZXcxRTRnU1VOS2Y5WUp2d1FHZ2doUnhnZ0lTSlJxZnVqcy9FY1B6MFd0Zi91TlcvL2ltUnZkNjRKSU9PWSs3dHdrTTFtZ3Vsc2JhaElRcWdKeUQzZjhoWGNjQ3Z3YXhhNXF6by9IUkphN2ZTOG1EaFl2cCtWNHhNN2NtT0JKN0cveGtVcTFHczEyczFHZnRVS0dLTk05c0NVMFpoYTRzN05HbmMwTnA0c2NSSmwyenVVVGszemZWNmJlNE1pKzR5WXgxdHBTOHpBcnlnTE10WG9OVERhZ1ljOWhkMnVBalZzOTlIWkhZR05oblFPa2dGSVNLZ3dRUkNIQ1dvQTRDUkVrQ2lxemlDcC9SQ0NmckNzdlVTMGNReHFCZ1AxTXJEUU9kaU9ISFdoRWlmSTY5ZGFCSEVFcVFoaEliUFJHMk9qa1dHMG5xTWNTeEJWYkRnVEhqTTZvUks0ZFpwTFFoK3lXVVk4VlhEV0lLZ1hCTUtNVkJZZ1VnVjBHRnI2bkp5V3FuME5nUVpBaEkzQ2V3aHVBb3JNcmpYZjkzTHVPeVg4bDZKODhkYjF6czVLcUF1NmtpTjZORjM1WHJ2dnRpOFVCajNqM1VkbmJqNmtZQ0hmTTAyTWl1dUFEangvejR0V0JnOFpUR2FSMGM4dkxiMm0wMjU5MmpDVm5MYUtvaG1LVTRxVnZmaEV5VVZDMXFHTzAvbDFUbGk4QWVLbjZlZmtVNkc4Yzd6M2hDOGJoSWV1ZHp0NnR3WERZYmRicnRUVFAwQXdYc1hVOXd3dlBYa1RhUytHczE2VmdCbGdLQ0NraGxJSUtBcWdrUnRLcW9kR3VvOWFvWnFyZ0phTkNBaFFMaUlBaElSQ0FZUTBqbEFMT0dFU2RFcEVTRUVLZzBINFpCWU9SQ0ltOVlZRWIyeG5hU1lnd0VMNklCa0NTci9qbnBVVm5XRUlKaVZKYlpLWFAwWlVRTU1ZaWtnVE5qTmxHakVZc2tSWWxRaVhSaU1VK1RSYU9JU1ZCa29BUkJCRVFGQmhwNFFSSUJLZVdHNDkvK3RGRG5VTGJYM3R4dlorVEQ2ZkhrMjdqU1RpTFZ3K1dUSHJZZzVOa2s3bnVRVytPMTRnSTdwaEhyNGFSN2paWk5qNVFKb0YvUnp1NHNiaDh0TEc0L0NtWVlqVWREaUZsaUxoV3g3RGI1WDVucDR4MEl1ZFhqN1FERlNmOW5lMnZXYTNUdTBRdVBNM1JYNi9OZnlIZ3h2ckt2aGp1aU1neWM3bTV2YjA3U3ZOUnV6bUR5MWRmeHMxYmw3QVVyZUE4WDBacEJsREMzMFBNenJmVmloSmNGSUFRVUZrR3JUWFlPb0FhRUZVaHpsVzNwclZBeUY2TFdSdUNrd1NXRmxGcUVPVVdRU0JncS92R09TQlFBdHBhWE5rWW9SWXF0T3NCSkZXSFZKVzNPMmIwTW8xQ085UWppVkZwRUNxSklKUmc1eEFLcnk3YlNnTE1Od05ZYlQyTFR4QUtCcVR6NUpsUnByRzVsK05XSjhOYUowV2FhempybFcvQUpPNDdQaE9jUHRMNjZJOCtjaWd0alBzbmw3ZEhCY0RFZDNwMU01RnI0eTRlOWxVRjBOY29uM3duQUlrN1VxMXgyK0RWcytNSG4wOFNrUVFRTUtEQUhCVHBVQlI1S3BOUUVRbmlMQjBpNi9XZ3Mzd2dwUHhTc3oxN2Z4Q0VKMGMwT2c0aDNNUmhadTl5Q0wycDdRMUptR2syR3VnUEJyQmVLa2xVTjRFQ1FITXo3ZnJSdzRmZW1hVzlJMS84NGgvZ2ExLzlEQ1ZLNGNIN3o2RldTN0RYR1NJdlMwaEZFOVY3LzE5bkxXeFp3bW9MNHNyYlN3a1d0RDltQ2lJNEIxakxmdWJjTUtMZEFvMXVBU0g5NDhaQmhwUUN0L1l5REVZR2MvVUlvUlQ3ZkhldlZlTzdBdXZkRkVyNmRGY0lRaU1PTU9iMFNpSFFySWRZYUljSUJZTUVvSzFYblEyVVJGbzZQSFZwRDU5L1pSdVhiSWwwSlFZdjF5RldtOUR0RUtOSW9PTWNYcnpScFdkZjJhVWpyZWplMWRtYXZMcVhQalVxYlRuaHpmZkRkeUdJNDFyQVJPUlRoenMyeFlFaHdINzNPOTJOYmZicU9YUzYrMEVncEhSQ1NsZnAyaDJjUFIrSDdPUE51cUVRSXBSS0Jjd2Nnem1zMTVxTmVyUDVpRGJtOEtnLzVIelFJNnMxUktCZW5GdGVIclZuRjA2WFphbUgzZTQvS2RQME9RRFpSRzNDWWtxWWVmMWJVWmFZa0NzYTcxVlhGNjVlM1hyMithZWVIL1UyM25iajZpc3lDQUozN2VvbDJ0N2VvdVhWSTNqOHJXL0R0ZldiMk8xdVl6QWN3Szh3cjRnc3pzRTVCOXNmd0dvRHJUVzBhYU51NjRnU2hnc0YyREtVSkVnQldPSHByUEZPaGpLM0VFcUEyZmZWUTBub2pUUjIreVVhY1FDbHZLQ2tkZXh6YytFcGVUdjlISGxwMFVvVWpIVm9SZ0dTb0NMRE9LQmVEN0U0RzBGVUJXd2xCR1NWWWEvdlp2amF4UjJNVmtNYy81RVRXTGwzQnZXYWdpMFlacXg0UXdSVGFQUjJNbHg5WVU5OS9vczM1TElWUDM2OEZUKzlPeXcvdzh4aEpVMUY0N0pIRUVvRVNuQlpmS2U1anlyNC93dFlrTlJoeWdJZ093Nnp4dDU4c3VnV0VWRVkxMnF0V3JQNUdJUjRxQ3l5UFYzbzhxMVBmT3poK2VYRGozMzlzNytOWXRBWFVhSkFyZGlSREk4bGplYTlaWkVIL2QyZGY1VVBCMThFYzM2WEZJVXhwY0MrZm0wNEdrMUdmNU5lUUEyR2cvTFd6Y3Q1bm5hUE5wcnhiS01XaDFFVWtuV1dlNzBkeE5MUllydU5ZNGVQSVlsanBOa0lqc2NUWmNURVJPd1l1dFRJUmlueVlRNVRXampqSmRTSS9UQ0tjd3hqSEd4aFVldmtTSXdES1FFR1F3cnY5YS92RENGSVlLWVJJWlFFZHJmckM1SUlwV0ZjMmVvREVBaURBR0VnTU5zSUVWU1JSajBKc1RnVFF3bm5KK1NFQjY4U3dEQ3orTnJGWGFTek1jNTkvQ1FPM2RlQ0hsb01OMHZZYXJiVmFnZWpMUVNBNW15QW93L01ZLzdrTEY1NGNWZWxPNm5kTHN5WHFuTEJmbTVlNlhkd29DUVdGeHVZbVVuUTYrVjNDYzcvZlBpb05kc0lvaGdxamhHR0ViUXVFVGZiWU9mSTZuTFNpd2VWRjQ4QkpFU1V6QzJ0bkczT3pmNWtVRXYrbmdqVWV5SEU0NGVPbjM3aTNLTWZPSHZ6NnZsb1ovY1dtcTA1MTkzYXpKeGhZOHN5eXRNVW8zNy9qL1BSOEg5eDFxNVZiY1BpUUtmaCs4YmtHL21YbndENUhkY29OenNhZUZIRlFSWTNva2draW9JNEtwdnRwcEFCS2VZU2drczBhakhtV2cwb3FhQWRySFUwa0ZJWklxR0lmTUJRNWlWR3ZTSFMzaERGcUlRenZuZGZXa1pSR0ppUnhzeElvNmtFaFBJdnB5U0I3WjV2cGJWcUZjaXRMOUNOSjkwS3k5anFaMWp2ak5CSVlpZ2wwSTREMUVPSjB2cURaMkVtUmhJQlJqc1BjZ0NTUER2dm0xYzdLQThsT0gxdTJTdmFTRUl0cnVZdmlSQW5BaklnaEFLd2ZZMUVNamczVUVHQStTTXR0OVBKTDF5N05maDY5VkpPaWpVd003TWZvZ0hGY1lCdU4vc0x2VTlSbzRWODJFY1kxMERTTS83S0lvZk8wdGNDZVFJZ2p1SzRQYmV5K3E1YXEva1BRT0tUdzBHLzN0L1p5VjJobzNOdisxRFM2MndIWC8vU2YrUTg2NU1weXV1bU5IK2tpL3hwVStvTE9pKy9aY3J5MzdEaml4WEE4d01nOTNLKzN5ZnROdmxHL3dPSWlJUVFxT1NOOW9QS0xEYzdXN3VqSjljN282ZjdoYjdZejhzWE1tTTNTcEFlV1ZlT3JORjdvNkhKakFtRFVKRlU2dUt3Vi82Mkx2R3lNVTZCZVZZSUlaVVVMQVhCR2sxRlZtRFVIMkUwS2xEbUJxTmhBUm9VT0M0bDF5TlZDUzRUakdGczlYSUlFb2hEQ1ZWNWFCSzNjL1JoWWJEZVRjRU10Qm9SNnFGRU93bjhWQm96NGtpaUhvL24wZjNFR3Z1T0lKNjUyc0dOT3ZEUUR4NUQzQW9CTUNpU0NHTkNIQk0wSkp3QWhPU3F4ejV1OHdtVVE0UFdjb0xaZTJlenpWdkRWM1kzUnp0VkIyTlNsWVdOY2I2RkpRaldPUmp6WCs0QWd5aXVVaVNRMFpxczFzVFdpZ081K0IwZ2I4L05IMnN2TFAxb1VJdi9yaTZMQjN2ZGprMjcvWXUyS0w3T2pwY0czWjNhOWFzdnNnd0ZBU0xMdXYzZnQ4Yjhjd0JmQnZDbklQb3l3T3NWd0lzcU43L2piN3pOWnBvQy9YVnRRb2o5TnR2dERzMmRXbU9tc051RFR2Yks3dmJ3cGJWYjNXL2YydWgrUFN2TEYzcUQ5UGxoWGo2WFc3dGxDT3VsNWQrOWZtbjM5d2FENGpsbjdhVXdBS1JBazhBTlNSQ0JVcEJLQWN3b2hobnlRWXA4a0NMS0RlNmJhWkFLQkROQVNoSkdoVUZ2V0NBSS9LQktLQWxDZXE2OXNReHRHYVcyMk9sbmlFS0ZaaHhpdGg0aVZBTEdPa1JLb0ZWVFBoOFpVMHpBTUJhNGVIT0E1L0lVRC8vd1BaaGRUZ0JGaUpzU1VRaVVoaXFhR2tNeitibDNFREpOZ0NLSVVLRFdFa1NscGFRV0xqWWJVZVBXcmVHemcyNCtYczE2Uis1cWpPT2lNQkJTSUs0RitNNDUrNEZRdmRFRVFIRFdiNlIweHBBeEpUbGpCRHU3cnlHQTI2cXVNWWhxQU9LNFBUdS9jdkxVejBraC9rNmVqNWFWVW5EYTlvczAvUzNIZHM4NSsraW8zNDJkTllnYkRRckNhS0JOK1JsWDZtZXI5ejJ2Q20vNUFVOStXMTNHTi9mNCt3WG9iMmpDekxFalI1SGxHVGEzdGtCRWpwbk5CTmd0QUUxRUlUT1BUL0ZjWjZhemRyVnpjVng4Q2tPVnRPZHFyZDN0NGNCNWNRSlZGUGkyWTdyVWFNcTN4eEY5Q0JLUFdXZm4yRnBJQ0NnUTJCZ29TUzdUNXRaYUwxTW5vOFpxSUFSSzY5Qk5Td1JTb0JVcmhFUXcxdGVuSFhzaWpHUEdxUERES3ZVNFJCUUloRlhWUFFvbGFyR2ZScE5WaktLTmczUEF4azZLcDdaN09QbXBFMWc4VkljdXJSZW5jSVI2eElnRGhtVUNCWXlBdmFDRmtBdzNzaEFrZ05Bdms3QzVJNWVXd1gxbjU5NzM4Ujg2ZGVQZi9hL1AvZk4wVUZyeTdmcmJZQ2V3WTNic2F4aC9aa1FvSmF2b3hZZi9wc2p1Nk1GWEEwZ0hKYWhqQWhvTXNJcHJ4MlVjdnh1dWJOUnFEVWNRbElzc0J2Z2tBQ3VrVkVFWUlXazFJVlNBTWkrSUxSdjRBUnBYZmN3UFZOanRIY1UzcW5xZzB4ejk5VzhQUDNnT1NrcnE5YnF3emgxY3dEZ3AvWHhRRm5uY08zYld1aXdkRm52c0JRYkxLc3l6enZJb3oreEZhK1Z6UWFBMkJKR1dRdVlPNkpHU1E2blV6VEJKdnI0M05MKzd2dEc3MEU3QzR3dnRwRFhJTmUvMENtckhBWnFoZ3JZT3BmT2lrTGwyTU1ZdldOdnVaeUFoTU5PSTBhNkhpS3B4MlNSVW5qN0xERUVFNDFEbHRBNVAzdGhEOE9nQ3pqNnhDbWZkZnIyNHRBS0tnSHJJS0psUU9vRlFWU2tvQUFoQ0dCR2tBalQ3bndrQ3ExaUVqVnAweEpYWXZuUng3NVZxcStzQlJWWGlzVkNsL1RPRTcwcEpMMEJuSFRscmlkbmRMVVQzRlhXaXVDcTYxUURVUGRpcGxqU1N0OFp4L0I3QjNDNnpBbnRibStqdjdaQ3o5cm9LMUxQTnVibmpyYm41dVNDS3FVenpJdXYxdjJ6eTRyY0IzcGp3NXBQaHVuMVZqLy83U2hyeURlN1JyYlY0OW9YbmVhYVJFS0JSR09HcU5VUzMxelBkMlpjbDNFbS9uTmdYeHZuZGVyaFpXbDdPMHZKNmU3YjJoVnFpVmtoU0pKU0tqZU5SZHlQZDdPNk1zaTJnbGx6ZUZ2VlkvVnhoN1B6ZUlPZmxaa3lEMHFMUVhyL2RnVEhJREFMaGRkelRVcU5kcjZFV1NzUkt3RGdQYkwveHhiZlNoUEFTMEVvU250L29JejljeDRPUEg0YXp2dnJ2MHhldlA1Y2JJQ3I5UEszVy9nK0lxbVdQdFJDUUVWZXJvUUNPRllJNmsyRG1aRll0UHZqVzVaL2FYQi9kZU9icHRXOFJVT09KRUo3QmJBeXMwWVlBOE1vOXM5aTQzSG5WZTlHZW00UFJCbVUrZ25OTXpwV1QyMXdPTGw4SUFjaHFZOHk0alJhVHdPclM0V1B2ait2MUQ1c3NYOHhHSXd6N0hlUW1KUkZKSFhEUWJTOHNuSzdWRzdQYVdNcEh3MjdXNi95Qnp2TGZBUEJ5QmU3SlhybkdKUG1IeE8xMndmZlpxdWszdEVlL2Nlc201bHBOUkdvRUVoS0ZBV0t2ME1MV09pYWk4ZVdJeUZacjBDemR2Z3pvRG04LytmK1RsV2hiNUxvekhCVFhCLzNpV204dnU5THZaTGZ5VkErcmZ5Lzd1Ym5ockxPOVlYRktTWkhNTjJJdUxaT3QyRy9HQWRwWVAzT3VEWEp0TWR0STBJb0RPUFppR0hFZ2ZJVys4dVlrQ0kyYXdvMnRJVjZ5R3NjL2VBeXR1UWpRREs0cTh3U2d0RlYrTHZ4V0dTYXZnS1BBaUpXbjVzaHFGdDlWU1kzSkxJS0lLSWdKS2xCenNRcWJXK3VqbC9xRGZGRFJDdmJCUG40ZEZ3NjNTQVlTdzA2R2o5OC9qOWtrd01hZ1FLQUVvcVFHNnh5VlpVbk91b004OWYyV0dmazhQSkJLMWR1enN3L0ZqZVpaQ013SktZODkvTTRQZjZvOXYvUVRlenRiSjN2ZFBUM3NkYWplYk1xd1VXTVZoZ2pyOVVXbHduTmxYclNIbmQxMW5hYi9VdWY1LzhaK2kyNXhJRnlmYktFeHdxUVM2M2ZmY1Eva0ZPaXZVOHVLRW5Fa3FwbHZZUGxRQzBaYjZOSmlicWtCSVlqSEYzc0ZDdWNaR3Y0amdlNEk1WEgzalNjSGh6N0duK3ZxeHJMV2NiRTdMSzZXMmdhSFordG5adXRSYUN0aENHUGRmcTllQ3NJd0t3RWl6TlFpUHpCRGhGb2swVXlVSDVsVkFrRW9rTlFVdXYwY1QrOE1NZmY0Q3Bidm1ZRXhEcTVrQ0h1N1ZlZVhTOER2WkJqM0hZUXY1SWx4RzhMNW01c3FJUTA5OUZSYVZaTkVTc2c0RGxhaUlEQXZQTGY1d2tUUmFyOHdSMFJzallQUkRtVnU4UGl4TmpxWm9iVitRVklRWlhsQlZoczR2N2xDSEFqVDkvdmlBRlN0M2xoZE9uemtyelhtNS85dUdNY2ZEcVBvM1NmdWUrdDdUNTU5MjJNN0d6ZGJONjZjM3kzTFVTYWxTR0JadU5LU3lRdHBpN0paWmlsTW5uMmxURWYvUDZ2MWYzS01EZHdlalMwUHZGZkFiZHFqQnpnSjdCTWFwa0IvWTFsYU1JclNFMXJpSklBdVBOQlhqOHg0N3lnRkdzMklzNUZtNS9qZ2xOWEVZcjg3cDYvMkl3RzhhdmhqOHRybmh4dkhSYTdkMmtJaldweXRoNmVVbEZRWUMrZll6NzFYbU90bkpacTFFTFVvUUdrZG9sQml2aDBpaWdTVUZGQ0tJQU1CcXgyZVhldkIzamVEb3c4dUlCQWUwTll3QXVsWE5vLzNHWUg5WWtmdENLVUZRZ0lrVjhNN1RERFd6N0pIcXVvcUJRcW1iMUNtRHJJaE9hekpzTmFLbHFKR3ZINzV4ZTNyRS9XTy9YRlRXNEVjQUwyME9hSmVicEFiUjQ2Wm5IT0NtY1ZFTlQyc1FCNkRLQUVRS2lucU13dXpqODZ1SFA3bEtFbCtWT3Z5NUxEZm01dGJQcnAwN20wZldsaS85a3IweXJOZkhVVkpXTExncGlsMVhPYkZlWjBYZjJLMXZteUs4bm0yK2oreE0vL2FXWHpETVhvSFFQNmRXVy8reGNEM284azMyeDgwR2hZb1MxOThiN1lURklXR05WN3NzY3pOWkJ2dURwdWJTMUFVbGpGZTNyaFA4U1EzR2Y0VGthVlg3enZiMy81aEdhTkJZZlpxU3Q1VEMrU0tuMFpsc3BYdUd3SG81d1VXMjNVb1A1aURtWVpDc3g3NDA4VjUyYWxJRWk3YzdHRmpJY2JxMjFjUnhncnNLdFZhNmQyeU5rQm1DTWI1aUVhSWFrc01BNGxrS09IRkxhMzFMRHhMQW9FQUZERXNCR0FBR2xsUUpNZ1NjYTBaTnBOMjFPenNGaGQyMWdhN0UzV08vWWswSW1JaGlBQ0l3cnlxMERZWnBvOTc0Z21Jb2xxamZtVDU2UEdmbkZ1WS84VkF5YmVQMHFMVjJkd2NzZVA4N0NQdmlkaGFQUFhsLzRRb2RLcVdSRWsrS29UVzVsbXcrM1YyN3ZjQWZCSEE1d24wTFd0NW5XLzN4dysyejhZTXYrL0hDUDM3QitpVDF1dWt5RVlsaXR3Z3ovUnJnaHdBaXNKNldFc2ZFc2RKaUNRT09BZ2tHMk1ydFRpNEE3TEJkMXZzSnpOdGQvdHB1VjRMeEwzTk9Gd2NxK0JFU3ZyOURzWmh2aG1EbVJFcWdVWVM3Tk5pamZVYlZyZDJVcHkzRmd0UEhFWnpKZ1pyQnliaHd3NExGTGxET2Q2OURuOEFFRzduN1pHczFrWEI4K2JMMGg4MFNxS1NuZ0xTMUVFWGpLZ21VVm9pRlRCYXMrRkt2UjNoL0RPNzUzV3VzMnBQOU9SRUc2b0J2bGVSWFloZUZhYlhpS2crdDdUOGprTkhqLytESklrL1VWcDNxTCs3Uzd0Ykd5L2thZm9makM3TjN0YXRrOWN2UG84eTdXTitma2JBY1hjMHpQNjlLY3AvQ2VZWDRIWHJCZ0NHZkx1aVByNE9kbE5ZakdtTlUvditBUHFmeC9ZbG15dFdiYU1WSXdna2drQWl5M1NWMytPMUx0eVJEd0lpMVhaem1KWGRkaHljYVNUaGpKUUNVU0JKRzErRmp3TWZ0dGVUQUxWSStsMFJ4a0ZLQVowYlBMTTloSHhrR1lzblp5Q2M4LzJncW9KWUZnNWFNMWhVa09XcUpjeStwU1lxWlluU0FvVWpTQWtFVmJJdWhKZWNRc1grSFBZc1JDVEJrcUFMUjBFZ1pMMFJyaVR0ZU8zQ005dlhuT1dEZitja1hUVUFFQXBDVEVUakFaU0VQTWpyQUtMbS9PempzMHZMLzRoSnZWVnJuZlE2dTdiYjJmdHltZVgvZ1JqV3NmMkJQQjAyeWp6bFpyT09ack5CeHRxcldaYjllcG1YNXl1UG5lSk9Bc3hrVmQwQnNIUzdjRmpKN292dmVMQlBnVDRGUE5neFFxK1hEbWNaZWZIcWtELzBkenk1VjYvajVlckFrQ050YjJscjlhR1oybjIxU05WRnBSWVpTTG4vNEdiTk0rSmNsVDRxS2ZES1JnKzdxeldzUExRRWVFNE1oUFFDRTM2cEk0RFNRWkwzNE01NUdXcFpkY0d0OVh4M1VWWGZrd0JvMVJrb0hVekJJQ2xRYW9Fd0lnUk5CVWdCb1NvUlRNc2MxNEthRE5WeW1ya3JHOWQ2T3hOSDJiNk8vbjRWSFVnWWlKWmJVZjNzYW5NeENXWGN6MDNJdmpjKzAxeWErMXRTQm04cjhsVGxSWVlpejBtWGhYYVdYd1N6STZKelVaTE16QzBzME14TWl3RlFOaHF0WlduMmVhM3RyUXJnWTZCUDlzWk5WV0swNU9tc1RKNmZ2OCtGZGxPZ1Q0SCtuN01pMDhoU2pldzFRbjVWM1dtNFV5Qmgwck1URVVTL3NEZU5jY0ZzTFR3VktabFlNSlhHeXpWSGdVUXRWcjc5Wm9Fd0VOamFHK0ZscXpILzZDcWF6UkRsVUVNWERoZ3IwemdmTTd1aGdja01aT1EzeGhqTnZudGt2VmN2cmQ4akY0V0VKQVNTa0RIb09BejNMR1FpSVFKL1FBZ0J5TkJMVUpNa0JBcEU3TGc1bXl5S1FOS3RxLzJYUnQyOFBBRHlhQnllaDBva0R4MXV6ZjNVMnc5OTZFZmV1dklyNTQ2MXpoV09COXY5c25Ra0RzZjE1Rk5FWWtsclM5bGdRTmxnQUZ1V0laaXZCR0Y0c2JVd056ZTd0SHdxcnJlcHlBdWI5anU3bytIb2Q3SzAvQUlEL1FsUFhod290dTJuRTFJSXJ0Y1QxR3MxenZQQ2o5OU5RVDRGK2wvV0MyZnZSUGpkNUpDSUdXNHZLeSt6ZGMzRlZuSnZhVzB3OXVxMVdLQVdLVmkvRndwRllmRGNWaC91M25rc0hXMkRMZnZsajlyQk9vSzFmZ2tGbHhabFp1QkFFS0ZFSUFsVWhlcnNxbVVUN0RlemhwV0NMYlBmMGlwRFFoQVJZSDF4cnRxajZ0VnZLNzFLR0VhZ1dEUWIwUkVpMnIzNjh0NE5veDFOZVBJSVFMTFVpdHFmZkdUNTNFODhmdWh2bnozYyt1djFXdkRBaVNPMUIwK3MxTTV1RGJteFo2UDNrZ29mS3ZNaVNQczk2RHhqWWdjQ3JRVlI5TzNXd3NLNzYrMlo5d0VpSEEwRzZhamYvVVkrR3YzVG9qQy9aeDN2SEFDNWdROVVQTUI5M2NNTFdBaENHQVJRU2lMTjh1bk5PUVg2WDU2TlFSNTVvSk43TmRnbmNsclMyNlB5V2dSM0pGUjBQQWtEb2FTZ1ZpM3dvbytHNFJ6ajJ1NFFOK3NLeXcrdVFFcmg4MjBsZk9WUE8zQnFRSUVFVzRhVkFvZ1V3cUFDTlJPSUNGVUU3aGw0Zm5BRFN2b0NuUlNBalB6V0dCQ2hMTDFTRHBjTTNiRmdDMFIxZ2lRaU9IQ3RKcUo2TFRveUdKaHJhOWQ2blhGZTNvcFYvWUZEcmNXLzl2amhEMzdpclV1L2ZIZ2hlVGRMcXFtRXFMQ09MdS9hK1JlMjNWczJoKzZlZkpnR3hhQ1BSck5KTS9NdE5Pb2g2czJhYWN6TUhvc2F6WGM3NDhKME1OanE5L1orSngrTmZzMXErM1hIUER6Z3hmZUxiVUdnUUlKNDBtTXpNNHBTVDBIK0hVeE5YNEsvbU5HcnZmajREREFZYTZVekN3ZmNmSHF0OS85NXlOcG1MUWpmb1lRUVVucVJaaUVJblY2T2kzbUp4b09IRVFRU1ZsdFlFaUJpaUVEQVdRdTJEb1YyQ0VNQkdmZ25WWlhLVFc0cVVRemhpZHhqVmNXc3E4RVp3VFU4OHpjTzJQZmpKY0NWakhUUWxMQ1pnMHN0cU9tbjNBeUR5c0x4MG5KOC9PSEhWMzlrYTMyNEYzVnljMlMrMWp5ejFEaDdjckYyOXNoUzdkekFxcFdMdHh6YmtrbWdwRTZ3ak05ZDBmenR5emRsYUZNNlBoTzQ2OW94QUJtQVNGc2dqT0lsR2FpbFVacVhhVHA2SWUzMWZ0c1ovVWR3dk1QK2RUdFlkTnNQMDdVMkhBUUtkaHFhVDRIK3ZiVDhUdER6QVJubDhTbEFCRFJ6eXhkZjJocjk0eVNLL285bkRyVWVjd3htNXpXZnJ2UXltSlVXV3ZNTldHMGhGTUZXdWJ3enZ1SkVkVStYZFFWREJaN3lhcXdYa0l6QU1OWHVkV2Q5anE0RXdRNE5zcFRCSW9LVWZvTXNSUUplUWN1VGNod0RZVXZDREMxc3daQUtrTVJnUldRWk9ITzY5WTcyRTBkTWJidUlXclhneEdvN1huSWt3bWMzZ0tlNmdxOTBMTmt5UmEzZXhLbUhIZ2JpRzlRaWpibVpFSEdpaEhQZ3ZlM3RyTDhudDVoZFNVU0pVb0ZocFo1M2x2K3RLZkluY1p0bGVOQ1RPL0x5ZXZ1Nk5scWI2WTAzRGQzLzZremNkdkozeTllWkNLcDB2TGVYRnJjVzZ0RjlNL1ZvVVFuQlc5MFVGMHROTS9jdklZclY3UjlTVGRXUHhTaWQ4MTBBNHdETFhwcks3MkFEakdFdit3d0NHUWVkR1UraWlhV1hwUkdlY2VjWXNLWHpHbmFLUUVyNFFoejV3ME1xZ2dSRGNQWDNiQmRvcmhYcWxGRDN6TmZDWTNFZ1d6ZUdMUC80dXVHdmJFcmM2T1MwczNrTGtBRk92L1g5S0xNVXozejFEd0RPVUFRUkxxLzEwUktnMVZaMGFia2VmTmxhOTZWUlliNXBqUG1pMWZyM25TNHZWNkNlbkRwN2xWcXJHSThlVFcrektkQmZKMkg4d1FvOERvSmRPOTRaWkdhN0hzcGprUkpMbHpvcHN1VUdXcXR0R29OWENQaGtHeDdRMW5ycXE2azQ4OHplTzQrckFTR2htblgzekRpVFdyOXNJaEJRb2Fpb3NuN0hHNWVNTUJMN1lIY011TnpISFNMMkJIbFZPTWdyS2VoQ2lyaGpLR0pHeWVBbk53Mit0RVo0ZnRmUmNOaW5ZTGlOUTJLSXFMV0VwRG1QRjcvMU9YUjZXK0Frd2JDZjQ4eU13RSsvZlJVLzhkYVYvTVAzejgrLzVkaE1zdDRydnJrMUtGNGlQemRlSENpNmxSTWdaeEppdk5LSnAwQ2ZBdjExWVl3LzAzcE9CNENHcFZrZnBPWE5vakNybTlvY2JwNWVwcVFXTURrbXFucmczcXZUYlJVSUJneDgwVTJDSWNFVlRjMExScUxTakJmU0wzWnc4QkdBVWw3aFJzQnZmSkdCbjR3VGt4eFJTV0JKTUVTZ0hRMTVJUVhkS2lCTFJoUVFOakxHbHphWVBuL0QwZWFncEhMVXgrRmdnQis2SjhIeDJScWV2TDZEaXhmT1k5RGRSTkp1SWF5MThkQlNnbDk0MXlJK2RQODhGdXRoYTZFVkxxMjI0MU5ubHBQR2krdkRsM2RIdWt2MEtxNTZWVjBuSjZRRVNRa1JSTXhHVDBFK0Jmb2I2aXpZL3pnb3pNWkdON3RFa3NKNEpwNlBtM0U5a01JUlBMcXBFcW53d25HM0JWRjhFUTRRRERqdC85Mk9kZWZCWGhOZStnT0J5TFBoL0hWYmlNSlZpWVlnM3dNc3RlL1JSN3NsNGtzcGVLUHc0aGNBTHZVWWYzaUQ4ZFNtZ1hFRWt3MXdicUhBcnp5eGhIT0gydmlqbDNidzdTczdNRVdHcU5iQXpNSWlncUNCRDU2czQ5MG5hbkFPR0l3Y3JIRXNBWEYwTGo3Y2ppUDdoUXQ3VHp2bWxEekk3eVRDRUVFbzVSbHV6b0dkbmQ0OVU2Qy9JY0w1dTFGbnlRSzdPdGN2MmRKdVVpQVB4Vkd3b1B4SUxUbnRrUzJVQjZ5cGZvcW9SbTVFRmNJN0FoeFRSWU90UW4veXhUcXBCQmllQml2SVQyc3kwVDRGVmhDQmlhQXpoM2lqUU9OR0JqblFDQUpDcUFRWURwKzlDYnpTbDJDblFYRFF1c0RScHNRSFRzMmdrUVRvYVlNTFd5bHNWTWZ5NGFNd0ZDRkJoZzhkRGJFUUNhU21tcFMxSUhiRXpDeGpHUnhLcE9vK2RhdjNBdDJwQmJBL095Q3FvUitueSttTk5BWDZHd2JvQjczNjVNUmJPdXpsMS9KUnNTc0lKMnZOZUY3RklUc0NrUlFRa3ZhM1Evc2MzT2ZwcU1KenR2N2NZSGgyRzBCd3hvR3JmV3o3eStSRlZTZXNRbndpd0ZqQWFxQzVXMkIrV3lNeUZ1Uko2QWlJVUZpTEw2MXJGQlFoa0FMOVRnZUR2VjFzN1k2dzBnenh0cE1OOUozQ2pTeEJFZFpSR2tZNTdPQnRxNFQzbjI0aENRaDU2V0JOTmFRdVFJS0luRVlTUUlhZnU3enplZU00SFU4RTBnUnZuWjBEMjZrbm53TDlEUUowQVJ3Y3BacGNRdWlxaDNFK0xHK2x3MkliU3B4S212RmNHRXBINHZhUzlURVhUR0Jja1BOTU9HYnZxU0VJUW5yZzI5SlY2NVI4SlowQXo1Z1JCTEJmdGVRS0MyMkJlTGZBM0VhRzJEbS9ZODc1V1hiSndFdGRpZk05aGRJQm5hMHQ5SGEyVVdZcFZtY2tmdWlSSmJ5d0ovRHZ6dWU0T1pMSXNoSmgwY0VuN3EvaHZhZG0wVW9Vb3BnQURTaExxQ2xDbmpxa21tRXRVNjVadjdLVGZXdG5WR3o0RlU4VjBIMVhqK1greXF5cFRZSCtCdkxxRTZ0QkQ0YncrOEF2TTcyVzl2Tk5abmRQclJIUGg1RmlkcFZDNDM1Rm5pb1JDNjRVWkR6b1JWV1lRNldZeEJWTGpnTGhTVGVPNGF3ZmtDRUFwV0hJbnNic3JSSEVvSVJoaHpBUVdLb0poSXJ3OVIyQkwyNHByTzhOc0xOeEUxazJnQlVHRkFSWVdad0YxWnI0cmZNRjF2dEFmMjhQcDlvV1AvdXVCWHpzNFRtUThKNjhIbm5CaTJib1Q3dGh6c2lNZ3dna2hCVFlIaFRYejI4Tm5xNldjWlR3bTZuOWFzZ3AwS2RBZjZNQm5WOE5kTHdHMkZublppM3RaZGNjOFdyU1NKWmxJS2xhbzBiRURPSDR0cTRjQ0t6OXdrZFp5VkNSSUZqcndFeFFTa0FxSC83TDZuZFFrcUJMUnRuVG1OMUkwZWlYSUFZV213R096d2dNTlBBNzF4UStjeE80c2I2Tm9ydU9NaDBnYWMyaU9iK0FPS2xEMWhad2FkZGd1OU5EV0F6d3ZxTUJmdXpjUEI1WWFhQmRWNURPVDczTUpvUWtFaWlkaEhhQUJTTzN3T1pJOC9XdHZuanBldmZXOVVIeHRlcnYvNzdjaXpZRitwdkVHTGVsWjVtQWFxa3E4OTBCNzZtZXBkMGM5ZktYaXFLc3hmWG9jQlFIWG9MR01wbVJobVh2bVZHUmFFaFVubHI2MXR4K0VVOVdKQmp5TFRZbENZYUJQRFZvMzByUjZKUjRmcy9pbVQyTnE5MENMM2NkbnNScFBMY1g0ZGJWaTBDNmpibFppYlF3U0ljNVhLbVI5VWNZOW5vWTd1NWdOWEg0NlVmbThLT1BMQ01KRkJSN2ZUeVJNMXBDQUpZUVNNYkFTUWgyR0E0TXNnSjQ2dkl1ZnUrcFczWnRXTHhjT0h6RGVZQWYxSHpqcFdhTVVUbGx3djFGYlVxQi9SNlpuVUI5R0lDbElCcmw3S0Y3ZDdCelBpeGZXYnV3Kzk4WHcrTEs4Yk9yUDdVdzMxaVNnWVRMRFpGMllPMFFLQUVvZ2hzTFF3clBkQlBLdDlSWUVMVDFHMTZKZ0xKMHlFdUg5bEREN0dUNDAwMkg1M3VNUW1zNEJnNGZQNFBEd1ZGMHR2NFVYT3docXNkWTYrY29Db3U2a25qa1VJaDZJcEZJd2t6Y3dybVZGdDU2dUFVRGh6QVcyTzZXMk52SUVCQlFsQlpaWVpHRUNsSXF0T3NTUW5oeHhrZVB6S0VkQmZUaTVxRCs5VnVkK2w2cVV5TElxcU5YbFJTbVdsQlRqLzVHUFZrRjBLNzV2TFV3ZHpoOTRFNXBLZ2VBblhFdUhSUXY5WGFIdHlCd05JckNXVENUYjdFeHNXVllJZUNNZzgwc1NIbHdULzVrZ21mQk9nZWtPYVBzbE5oOHJvc3ZYa2x4YVFnVVdZWkJaeGVIRHAzQzJZZmZpVXZQZndNWG52OEdiQ0NnbllMTGNweDVvSVZQZmVJRUhqdzBoM3RuRzdoM3FZbHpoMXRZYmtVK1lyR0Fja0JFQXJPMUFJbFNlT1hhRUZuaHNOSk8wQmJTRTNzSVNITi8yQnlaUytSOUs2MzZYcTR2WGQ0ZFhhamtuMHBVbGZkUVNZNlZuSHIwS2REZmVPWVlDR1VsQm0vd1dsUzZTYkE3QUNnemM2UFhIYjJZRDdPWlVNckZlQ1lKS1pCay9Tb1gzN2RTMVRMSGlrVlhGZEhCZnVRYzFqR3l6T0RxY3dPY3YyR3dOOUlvaHdPMDZ5bm1XZzRxV2tTWmExeDQvaHZRMElBS0VVRGpZeis0Z3IvenkyZncwR096YUo2dVlSQklYTi9NY09INkNEZTdKVGFIR29WanFFQWlDZ1ZDQW1BZHNoSkl3Z0J6dFFDQjlGTFhvOXdoeXl5eTBtR1lHb3dLYTNjeS9jcjVyY0VMbUFqZkNYQ0JGQzRLRkViRkZPaFRvTDhCTGRjVnlBR1E4a1cyaWJMVFpKLzlOdUFKY0NYdkRMcjVrNzFCbG90UXJxZ2dhTUt4Y0VUTTQwVm44T1FaYTl6dGs4TDZyKzF1RlhqbDZUNXUzTWlSRnlWYzJjUGJIeFA0Ky8vd0pLSlk0VE8vOXdLdVh6d1BvM01relNZWUVUNzR3VVg4N0M4Y1E2c2VvY3dadFpaQWF6N0M3TEU2WkMxQWQ2L0EzbTZCemFIR2RtWlFzTy9YRS9sYWdMYU1aaURBRHNoemg2ejBlK1RJZ2FRVVlFSEIwTGpPMDJ2ZGJ3SVkwbmhuSG1DbEZCd3J3Vk9QUGdYNkc5NUlUTUI3M0RON2RjNCtIbnNsQm9vaU5jOTN0Z2VYeTdKc2srTlpJb3BKQ0M5Z1o1d1hrNmpZczdxd3NJYlIyeXZ3eXBOOTdHMlgwR1dPVWIrREp4NFA4WC85djUzQzRhTVJmdXMzMW5EK2hWNkZRSVd3Vm9kMUFoLzZ3QnpPUGxnSFNRZGJldEVLSVJreUlEU1dZNkFaSWUwYklIY1lhWXRidXpuV3VpVTZxZkhLdEFhb0tRRWhCYkxDWVpCYTVNeWU1U2NaUVNEbDBOanRiOTdZK3dLQVhrVUE5RUFYd3RVaXhjT3BSNThDL1kwZnk5LzI0VEwwcERXKzA3dFBodkJWTlpySWFyZlcyMHVmSHZaSG1URjJqcVJzS0NVVnJGZXJZVlFTVWM3Qk9jYlZsd2ZZWGM5Z1djTllDM2FNcFFYQ1d4OXRZV2JHZTl3clZ3eUdXWWk0WFFjNFFLaUE5N3kzaFpNbkVvakFWL0RaRXF3ZDV3TU9zaEVoQzBOc3JxVW9lZ1ZBUUs0Tk5vY0Z0a2NhN1B3MjJLRzE2T1lHUldrUjFOUitMMThwUVpteEc5KyswZmxUNjdoVFNVVnBBb3dVd2lXaG5BSjlDdlEzbDRueFFEdmRFY0lmTE5MWktwUVhZRXJMekw3WTJ4dGRLcklDeHJvMkV4b2tKUkVSd3prU2tsQ1VCcHMzUzhBSnNEVXd4c0tXQmRhdmQ3RzhHdU5kNzUyRDVRQVhyd1RZN1NhQWN3Z294M3VlaVBISlQ4OWlmbEdCckdmbVdVMndoVDlJakNOa0JVRUVDanNqaTh1WGR1R3lFa1k3YUdPaHJVTS9MM0d6TzhMMXZTSFdPa1BzNUNVR1JxTmZhS1NGSnBJQ1Z0RFdVemQ3bnl1TjNhMkFYaEpncEJTdUZrb2U1Rk9nLzRXTHdOT1g0UFZqVmdOQ0FUSUFXdzBDZzltOWFuV1UvNXpoQUs0QmtNN2dxWjJiZzdYZVh2cjg3SExqZzYyNXhybjJYTDNkYk5lUWNBQ2RXd2hub1ZRTVU1Wkl1MTJVYVlwanh4S2NPZFBDVjc2YzRkZC92WS9ubmlsUVpCa1c1ZzErK0ZQemVQKzdGekViUjdDbFF5Z0FoQUtPR0JZRXJYM2VEODFnelppZHIwRXVOWER0eFEwc1JoS2hGQWlWZ0JFQ3hscVUxbnBsVnV1d21SZStoOGFNOWlCQkhJV3FIb3A0a0hzQlYxVEZCZ0l3SG15WjJ0U2p2Nm1NSFR4ZnZmcFlNV3Z1eGhJYnIzSVQ4TXFzN0RSdmpMckY1VUYvTkV5SGVaeVBzcGJSVHVYREVNVUk2UGU3eVBvRGFKMkRBb21aK1JaWTFQQjd2OVBIODgvbHlJWXBqaDNKOGJPL3VJb2YvckZEU0lJQWd4NUFpb0RBcjU1MUlPalNYd1RBREJpamtVT2VPV1FGNDlMVkRrYjlGRkZBRlVuSXo4OEtJZUNZSVlsQTFaWUpFb0l0ZzdMU2JtOFBpODhPQzd0UjFTTEtjWTRlQjRxSHVaN2VHRk9QL3VZelUxU25NQUVxVkRDRlg5VDRtbms3d1lMMzJXUmJldVQrZUc4MHZKd1B6UStYV2ZLSVZFV2dDNFArOWphWUhkckxpNEFnREhLQjMvcnRiYkFURUM3SFc5OFM0bWQrL2lUZTlzNDJiTW5Ra2hFMlBmdHVOQkl3N04zc21FTnZHVUJBa05KTFVZZEtJSzZIMk53ZStKVlFOUU9xUm1HaklBUTc1N1h2cElCMVhDblRpaUlyelN1N3czSjlvbW94M3MyT3drekQ5aW5RMytRV3h3M2tSVGJweWllOStIZzFrZ1RETnRydGhVWjc5dDNNYUdScHZ5aUtJanA4OGx3dGltdTBlZU1pZXAxdEdHRUF4eGp1OXYweVIydGhyVUd6RWVFOTc1dkgzL2lad3poemZ4MnNMYXdGT0Nmd0VOQ21VbTJzZE51Y0lqZ0JXRWZnaUNCckJCRUpSRW1BOWt5Q05TSjBVb01BQm1CQVNlbEZMY0lRUWtyL001eGhkbzVLb3QydGZ2NFY3YmcvUHVjbURqTjJVN2I3Rk9qZkY2RzhaYkJqd3F1M2xvNFhLYWpHVFB2ZXhkVWpmeU91TlQrWUZhbHcwcG1aNVNOcWJ2bElhL3ZtWlRVYzdDR29oYkNhSVBJQzczcDNEYWZPTmxBVUZxRWtKRkdJeDkrK2hPTW5FamloL1pTY0lJUVJnek9nekFsRkFXVE9hOUFqQkZqQ1YvV3JLVnBGZ0pRQ1NTMkVWQUtHTFpTVVhvL2VPUlRHUUFZQnBIT0FjMzRJaDhnT3MvTGx0WDc1Rk83Y083Ky9MTkhaS2RLblFIK1RXNTVseEh3SHlNZDd4Mk1BaVZRcW5sMWFmbnRqWnVadnF5aDVaSlFPNjNzN0cwanFMU3l0bnNCZ2R4UHIxeTVBSkNGczZaQ0E4YW1mT1lxLzhiZVBZWEU1aG5HdVlyRXhqQ2JZMGt2QkNNR3dsaUJpZ0JNQ1Z6bTEwZ3lyQ0tVUjBNWXJ6MWJyNUpEVS9LWllKUVhDVUlGS1JoaUZrQ0hmWmdCWkM2ZDl2aDJHSVRubVhyOXdYODRNYjVJbkRZNlhKanFHVjVCaU1RWDZGT2h2WmlPQ2MyNjhRNHh3ZTROcFZJRzhOcmU4OU1IbTNQeXZCQ281blJlWjJsbS9PY3o2dlRSVThVeHZkelBZWGI5R1VSS0N3Z2hKTThkUC9zeEovTUNQcnFEZEZvQ3prQ0NZb3ZyaDBrSUVCR084bnB3andCckNNQlBJSGNHR0JCWUFhY0JvTDFwcERhTTBEbkNFSUpHWVdZeVFYQXVnbEFBS0QzQ1NBZ0lFSmZ4bVdpVUZna0RCR0l0T2I3aTVtN21uL1ZGengrUWFBMEJwTGFKZ1duV2ZBdjNOSHJaN2tFL200eUdBS0FqQzJ0eks2a2ZyTSsxZkJZa1RSVDRTbmEyTnJhemYveU4yWE90dGIzNThzTGNkRWdIdGxRVm9tK0FEUDdDTUgvbnBlYjk2V1R1RTBzRTVEK3d5SXhBa0pCaWFDTGFTb0MxeVFsWVNCb1hYblFQOE1raG5BV2NjaUFqbHlBL1N5SkF3dXhCaGZya0dwUlFLeHpEYUlJd0NSSUVDUUFoRGhYbzlnYk9XMDFHZXA2VjdxcHViR3hXNEp6WGovQXBrQUlOcHhYMEs5RGVEelN3c3dCZ0RWWTJiOTdhM0R4YmVKcjE1cklJZ21sMWUrWGhqYnZaWGxReVBGVVV1T2p1Yk40ZmR6bSt5YzVjQmZNSWFuVmdEQ0NXaFpBREhNWXFjVU9aK2ZGVXBnaVQySzVZMW9TeXEwajBMNUZyNEhyZGtaQ01nR3dCT0FHVnVZVEtHRVFRVkNUak5vQUNvTndTczhkdGQ0cHJFNFpOTnRHWWpkTHY5L2J5ZENGQktvbDZQRVFTQ080TVJaWG14czV1N3p6bm1BVjY5NjN5NmNHa0s5RGRiaE83NzBkYTNrY1ppTkY3ZXRSS0UyUS9aaVdUVWFKeVpXVno2ZVdaM2REam93Vm1MUnFzdGRGRlMydThCd0FEQVVJVmhjMlpwaFdxTldRdzNleWhHSmJSZVFEMWtCTkw1d1JkTEtFdUJ0RG9FbEFCRUNHaEwwQmxobUFPcDlwUlhhZnlhcDZ3RVdqRWdRcDlWTjJjRWhQUGlqMVl5anQxVHh3TnZYY1N6bTEwSUlSQ0hJVWdRcEJBb3N4SndDbVdoeTdTd1QzVnord3B1VDZ4cFZGTnJTaEtIU25CYVRJVWhwMEIvazVpekZzNDV5a2NqT0MvY0xvaUltSG15eWg1V1YyQzFPYTZJanh0bUlrR2lWbXZBV3JkQ1V2dzFnSDZMQ0YrSzZ6WFJYbHo2V0dObXJwbU5Nb1RjeFlPbmppSm1RTEtEZElEV0FpeUFvTVpJbUNBVUl5MEVwQ2V2K1UyckpjR1VRSlk3U0FFa0ZVZGRLaUNPQ0lJWWxnbTFtbDhPb2JXREZSSnZmL2NxUnRmMk1MbzFCSVJBV1JTd3hnSU1EZ0pGUmFuM2Rrdis0OXk0SGZJYWNYZElTRFZDaVVZb01ab0NmUXIwTjdwRnRScUtORVZ2YjYrYVUvVmhlZ1h5c2J6YmVCOTVES0JHektFcGN6c2E5VzFTYXlKSzZqQkZqdTIxV3lMdGRSMkI4bHFyTmJ0NDZNaUpxRlpQZW5zOVNObkRELy8xVmJ6OS9TdklMY0dWQUxHRllZSFNFR3pwaTI3bEVCaGxCSVEreXNnTklTc1o1Y2g0d2NsSW9IQkFQZkw3MW5YSkNDUWphUUFxQUtSbENBRVlaN0Z5T01ISmMwdDQ1dFlBUlY1VytRZEJoUXBnRkNOTFg5cEp6YmQ4OG9BY0UwQVhSQ2d0TTJHcUxqTUYraHZja2xvTmxnZ3FDR0MwSmpBVEh5VEIzQVo1QkNBQlVHTWdsbElWMXRoZEp0RXEwcEhyYks2TExCMDRHUWJiVVpLRTh5c3Jud2pqNUMyandValZhaU44L01jTzQzMGZXWUZLSEN6OHRwZk1DRGdXR1BVRjhzeERUQWFNSkdDVW1wQ21YcTIxMUF3amdEZ2d4RTFSVmVmWlUzT0ZYL1FZQ0lZZ2hnaUFnQmphTUdRZ2NNKzVSVng5Y2dPRFczMUVZUUJqREFPQUJWMWRHNVMvVVZvZTRQYXV0ZHRBRjhSZzRIcHZ1dXQ4Q3ZRM05NaGpaR21LcEZaREpSWkJkd0Y0TUpHYng5VVZCa0U0czdCNjZKMVJ2ZGthRGdibzcyeVRFQTZ0eFRseUpPK1A0K1JrV0t1M3MxSHFTUGJ6RC96SWtmQXQ3MXdVdHJBUWdVTVVWMTdYZXE1Nm5nTnBUbjVIdXZLL2hUVitvYU1RaENRQ2tBUisrYUprUklvUkJKV3VmRWdnd1RBZ3NDTW93YkRhSHdDU0RZNmVxT0hZZ3d0NGNXTUFXTWRTQ0doak9wdVoremQ3cWJsUWhldVRtMU9kbjlwanh0U2JUNEgrWmlpK3hVa01yVFVacmU5R2hna3JVTmVUZW4zQldsTmpkZzJyQzdGODlOUzdXZ3R6bis3dWJjL3RiYTZSMFNYYXpTYWlJS1MwMURVdWRLMjN2YzJqZnYrbCt4K2Q3eDg2TVh1T0hMY0VNWXhHdGN5aEFycUc3NHRYNEhZbG9TaDlidTRxRVF5aWFzMnlZYThzcXp6Z3JmQlZlMVh0ZXlOaVFESjA0UWR4WkFBbzZiQjZhZzZYdnI0R1NpMExJV3duMDcrL05pei95RHJXT0xBaW1mekNCbTZFQ3AxczJsS2JBdjBOYkVKSkVET3NNV1MwT2NoWkgrZmlZUmhGamFValJ6K2l3dkFISEhOa2RWRlR4SGIxNUgzSDgzdzQyOXZkQVNRZ2c5RHU3ZXp1QkVybEFMUzF6am5tUGVmY0h3SUxzMWJiTTFKSkdQWURMQkV6T0NXdzloSldwaVE0elNoSzhpSDd5Q0hMSFpRazFPb1N0WVNSaFA2M0N3SkdRb3dnWWJBaU9FY2d4N0MyV2lRaEFWbjNFamdzQ0RabnpCOXVZbWFsaWM3RmpzaWNlM0p0b0grcjBHNTBBT1N1Q3RtZGxHTGFWcHNDL2MxaFdhbmhqQVZ1OThqVkJNaGpJcEhNclJ4NmI5eG8vZ29KT3F2TEVrSW1XRnc2Z2pDcDRlb3J6eUtJQWtnSzNhalR1Y2FNM3lwS3ZURUJuQkdBUFdmNC9RTE03SUJDQTFFQ0dFMFk3UkZDd1JCMUlNdUFZZ2lVRmhpbEZrWHU0QmlJUWtLcnpwaHRPelJiRG1GWTVmRmdSTEVET2FBd0FnVUpId1ZvdjgxVktPeHZnM0ZneEEyRnhkTUx1UFh5M3RXMVFmR3ZlN201Q1UrS0dmK3UrMHk0U0JKYXNhU05RVG5GK2hUb2IyeGp2N0xoSUJGbWNrQWxYRDYwOUVpcjNmd0ZTSGxtMk85eGQzdUxvMXFEVm84K2dKMjE2MVJrUGN6TXRiaXp2YmVwMC94L0IvQVpJZ3lZOS9QY2dCbGhrZXNCRzVTNjlLdlBCWUZjNGVsbUhCTUtCK1JXb0VDbHY5NHRRWVhEN09FSVMwY0pDek1XelpxRlVveFFBbXk4RGwwUSs0VVJNbUlrNUpBclFyOHZNU29sV0RCY0pUVmxIUkFHak1XakRhMWJ5V2UzMWtmUHV3TTk4NG5jbkltQUdsa1dnaVpIY3FjMkJmb2JMVzRIV0RoL2UrOS81UTcrdXBxWm16L1ptSm4vMlNnTUgwdlRWQTcyZGw5TysvMXJaWlkvZXZYODB3dWpYZ2UxdXVKSUVqY2I4VjYvSTc3aW5Fc3JrSmU0UGQ1cHMySFpMUXN1SEFDbEFLMEpNbUNvR2xBYWdoTUVHUUJrQ0tJa05FS0JSZ1NzSG5KWU91S1F4QmFSOHIrdkZFQlljMzdZaGZ4UVM2NEp4SXhheU9BYVVHYUV3dmdhZ05oZjQreDRicldPOXJGMmhvdDdKVGwyUHNiWW4zUFpyN3FWSUZ6UDkyVzA5bGZaQU1DSkUzTVFRcUJlRHdBQXp6MjNQcjJmcGtCL0hadmQxM2lsQTBCWDdmbjVRNHVycXorZDFHcnZLL05DOVhaMkxxYTkzbStDdVdiSzRpM3JWeTh3RVpHUUxWSUxzMVNyMDN5OU1WZ1k5RWMzY0x0TnhWVjBvUGEyaGx1anpJMEtRNUFCZ1oxL1dsMENKbU1nSWlqcDIyWHRHVUp6VG1HK2JiRjB5Q0tNSElRQUF1RUE1YU1BWXdtc0swRkg0ZGVwYU9jWFVRZ0Z6TTRZZFBzU21aRnc4RjhyTkZoR0ttak9KcXR4TFZTalFUNTV3TzNYSjVoQnVyUThxYVpUZ1p3QlQ1ODlmTGlOWGkrbEgvL3h0L0w1ODFzQUFLMm5oSm9wMEY5SEZpVUpkRkhBWjhEN04vaVkzcXFDT0o2Sm02MGZRUkQ5U0tGTjNPOTJzbHlYR3pJTUJqYTNwOEZvQWlBWnlEeE80Z0FnS1lTb0N5RldBWHloS21oVnVqVEVBTHQwVUF6VGtkWnA1aVZlcFBLUE1ycVNwOGtCSTMxNFBkdHltRzB3WnVjY2dvRGhESUZVNWIwTFFqcVNnQVNLQVlFdEVNOHdST0RadW80RnRQYlYrR2FEWWJzT3cwSjR2WG9CYUFzMFdzbnhlak5hR0EzeUFXNTNGbXgxNE5seG5zNE1Kb0x6bktIYjA2M1hyKy9oOHVVZGJyY1QvUGYvL1dmSXI1YXlIQVFTN1ZhRW5kMTBlcE5OZ2Y1WForMjVlYVRENGUwUTFiM0tteXNBVWhBZEkrQUhITGc5N0hWeTYxdytzN1R5UURyc0xmYTJ0OC9iMG54ZFNIVmZjMzZ4bWJUblZXa2REenE5alN6TFg2N3kzWEhldTUvL1cyT0xiRkJtUmVhZ0FnbGgyQU85WkRpL254eEpYYUE5NnpBL2E5R3NXMFNCUDRwSSt0WmE0UVJHUnFEWEY0aHJ2aDJYalFqRkNJZ1RCam0zdnhIR01VRXBScVBPRU1KQlcwQUxTWllaY1QwNEdzVnFHY0FhRVZtdmlBZGloc0x0UGpvRGNNeHc3UDM1L3ZJS3JaMER3SjFPeW41dEUrL0grRVRFUklTNXVRU3RWb3dyVi9hbU45NFU2Tjg3bTExYWhxc0dWY284cDRtNThzbEJsUkJBcExXZXliTnNwZFp1STZrM2cyQW1sSG1XQmZsZzFIVEdQZ25nczYyRmhVKzE1eGJlNHhoaXQ5UGJHK3gyZjdNczlIbmN1WVdVS3UyWGdKbXpmcmZzRkxtenFpNEZ0RitkVW80Y1lCbENFWktZTWJmZzBHbzVKSUh6YTUyckZhKzVFZWp0Q1RoSmlHWjhEWkZDUmhUNjNubWhDWEIrbnhveiszM3NsZ0RCa0JGQldrWldPZ3BrZ0RpSlpsUWcyMFFJQWJiTWNBQ2tYOVpBNDZLY3FmTDNzWWNmajZzNlpoNGZCUGIySWNET2FNdTdlK2w0RUFqTTRDaFNjSTZuWWYwQm02ckFmcGNzcVRlUXBTTXlaWWtKbFpoSmtNY1lVMXNkSjFLSWU1djErb2xHczBYV3N1enNiR0xZN2R3RTQzT3pTMHRMTTRzTEh4UlN0WXMwMWQzdHJmKzF6UFAvRGNBUXZpZGRUb1RDNDU2OG1GMXAzcnQwcVBWQUVLbFFHMFpaTUxuQ1FUdEdHQWdjUHNSWVdMU1F4SEJEd1BhcWFsNVFUYlpsWWovZnRvWlE1SVRocnUraFF4Q0trcENYaE1LSWFock9GLzEwS1dDWlFBSllUaGJ4NEtIRDRoMFAxZzh0eklXSjF1U2lTTmFjaFdSR0NXWUdRUUVjVlVYSmlJaENvanNZZ25MaUVoTUhKb0ZCSkFoRllUQWNsaUFpY3M0ZldFTFFkTjUxQ3ZUdm52bWlraU5UYWpockowRit4NURLeENWQldKRmg5RWhjYjFKdmI0ZXp3UjYxMnJHWW5Xdk9ObVptM3hIRnJVTkZucm05emZVL0tkUDBmd0t3Qno4UU1razhnZmVVRkFHd2pYWnlaUFhZN0dOaEtPcHdnQzBjV2NOZ1p0UnJoTlhWS2dSbkFwY0Vad2xHQ1pEMEREY1JBRTRRbkFWMEpWQlJkSDNnellwZ05XQU1JZE9lUVNjQU9DdVE5aG5wZ01FRzZBOUdlT2FidDFDUDVOeEhQL2lXQjQ4ZmE3OTdwa1h2ZXN2REsyK0prK0JvR0FVbjJxMTRPUWdrQ1NGSVNpRUFLR1kvclFjZ0lFTG9vNEZYZ1o0QUNLNWFsczRCeHZqTk5FUkVRaER1T2RIR2tVTk5iTzlrMDlCOWFuK0pucnpkUk40Ym9Nank4Y2JpZ3p6MjZNQVZFbEhZbmwvVU13dExXWkZsdFZHdng0MUduUnYxcUFHSVI0VXpLRVpkOUhZN3o1UnArdjlsNXEwSzRNV0JISmNtUWw2YkRjcmhjS2hOWEZjVUttS1grOEdXSkpHbzF3VUFScEZLSUhDUURjK1VJd2R3V2UyRVk5OHEwK3dGSUdWRWFLMHdsSFF3anBBWFhsVENNc0hQNWpoUXpoQ0NJRUxBT0lMV2pBNFg5SWYvNWlMdVdiMWV1NzYrVjF1NzJWOWNYcTdmKzhBRGkwLzgrQ2Z2ZFRmWGg2TXJON0sxWGovdkRZZGwxdTNsVHcwSHhjVlNtMkdhbGp0cHFuZXRkV1hsN1MzQW1ubGZyTUw0c0I4VzRIRmYzakl6U3lsZ2pFTnZVT3o3OVdZakFoSFFIeFJUb0UvdEwrTE92VTZhcys1ZzRTMEVFQWtoazZSUm55ZWlRdzV1MWhnOUsyUXczNXhmZWt4SWxlemR1b0ZSdjh2RlVKckJIc0U1dGd4bTUzalRXdmZQckxVdlZnQWYwMGpIT1M2cTV4b0RYZlE3YVcvUXliTmFJNFNSSUpFWlVDUWhXd0hDd1BQYXBXVllBNFFMQk1zRXdRenJ2QmZuNnVoZ1J6QTVnK0hGSVlrRXBHQ0VDYU1zZ1FpTVhCTTBDRUUxK0VJa1BFL2VNYzQ4dElEdXlOQWYvYnNYa0E0TGJ0UmpOT3F4ZU4vYmxvTUg3NXNSU1lRa1VNSDhJSzJ6Tm82SG1YbGZyMS9vMGJETUJ2M3N5dmJPOEl1alZGOHpwYnMyR2hYclJXbkxBMFhJZzZBWEFLeld6dDI0TldBbC9hbEZsYzVscjE5Z1pibUJqYzNoRk9oVCt5OHpkZ3loRkRsYkh1eVZSd0JGelptWkkzTXJLMy9ic1gyOE5FVTl6N082Q21xeTNtekhlMXRyMU92dU1JT3ZsbVg1Wk9HTFVQMHFGejhQNEt2d0ZOZkprSDBTNkpWSFp3TWdISFpHNjcxT3R0NmVUKzRSa1NRSUlna2dqQW11WUxpVXZkSnJ6dEJEZ21mZmV5SU53N2ZTbUFBekFsd1hvSkRCTFFJMHdCbGdJb0lWQURsNC9Ua1FSQVFJWXBCakNDSUVkUWtGaHdjZVhjTEZsM2F3YzZsRHYvZzMzNE5QZnV4KzZuZXZZbmV2ZzRVWndjT2h4Q2h6RkFhQ1dqS0l3MEFrVWFpYVVhZ1c2ODM0YlhsaDhueFVucy9TOGd0RzI2LzJoK1YyYjVBUGk5eWtBRFFSYVdZdUp3cVRocGtOUUs3VWxvbmdBSUxXRG1FZ1dZanZyd201S2REL2trMW54YmphZmxBaEpwWktKSEdqL29rZ2pINmkwSG05ekF0eUJwaGRYb0hWSlhkM04wQUNHb3h2T2VaL1c0RjhVRjFqVXN6a0RQY2RxcW00M2FLeUFNZzZiS2FEL0VZMjBKb0tGOHBJSUFrbG90QjdPRWNBUndRVmtPZWhPaytvb1JJSUJNTXh3VERCR045YVU3S3FrV2NNOUIxS0EzQ05VQ1lDbVNVNEFrd3BFQWxHUUF4bVFsNHd5cDVGRkNnODhiRjc4ZFFmWGNGSDMvOEFsaFptQWJlSk5OK0RzVVJ4TEtpZUNHampJQzBBSzJBaWliS1VsQnNyaEJUMUlGYVBOWnZSdVdZdC9MUjI3dVhoc0h4cVoyZjRyWnMzdTlmVHpLVFY2eko1NmFwaWI1bmhpT0R5d2pnaENJVlhyMkVBbUp1cllXbWhqdk92YkUrTGNWUDdjM2oxT3l2czQrS2JpbXUxKzFRUy8xZkc2c05aT3JLOXJaMitMVXJFU1YyVmVZYXlIRkRZcURPSXJ0bFNQd2RHdndKek9SR3U3M3VzQ1pEZjNxNWVQVzlWa0VPdEVUN1liQ2NQRXhBeWlCcnRBQ3ZMQWVJYVFVYUVJR0tJQkRBZ0dKL2graGExQTR3UnNLNDZQWWpBMG05b01ZTGdER0FLQmhSUUJoSjVWWkJqQnpqamY0NHhRR0VKWkJnRVJ0S0tjZjE2SDhnTXpqMHdnK0h3Qm9ZampkSkl2NUxaQWFPUlExazZrQ0JZQjdMV2tXTVFnOEhNYkxSVEtwQXpxNnV0VTNPenlic1dseG9QemMzWG9rWTlMSHE5UExlV0oyY0lKTzRVMlJ4SFBjaXkyMXprUmozRWJEdkI1dFp3Q3ZTcC9WbFJ6cE5UYWZ0VmRoSWlxYlhiZjEwbzlSRmpkRERzZEMvb0xQOGphMjA3SGZRWDBrRVhRa2lLRzIzQjRLWno3cUxUNW1VQWFYWGxFOTdjSGdENVJJV2d1c21wYWsyeG01MWJhTDRkUkMwaEpWWU94WmliVlNEQlVBRVFSWjU4WWl5QlFYQ3U2aHBJMzFvYkwyamdhc0Vpd1ZmaU9SUkFRcURrOW1FQUlpam5JQXdqaklFd0FLUUN3cHJYbFhOTTZJNFl6My9qSmo3NDdrY1JoZzBVK1I3U1RQc3BPT3QzdUduRHZvb3YvRjQzNmR0a3hNeEVSRERhSXBBUzdabFFKRW13TkQ5WGUvdkNiSHpmNmxJanFpV3EyTnBPeDNSZ1diWHBicmZqUEZGbkgvaEVSQ1NBc3JRMEdwV29KUXJhdUduby9ucXlYM3JuVWFTbHhjV2RES0VTc015ZU9PMFRzakdOQWwrNjJ2a3JLTW5kUVk3aHVGRi9RSWJxSTh3dUtkTjg0SXJ5VDV2TmVqZkw4a1FYT1FNWWdLZ0lqWjFYWVh3b1ROekRlcFI5YnNLTDM2SEdNZ0h5eVFHUk1hUE1ndjBPczNSUVhDb0szWmRLSElwckN2V0dncWdHUnZiTGhmQmE3ZGI2ZHBrZ2dwUytaK0Ewd01SK0JNNk9uNGloSkJEVkhKUml5R3BlSGZBaUZoQ0VJR1FJWm1nbm9EVWdHR2lsQXRZbWVHWkV1SER6T2g1NzZDSFljZ2RFUFpUYkJ0WU1FSVlDamJwQ1VUcElSVEJHb2xhVHNJNWhyWU9Tam5SaGtaY2FraVE2dlpMaklGS3RXdnhJNjFoNDV1amgxbk1QM0xmMHB4ZXY3SDN6dVJlM2J1YTU2Vlh2d1dSSWJ5WmZ5OUdvZEtOUnlWSVNFWWpiclJqT01RYkROMDlsL2czbDBVOHYxc0VNSklGRUhFaDgrZC85ZFh6bVR5NmhtMW9rZ1lRU2hFZ1NRa1VJcElBZ1Fxd0VkbE9OUnFSUWp5VFMwbjZ2UUQ3MjZBR0F1TFd3OEZOQ3FRODRhMVhXNzMrOTFhaGZQWFI0K2NjSWREekxjODNncjRhMTVKYUs0bnNJSUZ1V3orc3Mrd3FBM21UT09WRjRlNjFWeXZzY2VnQ0J0VXpOZHZUT3FCNGRiYzhsNHRnOWRZU0I5OUFpSUlTUlB4cksxSk5rSE1QbjVOYUg4TVo0ZWlzSmdKelB2ZXNKTUQ5ck1EZGowVXdjR3JGRExXYkVFU05PZ0ZyQ0NQY1BBS0NlT01ReG85NWdIRHNpOFBDamRkUm1CaEJKSHl4TE5PckxVREpHcjd1SHZBQmtRR2cxSkpRaWxKcWhsSTgwQkFTWUNZNGRpc0pnTUN6eDdQT2JkUE5HSDUxZWdVNDNDN1cyUjRKQVByeTBXRDl6N29IRjFXWXoxRGR1RFViVmExVUpadDN4ZXFFS1JnQVFoQ1FLQStrRk1vczN6eWJYMTdWSC84R1BmQXpQdi9RaWJ0eTZDU0pDUFpUb0N1R3J1b0p3OGdmK09TSWxhRzlrSU1YdFJIV01nbEQ0b3BNU3hJS0ErSHUzM21lU0pBTUE4OEx5WXpOejdhVFQ3MWdHcnRUYmMyZkNXdjNlcEpaMUNQaDZHTWN2SmEzbSswZ0tXYWJwelhJNCtocUFEdTZ5ZlBBdUFNZmg0elBZM1JxaHlMV3JLS2JqeDJhZG5lRzM1NWJhajlScXNpa0VrV08vQTBsWTMvL1dCYUNIaktEcGdWazZncTRBemc0SVlrYTl6b2lGUlF4RzBuWlFZZFYrWTBZNkZCZ01KWVJnek0xYnlKQ1JHai9KSmdVamx2NXNJdWQvc1ZwVFFaSkZxcStER2dISWFxaFFZWkVDMktzT3ZWMkxOSE13bHBFVlBtZVhnaEFHQW1uRmUzR09rUmVFUnFPR0xNdEl4UVJIRGs4L3Y4RkY2VnJIRHJmZmVmTEV6R05uenl3OWNlcWUrYzk5K2V2WFAzZmg0dDRWZURudGdKbkg3VW5oaTNhd3pPeU1jWnhsZWh5Kzh4VG9mNG4ydmlmZUF5RUVoQkM0Y2ZNbUxseStDQUM0NS9nSlhMaDBzVXA5bVY3YUhKSjE0emxHVURYV0tPNnFKVmc5akFoTUFDa3BlQy9WQU1DSFptSThmR3dHZ1JMNG5TZlgva0svKy9ISFA0aTh0NGZOODg4Y0ROa25xKzdSc051TlptZG5xRjZ2eWFMZGVFeEdjVFBOU3QzdkRyNXByZnNQelZienZXRVVuek82ekYxWmZrNFh4ZGNtUExoOUxZQ1A3Y2c5czhoencwWGg1UnJaRDU4eE00cFJ2M2lad0Zsckptd0NucXZ1Z0dwUklxQnNsZHdUSUNXZ1FpLzZLQVJRcXp2VTJ3N05ta01vbk4rTExvQk1TNi8rU296TVNhUzVRQkk3TUJFSzUzdnlnWFJnQUlaRnBXWHRLL0hEbkNCSlFaQ3MxaWwySVdKZzVyaENPQ3V3dHk2d2RrV2p2MkhCRnJEYXB4RlJGZGFYMnFES3E3R3lYTVA5cDVjeE45dEV0NnV4c3RDZ25iMmM4OExpd3JXT21wOUpIbTdXdzN1ZmVQellJNmZ1V2Z6Y043NTE0MHU3ZStsMUFQWHEvUm1EM1FBdzFySzExanEra3p2N2hnZjhYMm5vL3JNLzhkTTRkdVFJR28wR3ROWVVSUkVOaGtQYTN0MGhBUFRjU3krSTNxQlBZQllFQ090WVZHbTRoSjlqbnVSQ3EvMkxJVUdlRisyTE9DQzdyM2dJdEJKRmgyWnJGRWlCODJ2OXY5RGZNSHYwWHBnaW85SE9CdDBsZEk3Z0thNXNqSW5Lb25pcmxDS080OXBDVXFzM2JaRlNOeDBNRzdOekM3Vlc2d2tsMWJ3cGlvdWpidTlmT212UDQ3YnMwcmpLL3BwZ1AzeHlCb05PUnFOQk9TN0lqVWs2Z1hQY09IeWkvYTU3NzU5ZmlHc1NVZ2x5OER4d0tZRlErckZURHFwaUhBTlJ3R2cwR1VtVEVTVlY2OUFKUUFER3lXbzVHaUUzQXBvRTRucjFPUExBRGlRamxBNlMvTSt6VE5Bc1lOaFB4VW55SzVkTDl0TFRTdmczTGdpQnhpeGhabGtpYmxYU001cXdNQk5BU0VLV08yU1pnZEVPMXJGWHg4azFBaUVRcWdDMUpNU3h3eTJhbjZ0VExRbVJaaHJyRzRPdzF5K09MeTdVSGpoMmVPWlV2UjZadFkzK0xtNHZ5cm1qV0ljN1pXanBRRW8yQmZxZng0U1ErTWtmK1RUV056Ym9Eejd6eDlUcjlYRDU2bVhhM2RzakVpU1VWTkk2SzQweGtwa2xUd0w1ZHU0YlRGUzJRNXFRU3ViYkF4RGpGb3NQN1lsZ0hLTXpLdEZMTmM2dXRuRmlvWUZydTZQL3NoZXdWa014N0ZNeDZIazYyS3Zsb2NaODl1MnlMSnM2TDQrMzV4YWlNQXBsa1E4RmxGcUk0L29aNTNoT2wwVlJadGtmWm9QaDc4S1RaRjRsdS9UYUhuMEcyeHNqS2dzelhnQ2g0T20xaVhPTTQyZm16OTU3ZHVHa0RJVndKSWdCNk5JM0NTZ2dSTUxoMENoSE16TndpVURRSWlSMVA1OHU2YllJc3lOQzZRaEU0MG84SUlsUjdWR3NlbnRjamE4U1NpUEJEaENWRHJ3Z0lCUytmZWFxYVZNU3ZyM251S3IrRXlHS3ZSakd6TExFL0NFdk9iMjlyajNQbmdCamZlbmNPc2JhK2hCN2V5TWNQZHlBbEFwbFlaRUVBdlVrb0lYWkdzMjBZbVM1d2M3ZXFON3RGZmVzSEdvKytPaGJWbWFlZjNIckpSL0s3MGRnZENBcW93T0ZUcnhSd2Y1ZEQ5MlhHeUZxZ1VRb0JhUVEyTzZQc0ZjNGtCRDR2L3cvL3UvVWJqWlJsQVh0N3BYakpRYVQ2NGdtdDVZSVg4K0ZJRS93OGg0YkVOWGpVVTFZVnQxZ0VIbk53akV2V3NDenBXeGVPcGNXdWVzRW1wYWJDV3J0K0w4NE5CdjgvOG43cnlCYnN5dS9FL3R0ODVuajBsOWJkY3NYeXNJVVhBTm9oMFkzeVNhYkZObWttcFJFRHMxd0tERVVtaGx4WXZTZzBOdm9RYzhLUFVpaEdNVklNNHhRY0lhaXFLRTRiQTQ1WkhlekhSc05vQUFVQ2tCNWQyM2V0TWQ4YnUrOTlMRDJ5Y3k2cU9hd0tiU2hWQkVaMTFUZXpKUG4yMmF0Ly9xYmV6ZEpYWi9CNkFzeFNzWVVpQlFYUHJVQi9tNDVHclhqdXZpRm9XdnF3LzBqRTFNc1YyWko2QWRFMHZzaytlK0EvUXZJOEgvdkpnZXdDbExJQTZXbUdHVzFyZ3J2N2pwblF3amlCd1NiUkNPVWpLWHk4R1M3NG9YN0M0NW1KYTg4WEJDbXV2bWQwMHBvYmVNV2t0VnlQT2ttdHlqd2xvSWk5TlluZFpjSkNrKzB3V0F3VEYzRUdyV2w4Z2o5MlVGZ2NDNXpkNDM2UHNkazhIa0dWbzBkMDZtNjREQWE4ZTZySGMzN2lYRWQxVkUzSlNhVGtwTmx5ODA3Snp6LzFHVU8rOFFRRW5YbEVHTVkxUk4yZG1xT1R6dTVmN0NpNzRaSDc4MmJQdzY4RFB6TGRZV1lEOFpPUkM2eUR0Y2ZQTUJaK0xlcXBQODkyK2pHYUF6UDJqcHA3UStVM3hrVHdvQnp6aHdjSFJvUk1mRjhrMXdVZ1RpVS9PR056a1M5Q0ZiT1BmNHRZSjB4cm5ER2p3dFhYZDJvUnNhWStOYkI2bjRiWWd1bU5FaVhiL2dlR0pLeXBSaGlTdCs3YzhvTDNwcC8wNGZXbjV4Y0JOL2NXY1VoVXZpeTNLcnIrckZ5UFBwVUlyN1l0YXV3YzJubnNwTm9UNDhQOWxmejVjdEpVbW5nbmlnNTV0dkF0L2d3ai90ZkNjS3QvNnZxZ25wU21LUDdLOVp6WXBWc1NocFB5OG4xaHpjdUNlS0hRYzhEQ1lrd0NFa1N6N1Fybmw4dHFVSmlaOUh6MVB0TDdqdzFnZzJEVGZwdEkxWkZLam1zUWJMTHBUWDZyRk13TE84YnVzcFNiZW56eWVuTFlHQkk2em05MEdIcHMrZGNTb2FRRExWTHFwakxnMjRKaHJDZXoxdW9TdUdwWjB1MkwzdSs5M1hMMjk5VzB3dXhoaGdUTVNaZWUyZU9kU1hYOW1ZNjJ6ZHFpb0VUNnRwenBYSm1hMnNrODlOT2J0NDh2ZnJTSjY3OGpTUnNucDcyNzYxVy9jbjl3OVVIS1lremhsTGtMQ3FxdjlERHB3ZWVoWEhPU0l6eS94OGIvWC8ybFJ1Y05JRi8vcDBEN3A3MkYzb2JZWC9WWTFiR3lGbEpaSXh6QlFZeE1jYjFiWHdHWGhsalBNaDVVb25nTFJocmNkWVlKcVV2OXliRjFrWmRYSExXanJZbmZ2cXh5NVByVnpmcUs1YzNxb2ZHdGI5U1ZkYThlVy94RzMvdnQyLy80MWR2ejkrYWQ4R2piaVlmS3J1U3dOR3FUMi9jbS9QdzlwZ1BqbjZYbGtSbHFjcVFIeHh0RmNZWWYvV3h4LytVOSs0dnhSVDJtbTQ1OG5VcFZWV1pFSHEzYXBzRFFmNEY4SllJYytBNG8rd0x6dlBDTHlyVC9wWC9uUjQxOUczSUhCQzRRQXFKZTVjbVY3YTJ4ODkwYlN6d0ZpU3BLMHlDbDFZcnZwRG1sSVVRQzRNTHdpTjNWK3owQXplZkhkSHNPRklFVDZMd0JnbFphODc1VGQ4TXV1R0tIVU5NTU84MC9hWDBBcUxnWEQ4WUJmdXNuQmsvUnJHSTBWZ25ZMVY3NWhBU2hpQ2l0ME1tOGZSR05lK3pUY2NuZjN6S1pLL2d0ZCthSTNjYXdxZ2d4c1NpN1hqMWpRTUs2OWpjR0hIYUprYUZKUVdoQzVHeXRMakNtdkdzNG9uSHQvMmx2Y25IWFdFZjh0YTJNYVhsN2J1TGYvSzFsMi85TndlSHExc2hwTklZdXJ6aFA4U2h2ekRpQkdCVWU1bE5LKzdkWC83LzNrYmZtWmFJUUVqQzdlT2V3dW5ZNXV3aTErZGtqTVlPNVg1SHJDQm1DT2tpTXYwaFF3WUI3ekRPV1ZPT0Nsdk82bUw2NU83NHlzNjQySjFXeGZWck8vV1RqKzZNSDU5Vy9vb3YzR2hVbXJJc3pDZ0pMaVo4THpoZkd2TzVwN1kvOXZTVjZVLzl4dXRIZisrLyt2ck5mL2p1L2VZd25iUFcxa2kreENUY09XN2s4cXhtVW50WnRyK0wyYW1pV1RxQVh0L29Xcks3OGQ2VmgyeFJmQ21FN3FsbXVXQnhjb3B6VnJhcUVZa2swZHNueXMzeHY1UGE0VDhibXY1ZlBEQXJIeDY0UWY1N3FWb3hmaWhVM0Y1c2V4NTZkT3NSWjgzT01HQWtKdkFXSThLenNlT240NExLSllMbzVpUXo0V2IzQjI2OG5IanZ4UW1uT3dYR0tGdXRzRXFFQ2NrUzB0cnRWZnZyaUtFSkJ0TUpaU25FdkJCRVlCQ2RmeFkyUVRLVVhyQmVneHJYbEZzbDhXaExFRVg1OTRnbzk5M0RnQ0hrbi9HUjUwWlVtd1d2L01vUmk5Y0N4aGtLN3pnOFdQSDJ1MGQ4NnNVS2l5WEVsSHMrUTk4bGl0SlExNWJrQzV3MXRodlNwYUswV09QbHFmSDJJM3M3NHg5NzlmdjdmK2Q3ciszL3lxb1o1a0FwSXF2MUdPNUNENTlnSFlBTEtZbGN2enJsMHQ2WWI3NXk3OTkrTU82di9mUXpoTkR6N3YyR2NlVm8rOGc3KzQxNS9lNlNSUitOdGNibW51Y01EUmZkd0tWd1ppWlFjVzRTdUE0UkhJM3JldnowMWExTHoxOFpQZjNDdFkxbi8raXpsMy9xNTE2NDhwZS8rTlR1TDd6MHlOWWYvL2lOelo5ODVOTDRFOTdaUjZyUzdWYWwzYWhLTXlrOFJSTGp1NFJOU1l3Vm9YVDRxclM3bHpicWx5N05Sck9EWmYvMi9YbmZYdWl0emtvd1FXVFZCN3l6dnp2NjR4cHgrdkJOWGdGMlkzdnI4M1ZkL3VrdzlEdUw0Nk5GdDJnTzRoQ0wrZW5jbjU3TXBaNXMrbzN0blcxanpkVythNzh2U2Q3UEc3MTlvR3dYbytYeDczaXJUNjV0TVM0dGgvdExPL1RSUGdBRzFpOTkvdUVmMjd3OCtWeXd0b3dZTXdnOG5YcitlRmh3aFVnd3FrTTNKajhkbzkrMFhrVDhYRmhkOVFSdldRVkh4R0FSWXRLNlBXSE9Tdm9VTkk2NWk0YVl0TlMzNk0zdXJINTlqOTdlT0xCT1Q1WTRHTFdoMHNoMWxja0s5RkZkWmxNMHhLUkdGOVlxZ3BlU29acDVScGRxbXRQSTZqaVFvaEJUNVBiK2tyM2RFWnV6aW1GSVZMVWxoVVJNRUNKNGEvQmVkNzgxRUVQQ09XTjhZWDNoM2VXOTNmSG5yMXlaWFJlUis4dGxmeEtqRkJjNEVmWUJvbzBrRWRvMk1CNFZwcTQ4aFhjOGZIM3pENVZwNWU5cW8vL0ZuM3lHVVdtNWRURG5ZTkZqclRITkVFMU1ZcFBpT3k0bGNSZVE4Y3JvUjczK0ZmMm9PTGRTV24vVW4zN2k2aVAvN2hjZi9acy85K3pXMy96TVk5dC84dkhMa3k5dGpvdEhmZUcyclRlVEFFVVh4U1V4V0cvTnFBS2pmR2hqTFdaVVdiTlJHVk41WTFJU013UllkS204dkZVL3Z6c3J5M3Z6N252M0Y5MmExM2p4cGhScmpIaG56ZVZad2J6OVhiSG4xaHY5NGhSZ3VyR3o4N09GOXovWjlXM1pMRmIvWEREL3lGZjFNekdFVVJqQzIwUFhqU2ViVzRVWTlveTMwMTdwcnZPUHVOSFhmSUFmK085Lzh1WEw3RzBVM0VtZWUyOGZNblRCSU9MejJMRUM2ckowVzUvKzRxTS9YODNxWjNwd2c4QVQwdk5uMG9vYkpoSkVaYVpyZE1SSUZya09pc2lYODhRd3RzeDNTMEpROEN3YWd4aExGQzNqTzFHSnF0Z3NiUVVLTDlEbEU3Q0N5Z3NtWmM5M293QmNYTS9YMFY1OWZmeW1wTm5ySnYvWlpvUmUxdVVpNm42alpCN1B6dldhYmltYzN1K1FtRmcyQVNSeDQ5cU1HS0RyTlVVMlJzRVhGbXZBNTlQVE82c2VjeUhodlRYV1lKeTM1Y1pHL2JFcmx5YWYydHFzUTlmSGUvTjVseDVBNXMrZXYwSkdSbGJOd1A1Qll6Wm1GWk5Sd2FYZE1mdC9TRGI3NzZwMHJ3ckgva2xqbWo0aWdzbGxyaFd3S1lubHd5TXdiL1FtTHk2Q2E1dTFMNjlNcTJwV3U4cFpVeDJ1UWlpdHFZSWs4OGc0Zkd6SzZ2T1QwZlRLYWhDR1lVM3hFcHhEU205TUhBUmpWTTBVa3NWbjBVT1ZoTmdMeGlsZGM5a2xRaFJqTVRKZmh1TEd6dVRudi96Y2xlT2pSZitmM3pscDQ0VmVTekViRVRIeWI0eWlydkVIQzRKMWJ1cDk4YkRBS0F4RGwxSjZ6NCtuajAvSDlVWlZYWktUKy9zdnQ2dm03YlpaL0xRdlNsTVZKWXR6MEMxK2VJTWJrZC9CK0t3cURJVXpkQWRMY05ha1BoamtyRkwxSXBpOWE3UGQwYXg2TkxTeGlON3lxU3J5SitPU3EyVlUwY3JGQWlabGY5Wjh6a21oUklTOTExc09kaXJtRzVabU1JVGVhVjl0aENFWjJtZ3ByQ2lqYmlGVUlWRk1sZmNlQkphdG83V0NGeDNEOVdKVnQ1K0VZTURudXpLRzNENWtKOXJTQzRNeHBLaE1TR2VFaEFXck5sVXVRbTBENVk3blV6KzFoNWpFYTE4TjdHeFd2UG5PQ1pkM1J6ejE2QzU5QU9zTWZaL291MGpYQVdQUHh0VFREOEo0NU9tNlNPa01VbGhESDIxTXdteGFQdldwVDF6OWovZDJ4NTk5NiszRHYvMnQ3OXg3cyszQ0lxZmhyTWsydmVJOWdzblByZXNqWFJmbDJwWEp2MzA5K3RQWFp0dytYSnJmZXYwdXg4c3VtL0NKbFF2bytJV1pkcEg3N1dKYzJ1cnBxNVBKQ3c5UHIyK1V4Y003ZFhIdDhxUzZqSmhkRVRhT1YrRmU3Y3hrU0NsWVozZXQ5ZE9tUythNFNYU0RwbmlPUnJxaFE2Y3ozWTJSV2hnTmc3Sm52TS9rT0tmejFURG8vMXMyaVVGbGl4S2kxQTl2VDM3aGs0L3NmUGZnMVR1L1BLUzBGbjVFZ1dpRU5NUWsvd2JkeklVVFhyOVhVZFdYWFZFOFpwMTFFdE5CQ3ZGWWFCNjFHK05pTXB1NWJyWGNHb2JoemJLcWY4b2ErbTRJYitieDI4VVJqbGpueEhuSDBQVm4vZmQvOU84L3g2b0ovS04vY3B1alJlQjRHY3d3YjdKL3lrVnZPbE9BRkx0WHBwZVN0ZE9ZaEUvYmpsK2c1ZGE3Qzk0VjRia2JOZHRqUzR4R2RlWVhncUtNeTRDWk00eVBJbHR2ZDd6L2ZNMUtMSDB5RkVtb25kQWwxYXdYQ0pYVm5IUm5sZEZnMThCYWdxWjFUT3RJNVJJam13aURDbWtrSytmV1Q4S0lNbXpVOE4xbzR1dlpRYVJJdmFUY0pJdU9Zb2lKalMzSFozN21Dc2JBZDMvekRvVXpmUE03Kzd6d3pEWjI4S3pheUxpMkxCdGw2elY5b29vYURnbmd2S1ZwSTFod2hUT2p3dEIxUWRvbTFJL2UyUHhqTjY1UFAzWnBiL1JmZnVzNysvL3QremRQRC9uQklJcEJoR0FNOGY3QkVtZmc2S1FSZ0syTml1UFQ3dCtPamU2czViOTkrYjAxV20wbHBRZnp2TmM5WVFHVW4zOWk4L0luYm13OGZIbXpldXlSeTZOUFBuYXBmbmJERjQrYXdVekVZZDY3TzNDNkRNeXFpcGlnR1NMSHk0SFRWYVJ5a1dVdjlGRW9uV0dVZy91c05SUmVaWkVoQ1lVeGpHdERXZWt0WGhsREdJVEZVcFZQM2hsQ1NKU0ZNYzZaMU9IMkhyODAvVXVQN1UzZmZPUHU2ZHNaTTlEeGljRjJJYVc3Si8zdjlqMzhBYWxvMXl5dnJFNU85L2F1WFdlMnM3UFJoKzdGYnRXNm1GTHErcFlrNG54WlBseDQ3Mk9NeDBQZnY1N0w5WXZZd1VkeXNjWWpYWm5PR2Y3QmJ4MlNvaHE2NWVtRmZ3RDdLRjFkN0VtUzZyTlY0TStVTGRzcGNqTGI0dDFIL2lTbjF5emJkLzh4ekk4UUNveVhzdzErbHZ1Q1VsNHZ2ZGxTWHA4aVUwdVJSMnNpVU50RXZkWVpDQlFWV2xXVjRDcTFtWXFEMEJsMW5rblJZUE5QMlFmTGtBd3VBM3plYUJtUGhRR3JBS05Sdm4xcWhLSTIyZmhkRDRCZ05EalNXNEdRcUd2SEozNzhDbDBUYWJxZXQ5ODY1dHZmM2VlbEY2L1JkZXBTNngwTVVmRFdNSFNSb2xEd3dCZktFWWhEUW9aRVp3ek9XU01wc1ZvT1RLZkZVNS81NUxYLzVkVkxrNmRmZit2b3YvNlYzM2ovTy95Z00rMWFBaHZ2M2w4bEVXRlVlMWt1ZWg2K3Zza0h0MDcrOEcvMFJUTVlhdzFEU0IrVjUxMnZGOWZubjdwMDVVZWYzSG5oc1ozaUo2L01xay90YkphWGQ3ZUtHVVpNMXlYNm1HVGtqWXdMV0lqUTlnSWlIQzk2N2k4SG5NSHNUVXEySjA3Qkcydncvc05JbERFd3JpMnppYUVxeUlvclE0aEMyOG1aUHRwNXcxZ3NmUlM4TjlaWmtiM04rbk9QWDVuKzlNM2oxWCt4NmtLZkQ2WjFHVzlDK3AwTmduL3VGNTVnUGIvNmYvL2R0eTdRVWo3MFR5ekMvc0dkVysvRVliaXhlLzFxTmR2YS9vcVlvNFF4dFlCWTd4NnVwNk1CQXlFTTg3NXAzMzJBNHFwbHU1enY4Ny81MTE4a3hNUjA2dm5heTRkbXVSd3lvZmVNTUhUMlBJeWhCaGtCeFkzTjh1RS9VblNqcjlRRE8xYm91OGdqbi8wU0gvc0xmNHVVRXVHWENzeS8vTDlCbHFWS0hpQ2xsSU1jclA1K3RBamNlTC9oOVBrQ0kzSTJKcXVjTUFURHFyT1lOcEZhb0JRcW0vdm9xQ00xWnhMOVlBakJVRGpSTVZvMnFoQUx0bExFUFFROU1KTFZ1VHVpaDArelVHNStNVFVNd1p5ZExIMkFZQzJWRVdTSVZMWGoyYzlmNXVEdWt0T1RsbC83NmwzRzR6Rlg5bWJaV1ZwM28wVmZXN0xuUnBqZXFybEcwd2FHUVMyeHk5S2FHTVdjblBZeW5SU2pKeC9iL25PWDlzWXZibTVVLzhWdi92Yk5YOXMvYVBhTndlVXZlWEdpZ3pIYUdPMWRtc3BQLytRai9OTmZlbytidC85Z052dS9icDFxVHB1QjNJYy9TUEVjQWZVVFZ6WXYvZG5QM1BqMFY1N2UrUXVmZm1UekwyM1g1ZWU5c2J2ZVVzVWhpUXhKVEZEU3MvUmk1cWZSbkN5ak1jYVl0ay9tYU5tYkppUXpyUjNYZDJxcXlsS1hocXEwYXhkL1JNQVhodW5VTXAxWm5EVVpJTkszT0Vab2VpRWt2ZkUwNWtQVFAxTVM4SVl1SnJObzQ5YmRrL1kzRnUxd2ZKRjVsbnNzQ21mNDYzL3JoZnp2WUxZelltdTc1TldYNy9QU0Y2N3cvL2pQWDh0OXBJVWs5Z0YrZTYyZ21oeDJiZlB3MEExWFk5K1hLY2FpSEkrTXhaaGg2RGF0a2QyMjdVemZ0Sy8xeSthL0ZwR1RDd1NOYUl5SnhoaXh6aEpENUVzL2NoVmpEUCtILzlOM2VmVjdKNlpwb2ttaVN2RUx6Nk0yaGpIQ1dLRCtJeCtiUGZZZnZMVDVKNzZ5WTU2Y09sd1VDS0ZrK01KZnhkOTREbU1xM25NQUFJQUFTVVJCVkZmVW1JMHJwSGQrR3hiM3dCWkl6MWxwdkVZTFRESVlENU5GNVBCcXlUQnhsQzdyL3NVd1JKMmZENjJoRzVUQ1doUTZXeGZBUkkxdWtud3lTVEpuTS9pUTFESFdGb1krV2xhTnBUOEZFOEdWNTJHTHhxdGhwU2s0UzJsSnlkQXRvRnVxOHl6V012UkNOU21aN1l4WUhuUWNIN1VzbG9HSHJtMm9BaW96ZklaQjJaa2FCNkdYVGJwUW14MmZkQ1FSeXNLclhMWlBaZ2dKUVpoT3lzdFhMazArdGJjN3Fkc3UzcjEvMkN6NHNQeDFEZlpLak1wWmVQL21nc0piVHVidEg3cU5iaDc0dUZpcVgvUW1ILzJ4ajE5LzVzOSsvS0ZmZVA3eStDOWRuUlpmcksxc3hpakdXYVF1RERaaEpSblR0Y2tzanhOOUEyMmJPRzBpWW9SbUVOcHNKbWdNektZRjFsbTZlSDVoeHFTbCtHUnNLU3VEaUhxY2hRZ2haTkJ1blVvc2F6NjlZZWlFb2RlSGFwd3hmUkp6Zjk2Tjc4NmJsMDlXd3p1b3YxclF6VVd5MW9pejhPLy9iejdKSzE4L1lINFNxQ1lGbzdHaktDd2Z2TE13elRLWUdNVVluVFRaQzZQRTllRTN3WmdWeUg3Zk5PTys2eTRiWTR2TjNjdkdZRmllSE52bWRPbmF4V3JSTisxL2wxTDZKVDVzTGhIeW1GK2VlbWFIZy8wVmx5K05PVHJxekZ2dm5ocTFTeEtiSTQxKzRIa0FvODgrdS9uNGYvSkhydjZGSDcxYy8zaHB6U2hFaStsNndzYmpGRC81VjZpblc0Qmd5akZnU2UvOU5oTHpGVGVJOXNQcllWSldFdFJESWxqRHpaMGFIM1ZNMXZXV2tQTmhYQW4xQ09wS2U5OUV0b2xXbmg0MjMza0d6bjZmakU1T1VqSU1BL1NkSVN6Vm1jWTVZVGlGSVZoOHFSWlZNUmlLNHB4TEg0Sm12S2NFd1JrR1k0bFJtR3pXV09NNHZyZmtndzlPbVU0S2RyZkhkSDJpS0N4TkUxVEtYRGhTV2t2OUZKbTNWcjBNRG84Ym5MTlVwVU5FYU5wb1FzSU1nMGhWdWZIV1p2M2M3dmJva25QMjNxMDc4NE1NZ242SWdnd2FCbW10b1I4aTQxRkowdzUvYURhNmVXQjA5S0dSMlhvMHRqZXJOLy9tVHo3MWt6LzUrUGJmdURvdGZuYmt1RllWVmhVVFlMd3pSaUxHV1lOMWhuYVJHRnJCZUYwWXAwMGdST1UzU3dMcEkvMlEyTnNzMkp1VmRFR3l0N2oyMmphQ0U5VmUybnhiaUVBL0NNTUFUU3VzbWtUaFlGUmtvbnNVWXErSFFRUzZrRmkwUVQ0NFhMNTJ0T3kvbmM1WmFHZHkwQ1R3TC83SkxYUHIvWlU5T2U3Ti9LZ3p4d2VkV1p3Tzl2U29zekdxaWc3NWdjTnZYZUdzUGR0Ylg1WEdqZnd6ZmxSdmJHMWVZdWk3N3ZUKy9WZUd0disycFBUUFJPU2ZBN2Nmb0wwbUEzTHB5b1FubjluaG5UZU9lTzJOWSs0ZnRHYlZESWpJV3NGMzhYbU1nZkVuUDdIenlMLzdWeC8veWwvLzB0NmYrK3kwL0luQ21sa1V2WlZKQXZXTTRybXY0RGQyYy9OV1lzYmJ4THR2a3U2OWdiR1ZQcndMaGFoWjJ6VVVocXBMZkRDcW1UdUhkZW9GMytkNWVtVzFBNGlaMW1weUg0Tlp6OEx6aU15UzU5aTVqQkxkWkNKZ3hHQkw3Zkg3enRBZXFSMTFNbnA3aHc1OG9RRVRJUm1TMTg4WGRNdzNKUDArTVFpejdUSDlNbkQvMXB6OW80YVhQbmtaNXh6TEpsQ1ZsbUZJWnpvQjR5enBERk1WcXNweGZOSnh1bWpaMlJxZEhRSnRtMUFQTzhRWVcwekd4UlBiVzZOSE5tYjE0ZHZ2SGQrOTBIcGRISTJtdm8rTXFvSWYrOElOcXRML3ZyUG8zTC9pSnIvWWk1L1B4UTBqYTh3RUdEKzJPM24wNTU2OStyY3VULzBYclRPbE5VamhqQkhScXBhbzZaM09HNnBSSnBBWm9SNXJPVDVmUmx5ZWtiWkRwR3NEUVdCalhMQTFMVUFFajVJdXlFUUhtMTlaVE5DMnd2RThjcktJVk40d0xnekdDRTc1c3Zwd2dxSzBVUlJ0N1dLU0xpVGV2aisvZmJBY2ZqMExqejhVZ21EQXJwYkJkbDF5S1lwTlVWeUs0bFBDNnkwcS9pTTIrTmtCT05uY2ZyU2VqYjQ0bW81L2FqUWJmY0hZK0ZCUjF1Vmt2RVczV2d6TDArTi9MRW4rQWZEYndNR0ZUZjRoZzRrWWhYZmZQQ0lsWmZTMWJWZ25rNXg5YjJNMDFna1kvZnlmdXZIaVgvc3JqLzNsTDM1eTlqOTh3Wm9YcGlleFRCRXhhOUdCOVpqbUNEL1p3ejMyMGxrSkxPVUlFc1MzWG9aaGhTbmNoMjB6c25TVkVxb2g0UVZ1WGhzUmNzNDZYcCtMRVNXK3JQUGJqTTBrOGFESWZsZ3o2S3pWd2lFYXdxQi9IM09GRnFNYUNJQWh0RnBteFVMYmdZREJXSlhJUlRrbjZrUmppVVpsdERGQmpJWVlkT2J1QzgvcW9PSDR1S09vREo5N2FZL0ZJaEFHd1R0TDIwV2MwMnJSNXpaaFNQb0FSb1huL3VHUzdlMEtZeDBJckpxZ2JMdDgwNGhndkxNUHo2YlZveHV6ZXYrOUQwNXVaK01QZVZDajRKek5QZ3JtRDN5ai80Nmx1akdtdHNaTVJQdS9LVkJkR2xlUGZ1Nmh6VitvU2p2eXpsQVcrWWRIeTZ4K1VPSEVFT1hDdzFlcnA1aGcza1FrUWRjbmxtMmdUUW5yTE5QS3N6UDJWSVhGZVRVSXJBdERQWElZRDAyRVpTdDBnN0RxRWlrS2hUTk1hc3RrWWluS1hIYm10emtNMm11SEpMUWkwZzdDL1hsN2ZPZTAvZFVocnVFbkhTdnpnMEdJRDhwaXl3YzN1REhhR3h2RENNUFc5dFdyUHplZXp2NlM4KzZsSlBMdzBIU2w5eFdUNlNaOXYzSlJoZzFFWWdycEZ1clR2cTRxMGtVRVArcTFhS3kxYW1ZbVAyZ2hEWXlxeXMvKzRsOTQ0bk4vL3M5ZS8rdFBQelArcVkxQ05qZnU5dmk1S09jOVhad1BKRGk5aTczeGNjeldOWDNvenVNMjl2Qkg3NU0rZUJXeHBXNXNrNFZhNjE1ZG1VVk1tOGpKck9DZ0tpQmxSVm9tdURpbmYzWjVSQ2JKcU9sajNvVEpLdUdtQzhwL1gzOE1VYlBjdWtFM3FheWZpTk5LSXFHSGlpKzBKVmkybHFGVEFEYTB5cWtZbG9sMmtkVFhPVUxYSm94MXRLdUI1V0hEMisrYzhOZ2pFeDY2TXVHOW13M2UyYlZEcEJwUjVoczlvQldnTmRCMWtmM0RKUTlmMzJBWUVtRklOTTJReFlxNjBmcytpVFhtMG1qa3Iwcmk5YnY3aTdzWGFMSnh6WWNZUW1KM1p5eEY0Ymp6Kyt3NDYzNEhsdGY1TFc1TVpXQWtVSWtTaWlZYjQzTDJ5Tzc0Mm1jZnVmN0Z4eWJ1QzZQU0ZRWXhLWUlyb0s0TXpUSWhTZWZhTVFwaFVGdVRtSFRHM2ZmQy9rSFBxb20wSWRHdG5XTU1qSnpsMHFTa3FoMW1qYjRhVlQ0MUFacEJQN2YwaHNMckhGZlFVOW1jbFYvbkJvaHRvM1pFZlo4SUJnYkJ0RU5NN3gwdXY5RU82Y0I4Tk10Tkp3ckdWTWFheWhwVFozcHJyYWoyRDN5TThyL1pjblh4eDRxeStJd3h1T1hwcVdsUFY0UStNSFFOS1NVem1tM3M0dHlUeHJJdEtiMlB5RW5XQktRSERsc3JZQkd4SDdISksyQmlzWlAvMFo5LzRvcy8vK2NlK3A5ZnVWcCtkaFdrS29Za08wZkJ1Tk1FVWNkVENtcGxKa3A3Z3B6Y3hkNzRGR2E4d2RGSnl6Lzc3cEpYM2o3bTh2RjNtZENSa29VSUptYStlakpJcnlhUlJTbU1oOGorVHNYZ0hTWUlWc2grN092NXF6NkxJVFBka3VqdHJBR08wQTFxV1JXVEdsR0VxRDUxWjVtekdQMVNLUWNsQ29Sb21IZVdQcXBoUlRmbzEwbUQwbkZqTDdUTHhKQnYreENFMEVWQ01KemVPMlcxR0xpenYrTGp6KzJ5bUVkV1RhRDBscFJiUWVPVW54R2lLTGtpS2kvLzN2NUMzVzJtRmFzMjByYmhURXVmY214MFB5UmpNSmVxMGxWdEcxNDdtWGZ6QzdkNldtLzIvWVBsNy9zbWYzQ2pYN3pKTC9iajQxRmRqMy84K2NjZStWUFBiUHo0SDN0aTkyZSs4dmlsUC9xRmg3Zit5RzdoZjJ4VzI4MUo1VXdJaW03dmJEdEtEMDJyWkFZRFNtaXhKcE1UdE14TEdPNGQ5ZlF4S1dzcEprUkVmMDJ3dTFGUzFzcDFscVFNcTVEVTRxZ3VMS1BDWU5GRjNJV0VFYkJpR0hwaDZJVXdwR3lVb1ArK2F4UERrRlJzWTVFK1NmSHV3ZksxUlJmZXhGQVlBOVlhYjZ3cGpUWFYyUTBObFFpRnlGbndYL2tBK0RXZGJWZmJWMjlNcnp6MS9PN2pEejA2ZTJ6VjhzbVk3Q09TRWdsanhGaUdwbUhvMjlSM25VZ0M1MjN0Q245ZGhIbm9obGZ5YTdEV0d2ZUEwT2VqQ0VrSytNSG9qLy9zaldmL0IzLzY0Zi9GdzQrVm4rNmkrT1BqeExnV3M3TksrS04wTm83TTQ1NE1zQm5rNkQzb1crN3R2Y1RmL3ZWOS90N0xCM3pycU9aNnVNdVQ2WDJpYzhxVVcvdmJySk5KbmNGc0dXWk8vM3h6V21HQ1VFVHRKMlRJYkR1am03eTVVTXBiQTEwd0xIdExtME1kamRGUzNOaHM5V0sxcVZWd1RQOXRDQVk3aUNhNlluQjUvSmFzbW1BRWREWnZ2U0U1UTkrclpYU01pYUZQaENDMDg1Nndhbmp2MXBLcWNGemVuVEJmRExvV1JaUmp2SlpZaW5yU3hhamwvYklKM0xtM1lIZDdyRmhURnhsQzFGSWNnNGlZbUtEdm95c0tmd05qN3J4LzgrU05CMXF4cE5udWZ6QWFkdjhBK1BiZ3JURXl4dFIvNVk5ODlqT2ZudG0vNHR2NUp4ZXJZUktHVkVuRXQzMXZaVG9pR0wwb0ttK3BSN0N4WWVsNm9XMWc1UFVuRzlKYUJKS1piQjVHVTArVkhFTklySWFJaU1XUWlKSmdQVHZQQzNRTnZya0lLUWdEY3VaNk1uS1pPcG1yZ2lpNllOYWU1T3VGUkdaUitjSlFPVmRPUy9lSU1XWVROYVJ3YWpoZ2VsMW5xcnJiMkNxbm83R2Zsb1hibUV4OWRmbmFlTGE1VmN3ZWZXTHordmFsK3VIUnVMcGlDanVxSm02N0tGelY5Nm40Zi8yWE4yZXZmSDJKTDR6QnFXa2hRREdlbW1wVWswSnJySEZpYkRFZTcvSlNzZWUvdW45bitYYmZSUzNmalNtc1htaURpQVNSRDdVV2EzUi8vT2lOMmRablBuUHBUOTk0YlBScFZ3WlRsNFpxYkNsSDBKMVk2dUpjYjJYV3c4TzFpQnlMdlBaUGVldDBnMy82Mm5XNk95OHp1Q20vZGVsamZKYlgyWXdIREZKaVREb0g1ZEJ5U0phQVR6eTFYTEU0dEx3K0hhc1BleEpzRnJzTUF6UmlHTVRnc3BERmlHNVMwdG9oUkRldnN5anBCVDNRSmJkZFBsdVJ4S1NoYWRiQTFHcUxzRWpLblBOV3E4VjRaaUtvb3hDSnVzR1RnUEdXMGNZSTV4MlQydkhyLy9JV2wvN0VqTm0wWU5Wa01WTVhpVEZSRjE3ZGM1SmVQREVsdGpacTlnOFdISjAyN081TThJV2w3NE5PY3pMSDM2ajNwU0F5bVUycVAvSDRJenRmZS91OXcxZno0ZHdEVGtTaU1ZYXljS2JyZy94QmJQUUh5L1lpbCt2bG4vcXhUei85K2IzeHY5ZnY3Ly80L3FJdGxpR0pKS0d3NnFOZVZJYWlzRGlnS2cyK012aVJ4UlVSMCtsRGIzdjE5NnE4eVl3cXdSV1dvakowdmFpMWNBYmFMQTd4eXBRclc0dTEyYkJReDZUNk9UYURNMW1SWkl5eXExeWgvZjh3NUVNZ2wxOWRyNXZiRDRhdUEwbGk2c0lWRDIzV24zM25jUFZMZUh0dlk3TWNYNzQrcW5ldmpIZTNkdXBMT3p2RnJ2T1VUend4Mjd1OE83bzZLb3FIeEZHNmtTbWROWDdvVEpHOEtVT3loYlZpaG9TTldDaUZ5YWJIV292emxqVHZTYXNXUk9pWFN6TWExMVNUaVZZV0NYZmo4ZTFQL05FL2ZlTi9kYnpmdkhMbjV2elcvTGk5K2ZwM0RyNXg1K2JpWG9wU2hoQkRqSkpNRnZ5S1ZzbFY0VXoxdVU5Zi91SW5Qclg5czZIRUg3VldVb0FyTzFCV3NOeHpqR2VXOGpqcXJaT3ZLakVHVzZodFJPb1dmT3lkdjh1WDNpNzV2L3pxOTFsVnUreDk1Yy96d2JVbjJHajJNVmE1QnpobHJLMUxhRnFJTmxHU2VPbmVLYU1tOHIzdEtjRmFhcXMwMHBRRUc2MVdYUUJSVzY5azFmTEdSQmhzN3BHRDRIMDJyQlE5a0swUityQjJ0bEZxckUrU0FkME1IMlNHWGlIS25CUzNkZ3ZWQXlOR0lRUjkzZVdvb0o2TTJPZ2o5dzhhdnZ2YVBwOTQ5Z3J6eGRxMFVsMXlobXlBS2JtU0hBWmhPaTZvS3NkODBiTzVNV0pVT2JyR0VHTEVKNk42dnZ4NlFoVEt3ajIvdFZGLzJqdjdib2pwNGpURnFqUTZwVCtvR3gwKzdGeGFDdmpOamNuMmo5K1kvUm1aSDMreGFkcGlFQ1RrdEl5SWNwcXJVbzM5bkRXNFV1ZWh6VXBvVzJIVkNTNG8yR2Fzb1Nvc3ZyWjRCNjYwRkpYalpCVUpvbkcrWWlDa1JOc2t1aTR5MnF4MGMxdWpMa25HSUVaQkV1ZjBob2dpTkVGWDRKaWt0bTNXVURpb0NtVlRMVnJEa0VRWGxJRkdNRVhwek1hb2ZPUVRuNzcwcGMvOXpMWHFvWWNtVCt4ZUhsMlpiZnFOb2pEajBodGZlaUYwNGxJdkxnb3VXYVU2Ull5WUVwYWROVjFBak5PaWJBaUdWWUNtaTlsaXgrR2Q0L0tOTFk0UDVqUW5IVEVPbExhZzd6b0tWeEtDcjF6dG4zNzIwNWNlKzlnbmRtT00wbjMyenZLZFcrK2NmbjE1MnIzNy9wc243Nzc1MnVHN3B5ZmRJZ1F4a3FSRXBMcDhhYkw1M0lzN1g1NWVjcnVKSkhkdkpoTzd5STFMaGxHUldHMTdqdmRLTG5VdDBtVWd6UmlsdUo2VnB6QU5LLzY5aHhlc2JpVCtqOTgvNEsybTV1WGhLWjVPTCtOOU9sT1lpVE5ueG1rU3dYUktVUEkrOGZ4cXlUUkV2cjh6NGJUeXVvaEVLR1BPZC9FUUVJS3haeFpVenFyazFCZ2hXa05uVkNPUDFYWXNyUEpoWFdXTmJnNlRHRVRESldJMFdLdUJhbmlyYmFGQTBRYlNJakFVRG93aERrbVRiWjJqcWdyNnFtQmpVM2p0eldNdWJVK1pUVWMwM1hBR3lqa01aV2x6Tm8wK3hxNVBYTjZaY2V2dUtWY3Z6ZFNSdG5JMFRXQndDZkZtUGNBd2dpVHJURFdaVkQ5MWFXLzZ5N2Z2bmk0NXAxcWZXWUx0Ym84NU9GcjlnZDdvSGlpYzkrVmYrWWxudnpCTnk1OVp6SnRSTDBhTUZXT3RPVXRBc1ZaNzRsZ0ptNXVXN1V1VzhjU3hPSW9zNWdteENwQ2x3dUx6YlI2endVQ2ZFaW1JdW44TWlXYUlHQ0RFUkI4aWJSKzFEL2RhOWd1R2NRMXRieGhWK3E0V1lxQkp4RUdyZ3RnSjBRaDFyY0dCeGtQaERWVXJySmJLdnJIRzRvMjZWR3pNNnRtalA3YjNGNS83NGhXUGlQY0dtMUkwc1JQYVJ0SmdSWXdUazNQQUdBTFNpelhXWWJ4SmpGM0NpakZ0YjBsR3NBamVPemEzS3JyRlRTUnNzckc5UjVRRjJBWEdHZnFtWVRSU3U5UnU2Rmd1QnROMDBDY0tHVkxoclJsZHZqNzk1S1ZyMCtlSkthYlBoL2IyZS9PdmZmdVZlNzk2ZE5MZTM3Kzd1bmY3ZzBWejVhSHBvNWNlMi9qa2FXUE15RnE1ZmwyWWVPSCtmVGcwbHUxTHNMaFJzSEU0VUVlZGJoalIyNW0xTUNUSEkyODZ6My80aFQyMkg3L09MMTU3bXZwUktHOWZKcDdlMG9OVEpNL1NsZlFpRWFRWHBEZUkxNUw5OGFPR3ZSUjVZenJpZzdLa0taMGFQYVp6dXluSnhuTjJVQzZFY1dwV0VkY0lkc3JoVHdLcFY0V0lMYy9sUXFaUWdvek44L2tRMUJiTFpBbXJBSVNFN1NNNGl4VmxPWXExWjhoNjZUMjdXNTUzRjhlODhlNGhMNzE0blJBVHppaVBmczBoOEY2clNjVTJZRFR5Rk41eVozL083czRVYTFYZTJuVkJTVUhXSWlKNGEwd1FHSS85eDJhVDhvWGJjRGNUb1R5YSttcnl1SlRmejM3ZFhiak4xOFlKTlZBOTljU2plei81Mk83UDExMzNvMzBUckhYV1lLRUpDcFlWR2FHODhkQ0lSeDZya1JScFc2RXVJZlJDMDJnWnZVWmhLcS96OEpUT0I5YXJWVlFDQXFKU1ZPK3d6akJFWVh0U2NIMnZ4dVVaYXAwcmdYSGxzUmJhVGsvekVIVUJPUStUaWNOWGFrOVUxb2FpdGd5Wi85NTI2YXlYU3dhU0ZWWjlORWQ5S0xkdWJQdXVGU1A1eGk4S1F6WEMyZ0lib3pYV0dtT2NNVEVZTTdRRzY0UStXRmFkcFRBd0xoSlZvY2trM2h1MmRncU83eTk0Ny9XN21PUXh0aUpsSlVmc0F1Vm9oQkdoWGEySWNlQ3BseTZiOFZadFlsQmp0WXd4dU9SdDZXbzMydHlzSG52eXVkMGYrZmpucm56eHFlZTNQMW5QNm8wbkh0dDg5cG5uTmo5ckRMWjJZcVpqdFd6K3h0Y2lYLzJOZ2RrVXRoL1RaSlA2T0dMNjg0bXV5UjlyaXBCWUdOV1dqMDBqejEzZjVoT2YreFN6Tzk4bjNua2ZDcTlBV1pHcmdYeXRTMmVRZnEzOVUyeWtUb25yWGNlVmVjZDRTTXhTd0VWaEtZNU9WS1NDcU1rRkViV1hqbEI0WmMrbHFPdkRXa1hUR3pIRXdtWmVmWjc1RzBQSTh0cW1oejRxc1lDNHRxZlNsaUJoTUZtZzB2ZUpmalhRTFRwU0gwaEpxYXozRHhvZWZtaktiRnByNkdKK2Y3eTMycWV2bVphNWVoWGc1TFRsMHU2VUpBbkJuUFhwem1WZ0VXTlNTc2s1TzFtdWhnOU9UdHVYYy9rK0FFR3B6YVM2S241ZkdYTHVnYks5eUtNai8vbEhkcDUrYkdUK1hER0VoMklTb29GbVNMVDU1aTBLamN5NWNiWENKUGpnWnFEcllHTm1PRDNSQitxZDl0NUZub1VieVRQVy9QY2g2Q3c4WVBUSWMydit1akFiZWE3dlZHQTFscWV1enBHb2s1TklueGx6UThnOXV0ZkZxT1dwbkJGclhLRVBvR2tUN1pCSVVkbHlPRU03SkE2V0xWZWYya1VHTVJiTXFNYU1KMktNVXl1a0dBMXgwQU1sU2E1S2V0VmFPNmNnMHBxcEZZUDZtNDFuQlU4OGY0bkpSc1d0ZCs1eGNQdUlidDRTZTcxWmZWbXBLaXYyUFBIaU5oLy84WWZQbkNXOEJjR1lJTVpZQzhZaDBWdkVtdEk0TTVsdGo2OCs4dFQyaTFmM0prL3Z6Q2g5SVJ6ZkM1d3VJbHQ3RmwvQi9YMWhFTXZPRlUrM1c4QUtab3VZWTVVVUdTZHFtSUxSNzBHS2hpcDJQTnErd1N3ZUUrZDNrZFVSeGl2cnhlU0t6Smp6dzJLZEJHRlFtV2thSUhVd1hrVXVyd2F1OUQyUHRpMlB6eHNlYmp1MlEyQzBTbXlFeUxqUU1uMnRXRXRBc2pZRGFocnlLTTVtUnh2T2pDUlR5SUJyc3FTb3pqWE9HNlJQQ2hSYW02WEtRdW9TOGJnbDlJbXVqL1NManI0WldIT1hoNkJsL2JYTFU1bzJZcDA1MDFSa2Q4MHpnVXJLQU9KaTJiTXhLNm5yZ25ZVjZIdTFIdlBlNGV5YURXaEVCSnVpSE0wWDNUZFd6YkRnQVVmZnBoMStYOEU0OTBESlhnS1Z0V2IwRTQ5c2ZPbHFYZnljeDQ0aVNCZkZ0REVSUktncXYzWjJZVnA1bWxYS3pvN1FEOUEyMlJuZlFsRm1BVUlVeXRyaW5KSVJ5c3JnQ3NQUmFhUTNzT2lpSXAwWXVwQW9qR0ZTRnd3UitxQ0VtTEp5Rk9PQ1pSTkpvbWFEa09mMFVSZWZOVHA4bGp5RDFmbXIwUGF3NmhMZEVKVU9tNFNRaE1OdWdISEpaRmJqQzBOWm1weEFvb0taTklCRVlka1ptc0VxMnl0L2pBb2RLU25mWGtlQmhjMmJ5RmdlZjM2WDY0OXRjdk9kRTA0T1YrcHBYaGZnUzBKTTNIaDZnNS83cXk5U2pDcmFMbUd0T1hQc09PY2dpN0VZazZ4dS9KQ0VvUk52Z3hRYlk4RTc0ZTMzQnQ1K0svRFlFNDZISGpGY3ZlSFl1KzRRNitpU1pWRjdac3VCRVVtREV1TUY3dm1GMnhMcmRPSXhmeHZDTWFieTU4MWR1dkRDY2k5dGpORzQ0eWpRR1dqMTE1Z01hVEJ3S3JpVk1PNGp1NHZBdzBjZGo1MjJQSG15NHNsNXd5Tk54Nk9oNTdKRXBoTFpIZ0psU3ZTaWNqTGpUSjVWRzRiOHVsT2pmNjkraGRsNng2Nm5Nb1k0Q0hGSXhLQkNKbWtqc2RmWmQ3L29hRmNkeGxoU1NxUWtISjMwYkc1VTFHV1Jxd2tGYzYxYlAyc1Z3S3lqV1JlTEhneGN1alJSSm1kSTlJUGE2cmhzYVo2U21wNDRheWZ6UmYvVjQ1UG1GaGVNSmJPcTdROE9kYzk3eEl4S045cW95aHVsZFpNd3BEUEZUekpncmFxUVlyNFZVMVFFWFU5SU9EM1ZwTTNTYU5rVE9rVTB5OUpnTXlOT3JGQldsdVRBRjVaU2hOSnFaSzRtWmhyNktKd3NBcnRlKzN1SlFvcjVheFdHYnBtZ01JeEtUZjBZUWo1MWcrVHhtaWFDTzJzb3ZhV3VCVjlhcE5IWmVnZ0ppOEVIT0x4NXlyVWJtNlF1NG9JbGRJWlYxaStQQ2xHbFZqenZJMWt2dEY1TDJUam92QmdIdFJOcXI1QjZpSkhyRDAvWXVUVGw3cTBWVlczWXVqVGwvb0dRT2hYTGpEY3IraUdxUkRJa0JyZXVYUFFRU2Nsa0R6Zm9vakZWZ1NGRWFYcGhPVmkyUm9sSG55NjUvbWhCT1lWZUVvdUZNRDhWdGk5YlNnZDlhWG5qK3BTbjMxdXdGUWFpejg1MDY1Rlo1R3dEdXhJWWVlM0JPOVdXeS9ybkg5VHBSWG85eEZuM3NGWjdkVHI5SFBMaEtFTXVwMGY1Z0ZncjBpb3Q4NmROZzFsNFpCSVlKSkNzMEdLNVJjbFI1VG1vUExmTGl0dXVvTStPM0xGVzJxdU41NzE1aU9DU1lFSWtkVnExc1ViZGEwL1hSb1pWSUlSSTEvWlVWVUVTS0V0TDAwZmVlUHVJRno1Mm1hNVBqQ3BINGJJUXhYbXNxRWU4TWNyQzI5NGVjK3ZPTWRldVRSbU5DMDVQV2xLTW1oaHJRQXAvSmhYdzNsNlpqTXVuaXNKOWN4aGkrNEIyblQrd0c5MWtNc2pJdTQyUFg5NzRpYTI2ZUNrRU1kWWJNK1FmT09WU3hocW92V05hT2FyYVVvMmNFaFpFQWJjKzZHaGp5T05DNXhSdDFkSlZiL01VWWJtS1NCQ2FQbW4vTDdvSlkweHNqd28ySjU3Q0drcXIvbDZGMDZjclNURG80VkFXT1VON3JZQTdWeDVtZzJsbGFiVjlZdFhHL1BWVjVOS2t5RkJaOXE3T0tJMVFXbDM4UmFaN1JtdlViMXIwQmxTancreHhsclMvdFBubnNsNy92M3FtNlJqcGU5OXErTjUzVmpSdHp4QjZsdk1CWXl0aWpJUjJ3Rkl3bVJTTXh6cTl1T2hBNkswS041UjBrc3RzRE4waUdRY0tTbG9vYXNmbXRzV1hhcWh3OTFiaWplOUVaaHVXNmRRaUVVNnNveTBjRysxQWxTOWwrWkQ4UXJRODl4azA2ek4zWFhLc2hwaXpTQW5wMXZ6M3RUUk5MdHdXK3I1SVZ0ZTdMRjR4Y2IyNmMybmV3OUFaaGtZSWk0aFpKT3dLNnRQSXBaT0JoNVlkVHk0NlBqWmZzVFZFZGxKZ0ZCSUw3MWlLSWN3RHBrdFFLSEhWaTlDM2liNU5pclJudW1yb2hlVnhRemp0R0xxQlp0bGluVnBacFJpb1NzOWlHZGpZcUJpUFM3cGU5UmN4WnhEMFFiQk9RY1VoNk16dFpLNWpqTEt3M0xwMW5IdDZWYzJkYVZSRnhGcHJRa3pMMDNuN20yMFhtbnlqRDhhY3NScms5L3RHLzVBa05ZbllxR0lPZGZZeGhycTBpUFVzTyszUnA3Vm5yVW9ySzczbFY3MXVIazNRMEg2OHlDNytRNlpKbHFYK0d5RW5kQmdOMFhNQ0thUzFyU1pkVEF3aFl0RXh6a2tyUkNmMEtTdmFySUoyeGtGVmFzc0FsckRPV0FzcWFJbVpzNXhVZTRHM2hqWnJKNjJGWXJETWx6M2RxbWRjbEVnUXhpYmhIWGlycVNTbEVlb3FxV1h4R2ROT2tCNThKVHBleVNQRVpQWDFsaFc4L2ZxUzMvaWxCY013cHF4SHJFN21oTDVYcHhTZ09SM3h6Vjg1NXM2YlBVKzhVUFBjcDNmd3BkZFMyT2hpMDM1WTZLS2xSQUdydmhVMktuVlVEZDI1eWJqTjVvelhIckxNWmhaZldMVnNTdUJ0NGs1UlluZW52SGcwcDh3emJicHNsT2NNeHAvbExtV2R0dDdvaXFLU3BjSDVsQmdnRGRtcTJaN2JiSXJObnQ5R04vZUhWbkpjZTlLZGh6K3N3YjJVR1hMUnFRMlZhY0Ewd3N3R3ZuaDBRdTh0SjZYajlhcm1tOU1KYnc2V2VlbXdHTXJzTkpJeWlTYUdTQXJhMHNVMmtOcW9BRnlNcEJoSjBlR3RKVmxMakJGblliN3N1YlEzcG1rR2dsSDVhb3c2OHJXWURMNEpJU1pPVDF2dUg2eDQrc2tkaG40Z2hNQmtNc1o3UjljTitNSnJ6cE1YcXRJOVhaWitmSkhsS0NMV21qTTNHdm45THQzUER1VStwTmdPY1RuRU5IaG5DbU5FdkxlbWRsYUpDRU9pUWdVbjljVFNKMkhWQ2dHaDhCWm5sYjJHTlJpdnpLRXVhL3VTQWRxVU03ZDBzeVpnNUIwbGhxYlR2aWVLY05JRXVwUW9LcThiekVrbWZ3aURxTGhsdlpqVUVWSE90ZWljQjJhdHVkNGVzRWxmVzVBRWxhTW9ISXZET2FlSExkTnBwYU82b01odVdTUnNrYitIUUVraUdrTXdCcDhSS2V0eWJsaVdwY1NzUG5IVzhNN2J4OXk2ZFV4UnFEWWFQSklpdzNLRkx4M0pXZnF1NSs3N2pwUDdjN1ozUzU1NGRoc1RoU0lyOU00UVU1UEx4MDZJVFVBS1R4YzFjTUViYUkxQmNBd3hNYXVGclcxREdQU3dNNWsyR2diaGRPYTVONnU1ZHJmRno1TWVFbWN1SzNyUG1Iemt5NFhrdXJWejVucGpTOHkzOWdwTWVkNzRtYlZnd2VTRXFQQ0FjTlBKbVE1QkpiQnJRbzJjaldQV0ZGcEtDRllkWlV3UFcwM2c4MmJCVTBjTjN5dHJ2cll6NVgyeE5HaXI0S0pnY3J5TDVIVWF1a0NLQ1RFd2hJaGs5aVFHblBja0dYQXVjWEMwNHRMdWlLcDBaeVFieWNCY1V2ZFFSSVJoQ0JTRjVjNjlKU2VuSFZldmJuSDd6akY5TjJTazNpQVNjQzQ3SkRtN05hcjh3OWFZVytrOFh1ek1KR3l6ZHB5MGtmL2R6ejRFd1AvNkYyLyt2cFR1QlZCRmtlcjV5N09uOThiVnA3MHhaUmFIbUQ2blYxYUZwZFRNSmNZalI1K2dUM3E2RjA1dmJJeko4ai90MVNWVFVac21NWjlIVnN2SW9rMmNMSUwyNVJhNkp0SjNXcmFIVEdtOGZuWE01VXNsVmFubDhQbzJqMFBtdmlmVm84ZW90M2U4VUJDdHM3NWNUdWNOU1ZpMmlhYVBSQkhzMk5PRXhMMmpCYU90RVpzN1k2elRXQmpKYzllMVUwTFhHMWF0WlRrb0V1eTlpanRjcVJSTjFseCtwejkzVlZrK2VHL09kMTQ1b0dzSHZMY2toS0ZWTUdkemIweks0TmgwTmxMLzhYSEpwWWNtNm9HZU9RZERVa3ZseWluUTE3UkNtQWZGTFRJeVRRNVJVUHM0Z3pXR05BaEZVdEY4WWNEMGdoMVFBOGVyaGxoWnlsV2l5cVcxbVBOYitXemorM09wNm5vRFN6Um5ZN2wxM05JWjhyNEc5WklLVkFpY2czK2NtMDZjZTdIa1l0N2w3NzJtTE1lY0JKUGJBSk5mUUVJNThLTXU4VWczOE1TeVkyY1k4TUFLdzJxQXZsZWF0Vzd5U0ZnTmRQT09JUXBIaDZmMDdVQmRGWG81dUxYRFRLUWZoSzZMVEVlbDZqRXlDU3lsekJjSkNXc01iZFBpQzgvdHV3dmFObkw1OG95TmFjMTgwZVladkQxUDh3VHgzdm5scXYvZ2RONjluSktraTNKa1k1Qlo3V1hWSi82REwxMm1kSlozajNwcVp4bDV5NkpQdnljYi9hS1JRZm5pMWMxbjkwYlY1eDFVTVVIVFJ6UHZRcDVwT3pJdW1ubnJlcnNYUGlPeDNsQVVCbWVVcURBRVFZTDZlamNyN1pOalVzR0FNc3EwNUk5WjUyTXowZHM2dzJNUFRYam9ha1hvZFZNNFp5aEt0U3FxYXgzSG5aV0FSdnRwNTNVV3ZqNXdVbFNFTm9nQ04xMFFna0NiWU5FSGp1Y3J6S1JpdGpYV1h0L2sxNTl2RzJPZ0dTenp3ZEpIM1lWMUtUaXZpejVsK2FYTmhncGFqbG9LWS9uZUswZWN6aVBlNi8vdlZpMHBLc0NaRWxUMWhORmtUTWpJN2RVYll5YXpBcGR2azVnN0VaVjlDekVrRmljQmEvV0dEdEZrNHc2OXdkZEtQNVBBSndXcEtxTmVicUV4MUdPaHFJV3V0alFqajhkUlN6d2JqNWw0d1FsMlRUVmRiOXgxMG1MNnNEV21ETGtrenhwUHlYMTg2dlBYR2pKZHRUQWZVbFlZYzJHMmY3RUZ5TlVlU1lrOW1wU25melloQzFvRXhrM2k4bnpneHJKbmV4bXdNYkZDV1BUcUt0UTFQY3Vqbm5iWkl6SHliT0h4RnU1Mkt0SVhySG9oZEVveWFOdElVWGlxdXFCUEtyenFvOUFsQlpwamlIUkQ0UGkwNCtpNFlXK25abXVycHZSZWVSRnRyK3ZmcUVPTmFKOXVWODJ3ZjNMYS9uby94SERCK3lBWmtDN3o4WC8xbllYNXpyM0cxTTZ5R3BLeHdHSllFM2wrZUtXN1BPQnFtcm8rdGtOSVlWUjdFbklHM3NTa0J2bERNb3hHamw1RVFhckNZcExlcUQ3VEpVUHVwMk5HekdQZXhONHJwYkVxTFdWaFdMYVJsTUJWRmhzdFBrQ2x6UkhKUUZHcXhqeFozZnhyM0tCdkUxMnZaYTczMmxkYXU4YU9kRFFUbzNJQWlrTHBrMlZwbVkwODh6N1F0RHJYSmhtV3B4MkxrNTdhbFNwYXFMWDN4MEEvbUJ3bkpCZ3JqSnljT2FGYVVFNTRnTmdMeVJsQ1lla0hZVG9lOGRSak0vYjNqekcyd0RoaHNsRXoyL0RjZnZja004R1c3Rnk2VEYxWmp2WmJicjA5NStxMUt0dGlyVzJZOUJBTXhtQ2kwTFNSUEZYQ0h2Y1UwNEp5cEx5R1psQkJTYWd0ZUpqWXBITitDL1ZNaVVWT3RNWTZxZ3BPdHp6WEpYRnAzdUdNRVAwRlFzc0ZVczFhaTA3S0tMdkxwWFovWWNOM25QWEtRNjk0Z1hmYXhwRDB6MnNpQ3VzQXhEekpjSVY4NkxhWHN4bDliaDFpL25QMnhJakowSW5hVE5WTjR1SFFNaWtzejR3dDcyQllJRFF5c0tvVHM1Rm5MUENZVFBqbXZZTHZyMWJjMkMyeHBYcmZwVmhUT2pCaTJaelZGRlhCYWtoMFl0alBtdmZUTm5GL0hwaVdqcmZtUFVNVXR2YW1UTGZHdlAvZU1hVXpWS1duNy9vTVZtdEYySGNEenBvTlo4MHN6enFxdGZlQVVoRWtlV2Zremp5a3U0dUF0MGFjUWRxZzdMa2hpZnpzSTF2ODRudkhQOVFlZmIzaDQ3SlBmVEtrb3JMRWtQRG9HR3paREVRditNSVRnTjdBeEN0TnNtK1NtdmlsaklCMnFpS3l6bUNWOUlFdG9mSk9LeHVYWFRmY09Vb3VCb0lvVzI0STBFWHRwWXdkTkxuTjZoeCtHS0RyOG9nbEtqTHE4aUVRZzJEeU1SamllYnhqNlExVllSZ0tRK1gxNStrd3hCVHBqcGVzNWozOTFET0pvcnhyTE1acUh6NUNLRFBPVU9YTU1NbERleE1VUFU0cm9VdVFOaUI0UXpWeFBQM2NOci85MWJzWW1iQzNlNDFtZkF4MmtXOHZvVnV1bUIrZnNIdjVNdk9UbnJ2dkxlbGUycUtzSEcyQTBxMVJmU1VXOVlQUTlZa29VSmNHbXd5cFN6UkJEOEo2WlZndUxSdGpDR05EcWh5U0xaVk5GcWVZcUJzbG5zSlFHZDYvTk9aMDhOdzRXREdTeE5BYVVzTjVtSUxOd2lOM1psMnZxcTJraVB5NllsL2Y3RVlVYU1XQ2pZblVkSnFidGxSSDJHbXByMGRDZ3RKaHZTUDBPcjQxYmoyYzB0ZWRjdDBwTVQ5WHIweTRPSnlUV1phOVpkNUJiQko3SzMxT0J5SFNMeVBXSnFvU2xpdmh0Y01GejIxVy9JOC9NV2EyWXpFanJmNk1VYmFqeWFadktSTnlRb0pWcjJ2emRFamNtU3ZSNjVWZDRlYmhtTjNMVTVyQ010NHErZjdkSloxMUZNWVF1Z0ZuTFlXekpHTk40ZTFWNyt3VjRNUVlhcEh6WmthRUVGT0dQb1VVdEx3WG05Lzl6MStlR3ZOREFPejhBMFoyNjk4blg1aStyR3kwM3FxeGdGV1NpVkg3RVBCYU1xN1ZSWEhJTjN0dEdmckVhaGwxRnBzRVgxbTE5N1c2SVgxaHp1czJaL0NsbzB0Unh6dE9EUUM4Q0cySXpCYzlLV21Vem5xc2wvSk1kVHhXZGxRY01nYzdJK0tzRlZLZ2ZtS1pYam11RFNFbVZxMWhVam5hSkF4V2tlVm0xVEZmOU15YWlsRWJXYTMwdFl5dFpWb3FDaDhUR2tibzFJOHVCWlBsbHFvSXM5bmlLRXB1WTJ6aXlaZDJlUFpiVzN6OTErOFJtNTdOU3pzMFRXUzhVVEdFU044RVRnN3VNOTNZb0NwTFRLay9ueEdWU3NaTWJISFo1YlpkUlpaTnBMSUdHNDJXZG9QZ1NIU0R6dlNITHRFdW9ha015NGxoWjJLWlZyclJLUlJFc3lYNFFzdUczbHZldnpiaXBQSThlYlJpUjNxR2FKUkJsOUYySGJ2bFpXS05JdWZab2tOeWpOTmFTUzlKY0ZFUG9JV2RFQjU1a1hEbEVaVjg3dTd3bSsrZDhNck5GYnV6aXIzVHR6RkR3NU96d0Y3WkU5T0FHK1pJMzJJR0xiRmRhVEhSTXNRYTZTMVdvdVpiRnJtcWlFS1pTL3grZ0tFVHVrWGtlQkU0NlFjVlRBbDBNU0V6dzh3VnpLeUdnZmhDaUJsSEl1U0tKVmNXNG1IYnI0RkR5M05UZGQ3NTBhdmJkSm5LTzIrRms2c3piaDVYZlBWZXp5dkhQWGZuUFNkdFQ3TE9Ua3N2M3BtSHlzSStibzE1bHd1ZVB6bUkxR1dEMG90b1JwTHMxUlJFV0lYMFEwWGQxMkNrNktRcnRSR0pNWWoybE42Y2lRdXNNMVFqVHhNaTBYRFd5eGFGWVRxeE5BMTBUY3JBbVFXWFBkdUNscDdHRzhvaWwvSE9VSThkelpEMG9YcUxGNUFZRVVtY3pudjZMcEJDWUxXTXVEV3lHVlZDYVJKbkVzT2lNdGhDZTErYmFZNHg2SzArcW5VTXVHaldMaVpLcHl5OFlWSlZISjR1T0pxM1RCWVY0NGxqUEhHNVhGUnNRV1ZIcW44MmViN2Q5NXI0NlQyNEtWQlozS0JKSmhLemYzamwrY3FmZnBwNlV2UDEzN3pGemJlUG1jMW1qTXN4eTdCUTA4T200ZVRva0wxTFY1RG9hQnBodEFHbFU0VVdrczB0UlZPYVkwcjBmU1FOaVZIdHptYjJScktyU2krMFJ1aFcwSzBzN2RLd01iRnN6OEFiQ3duR0pIVlpqU3JucTB6aWFGenljdUY1OUdqRkk2bkZpNEtka2pWWFdrNnZreERYTTNiRktZek5VNVo4VFNFUVNjakdqTTB2L1JqbHM1OG5iVjNuVjk4TC9MM2hrSGZEV3pUM1AyRGo2bWVKekhoaDB2RTN2bnlaeDYvVUxHKzlUenk0aVQrK2l6bTl5M0Iway9aNEFmdDNHQmNCVTR4SnhpbWduL1FRdHdJalkraXpYMEhvaEQ0bG1wUjBwbVV0TzFWQkZSeHYzUloyRitvdmFDZkNsVXVPZXFyUzJ5Ukt1aUlvYnlHYWRYck1XcGdEYmpDTXZSWWUwNUhoV3VWNGRuUEVGMi9VM0Y4bTdzMERYOS92K1ByaHdQdkx4R0pJVllocFlveENKc2laN043dzRUam1jOE12RWVPTWtlOGROV2ZXc2o4TXJ2dURwQmwvZVZwZnU3NVJmMkZzN0U0SWd2SFdkQ0hTcDRSM0RtY1YzQnFOSEpzVER4cVNvRGRyVWk3NG1oZWIxZ3NrTjJmV0tpdUpyREVQR0padFVOcnBrQWdoa1F3TU1WRlhudWVmZVlTZG5VMk1zUlIxaVM4Y1hSdnBtcGo3T0UzNmNKbHlXOVhxTFdhaVFUTHlhM0wvYm96aDZEaHdzaGpvaGtTMGhuay9jTzlraWFrS3B0TXhWZTBwSzB0ZE82cFNqUkhhcUNtaEJpanpSTlRtZkREdnRYK1B4dEFrbzJtaW1VazRkSUlyU3g1L2RwY2JUMjFUMTQ0M3YzdUgxYkpuNkFJMlErd3BDdVY0eG1vWm1HeGFkcStOSUVrMnoxVFhsQ2dxMXowNjdPbFhnZEJGaXRwbmpqWks4a2dHaVVrSklYMUNvbm9CZEszYWR6bXJyaWkyRjN3VXhGbXNDR2t1MkFocFlybFhWOXkzbnFwUFRGeFU2K1pvem5QYXN2aktaRWZYTXc2OHUwQ1hUZUJLeHlndGNPKzhqTG41TGZ6QjIvenlhM04rN2JVM0tXLytFdmRmL1JXKy84MWZaZXZScDFqTm51VGhHMWQ1L3FYbktLNC9RZjNFaTFUUC9RakZ4MzhjODh5UEloLy9NdW1aejlCTTlqZytQaUtkSGxLN2duNVFRbEFmNEdRUWVsR2UrN0tQbkF5RHJsZHJxYXpsKzZzbE81WGpDenMxdlJYYUJQL3M1cEsvLy9veGJtblk3QXBNYjZtOVZWRFZRWExyUVlRNTg2VS8yNDdtWERVblNUa2ptNlhqMnRUeGlXc1ZYM3hveENkM0N6NXp1ZVNMMTJyNytLeHNndEJkM1NqOFZ1MU02VXpjR1hzMktoZXVUSDJvdlUzelBxMUhiMktOeXF2N0h3SWE5MUU5dWdDeTZFTFQ5bkVWQ3NFNFl5UW5hOFFrckxxQXN4Q3RZZWdqQkVHaTBBWEJHSjJqajhlV3BvVlZFNVZYSzVMZmxJUTFqcGg3Y2lzd3JSMUhUc1B6VXVXVmJJUFFESTdqNWNEQjBUR2IweW5UV2FLcWFseGgyZDJyYUk0WEdHUHBla05JbHFJc0lmV0lHMGd4WVZ5a0xKVEpGcUphRjQzSGxyTFVtOC9rdVRwaUNDR3lXallzbHgxZFUyVTdvbldsS2ppaklwQ3NlTXh4d0RwblQwbmRicnNXRm5PMW5CNXRPcnhYbW15SUNldmgrdVBiMU5PS2IzMTFuMFVUOENJOC81bnJiT3dhL3VVL2VsOFB1UmlZbjZ3d3NxWFRwYWpqSGVjTWZTY1VsY01XaG02ZUdIdWRhQmlyREwyUUV3aDhkdkpaang2dFVXdXRvVmNqaGMycEpjMGN3ZWh0WEF6YTEvcXBFR1BFaXVGa3ArUzNuT2ZSZWNQamZjZkVSK0xLS0dQTzV4aVozdWhwdjA1Wk9FUG8xMEVOUWdvVzR3VHp3WnZFZDkvZ3o1bC95Z3NOZk8zb2dHK1p5RCs3ZVpQM2Z1UHZZZjdrQzd4Nk8vQlRpNWFOU1luWUNtdHFTRlBjZEJjZm9IbjBFNXcrL1ZNMEw3ek5iLzlYLzJjZWZ1MVhlV1JXWUwySFhQRU1lUjJlRWFmVVBnZ2JJMTg3UHVHcjdURjdHemY0eWlNVCtnSytYSXhaM096NTMzNzFGcVZZZm54dmd4KzVOdUd4dllJclU4ZGs1ckNGRUVvQm42dWI5WWJQNXBYaXprdmhkVTZuRWRndERGY3VsVVlTTGoweS9wSCsyYTBYVHJ0NE9DQW5mU3ZIYlpKN0dGa2NMZU9iUTJEeHhrSC8vZi93RjkvOXJTRFNyci9GK3EzOVBidlJ0K3R5KzJPWHBqK3lPUzF2UkhTbVBTUWx0eGliTFlXc29hNGN0Yk8wYmFKYkpJWW0wYmI2NDNxbnBYdWZOZWVTQkZzNGpMZHJWeW04MVJKcXZrd2tFYVhLWnRxVVdNTmlNYkE5Z2IwdHgvRmh5MnJSMGpaOUhqMDVmT25aMkoweW1wWnM3bXl6ZlhtWDhXeVR5V3hHTlIxUmpEeWoyWmh5NGtsb2I5Y0ZPRmxHK3BBWWtuRFVkTnc1WHRDa1JEV3FxRWNWNWNoVGo1M0tYVXNkdHhWT0tJdTFXazFIZWQ0Sk1Sa1d2ZVdrdFN3N2kzRUdYMmFxWjlDeG1CaERMNGJsb3VmcnYvd3VRUXliTzVjWjJvTFpyc1VDeXhNRFRuajQ4WXFISDl0VTV0bDZhcFVweGNrWjV2ZGJWc3VnUElWeG9TeS96RlJWWWtmZVpFbkZHVVhsc2toSDZEdDlEczRZMms0TkY3V05VVERQbFlvSDJDU0lNeHpOS2c1SEJjRWFObUxVdHVvOHd6Z3pvQlJyV1ZOY1RUd1hGSkhUYmNtajFrSUMxOHZJUzNzVmYvVEdpSjkrWk1hTk92TFVCang3dGViSlJ5OVRGbXMvVnZXdFN6RVNoa0RvbytJRm8yMTQvUE44L1RoeThNRzdiS2FXb3ZENWM2RU5RaHZVZnpDSzRJMWhFU05mbjg5NUw3VjhwMjJabFo2UDcxWHMxb1lYWnhPZW5JMTU5WGpGMzMvcmdML3p4Z0cvdXIva3pmdVJrME9ZbndyamFLa0dwVzdiMHZ3Z3FyWGVRV3NBTTQ4R1V3WVVVOFM1YUViandtNXZUTjNWN1lsNzlGSlZQTGZuaXhjdnBmSnprMlgxaGRXcE9YN2xZUFcxdTkzUVdSM0ZweCtXYVAzaVJzOTBEMVd4ZVd2SEwxN2ZmR21qOWsrSHFBdkdXc01nUXROcDhvVDFGdU1OTllaK2xSaTZsRFhMU2pHTm1XRlVqWFRPYmd0TFVhbElwYTRjUGtmaXV0TFNEWW5UWmNoWjJObUZVNFMyQzB6cmdrZXYxalRMeVB3ME1qOE43QjkySEI0UDNEdm91SGQzUWJOc2tOU1JZay9vZTJJY3NDNnBaVlhwS0t5am5vNXdUamc1N2ptYUI1cGVIV2lQbTU3N2k0WlZGQ2JUbXVuR21MTDJXR2Z4cGFXcW5CSi94T2g0cXRCMVcyUU5lanNZNW8xbDBhdFJZVmtxRHRBTmVoaFlaK2pSK1h6WEo3NzFhemR4NHkwMnQzWkpZY0JYUGM0NmhtYWswbG8vY09uNkZGZTRzMFl1UmEybXJMTXNqeHJteHoxdVdwR0Nna3F1ZEdmb3ZJWU41RUNFck96eXpoQ0RDajdTSUhROXpCczlwR0l5aW9xTHVhQzRVUDJBUStnTHk3MjY1bDVkWXBKUWgwU1JFWGZXbm1uckh2MENHY1ptSElZOGdsU3dUbkdOOWVqdTJzanptUzNocGY3N1BMci9MM0UzdndWSHQwaEhONGtrQmwvUlIxSG4xK1RvQXN4WFBlSHdBelpIaVdyWUo5Ni94ZGlwMTFzUW9SMkVSUjlwb3ZiY0dNTmlDSHl2bldOcVpkTDkrbUZETDVibmRpbzJSOEpEMDRJZnY3VEZwYkxrclpPTzE0OGJ2aDhEMzBudzM3eDd4Ry9lNi9qT093MUgrd1A5eWlBTHRTWXo3dHk5VXdOdE9mUEhPK3Z0NVN6WFhVZ205UzFoZm1ENnc5c3kvKzQ3L2ZmK242K2MvcjEvOU03cGYvcDMzdG4veFZkT1Z5ZFJGQTJ4Wm0yWTljT2RvNitEVHhJZ3gwMi82bE02RHVtYytWZzRTd3FKcmcvWTBtT3hXdUxhaEVuQzRGU0tPcDA1NmtLamZZdzErTm93UklmTG0zL1ZSTDJSOG9qTkM5U1ZWUXVob05yaHNBNE44SmI5azU3am81WWhHQmE1V3VnSElhV1VTeVoxNWp4WkxCbVBWbXpNQ3FxeHc1cEV0d3pFVHFnS1N3Z3BtdzRxR1NZbHliVElwRVNacUlLSUlTVDZRWHRiWjFSemJvMVdNMUcwWDVWa0dHTENPWEx2cklFRTYvSFRla01ORGdaaldTUU4xUzVISlM5KytVbmUrR2FnY0k1dUNMenlhKzlqcmVYUzFVZHd4dkc5bHc5cFYvQ1RQL3N3dTNzVkpsdlFEa2xvbDRGcVZwSENuSFpJVk5hd21nY29yQkxaemhSZE90cFVHNmFFaU1YbnBKUVd3OUFrSGU5MVFsTWFSZ1dVSTB2YldrYVZvYTZnckhXMFdJaFFPbWcyUEs5T04vaGdQckIzcjJNMFJIYmJRSlhVRnRtRWZOc2I5V0VqMDBqUFRTa3ppeTZlSS9SRHAzTWw0dzEyUGlkODQ5Y0kzLzR0VE9Xd2t4cTU4VW5pN0FwcGZJbTA5U2dtSldaMzMrTHk2NytFTzcySGFYdFdXeFZ0bnVlUEM4T3FNSXdMcDc0RG9ubkdDYUd1UFRMeUZOYlN4OGovOWEwalBsZ0Yvc1l6V3p5N1ZiQm40Szk5ZkpmUFhaM3hEOTQrNXBmdm4vRDk5dzZacndLdnVqa3lKTWFGNDZGckU1NGFGL3pJemdhNzQ1SXJZOC9WeWxDVmhzM1NVaFg2UGk5WHdySVZURWpTaWl4anovM2JKK0gyOS9lNzk0L2E4TUhiVGZQSzl4ZXJWKzYwL2UwdXliS0phakQ5VWZQdUh6YnFmcVpsNm1KYW5MVGhUanVLUTJFb1V4VDZrT2piaUlqUURSSGJXNUJBcUJ6MXlESDJodW5NTVprNEhJWW9Pa05QU1JINUVISU9tdWhOMXdlbE5acWdCSVBLcWVGazEyc1pYeFNPS3Nja0w1WXFiWTFHTnhGV0R4NDRIL0YxUTZJUHNGd0V4bVBQNWtaQmFvVittZWdrYXN1UkJSbHJTOStoaXdwNm1ld3VHMVFBb1NZUXVjZExPa3EwRm1LbWE2WUlRM0o2d0FYTEtocVdQZlJSTUZteVdHUWNvNG1vbmpxM1BsdFg5aGhWcDZTWUdLS0tJZ2pDL2RzZmdGWHgwUEhoUUxzTXVLMkNKbVp6RG1QcGhvaHpqcUVmb0FtVVd6VUdxNGFZbVlLY0JqMm9Ra2dNVVNpaVV4WmVvVVlQRVlQTllOMHdDRTFwR1plR2NVZ01BZnBhSndwbE1JeEd1WEl4Q1N0YXNTeDNDdTVNU21RSnMyWGc0Wk9XNjZ1T2NSYUlYQVRtMXR5SWl3eFpFWU4wT2hvenBmYUxPQ0dLUjN3QkpGSWp1RzZKdmZmUHNIR2dwTVNQTnZRazYxZElOUFRpaWNGZ2t6ckU1dEFZSm9VbGpMSnJWaXVjaEVnU1lUd2Q0VWNsaUZERVNOdjMvSU9ieDd3OWIvbWZQclhMbDYrTnFjZVI1Njk1Ym93djg3TW4yL3pqRHc3NEIyOGY4T2E4bzRrSlAzTmdoVzhjbmZEZGZtQnpObUZ6VkxGVmVtd1FObE5pYWkzZU9rNlhIUzNJL3QwVE9SN1NHNmZMNGYvK3dhcDdjNVhTdlNSeUxDSnRVdFE5bWZOUjkwVjFBSVhSbjYzOS85SlAwbjJFT2VSWktza2ptK1BIdDZ2aXBRSTdGcDNzcytnR21xQTN0Y3ZzczcxWnlkNU95ZGFHWnpSeU9HTW9uRGtyNVlLb1hMVzBocWJSUldpc2ttR01KVXRRRFYwWHo4THQrNkI4OTVobjlMV3h6Q2FlRVBKdHZrWkNsVjEweHFrTVNSaXlpMHpYcTlIK2tJVFRRV2hDb29uQ2NaczRQdTVacmdhNklUSWdIS3hhRHJ0SU5TNlliWTZaVENzTmtIQlc5ZmFGZXB1RnZHcFRuaDRNMFhMY1dJNGF5MmtqTEh0MXpWbWJGcVNrbE51WXRDK2F6eVBmK2EyR3NOQnBTdE10NmRxRzJBK0VZU0NsaUsvSFBQekVMazg4TTZNb0hhc2UyZ0c2Qk0wcUVoY0RUWWljbm5RVVpaRnhEeDFOMnV4djEzZUJadDZ4T0cwWklwakNxZnZLT3FyWUtJSy9qcTFLV1Jpd2FoSk5vMWQveUJNRWcxWkJvSDJuUitXdzRnMkwybkd6ckxoVGw5ejNCWXVVUy9uQ1pMbVduTG5Uck5sMmE0ZGV5VGU5WkIvQmxPbUE2MVpGcGJrbHlZNVZBOXdQcEQ2U3BDUWtyeUVOMlBOSXB3c1RnVFVicnduQ0trYU9ocDc3dGFXWVZqaG5zVTV4Q3hzVEg2dzZmbk4vU1Q4WUhwOVdiRThNMWlVbTF2UEM1b3dmdVR6REFLc1lTYlZXSU5KRlNnT1Y5eFNGZzlxemNQQkIyL1ArRUxpWklyZml3SjNROGQzN3AyWS9wT1dkVmZjUFYwTThTQ0tEeWE1WEY1eG5oZ2M4NEpPSXlJMVJ6VjVaY3I4ZmZrOXU5QWlFdzJWL3E5dU0rMlBqZG8wZzNoamp2VU5Db291Uk9xbklZYkdNak53QW13VzF0VlJPeTlaMmdHQVVrVytheEdHWGFEdmQ1SlhYMjNoVU91b3lDMkM4K21WWGhhV09qaUVsclBkMGZlVGUwVUJaYXQrYzhvTHI0Y3hCcGd1SkVOT1poMExLZXVJaU85WjJNV21nWTB4cUtoQzArM1hHWmhUU0lrRXhnU0VraHFTZ1RqTkFIN1NQalRrdGhBdzBPaS9LZ1c5aDBZaUthNGFFOXpwMzZvS3l1RlErcXF5SUQ5NXFXUndPRk03UXR3UE42U0pUUS9YTkwwWWp4dE1aazgwS1l3MkxOckZLRjF6ZHZiWlBPN3NUN3Q2NlRiZXExRWJMYVo4c1JqZGdPUzdvRmgzN0h4eVFFbHg2ZUlmdEsxTkdkVWt3aVNKckNZcTE2R1VRakkyWUtDeXlUZktzZHhTVklmYU9PSWE2emtwQnErTkVoekR4MEU0TUozWEIzYjBLK2hHN1hXQzdpNHhQQXR2TGdlMCtVRnVsM2RhUzhDaW9hS3R6TmwyNjRNOG1TUjFpU1JydFpRaTYrbFAyKzA2SkZKVGZIN1Avd1ptOWxWSHhreGpGZUxDb3hOUVlkZmVwQ2dWa2g2Q0hRVWJLRDdxZS8vMzNiL0h0d3lWLzdaa2RmdVNoTVpkcVlYK2VlTHdZOFIrUEgrWlBuS3o0NWFOamZ1M2VLYmREWXQ0TnVMNm5Ha3FtVVJoajhFV2hWU0hnclNPYVpFcnJpR0syZW12cVFaOWtTREFZWlRXZlplMWR5R3c3cTlnclp4bDc5M3N5WGxzdnEvVCs4ZXJPeHkvTkRqZEt3UnRqckZHQXhsdGxtRm1qQzNqWlJ6YVQxL3kwenJCTTZ2WVNyWHJCU1JTYVZjUWtLQ3NkdnhWR1JTZHJieTdqTE5ickJrMVo4T0tjcFVrNlUyOWo0dUIwT0tzSDQ3cVB6dVZteUgxWXpDT205ZWpST1UySkVaTW5COW1vUHhyQkpWME1WbUNqOE5UVzBQZVJFTlZtQ0dzb1JoWmJHcnBremp6bU5SVlU1OXB0VUxZY2VRRXJFcS9xcXlTYVZpSkpNTlp5ZWpKdzg5MkFTd3BXRFVOTGJCWVFCaDNkT1VOUjFiakM0eXNWQjRXVTNYd3V4RXBiYTZpc1kzT3JabjYwcEpwV090V3dob2hrRXBKbjk2RVpjZWg1NzlWYnZQWE45OWgrZUljYlQxNW1OQzdvRVZ6bEtERFVSdjNJaDVWa3pqY2NyaEpkRUdZVEJRVERZQm0xbWFlUXkza1JrNVY4TUxXSnlnaHNHSUlydVJVTmk1blFMNFhOVmVCU0RKUUllMjNQM2pKUTlZbFNFcVVUWEJZOHVleENJeUdiaStSS1NMM2tzcWM3T1dCUmREUVlSSU1nTkhNOXkwK3pONTVTckRPNFd6dEcwd3FwdkZvKzlaYTJ5Vjh2Sm9vaDBBNDlmLy9kZmI1OVo4bGZmbWFQUC92aUpvOWRMbGllSnZZUDRkUEZqRTl0VC9qSzlnYi8vTjRKWHp0dE9PNEhGcXVXNUN6anV0QklwK3hTNjV5QnBPdllpQlJHNHcvU3hZKzh1Y09Ga00vekR3UGpDaVlGdnpjYlBYT2Y1SVBUNXFnSjhYWkVZbW10eS9wYWlyd0pCUzNOQjhsYTlPeUdlYnlNeEtpc00xZFlyRlBqQ3BlVXZXWllteEtxRjVqckVxVXhGRjZOL1l4QTdmWDBEa0hGRXNNUW1aLzJlS2RJWnVnVFEweTBYU0NLVUpXT3F2SU1TZTJvVWxRM0hEMXhkTmNQTWJGcUF2T3U1N1RUc3Qyc0cwbUVuZEp5bFBSV0R5RXBTNiswNEJVcHhtUU92REgwUVMyTitrSFZjNFV6aEt4OHMrNTg5aGxFeFRUV0dkNTZvK1hlQjBzbXhwT01rRkxQamVjdU05a291UHZlTVFkM0czeFo1Um0wdXUyYVRQSkpvclBoSkVEbEtiM2xVaEkrdUh0TXZUT2xyRHo5YXNBWGxvM3RHb3lscUQxUHZuaU54MjlzOFAyWGIvSHE5dzZZSDYyNDhiRXJiRjNld0Nmb1JSaE05bUcvNktpVFlENUF2MHIwQW0waHpGYzZaaHhQTEZXbEVVaml5U0tYZkExRktJWkVhY0dYY056Q2ZOdHpXcFlZWjNBaWJDd0RzemJnZzFDR3hIUVpxTHJFQ01FM1NkbVRBZEpjY0NMNElGUmxqa2VPUXBkOUJIM0k4bU9qZ0tITjVodHA3UnZvUUVyRFVXWFlIeFZzN281cFExSWp4OEtlMlUrUFJtcjdGVUpnNUJQZlAxbnhuL3pHVFg3anpvSi81MU03L05qREV4NjU0VGhaQmxKaitQTEdqQzlkbmZES1NjdlhqcGJzUjhNZERQZERZakRLeW14enFPY1FoRWFnS3AzdmsxUUNLNkFCR3RGZkw0WnJwZ3NNVlFBbXRXV2pzajkwTUM1ZHNBQkl3T3FvSGQ2OE1wUFRDcmFkTVRLcW5KbjNBekVwK0ZNVzdrems0TmJwS1NMNHNkTk1vU0NVUmcwR1lsUWY5Nkl3K2NUV3pkak1oYXJYRzlkN3BmTjdaeEVqakF0TDR5MnBqWVFZRVdmVnRUVHZKSi9IU3M1YjdUTnpydHVRb0dzSEZrMnZsVVlmT1cwSFZpR3hIQUxOb0hOMDFQK2Z3aW5vNFFxaGo1RXVDcXNoc1ZnbGl0SlNvNTUzTmhvS3J3dXNDM3BRRFVIbjNBREpRaHN5MnV5MHhCMTVyUzhYN3g0Ujd0NWk3andVWS9yUVU4U1NoNjVkUmFSaXZ0akhGU1ZWWFZLTlBDRnAxVUg2Y1A1dUxKMXVtQzVpVDVZYzNqbGk5NkhkN0lrdWhKQUlVUjFWZXhGMjlxWjg0Y3VQTTl2YjRkVnZIUERhVjkvbDh1TmJYSDdzS3RYWUUxeTI0cjdndFc1c05pS1BocUdCVVJ2eFRsbUM1Y3BxQU1kSXFFZVdvbGpMZ3NHWFdheUNZVEl4VEt0RXdMQVFRenRvdHZrdzhleFQ2RzJjREM0bVlnK21FMXlqeG80MEVacEUyVWJjM1lZWWhjMGsrRW1KcnoxRG4zQVJiQjhKRHNaUlovL09RS2dzcXlDODIzb09ETHgxS0J6MlBVK09DMndmbGVkUUdGS3M4aWd5TVJyVmhEQXdoRWpoaGFhUC9QM3ZIZkt0TzB0KzVvbE5mdjdqVy96b3cyTkdHNForU0xnT3ZqQWI4ZExsbWtVdkhBL0NtMzNnZGtnTXdPMCtjaklrbWc3MmhoR2p5dnJ0UzlVbm45Z3EyQjc1L3RuTHRYdHN0eXAyUnE0cUt6ZSt0UXp2LytMTHg3LzRILzJqOTI1ZkpPQ2xsRlYrdndlb3UyaUFEaUxRM0Y1MDd6eTVsMDRFdHEwM2pOQ2pPMWZJWjZkaUhJUTA2Q3k5OUtyOFdiWUJHWVMrVkpESVpCYi9rUHVwRklWKzBOdzE4bmhyNkpOcXpyMDlveGdXR0pMVjhWdENTN3QyaUNRRTZ4V3BiL3RBdXh4WU5BUExQckpvZTA2V1BTZnRRSmZSNXo3SjJRbDI1cUF2Q2dvU0V4NFlWWWs0UlBvUWFkcklmQmt4M2pLemhxblhvSVkyNjc2N1h2dnl4VXJsc2o0ekVVTFV6WDY1aW54NWE4VVZIMkVwL01pbkkvczNKaHd0aEx1dDVjNXF4UGMrV1BIZXkwZWNMQnNLWDFJNEhRMU90Z3A2QVJmVkVUZGtiWHJLdDN5S0Jxa0xKa1BnN2dmM3FTYzEwNTBwcHZhRXlKbFhueGpEY1orWUdjdlRMK3l3ZS9rYWI3MHk1NDNYdjhmQjdUZTU5dlFlTzFlMktFcXZJNitvU095WkJ0NGFlbXRwb3lhdkZBWjhFT3lRc0IyVXk2U2VnZGxCdDZxVm94K2kzclIxclVFS1hxQjBPUkkyNVRtZ0FTa2dGSVk3eHdPSHg1SFpUb0gxanRNVVdmV0MzeW13MjU3VnlVQjd0OFU3bU8yVXpQWnFyQWRwTlpaTHVnUWhVcXpERmtWZGY1ZUQ0S1lPLzk0SnpzSG1ScVVZVEVqRVd1aUhTTmNQZU84WWowY01JZEoyblZadkJ0NDY3dmhQdjc3UHI3OC81NDg5dmNrZmYzS1R6MTRkTTl0U24zcXpFc29BbDczbEtWUFNpN29ndFNrUmdzNzFUODBHMXB0aWF2bVRQdkZIWTVMWVJnbW5wL0gwNXY1d2UxVDcxWjFtNk4rODMxVWZ0bll6WW41SVRwSy9VNDhlTVNZaUVnN2FmajhrT1phczZ2Rk9KWjV0SDFSK21oMWlUNXRCYVhWZWJaaUdQcEVHT1lzMlZpTkhhUHJBMEFaeTZwYWk2MUdkYXhhTEhra3BHemk0TXhUWm92TEFBUzFuQlZoSm9nMlJZUlZwaDhEeHF1ZGczbkxjQmJxUWxCV1Znd1hrSTBoTTVweXV6RVhUazJFUTRoQzE5eDhTYlM4VXZWQ3ZOMC8ybmI4WXhYemFKSFdCS1Mxcm1YYUl3b3QxdzAvTVZvejZoSlNHVDcxUU1Rd2pUaHJMWVdPNTM4QUh4eHU4L0g3SEwzNno0YnZITFNGNkpwcytDNFhVK0dEa3laSFRhMDYvdm5vN0tka3NIUGRQVnh5OWZ4L25IY2FPYzVpQUVNVGxUV3NoQ2tVSVRMZmdFMSs0d1pOUHZzRFh2dnBidlBIYnI3SjErWkFyais2eHNUMWhHQlZubWZUV1cxeEtsSlZoTUpZQndTYWhNSUlmd1BlUjFSQ3hoYVVjZVVaalM3SFNERDZKWUE0VG82bFZnb3hUYnoxVkg0THhPcmxKZWRuTlBCUWpqWk1xS3RqWWN6UlRpL1VXVzN0aUdyRjhmRXpYSnRVSGpDeTJ0REJXOTV4aFNNVEJrWUsrUmpORXl1d2UzRmVlWTZPbXBKZDJLbzVPZW1paEtoMTE2ZWhLZjRidFRNWWp1ajVrSytmekpOcFg5aHZlT08zNHArK2M4cVhMVTM3aXhwVHJXeVhQN2xUc2VjZVFzK0hIbVI4OURZNG1xWWxvTUhCdk1mRE9Lc3hEazk1WWhYaDNGZVNONDFWNDdWdTMydmVhWUk2L3M3ODZmWFBSbk9Rak1DdER0Rlg3WVJwUFBJaTZyMjMreTN2ejl2YXFqMitGU2w2VUpDNVpxQXFISHlKRDFOQjVzY0tpRldwcjZVckxXbHhyQzB0UjZJbmU5cEZWcDB5MEVOUklzYzgxaVF3Nmx3K1NNbmpDbVY5MnpKRzJnb0pSU1lSbEgxajJBNVZYY0hCalVySUlVUmVqYUo5Y0ZaYTVSRFc3K0lpU3hmRGh2MDhYYXFXdUgyajdTRHNJdG91dzBtaW9wbFBuRUNQQ2NoWFBhS2xEMUxhak55cWtDY0NXVFR3LzdSbDVZV2l0UmdjQlE1dm9laDFCN3BXR3piMmFHeHNseis5NC92RXIrL3pLbTZjVW81S3ljbWZqcHk2dVZXUnk3dnBpRFg1YVVaWUZrMVhMeWQwVERwekRzZ2RwUkFpT0lnb2hPVTBVTFpXRElFMlBNemZadXpIaTV4NzZNN3orM1JmNTJ0ZCtpZS8rNWx2TXRpdDJybXl5ZlcySGVsb3AyODRhcXFnaXBNSVpUQko4ZHI4dG5NRTRoNndDdGsyMHdlTUwvVHlmUy84MnFkaElNbjNNVzVVNm4zbkZxZmdhNHd2R20wb1NEMUduQ01YWW5LMFBZeTJUU1VuaFZmcDE5UDZTeGIwVjA5MFJrMHNqdlJBR0lmWUtwSnFRQXgyR0JFTWs5Sm9GTUJsWHpKY0JUS1FzTFhYdDZZYVNGRldsV2RjVkc5UEFNS3lZeDZpdU8vbDFka1BpKzhjcjNqbHUrSWR2SExOVk8xNjhNdUtscTFNSzlKbEtKbEI0NnpoSmNOb012SGE4a3RPdWo3ZU9tcGRQanNOL2RudlZIMFc0RDV6a2ZyMi9zQVEvZEMrTkMvTkQ3OUV2L3BkRUNBWlk5Zkg0WU5XOWZXVlNyWnkxR3dCRlVyQW1wS2pqc3NxcXEyWWlSOVJrbjBFVGFadEFQMFF0dFFWS3IxRk9RNGgwdmZxWnIwUGxTNmQ5cFNhZ2FyOFVVMkxaRFRSdDBHZ2c3eGhQU2o3K3lEWjdteFhqMGhNRmR1NHV1RG9iY2JUcXVYMjhSR0xndEljN3kwZ2Z6ejJ6ekFQdnBuMkFmUlNUMEhRRHk2Wm4wZ1dLNE9uN1JMUEtWc0pwbmIyZGpRTlRUZzUxNW15VTFvbmx5bXpneWlnNzJNVHNwaHFWWEJOMDdlbU1Qd2dwV201Y212QVh2bER5dVNjYjNweE5PQjBYWjh5L0x1UnhZZFlDcklteExxa1JSK1VzbTFHNCs5NGhHTVBPalYzS2NVVVZOYmRjMDAyVWN1eU14UStCMndmZlkyTjZ6QXVmK1NSUGZ1dzV2dk90ci9MRzY5L2s5dXY3M0h6cmdLM0xVell1YnpMZUhGT05LOHJTVVk5MEl6c1J2R2dKN294NnIza1V4blc5TUdSekNHY045QkhwSTY2dytOcmhpc3djdk9BaGwzS0xvYmVYSHByaXpOa0JueUtJVVR3bjVUQ0ZrQ3c5bnNON0haMzErTXBESDBnWnpDVUlwZzJZUHRJdGV1WW5LN3B1alBVbDNqV2FDV2dOWldHcFM4Y3dPSWJCa3B5anJtdG0wMEFJTGF1NW5OdGtaZU5LOGZEQm91ZTlCYngyMnZKYnh5M1RjWWtWTlVueFpVRlplbHpobWE4NlZuM0V4TUVjdEgxMXB3bkhRTHRXQWx5SUtRL245cGo2UGhUV2NOcEh1VDR0Zm0vSGEraTBKdHhiOVc4OWF6bDBoZDJ3QnNiZTRVUkhYclZYaVdyTWVWWktkaEdTQ00wUXorZmJhOGxsM3RVcEpId1VMY3RGR05yQTBBZTZFRm4xQTEwL3NCb2l4MjFnM2tjV01iRTdLZm1MWDNxQ3l6c2p1cGhZdG9IdjNUemw3ZjA1OXc1V0xOcEFsNFFtUkN4Q1pZVk5vOGRteWovc2VxTzdDNkVqRjVTVmlrU0d4TkFOdEt1QjBjZ1RuV0VBT25zZTJXUFB4bndaQ1JlRFNZYkJHTHdUbmh3UDdKUlJPZWRaYlJ5anByMUV5UlRhb08rSEVXMWhLdTk0NGZLVThqVHk4c0dLWm50RVNqb3lsSmduTG1tOStCUEZZcUMwaW1WTUNzT2tDK3kvZlo4a2thMXJ1eEJya0FMSlg4TmxFSzhTaSswRFJ5YzNhWVk1V3h2UDhLV2YrZ28vK21OL2hMZmUvQjdmZWZYcnZQM085N24zN251VVkwZTFXVEhibkxDNVBXVzZNOVhScHplVWt3SnZMZFlJcGJkMDNkcU1VdkRlNm9nd0NtRVZrRjRvTndxS2tlcjhvekZuZ1pzaWN0Wm1yYjMvY2VkYlFUbjc5a05tbEdLaDNoc2hTWEdTWnRVcDVUZnF1SlNZc00xQW1IY2NuN1EwaTQ1dmZQTVdUejIyUTFWYmxvMSsvYkowVkZXaUh6ekRvTGxzUmZLTTZwb3dEUXpEUU45dzVpemI5VnFpRjNxdTBBZGgwUWJxY2FFZ2RJcjRaSW5SVWp2TldLOEtLMFZaY094YzdVeFVKZ3dmTXB0NGNMeVcxcXE3cjk1WjhzeE8vWHR5bzUvMzZjSUFsRy9lWDd6MXBjZDI3b25oTVdPaHJCMVY0NWl2QXIwa2ltUm9VK1NrQ1NyeTZPTVo5ZkdzVERZcUJSM3k2VTJPTDJxN2dkV3lZN0hxV1BRRGl6NXcxQWFXZ3pDSTZvdXpmUmhoTmZEUFg5K25zSERudUdYUkJsYTlqc0tJaVRPTHM5eUFyN0t0N1RqSFdjb0YvOEgxV2xLTGozTUhnQ2dRUXFSdE8xYUxqcnAyU2g4Y3N2bEdqcHFLbkdkb3UxelNwaVMwMGJCVkpoNGRCeW9ndEd1OXNtRTFHSmJKMFlkc2tCRDF0dklHS3FQMDJTRUl6WEZISHlCdDFqbGFTb2s0aGNzcHBKbHhFWUhhKzR3M0NIdGp5ekFQM0gvbmtCZ2k4ZW9PSVk0cHhpVmUxQnJhV2t0bmhkSlpSaUtreFp4bTlUVk9SKzl6YmU5VFBQK0pUL1BreDU3bjZQQWV0OTUvbS9mZWU0c1BicjNIL3V2M3VCWHVVODhzNDQySzhXekNkR3RDTmF2eGxhZk83VWJoTFlVMytDQzRrQ2djK01xVGJLSWZvREFwVHp6emRDRGtWRjFaTSsvMGZUUzV1ck1XWEdFeFZxL1ZaTmJjaXh5eExKRGlPbEUzVnk4aFl2cElYUFNzVGxhMHE1N1FCOTY3TmVlM1gzNmZGNTY5b3RoU0VncG5xU3RIMzN1NjN1ZTBJS0VxUytLb1p0RWxoaTVtZzhyTW9BN3F2YWZjZnBWaWh5RXFvVXNaT3FRUVNQbjFMWnFCV1E3YndKeHQ2b3NmU1pWcUlpTG5CZWI2OTMvNzFZUGZreHY5YkxOblYrNTRmOVVkZGtsdWg1aWlNOVpoelptVXNBc1I4UTZEWWQ0TjlFRmRZQ3FuUDVYZUpwbk9tbEVGeWFmMXN1azVPbW00ZDlKdzFBMnNZbzVUdnFDRHVBaWlEU0h4bTI4ZmFLMlR2MWFCd1hHZUt1VFBBVjA5MlM4NENjdUhlaFBkMUlZMXdlSDhoNDU5SUxROVE5T3ptdXZQMXZmS2VMUFpTc3RxR3FMbWZPZjBFUlhEd0dPYmtVYzNnaDUyT2NvcE9iVnVIb0p5QTFKVVIxb0RtS2pWVFRLR1JSYzQ3aU94ZEprS21tK3BUQVFKU2NrWUpzOWROcWNqN01FeFNaUW9jM1hxdURtUDNILzNpTDRQYkY3ZVpySTlveFNVS2lzQjV5MngxTENMV3FBY0FpZXI5ems5dnN2Tzd1TmMyMzJSSzFjZjV2cTF4L2pjajN5Wm9lKzRlZk5kdnYzdHIzTnYvejNtOHlQdXZYSEVyWENFTFlUUmxxT2VqUmhOYXNhekVXVlZVRmJGMmVZdnk0elZPS0RKR3pzcGhoTkU2YzRwS0tIS3JsMGNiTUxwbTR0TCt2T2ZQYjlNZ2lKWE5qTG9WQ1VPQ2JwQWJBZENNekRNRy9xVjJtdTNxNEcyQ1h6N2xYMCs5dlFsaWtMMS9jcUJzRlNGcGZLTzRDTEJXZ3J2cU9xYTZUUVErNVoySVdkVTNUQ0FxOVFYTDBSVmM4NFhQVnViNm92b1ZPTkRUSWtZTlBuRldveTN0bmJXbUJqbHdaczhpa2o2Q0pQVzM5TUFCM21BdlNNaU5POGNyNzUyZFhQMHhTckpaWkpRR1VOZE9JWWhzczVOR0dJNkE0eVU4cU1lN1RGQkh5T3JybGNGVm95Y3JqcnVMWFVVMXEzbGhCK0JESm9MRVJlYUNTZ2ZlaGRzN3ZmaWhjKy9pS28vaURKZVJObk5oYjlMYS85ZHB3dE5oaUZIK0tpUlpWVVZlbU5WQmwvWWJPK2pOMUFRdGVVZElreDk0ak9YQTFmR1F1b3lVNnVFMkduT3V5Y2hvb3kzbEYxUkE0WSt2NGR0bXppS1FwOTN0UTM1UFVXUmJEbXplVEZRRjFTbHd6bEx5aGlJZDRhOWlXT1lSMDV2emhtNmdXN1ZNbTAzS0dkamZPV0l3WktpcGM5QVh5MEpINFRDZE56KzRGWHVINzNMM3ZhalhONTZsbzNSTmNxeTRybm5QOFVuUC9WNWpvOFBlZitEdCtpYkJvUG43YmUveDF0dnYwcG9lazd2TDdqZEhvSUpGQ1ZVNDRLaWNGaHZtVzV2VXRXYVFscjQ3QVphdXJPRE9BNWE1cTViRkdjTlJlRXdoYWNvOWJCd1RoT0JUQXlZbkUrdXQzaWVrTXhid2ttanJVQWZDYXRPZGVHU21DODZVa3JjdW5YS3QxKzV3K2MrL1JESGZVOHl5b3QzVmhXTjNsdVY5RWFvaW9LTmVvVFppQnlGZ2E2Uk14K0ZtSlFQRXZPQlBXOGlzNmxPQkZKU08yOUpRcEowN2xFUEtTVUpGMmptS2VQTDZRRVQ3ZCtYcEphTCt5TGtaS0QrTzdkTzN2cjhqZTI1ZUhjNTZVc3pMcGVQTmp0cXBENGhLWkdzcFNjeFNHVFZEVFRkK2ZoclBrUzZDRjFPdnZnb1JKd0xSdlBsQTluT3lJYzM5ZnJmT0Q1TUt2bWQzclgwQU5wK01kRWxXQjM5RUlYWUR3eHRxMk1tYzU1Z1lxMmFEL1NKbktsanNLSWtvU0VabnRxRjUvWVMxZ2l4elg1YmhhRk5oaTVaQm11MVJjaGVkNnBzVU9SekNNSmhFemsxbHNXUXNDZTlnai9ac21sWXY5NU1IL1pPeDNtRjk4U29TUzRZdzZRU3JnSjNGNG5WdlliUUJZYW1ZN2E3UWJVNXhaZWVXSHE4Vjh1cmtCZENsY0JHNkE5UFdjMWY0ZTdoTzF6ZGU1cXJXODhRNGxXZDhWY2pudm5ZSnhGSmpPcWFMM3p4eCtpN25oQjY1cWVudlB2dTY3ejU1cXNzbXlYTmFrNnpXakwwZ2Z0dkhHTk15Rm5uVVV2ZlBFa1J6bE5SaTdMQUZRN25Dc3BSeVhoN0FwUlk0ODlzb25YQ0hNOE9Cc1YzSXVHMHBUbGVRZFpYU0VvVTFuSjAwckZZS0gyNmJRTmYvL3B0WHZyNE5YWjJSdXp2TDVXeDV5M09PUW9mR2J6RFpnSzlMd3JxdW1aekMwN2N3TkNxRCtFUXdEaWg5QkNDSHRDckpyRGgzZG1DU3FJTXpXVXo0STNGT1d1dHRVNkQ0aStHV1B6ZXB6TDlUcWo3aFZ2ZFJKQjAwdlJIM1JCUEpvV1RtRlZuTzlPU1ZhK2U3R21JZE0xQW15TFJDWXQyNEhEWmNkSU1uUFlKalZ6K3NFeHVMZG01dUZuTEN4c3hYWkR6UERnU1N4KzI3dnJJdHl4OXhLMSs4VWEvZUJna0I5UUtzbmdIS1FSQzF4T2NwOC90Z1NMZVdTV1hqUVRyczFRVkJSYWYyeFJ1VElUVVhrZ3BSWWpKS2g4Nys2S1Q4K21Ta1d5MUJhRVhqdHZJcVJpNkptQ2JrQmUzQW5Ecjk2OXdhdDZST3FYbDlVRnljSUNPdXpDR2lRazhXUmZjV3lUdUhmWWN0eWYwVGN0azNsQnVUS2htSTZVemx3NWZhRHlVL2d6Z3hXQTdpUDJDZHhmZjRIRDZObGN1UGMzMXZSZUlzazNoYTV4enJOb09KRktYRmJQWkZsY3VYZWVaajcyQSthTS9UNGlCeGZ5VXJtdUpNYkovN3hZaDl2Ujl4K0hoUHBCbys0WVlBMjNYMHZjOWZiOWcvK0FtZDI3Zm9Sd0w0NTBaOWFpa0tMd1NydktobDVKdVlpUGFrL2Vybm03ZTBqZTllaVlQRVJrQzNqdWF0dVBPL1FVeGFvQ25NWEJ5MnZHMWwyL3pzei96Sk1QZ09UNk9GSVdsS2kyUy9Gbms4a0JnVkhtY0d4TU5qQ1hSMjBEWDZMU2xyaXkxZzZONW9vdkNmRFdvV1dkWjVCQkh4U0ZpRUNTSktRcy9xVW8zNm9kNHRKNlMva0hFSnY5TzgvUUFNTy9pL3EzajVwV3A5ODhtWk5URnJBZ3FQRU92STdRbURCdzBIZmVXTGNkZHhKWWVjUTVUVzZvRW81U3dTY3Y1ZVZUU3I3bWdpL1g1MTdOd2p3YzJhbnhnc3o3NCs5L3B4RElQNkhMbFFrK3ZtQUdZRVpUMWhaSStSa0xiNm9BekJHUUloSDZncjBxS1VZRXROUTh1R1JYT0pHUFlLZURwRFNpTU1QU0tLcTlqWk5JQU5nb3VDekdzT3lmQkdGRTU2NnBMSEs0R1RpTDBtVWtvb3IxN1JEZTc5eHJETkRoRFhQVmNMUXZHcGVkME5hZ09JQ1Z3amlqQ1Z1VjQrTVltTDk4NjRmWnh5Mm5mMERjRDlXcEZ2WnhRVlJWRlZlTEhKYllxS0x6VjFGaWpKaGt1ODhtSDFTSEhoNy9CM2J1dmMvWHlNMXpaZTVaeHZVSGh4MVMrcGcrUllibGtzWmd6SG8ycHFocnZQTFBaQnBQSkRFbkNsU3NQNVV4MVN3aUJmdWoxbysvb2g0SGprME8rKytyWCtPNTMzK2IyN1RsWG50aWwzaHd6MmFxek9hVlNhMU5ta01nUXoyS1grbFZQdSt5SS9hQ2diRlF3TDhiSW5Yc3JWcXQ0TmwwUmdhNExmTzBiTjNueWlVMmVlV29YYXpzT0RsdjYzaEtEcGF5ODhqZEVjRW5McVhvOElzWkVhVnFjaVN3V09Vc2c2K2tIb0drVFhSY29Da2ZDUWtyMFFWTjFyTFZZWTZ6VkVENWxrQWsvTE9MYnYvR05mZzdJQ1VHem9kUEpXd2VydHg3ZkdyZERsTkVxSk9aTlI3TlVSTE5QaVpPMjU4NnlKem5IczQ5czhZbkh0M0dWbyswVDg5WEEzZjA1aHlkekRrODdRcU5CaWVGQ1Q1MHVlTjZtQjI1bzh4R0Ftbi9ndHBlUEtFbDRvRWo2Z1Q4N1lBUzJVcU5JWi9QSUp3cERweWFUcmgvbzJ4YS9LckJGb1hQU3VqakxaalBlRW96anNldU94N2JMTXl1bndkaHNUS2toaUwwMzlJT2xGOFV4S2c4MnFNNDhpbkRhQk80dUJrNWlKUFJEemg1ZnErK01ac0lWbG1EVkJhTS9iWGpqZzBOaVZIZFg0M1FXSmFLMzNhTHB1YlpoK1B5ak8zeWRJejQ0Ym1nT0E4TnFRYmZvcVdjMTVhaWlhR3Y4WklTckM0eDFTbGJKVVZjK0pVcUJlckFjM3QvbjhQNTkzcHArblozZGExemRlNHFkalVmWW5GekIrNXFJb1IwQ1dQVUJHRlUxR08yblk0eWtrSWdwWmxjZ1VUZmh1aWFFbnR1MzN1WnJYLzAxYnQrOXlhWEg5M2pvNmF2TXBpVmxhYlBLS3EwSHpJUldneE9ITnRBdk9wckZpcUhyYzN5VTh2MnRzeHd0ZW83bm1ndndvZWR1NE9TazQydmZ1TWVUVDF4amM4TXhER3FoUFF6S1BaREtaOVZlb0RUQ2hBSXpIaEdzSllZV1ozcE5DZkxLbTNlWlBMWHFJcU5SVW11dGZLbGhMREZGckMrOU1hYjg4RklWL2lBM3VseTQrS0phUVZLZXRzUE5way96THFhZDFhQXo3NlBGa3FQVGh2dTk2cGl2N296NW1XZXY4ZVRlbEkyTmtrVktIQ3g3NW91ZU95Y2RSNmVCb2RmOU5jdGpyL1RBNW55UXFtb2U2TWZOQStYNmd5VzYrWWlEWWYzNThjTERwZ0JUZzZzeUVlSkNPS05rQlZrY2twYnhUdnRyNHh6V09ZeTFXT3R3aFVlc3BmS1dUMzk4azRjM2FsS25wUHdRRE4xZ0dKS2x5MFNaaEtoaFFoQXNhbHhvalpwanpOdklRZE55MG5YcXVZaWkvQ1p2YkpQemlGUjZhekhkZ0I5MGpLZjBWMlhnU1loWVkrbkR3TW1xNWVHOUxUNzd5RGFGZy9lT0d2cWxFSWVlb1IzdzR4VitWRkUwWStyUkNGTjR4Qm1Ld3VPOW1qTTRvSkZFblFRbmlhNmRjM3g0eWdmdnZjbDB1czNWdlVlNXZQc29zK2t1czhrdVNiYUlDU3BmcUpXWTg0eEhVNnBxaEVpaTY5V3JYSXh3Yi84Mi8vSTNmNW12L3ZhdnNIOXloK3ZQWCtQU1F6dHFCMVk3NWExbnkrQTRxSDIxREltK0hlaVdIZTFpeGVyNEZDT0dzaTZ4UmdsWmkxWFB2ZnNOdy9DRGFJMWs1dVdiYngzeDJ1dEhQUC9NRGh1elNyUHNRcE1QV0syMlJKUWxVNHZEbENYTElVSUtGQlgwWGFKZG00RmFaUzh1bXNSMEZESFdnYlAwUThTWDlpejhNaSt5c3lXYzE1ejVnOTdvK1ZhWEFhamVPMTY5ZnJUc2IvY3AzcGozZzJtV3JUbGFkTnpwRXFkUjBjc25kcWM4ZlhXRCt5Y04zN3Q3eWx1SEMyNGVycmgzMnRMMDhhekg5aGZzYk1JRllJd0hOaklmdGdvL3MrRllmLzdGbnY3QjIvcmkxN2xZSVJpZkxZeEcra0xzQlY5eVlXM21sdytnYkZPVlFrU0lpQmx5cjJmT3dLOGhHWjYvUHVZTFQreGdYUVpxMXU2dnp0QXZkSjRlbzgwMjE0SWc5QWs2c2hGbUV1WmQ0TzU4eGRGeXFaeHdMbndmYTg5MSs5YWVIVzVQakR6YjNuTnZwUXQwdlpKTjBwbDVNd1NhTGpBcFBKKzZzc1hJV2Q0K2JsZ01rV0VwaEQ1Z21vQmY5Z3pqaHFJdXNkNFRDbzh2VkdCaW5hVzNobFdJT0pRQjZBellaZVQ0OENaM1B2aUFVZlUxNnNtWWpka09sM1lmWlRyWm9mQWo2dEVJNXl4bE1RV2pvN1hEKzBlczJpVkpCcjc3M1pkNS9mWHZVb3dkano1L25YcGFNeTRObzBJeUhWYUJ0Wml0c1FpUkVDTE5vcVdacndpTmhsWVdSYUhQelFpTFp1RE92UlZORTM3SGhXOE1IQit2K01ZM1ArREp4N2VwcXBLdERlM05ENDVhQkUzMmtaUm9zdytlc3daSlVZMCsxaGJiVWYwSXE4S1Mra1RYSlZadG9DZ014bmdkLzhXaytJdzNLYVVNS2Y1K051ai9PcVg3bWtNQ3BNTlZmM2pVRHUrSG9YL3BlTm1VSjZjdCs4dEFKNW9jNTBRNG1iZjg5aHYzK083dFU5NDdiVGxvaDdPWTF2SUJJQzE4eEVqc28yaXE2WUZibXdmK3JyandnOWdIQ3FJUENWZ2NtQUxjQ0V4eEh1TjAzcGRMUmlRMGdzamE5YVpjV3huTEdZSmljbEJoaUdDUzVYT1BqSG5ob1pyWVowbUNnYXBLdUVHSk1rWXkxVmM0aTV3ZVJOdVhMZ3FyWGpoYUR0eGZ0S3lhWVIzTnBpaUp1ZWk3WnM0czFFbHdPSzdZMlozaGpLVlA4UnpGenNTYVpkK2ZjUnNLYjNsNlo4TEVXZDQ2YVRqc0FxRVhEVURvQmtJVGNFV0xxeDJtOGhUZVV6aVBGSjdDdXpXdWVCNW1LWUkzbGdLWW41d1EweUdKOTZtS2IxUFhKVlV4WmpTcXMyTnVUVWdEN2FwajZBZFdxeVZ4Q0RSZHgzUnp5bVJyUnVrdFJReDRjYVNnSVlxK0VHS0l0RTFDK2toc0I1YW5EYWRIYzBMWEs2NVRsbmluOWR2eHZHZi9vR0c1Q3YvS3FuZ3RUMzN0dFh0ODU3djMrTnluYjJBb3NiYWs3VUxtSlZoQ2pEVHRvRHIzR0hIVzRndUhMNkk2SGllb0tvK1lsT1hCMEhTSnlUaUJDV3JVR1lKSnlWQjVWMWxuNm84b1RQOVFiUFIwb1h4M2Q1YnR5MlhzZnZyKzhhbzZYRVdHdk1tTC9PYTl2Ny9ndmZ0TGpvWkllNjVsVU4xM3BvNzJuSWQrWEp4cDh4RWwrSVhJN3JOYi9JRkFrTFBlM2w0czJmUG1pT3MwVXBTajdJcHpQcEl4dWhtVTBDQm53UVBHWHZEQk51YkMwemhYQ3A4L0tXRnJVdkNUejgrb0M4T3dTa3FTeVVrdWNhbWtHWTlReUpwR3k5a2hFNklRQnpoWkJXN1BXMDY2b0lkSDNsRHJ6ejB6V3N6dVBaTDFCc2NwTUd3bUNxdEt0dytKSEJNTUtiSHNPeXJ2Vk1NdmhxdmpraHJoTUFydnp6dU91a0hIUVVGSWZTQU1BZFAxQkcrSjNpSGUwVm1Mcy9aY3Yyck1HWC9DNWtQZUdmV1g3NXFCNVhMQW10VzVJWnpSQ3NNN1IxbDRyTlUzYUZTUHRTcnFlb3JTWXIxU29QcVF6dnpqaGpiU3JRWkMwOU9jckdqbVMvb3VSeFRiOHdybitLVGwvbUZMMThaLzdRMXdjdHJ3OVcrOHk4ZWV1c0wyNWhRa2NYbHZES3hvMnNScTJVR0tGRlZCczlMMTRJeUdkYWFrQVIxaWhQSFVJNUlJUzlWL3FFdzRFRU9pcUpSOGJRUnZqYW5NMmsvN0R3a1l4NFcyTm1Rak8vZis4ZXJWUnl2NlpaZFlKcVM0UUdoSktqczFGemJuV2FDRjVMTGdnVkw3TElRaVR4OS9nUGppUGdLVXV6aDZ1K2pOc3k3SlluNVJGLzkrVGNsTk1Sc1Btbk9tazBIT29vV3N6YVh2MnJVMGM5Zk51aUpZYTdXejIybE1oc2N2Vlh6cTBkRzVwM3BTcHhZSjZpbTM5alN6SWpqSkFvSThHL2ZHMEVuaWVCbTRlZHF5Q1BHTW03Qm13NjIvcHhIbGVLZDRiZ1hVb0thZHBYTXN1MTZWWU9hOGpra3BjZHcwYkk3cVhOcnE0VEZ5bGlmR25yMjY1SlU3eHh4bHd3UUVwRmZOdjdpSUZER0RnY29oc0JrY1hOdHNyMGQvT2dhM1dhV2hDYlBrTWF4MUZtKzlTbmdsMFEwS2tLbFBZSUYzMmVaVFJFa2JJU2tsTmdtaEMzU0xudFZwUTc5cWFKY05xUjl3MmR4UkRVRVRKeWNkQndmdFIvYmtINXJMdWd1TEp5K3F0OTQ1NU9zdnY4K1hmK0pqV0dzWTFRV1RzV2YvM2pGSGg2ZnM3RTVZTEFKZE45QVBtcFRxbmRNOFFac1kra0FqVUk5VTdqcGZhUW52Yy9LdnFUTC9JeVFUaDJqejh2cERWN3F2MzVZZWNIY1czVHVqWUg5MUZmalQyVS9BY0VGbnQ5NllVZG1hQ3dNSHVTS1lkS29IMlBRd2loZjgvTlllRnU2OElsMGJONTNKTytWM3dDY3ZzdWNvTkNVMEZibDZGaVdBWktCWEx5Sjdic1FvT1NmdURIbE11c2pYRGIzSnRhcmhCNHN0VFRoVnJmMEwxOFk4dEZXUStodythUGovY1BlbndaWmwyWDBmOXR2REdlNzA1cHd6SzJ1ZWVxcEdBK3hHazBDREdFaUJBa1dRaElTd0tGaXlMTXRpMklxUUZlRncyUHJvNFlQRDRYRFlZWWNzaDhNTzIvemlRUklsVXhJbkVSQUpDc1RjYzNWWGRRMVpWVG0vOFE3bm5EMzZ3OXIzdnBkWjFTUVJRUnBndllqc3JINlo5ZXE5ZTgvYWU2My8rZytiRGlGRnRYa2hYWEZoWGZjSTJvQk5jb29lTGgxMzV5c1NtYVlxVE1CMWNmTmtORSsyNXhjbE9uSG1QSHVqUnRSaVNyN2pqVUlpaXhxdmQ0R1J0YXhQc0tTZ0d6ejc0NWJYdGhvK212YzhTSmtGNS84OUVrUW5KcGdaU0ZyWWptdXJySlRWNWtEVVJteWtXU3ZQUW9JZ0pCN1RXREJac3VqV1ZHZ0ZUVlZqakpYeFNFbjN3UkR3UGhLSzhDa09EcmZzR1ZZOXdRZHlpbGhWdGxNS1Z2M0EyWmxuZnVZM0xqK2Y5S0ZIR2p1V3RKNFFFamd4Y2xJUlZpdlAxNy81SWMvYzNFYm54SjMzN2pPZmR6eDh2T0RHcy92czdVMTUrUEFCWGUvTGlHQXdNWkcxcFB5bWxGbDFubFFaUnEzQnVVdy9SSnJpcXVSZElJMHFwUlVqbmZKVVBjblYraU54bytjTFh0TWVzSjJQSisvNStIOHNZWkpmMDdBdDB3aGRnbm1FZHdPOEhlRmhoRWRyOFppR1Zsaks3Rm5ZeW5CTncrYzA3Q3VZQXVQeXZGeG80MFdMSHJoSWUxVWIwR2tkcFowcnVXMXpoYVNEY0NFS3JCZ2RwQ1JmWENHbnpib3QzcVNhckpsdmRTbWllUDQyWk03enhIU3BsUlJoOEpudDF2S1ZseWJZVmpHc0locFJjMmtOeTBHelNocFhUQ0tkRnFycm1peWppNFBwNEJPUEZ6M3p6bUhEdWNwdVBZSnNEcnE4NGQ5STRSZGh6UEhLczlmV2dHSndRVkI1b3pkOC84RkZ6bFk5N2ZaMGMxcG9ORDU2T3VmWW1qUzRmbURrNGJIUEhKbkNZOURuQ3I5MXluVytrR08vL29ZVTY5ZFBDallXaTJpankwRVFFeUVMN21DTTJhVFpVbWlYYXIwTmNVRldtaUhpZkNENXdsL3dmZ09RR2kwYWVSOGpxM25nN01ReDlQR0gyeTBWZHBhdVliclRnakYwZzhQMWptZ0RlU205NmdjZkh2TlgvNy9mZ0p3NVBWcFNHZmpLVjIveTJUZXVjWHJzT1QzcnFheWxyaFZETHdRbFl3eFZwZkhPTXlpeEh4dTFsdEVvcyt3RHE1VXFKTGkwZnFqYkVOTjIvaU0yb3orTmU0V3lEV01GYjF2NFg3WHdYMlI0UGtBVjRYR0N4eDd1ZXppTE1PUW5CZlVBeWdtL3dCZ1kxM0JnNExLQ3E4QkxGbTRZMkZad3RXN3RqcmE2WHE2OHJJcUt1MHBFWXBCc1ZkN0FTbTQ0TGhBaW51Q3ptM1ZFem5tQXdMcU5NS1dRZERrSTFuOG5KNGo2ZkNSWHhmM1YydUx4cm9wdXZVLzhzVmNuL05UblpxS25yelFxQ1Z3ZUlneWR4bnVSTThaaXpoVXpBdGhGYVhFSEQ0OVBQWGVQT3BhTFVJQ3hjNHdnY0Y1a1Q2UEdaT2tHVmdnUWROWm5IcDE1cm14VmpPdGlkbEhVZG92QnNST2lvT1dVL0x3TWZlOW9SdzNHR2xybnVaU2hkWEFZWVZtdnVmOVBIdjFyZWFteFpSVlplUHZXckxFUlFlWFhBR0xNcVlBb0ltd3hWWVhTbXBBUzBUbHN6c1FReW5ZamtWSWl4U0FkMmZwZzBySlNqQ216V25tV0MwZTNpZ1NmUDlhbUt3UFZTRk8zRmNySUdrODNscXB1YUVZdGRSTllxQVZESFFqV2swOEN6a1hlZmY5NDgyVW1rNXJieiszeHpMV1d2L1c5UTd6TDdPMjFER1ZzVUZxTHZ0OW9uUE5GSTUvb2ZYRklFZzhnaWFJQ3BaVk9HV1d6VXZ0UFFWT2ZKTS80UXluMGZHSDl2UGxjZ0ErWDhGREQzeXMyWU92d25hZHhzbytCNEZsNElxY0JIZ0p2SzJHU1RrcVI3NDlhKzhKWC85eHpQL2ZLanh5OHNaeDdYZGtTRU5ncjN2N3VNZC82dlk4WXVnN3psRC9PcGxEWFhPTUxOK01HTVZibkFRSmFzOG5LS3VwQytUcjZIRUNVQjFOb290Wlc4aWFYTjNVeWhSOTVkc1pIOXgxLy85dExWSWJ0VVMyeFBmc1dsVFUyR0pJU0d5d2RNMDJTRXpEcVlyeVlFeWRMejRPVGdkN256ZHFSSC9MaTVVOTRjNVkrTWg4Q1kydVkxSnBScFVzVWtxenhLcU5aRG81dThFeWJ1c3p4VXV6ZUpWYWR3MVFWS0k4QzJneHRnRkZoOEozVzRJb09SYW56MktlTDg1UytjRGZwQzRTSHZPbk5TdkJGeWlqdlNzNjlqQVFoZUh6WmYrY2tuek1GL0ZQbEM3dVU4YXVCMWR3ekZBUEpYTm82YlJYVnlOQ01hdXFtb21rTXpiaW1ibXNKdC9TUkhDUWlXOWNWNDVGNDVtdm42ZTJBQ3d1WXB5ZWU4cTczL00yLzh4Ni85YnYzdUhObnp0WExNL2wrME5qS1VxZFVPc3VNdFFaYko0aUtyZzgwV2dKTTZzYmdjeFFGWXNFdkswMmp6Z1dXRnhHRStJZDlvMzhTeVN3aDgzbUkwUDhRWjZiNEQ3RnIweGZjTmVvc2hpc2hDazYxZk82MS9lYnpQM1hEUFB2eXRoNThMZ0dCc0ZwbERsNi96TUdsS1YvL1c5L253VkljQWJRK3Y4bnpVMnUyOVg4MWxlOWE1M1BZWHFrbnkyYzlHcWpTbGlvdGxrZFZWV0dyR2lYeEt5aWxxSURHS0g3clcwdCs4emRPbUtxYUxTdEwrWHU5NTlLTzViUFBiMEZqMmR0dWVPMzZsTVpvY29waTloZ1RQc0txVDV3c0hJZkw0WHdjZVJJcitrUXc4dUxOUHNUTWNvaGMyYXBSdWtaUnFLS2JHVCtUVldibEhhTzZrZ0JBbEdpbmdSZ2psYlVZYThESGpUTm9sV0hzb1E2d3FxQ3owRnZSQmF6MUNtdEFoY0srRlV2d0o1RldWZHFQa0JJcUp5bG9yU1hwaDNWeVFjbHFTNm5jbUprWXZVaDdmYUJiUkVKL1h1Qm1yQm52dE15MngweDNKb3luRFhWVFNYcXMwZWNwUHNXWGNGZzVodDR6QUthMmpMZW41TUdETlVRM0VNTUF5L01YT3NYTTk3OS9qRkt3c3oxaWE2dWw2MzI1eVRPK3BQQW9GSlcxTk9zMTRKQlFsV1pyVkpHVnhwcEkwYm5rS0NrZ3pWTjhyODJIWVAxL2VETzZldXFDV1lQai9vSjZWSDJDbGlRL3RTM2pxUjl3WGVoK1F6M1BXRzFVL2RrdkhUeC82ZXJvV1RkazdyemY1ZE5qcHd5YTZYYUR0NVpMT3hNK3Q3ZERHK0d4ZHl6REd0bzdCOWMyL1pBNm56WFZCYi8xTldxKzVsK3JDeUNVa0ZTa1ZUVEdZR3lGc2JiYytPSjNwNDBtQW0vZTcvaGlxbmhtdThFbHhjUllkcHNhdDB4OC8vY1hQSENPMHh5NWZXUE02eS91OE5sbmQ5aHV0YUR2cWRCZXo4cDgvZ2xNUC9WRDZMMmJRaThFbkhrZnVEeXJxYTJoYzNFeldPZDhUaEErWFBSc3Q2Tk5PMXg2U21LTTRnNVVXOHdRMGNVS2YrMDhxekpNSFl3ZCtBb0dBOTVDYndSeFZXdi9lZjNrQVpUWHE4bXMwRXFNUHRmb3ZhS0VaOGphU1Z4QXlpM3BmYUJmUlh5ZjhVTXUrdlh5ZFN0RnU5dHc1ZVllbDIvc3NuZDV4dlp1UTF0cmtZZ08wczRIbHdybE50TWpldlJ1UGpCZkRuZ0ZWYVVacTBvT0F4L29mQ1k2VitKL3p2M1VTSERsMG9SUlcrRmN4T2hJak1MMks4a0JKQjFsSGkzYkJ4ZmdyTXNNM3ROV0ltSVNzRGNwVXE3THB0bi9VWnZSODFNWDQwWEU4S0lnalUvb09EOVc2R3RtWjhGZ3pGUEF1WDMybGYxckI5ZDN2dkRCKy8zV1c5OTdrQmZMcUc0OXM4MTJvd2xEc2FqcUF3cTRQaGx4cTU1eFo3N2d3MFZIeUFsOTBTSktuZDg2V1QzRnVsdlBHYVd0MHB2aVZtaHRNVVlZTTVuTTRCM1pEWXdtRXlhVEdYVXRoVDhlajVuc0IxN3NGYW52Q2NjbnJEcFB0RlphWnEyNDJkUnNENDZUOTViODNic3IvcXZmZmNnckwrengrcTBadStPYXc0WG53V2tuNFlsUGNmYy9xYkNmdnVYWEI4TWlpcnF0MG9wdTgwYmtEZE12Ui9FQldEakhkbFhMVGF3TGY5NEhuUE8wVFkxYkJiU1B4ZFJENmkvbXpUbEs2d1ExVFVYeHQ3UXdhTWtYU3FYWTlZVlphZTJRWTVTQWxPdlhlQTBvcHBLZ2k0K2trT1hXZGlWSVU4emtCSkNzRmUzTXNuVnBpMHZQSEhEejloNlhyNHdaenl6Ylc1WnhMZUNmN3lPckx0TzVoRnNFZk1qNGtGaU5LOXBKaFhxa09KMDdTV2RwSzFwanlER1JuS1ByUXJHak9uY25xYXptMHNGRTJuT3JHZHg2elhnK1dwdHMwY2FWbENFQkdIc3ZETXBwSzNNNkdaVmpVc1VvdGliVFhYd2M5UitCR2YxaTR1MzZMb2hQMGtjK1JtYmJmTktXc1ZpRENnb1ZDK2o4RkFkbVRXUEpTWm5yZi9kWFAzeE9FZFVMTCs3bHozL3hDcFd4TUVSY2VTaldsTkhUcFdOTGFWN2FtckZ0S3o1YXJqZ05uc2o1b25JTnJnVmY1bTE3WHZUa2k5KzhLaTFiSXFXSXFScTJ0bWJNdHJhNGN2azZOMjdjNEl0di9CZzc3WXpkOFE3YnN4RUhCNWRabkIyais1N2w4Ukh2ZmZ2MytmNXYveGIzZnZCMnNZeVdSSmtZWUdJTk1TYmM0NEZmdmZNK2YzMXNlZVBsZldhVjVjSEpTdGhtWlNkTnVRVS94dFBKK1lrRDRDSmwyUG5JZk9YWjNhb3hSaFJpdWZqUlNUcXNISkxIcTU2dDNXWXpWMnNsZHRyZVJiU0sxRzNGTUVSRzZ3a25mNXpBdEQ0OG1pQjcwZ2ljQUlkRmZoaEtSSnFRSTByUVpoRThweGdoUjNKeEg4cGVkdlpyRWhBWHR3b0ZMNmxuRlZ0WFpseS90Y2V0MjN2c1hadXlzOSt3dlcyb2pUekU0emJUdHBrUU5mTTVETW5Renl6TFJSUjNvQ0ZpR2hsV2drOHNlMCsyUmdnOFRzd3crckVXZi9qdS9HY2VqU3o3ZTJOU1VqUzFaZEVONGpWWFZiZ2c0aHJLK0NFK2dKSXFJd2NjV0dOSU9aNkRQMktLcStKVHQzbitwenlrMjMvTXYvZXhTNldSWDJyK2xGWThQblVxcWZQL3lNZFc0ZXJjN1NrWFpGWFhJN3QvODlaMDc1V1g5OWk3dkVVWEpkbzRvZWlHak84QzNxaGkxQkRwZktDeWlwazEzQjYxUEZ3bURuMWdVR3Z5UzFsUlhVanRmSHJHRlZlbXhIZ3laWDkzajVkZWVwV2YvTW1mNHJYWFA4ZjFhemU1ZXVVNnM2MXRjb0wzdi90N0pQTjdORnRuQkphMHN3cWZ6aGcvQzY5OHlYUDU1NTdoM3RzQmQ5YWpNcHcrY0R4OFo2QTdkZHkvYzRvWldyNTY4QXJMZHBmanBtWnhlcDkyVHpFSmh5em1jN0dKMnN3VmJNd29VOHpuUU1nRk1mMzZ0WGN4Yzl3SDlxZFdkTnJGaHo5bmlhQ1dsRm9CbVRybmFiV0JsRW9oYWhTeTBqSmFmTjlxbDRqcXlZZHZNd1NVL1pBckJDaVZZUUowSGhiK3dwdThKaDhWS3ZHVFQwSCtoOTVoR2RDMVpuWjV4TlZuTDNIOW1YMHVYWnR4L1hyTHpxNmxhU1V4Si91RURobFR5WUhTYU1nelVMM0NOb0t4ZEtzUzU2d3phcWRsMzBmYzNUbER5bUxDVVZtcXVzWFdBNjZTZlpFcVNPNnRtMXRzeldybUM5RzNDL0l2NXFNYmZDRUpKcEtlZXJpMEVndXluQ0NtU001UmV4aWxrcEh4UjJtUC9rTlBtM0dwb1gvVXYrZTRNUFk4WFdURmJtYzk2MDkzMi9HUC8reXQ1MTcvMHRWdFAyUVdwMTVsTDdZOG5VOE1Ya1FSSGkybWxCWWVuM1dNS2tPSWtaUVRFeFR6SlN5VlNFK05MZXVXNnR3SVA2Znp0Vm1LaXJhZGNmdldDL3o4bi9sVGZPMXJQOE5uUHZNRjl2WU96dCtLR0ZIRzhONFBmc0RYMy9zcjdENzNlNWlWaENUSWlyVHc0WE9tMnF0NDdxc2pjbWpKRjV4T0FRNC9XS0s2Ylc0Ky94VjJaNTlsWi9aWmhxRmx1UnI0cS8vUmY4amYrZFcvd2FQNUIzaDZyRlUwclNGNDhVVTdPK2s1dkwvRURaR2hDL2d1UENFRVNzREtSWnhQVk5vd1pGOG9yK2VjQVJSMFR1VEU3YVF0Ulg3K3kvbEFzZ3BURzdLWHhGV2xLQ1NmOHhxMTY3VmthZXZYTGRsT0FWejZwNGE0L0FlOHFwUlJOTE9LL1pzNzNIN2xDbGR2N0hEcGNzdmVma1V6TVl4YmFCdVJvMGFsMEkwa3lYb3ZrYzVOSmQvMzBpdW1FeTB0dmRWVVN4bjU4dDZJYnVHNC8zaUp0Z1pqRGFhcE1aVkZsYlZIVGhMdzhOcXJseG0xRlgwbno2RXVyYjdhQ0p2V0YwWng5ODBaN3pMV3lwOEZIOFZtelFWQ1VucWUyY3ZDS1VsUGczTHFqOENOL3JHUDQzK013K0FmOVg0V0o2azFvR2YycnM1MlROMDhHMEltaFpoTkh4Uk9JcDE4a1NvR253cEVMNjZvTGtRR0wvN3dPV2Q4S3ExOUVGQWtHd243YStvblYwQUtSZkNLZy8xci9NcXYvQ1grNGwvOGIvRGE2NTlGYXcweGt2MUFEcEdzTmNvYXlJWjMzL2s5QnI2UFprTHMxSWJab3RmRW5RaERTQXc1b3cxb25Zb3FUbHE1Uzg5TnNOYlQrNy9PaDhQZjQweC9udjNwRzF6YWVZTi8rOS81eS94ci84YS96bmZlL1UzZXV2c1BPQjNlSjZoVHNnclVUVVZZT1I2OWY4TGlaT0NqZDg3NC9kOTh5UDBQRm9RaGJoNjJQaVE2bjVpTURjdGlSblkrbU1pdHJsWG1kTkd6MDFSVUZKRHN3Z01iUWhSNWFxVWxCQ0YvWElQd0JJbm5BbURUQWxzWDBOVS9VSis0WnFnMm1xMnJNNjYvY01ETlp3KzRkSDNHM243RjdyWmhld3JXWm5GVVREQXkwSTR6QVNValFJUWhLZW9oTVIxbHNOQXBUUXJTQzlYV1lyVDBuTVBlaUtPSGMvclZnRzBxak5WVXh1QnFROVNpZWdzeDQwSm1ObXNZK2tUdklrMXQ2VU9RRFk3V3hVRmlEZUxtelVxeHFtUmN6SVYzMEx1SU1SWkRWdkY4dmZia2pmNVBjVW8zL09GOEtLV1V6am12VFdWYVlIVHJwWU9YcnoyNzh3dGJPKzJlenBtd0NHb0ltVlVDUHlSU2xDU09HREw5M1JQU3loRmlaT1VUczFHRjgyTDl2Qm9TUXo2bnRicFFpQ2RtRFJZcEVvcko1SUQvd2IvejcvSnYvVnYvTmpkdjNJUVF5Y0dUdlNmM1MzTDBhRzNRVGN2OGRNNXYvZGIvazUwckh6R2RpaW1sMXJuNHRWK1lYU1Y4RmF2ejVyb1Y5cDBtT0JGQmVOL2lmV1krdk0vaDR2YzVudjhPTVE0YzdMeks4emZmNEpWbnZzZ3psMStoTmhYT256RzRNNXBSNXVaeld6ejd5aGF2ZjJtUFYxL2ZvVzAwaTJYazdNeExaNVFsRW12V1dueVVlT2dOZW55QkNlaENabHdaR2l2NzlwU2xhMGhaMEdwbERNRm9vWG5tY3pPUWp4RlQxRGwzL2lLaWV0RWk3QS8wTURhYWcyZDJlZUVMTjNudTVjdmNmR2JLd1g3RjdreExtbXFsbU5UU1BlbXl4cXROeHBURmZvNFFrc0k3bUZRWjJ5Z0dwMWo3cTZwaXBsRXBSVllhMXdkT1QxYW95aEtHZ0JzY3Z2T2twYnloNjlmMHBSY3V5VHEwUkdvUHZWU3dPQnpINHIwZkdmcUk5L0o2VkZaampKSllLRGtOYzZXMXlsMTRIT0h2UkxrcmZXbDRnNEpVYVVtTS9sUVZlcmtJYkJuem1uWnNwODk5NXRxWDk2NXUvZW54eEZhS2pFK29Mb0ViSkpreEpKblhnMDhNUjB2aTZSSkY1clNQTkpWQ3E3d3A5QzQ5U1Q5YXUzVW1MVzFXOElaZitWZitFdi9ELzlHL3g3aXFTU3ZKS1NjbGtuZkU0REdqQ2RwYWxMRzg4OVozdVB2b1ArWDZjNTNJYm0ybU5rS0NVVVc4WVhXbU1abmFab3pKRzFLSzBXc2VzU1ltUlhBUW5RYlZrTEtoVDJlY2RtK1NZbVJuOUFxdDNXSm42enEzTDMrUi9la3pWRW94dUNONk55ZUVoSzAxVjIrM2ZPRkg5N2o5d2pZeHdmelVzVndHZklKSmJhaU1kRDJaODBTWmZFRm1tbEptMWxhbENIS1pNU1d2TGlYRmdLSW1vUW90L0duRWRaMnZrRDVPVE50NERJUS93QU9oRzgzK3JXMmUrOXdOYnIyd3o4SFZsb09EbXVsVTA1QlJWbUVOdEdXNlhkTXJNNHFSelZUNmZKRFVsV0kwa2JHdDc4QUhTWXQxUHBHU3dscEZWV2x5Vmh3K25MUG92UERtejViNGs1NDhuSCt0MDdPZTY5ZTIyTjhiWVkyaVd3VzZYdEtFVStFRHB5UTdkQjhraGx2bzFsTGt0UlYvdnhCelRqSG43UE5IWGdyOTVPbENWNnFZNEg2S0NsMHJwZGFGM2dEdDd1WEoxdlVYRG41dWEzZjhvNk94SnFGVW44UkNlVzBGVElMUUIySXNob0QzamlRQ3FiU3NJNnNZWEtSem1UNmREMEdiQnpSQnpob2Y0ZVdYWHVOLzlqLzluM1B0NEJKNTZORXBrcndUWnhBdGJaaXAyM0p5Szc3enJiK0xHZjh1VzF0ZVZnZXBxTXNNRWxLZ001WEpoZkNTTi83UkthaE5OYXlESExLWHR6Z0ZZY2ZGVU5NUEEwTlljV255QnEzWkl5ZVBWcGFkNlhWdTdyek83dVFxVnZjRS9RaGxCb3lHcGxMY2VHYkVTNS9iWjJkL3hNbVJ5eWVQK241U216aXF0WFZSSW9yVy9QUU5iMS8wSmpSV1V4c2xxSHdXdzBVU3pJZkVrVSswVm03RDhBbkdSL21wNHVZcHhhRXVmT2wvbkJiZTFJcnRhMU9lZWZVYXQxKzZ4S1dEaHEwdFN6dlNXQ01PUUcwampxdFc1NDFld1lpSkM0MFJrdyt0b1RLWmNaTWtudGtyVnIzTXppbEIzd3ZGTmhjUGZHMDB3U1h1ZlhUQ1lyNWtPRjRSejhJVDMvUTZLZWZsRi9kcFc4dHk2Vm10dkJDU0N2aXlCdU9VaWhndHEwSG5zNWhORm1ueG1vOWdZbjR3bk4vbzYrWW5GSTdPSCs1NjdaL2lyYjVocUk2bnpjZ2FmY083aU90amJpWmFwWmczTDVKV0dqODRWaXN2SmdpMWxkU09uQmxiT093Q0p5cWhuL0tJejA4UmkzUElXRjN6eTMveEwvTHFxNjlEQ09pNmhad2t1VVVWUzZaeURTcWpPVDA2WmRtL3crVFNJT0JibGpjelpIV3VpTXNaVlpSckYwWHJPcTExN2htSmtzOGxWTEFRVFpBYklRZEZsYmN4MVVnbU9PZmxMMmhGYlNZOE8vdFJyalRQY0xmN1RlNTJmNWV6OEFQSWloZ011M3VHbi93ek43aHlmY3F2L2lkM0huMzAydytINU5PeldsRkZkZTVFdUdZUGFpVmhFNmVkWjF6cERaZ2sybTVCMjYyQ1NtdWlUYWpTd3VZZkFoaGQ5TVpmM3h3TlloVjI4bzhvZG1WaHRGZHorY1llMTI3c2NIQzVaV2ZIMG93VXRwTENybXNZV1duWmZWU1M2TnJLS0FZQ0NOWUt4dlY2VkpFaVQwbm1aNzhJQkpSUWtYMUd4NFN4UWxPOWVuMkxleDhjOFozZmYwanUwc2ZhRUtVVWR6NDQ0ZTY5T2MvYzJxR3BEYmJTUXVOY3k1eVZwcW9zS1ZXa21MRTIwWHZvQnptY0txMklJYUVVbXN3T21mWVRObENTN1o0L25ZVys4WXFvNm1xc2pUa0lRNkpieGx5MVZpVW5qcDVWcFZrYzk3ejc5aU9xMm5Ld094VnZzNllpTG5wVVN0UWFIcTBpVytvOE9GN3pjWjg1RDd6MDR2UDh3ai8vWjhWZnpGUkNiU1ZEOUJzcGxzcUF0YUFOZCs5K0NPWXU0MUVxMXM0eUMrWlVDcnRvcDFVUlZHaHpjUjJWVVViUS9SUktuSEErNTlIckRJbUUwWXJkOWhxamF1K2NRaUhYQmRrSC9HcUpYMm11VjEvbFlPZGw3blMveHQzNXI0T2RnNWVNc3hkZjMxWTdWMTZkL3RhVmlYN3Yxei9NdzVrWDZXcVc4SWkxaUNvWHdzdEpGOWdaV2RyU2g2OTE1eWdZYTVHYUdpUTExY1VuaS8ySFBZL3h3cCtQeXEyK2ZKcGNzUjRGRERRenc5YkJsTjFMVyt6c3Q0eG5obWFzYVNvWmo2cXlTblJCV25jdWlHVjArWVpFVVNpaVpvTjBTU21lc3lUZEtncFRibHpKcFZHaXIyTk1qRVlWTDd4d2lmdHZIZkg0YlA2SlAxUFhCNzc5dllkY3VUeGxOS29ZdFJYREVEWmNmV00wV2xsaWpCampaZE9qWUhEeXZxNUZJRDdrbERMZEQ0TTk3Qjl3M1BrRHRkRDgwZmhRV1ZHaHFJT0xkQXRQMzBWQ0ZQcmc0ZjBGMy8zNlI4U1ltRTFiWW9pbzJzQzR3VHVKUWFxVnRLUEhyakM1UG9Ga2I0b2p5Uy85K1Yva3haZGZrVnRZcjlrZFFpNFJVejhqRDVOV0JPODVmUFFCeVI2U05JU282WHZETUdnR3AvRlI0NU1pS0MxcEZ5aGlsSnZIUjBVZkRWM1NPT1R2eGFqSVhoR2RHRk5JaTUvUkdLYnRkYXdha1FjbktMaTFZQzJxc2lqVDRGMVB0MWpBMlM3UDJ6L0hhOXYvS2syNmlVazlyUkhsd2M2TzNmM3luN2w5L2ZVLytXelZqR3JVMmh6aUtmUmNLL0F4czNDaFpPVGxEZjNYR01YRVNqcnU0Tk5HR3c4LzNLenpvc2doWFRqQngrVjJmNktOMDNMSTFSUEZkTGRsWjNlTDdmMHgwOTJHMGNoSXU2NHpiWm03ZTYvb25DbzVkWGtUeDdUUndpUHF3SkQxaG9hYnkwMGZJdEFhdEZHa2tEZkVmRW16RlZiTzdzR1U1MSs3VE4zYWp6SFExL3YvZDk0OTV1aW9ZektwR1krcWt0UWpRUnJhQ1AzV0dJTzFodHFxRFlhUk14aVZzVVp1NjN3ZXcvVC8zMW41ajBLUkF5ckhuSExNM3J2SWN1SGxUVkNLZDc3M2tHLys3dnRVbGVIcXRWMnMxZ3d1Z1RYa3F0cklRSVBQaklCZS9BUSt4dkJSU3VHQXE1ZjIrWm1mL1RuYTBhaXdkTlM1R0wycXozMmJ0RUQwaTlNbDgrVUg2R21QdDVwY2dabENNODIwNDBSVEo5b21VVGVacWlwck52MlV1aWRKeHBoWU5tY3dHYVh6QmRmWlJGTlBtVTV1Q25wTUl1c0xiNDB4Nk5veW5zd1l6M2JvVjJjc0QxY2NwQy9Tdi8xRkZ2ZkdUTnJBcU1ub2xOVm8yK2lYdjNaVFBmZWpOMUhHRU9QNTJvY0xFdDFLWlJaOXhJZTBJWGhrSmJkNkNxbEVDa0ZjazNYVXgxdjMvRU9FRFd2dGtDM0ZYajN4WG9CdG9Ka1lScE1KMDYwSnUvc2p0cmN0b3daYWs2bks5eHNpSllkZTJuR2lGSTRwZTN3Y3hIbkd1L0ljcE1KSzArc1labEJXWTJjVlZhVktibDBKY3l6SXVRS3UzdHhoNzJEeXlXdS9uT2s2enplKzh3QlVaamF0MmRscXNjYWdFWGRYWFhRUjFsUm9vNmlLOTRFdkFaS2h3Q0FvUE9yajBZS3F1QWw5ZWd1OXVDNHFyVlRPMlFhZldNMGQ4K09lYi83MkhiN3pleCt3ZnpEbDVyT1hwRmg5Mm9SVlpXUHdRYVJ2WFJscDE0R0xUNXRPcm4zRnZ2REdHenozMG92bklGMFNNWFVPbmh3Rzh2S01IR05KVDFRczVtZkU1aDVtNGxDVmt1dHBCTEZSUkNOcnVxVE9lUVErSzhMNlYxSmlLNFg4N2d2NEp0aFhtUmtMNE5qV1Z4bVBiNG12ampLUUlIa25LNTRTdDdTY245RXZ6dGphMmdPbGVQamdQa2NmZ24vd0JjYnhlWXp5TkpVRU1MWmJocy84NmVlNC9NSitBU0VWc1R6NGFjMFdORENreEh3SUc5dXNVRlpQWkNFejZRM1dJSE83MXY5d0k4OThvWVhuQXI5NWZHRitOeGFxUmxFMUZYVlRNOXNmc1g5MXhHaXMwWVVqMnRqellBdGgvcFVFV2dSd281aUQyRUtqVGNVa2NIMm81L0llUERGU0tKSEpyazFKYzhHQW5JdU14elVIbDZaRmFmZnh3eXlsekEvZVBlVGUvUVZiczRidHJWWUF2V0xqckpUQ2FCSHVyRUZhV1QwcVFzcUVVSERRekZBbzRFOGVLZm5qck0xUFY2SExtSk5EU042NUZKUlM5TXZBNy8vOTkzbm4yL2U1ZmZ1QVc3Y3ZGWE9EdFBhWWtobXJLS3k2bE9tekJDRjhvdVdVVXNTVXNBcCs2cXRmWVd0N2h4UzlKS0drU0JxR3NneVB4VTNCb0FyanBsc2RVMDJQYUt4SEY1UlBKUUhaeEhSUzRaeWg5MUswR1FIcEFvcUlKa2JKMUY0NVJSYzBmZFpFb3doUjRYdUZqeG1mREZWemcxRjl0WHdmV1d5WVVwYkF4NVJRTWRPMkxURTRjazQwVFN0OC84VVpzYitFT3ZreHFuQUZyUUxXS25KT2JCKzBmUDdQdk16MjFTM0pINC9uQkk0Z1lhejRrSm03SkM0K1NtNVFvNVRzcHRWVHIyY3E4bFQ5eWJmNzA2S2IrQlFTdjJiYWFRdW1Fcis0MGJqbXlzMHBPL3NWVlpsdGk0Mzlaa093dHQ0S1NRNVdZNFRPbW1OeEY1cGNWQ3VxamVsbUNBS1l4U3hjK2hEbDkzNFZoR1Zab3B0VHlNUUlWVzB4VnYwdzRnZGRGM2o3blVPcTJsRFZtdkdvZW9KQXBEWTJZMG9hd2hJZkZSSll2U0dER3FVK3ZzQlljK00vallWKzhSbEt3Y1VoREtIUENycmVNZlNPbDErN3lyTXZYQ2FoQ0Q1SXVtakt4SkR3ZzhmRlJBZDB4Y3JHLzVBSHppQ2g4bGN1WCtiSHYveGwybHFNRWxNVTRvT3VHMVJWUTkyaXFrcG9kVG5obHgxbkorL1ROby9aSDN2R1Z2Yks2eHZaa0tsSk5EbGlmU2Ixa0h4SlBZMXNQT09DVTNpbmNDaThVcmlzb2MwMGswelRKdHJHc0RXNWhhRWxlRmVRKzBnT2dUd01FQndwaXJLcXFscUNGNEpNM3psVy9ZckJkNXcrYnRnZWZvb3FYaU5taVdmS0tYTDF1UjJlL2ZKdDZyYlp6SzlyL1g0dU0renBrRXFHWGhiK3R6b1B2MVRxeVRGa1BlVms5UTlINFMrT3VuVXBjbjFoUGxkYWdnMHYzZGppOHZVeGRkbUYxNVluQlVsc3pHbGtaMTFvWmJXRnRrM1lKbU1xY2ZldGpIenZPU01ydFpnbFJ5MWtuTS8wUWJMUGcwdDRMMkdKSVNTQ2o3ak9DeGZDZm5KSjVMSXZmK3NIaDN4NDk0enB0S1ZwS3F6Vkd6cnNXbjBrb1JXYjRwWm9KMVBzTHpPK0JBRC9zTzcyVTFubzY0em9OQ3hkTjNUK01NZEU5RkUxaldWM2YxWWtrcG02TVJnclYwbktHZStqR0Fwd3prb0xmSUtyeklXOTdvLysySS95M091ZjM0QndTcDgvVmNKZkZzWkNSb0dwY0VFUjFRbVZYZUs5c0t4V2cySTFhSHF2R0p3aEJCRlQxRG96SW1GOVFuV1p2RURZUGlHaisweDlGakhIQ1RYUGhBR2MxNFFrWTlwb3RNdnU3RlVJa2RTdFdCMDlabjc4bUJBY1dNbnhTaUdnVFlVeVZtN2tFSGwwOUlqZXJXaWFodDROekk5SHBQbnpESzdGeFV5SXdzSi83a2V1YytXbEE1R0tHaUh3VkJkYThDNWtIbmFScFk4a1kyZ2FLeWkyL21UbFJZeUZRMUI5Y2d2L2RMRnJZS0pncXdpeE14QjlackkxNHBsWDk1aHRHZGFxejVTaFpFZFNxVlJhK0hXNGdBeTMxbVJxbTJqcnpMVEpqSnBFWFNXYUtxUFZPZXFZdkpoYnhwQ0ZXVmwyNkRHa1RTQ0U2d0w5ZktDYk8wS1EyT04vMk1keTVYanorNDlSR25aM3gwd25MY2JxRGFDcGxjWnFJNEdjRjVtUk1xT25yRGhFYldJSDB3Vlc4VC9WMUVYOWgzeWJiNHI5Nk9GOHZwd1B2ejBNMGNVUVZEZnY4K09IUy9vdXlFN1hhbFJsSkYwMUY2Sjh5U1M3YUlHemRqNXB5bHpZbGhOMTJ4cCs0YWYvSkx1N3UwVFhrNGQrbzk2U0ZqR1NnaTh5U2lBa1F0OUJlOGhnQXFlcmlzV1pvVnRxK2s2emNvWkYwcHhtdzFHd3pMUEJXeTBCRWFZdzR4S1lLTGRNcGNHNmhENkxtT09JRFltb1llazBpdXRNcTJkSk1XR3JDb1lWdzlraE1VWEpjUzBLTkpTbTZ4MGdjOS9kZXg5QnpqUjFndytlb1EvTWp5enpSVTNuSmNiWnhjeG9Wbkh6alJ1WXRoRk5mekdXR0M1SXI4OTg1bkV2YlFnMUh3QUFnQUJKUkVGVUtzRzJNaHVZWGZQeHROcTFHYVJHb2EzYXRQRlBId2dYaXo0aTlyOWpyZkNEWXV0Z2k4Ly84V2U1Y1h0S1pZc0xiTEdJMW9rQ3NxcVNORnVTWjBveHBISmpleS9UMW5xY3NBWGdqRUUrSHdzdUVhSWllQUVYTFlDVDl6Z2w4RU5rV0RqYzRQRzlFSXgrNkVOYld2MDdIeHh6Y3RvemFpMjdXeTF0TFlxcFhDakhkVlhSMUphMTZXNUtRcURoL0N6N3hBbnpuMlo0eXgvMmpMNStCbUpLdVYrZDlkL3Q1c09Ic1FUSkw0OTdIbjk0Z3V1Q0dHNXBRWWFORVZNK1UxdGhHVHpGdnJISXVtMmtZV1lVRFhEcitSZDQ0eXMvVGx0VndvQXpGY29XcVpMU2hkZWM1WE5KNGlDVTZnbnhMcjBMQkRTMnl1eU9BbGNtam9QV3M5TUV4azJpYlRLNmdxZ0ZlRXRXb1dzaGd3U2pDV05OMk5Hd3BiRFRRdDNzQ3ZoaUxUTjdsWGgwek9yeFI4UVlHTzFmWWUvR0M3VGptUmhnbHM1akdIcTVrV0ppZm5iRzBkRUR4cU9heWpabHg1MUluV0h4T05NUFFtVk5TV3lyTHQzZVlmKzVmYkxXRzIrOGk1UlZIeklQQi9BeE1mU09tTlBHeC83cDlOcTFUMzhLR2F1Z3FUUldxNDkxbnhjUDRKeWhSek5yYTY3ZDJ1TlAvUHhydlByR1pVYUY4ZGFZVEZ2ODgxMkF3U21jSytHd1dXeXhSMW5NTFllZ0dJSWlSSTByQmdjNnkwSFI5NHJWVXVHODRES1MxUlpKUHBGOFBpL3luSWsrNG9hSWMwRlNZMVlPNS83Um0reXpoZU9iMzMxSVZSbEdvNXJwdEtXcTdNYnJUcWxNemhGckMydFNiYzdONkRPSE1XOEVmcHNMTC8xVFRsdjhReVBNNUxXejNya3RWWGh3NStqZFptVC9OaVlmS0ZScmphclBIaTlJR1M1ZDM4Wll0VUZBUXhSdXRyNXdpMS9Rdmt2QkY5Q25XMlYrOUkzUGMrM1dNMENtYWllQ0xJZElkaEpRUUJLWEVZeEJKMm5sUTFvUldLS3l1TFppeGVsRWFYSERWTG5zM2swQmU0TGE1TFhGclBDRnFKSmlGdXZqc1R3RVJtY3ltaTVrbEc3WjMzcWRkdnNTWWVoSktXNFVVY05xUUpzS296UXBTbkNmTlptKzd6azhma3puT2k1ZDNxZnJUakdtSmVmTWFUZm40ZG1TV1FXalZ1akQzbWZRaW1lK2RKT1RqNDVZbmE0MjRGaE1KWlUyZzFNUVU2TDNlYU01djJqUzhjU05Yb3JYaDR5eVVOVkM3UTJmZENOV2hzbmVpTzFiMnp6M3gyNndmM1BHWkZhVmx2c2MyRE5KZ0VzdkVBa215MmJBUlpsM20xcjI2OTRMcW01SHNyRlBXVnAybFNFNXhkQVhIa09mNk0vOEpsSXIrb1NQaVZCcGNzeTRWY0Qza3FZeTlKNmg5MnZaOUQvMEkvakluVHZIdlBqY0hudGJJK3FsRTFXYk5YaVg4SVYyYkxVazVnNitHRzhJYkxPOFlDUDFoTVZhL3lrczlGeFdhakdML1VZQWZMZDBwKzk5OS81Zm0yelZxeXUzOXY2VU12bzFZdzFuanhma2xOZzVtT0ZUWm9pSm1NVlNVaVB0Mk5vOXRWNmZubG9lUG0wbEJPK3pYL2c4czltTTZCdzVKRmJIaDFqYlVObGFTRExXRUFZbmJpYzVVemZnNGhtUmdUd1VyclJTREkwbUc5R2lsK2h6bENuMnhscHRBQ3VmRmE2c2U5WXFPaFBGVk5DWERIS0liSSt1czdmL09aUWVZN0NZdWlhNW5qaXM2QmNMK3VVQ1c3VTB6WmdRQTh2bG5PQWpkKy9mSmViSWJMcEQ5STV1ZFlJeks0NVd4eHozQTh3cnJCS0F6YnVFRDRuWjFTbFhQM09EZC8vdU8xSlZNVys4NHkzaXRIcllSNktHNmRxczR5bC8wbytaQ0paaXJ4SHV2Vkx5LzlkdXUzWmNjZjJMMTNueFR6ekQxYXNUUnBWR1R4U3gwcEp2WnpKMWNkME5ubzBmL05wd1EyVTJPK21rRkgyVW5Qa3FLUm9MdHM0YndYeFM0TEtFSnVTUVNVTWtlK0ZjMUxVbXUwUXNlZWNoUm9iTzR6cFBjSjdsdkdPNWRQOVlLeTZsWUxFWWVPZmRJM2ErY0lPcTBsaXJzZFl3REk1WWRvTEdRRjNMK2pmSGpYTzJYVnZrODhOelNUNVZGTmhjVm12ckc5MmhjRU1YdnI5ek1CdkcwOUhuRmVvMThYQ0QwMGNMaHM3UlROdENKbEdvbkxDRmhsZ1ZocFJadTVDV2FLSk00c3JsYlY1NDRYbU1pemkzeFBlZTVla0pkVE1sdHdvZk96bHVRMlR3bmt4bWExYXpuQjl5TmwvaE9vMUZVZGRTSDhtdVdSOEpaUlF4S3pCQzVGQVora0V4RE5JMm84L2puaEtGTVpWbEJSY2o3RXhmWUZ4ZnBudDRTQWc5MCsxOS9EQmdteEZidXcwcVJjN09GcHdjbndLSm9lOElNZkx1KzI4WGVtdWtxbHI2YnM1cU9HSTV6RmtORHJzd1dCM1JJZUpMZ0lSU2NIQjdsL3ZmYmxrZUx0RzYxSEE2dDNFZU1qeU84b1pNQ3VmOVlrck0weHVOZFZzKytFeWpGSlBHMEtuRXlpZmFuWmJudjNxYjEzL3VlV1lIRFhid21KaXdFNE95a3VhbnRNS1lUSzB6RlpsS0taekpCRi9XZVZxSTRUNHFYRkFvSXlJanZRN1JjQXBWWHZ1UUZKM1hPR1N0bGxCUVNZRTNZMDBLbVg0VlNFb1JYU1FNRWhqaFhXQSs3K2xXN2g5ZDVGcTA1dDVIM24zL2lGdTNkdGladGxSMndGcFRmQWJQS2M0V1VPSSt0VDVUei9MSEU4TFRwN0xRcTlvVTVEVmV0SWIyaFJwTlZqUXA1NGsxSWlOVFdpdXRNL1BqSll1empuWTZ3clExZHRveU1ocGZqQlhYRGt4cnNvSXFvdW50blJrbVpnN3ZQYVR2QitFb1owWFZWaXk2bGN5K3JQZTFrZzIrWEN4NStPaU05KzRuZkxhTXJXRlVKY1p0eHRhZ3FveEZzc1p5a0p0YW9WQWgwM1dpaVY3dmpCV1pyQVdHU1ZsMnJGcEZtbXJLbFowdm9qQ1kycUxyc1VRZUZWSzNxbHJhNlFGZHIvQmhnVFdLbENMSGp4N3kwYjMzZWZIRjU0Z3hFbkptTk5vaVY1YnVWSlJWMFV2QWhMVGx1UVJVWkNaN1kzYXU3N0E2V2hYZXUwUWxtU1Jyc0hVMDlRbVNxamtwZ3BHbkFibFBXcTA1bDlBb2FnTm0wdkxLejcvTUMxKzl4V1RiWW5MQVdFVTlzNXNrVnEwTFNLbUZwMTdaektUT3VCNFdoVjZZQzZGSUlaUmRnMlRoYVEwdWFycEIwZWhNcXhOSkticW82RDI0UXFHT1hORGp1NFJmZUVKclNFTWdEcEhvQTk0RlZrdi95Ymx0Rno2YTJqRGJxakVtY25ybW1NOEgzbjdua0RjK2U1Mm1zYlJWUlRWdWVPZ0d2SlBMUUtsOGtSRG9rWWl5aTRYKy81ZWIvUStsME1lemxoZ1R5OU1PcFZUS09VdWhDMGloRHUrZXZqZWUxdi9aOXNIMFFHdjE3SnBGb1kxV3pubkNVY0MwRXM1WGp5eW0yUFdzd3crRnJsNW1hV1BvVjB2dWZuU1gyZTRIRFAwS1cxbVVNcVFZWlZVWFpRTS9ERU1KRUJDRjI3c1BIbkRudmlPYnhMalJWRVpoMTdyelZ0Tk9GSk9SNk0vRmNrblJPMFZ5VU9uTXFFNlkwbFBHZEo1VlpyTkNtY0RXN0JvSGsxZkpJVkdOeG1oVGtXTkFXVVhLUlpwckxIWGJVdFVWeThXQ2RyVEZnMGZmd1ZhV1N3ZlhDeEk4WUsxbEVRWU8reFBodHljaGdlaEdrbVgwRURleFJqdlhkM2o0ZzRlRTNtOTg5WktTbVgwOW9nWmdVWXArbk9VUU1FOEpoZkluQUhWTEY1bnRqbmo5WjEvZ3VaKzRSVHV6YUJMV2lCZCtwUVU0VzQ4Rk9tZnNPdDZoQkY0MkxVUXRLYlBPSzNJVW1uSk1Xb2c4cFp0Ync5ZURoNFF1aUx1MDd2MlFXUzBDZzR2VWpSRU9rczl5bS90TTZDUTBNZm5JYWpHd21MdFBUTVBKR2F6UjdPMk91SGx0aThtazR2aHNTYzV6am84ZGQrK2VjZnVaUGZhbUxaZFU1clh4Tm0vZXIva3YzN3RINThJR2RTOWZiMUN3dkJBajhPbHUzWFBPTEU2NkxGRkkrU0w2N2dBVFF6cDU3enNQL3NNcnovU1B0aTdOL3VXNnRqK0dVclV4SmxkVlZqRkUvR3JBNTh4SUpacnFQRjl0VFYrM1JoZkVXdE92Rm56L3JXOHkyWmxpYklOV2tyeml2U3ZzTUVlSW5zRU5OS01ScHJJc3pzNTQ1ODY3UEhqWU1iQ2lyalYxYlNURHU5STBqV1k4TTh5bW10Rlk1c2ljWlMyVWtoZ2tHQ1hFaVUzc2NWTEUwZ3JYbGVaZzk3T01tc3RFMTVjRTF5eUNtaGpSeHBCQ0pFV1BNWnFZby9pU3hjRFI4U0ZYcjE1alBKclJEUjA2QnR5dzR2N1JoeXo5RWx0SmtFUkMybHhseFRzOUxoelVsdkhPaUhabnd2RkhKOWh5TU9vMUt5NmZnNXU1dEZpaHJDcHJ6cE56UDJrZEZJRnFVdlBNVHp6THMxOTdobVpxMElna1ZJSVlSY21ubzFoYWlSSkpEa0NyUzdvdGlxYk9HSnZvTzBXS2lxanl4dndpWnhHNDVLVFpVWW1KU1F4cmVyRlhyUHBFdjBvTVhhUmJSV0lVUW8zdklwMVBCQTJoQy9Rcng5QkpCdHZaV2M4d2hDZFljTGxnQlB1N0kxNTVicGViMTdhWVRodm1TMDliV3lxamlmR0U0NU9lano0NDVwWFhyL0hxM29oYnJlVkdkVUFNaWI5ejV6NjlqK3Q4NUt3eTh3eEhUKy9RUDdXRmZuYTBLdDdmT212WmZjYWlFbExsMmRMQTRzR2QwLzl5ZmpvODNMc3krNlhSdFA2NXFqSjdKdHNzS2pPdFlnaUVjcXdiTGJONXVrQnlyNndwR21uRjcvN2VyMk5uTmR2VGZXS0srT0RKT2JPN2Q0WDkvY3VNWnpOdXZmZ0NTbXYrcTEvNzIvejl2LytySEIwOXhvNHFUdUxBbzlNVFJwT0dyZTBSMjlzdDAxbk5aRm96M2E2WWJsbnFSbU1xUld0RjFqbDRNYmxvNjd6cEFsUVpHVnpPVkhiTS91eUxjaE1hczFHWlVmNC9XZUc3SlRsbFFvamttSmhPcHp4ODlKRFZzT1RTcFd2RUpEN3BUVE1pcHNqU3I0QkVWVmZZV204aWwzTUJoOVFRQ1FsTVk3ajE3RDdUM25IbjhZcXEyR0RIWE9pOVQrM09BeUkxRFlXZlVQK1F2YXl5bWh0ZnVNckxYM3VHeVU1VjVMNENySm5pcjVmV1VsNnRTdWlpek9GcldxMHhtYXJLVEV5bVZncnZWUWx0Vk1VSFFESEVjdGdrVVlXNVVqSWhRYitNTE00Q2ZYK09mdmNyTWRUc25aQmtodFZBdDNCa0graFhBL016ZDI0MVhTNmlVV3Q1NFprZFB2ZktBYy9lM0pZOGdTN0lOa2NyVHVjOWZRL2pTblBkYW02VHVUYXhUR2FXcmQyS24rRXlSNTNuSDN6MGlFek81VFdkSndrZGZUcW5JMzhxQzMydEpSbk5ORGxCdnd3WlJTSi9USTZyVnFmOU4vdkZjTGgzZGZiOXlYYjdpNk5SL1JsampTYkdoRFhLTmJVYXpnSTJGblJXcjduU2lib3lXQzJaWHQxcXpuLzluZDhpOUpHZGRzeDBzczFybi9rQ0wzem1OVjU0OFRXMmQvZm91cDcveC8vdDMrZHYvWmYvTVZXVHVQTGNqSEV6WTNkVnNUaDV4S1AzVGpsdUtyTFd0RTNOZUx0bHRqMWg5MkRNN3FVeDEyNk9hUGROU1dzVkFFd0hDVGVvREl3cUNYWG9RMkNyZlozZHlhdGlSSm1TeUdYWGtMM1c1SlJJSWVKN1IzU2UxV3BPMDdTOGQrY2RVdmFNUjJPOEg0U05aU3FVcVJoVVJCa2xDTEJSTXRwWUNFTkMrWVNaVkxEMG1Fbk53ZlZ0ZnZKS3cxcy9lTVN2ZnZ1STNrV3NMbUJtUG1jYWJsWktQQm1vdDc3WkwrYlhYM3B1bDFkLzRqYXpyUnJseXg1ZTVmTVdYNjJKTnRLKzZ5eUNRWXRzTGF5RzFpWW10UlM3clhReHZEVGtra3MzYlBnU3BZaWRkQ0l4d21xVldLMGl3eXJTTytHd2F5MWttYUVQdUQ0U2ZLUmJPTnpnaUQ1eWN1cm8rckM1eWFmam1sdlhwangvZTRmWFg5eGpkNnNXUnlPZmFHeU5WcDYzM2ozaXJYZU9TRDd6eDE4NjRLdTM5cmhrTkxzenhlM250N0hqS1U0OTRPZkRWVkNaLytMMEVVcE0rYnVZUHpHaFJZSGs5cDEyN3ROVjZHdk9kY3JrcWpiS3V3MHdGeTd3WHhJd1NqRi85UGlqcy8rb1h3NXZUWGZILzl4NFV2MUUzZHBiS2h2UzFpaTdSeDBoWnBYaXVkd3ZSa25vckd0WnJiamx3UEdqaDl5NC9USy84UE8veFBQUHZNQUxMNzdDcGV2WGFkc3hxK1dLdi9rMy9pcmYrL0N2OHhPL3VNZjFtN3RNWmxiaWdQeVluMWhXUEg2NElzWk0xMGRXSzRXTGl0UFR4SFNtdUhKZDhjeXptZWtrWVZJbWVHa25KU0s1ek81UlVkbEVYYmZjdnZJbnFPMFdKTEVnRm1PNWpGb25JQlk3bUJTRDVLSVp3OW44bE85Ky94dnNiTzlzMmt1dERWcGJGckhqek04bG5IQk5GazhTZWFSanhwMDR6TFJDTlpaS0s5eDJ5MTViODVkZm12RDhqUW4veVc4ODRMMkhuYlR0Nmp3eE16MGxVdW5MNXhyV2lhSHlaN085bHBkLzRobXV2clNEenBMUkZJdHpmMlVMbXFjektyQUJUcTJWdmJqSmhUR2loSXNRb3B3Z2EyS1BDOUxTcHlnODhsa3RiRU5YTlA4cHd6QmtGdk5JM3lWaUZINUZqb25jUldKbHhDWjhQc2g2dG5NRUYxaWNkWnljOXVRTWsxSEZDOC9zOHNMdFhXN2ZtTEc3MDlBMld2Q0RTckV6c1R3ODZ2bjk3ejdnZDcvOWdHR0lmUG1GQS83RUM1YzRhQ3lFUktWSFRHY3RwakpjdjE0VGhwWmZhbTdpZzFaLzg3c1Bva3I1VVJMWTR3bjZod0psakZaS2tTOU5HaDZWSEw1UFRhRUQ2TnlnMVBEMG1pSHdwSTlCQk9MaVpQaWQxWmw3Zit0ZzlGK1BwdlhQTkUzMUk3WXhOK3RwcGZQY1pWUVJmQlVCbUE4SjV6TzJWelRCOHZOLy91ZjVwVi81Ti9uTUs1OWoxTFJ5TDJqUkRyNzcxbmQ1ODUyL3lWZi91VjJ1WHB0Q0RtVGxLT0czWERJem5uMXhKc1ZqMU1aTHpEbGgxMXVqcUVZWnBTUFpRWFNLdmhjd0thV01HNkR6aHNXUWVISG5WYTVmK21LaDRGTEFwYnk1eWRjb1UxWFZwRHJpaDU3dDdUMisrLzN2czFpY2Nldm1MYlNTNjllSGdaZ3lENWVITE4yS3VqV2JyVU9NQ1Jla2F3b3JUMDRKdTlXUU10U3podS9QbDN6bHdQTExYNzNHUzFlbS9LZS8rWUJmZi9PWTB6NDhRU20rK01Za3pyT3dtL0pHdFczRnpUZXVjK1AxUzJoVFVsUEpCQ1ZkaFNyY1ZhVXBMYnpvOG0xaHdzbDZUdzZ1M21sOHlKaGFadm5nWmYzV0owM1FvcUV2dGhQMFNRNEY3eEx6azhEcVRKRHptRUNsVE93Q2VRZ2tHL0duQTM3ZTQwRUVVWU5qZGJxZ1VvbEJRZHRZYmwvZjR0bHJXMHpHVnNCY1lEU1M3ZmUzM2pybTcvM09QYjczZzJPOFQzenVtUjIrK3VJQmwwY1c2ekoyWktoYXphTUhKNndXbnFxRjZjelFuMmIrM0t0WE9WNE0rWGZ1bkN6RWh5TGJmSTV0Nmd3cXBxUUdIMm5xS3U5UGFnNlg3dE5UNk12VHdIaXFjYUtIem1VbisvVGE0ZUw2TGFTVS9jbkQxY255WlBoMk83R3ZORzMxU3F2NGhRcGVSRzBVZzV2L2lWRldXci8weTMrSmYvMi85Ky95N0xQUEEwb0tTdFozek0vT2VQUE4zK0xhYmMvMW15MHFEaVdTV1I0K2xUS3BhSjVEVUtDU1lBSVdSaE9OdGhsdEpLbzFKb1dQbW1Ua1FGQlpibFJyRlNvbWpLbDU3dWJQMGpiN1pPODMzd09wdFBEV2lFOWVqSGhYV25OdDZQdUJkOTcvQVh0Nys5UzJKcU1JUVRMRWxuN0JoNmNmRUlpTWJGWFVVMktYNUdQSlNLL0Y5TklZVVkwUk0wZWQ1Y041NU1XWjRRdlBiWE56WjhUK2JNVC82N2Z1MGZkK0E4aWxwMVpyNnhWY1F2elFydDNhNXJuUFhzVUVHSTRIbEZFa3JiQjdHbU9GSmp1cU1yWEp4S3l3VmFKQ2J2YzFkVmpsd3BDendpb01RYVJyMldTYWtlejNUUlNhYTRvWlk0U3BiTFV3NmZxaE9OaVduMWNDNnFQY0ZDSGg1ajArUkhvdkFOMXkzdVA3eU03VTBybkEyV0xnOEtUanVSdGJaQXpXS3FaankvSEppbTk5OHlIdnZUK25IZ0kvOThvbGRpY05WM2JIWEo4MmpMSndJM1oyeEVycSs5L3I2THBJM1ZxdVhUZlVXekJhYXY3RnoxeFhmY2lqYjl3OVZSR2hES3paeDRpU05nOGhwak5nWEp1OFBhNDRYZmwvWXJWbS9yQnZkTytFZG1VTTJOcElJbWJNZkVLeFB4SEZuR0x1WFI4ZmRFdjNkaFd6YjhrL0NsaWxaR1d0TlVwclJSZmh4My9xYS96My95Zi9IaSsrOHBvb0JGTlJyeGxKVWUzbWMrN2MrUjIyTHQraHFRY1VvanpTUm1ZOG84N0JJbXN6MmxLWWJkSU55STY2N09IWHhnN3JGQlMxZG83VGhCeTRmZld6dlBIeXYwZ1Z4QXhOcjgwb2pSUmlMaVlUeVh2NitZSnV0Y1FZdzRjZjNlR3RkNzdEcGYxOXFxb1drNGpnU1NGeTFKL3cxdUZiSkIrd2xjRTBWaWFCaFNQNVJLNE5xckxvU1lXcFRBa0loS0FVYWVsNWFTTGtoZHBvT3FmcEhKeDJqczdGSjBJZm55YktKR0MyUCtaTFgzdU9LOWRuaENHaUt3MnRnY2FRYXpGaWFIUm1WQ1dSYldwRmJUTldLM1FBa3pQdEJHb3JxNjljbEdyRElGejN0ZlZUU0FvZjVQZTFwYkozOHBmbjg4alFKWHlmOElNa3FPWkNQY1pxbkU4c3ozb0dGNlRZZThlait3dFV5c3htTlNFcWxuMWdOS3A0OXVZMnMxRk42ajJIRDVkOCtQWXBrNkI1OWZLTVY2N3ZjUHZTbEt1N1kvWW5OZU9zMEQ0em1XZ21FOFhqeDRIVDB5UW1HQ1ZsZG05ZlMvYWVxZlNMbHlidDJSQis4T0ZwLzdCSVZkZTJVcWswS2NVVVJHRzBZbEpWZEQ1K09scDNMckNyNnBIRjl6R1hFZldUYnZVMVhUWmNPQW5qSXFSZkEzNmtoWitwU3lpcVVpb1BJZWV0clMzMUYvK1ZYMUV2ZmVhejBoNnI0a0dqNUZaWGdIY0RablJHcXBia0xIdXlIRUFuSmEwOTU3N3RXYTJKRUVrWWNlVTdERm1SZTRxUVpNMlFFQWZUdWhHakRFemkyWnQvakxhZW9VS1duZUI2WlZDY1pIS01FcVlRSWtiWEdDMVJDTzk5OEM0aHJtamJGcFFtNVlneEdxY1NSOHREK3FHalFoUDdDRk1SdENpZlVEN0R5RkpOVERIYWtMSTFSbUVidzZOUTBhdklWSVBMbVpQbHdLMzlNVDVIZnZPdHg3aVFucEQvWGl4NjB4aWUvZHdWYm56dU1yRVhJRkJ0VitpcFBGWlppV2JmWGpDVHFIUVNGcHdCVTJmUjlOY1o1VEpwSVRmNWtEV3JGYVJGWkx5dnhZSXI1WTE1NVJBaHJKTGttc1dNVzBYeUVIQkRvSE41NDFtWHRTYTV5R3JwR1dMQ3UwREttYU9qRll1VjU5Sk1NMjRyZG5jcVRuckhvOE1GYjczNWdPTlJSZW9pdFRYczdJeVlUUTNhQzYxMlVKbFJyWmhvQllNOFAxdGJCamRrRmd2aGN3U2ZhUnJENlNxUkg4S1Z5MFk5dWgveVRkWGMvcFVmdWZXWHlmeHZmLzI5bzk4R3hqbm5zTkVKWlhMS09mY3VaRjFiWmZRL09jK1pQektGbmhJYnZYQjVSbmlxbFU4WFJERHBRc0c3SWVNai9HODYrTTBLZnI1SjNCN0RKQ2FhTDMzbHkrcUxYLzRLVnBJczVkYlY1a0ordUtMcjU1emtCeVN2bUJwTlk1UE1qNXNZWEMweXljM09PWmY1dFlnL2tyaGJwZ0NycFdJK0YxMTdNMU5VamZDZFVaN2QyUjVYOTE1SFl5RjdpWHFLbVJ4aTJiRW90TFdFb2NPdE9yejNHRzM1NEtNUHVYdi9JeTRmWEx2Z002ZndPZU9KM0p2ZkF6SjJYTEZPaTBoRlZWRjV2MGxWTVRFVGZJU21RcE9wSzAwZVZUeDJrZjJaNG1pUk9aeDdVdFo4NWFWTEhKME52SDMzRklPRU9Hd2ljRXZhd09XYlc3enlZemZBYVBRWVJsTkxyZ1FUYUd1Wndkc1NhS0cwQ0lMckVuTFIxaEp4TFVRV1JWNUFtZ3VOZGFnVVFTdHlDMzBVbTZaVUNqZ25XWmN0VHp4K0VHOHBrOUxHYURPdjVjc3VpcFBNZkdCNXVoSUFMa1lXSzgveFVVOU1jTHBLTEIrdDBGYXozeW91MjhSd3N1U3NiMmpRVEdlV05vaktUUmVOdzdUUmJGV0t2RXhrbjVoc1dYS0dvNU5JeWtvNk1wVFE3elBNbDRrUVlXZHExTDB1NkdsdFgvdmxMOTc4eTJkRCtGOTgvZTdwbTBxcFNjNDVYUkFGWm9DVmkybjFUOUJEOG85TW9RT3M1bjdEU0FLd1l2YVNVM3JpSXRHZmNNUEhBTzlHZURCay92NHk4L0pweXMrUGpQbVJMMy90Sjc5NC9lYk5xVmd5eVNBbzg3dUJIQWtoTVYvY3d6U0hZRFRlUzFGVFp2QzFSMW91cGhReFFWSzYrTmFwVFErYllpRnNCSTB2OHNTY1lPakJCVU9JSGJjdlA4ZWt2Y29tZ1NEbklvb1JTakRlb1REWXFrYXpZcms0WWJrNDR6dHZmcDNWNnBoTEI4OExveTlGbE5ZWXBUbGNQdWJJbmFLTVJSa3RlK21jMFZxakp4VlZyVWlWSWZneXNyUldDa0cyZURpamVlQVVud0VXUStSczVjbTY0dEpzeE05ODdockhTOGZEazI3em9LeGJyTW1rNXBVZnZjWDJ6UjJVZ2RGSTBrMVRsalo4YkNrY0I4RklVcGZKcmRvRTd1VXNnRndNaWhqa3BuYTFJaG1GVGVCOUpsWEZPZGNsdklkVmlLSnU2eVF3SVNleC9uVStpYlZZRU11dDVDUDkwck04NlhBclI3OGFDRUdNU2g0L1doU3JabGc1d0FjYUJaZXFvbzdMUXJPdEs4UHVxR0szdGh6MUFXTTFPOU9LL2JFaEx4TmRuempZTnJRanplTkR6NnJQdExVbWF5V2RUYTFvdEdnQU9wZXd5bUN0VnBtYzk0Mzl6Ri80M1BWLzg3VDMvK3YzamxZZmFxVlMyc1ROQ3RueDNEcjBuOHlPL1k5VW9WOXM0OHRvdGdrRU4xYndxcWRhK2ljNHcxbHlweDhycGZxUTg1dGYrNU4vOHY1UC84SXYzaHhOcGxNeFdYVEZDaXFoNmdaU1p1aDZUazUrd05ib0RGT25jcklJcUJhQ0tzand1YlZ3U2tKeDJodzdFWkxMZUZjNDJUblQxcUtzYW0wdUFwYkVrRFQ3VzY5aWRTdnByR2d3V3RycEtJVXJySlZFNkFkaXpHeHQ3WEp5ZXNTMzMveGRSbzBpeGw3TWFtMURpZ2tmUFBmTzdyRWFPaXBURnpCUGI1aG9xdEhFdGlHdE53WFdpRnhXRjFXWWhSUVVROG1ibjNlQmJraHNiMm42RUhuMjhvdzNudHZqYjMvN1B0cVZWRkFsRC9MTjF5NXo0L1BYaUFxcVJyWVg2NlNVeGdoUWtWRzRYcUZEWktJeW83RmlWQ1V5b2lkM1hsRHpETmhHckpPelU1aVlxYUpralljQXl4N08xak40VEJ0dGVReHlxeElrZ2NVSFNadnBGNTdGYVU4L0h3aURJL2hBekpuRHd5V25wKzVKNit1MTUzcUVib2kwZzJkN1BPTGF6cGhMV3lOY1NLSktkSUg3SC9YNFVjV3NiUmlQRmZYWWNIZ2FjYjBrdjBBbVpQR0lxNUx3QUxvaUVGb0YrYlBLS2wxVlNyMThlZklULzhaWGJnLy93Vys4LzcrN2M3VDZRQ2sxdmlEZFh1LzFJOUkxWm9EL3pwOTRqdHBvL3ZlLzlvTS8rSGFMUDZJZk9ZTWY1S1pjZjhyV0NtUFUwMGk4Syt2ZEh1aVZVbjNPMlJ0anF2L1dyL3dyTHozN3pLMERoaDc2VmQ1ODRUV2daQzJyeFFtTDRTMlVEcVFvcXhSakVNS0d5Y1VEVEdSeE1wS0x1NmlQV2d3V0ZlaTZPRVdYazdNeWErTklpUnVxRzgvQjlpN1g5aitEMFRWcmI3RWNZdG1keXovbkVFa2hGRCszVEZXM25NMEg2bnJDN3Q0QjFqWllXNU5JWkFXOTYzbThQTUlZUTlPSUlpeHBSVlJxNHdJVFF1YWkwOFRhcjE2VHFiWHd3aGRPMGZXS3MyVmtPUVNzMG1pbENTbnhFNjllNXFVYjI3amlia3JPVEhkR3ZQQmp0NmdiUTZzem96TE9HQ1drK1JDa3lHM0k2Rk9QWFVWc3lxZ3VsUWdyc1lLeU5oZGZ0UUsycFVKK1FWR2dFZ2FYT0RrTkxNOENxejdpblhnUnhKaUwzMXNpT0xHR3lqSGora2kzY25TTG5tSFZNL1FPSHhPblp6MUhSOTJhY3YwRVU4VWkxbHJXYUNadHpYUFh0N2w1WllMTGlia1BCQmU0ZDIvTzk5OTl6TzkrL3lIZDRMbCswTEJZQnViTFFGVXBtbFlYbDFtS1JGV1lpWk5HM292T0pWeVFROEFZclNhMWFsN2FtL3pVZi92SGIvL3J6K3lOYitTY0czWE9OSzRBUTg1YUJoZFVXMmtxcllYYS9XbTUwVC9wSXdiUVJpNVRxeUFKdE1ZRjZxd0huRklxNUp6N1YxOStlZlRhYTY4OVA2bXFXUW9oYTJ0VlRta3ovT2NVU1NseGZQb2hUdDBwNW9YQ3hVWkpXMTZVUjBXTVV2YkFXdEpBWXFBNGpFcHdRTFlaUFlHR3ZDR2NiTEs1Q0l4R041aTJ0MUZ4dlRZUWlXdU9vU1MzRkRUWkI1SjNhS1ZZTHBhOC9jNTNtTTFtWEw1MEUyTXIyWitqOE41eE1weHlPc3hwUmpXMjFpWE1RSXBYbHJRbGtRUUpQc2hhMWxFS2hUS3loNjhtRmExM0tDTEh5MGlLTUtvMGlvd1BzRFdxK05uWHJuRG5jTW5SWWtEVmxoZStkSk1ydDdkcGE1aU1kTW1lazE5YVp4b0w5ZnFnck5hQkdoblhhL1FBYlMxZWJxcWtyYVFJUTVUQUNLUEUyamxrOEZyUiswZzNkMEtZS1c2UjJjdElrQXZta0V1UmV4ZFlsWm04bTY4SXpvdDc2eEI0OUdqMWllbzBqVGdSVFNyRnRLM1ltWTdZbXpXNG5DV25QV1NHVlNBRjJkU2NEWTYzNzU4eWJTMHFTNGlpTVdwenNJdW51MFlsMFRaVUdub3lnMHZVWmJTeWxjSm5sV3ZMK0pXRDZaLys1Uy9lZlBoLytZMzMvOHJqNVhBeG5EWmYwQmNsaGVLMGMxU2k2dm4wM09pZnVJb2JNbHRHTWJPeUZxdXNUVTh4TTFOS0tRSHBML3lGUDMvejB2VWJ0MlhJMXVlM2VFNlNyNlkwdzNMRlIvZC9nMXcvSkNkTEZQOXRtUmx6bWN2WDFNM2ltcnBwVWF0TVcyZEdkY2FheEhyc3Q1WHd1aXRiUWdHTi9Qbk83Rm1zYlVuQkVWY2RjYkZnZmNWbXJUY3plL0llUDNoeVRCd2ZIM0o2ZXN4c09oYkdtN2FnREQ1NGZQUjhjSEtIR0IxV1MrRnFMZVFVWFJJVlUwSCtsUkZUREt1Z0tXNDYycW95MHl2R1ZnNkgrVEpRVjVieHFONGtyZzQrTVcwdHIxMlpVVnZMM3RVWkwvL29kU1lqeGFpVmYxK2xqRjViUWJ0RU5VVEdPakVhWmFZenFGdEZxalgxTnRTMTdMcDlMNit0SDJCWWlRSXRSakNzRTBxbG0xc3RBdDBxeXJ5L1JtZHpzVzVlVzFlSEpJajdmR0I1MnJFOFdlSUhJWnlFR0RrODdPaTY4REZUQ1ZWSVB6T2ptRTBxWnVPV3lsYWNMajNFVEZXY2ZJM1dqSXhoVkZtTTFieDkvNWpmZVBNaHZZdE1Sckp6VHhsODZiRlRTcmgxeEhKeG5rMEpWbDdjZTV4UCtKalZFSlBLSVcrL3VEUCt4VC83bWF0L2FsTGJTWllrcTlHYWZKaHpOa29wN1dQaUg3eDd4UC8xTjM2VWYvTy8rUzkvZW0vMHB6djdQLzZsTC9DOWQrK29oMGZIV1ZxbXRPRjBXR1B0VDM3bEt5OWMzdCsvUWwyaHRWYnJVQVlKVUZRa3BYbjA4QzRueTI5VDdSbDgwaWlWTUlnK1c2U1JGSEJsa3pOeGJvU29pd0NqeUwyMFVzU2tXWGNaR1ZVc294TFdqTGkwOVRtTWFzaDVmWlBMcWl0N1gzenFNamtrWWtpNG9XZm9Cejc0OEgxUzl0UjJUSXhCWEd1MXhYdlAyWERHdmVWOW1ia0wwcXdMeTQ4b3ZLdUVhT1dydWdCRWtqNk4waEl3YUNwRldDWHFKTjd1OHk0eWFpdEI0OWRFQ3lPMzZqTjdFL29JNW5OWG1PNk5TQ1hXcU02WjVCUFJpbFh5c0V4WWs1aHVhWlJXeEcyTmltSVlVVFVablRNQjhkU0xTVEVFc2NSZVo4cm53a21JVGpMVDVrZWViaFZwclpiM3BqQVNVM0c0RkRKVHdpMGQvV0xBTFh1U0R3VkFUUndkZFp6Ti9TYzZ4MVRBVk1PazFVekdMVnZUbG11N0kvYW1EVG9tRnFlT0VETzJObFErTVd0cmdzNE1PWEZ2dm1EblVjM09iSSt4TXJpUTVIV1ZpR1NHa01VQ1BKZVFUYTNvWGFSeFlrOGVvOWhRazNQZWF1ek5IN3U1ODYrdWZGeitmNzV4OSsrRW1KN1lOQ1VaM3ZQYmo1ZDViL2R2NTdiOTg1LytRajhxN2RkLy9jM3ZpbVByazc2UUd1QW5mdnpMQjlldVhYM1ZXajFlbDZpeVJtRDhrcEthWXVTREQ3N09vTzVoa2hYdmJTVkZ1eVpreE1nR0VaYmdDSVhPeFRGR0NYWm02dlBkY2xXQUp1ZUxOYnpXSkFaMlI3ZVpUWjRuT1U5WUxXbW4yeVNiU1Q1c2lEZUVRT3A3WE44UlFtQytuUFArQis5c1BOQ1YwbWh0OE5GamplWHg4aEZkNnJDakdsMmJvZ1lFZGFHTlhIY2pLV1pzRWtxcXl6QnI1ZWFQS1ZPRnlMN0tIQzhpWjh2QXVEYkZiVFZ2NUxYU0ttVmV2YmJGOFlFVWVYUUpXMW5aa1J1d1ZvSVY4dFNnRzAxU0lseHhTV0d0dkdaREQxaE5OZ0oreFNMYlRScndtVnhKMnk1QUhTd1dpYTRYWG9FZm9qRGlsRmhKUlpkSUxvckJZeC9vRmdPcithcmM1T0lwY0hJNmNIemlQamFYcjF2WkdoZ2J4ZTZzNGRrck85elltekp1TFkzVnJPYWVZWWdiLzNwYktVYkdrbzBtS0Znc090NjZmMEpUR3o1elkyY2pqOTVjQk1WMUo0UnlPU2dZTnhxRm91c2tpR1FkNnBCQ3lnZmo2dm1mZW5IL3YrdGlkUC9STis3OVZ4ZTZWSW1obHdWTjhzNnA3My92ZTd4d01Ncy9lRHovZExidVQxenBNYTZuR0pWU1doZTVBZXkvOEdmKzlBc0hsdzVlSmtNT1FYcHRVMTFJOGJRc1QrYmNmZndON05pTFpYRlpFSy9QMG5WU1p5cDhhK2ZGeXNpWEJGVmR5VHZydkNKNEpXd29CSlNTYkVTaFlzWVkyUnEvVEYzdGdRL2tHSWw5VDNkOHlIQjJRdlNlTlBSazcvQjlUN2NTeDVzUDczN0EwZGtqUnVNUlRUdEZtNG9ZUzJxTDBqenVqb2haWXBXdFBYL0lLaU8zZHlwdHJyYXlDdlNEdkY2aG1Fekk0UUZOZ2pHWlIzUFA0RE5ib3hwclZPSEtpeWU2Y0hvTUptYnlleWVvaFVNQmRaR3VhYXVvS3NFQmJLVlExWGtFbGNwUUd5bjZxSVNBSkY4WGNpalloQkh3YlFpS2JsRE1sNW16WldiVkpWTEpTa3RESkE2UkhCTGVSWHhmQ256cFdaMTF6RThXck9hZHFOSlM0dlJzNFBCNHdIOUNEdkhHYTk1cW5ya3k1Zk12WE9XRmE5dk1KaFYxYlpqV2hrbHR4R0ljQ0Q1aGpRQmhJNlBacVd2R1ZVM1hEWHozL2NmODRPR0NWRkpUKzBIa3NURmxrY3FHSkZKcHBSaFpMV3ZCZkc2K21WTEcrNnhTelBuNlZ2UFNUNzkwNlYvNzZaY3Z2YzU1QzErWFh6YURXcTQ2L3Q3Zi93MjBWcng4WmZxcGI5MEpJYXh6c2tvU2p6STVaNzIzc3pQNjdPZS8rTkx1M3NGVnloNDNxK0xlbnRkbmZlTCt2WGRaOEFQMnhxYUE0T0xEcmd2Z0pqSEN4V084Rkh1S0pjVFBpNVdVcm90M09OSjJwZ3Z0dmxoSVJXdzJiSTF2WTJJRnlkUE9kc2xPSEdFeWllUjdNWlR3bnBPalI2eFdBekhCKzNmZUFSS3o2VFpHVjNqeEprSnJRK2NXSEhYSDh0Q1dsQkNsd0JyaFhZY1NRd1RGRGJ2YzhMVVJzRWo4MUNSV2FrTEdoTXlqczBCbERaT3hGZlM0SVA5S0tRWVhTNUt6d24xMFJ2M2VLWHpoZ05xS0w5dFFzdG5XdTA4U0dGdUlNbVp0b2luYThiVXFSaWNFV1VmR2poaGtuUms4ckZaWjVLWmRJRG1KeGpFbGl6NTRXYVBGSkFEWGF0NnpQRm5RTFR0aWpHaWxXTXdkajQ4R2h1R0hXMFB0TkpZM250bmhqZWYzMmQ4ZUNWUFFLQm90eGR4dU42Z0loM1BKdnhQS3RHQTBWVExNbWhyZk9SYXJnVGMvZUV4Vkd5NXR0UnZWb1lCeFlsQmFWVUttY2s1Y2NkYWlLUEdsbHhIT0pqR0p2ckhidnZGVEx4Mzg4a2NuM2FQdlBWemN2UURPbGNZcTV5NlNUenJId2FUS24vcEN2M0E0eThKSUtaMXpWaTg5Ly94c1oyLy9kajBhMThuNzg5YTR4R1VvcTRtRDU0TUh2NGZhT2lOcFM0d1pYWklTVlFLN1NYNlVOOVlncm9teEsrU1lESDFwV2JFeTA2ZGF5UzFmM2hVZE5RbEhhdytZdGMvQUVGREdrUHlBTVpaNk1nT2xTSDRRU212b1dTMFgrSkE1UERyaHdhTjdiTzlPcWF0RzRvQml4TmlLeXRaOGRQb0JYVmhTb2RBbEdSU3ozZ21Yb3QrOFFGS3NxVEprcmFtMUpDejZYcUpEZHFOa2g1LzFtZkhJVWxkNjgzSnBJMGt2TG9qUFBncEpKZmxvanJvK0llek0wTVhLR2tTdzBsU0NXd1NsTnM2dXFaZzV0amFoVlNZTjByYnJzWHpQc1NTenBBdTNYQmdTYmhXSWcraktzMG5rcUJtNnNFbGE2YzU2RmlkTHVtVlBLbGtBWFJjNFBQNTRrYStWdjBZcG50MGI4Mk8zOTNqaDZveEpZMHRiYmJBb1JGYVdvVkxzN2Raa0JhZXJrakNySUhTWldQZ0trMGxMbndJUFR4ZDgrMTNOWjU2L3pMWHRWdUtZbE9BT3hxcWlseGZXbHk0TXdaZ2crVlNzdllXaHFSUzBqVkl2SEV4KyttZGZ1WHozdVBOLzVlRjh5QmM0OFpJTm1YSThXYmtjVTFLanl1Ui9IRDc4UCt1Ri9yRXg1UHJWSzYwaTd5ZnZTQ0ZtM1RScXpiSE5LVUxXSEQ5NnlLSDdPcE45YVlQUlFxOU1VY1FJTVorSC9Ta0Z5bVpzdFdieHlNMmtrTWlqR09VTnloNWlEYXFWYXpRazhDR3dQNzNOcEwyQkRvcWNROUY1SjVMekFyRGxDTXFpTUl6R1cvUW5KM3gwOXc3YXdOWnNTeVNzSlZreXhvRFhnWS9PN2hLejdMc3hKZis4Q0djZ0Y1Y2RXZGM1bjBYYWFVUWZMbGwwbWJ5U01JUzlFSm4za2VXUWFLek01eGY5VDlib3R0V2FtS1dGVFVORWYvK1l4VjdEWksrbXBTVGVaTkFoazF5aVQrQU1JbXd4NS90cWF5RllSZTgwbFN0NFJ5ck91S21zTFlkVS9OYkxlckpFYnhuRUlTWXNIVjNubVI4dkdCWWRLaVdNMGF4V25zZEhBLzJGSXIvb1ZOdFl6UnUzZHZueUMvc2N6RnJ3d29LYjFaYTJ0T2doZ2E1RVZOSzBoaHRYV3V5eDVuamhVUWtxcFNTNkc2amJtckZ2V0EwRDkwL210QjlWN0Urdk1CdFZLQ1VtSXpJNmlIcHh6ZXNNVVFwZVdoM0JOOHJubGMza1VhV25YN2kyL2N1SEMvZmhYLzNXdmIvZStmajBkaW1IbVBMSnl1Zlc2bi84NHZnVWZLaWNSVzd5cFRmZTJEL1kycm9raU5nNk5sUmtpemxHY3NyY2UvQTJnN21QenBMNVphek1tYXFTZ0laY1dyU2s1VjlGS2ZSWVVlK0NuZ3E5RVNOZWJDWDdUL0s3bHhBWGE1T1lTR01icnV4K2dkYnNGakdOd3RpYUhBSkthZExRRVp5WUV2ckJnZEwwUTgveDJTR1RTVXZidE9maDJSaElrZFB1a0x1THUzSUFXSWxFRWk2N1dpYzlGOWZYTEU0dWlQdnArc3VzWTVNZE1CMENleWx4dEVpNG1HaUszZE02dFNaSFFiY0hIekZheWNOWnpCTDFveFg1elNPaEMxdEYzVUpGWWppSnVOTkVPSTBNaDRuY3lRR3B5eVlqUlVtYVhTWE5jYS9wbkRqbnh0SzJSNWVrd0F0ZDJaVFZvUE5DVnc0aDBRK0J4Y21DN21SQjdDWDBZcjV3UEQ3czZicjRCR2wwVFJXNnR0M3kwNSs1eWs5OTlocVhkc2JrbEJrM2hyMXBoYzJaNEVzWVIxblppY0F2TTVvWTlyY3NkVkg4dFpWaFhGa2FyV25haXRsc1ROczJvRFVmSFoveDVrY25kRUZDUVRxWGlqTXUyRnFqcldBbktjdGxVVldLdXRMWVdoT0RZQkxEa0ZTS21VbHQ5cjUwYytjdnZYRmord1dnVmtxMUY4ZzBkdDBjRERHcHRScngwMzZqcTJKYWtBQzF2N096WnlKYjg4TTVNWGlVTmxSMWl5cDdtM29Ld1FVT1R3T0wzbERYbWFhV21kcFd1VVR5S2paNXppV2pTeUYvaDNGcDM0TVNNR25JSks4MlB0NnFBR014ZUxiR3Q3bTg4d1ZNc3FUa3hQSnBEWVViQTlwaWpialJucDZlY0RZLzQrNjlqNWd2VDluYms5czh4c2h5ZFlLMU5kUFJGbS9mZjVlbEUrbnFXcVVsM1lmTXdyRWt2YXF5Yjg1SndDQmRDamlyd3ZMTGNDTkViTXc4WG9wU2E5UlVtMUVuRmFsbjF0QzV3S1RXc3RZcUxNMlVNdkhPbk83NWJlcVhKcGdxVWljWVNxeTFNVkxjVmhXL2V5VnBLaG14ZUc1c29uZnlmZmpTRFF3T0ZxdEU1eEl4U2hlV2ZKUnVMQ1NDQ3d5ZFozRzZaSFd5SUF3RElVYTZUdGh6M2lkaEdUN1Zzcjk2ZFlzLzl1SWxucjA4d1FDcGowd2F3NlExZUo4WUJpbk1jYU9wck1SektTVThnWmd5VFd1NGR0QncvOUJ4bHFJNHd5b1l5TlJ0eFRpMzZOclNPOGRiRDQ2WmpDeXZYOXZHS0tockNiWk01ZGdSY0ZNVjRwYThIbm1EaDRDVHVWMDVGOU51VTcveTB5OWUvc3RISy8rLy9ON0QrUWRLRllsRk9hK0wwV0wrcEV6M1QyT2g1d3ZxSC8vK25idkg3NzczWVhmMVNzQzdJVnRyVlZ1UE5yTFJ5YUxueXRZMXJML0t2WlAzYUVjVmRRTjFKY2I4MW1hcXd1eXF6SHFWSmtCZHBseXNaS0lSQVlhdVpVNVdxZkRMalVRdUJSZTV2UDFGdHB2YnhOVkFpZ0dmWkQ1WEtqTS9mSWpPbVhZMHhmY0R4eWRIdkhQbmZkNTYrN3RvbXhtTnBrSWFLZW1mYldOSk9YTDM5SjQ4aUVhTUlSWFMrbElhbDRJRkNRaVhTaHZmbU0xK1gyVnhmekUrY3BBaXAzMWl2b3FNU2xydE9sUE51MVNvL0dMMG9KWGlySGZGcWtxakxmaWxKM3o3a0hDdFliQ2FxVmJValNJNUVhd1lMWUFiU1lRdVZoWDVMRkNySlAxR2dqNHJ1Z0VXaThocUdZbDlRa1hoc1l0RHJLemhDQm0zNk9tTzUwVG5DVEZ5ZHVhWno4VjA0cUtNRm1EU0dENTNjNGN2djNTSi9XbURWaktEanllU0ZhZFR4b2VFWGVmNWFRRldsWkoxbW0wMHppWHFWck5UVnlRRnc0UEVTbnR4cjQwUmF5M2pwa1liWVNZT2crZmJIeDVUYThPcjEyZlV0ZXhyQnljZ0ltdDFYYzZZU2d4QWNwSzFxQ3IrZGo1a29zODY1cHhldkRUNXlzKzlldW5QSGE2Ry8vUGgwdWV5cTFqYjFSZXpsbzIxNVE4RjU4dy80MWY1ZXZ3d1Npa0xtUGMrdU9OZWVQYTU2enRiVzUvVlNxQ1BFSVh1S3NIM2daM1pOaW9wdnY3bTc1Q3pSalZHM0dPaWVKYTVBTDJUY0FDM3pqYjNpbjVRZEoxaUdEUnV6WjdiTEZBRnBWZEc0NU5qTXJyT3E3ZCtpWm02aHUrWHhLR25XOHhsOTJ3ci9HSWh2enZIY3JsZ3VlcDQvODQ3M0xuN0RwY085cGxOZGdTc2k0bktWb3phQ1EvbkQvbnV3KzlJeUlNVzExbGR0SjdhaW00N1pXR2VhUVNGbHdkUUFCODdCTEpMT0tXNTFubGVWNGw3SjU1SHA0SEtha2xsaVZrT3JyS3FXN3JJNDNuUDFyamhkQWhZclJnM2xlaUVROEwya1hxM1JSMjB4WjlkRGdabE5hblZ4RnFUQWpSYUh2Q0ZWNXZITVNxRlM3SXo3ODhDM1R6Z1EyYm9BbjZJWWduRmVUWjU5SW51Wk1GeUxseURrNU9CK1R4Sm9UeWhCb0ZyMncxZmZ2NkFyN3g0aVoycENIdWFETFBLVUNrQjVYUjVYWnJpMlcrTW9tNE11N3VHeWRUSXpXMlZSRDM1WEFBMnplQmx0SEJCS05WVlpUQkt5NHdmSTcxem5QV0I2YWhoZTFJVmgxbFJESVlvdTNWalpFWVBzVWlLMTl5TmtQRStid3lCUWRuTHU2Tm41MzE0LzRQajdrNlVFVFUrdFdmL1I2THYvMndYK2dhcEtzZzcyTFBGd3AyZG5aeGQydDkvYm5kMzk1b1BBYTJ0MGtaTHNTY3hMcnl5ZjVVUFQ5L2hjWDhmWTJ0aWFaM1dLU0E1aWREQ0JVWHY1ZGVxVTh5WHNQSWE1eFRCeWI0NGVFbG04ZDdJM2pSbG5ydjZNend6L2VQNDR5VTVCa0x3a0JOR0cvcXV3enZSUjY5V0hkNEhEbzhlODQxdi9TNUtSNjVkdllsU2hoaURJTzFWU3dpQk54OStoOFBoY1FGeXlsb2dKa3h0VUVadkFnTHpPaEhHRmsrOFdPWjFMemVZenBuUCtzQjJ6dHc1OUxnbytYU1ZYdlAvNU4vVlJuT3ljaHd0QnFadHpmSFNNV29zNDhhSXNDU0xKWE9WRmNOdVN6Mnh3a215aW15VitMNVowUUpVVnNoSUtTdGkxTVFJTG1sNVlvTUVMdlJkSkEwUjV6S2h6TFl4Wlh3ZmkrVFhNeXdIWERmUTlZNlRzMEFNVDZiSFdLMTQ4ZEtVbjNyOUdxOWMzMkZjUzZCaXJSUWpyVWsrMHhmU1ZWVnBiS1hXZlRCdHJSbU5OYlpXdUNSY2Y2MFZmWmRacmhKOUtHTmQwUThrbytsQ3hOaXljMC9TakN1bDZXTmswVVVtVlVWbEpKc3RSSG45QVh6S0xGekV4MVNjY1F1K2t1U2FYaWNHSzBXdWpCN2ZQaGkvZUgvZWYrdmU2WEJZV3BiNENRck9UMStoQ3hLdDFGTWNDQTNZK3c4ZkhqMCtmSFJuTmg3ZjN0N2V2bUtNSmNRZ3VyOFU2Ym9WYlRWbU9odnovYnZmRWgxem9iL0pmQ3N6VllqbmViYkppMjljTnFKZWkwRXhMQk9yRlNKUkhXRG9BOTRsbnJuODQzeit4bCtnOGhNeUNXTmxObSthTVNrRXdqQ2d0UzQyT3BybGFzVVAzbjJIYjMvdmQ3bDY5UkxqMFpRWUJhRTNwaUxuektQVGUzem44ZmNad2lEUnZGcGtuVVpMUVc1czRmTUYvZVhhbXFsWTNtaWdpM0FwSk42d2lVVVh1WDhrYVNLMVZxaml0NlpOMFZVRHgwc245RTVqT0Z6MFROcWF1aEEvRXBseGJiRXVjUll6bzJzVDZRcTBzQUtOS2Nrc3FzaDFvOFprTWZSd1NSR2lLa1lTbWNPemlPc1QycWR6QTVLY2NZVVJSODUwbldkWURmU3JucjczTEJmbmFTMEtHRm5OYTllMitNblhyM0pyZjBKdEZBYkZ5QnBHVnBOOXBoK2lLS1BLM3R3cUVaNU1ScGE2bGdPdWR4a2ZNdFlZdENuT1BMbFFvNVZpM0JyQldyUWNDS0hvLzBkTlJWM1lTd2s0VzNhNG1MbThQWkpNT1MvWWd5MHV4ZGJJNFNwenZCaUdhSzAzcWNIV0tLcEtKRkpOYldhVHBqSnZQcGovZHVjVDZpa1UvbE43bzgrbVU0d3h5bnQvTWNKN1BiVGJldzhmUG43bjNSLzhZREpxZGtkdGZUMm1XSVhnVkNqUzBKZ1N6MXgranBQNU1lL2QvejZWTmdWbFZrVjVwallyaVp3azVDK2lON3oyelY0MXlNUGprMkozNndaZmVQSG4rZnp0ZjRGeDJpZUhpTmFhMWZKTUNpTkd1dFVDYSt0QytMRjBYY2RIOXo3aTEzL2pWd2xweWJXclY3R21vYXBHaFFnalJoaHZIYjdObmJNUFJmZThuaWtyZzYzTmVmSm9nZFhGazZpQVAxSFlmZUsyS3JQM2o2aklqUm9lbkFiT1ZtSjBTYm10bEJXOWVpNmM4cnZIUzdRMmtPRm8xVE50YTlwS2lQUXBaZXJhU054eEh6Rlh4MVJqZ1gxMEtmRFdpcG90SmlXM2J5NDc5UFcyd3NOeW1lbFdFUlBUWmthbGpDQ2hLTk5FQ09OWnpUdjZUZ3dZVjEzZUFHNWJyUkJndnZyeVpTNXZ0YWlVcWJXbU5acmFLa3dHeXFwUWFVRzdSNjFtM0lwS0tRTDF5RERiYXBsT0xiT1pZVytuWVRKdXNWcUVLU1RaajJ1am1VM0V3Q09tVE84aUt4ZXdSdE1ZSXdkdStiUGpaWTlLaXQxSlN3anI3WWN1S2pmRmVHeHBScWJ3OXptWE1DY0VHTXlieEdxOTFkZ2JPZVhWTzBmTE40UDArNUdQWjdoOXVncTliUnI2b1VjcHJiVFdGK1dxYTdCY0g1MmRIWDdyTzkvNlpyYzhybUp3MTd6M0krK2RpaW16V000Skx2RDhqZGQ0KzZOMytQRFJQVlEySWoybE1ONjhPSTNtSXArVUdYaWRpNVpRMmpDZWJ2UHFjMS9oajczeXovTmpMLzRpdDJhZko1MEZ3dUNJSWRCM0hkWllZVUFWSkZ5K2I4VXdPSTZQRC9rSHYvWHJ2SFBuVFc3ZHZFcHRHNVNwcFF0QVVWVU5jN2ZnbXcrK3paQjZ6Tm9TcThnalZYRzZYYWY0cmIwNm9rK3NvOHJYN1U1RXNUY0UzcWlrbGYvZ29jZjVOUmlsMFZaUTV2VjZxWGVKdThjcjJrcElKWjFQVEVZVjA5cmlnNEIxazhaaXRXYXhjT1JaeGVqS2lOWm1hZ09ObFVJSGNlek1HWHF2Q0dtZGt5WXNPRGNrVk1nTVhXSW9iZlY2TzVHQ0ZIcHdhNTE1eHpBTUxKYUJZWkJPNU5LazVnczNkdmlSNXc4NDJCMmhjc1lteFVocDZqV2ZvT2pCWFV6WVdyTTlxN0JXNFdPbWR3bHRGRTFyU3hwTW9Pc2k4OU9CMDVPTzRDT21Gb1MrN3lMV0tyYTJMWk94a1hTWUllRkNLdTQ2UnJvY0szcit3WWNpTDdXTUtzdW9Ob1YrTERQNmVLS1pUZzBwZ1J2a2tFczVTK3hYYXpZcXdoeVZ5b25tdVlQSkMyYyt2djNPNCtWSFNpbjFDY1grNlNyMHdUbSs4UHBuMkpwTmVYeDB0RjR4WFB4QmsxSktkYzUzYjc3ei9qZnZmL2lEbytYWjBhWGp4L2Ruang3ZXN5Zkhoenc4Zkt3YTAvRDh0ZGY1emx0djg4RzlCd3hlUUpZVXBkajdRUjdFNERNNUNoMHpSc1hlN0NhZnZmMFRmUEhtei9MWnkxOWpKMTltZGJqaTlPaUkxWEpCU2hIbkhTa21iTlZRMXkzZU80WnV4ZUFHNW9zemxxc2xiMzcvTy96NlAvaFY5ZzltN08vdWdUTFNycWVJMXBMWGV1ZmtEdStjdkErcXNOQ0taYk11RDB4SzU2NDhZc0tvTml1aTlYV1FpcXJ0RlNMWHRQaWxQVHdONkpJRFZ4VkczSHFGWm8zaFpPbDRkTm96cWkycndaT0F0cmFNYTB2dm8vREZSOElqUEJzQzZXQk10VCtpcXRUbTBkUEZDQU1GenNGaVdSUnJXYkhxTTh0VnhBK1J2bzk0TDA0NHhraVFYZ3hyYzRsSTMzbjZSVTgvWDlKM2pyT3pTS00xeisyMnZIRjduOWR1N2JLLzB3b0FtUlMxZ2tvVnQ1MFMva0NTbjNWbnl6S3FOVjB2Zm02alZ0UFVXaFNJVWJxTHZrc01YdjUrWGVteVB0WFVqYVp0RFUycnFXdUZkNW1UVTAvS2VhTWZXTi84V1ltU2JiSHFPRjROYkkwYXJ1NjFWR0lLUUZVWDg5RkN2ZlpPZmw1dEZHMXJ4TEk3VWt3Mk1pcGtsRkdqdmUxbSt2YkQ1ZStkOWI1WFQvb28vdENiL1o5cE1PNVBmZTFQTW1wSDZxMTMzM21hSDdIKzU3USs5UjZkTHQ5OTc4NzczNzEvNzQ2K2QrZWRndy9lL2Q3NHpydmZVMjkrNSt1TXFoR2ZlL0ZMTEI0UHpCLzNyRTRkeHljTHVpN2lQSFF1MGczaVYzWnQ5d1YrNUtXZjVhdXYvSGx1eno1UC84aHgrdUF4SjZkSGVPK0lLZUJjaDNleTQxMTFTN3p6K0JEdzNyRmNMVGsrT2VUazVJaVBQbnlmdi9HMy94cktlcDY1ZVVOdXJ1QWtlcmlaVU51V3JsL3duZnZmNVhRNHdSaHhrVEVsY2tsclZYYitBcmhSVEJ1VldyUHBDdmUreUNiM1UrUkhkTVltdUhmb0dWeG0xRmhzSlYyQ2RCekZ2bHJCNFh6Z2RPV29LOE5KNTlCR00yNHFqRktFS0d5MFVXTUlMbkVTRXZPdEJqT1RoQk9seGE0NVJNbVA5d080UVZKWFhCVEJpM05TVkl0bFpCaFM4V1FYNVp3ZjVEV1BJUk5kd0hXZTFka0sxM1VzbGg3bE5aKzV2czBYbjkvbjl1VXRadU5hOXRVdVlhUEVRQ3VFTnhDamhIQTB0V0kwTmlpbFdDNERLY05rTEMyOGM4VVR2dlRLNDFaVE5hcUVZU2hpMFVuSXVreG02SEx1aTc5ZEZ0MzZXaU5RVzAxbERDRm5GdDNBb2g5UVduTmpiMHJiR2dtNnlBcm5oZGN2dkhoTlJsRVZtYkR6Q1Y5V2pFblVoS3FxdEo2TTdLV3RjVzNlZWJ6NGJ1K2pVMDlhb3FkUEhlcisrZGMvUTlkMzNMdC9kMFB5K0FRa01vbjBSUmtYT1QxY3VyZE9sOTE4UGw5Y09qMCszTDEzOXdQMW5XLy9Ic05xenUycno3RGRickhUN1BQdzdqRnZ2WDJIMDVNVlF4L1oyN3JFVjEvL0dsOTk5UmU0dmZkNTNFbmcwWWNmMFhVcnRERm9yWEd1SjhTQXdoQmlrT3h5SHppYm43RHFGdlJEeDhucENURWs3bnp3SG4vNzEvNXpGdDFqbm4vdUdXcmJpRTQrQnF5dGFPb3hsYW40NE9nT2I5NzVMbjd3d2s1ckxOWkk3SkxTRjRvOUZ4cEZLVzZ6ZVJnellaQ1F4aS9veE9XY09UNExQRHp4VkpYQ1ZycHcxY0dIZ2dxWGRkTGRveVVoeVNxb0M1RzJxaGczVmZHeUYyLzJVVzNvK3NEcEVIaGtGSGJhTXBtWW9ta1hMM1pmb3BOUVpTVEtKVnpDSlZhckpPRUxUclQ0dXZEMy9aQUlTUnhZL1JBWWxvNSt1YUx2UGYzSzgrTGVsQysvZXBYTFd5T1NUNXpOQjlHZUh3L29KSFRYamVzTHNpWWJqUTNHS3J5WHUyRFVhc1lqS2Z3TU5KVXVXZ1k1Tk5kdVJLcDBKTG9RZTBLUUE4azdlYjFIalJFTHJTUm91dEpsNHhGbEJKRkk1OHp4b3FPeUZRZmJJK0g0RjdRL2x0SWNqV1FWNm91OE5jYVNhbEVnS0YyVjJkN3ErdkpPZTZPdTFQMXZmSGo2dGpwUHpQcWh0L28vMDRYK2plOThtN2ZlZVljYkJ3ZFUxcXFZRTJGalJmTEVEMXVJck5RS3BZYVk3enFYOW5xWFh4KzgwdlBWb0U1T2pwaE1SMXkrZklYUGYvYUxmUEd6UDhiQjFtWDJkNjd3K290ZjRLc3Zmb25QWFBzODNYSGs3Z2Z2OC9qaFBXRjVWUzB4Um1LTXBDUy9PKy93M3VHR2dWVzN3Z2VIOTU2ajR5TStlUDlkdnY2TjMrRzNmLy92RVZueC9IUFBZS3RLM2d4Yk1Sck5xT3NSeHRUMFllRGJIMzZIeDJlUHFWS1d4SmRKaFMycEsyc09kMGIycnluSnJqcXRmWkdoMkRSbHJxYkVhMHA0NkErT0hMM1BURVppRmtrV3drYnZFcjJMVk1hd0hEd2ZIaTZwaldTTHU1aG9hc3Vva1NTWkVNVVFjV3RVYzdyd25EalBhYTJwdDBaTUpsV1pSV1ZMa2NxVEdMS3NJMVBJREgyaTcwUnZIbHdVZ1VjcWxOM1NzcWNFd3hEd25XZDFzcVJick9nSFQ1czBYN2g5aWQxUlF6ZDNuSjBPTEZhTytjTFJEWkt3S3lzdGc3V2FkbVNZVHEzd0VqS3NCakdKYUJvdHE5UXM2TDh2cEphcTFsZ3JuMHNGVjVIWVoybnRjenAzS05YRnhDT2h4RTBtSlVJVVg0SmNWZ0oxTFJsWlo2dU8wOVhBYkRSaVoxSVRrM1F4YXdlanV0Wk1wb2FZUmVTajB1YmNSaHNsZG1FbGJhZXU5SGgvVms5UGx1NTdIeHdYS2VPVEs3ZjhxUk8xcEp6WkdyYzU1NnljOStTc2NoVExtWFZnbzBYTVZSemtVTU4wQjE3UUtldWNJb09IczA1QnRjV05tODl6K2RKVnJsMjl4ay85NUU5emVIckl3N3NmOGZDRE8zeno2OThtSzAzZE5CaHRtQzlPR2JVakpwTWR1Y2tWcEJRRUdDeVdzYXZWaXRQVFkrN2Z2OHU5Qng5eC8vNzc5SDdGbGN2YkhCeGNFNGxxeXJJenhXQk1ROGFTWXVMKzRqNzNUaDZnZ2FZMnhCSjN1dTdLVmJteG54RG94Ynl4V3pKR1hodVRNN2NWakZYbXFJdXNYS0t1WksxampDTDZMTURkMnZlZXpObks0MkppYTFRejd6MGhKVGFVNmdKM3JsZDNQaVY4TWJoSXBVQ0R5dGlzTmplV0MyWDlsekp4U0xoT05PWFJTN3Rzak5vUWZuS1NOanI2UkhReXd3K0xGYzQ1aUltYnUxTjJ4ZzM5M0Fud1ZzaENxb3dVUTBvYzk1NjZ0a3pHZGpOanh5UmJDRjBwbXNaZ0swM2JLTUZmRWt3bU1udjdrSWdCZkNsQ1hRN0N1b0IzTHNwWXNINlBGWXF0bVFFcWNrcTRRZmJqc1dRQnRNWXdheHU2NllUVHhZS3Z2LytRYVhXTjdkYktHczBLeUR1ZlIyeWwyTjIxVkZWa2RScHdJV05id1FheVVwdDRaNk5RbDZiMTUvNzVMMXo3bHo0ODd2LzlENDVYZDVXaXpYbGpnLzVFTFBPbm90RGZ2LytBRjY1ZkplZWNyK3hzY1RKZnNYS08vUEdVbDZRZ1RPQnFDNjlwR2VYUXdQSGp4L3pIZiswLzR3ZnZ2czN0NjVlWXRBMnpyUzI2MVp6NTZRbFZQZUx5bFp0c2JlOWliY1YwdWlYZzJ0RGlvM0RLMXlpNDk0Nis2emc4T3VUZXZROTU5UGd1RHg5OWlLa3kyOXRiWE4yNWdUV3dYTTJwcXBieGFBdVZSZlRpbktPMmlybGI4ZDc4RHFFS05IV05iZVJHMG12Ymw3V1VkczJEVkVWV200cERkdkc0QzhCbE1qZUtUZE95VHpTTm9hNmtYVlhyYmovbE5ic2ZIeEtyd2ROWVRWMFovR3FRVzBVVmRWOUp1S21NcG5jaWVna2xQeTJGU013UWNsbER1a1FvYUxJdVFKVVBVdWhESDhXeXVSd3lPUlhBczNqUUp4K0lROEFQUW5mMUx0QmF5NjFMMjlnSWRXVXdSdUZDd3FRa0FSdEI5ZzZya0hndzc5QmtLdDFpbEJaTmcxRlVWZ3E2c2dxZHdKRm9Hc1dsU3pYT0plNC9qSUtDRjRaaEltT1M3QzU2bCtsaVpyUTJnQXlpajZpdFluOUxmQWQ5U0p4MlhrYVBFdmc0cWd4N3N6RWhSQjZlTFBuRys0LzUwV2N2TXg0YnROVlkyZjV4ZWhvSVR0Tk9EV1JMbkVlTWxSRXRyZzl3WFg1WlBiNjFOLzdaUC92NXEyLzlIMzd0bmY5M2VjWWRKY1hvWXJGL2FtU3FQN2g3SDRCTFcxT2lkMW5XU1I5REg1VUNSb3JYcWt6N1JJK1RNNmZIeC95OTMvZ3R2clUxWXJmVk5FcFVXNlB4bU8zZFBVNVBqcGh0YlRQZDJtTXltYUZJdEtNeDA2MFZ0YTNwbG5QbTgxTWVQMzdJL1ljZnNlcVhLQ3V4VEFlWEpreG5NN1RXK0REZ1hNUm9nelhnZmNDYWhBL2xQRW85ZDFaM09YVEh0TE1XbzhXb3dLeDUwaVg4TWFjTkxpRkZrczZ0ckhQS2VEUzFnbGRVWXFiZ2RCbnhTVmh3MWlwcUkvdHNuNFhsRnN2czdXSms4SkZKV3dzaFJ5c3FiYkJhakMyR2xEZXl6eEFTUTRpRVJoaG9idW5wZmNaSHNaQktRdWZHQmRGZkU4dWFxdzk0Zi80OXJ3WGphK1ZhQkp3TGVCL3d6cE9VN0tVdmJVM1ptNHlvZktTdXpNYUNHalJKeTM4dlVINkd3ZU83Z0lwdzVWSkxaWVhlV2xWYUhIOHpuSjVFbG90RU8xSXNWcDZqbzBEWHk0dm9FNXRXZlRheHhXMG9JOWJMRWlLUWpjTEZURWlaeWRod3NGdlREWEtyQnhMWktMd1QxVjJsTmJQeENCY0Q3eDJlY3JBejVyWHA3Z1lIMENXUWJiR005QUgyOWkzdFJMUHFaT3NqUHFlSzBVaFRWNHFVeUpPUjJmdnNyZTFmK0xPZnYvYnQvL1FiOTM2N0tOemNoVzcyMDFYbzY0OUhad3UyakNLa3ZGNHByK2R6blVHMWl0MHhmTkdLdjBST29sblorRkNGbUhoMHZPU3NOdXlOTFB0alMvQ0IwK01UaG1IZzdQU1ladlNRcW1tcFMyNTVUSnJscXFQdkZ5eTdNNHcxMUkxbU1oa3ptVTJwU2tFNTV3cVp4R0p0SXp2U1hBQ2VHTkU2b1N2RHZlVWo3cXp1a2t5aU1vYjFWU2c3OU1Jbno5SnU1M2p1anJwR2pGT0cyQWU4MWJ6Y2FLNGhiZWl5ajNMckppa29aUVdjd2d2QWxFcHJjTEowOUNFeWJhMWtyOFZFVXdrSVdJNFZjcFlidmVzZGZVbzRiWWc1MHk4ZHE0WEQ3VmJVdHJ3RnhYazJ4V0xrS0hKTWZDcmVkRXB1UFdLNmdEbVU5Wm9MQk8veFNiNkhXMXNUdG1wUjdzV1VpMlZXNGZWcml6SFN1aWVmaVViVDVjekQ1Y0JrV3JHMWE3R1ZIQmp6UmNMMWtjVlpZandTRjVnSDl6MkxMbE5WQ3FNVUZqYnJPYXZGaEtPdUZIVWw0aE50NVBWYWszL2NrTWdSeGlqcUNNWmx2TTQwdFVXcGlBK1JTVlBoNDRpSHgyZDg4ODVqTG0yUHVIVXdMbHoraktsa3RlYURqQTNqc2FZdmhWNDNtdEZFdGdRQ3NHV2xFbmwvdTNudHg1N2YrNWZlZWJENDZOc1A1dThwc1ozU25CdXpmUG9LL1lYV2NOK2w5WTVoelJVeFJjZWJKL0JhcTNuZWFLMnRVY3JFaEkzRjB5eEx6NU9CcFl2MElUTHZQYnNqejdoeG1HVlBVeTlFREdFVUlSWHhvUkxQdWRHa0VRQ290b3pHTFZWbENHNGdLWVVwc1VzcFpVYWpHcFUxTVNTd3B0QnV3Zm1CKzh0alB1anY0M1JQZ3hYWnE5WFlSb3NFYzAwSHlxcllJb3R1WEpmNU54ZkZta3VaS2lhdXg4U2tVcHl0SXAxTHJFTm10SktWRWlYMXRSOUtERTdPSE0wSG9iMHFPT3NHbkk4WDFtcUZoYWNoNU15eTk2eGl4RmN0dWpMNGxhTS83WWxYUnppck1VVTZxM0pHZFlHd0RMZ0VRNUdVcnMwVTE3bGJXbGJva0RKR0tWSTNFSHNoSDkyY2pubGhmOHE0MWpnbGJEeGY2TEphSytyYTBOUUc0NExJV3JYTUpXZUQ1ODdSaXRHV2xYZ2tMYnp6NEJMYlU4UDJsdUxrTExGY3BzMEdReUVLdGczK1FTWkdZZFJwZmY1OTVweXBTa1IxdnhDM25rckJ6cVRDcDR6VG1XdzFwdEpZTDc1emRXc0pLWEgvMFp6djN6M2ljNjlzTXhscFFsUTA0NXJhUms1T0J4YW5rY1Zwb3V2RSswczNNaUpRR0pscWc4bFEzOWh1LytUUHZuYmw5OTk4dFBnck1lVmhmYkY5S2xEM1QvcllzNXFRVVoyNE5hNEx2QUZHdFdKNnU5YS9lR2xVZjNGL01qSzdvMFpOSzh0MlV6R3J4R1VFTWtPWmJWTVd4SHJoSXNzKzBxOGNxMVhQNEh0ODhvUVVRU3ZhY1VNN2FxaWFDbXNyVWtxRUVQQys1RnNyVFl3Slk2eTA3czZobEdZNjJVR2pwV1BvbG56My9oM2VPN25Ia0QzV3lHMXJyTVE3bTJJeWtWTkJjOHU4bTBwK2V3aTVwSXVLOVZLeW11dVY1bldkYWNpY0xDUE81dzA1cGk2RW0xUVVWV2NyNmZST2x3TjNqNWNZbzZtTTVuRFJZWXhpMUZpYXl1QjhGSTEyYmJGYWNYaTZZbUV5ZVhlQ3JnelJSZHBKeGRiZVNNSWlzdHhVUTVtN3ZVOE1vWER2QzZGbVRUTmVYejhwWnR3UUdGYWUxZW1DdnV0Skx2S0ZLM3U4Y24wYmhjS1ZGTU4xekRKRmtXYTFMbmw1UWg5T2hSc1FFc3lYSHBNMDlacm5yaFZOcFRnOVN5eFhZdEd0alFoamxGSkYyMDlSRWNxb0ZPTTVBcC9YNndTbENIM0JJcnhnTlhWdGhOT2c5U2FXSzZIS2UycW9La3RJbWJ1UDV0VEdjRzEzUk50cXNzb3M1bzdUWTgvOFRFaEV1Y3psYTZnMG9RakZneTU0bEVzNTVjRG9lTzRXSHg3M3YzSFMrMk4xSGtTYVBwVTN1dEdhS0NtVVdvRXBIZ0YxQnRWcWRmWDZ1UG5zZnR2V282cFNPV2VpUGFlUHJuemcwakR3c1BmY0hTTEhPVXMrYzRLUUpENTRTNEV0YjNncVlvYlZzc1A3U08wcjZrYWNSTmNJZVBDSkdJZU4xVkpWTlN6bUM3ejNwS2pvdk9OeHQrRHhhczRxZWt4dEdLc1dXeG5xeHA0VEFzb2NLdUx6Y3B1a2RKNVNNZ1I2bjZpRCtNYTNvNVlYYldiSHdPa3k0WDFtTnJhQ01pZnhGQmNqWFRGWlhEY0t5eUZ1VkdDeG1HNk1ha05kYUx3aHBjMTgzZytCcFEva25SWmJWOUpSYU0zaXVHYzVkNHphbHVnaXNVdFlxMkZzaEFVV2ZWbi9aVlNXL2ZtYUJ4REMrZTY4SzNGS3pnVjJiTTJ0dlNrcVprYU54aWZEZko2b0tvMVNNaU9IbE5FcVlZMWhOalVNUTZCemF4QXJjN3J5YUNQRnY3OVZZNjNpWkNHcU9jbEYweEpIVmRab3kwWEUxdEpLVTFhWE1Vcm1rdEZGYjJDMUVHMzBPbFJTSHFaNnBMbFVhUjZmT3JLSDVSQlk5dUpoNkZOa09YajJkOGFrblBpdE54OHlzdzNQWEptZ0szbXV1dVg1dWpTbmpJc1ozeWRpTUZURm1WY3BpRnFpK3c3bmJuNy9wUHYrNFdwWUZvejEwN2RlQS9qNTF3LzRtOTg3NUwwK0VOSW1CbEVqeFY0QjFVRmxucDFXOW9aV1N1V01TZ1ZwMWtXYlBLa3N0ZEhNNm9yZDN2Rmg1N2pyRTExcDUzc2dla0dVcHlwUk5Rb1hncGdKYXJVNU1PUVdUelJOaFE4U0pxQzFLTDZDOTlqS3N1aDc3czRYSEhVZFhRb2x2ZFdnZk1LdlBMMFNkbG0yaWtwQlVMcHc3T1diV2JmczBVZWlGNDl6NWFMTTJiWGxDcG1iUll5eFdyUE9LcWpLTFQ2RWhDK2ViZjBndHpRcHNWZ05RS2EyQnUrak9NdHF1ZDE5bWFHMWd0cG9IaTE2bkFJMUc2RzBhT2NoTXl3R1l1ZElyb2JqZ1RSRXdsWWp6amFGQ0tLejhPMzl5aE9HU0RVVkU4d1lKZVZrY0FIWE85eXFJOFhJc3djemR0cGF1cENZR2RVR1BZWEZLcUNzdUc2a3N0SUNPZXlzTll5VXdpVUJBSnRLYzlwN3VqN2dYT0xTYmlQclJTVmtJYVBLamp5WGxWczhkL2JWUm5iWU9ZcitJZVVFamQ2MDBUNEtvY1hXY21zRFRCdE5vcUovRkxFWkdoUkxIM0F4c2hvYzh5NHhHVFdjTEZaODY5NGhWeStQMktvTVBrRFRLSUlTVE1TN2hIZUoyaWdDbWV4bDFha3FoVEZHOWIxZnZubjM1Sy85Mmc4ZS9TZnpJU3pYVytlTHUvUlBUYUVyQmVQYXNPaURTdWRGYmt2clhpbG85eXY3a3RWNlhCa3QrSkFJMnA5Z0dCaWxHRnVMR1NsYW81aXNISGRjNUxTa2Jyb01KMEgrWVdZU3FFU2xLNGt2Y3E0NGhZaitPQWJ4cUd1YkdxTU5QZ2FPVnl1V0tiSU1nU0VFT1J5MHhpRHFPUjg5YnRYamxoMmhINU9aTVo2Sk8wb2lRUjlRbGF6YTFpU1o2QUpoaUNRWFlWeXhQNjU1UVNYYW1EbGVKbkpXak1lbXJMQ2diVFRCWi9vY0NGNW1iUkljTHh4bm5kc0FUOHRoS0FZVXNvcnlnOHp3YlZNUmMrWnM2VWlWSWRVV1hZcWNsTWtxNDg4OFllYkZpS01WcDVZWU04TmNoRFMxVVdqNTRWRlZvZC9HUkl6aUNUY01Iajg0aHNHejM3UmMzeDVqVVJzZ1VWdkZyT3pJRjB0UEhoS3V1UGJHUktIVHlweGZLNDJ1b1BleXpsdWx6TDJ6bnFyUjdFd3Eya1lveGJsc0huQVNzVjIzUlRKYVFEOFpROEM3S0h2L0tQbHNxWVJWR2l2MFZWWEM5eFNaQ3NWRWEwSnRVU2dHTDI3QUI3TUp5OTRSVTJZMkdmSEI4WXJ2M2p2bGk4L3NGdTkzZVUyOGw1L1hhSEc4VWNVRlowamtKaXUxV1BqdTk5ODcvaHYvK1hjZS9OL3Z6b2U3bkxmc1Q1Qm5QaFV6K3YvNDU1L2h6dUZBYlpTNmYrYVVLa0VPNjlrY2FDZGFYZjdjMXVndjdiWHRjNDJ4U2l1MXpqWkVVMElPVXNRWEp4cktBejQybWhHSklXYUdDNi9jT2lLNXNyTGJOc1pRMVJYV0dPckswaloxSVpSa2ZFb2NyenJ1THhZODZsWXMzRURNcVFRbXJxMGUxS1pOQzg0VFhHQzlMRnNIUzRvRlVVR3ljNVk0WUJjSmZTQjBqcGlnSGplOFBOYThZbVRIMjNsWlBkUlc1bEpUVkcvR2dBc2lzWFNGRWZmb2RFVWZJdU8ySW1mRjZjcWhVT3hNV25UUlUrY0VvOGF5NmdQejFjQXdyb2lUVmx4cE9MZHNudTQwak1jMVlWd1JyU2E0U0JnS0M2NXd4QVcrVUJzK2V2Q0NoTHNoNEZlT2J0bGhZdUs1N1Jrdlhka1czN3FReXc1ZmJrNXJ4UmJLZTZITTVyS1BENkU0MUdnbGxPRjh3ZGdoSXl2QmtHa3JJNkdJbXMwQkxWaW43Tnl0a1lzZ3hJeHo0bEFiRXlncm81allkNlYxbHNpR1ZDU0tZYUd6bWtKdkV4SU5HNVhiYk54U1c0TlJpczU3anVZOWwzYkdiRTFxUWhDdzBBOEpveFZWYXdTalVRcGZIcG5qdWZPLy9ZUERYLy9Qdm4zdlA3aS9jRytYL1hsWDFtdnhBdTg5ZjJwdTlKUE9jK2VvUjVVb3NnTEVXYVdvYzhiY2FPdVhkK3JtbWRaWVUybE5BcXhPWlgrY3lFbGpWQ2JrSUVZQ3hiaW1NWVpMbzVxVUhNbEZqc3ZOSGpLY09YSlVTVTJ5cDAyS0tvSEMwdzJPdk5KMDBaUEorSnh4T2FHMW9iSm1JeldOTVFyUHVraWUxa0NQYlJ0cGhYT1d3TURPRTFjTjdiU2hIdGNvTFlrdG9aZmlpYjBRUzNSYnMxTXBuclhRNXN6OWVXQUltZG5ZME5ickdDYnhHS2M0d2c2bFFIb1hPVmtNd2dDckxHZWQzRGFqUmtBN0h5SXhDV0t0bFdLeGNyaVVDTFVWTm03S3hDR0kyYUVTRXN1Z0pSczlGV0lKV1RZSUprWHhvbFBsOHdtOFQ3amU0L3ZBc0J5WW55N3dxNTZEcXVibXpwUkprWW1DakIrcUNIbDhFb0J4WjFiRHdySHFneGovSmxERnZrb1ZNbEZsRkUwaDJhUmtPRjQ0REFwMlJveGFRMVhMZTZ1TWdoTE5uSXZsZFl3Wm01R0QzY2lvNTRPUWRLelZaZFVtUjdNdXlyU1VGTHFXTG1pN3JhSFJOQ1BMMGNMUkpVbTNyV3ZCWW15bGVlZnVFYi83Zzhkc2ZlWWFyZGJFY2pEbktHT0VVMnBEZ1QxZERzUHZ2WGYwNjMvcmV3LytUNDlYNFIzeHZhRXJ4UjQrbFlRWnJSVFA3RGZxOXo2WXIvZmw2eHU5SnROc2pVejcwdTdrajAzcmVxL1NKbXZCYTZtMHBsV0tJU1lVY1dPbDVGUGkvOWZlbThaYWxsM25ZZC9hZTUvaFR1Kyt1ZWF1NnVwbWQ1TnNxam1JRWlrT29pUXpzaUhKWTJ3cE5nekJNQklrQVdJZytadmZEcEQ4U0FJNGdCTnJjbUpMU3V6RUVTUkhsaXlKc2lWUkV3ZVJJdG5zc2JxNnhqZS9PNTVwRHlzLzFqNzMzWHI5aXJSc0RWM05Pc0JGa1ZXdjZyMis5Nnl6MS9yV04zZ09FWGhoYUtXd2xtbWM5d0dWWXhUU3dkYzJvRDh1QTArcWhoUlpXYmt3Z3pXZ01yRkExb2FRbUFTSk1WTE1sc0ZhUTBPQlNTMG9iQndaV08xV3NKV2djbUNVMVF6TmRJNjAzMEYzcFlNOGw0L04yNEJRTzJuZHZhU2VQdG5UdUtobFQxdzFRVzdrYVBzRUoraXRpMmg5V1huVWpZZTFBUWZqRXFWMVdNMHorQkJRMWc0QTBNM0ZvN3gwNHZTUzV4cGxaVEVyYXpRRUlFc0JIK0NxQnFHc2dUUUJLNDNacE1HZ0NjaEpUbUh2SlVTU2xJdzJtZ2dxeE1naUgrQ3RSMTFhbEVjelRDY0Z5bm1CWHVPeDFlbGhMVTlsL2VtanU2eUpNVTdSVEJjQThseGpTS25RVmhGZ1lob0tzZEJpU1JFMEZISURXRmFvckFjUmNEU3JvUlZoVytWUTJvQVUydkJEc2RMR3lVcFQvQUdrK0dSbEdFLzlKQ2JYc3VTaUo0bXNINjBRQlVDYXNOSTNTRE1GakFpVUtJeEt1NGhxVWdyb2R4TVVsY1dyZDBmWTdPUjQvdElxUWlQN2M1SEFLZ1NTZEozWjNMdXYzeGw5NGRkZTJ2MUhCNlY3RVVETlFBR2dQb3NWOTQ0bzlJKy9hd1YvL3hmZmpDMFR4UlR3eFZvdFpjRDh2VTlmL083dnVOejlCSHZWblkwQ3owWUJSUzBPSmVOUmdIWmllV1I5UUtZMHVrbUN5amtVSEFrdXJOQkxDV3VONDBQUEtCbHZndkNiREh5VUdkZVkwUWx4emoyQlFSaHNCUGYzWGdBNW82TzNHd3N3dDFBdEVJR2RpR0swMW9CUzR2bEdDdDQ1MkZJQXFheHF4R1VsTlRDU0lnRzJIaFFZbkNkWTZ5WjRya05BN1ZIV2pKVnVJclRXbUtOV1ZoNHJmWTI2bGhXWERZSWdOODVqVXRZeGZ3NW9YRURqUFJLamtLZG1BZnd4Uk1neW1qY29teHB1ZlFEV1NuNzJ5aTcyK2NRQndVazRvbmNVMGZwSTVuSHl2NDJTZkR1bFJIakRnZUdMQnNWNGhxYXNrVFFPd3lURjFxQ0xYbXh2S1JWUGVlQWtURkl2eENPTU5OUG85eE1VaFl1emZJQjNQZ1pRMEdKRU1zeXlpdEVhWlcweEtodmttVERtdE5hQ2RzZVRPd1NodUdwU0lNZlJ6MTgrT2sxaWx4V2ljMDFMVmVXNExxeWJnTVl5TWlNZHlPcEFWbXBod3RnMEdXYTFoK09BUkNzZ01DNXRERENiMS9qaWpYME1USUx0WGlhNjA1U2dVOEZWam1kRmVPbmU1R3UvYy9Qd3AvWks5MUpzMCtjUksyNU9uZWJ2SE5UZEtNTFQyemx1N0ZjRXNHS09MVHVRTWFBL2NuMTQ5VWMvdnZuRDF5K2JKNUV3dTRwb2ZCaFF3NlBpZ0ZkZURuampUWWY1M0dNOHNaak9uTnl3a1JIRk1kTElCb2R1clpFMWdSWGpobVA4R2hIK2dJRlBnZkJkWUZ4WUhyZzlDUnVOSW5VcnFIaXFCc2tyRDlINVJFWHJJSmxYTlZSRVdoRVlBVTdHQ21PZ1RRSVFvUzVyTkZVTkZSZ21FVHNqa3hyMHVpbWU2V2tNSFdOVWlqMVVtZ0EybkJoVEtFVW9haFlLcWhYOG9MRWU0M21Eb25ibzVISThOczZET2FDVHBjaU1Ga1dZRHlLczhRR0g0emthQmZoT0FzM2l2YzZ0MXJLTnZ2SkNpTEh1aE5ERFNwSmNVakFvQ2thTVZvdTJ2WnlWcUJxaHJmWWFqNVZlaW8yVkhKMW9UeFVQV0hrZm13QW1JRTlFOE5GRTk5UnVOMEdXYWN4bURXb3diSU5GK2kwcEJVVXk4eXF0NWFGQkRPY0REcWZpeFFjQS9aNUJrcElJWU5xdEpnRkp6RUlYd3BDUXJGcnVFaWtnejJYTUtTSTVhVjRJK0pjbENxNW0wRUJqMkRlb21vREozQ0hYaENaRUgza0djcTF3ZVdzRlg3MTVnQy9mT2NKM3YrY0NzbHdlUE5ZRnZuOHd3NWR1N3IzMjBtSHhVM2NMOThWWTNLZUwzSjFTcmozNnJmdi84aVBYOGQvLzY3dElOVkYwekYyYzVwS2VSZmwvK3NudFQ2d1A2Q2tYUFB3WVZKWHlxYXl1RUxybkFqWldFMXkrckRHYkJCeFBMTzd1MWRnL3FqR2ROYUFwb1NrOXZCZkhHVVVLSHRRQS9ES0FraG12QTNnZHdCY0IvQkNBNXdIMHhmZ2RGQ3pnRmFCU2lZTmlKYkUva3FxeXlHS09lMW1SVlNvSm8wQndIczdKVGxzYnN6QzdiZE5tQWd0b2FJeEIyamU0c3BiajZaUlFWMktXa2VvVGNvZG0wWTZyVkdGYU9GUlZRT2xFSWxyVURydmpRbTVjQ0dCVVdZOFFHSGxxWk4xbDQyaWdFa3puRmNxNmhsdnBndE1FS2dRRTY4QmVuRkhFMXRndmROdXRHU1NCUUZvaEZEWEN0QUVsR3RReGFLeEgxWGh4ZUMwcjFLVkZtRHAwT2diYnF6ME11N0x2Ym9VNkxyQ3M2R3JCR2RJdVNlOUdKd200S3oyRHhCQ09qMnFFTkVwTm13QktaWUFPVm5UdldhTEFuS0JzSEpyQTJCOVgwSnJRR3hpSXE3SllXd2tBS1NBbVNMb1NXY2xHN2JsRzNLdkw2VDZaT1l6bkVvbWRSMldkaHhoT3Bnb1lkZzJhV2xLRUFnT1ZDMUdGU0ZqcDVyaXlOY0NyZDQreHVkUEIrNS9jUUZWNzNEdVk0c1ZiQnpkZlBpNys5N3RsK0UxbUZMSEl5MU10K3p0UHBwb1p3bDkrWVIzLzYyL3N0Q2FuQ3ZLZXA0RmhybTkydGo3MFpQN0NvRTlEVnRJbUdpWElLNEhoS3Nac3pFQmtqRzJ1cHhodVpIQUFKbE9MZzhNYUJ3Y1Y3dStXR0UwS2JncEd5WHd2QUM4Q21NYW5wd1hqVndGOEhjQmZBUEJwQUZmaEFWK0I0VURjQUp3SFVFY2hTZlJDd0tGSU9nWVZYYXRiM1hPTWh4VVR3ZmdzWUc0MXpoTFRTWkJNTWtzQjNjemdQVDJEcEFxWVZOSUtVa1NZOVJJSzdDMmpLRDNHY3djYnhJaHhXalNvR29zODBiSnhjSXphT2VTWlFhSU5abVdEdW5FUm1TYU1acVV3elZJdEdXNGVDTllKbDkyWXlNT25SZXRzNGluUGlxQUR3MWZ5VUFpSmhvcU1OZThDWEcxUld3YzdkK2d5Y0g2OWovTnJQWEZjTllJY3Vqck8rbkYvbW1xQ2E0TElYRHVDdnJlb2V6YzNzSDJKUlBJMkVvSWdKQmRucGIxV2daRnBCWlVuYUlKZ0dvZXpXdWI5UVNLV1dDRFVUaDdTVFBJOU9ick5CQWJnQWxRdUxyeVZaZFMxMkVrTDYwN1djMFlyZEZLUkJaTUMrbDBGYXczMmp4cHBQNVVBZmtvSlpmajhXaGRIMHdxLzkvb0JFcU5RejJwKzlmN3hhN2VuOWMvdU5Qd1pacFFFbEN3bmVYMFcrUGFXenZkUkx2U1hka3ZzVFJ0eWdZa0lpdVcrVGpobVZQM3RqMjQ4djcydW4xYWF5VGtHeDBERXRNZEkxd0tDVmFpdEVtY1FMMllLbGhpQkNMMXVndDRnd1lWTFBWeWRXaHdjVmF4ZnpmREtLNGV2SGMvckhUREsyREs1K09POEJ1QW5pZkFpZ0I5Z3hrZkE2SHNMOWhia0hVT1JFK2NYRmtjSXBUVW9TY0hFQ0JTZ1JkelY1cjdMS2d3VS9lZ2pHaFVFSkNSaUJIYlFCRHpiUy9Ba0FkTkM3RjYxa2dlRml3YU9XaE9LS3FBb2hNcGIxb0tnTnk3Z2VGWXQ1bGRaT3prMHptRnRwUU1DWTE3VkFCTUduUlN6b2taWjFIQkU0TVJBTVF0WElJS1dCTWxKUTJ5QmlZRGdvNkZFOU5WblpsQXZCYWNhcnQwVmx4WmxVYU11UFpSbHJBOVNiSy8xTWV4bnlESVpKMnlrOXJZVVBtUEV5eTA0MlhkM1Z6VHFJMGtWOVo3aHZFZVNLblQ3Qm00U0VPaGs1dVpJblZXS1FFR01JeFFyTUh2TUdvL2Q0d3FKSVF6SUxGQjE1OFhRQU5Fb05BUjU2UGdnNDBHdU5KZ0VvZFdRdFJ3QllCZlE2V2prbWF4d1kyK0NYcTR4U3hWODdVRmFMeHhuaUFpWk1YaDZlNGo5RzN2NDlTL2Y0NEVLUi9jcTkwLzNISDdWTTJhUUlpK1dpdHpobXhoRVB0S0YvcysrY0FEeHVDWmlqaUFjSVdHR3ZqQk0xNzd2ZmYyUHJBL1Z4UVVsR1pLUHBuc01NMkJNZDhWYkhFVFFTa0lQV3FjOUZ6OUlCY0tnbHlEUmh1WWw0ZlpoZVdIVzJHVFVoSHBwTm1wbDdZNFp2d2JnVlFEZlQ4RDNNL0FVQU8wc3VKb3pjYkF3bVFOckJXZ2Q3WU5OTkU0NDBaY3JJbWdtRVM1R2ovUFc1TkY3Qnc0QnRYTTQzODN3dm1FT0hRUW9TZzB0ckpFUXBaMTFGVkJVSGtYcFVWaUh5dnBvYlZTaGFoeXlSTExhdlE4b0c0ZE9wbVUycjRTdzBzMVRLQUptUlFYckhmeWdBelo2b1I4WEkwb0Zqc0lkRVlDRXVJSFFVRzN5bUFmSUdLaE1rbDJ0QzJncUo2YVBSUVV1TGZxcHd2cEtCNE5PSmlhS0xmMDNta08wcVNiVVlwK3BRbmM5Z1RaQWJjVnV5emN4cUVJcnJBMVRHRVVZVHdSWWRYNlJZeVFnYURSbjVCQ2dTVENmVWRIQUhBQVk1a2d5alR3bTRuZ1NmRUFGTEZ4a09qMkROTkhTcFRDUUtrQm5hcUVQMVVwd0NCOXdvaTF3QWFTQWxZR29BOHY0Y0dpVGNMMFRHdS9sUVI1dXpNWlVwemlZZ2I3a21TZXhWUytYZE9mZnRNZ2Y2VUxQamNMdG93YUNzVkRyUW1UQVNBRG92L1NCdGV1WEx5VHZUVHRJSFRQRGczd0V3RUJBc0VBMUY4QkZGR2h0Mjl3bTJRbmpDYTNWY01XWVRHcFFDRWxzaDF0REM3dDBxcmNDbXBzZy9Bd3hYaVRnUnhqNExtWWtUUTBPZ1NuekRFNFpYc2Y5YkpiQ0pBbWNPc2tQNDVpbkRTMCtab3dBYjBVbzB3bzFzazZPRnk2c1FRWGczc1NLSjNwa2xqVldDczAya3BSYVd5L2hmaEg5RHlGZzczaStTRWwxWHV5aW1CamRQSUh6QVZYakVKalI3MlR3UHFBb0tsUU1oRUVubnREeGhGSUFHdzJWNkpQb0t4OWdhdy9UMHdoS0FFYlNoTkFSdklFaktsOFZEZXF5UmpWcmdDYmcvRllmbDg0TjBjMmk5WEpNZFdXV2RSVVRZTFFVSEVGODN6b2R3dEhJd1lmNGRuRU1vb2pDbjlWaENpSmdOSklIQWFKSkJyZVVwT2hPbzFpaWpwa0pCN01HcWRIWVNtT3dBb3MwTlVtRlJXY2RvZC9YT0grK0Myc1o0Nk1TUkNRNTYzR3RHbHE5UTN1UDhkSmg0bVU5bHhuQlRVSlV5OVZ5Y0hIVE9OYk1hcldqSmlQblAyTTk3NUNzMGNxSHJORytZWWpESTMyaUoxcVJrNU5EdHdRWklaRlI3d2Mrc1BJZDIydm1xU0FHQWVSQWNFUXdDY04wZ0dhcU1aM3BtSEVPMUw1OTEzaWhpUTVCU0Juc2dLb0tmRncwZEZDN3J4U09KMFRRQUtrWTE3eHN1ZXZqL3A0RDhMdWFjS0FZaDB6NDg0SFJkUTBZQVdRdGc3MkhNUUY1enlQdE9oaGpvSlNHQnNEZUlaQmFCUEtGNE9Hc0JZY0FNZ1pabXVJRGx6Ync5RW9Ydi8rMVhSeU5TdmpnWWExSFkvMmlGUWZFQUZMU1FqTjBzZ1Q5Ym9hRFVZSEdlNnhrMlVLbzRrTkFuc2hzYmlNWTJFMFRkTElFZXdkajFKV0ZIM1pCZVNhV3pGSGVSWGtxTmtlUnF4NjhXSDYwVnAwK3BxdHlJRFR5eHNFSHdOWWVUV25SRkZMb21XT3M1Q2t1YlBWeGJwREtxUjBseEZCaUFVVmFXR1plQ1VDMnNTbnRkVmtLdWgyaVRMYzF2YlJXd2d6WDFqSUJCek1sZm5XVkV3dG9pUHVxRG5FRlI0Q3lIdlBnY0RDcmthVWEyMnVwVUdNVmlUNjhacGhFWWJpaXBVM1JnTW9VbWpJSW9jWVEwbHhGU3k5UndVbE91dno3dGdHcVVqZ01hU3BPdXBQQ1Ftc2hVOW1tcHFQeGpHWk5zMThDUDd0VDhmOWJCUnpGazd6Nm81emtqM1NoWDFwTmNYZlV0QWFacW1YQ3hmbGNmK3Fad2ZtckY5TDNkTHJVOWJJZ2svMW5DdWcrUXcwRG1qc0daYTFnUFJZcEdaNU81S2tjblV1aUh3S0sydE9rck92anlyNVp5NmlaQWx5Q0tKR09tNEVIcFlFaGtyZGUwY0NQYWNiOUR1R3ZXY0s1eGlGNGlSWURFYU5wUEZnRmVPTmdkQ0tubzFJaXMvUUJGQVMxMThZQVNxSFR5ZkgrODZ0NC8wWVBMNysranovNCtpNXM1UmR6TWhHZ1RHd2JNNDJVRGJJa1FWSFZtRlVPOXc5bmNONWpwWmVoY1Y2WWI1RWhPT2gyUUFEcVJyenZPcDBVczZMQ2VES0hUeE9vclJVb0ZYbnFrUVlXU0MwRkRVUTFZT09nU2d1WENBa2xpYW94RG96YUJZUW1vQ3BscFZZV05XemhzTjFKTU1oVEtDY3piTCt2Y1h4b01aODdrZGZpSk5TU1JhS05yS3NqUUVjZ0pTQ2xpbHA5OWpFVk5SRVE3dktsRG9hckJyZnVscmh6cTRsZWJkRTFOTlZBSXVFY0lJbzJ6UTV2SHN3QlExaEpOTEtPQUlOY00xWlhSTFZXVkE1WlJ5RkpDV1VsQXBTKzBhSUtMQU5Nb21BeVdwQnZnaGZ1dW91Z1lxSUp3NDVCVVRvY0haYVlGblc0TjUzZk95N3F3NW56djNpMzhMOHc4emlJQmY3QXJsd1JPRk1Tcy9XT0xIUUEyRjVKYUgrNmlHUFN5d0tXSC9qQThGMWJxK1paYUpiekZURS9QQVZNbndITkNJMFV0UE5pMFd1ajI0dUtmbHlJdjFZT3NFdzhyUnlOU250VU9ENWtJT212cks1ZXV2ck14VmRmL01JckhBSVRLY01jNnFXbmJMTW9kdUErZ0o5VmhOMExIZm92aTBEbkRpdTVwYndIdUFFQ3NlU3lLUStUYWhoakFGTFFVZmxHU2lNb2pZMStCeCs2TU1Send5NisvdG8rZnY5cnUyaEtKMThYUnhDVHRDRjloRVJyRU11ZXViUTFpdG9oVVJBK3RSZUNqb0pDV1ZrUmdCZ042enhxMjBZa0V3NE9KeWhMRDc2MEFqWktzc2dpZzQ4SkQ2ajJTQkVJQ3FweDJKcFdLSHNwS2xJaStvaHJSUmNBYmh6bWt4THplWVhacElZT2pMVitncFU4UWFvSTg2bURBWXRSWWthWVRiejR6eVB1NWdPUVpRcjlnY0h1YmlNYWRDSllpZG1SWm9Oa202TGpXalBSaEc1Q0dBNFM3Q1k2RHZxODhOZHJ1eUJGaEZ4cnVJUlJXb2Q3QndYMHNJTlVFVHJLSUIzb09FNFFobDBON1JXSU5JNHJLNjI2SnN4dHBNaDZBZXFNNXVnMHl5Z3I2WHhNTk1Sc1BHTm5OTWZyZDQ0d3FkMFhkNXZ3ZjlVaHZEcTE0WDRWZVBra2Y0QVF3d3dZQmNZN3NkQi8rTnMzOGZrM1p5am1EbGlTb3BLQWNPYkNNQjIrY0szN3ZvMitQaGVjUE9sdElBUW5ubHphQXV3VXhuT04wb3RXbWZsRVlzcnhoaUcwWkJNUlcweG5OWTZLNW5iaDZmZzk3Lyt1OTM3MzkvLzFUMTU2NHVsblgvbks1My9sNTM3MkgvejBmRFlaK1lDRVE2aVhUblVYUDZEZ2dWQXdmcVhQVkQyNTJmdXZMak11M1RndU1Dazl1VHFLUEZMeFdXTnk0Q2g2Y2N3SVVPam5HWjVkNitLVDE3YWdiY0FYWHR6QkYxL2VRMTA1K1JEakkwOUZMclRnRG1MUU1LMGJhVnNobWVXVUFFMWpSZkduY2hTMVJlMHMxbGM2Q0NHZ3RuTEQ5anNweXFyQmVGVERkMUtFVElPdEF4S3pzSlJxWFdOYmMwZFIyVW5XV1Q1cnNPVXM3blE2Q01JUGhncUVSQVBUMm1FNktUQ2ZsNmpuRGh1SndyQ2ZJMVVhWkNWYzhaZ1pTUm5RWHpIWTJOSW80MVloY1RLdm43K1FRaHVnbkh2Wlpxam9paHNmY3Q0Rk9DZVN2Y1l5YWsyWTFTR0dOdWpvWVgrU2FDUFlncWplZWowRFVnVGJlQnlQS3lnYk1Pd01rYVhBYUNZdU1sbkdLQ3BHenlnY0hCU1lUaDB5VGFpVjhQaDEzR1o0SzlaVzFvdGZ2dmo4eVQwM25sbDg5ZVlCYnR3OTVLbjFYOXByK01kM0t2OEhmRUtFV1c3WEY3dHlBaWhkSkpIOU8vZzBQR3FGL3U3ekhXejJFM3A1dDVUN1JzQzNsQWhkQU5uM3ZIdnd4UGQveC9BdlhyNllYUFZnVmdEQkE3NlJ0VmJhWjlTRnh1R3hRZE1RR2s4UHVPaTFQUkVGSURRQjhNekZ6Tk5MdDQrYUd3VSsvNjZQL3NEYWYvSjMvcHUvK3RRekwzd3d5N3RiVjU5ODlybm5QL1NKcDRyWjVPQnc3OTZoZHk2aDlzNDVwUXNPQUJjZWR4S2pYM2xpby8vVTArZUg2NW1XVDZ1MmdaeUxpTDhINmtwK0hhUUdUdzRIK0w1M25jTjNYRnJEZkZMak0zOXdCeS9lUElhemZzRVdheE5GVlZSTkZaNHhhY1QxMWJxSWpFY0F2ODI1TUVhRFNHRmNWc2d6ZzE2ZW9ta3N5cXFHTVJwcG9uRndNRWRaZTlCV0R5NVNQRFZGRzhPSTdvdG9KU0JZdThnVU04eFlaY0pLWmpEcHBNSUI4UEZucVN4R2gzTk1qc2FZalN2NG1jT0ZRWXBMbXl0WXpUTjB0SUpKRklJaU5GVkFNUmRkL09xS0VVR0pVUml1SmJqMFJJNkRmWWZqL1VZZWNuUWlPT0c0Q2xPS1VGZmllMmNTa2hpbUpwcGdObUVSRnRtK2g5WUtwNzhWN3dUSTE0NExpenhSeUxzcGtoVG9kUW1UR1NITkRjWXpoL3M3VmZUdEV5QXVqYmlJaXE4QWdtVlo0ekxMeVg0OGJmRDVsM2Y0bGR1SFBHLzhsNDg4Zm1LdkNaOFBRb1pwWHcrdzNrZzJtQ0ZWQkNYMzB6dXowTjg4YW5EenFLYWlDY1N4WFNjZ1p5QTNpbnAvN3k5c2YreVQzOWI3Z2F4TFBRVEFOWXFxUXFHYUM0cWU5d0xxc1VJeDFmQk9UandialJFZFpGZnFnN1IvempHY1l6bzRxbkI3eHU2NXYvQ2ZaWC9sYi82OTc5dytkL0dDMFNicGREbzBIUGJUalkzdHE4ODkvKzN2WHhtdTBjNzlXL2VMMmRnQnBFL1JFTGx0dDhhVjI3ZUJYejYzMHRsKzRjcjZoZWN1RGZXVnRSNVc4cFE2aWNGR0o4UDE5VDYrNi9vMlB2M3VpM2pmK1ZWb0QvejJWM2Z4VzEvZHdjNVJBUXBCS0poTDN5UVFNQXZBSkFCVmRFMk9JYUR5aW10R0ZXOUdId2pqMGtHcmdOVitEa0NoYmhwaHhXVUo1dk1HbzFFRjlGUFFlbGQyMGRFYUNUR1JKQVNXL2JqM2dBOVFSdmJKeGpQV2xVTFFDdE5oQjhISUE4M2JBRHR2Y0xRL3dYdzZneTBiSkI2NHN0YkJoZWpYbnVVYVNTYithb2ttc0JVenljWUJlVWRzbTFlR0NRWXJLVzdmTEZBM1FKTFI0bW5kUmlzbFNiVGZvbWp5U0tJRVUwRnVuS2IwY0xVSWpRSUU1UW14SzBtTVd0RE1FUDBCUjNPTGZqL0JoZTBjczFsQTNqT3dqbkY0VU1ORUtxNVdoTHlqME92cHVMYVQ5OGtHOFlRM1VSSjdOS3I1OTc2MmcxZHZIemtIZlA2WTZTZDJhdi83Y1U4K1Arc2tKMElnQWlmaXhzdUlLc3AzWktFL2Q2R0xPOGUxVW9vb2hLaFFBM0lBK1VlZkdsejQyNS9hL0N2dnVwSjlJSGdHSE1oWkJkdkltcXpUbHlmdTRaNUJYUkpDelAreWlDMTdDOFJ4M1BrNm9HNkFHM2VQMGZTZjBCLzR3Zjk4dmROZnlhdTZwcUtxS1hnSElpS3ROZlY2SzJ0WG4zclBDMWV1dmV0aVZjNzNKcE9qYVYyVkxWdHYrUW9BTUtuYzBkRzgvbEpxbEgxeWUvRFV1ODROa3VldnJORzNQN0ZPMy9YME5sNjRzb2F0WG9hRDR3cWZmWEVYdi9XSDkzRnpkNHFxZHJKemJRRkRCVGdsZDBaN2Q5aGxJVEpPWm1qVmFySUJUQjB3YXNSVlp0aEwwVWtUbEhXRHVyRUFTME0rR2Rkb0FxRE9ENEE4Z1k3ZEIwVVhSMmxUUkJOS0xhaXNGSHdJNkRHd2tZaGJhNUlsU0wzNDJaVzF4OUhlQkh2M0QxRVdCWUtURWVYS1doL1h6cTJpMTAzUVRSUjZpY1F4YXhLampPNUtBdWlUWk51dHJRUmw0WEY4NUREb2F3UXZHV2p0bTYxaWZyeDNKNk5aNjJOdjV4NitEckxmWnBIdGhoQURIbzFzS1l4UnFKc0FaY1FIbnBuUjJJQW1BRDRvbk45S1JmVzMzOFRFSHVrQWxKS01ONlVrR0tOcHhBYUtUMVNzT0RpdThia1g3K1BHM2VPcTV2QWJlMHovOEtEaEwvdVRrL3gwa1lmWUluS3VUOEpFeS9EdlhqZVBWS0ZmMys1Z0pWZTBPN1lVVjJydDNqclhpcnAvNTdzM1gvajArd2QvdGQrbE5aWmxGeWtBWklXWDNCa3dtb0p3Zkt3eGI2SVFJakE4eVY2VkhDOUVDb0RFSEUwS2o5ZnVIaU4vNHR0cDgxMGZSaDBaTmlyR0h0ZE5BNjFOVElqaDdOcjFaNTkrNFlQZjljSndiVE9NancvMlJxTUR4OHlLV3JMNmt0Q2dhSHgxOTdqOHl1NXhjZTk0VWwzY0daWHJSNU9LYnU3TzhMblhEdWczWHR6QmI3K3lqNXVIYzlqR2kvMXdlM0JSdkJzSW1BdWY1T1JtWG5yUGFPbFhYb0p1SFlCQnBySGFNMUFzSHVyT09lSGlRNkd1QTZyQ2dWWnpxUFhPMGd3cktEMWlpSU9LYXpZRlFFWGxWL0NNSzcwY0t3cG9hb3N0S0tUSE5iSlJqV3h1c2U0OXRuTURIWUNEbWNPOENnQXJYRjN2WXBnYStlOWt3RGNSeFZkaW9kUjZCT1FkamExekNmWjJHNHhHZ3NoM085SHJMYmJyTmdCVkpSUllXY0dLR1NSY2dLOUZiOURKTlJJanUydU9JQjVwY1d4Vm1tS1dlL1N3MXhvdU1PYWxSZHBKWUpUQ3dZRjR3Q1ZKaklHMllnZmR4bGExRWR3TVFmY2JHN0IvVVBQdmZlVWVidHc1bXBRaC9QSmVvSjg0YXZqbElCOUxXK2oxVXFzZUFMQlJCQUt4aVhseXRlYy9VdTA4VW9XKzFrdncwdjJTUXVCV2M3NDR6YTl2NWh0LzkzczNmK2dEVDNjKzVjRUVKZ29Od1pZRTd3aTZLNGo3Ykt3eG5XbzBGbWhDVkNJeFE4ZDFUWkRaQjhFeUtndnNqR3JjUGFveGZPLzNvTE4xbGFxcWdITVdqVzNnT1VRQ0M4RTVSOVphQ2g0MFhGMWZ2M2I5M1I4OGQvSEpKN1JPcHFQai9WRlp6RnJSelFQRjdnUGphRzdmdkhFNHYvSEt6blR0cGJ2amMxKy9QekczRGd2TWlvYTBaK1JnSlBHUjNqRFF4Q0szY2Q0bVBHamlUVXVGdmJ6azl4Q1ZWYW9KYVp3ZEs4dW9DaWx5N3dNSUdrWnAxSE1IWndpMDNRVlNEVVkwWHpRYUNnVGYyTWdvMUdBbmZDRmxKS21rcXhXZTN4akFoSUN5Q2VoMU05ZzZvQ2t0MHNiQk5BRkRrK0xpb0FmRkNnZFRpNk9pZ1dIZzZrb0htWkc4TjZYaVVaWVEwa3dqNjBpWXdmcW1RYWVyOE1icmxVUmFSVUExYlUvU3dLaUxBRnRKdExPT2M3M1lSOHVPWDhkWlhtdHh6ckVzcTdyV09VWVorWjRoTUdycnhja21VY2h5QTUwbzNMd3pSOEtFUE5XeWNZamM5bDRXd3hVQm1GeEx0eGpOSys3c3p2RzdYN252MzdnLzJpOFFmdW11d3orZU90eGNrcHFXeTl4MUlnU3RpRFVSdDJ2VE9qRCtpRFgrYUJYNmYvdVhyK0ZyZCtZMEtSMkMzTmNDd2ttaGQvN2lCMWV2L3VDSGgzOWphOU5jQ0E3TURsUVdDdk5LYnBydVpnQWJ3c0ZCZ25HaDBEaGhKNG5CQ1MyY1hqekoveGZWRm5CM2I0Smp2WUhodTc4YnVydUNwcTR4R2gvajRIQlhBdldjUXdnTzF0YW9teG9NTVowa01zbmE1dm1uTGo3eDFBdFhycjRyei9MTytQN2RONm9nVkR5S0ozeXJ0VkFCdEEvd1M0YWhNK0JjU3RRemJTSUxnUm9BRlQ5b0JyWjhVcDkxZXZPcHA0b1dFaHRxVVhtaWRvekt5MnBSUWxRSm5VVEQxUUdORGFEMUhEVElKRURTaTF1TDFncGVMSEJoMGdRSzRxQkNNZDNWZTQ5TG5SUlBEbnZZT1pnQnBKQW5acEdueG9wUVZBNWxKUFlNRTRQVlRvSnBZM0YvVXFHZmFKd2Y1QUxxYVVMU1ZjaDZCbmxYUlFOS3h2cUd3ZUdodzd5UXpEYkpFWmY0NGFZVzAwdmZCQ1JHSWMwazJWVnJnb3FxTjQ1WmFvRUJEbkhIYlFpVXlvenRyYmo5aEVpRmxpNEh5SE9EbFpVTWRlV3hkMVNncUJ3NlJxSGZNVmdkR0t3TXRNUXFBK0k3b0lHcUZvM0JuWjBwZi9ZUDcxV3Y3MDYrTk5QOHYrODArTGt5WUNjVzltd0pkTFBMUEl4TlF4aHFZTFFJMlBqM3V4NlpRdi8wODJ2NHl1MFpIYzJkNHBPZGVVNUF0NS9wM3QvOCtPWkhQL2w4L3dmU0hIbXdqS3JRTktzMENpL0JoTjErd0h5aWNYQmtVRm5BeHBnVzcyVkd0N0hJRVYwOHZBT0trdkhtempIS3RYZGgvYm1QWWRCZmhYVU5uSGNMNy9aNU1VTlpsYkRXZ3BTQzh4Yk1UTlkyMURRVnI2NXVESysvNjMwdlhMcnkxSE9Ybm5qS0ZjVnNmckIzcjVIdEYya1NoSmdqUmphendGYzhjQkFZbXhaWWRZQ094YjNja1Q4QXd0SFNCN2tjbEgwYUNXd0h2dE5pNVJEUitpeEcvYm9tQUlNRWFxTUxCcU9wYTNHZ1ZSckJlMUR3U05Ka29kOUdqRzJ5UGlBRDQzMWJLOWpJRXR6Y0hhR1RaK2puUmtJa283R0ZKckYwQWdEWGVIUVRqVzVDMkovWGVITmNZYjJiNHZ4YUIwbFhJK2xvNUxsR1ZRZFVGV080S3NrMXh3Y2loUzJxeUtsbmprVXV1ZTFacm9VclQxZzhESnJDZ1IyUWRYUUVJK1dobWVSQ2htbERIWUpubEkyRVE3UlloTkdFWG02UVp4ckhveHBsNHpHdkhUZ3dOdm9wTm9aSmpNNlMwTVRHQTJVVFVNNEMzNzQveGVlK3ZqTzdjVEQ3OWJIR2orODErS3dUOVdONVNrL3VsNHNjQVBlMHhHQk4vSDlZL1R3eWhmN3NoUjU5NGVZVWxRMHE4QUp0N3pEUStmaTdWczcvOENmWGYrUzVaOUxudlFvTXI4ZzFCQnNVSEJTeVRrQzNFekE1TnBnWEdzN0svQzFlQ1pMWFhRVkdFd21zYkJuQkE1UEM0ZForZ1IwZUlGMi9qUFdOYytqM1Y1Q21HY0JBcDlPVGx0WUxCOTFaSzdMR3VrSlJGYkRla1dzc08xdlQydWE1Q3hjdlgvL0E1YXZQWE56WU9zOUhCenZUMlhSc1crd29NazVVWkllK1RzQ055Tm5aVkVDWHNCUWFJaDM0Z2lUVFhtNnB3TldwV1IxTHYzLzZCdEN4MEczMFZkZUpCcTJuOEpvUnZKZ3NpaTVlZzBPQVVncEdvbG9qUVFZeG5NRmpLMDN3dnUwaG5ITzRjekJGdjVlamt5VWdKUmJURW1JZ3FUTSsya2dGVFdEMjhFMkRPOU1HWSt0eC9jSUFXeHM1U0V0UWdYZFNiSGxIWTNKa1VjKzk2QlFpQ2hodDRtTmtrb3Ftbi9IQkVxV2lpTno0TkZQQ3JxT29KVkJBR3IzeHFsb01RbDJROVdHV1NWQkZva2lTZDF4QVZUcjUyV05ncExVQjNTeEJvZ1hWdHc2b0dzWjg3dkhhN1JHKzhQTHVtNjhkenY3Vkh2ai9tRGkwSm83ek04UXBIZ0NuQk81b2NNUEFQUHlIRi9ralZlZzNEeXFhRkk0Q3MrS1R0cjJqaURwLzdTUHI3LzlySDF2OUcvbVFCd0FCTlJFODRBS0JQYkF5REVoU3huaWtVWlVFMXpCc0kySUR2OVRiY296VmJSd2pPT0JnVk9MT2hIRS9kSEJZVERHZGpaQ1lGS3ZEVGZSNkEvUzZmUXg2SzBqU0RNd1NtcWkwaWRGQzB1STJUVTNCT3lxcmdyVTIrY2JtK2FmUFg3ejYvUFZuM25mdTBwV24wbUkyYVViSCsrV2lueWVwNFFEc2VlQnJBSTRJeUFqWWp0MjNGRjA4ek1PcE5wMGVVdUJ0a1M5RSsvSFZmbjM3a05BSlFhOG1DSm1DOHc3S0pEQkpBbVdNdEtNUVRBUFdpY3hXeGFLTjdmeWxQTVhWWVIvSDB3TDdreExkWGdjcU1mSkFaR0hPWllrOEpFcnJVWHUvTUxjNG1sYVlXY1orYWVIQnVMVGVCYkdzUUkwV3krcW1DcGdmV3NsYnl4U1NWTVdDNW9XWmgrTUZoMGVZYWs1YWNXaENraWxRSWhaUXBOdDg5UGh6cGNMZ3E1b2dENk80M1VpVXNBRWJGMUEza2dsbjNVbTgxYlN3OEFIb3hXSVBESXltRGI1NjQ1QS85K3JlbDE0Nm5QMlQrd0UvMXdUc2taemVzNGNvMEFJQXJCckMwQkRHL28rdmZoNkpRbGNBNWswZ0l0S0JId0RoT3RlMzh0VWYvWjZOSC9qUXV6dWY5QndZdFlCd2RTTmFjMjBZSyt2eTlKOGVhVFNWZ3ZXMHlBTnZXMWNFQWVUYU9KL0dNbTd2ei9GbW1hTHNiME9sT2FiVFl4d2Y3Y0ZaaXl6dElFa3owWDNiQnFRVmhzUDFXT0FPbmJ5RDFLVHd3VWZYVlNMbkxLeHR1RDhZRGk1Y3ZQcnNoY3ZYWG5qcW1mZGR1M3I5dVh3NlBpNk9qL2JtQUlJVU8ya0lqZm5WQUx4TWdyM2xEUFJVOUZRSlM4STdkYXJJYVlrMjJMN01xZDhqa3U5Q0J0QUcwQm1nQndyVUVYTU1iZVJSSUl4QnRiaGhxQ1dHcElsOFA4OW9yRVVIalBkc0RMSFdUZkhtM2dqejJtTjdyWThrTWNKSGp4UlpIOFNjb1hJZXRmT29HNHRaVVdGMzJpRHJwT2gyTkc0ZUZMQzF4MVkzazhqamprS2VhUlNGRjd2bmp1U2J0NW5vd1RPNERXSlFjVzUzaktvV2cwV09FbVVWN2E2amY0ZmdEa2JjVlJIL0hyTmdFWWxSQzlwbGNPS1dhNksvVzRoYkNJNkFhbG1KTjEyV0djeG1sai8vMmo1OWFYZXkrL3FzL3JIOXl2OGJsdUl1VHMzajdTbnVEWWx5T1RDNG93aEcvZkdjNUk5VW9VZGJ2MlZPZXhZTHZmdnA5dzJ2L3EyUHIvK3R0VFU2QnlhUUJYa25SZTQ5ME8wSFpQMkE2ZGhnUHRKb21waWoxWjZFVWZ3Z29Gek0xd3FFOGR6aTVuNkIrelJFR0d3alNUdElreFRPTnpnODNNRmtjaWc1NFVyQmVndnZIWXhKa1dVNWpEWVk5QWJvZG5zd0prR2VwdkpRa0dJaEw0RmExTzBOK3F2clc5Y3ZYcm4rL0x2ZjkrRXI1eTlleXcvMjcwMm5rK05wTEhoRFJDb0FoMDVPOTljSjJDZDUwR1VSaUl4bTBXK2QzMm1wVlErdFo1dVdva1lpVkZqVEFVd0dxQnlnckNWRjgySW4zdXJhZWNFMWxwTk9hUjI5eXdPYzgyanFCcGZ6SE05c0RLRVY4T2I5RVVCS0NqMzZyalBKenI4TUltT1ZnbUhVMW1FMHJUQnFHRmZPcmVEcDh5c1lGUmF2N0V3eFNBMHViZllXZm13K0FEcFZDN3ZxZHF4UU1SeFJreGhKc0krUnh4Qm5seXhUa2kwZlNZcytnb3VrVHZMZmZCRFZXeWRUaXplUkVPMmxvd2VnNkNaaXFFTVFhMnNWUlRCRjdUQ2Exbmp4Y0lhWGk4YVB0UDZsNDduN3hhWjJZNXhRSFU3VFdRTUF6alR4d0JBS0wvdnhQODRpZnlRSy9STWYvemh1MzdwRjBWNndCZUV5SW5SWHU2YjdOeit4K1ludmZYLy9oN1JCQWc5YVJPWTA4b0gyaHdHVUVJNzJEYXFaR0UySVZhK2c2K0lZUVpFWkZ6OXdCeHlNRzl3NXFqSEt0NUdzbmtlYTVORzlSZDZ5Y2o3RmFMU0hxcHdqVFROMHV3T1JHV3FETE0zUjZYU1FKQWs2ZVFmRHdRRGRUaGRhYTZScENpSlExZFRrdmVjUUFtVlpwenRjMjNqeTRxVnI3Mzd2Q3grNWR2N1NWYk8zYzNzeW40NW44V2JRRUdCOEp3Q3Zzcnp1QUxqSHdJRW1NdjNNNUoxVTY4UW85RktOMVU2S2xUekJTbWJRVHhXeUJOQUp3RmtzNkJSUXFhamNLQTc3N1FNaXNPaTlPUVF4ck5RYUtramduQ0loaG1DSkhsclZOZkxBZUc1ekZkdURIRVZsOGViZUJJa3hHSFp6K2VRSVlLTlFCa2FJMmVRS3JlMTBnK05aaGJ5VDRjbExxOWhhNmFLYktPeFBhOXdkRlhoaXE0dXRsWTQ0eWNhSEVFZlZJUWN4alJUWGx6YVpGUXRQZG1PaUdVZkVFZ0lMRjc2VmpJcGpLOGRBQ2ZrYUhRdTdLSjJrcEVUcXI3UFMxaXNTRzY4UWFXbGFpeWJoYUZ4aU9yYzhTelJOVS8zeTBiajZKOGNIODllWk1UOUZaeFVTRENFWVdaUnptejFmaFQrWk9ucmJGL3JWSjU3QWJEcWx1cWsxc3hRNkVYSXdlaDk1MTJEcjczenZ4dCs2ZGlGNXhrY21uUFJTaEdDbEZjM1hHRTFGbUJ4cDFJMWEzQURlTTA0TWtOclRRYUkzR2cvc0hKVzROd21ZZERaZ2VtdWk4bElHV3FmUUpoR2pTRzh4bVJ4aGZMd1A1eHBrZVE5WjJnSEFxS3BTREF1VVhtamNFNU9nazJkUVNrY3pRRVdwTVhET3NYTU9hZGJ0cjZ4dVhMdDIvYm4zZk9qRG4zcHFzTEtHZTNmZm1EWjEyY1FKM29Bb0JLSWpUM1RIQVM4SDRMVzFYdHE4NThMSzA1ZldlL2xhUCtXdFFVWVhoaDFzOXpLczkxSnNESEtzWmdaOVRkQUlLQnJHM0VxL3I1YjZmV281bHZFc004YUkxN2tFZ0VWTEtHbnJPVVlPV1d0UnoydWN5M0k4dVQ3QXNKdmlZRnJnM3RFVS9XNEgvVTZHUUlEWEpMQXloNWh6RnI5ZllKUzFSV1VkcmwvWndNWE5BYXJhb1pNWWRJM0MvVkdCV3djRjF2SVV3enlSTlI1SGdNNktTRWR5NFU3ODVLSWhEeWk2dTFBOHVWc2dJekF0aWx0NEZFQ1NFTG9kQlVPRXNwUlJ6MEFNTHBORUM2THVvdzhlQVJUazUwaVVRbTA5NW1XREpEUFkzdXlUU3ZYQjdxajhtVnYzeHIvcGJKZ3VzZDBXb0JzaHVvRkxzaE1jLzhrVitTTlI2TmV1WHFYN096dG9ta2JGUWs4MVVTZE5WUHFESDFyNzRBOS9iTzJIdGVFZWxNUjRDU3RUanBDMHkwaUd3bTJmalF3cVM2Z2RpVDFIcEVXR2xyb1phREY3alV1UE83c3o3SVErbXVFbG1Ld2pIUllSakVtaGRBSnRETEtzQzRCZ214S1Q4U0ZHeDN2dzNpRkxKUXhBSkpVTzQra0V6anFZeE1BSFFab2IyeURMVXF6MEI4aXlsSXhKcUpPbm5CaERhZDRkREFhclY5LzliUjkrei9ybWVYcjE1UysvVVJXenR0WERDZUJPbWttNWJxcXpsWVNlVHhFR3RtNmdpR2tsVDVFcUJXVVVzc3dnU3hNWUlvVGFvWng3ekJvSWw4QUJ6a1YrUDRtVHFZNHNOSzFJVENtamtZUlNPbHBTeTdQQlc0dkp0RUxpTlo1Wlc4SFdJRWVlYU53OW5HSTByekhzZGFCVGd5SUVWRUhBT0cxME5HbFU2Q1JpcFRXZVZ4ajJNenozNUpicytTc0hLRUluMVJnWE5XNGVsaGpQR2x4ZDY2S2JKN0JXREI4cGhoOUNTVUlzZTE2RUtDd0VKZm9raENGRThibVBBZ0NPRDdjMFZjaHpMZUlUeDZocmNYNWQ2U2RpNzd3VUlhV0pZQ0x6dDJVTE1qRUd2WlNUM0dBTXJ1OU5xbDk0OWU3b1g4em16UjRldEg1eVJQQ2tpSlBNUUxuQVRQajNJc0Q4VWErM3ZVeFZHd05yN1FKRElvSU96UHJ5UnQ3NTVQT0RqL1NHdE9ZNU1CRXB0Z0t5TkU3MndRYU1VQkI4UWFEQUNLeGd3V2hpWmhaQzlHMlB0a0thQ0JZU1FUeHZHSFc2Z3FRN1JKNzM0cEduNCtFbnhnWTJxclh5dkE4d1VCVUYzcnp4RXZaMzcrREN4YXU0ZE9rcDZDUkRZeHZVVFlVQVJwcWtNdU9TUVpybWdKSXdSaWt5UTBtbWtCak5QckN5MXA5bnhxQ3BLdjNjODkvK251Lzk4My9qQTd2M2I5MzUycGQrNS83TjExK2NWRlhwd2N4SFJYTzcyMDArYTg2di9HRGEwWjE4MnJDdUFnVklzSGFJdnVwYUMrc3RCYUhEakVrczlOaUpvMVlNMHdKektpREpHRVlEUmltd1ZnanNKWUFCVWJvN2QyaEs0SW10RGpiN09SS3Q0MjdiUXNmNXZnNEJiQVRZSXFQQkpGVFVuSUF0cmJFenE1Q2tDdGN2cnFGakZHYU5GLzk0QnNvYW1EWUJKZ0hlSE0zeDJaZjM4ZWVldnlBM1FSd0h5RXVJSk1kTkNaT0FnMHJIK2QwdDdTU2pRd25IdGwxckxJRnRITmQ0b2hOWGlRQnpnNDZHZHc3T2ltVzJKMExWeEVnc0ZuN21zSi96Z2ZXNE1TMnhYOVMvY1hkMzlzK1B4dFY5bkdFV3dTeDNuVTQxKzhySlNoZVBDMTBZYXllaVd4RkJLdUpuTCtUblB2cHM5enVRQktNQ2dSdkFXVUxUS0hIdVNBSlVKdHoyZWFsaEViMjFveW1CSjRJbjBVZnIyTVk1QWlvUWlzcWk4QnBOcncranBFVW5DUDlacCtMQXd1ekJ6a2FabzRkU2tuRHFmSVA1YklyWFh2NUQ3TzNjd1pXcnorTGlwU2ZoUWtBWjZiUEJCM1N5SEhWbHhaemZOaWlyRXFrMkdLNzBzTEU2UUc0UzdPM3VqdTY4K2ZMZTlzWExIL2pFOS8zUXA3N24wMy9wL1kzMTdxLyt5SDlSN2UzY3Z2UDUzLzMxRjIvZmZPVjRiL2RPcVZkMk1YanZCdnFVSVhseEg4MTBDcTlGb3cxbWNJdy9Wb2xHbGdLcGphMHBUbHBkTVM0OEtYeWFpMFYya25oNVA1VkVXdmdBVkxXNG4yNTBVcHdmWkRCS0lUVUtWV05SVkExU3JXRWlLVVpETXRhRFVxaUM4T0xYdGNaNFdtRnZWR0p0dFlNa1MxRTBZdnBtRWcxMkFmdmpFdlBhUlZOWnhoZnVqN0RhUy9HUnA3WkFPb1lwV2dsa1FLVE10aWc0eDBnckg5Y3JpZ2hKQytLRnVGczMwVHVPR2ZVOG9LazlWS0xFbGhsaWRVVU1wRXdTUFUxUkFCTTdRYXNZUGxOOFkxN2czcnlaVGtyNzYvdUh4VDg1T2lwZXcwUE1JbUozd1J3WXpaOWlIYjM5VDNReE1seXNpQmxBTjFWNC83WGVFMnNyNmpMN2lBc0hnQzFnS3lCWWdzcGxMck0xb1NqRnpNOHdJeWNSU01Eeklra2xqUThTeTBCcEF5YUZ3eHdwUXRLUnRKYmdFZGdoQlBGc1N6S2hhQnFUZ2hFUW5FTTc4WE1JY0tHR01SbW0wekZlZi9Vck9EcmN4ZVVyMTlGZldaZTVGSXg1T1VjSUh0YWxDTUhEVzRzNkJFeG1nTFVPbXh0YkdJK1B5OGxrZFBrdi9jYy8rdjFQUGYzOEUydXJ3N3dvSzZvcWgrdFB2ZWZDdFNlZmVaKzF6aFhGckw2Lzl4VjlYSHc5bjczNk5VeG45OG5iR2g2eWVSQUdtd0dna0NZSjBpUUJLWWNFZ0dJSmdYeUFMYmR3WElrMFlRZFUxWWsxV1hSY2hpSENhc2Rna0lyVHFtSmdYRGFvR29kQnY0ZHVKd1VTS2E2cThWQ20xWGt6eXNLaXJEMjZ4aUJWQm5VdFU0blNraGJybk1kaFVjTjZodFlLeWdETURwOTlZeCtydWNGN3I2N0R4OWhjVVB4N0xHbW5hU2E4OU1hR3FGTlhTQk54RDJyMTZoVHRtSWxseng0VXczUmpMQk9BcGhMZmUxSHJDZUZtVkZySnF1T0FtL01DOTJ2TFFSUFBYYmd6TCt3dkhCeVUvM0kycTI5SEsvQmlDV0gzcDVqTFlvYjV1TkR4TUxhbnhNc29CV3V6ODErK1lVd3ZCNFlkUmw4emZEUnJhQVBTMlFKVm9WQmJRckRpNjY0QVpNeElHS2laNGVPczdrajQzMVh0TVM0Y0N0MkhTbkxKUWhORGFXZ3RybVZOT1JjVU9YZ1luY2IxRXlOTk9ndmVlL0FPcEFoTlhXSjM1eFlPRCs1amEvc2lubjN1Qld3UXRhaThBQUFsY2tsRVFWU3Nib2t3blJtTmJkRFlSbXlRWElPNnFURXY1ckFCMkRzODZuL2dPNy9uSTg4Ly84R05sZUZHMmxoSFdpa2tpVUtTS2tWSU9sb3JsZWNiMk5yOGM5ellqMUg5MUNIY0oyYVlIdHpCN2EvOEJpWjdkMkNiQ3BQOXV6amUyME5aV2dUTDBhQkMvTEZKS2NpamFtR1dGd3VlSHlqK0ZzeHFKWmRHRTlhNktYcTVRVGMxQ015WUZEVUNFVHJkRk1PVkRNb29lQjh3cnowQ3hMMjM1b0RTQjJ4a0NZWlpnb29DYkZ4M2VTZis5a2V6QnJ1VEJrMEFEQk1NRTdJc3dKTEQ3OTQ2d3ZuVkx0WUdHVUxMZllqT3JoUkpNd3ZyanlBdEJiTzA4VDR3ZENwN2NYR0VqVE15RWJLb1gzZE5XSUI3WmUyaGpJTEtGYlJUT0o0VXVEa3ZjYXV1QWEwY04velY4Ymo1bWVOUjlkdDE3U2VuRkdnUE1ON091SjhmRi9xQzF1a2NLYVdXWTJiQ3RITHVNMTg1L29QTjN1RG8wbloyWVRYVFlaaEF3VE1TeFVnTWtCV0VicUhSTkJvMVJFZk4wZFUxWVVLanhKYW04b3dTQkhLQzVNNW1EV1pPQjV1dGdFeEtIRUxNWHhQN1VTS05BQytjYjFLTEdaOEk0cmZPQVNaSm9aUVJSVmp3U05JVXpsbThjZU5yMk51OWpVdVhuOEtWSzA5amZXTWJ2VzR2RW5ScVlYQUZENEtoMlhTQzNtQTQyTmpjSHBoOEJVWFZrUFZBbGlZU0hGRFdsQmhOaWRGTWlOVFB0SXQrcnc5RmhQV3I3OGI1OTM0TW9TbkJ2c0hzNEM1MmJud1YwK2tFTzIrK2l0dTNibUYzVnVMK3dSN0twb1lKQWM3WmhlTnNpT2dUTTRQNTdNZXVVY0JLcXFHNGxYUUdUTW9hUmlzTXVwazhWRlZFdVRPRm1aT0hpVkdFMGt1a2M2ZVh3UHVBeWpwUWxrQkRaS052aml3MkxqMkZDNWxCM3VuREpBbGUvdkx2UUtIQlhsM2dOMi9zNGZ2ZmN4R2RWSGpyV2E1aTl5RitiTENDMDFnWGtKQVN4eUFYL2ZTQ2lHRUNpMHFSaUpHbTRnUG5IY05ic1pSeTdXWW1NTXJhNGNiQkJGODZHS0ZVeEVhcDRFcjNoMGRqKzc4ZGo2cy85SUhiUGZsWkozbjRzeXp5UjZMUXZmY3d4cUN1NjViZjRobkE2L3V6bDM3LzlhUC8rei9xbi91N0NTUHZRSVZVRWRVV05Lc1o5VmlLMjJTQVRzU2hnbUthSnpzeDhETWFTSTA0ZjFqRnNHQ01TNCtkOGV6K1RqS1piVythUzFuZTdUcGJnem5BZTBleXcyc2psRHdvRUpUU01EcUxlSUljTWNGN2NIQXdTUVpBUTJtRkxPdkJOZzFlZmZuTHVIbmpSVnk1OWh3dVhMaUdKSk1DN1hUNjRraHFFaVJKQXVaQXpqV295Z3JNQWM1N09POEVCWTg3ZmEwVnBZa0JJNFdQdVd6YUdBUXY5dERhNU9qMFZ6SGN2b3FyNy84ZUFJeGlmSVJxZWdqblBVYmpZMHluSXh3ZjdPTDJtNjlpTnB2aTZQZ0FSNGU3cUtvYXhYeUdFRHpxdWtid0hzWm91SmhjdUpFVHRqZFgwYzhNaUIzcW1sRmJScDduU0xNRWVhZUR4Q2pNWFFDQk1OQUVrK2FZenlyNExJVWE5TEZ5K1FwV2V3TnNwaXRJQjV0UWFZNmdNbHlqRERydllYcThqN3UzWHNmTEwzMFpqV2VrQ2FCMHdOZjJ4MWg5UGNYM3ZQYzhsQlpjcHBrNzJNb2p5YlY0MzRjSXJESEVUaW93ZWxxSU55REF4dncyeFlCdG5PelhqUkxGR290aEJFQVl6UnA4YWVjSXIwNW5ZSzFCSUpxUDZ1UFJRZmxMazRBdk1yTmJLdkxUSi9tZmVaRS9Fb1hlU2lCeHdsWjF6TndjRjQzNjNJMkQvek5sZis2cHpmeFRtOE44WmJ1ZmRWWjdCb2ttU1NJbUltc0IxR0ZCcFEydE9WK1VKdnFZMnNaQjVzaEphYm1zN1ZkZWZ1VkxQMzk0UFBxMko5NzFiUi9mdkhEbGlUUkpCOEU3V0dmWjJwcVk1ZFFMMnNTVm00bCtZVzNpSDROTUdrMzcvY0tCeFNRWmxEYnczdUxPN2Rkdy8rNU5aSGtQVzlzWHNiVjFDWnRiNThHa3hHTU5RSloxb0pWQ1ZjN2huSVd6TmVxNlJwYmx5TklVenNsTVg5VTFGTVRxeVFSR1lneUlOS3l6TUU2RE9jRFdjd0dYMGhUNTFpVUVabXhmdWk0ckx4YXN3WHNQSDl6QzZYVStIU01FaDkzZCs1ak5KdWozY3N5bXgwaXpEZ3c4emcrN0NPVWMxZEY5ZUJET1QrZGdNSHJkRGt6ZUF5a2pFbGlUd1NRcHVzTnRzRXBBcGdlVDVrSjJVQXBWVmVQZ2NBL2o2Ump6NlFnM1gva1Nicno0QjlqYnVZWEo4WDBFYjZHVElJNHdEZ2pzOGVYZEVhNmQ2K1BwclpXWXI4WXdtWVpPU0JCMGo3Z2JGL1piRnJ1SnB2WWdFaDE2YTEzTlRVRFcxWEErb0dsUDg4RFlteGI0M04xRDNHOHN5TWpXWWpLcS9QeXdmcW4yL1B0TXNBUVUvRmJ3N2JTSUVJOEwvUnRjSVFRMnhyVFRsb2R3Q3hvQTZ0WnhzWGZ2cVBpZmVwcit6ZmxlOHZIemcveEQyK3Y1eG9YTnp1cGFKMDNXQmhrMmh4bU1VaHdnNkNrRWZDTFJMQ08yYU1EY09qNGMxVFNiTlpQS2hkZENDRGYyN3R4NGRmL2VtLy8yM09VblAzNzVxWGQvYXJoMjdrclc2YStrYVFmQlc2NnFHWnh0RnJuSFJKSlVvdU1Pblpsaktrd1R5U0VlUVhrb0VvMDhNVURhb0txbXVIWHpaZXpjZnhOYjI1ZHgvdndWNUhrSEFORHZEN0EyWEVPdk54QVdXVGxINEJvVTJlMCt5TTZadmNROGQ5TVV4bWhZTDVsZXJWMFN4NWdmS09sRXZIT295Z1lNSUUxRW5LSzFGbVJlbWJnelZsamJPQThpeHViMmxUaXpNL0k4UVpvYWVaakVyRFVYSU9NTWkrQmpYbFNZeldzQTR1ZnV2VWRWRlFBWTNUVERkRGJCdmJ0M2NYaTRqOG5rQ0xQcENMT2p1OWkvOXpwdTMzNERCN3Yzd0xaR3kvcFBVbG9RKzF1RS9haXA4S3N2M1VjR3dvVzFic3hURXdxaGp3dlpJR0xHQmZJZXVGM0RpVDVlUjhkV1owajI1NUZaWnh1UE53OW4rTUxlTVk2Y2gwa01rc1NnbkR2TWo1cERkdUZmMTRSYllOVDhZTHYrZ0svLzI0bEcvcmErUHZheGorR3puLzBzYWEzSmU5L0N4d2JSZElLSjBqaEVyaG5nV2g5NDcxcE9IK3dtNm5KdTlMbkw1d2JEeTl1OXZKK2FiS3VmWTJPWWc0eGtZZFdCVVpVZSswY1Y3dTVOVVpTMm12dncyUmVQNWovKzVxaDhJMjZHYXRuZjA3WGV5dnJIbm5qNnZSL2V2dlRVdGJ6YjJ5QkZHUWNKTEd3UmR5S0NUbEtaY1Jrd0pvbG9zaEh5U2JSeEZ1YVdGRmJMOUhHdUFTbU5MQlgybk5ZYWErdm5NRmdab3B0M3NicTZEbU5TcEttQk1RbDZYU0h5SkViSE9WOVFZcU1KaWhUcXhvS0lvWlNRUVhUOE43MTNjTTRqQkkvRXBFaFRjWU9saUhxSHBleHlBZTE0d1EwSENhdFFSMy8zTERWSWpKS3Vvckd3VGl5Z3E4YWlLQXBVVlluSmRJVFI2QkRIeHdlb213YVQ2UmpUNlJoMVU4SDRHbFRzZzhvallINkFHL2QyY09kb0JwVVFvckowa2JmV2V0K1JkTmlSbjA3NHRuTnIrTzdyNTVGcmNZZ3hjVDJtRlNHTExvb1U0NUtkRjJtdFRoUmM3WVVacUFpMUY4MkRWb1RSdk1Icmh4TzhQSjVpRnVSOTBFWWpNR0gvN3NRMjQrcFhTK0IvckJoM1lycytQMVhvL0habzF4K3BRbTh2cFJTRkVKWlZscTBtUFl1SHRTUWVnRk13MGhUWTdCQ2VUUmpYZWdrdTlSTDFyclYrNTl5VmM0T1ZyZFdzbDJsdDhpeEZVVmpjUFpoalhOUjdwUSsvZm50YS8veU5jZlVpVGxJcWlVaVJSTEd3QWJEWjdROC9kUG5wOTN4NFkvdnlDLzNWalNlTU1SMnRremJEbkgzdzRCQ0lPY0M1UmdMOGpPUi82Ymh2bHhOVW5GY1dWczFhUXlzTjUyd0U5bGhhNmhDUVpUbTZ2UUY2dlJWME8xMllPTWV2cmExanBkZVgrR1dkSVBpQU5FM1I2WFRnckZ0d3V2TTBSWkprTWdvcEZiOVBneVNWQU1WRXg1OHIzcDhjN1psQUp3NHlyZDFVWUtCeG9yLzMzcUdwUzR6R3g2aktPYXE2aGc4U0wxVVVjeHdmSCtIZ2NBOWxWYUN4RllKelVHelI1UW85S3BGVWh5aU85dkhxL1dPVTFxTDBWc2hNRVFUemNiL1BjZll5WnBsUUliK2ZHWU1QWDlqQys4NnZJVXNWa2xTTHVDVktUL05jcEtNMldsKzNnYldLZ2NhSkhyNmxTZTVPSzN4cDV4aDNpd3FzRlJJdCtJbzJoZzkzcDVqdHorNXd3SDkzelBpdHVFYWJMalBmM2k0eitTTmI2RnByaXJHN3A1V1h5eWt0NmRLSnZ6QUVKV0RRMGJpWUIxd3pqS3RyUFhWdWtDWVgrNW01cUkybXdKak9QZi95VncvbVAxKzRjSXdUZFZIN2RGWUFHUW1KNEZidHVkN3Ryenh6NmZwN3ZudDE0OXdIODA3ditzcmFkczlrT1lKM3pERWlPQVJIMFQ0S0lUaDQ3d0FDMHJRRGtGNElSQUE1L1pYU01lZ3hJRVRhbWxJYUlDVkY3ejI4ZDVGbjNxRFQ2U0hMTWxobjVXR2hDRm1XWWRBYmdFZ2p5enBnRmo1Q2xtVWlvZTMwb0xXQ1ZnWkprZ0xNeVBJVTNzVklaZ2dxN1gxQUU1RjQwWXhYc0kyc0FNdHFEdThjeXJKRVdjNHhuNDNoWENNT08xQWdaUUNkZ0wxSG51VlFDRWp0SVZJL1E3Y1pJYk1UR0hKb0dvdlhkeWI0M0p0SGdHWmtHb3RZcVpQTlMxd0ZKbEZXU3lldm1JT0pmcHJpRTFmTzRlbU5GYVNwdU1za0NraWlMQlVRRzJqbldxMURnRWxsNVBCQi92dHVIRTd4cGQxakhGb0JIVFVwS0syUXBBYlRjYzNIZHlhV3ZQL1pNZWdmMnNEaldPVHpKUUR1YlRXWFA2cUZEdS85V1hKcmZjYkxuSHExeTJFRG9nek1DWURCQnVGcXFvRXNON1A3WlhpbDltRVMxOHZOMG5xa1BYRGJmemNGS0NWQXMvRE9ocVRVMHh2bkxyLy8wclYzdjZzM1hIdDNmMlh0Y3BaM3U1TEdFYVM0SlErWnJLdmhiQTFTQW9BbEpvV09vSjFXU2xCNnBhR29qUXdXeEpwVUc3allKcjU2Vk9VTXpIS1NlMjhSdkJVd3pWbkpFT1BvbkVvS3BCUkNrSldnaWFlM2pyeDFCc0dZUkZ4ZW5GL1FZaGhpZ3l5WWc1em83WWx2WFJPTE1XYXJSOGtweDVSVEFpTU5OUWFxUW1vQ0tOUllEY2RJWWVHYUJsVmxRYVJSTlI2djdZenc4dTRJcmFTTlk2a294S2oxTnZZcE9tV1FpdjUzMUlweVJDWjZwZC9ISnk2Zng5YXdLN25tMFlaSkNDK1NNMjlyQnFsWWpZcVFwUnFqb3NIWDk4WjQ4WENNdWZkSWtpUm0zeEZNbXFBcUhSL2NIa05WOWc4S3d0K2ZCYnlFczdYbC9IWTd5Ui9WUWovOWM1L2xyN0Rzc3FTWFRuNno5T2NVU1hiUmZnQlJwTGdvOHRQaDh1MzNXZTRnVWlKS21hRkY2WTBFd05iSyt0WlRGNTU0NWtNcmExc2ZTdEwwZW5ld3VwbGttU1NNZ3BnNWNQQ09RRVRlTjZDNDR5ZGdJUWx0RlhKYVM3b3FZcnZkcnU4RUZDTllLK2tneHFUQzRGYWlGWGV1aVU2MUZid1R0eXJpeU91UFBGRWlCUTZ5OTlkSnVsRGp0ZGlCaW1rc3pDSE83L0s5aGNNZUU4K0pRS1JCSkViNDVCcW9aZ2JqcHVpNkFsdDJnbDdYWTZZOG1BTjZtUUVDWVRKck1Dc3NGQmpUZVkydjNoM2gxbkdCTEJHOWZBdFU2cWlmanpieUlCMzk3WlRNNkxwOVdDa2xubmFlOGV6YUtqNzh4RGJ5eEVpS0RjdU9YTXVUR2FEV2UwQyt4M0ZSNDh1N3gzamxhSUtHQTdJMGhUWkdnRW1qVURlZUQrN09RTE42MXdIL3d6SGpNeEY4YTF2MmVtbVZocmRyb1Q4eVZsSVBDWmxhQmoyV2ZSSDlxWmM3MVk2N3BRK24vZk5tcVFVN1RYWUlEL20zWTd0RzBSY0Q4N29zN2h6dTNQNzY0YzZ0cnhXejBjdTJxZCt3ZFFWU2FxQVVaY3BvTXRvUVFLeVVnVkt5QzB5U0ROckluSytWQVNCck9WblBCY2hEZ1VCS0w1NDlXcHZGMTdZb3ZHUjlxNU1IQkVoa3RWRXJ2NkNNMFVsbW1tcWxxVVJSYnk1V1dFWnBxQmc0RTBEd3BDU01JQVFRQnhoZllWVlZPSzhtNk5YNzZNenZZSzNad1JBakRNSVUzYW9FaDRCR0s4bUExd3ErOFpqUEdsUzFnMjBjOW83bmVQT29SR1ZQaURsYXh4TmJpY0JHcVpOTU9UR0xvRVdtdVRZYVNSVHJhSzB4Ymhva3BEQk0waGl4eEhIOEZ2eEJKU0xGYld6QW02TVpmdWZXTHQ0Y1R4R0lrU1dTVTIrMGdsWUs4N25GMGM0Y2V0WTRNUDZmTWZCei9xMmttT1dUbk4rMkJ5WGVHZGZEQ3Y2QndvemU5NDVPaXRuR0FyY2t2KzlPRlRMandRenFzUFJyK3hCd1N3OFNUMFFNb1BiTzdzK25veHNITzdlK09qbmUrNHB0bWxjblIzdXpwaTdtcEhRbnpmTk8xdW1SSWdWak1wQlNyTFNCU1RKb0hXZDFkV0xsNkd4TnpNeGFHeUlRY3dqRUNMSEZsK0tXZGozSTdLcWlBMHdRZEwwdERrMDZNdmRVYkxBWlB2ZzRXYlQvY1FxT2xSUTNTN1NUNUY2VjJLQUpMcVZUYkRZSGVGTHQ0N25PRVM2Yk1Yck5DR0U2UXNZV1pHVFZ4dzZZMWg0dUFtTW1pSWY4YUZhamFpeEdreEt2Nzg4d2pmN3JJZXF5VzJXWmxvV0V2Q0R2dUlvalRPc1cwNm9KNWNHazRBQWNWdzA2cEpBcERSOENqSXJjZGhKbm5JTjVneS9lTzhKWERzWTRxaHNZa3lCTE01aFU1TWRFQ3VOeGpkSGVuTTNja2dFK093RitvZ0pPeTA3dEtYcnIyL1lpdkxNdm9nZmIvT1YybjVaOHowK2NwZUt2TXZvUndvT3R4T2wvUTUrTUFndDhJSkhXbnBLSTByZnRmZ2ZBY0RCY1cxdFpQL2Y4WUczejNjT05jeDhkcm05ZlM5T3U2S3JGbTBuQXRrWE9tVkJTbVptSld2V1YrSXlIWUVHa3lKZ3NudFNNRUVTWG1hUWRFQlNzYmVCY0UwazcwaDFvbFVqTGJUUmM4UEN1aWQvWGdvTkhwZ0p5TkVqWW8wTTFWaktMemJTQ3JncXM1UUhCZWRqQ0lvdU9xMG1pTVo1YjdCNDNJRU1ZUjJPL3BQWVlseGJVTmFEQXlMUkNVVGtjelNyTXl4cHY3RTF4ZDlvc1RCWVhUK1lZL1p3WVFkbVRSRDRzMXlER0pnR1UwSUxmcnJXRU0xRGNNSGdHdHJJTUg5N2N3RENUazczVE04aFRqZDE1aFMvZVA4TE92SkpNTmpwNUFKQldFcWg0WEdOK1hIRzM4YVNCcjA2Qi8za01mSTRmVEw2cVQ0MTMvTGpRL3l4YkZscmtqcEZlempnbGtJL0JCWWtDRWtXTFAwcWo4OHE0QWJ1M2pneW5FNDlPNHdSbmdZTEpVc0VuQURLbDlNcjZ1WXRYdTRQVjU3S3NlMjNqL0pWM3IyOWRmRVpwblRsbnhYNEc0S2F1bEhNMmFKR2dVVHRUSjJrWDdEMkNzNkI0ZXZ0STF0SEdzRllKdE5HVXBHTFJYTTducUpzS0hCb0UxUExmWERmb2VvZVVHdEdmazBXWEd2U05oV0VMMTNoa21qRG9BSGtpcGhRY2hFN2FWQUY1cnVHOVpLTVZsY1BlMUVKbENsTW55U2V1Y0hEV1ErY2FvWFl3U3FGcUhPWmxneHM3WTd4MlVJalR6bW1TVkN6MlFJRFJRTGNISkhGaUVmVVpBSzNFbFRicURLSm5LNVlWZGxlN1BieHZmUjNydlF3NlUzanRlSUpYajZZWTFVME1uRkNMRGlFd01KdFp6TVlOdUhLaDUxa2x3TDBaOEErT2dGOE53QVFuN3EzMUdhZjUyN3JRelR1OTBGdWxWVXJnNk9jdmhBdE5QTGJ5MlJnQ0Jva1lGWGdHakNLc3BER0U4T0Zqd3ZML2ZrdnkwYW1pWHlwNE1nRFhJZmo1d2YzYis3aC8rNnRLNi94NC85NzZ5dHJtZTNXU3JzYVpQK1VRRUh5VGVPOGRrZXJFL1hZT0FuZDcvZUg1cDljKzN0bm9icE1uSnZaRW9WVzNhV1FkQS9hKzNyOXpoTU85NDlRR1Iwb0hyRzNtNkEwMU1xMkJVUUdxRytSRmc3NGk1TjBFV2FxUmtoTGR1UmJYVTJzQnNFYVdLVFF4SUtIeEhra1VoemduUkJUTEFZb3BHbmdBTnRjSUpFcEJaWVExU0ZwUTd0dkhKVnc4K1UrL2lScXk0L1lTYlk1eURyaE1UdmFFQUJnVklWUngvZkVCQ01ReE5wb1FqWWJ3NW53R0lzS1RZWUJiTzNQc2xqVWNSeTk2clVXdnpzQjhaakdiTnJDbFIyb0RkK1ZET3BvRFB6MEdmak9jT0xpZXByZytFa1grTFZIb2JZeE5hTlBxMmpiUkw1a2hRdWJRUlpJcUdJMG5lT1kveXZNa25GSDhQaGE4UFNsNk5xZUt2d3JlNjRPZDIwY0hPN2R2S0sxVnRIdFdKMDdPTEE0NkVseGhtRU95Y1g1dzRjSjdyeit0Vm9iYmFBS1REeHhxRjJiSFpURS9uTzNYUlgxdk5pdDd4d2Z6cDVKdW1wNjd1b0h6bDlmUUg2VGdJRzIrWCsxZzNrdFJGZzFtc3dick5tRGdHWnFGN2VZdHd6c1BvMFdrNDF4QWtvZ0lpR08rZUpKSVdSVzFSK01rQmlsQVVsdnEycUlwSFZoTE9tbFJXaHhQU3J4eWI0elNCcWd6S21WNU5qSnRUMnhsbDg0S2NBa2p6Ums2RTQ2NjdOTjVBU1pDUlRBU3NoRzRWOWZZUDJqUWNOVGxVelFDclQzS3VZV3R4SERDZUVhUHdabDgrOTA1OE05R3dQOW5nVU9jZUw0OWtrWCtMVkhvN1ZXOGhjcHc4dmxVSHFpV2pidnN2OWZuZDlaZjhFdkY3bUtCMjRmdi8wbXpEeW9zT2dKZXhoazBBTTF4OXUvMDB3dTlmdWZjZUg4K1A3NHozaW1QaWplTzk2YjNtM216NzZ5cnlhaG51dXVkajUrL3ZyMnl2YlZLdzJHR3ZKdUk4MjEwUmFUQUNFU3dlWW9qcFhGY1c1aWl3V0RXWUUwckRJblEwUXBNa2pyYk5FRFRpTXNNR2JIdHFpc0IrcXBJTCswYU1lQjBubEdWRFh6ajRSSkp4ems4bXVIVjNTa09TN3ZZaytPRWtmUkFFQVdmM3A4eVlOcDNzd21BQnJ5T2hoTUdDRnBjWTRJU3lsdHJaZVdDR0lwUUFKeGxOSTdoR3cvckpTa21BZEJqSUkyNGpBTU9TdUFmVDRCZmRNRFJFdmgyV3BIR2o5TDlUM2g4L1dtOXg4czI2MHY3L0VYUjA2bmZQLzMzSHVENTk0YjV1YzNMd3o4M09peXJjbEx1Qnh2bUliRHBEZk9yS3hjRzN6ZmM3SDlnZld2UUgzWVRTcGtSR2c4T0FQVXpjQnFUQXJ3d3dwd044RmFDRkFNelF1T2dLNHZVZXZRcWh5RURhLzBjdmR3SUNZVUJrMnB4UlcwQ0FnZU1Lb3VEV1kzaGFnZmVFSTVMaStsa2pseHB1TnJqL3VFTU40OUx6QnEvV0tPZFRwYmhoOXlRWnlHZ0tRbTIwZ3BjZEd0WlRkRWtJeWF3ZUErd0V6c3lqYmhENTVPVmt6cjVVbmhnWEFNL093RisxcDJjNU11ck5QdVE3dTF4b1QrK3pyeGZIN3pQaVpRUXk4OU1WVHJOQXBSd1NVS3V0RXE5NXo0Qnc3eVhicTlkV0hsaDgrcjZwMWUzQnMvMSs2bkpEWUM1cGRBV1YyQUpjdWlKSzA3d290bG1IK0FhRDJjRGdnc2lVZlZlZ0xOSmlmbk5ZM1NhZ0N2bkI3aXkwY05hTDhXd2x5RlI0c2xXMXc3M1J3VkdoY1hLSUFkbkdvVVB1SG5yQ0xONWpVbGxjVlE0aVYwK2RXS2Y5ZWJ3R1c4V1RqME1vaFpGQ2o4V3ZZcDRTNGp6ZlZ2UXZGU1N4Q2NkUkV1Nlk0QThNUFpFUHo5bC91bGFQUFBQQ2tEMGo4TE8vSEdodjMzZTcrWDc5WnZGcHAwdTlEYU9xZ3ZDd0JpOXNuVmw3ZG56VDIzKzBPcTUva2U3L1hSRGcrQnRJQW9CMm5sWkw3RE0xZDRGY0RjVlYxY1hCUFZtUm5BQjFzb2NUaTRXdjNXd3ptTjhPTVhSR3lPNDJpSFhDcHVESE51clhWeGM2NkpqQ1BkSEpmWkdSYlJPTnFpWllVUEEvZU1TbzlJdU9NaDBhckNsaHhRd24vR2srMFpGZnhZcXV2enI2VUJLT2hrVld0QytETUMvTEloK3FtQytqUWNWYVk5OGtUOHU5TGZKcFlUdFJzd0J2RmdUeFJ1WXVWMlJ0NjM3b3REemJySnkvWDBYUG43eG1lMGY3Vy8wdnBOOGdMZUJ2UTBVZkFDc1I4b01CWEc1RlE5eUFuVVQyVEE0TDZCa1lBUWY0THkwOE93OG5QVUl6Z011b0c0c2p1Nk1VTzdOaFRUTURESGdWa2lJVVBzQUgzOUFmUW9Lb1lmMHVQeVFvano5ZEh0WVMzLzZhNWYvSFg3SWpQU1FyeXMwOEcvbndEK2FBUy9Id2w0dTh0TmlGWDRrNzdISFpmYTJ1ZmhocnpUTEVCbDNEMlJuYjE1Y1dYM2kyYTIvdm4xcDVUdlpoK0I5UUJ3QnBIaHJKNFhiZWo1bUNhaVhSc3FaRUlJUTllYU81V1RYVWFnaVZrd01ENUdvZHRkenFFR3lnQWR6RUxRUHFKMkhZVVlXMTFwdDFycGF1cm5DUTJhV2IzWmFuNVVVZTlhYnRVeUJQRXM2dG5Bc09UbWFPU0xSaFFKK2VRNzgyQXdQeEJrL3NtdTB4NFgrTnI1YU0wYU8zRHhlZWdGQWQ1QnpwS1BMSzFMVGxTSU5Id1p3QWNFRlJreEFVWnJBY1kzVUJnMFNBeXBSTUtrbzFuU2JaRUpZcU0wa25VWEZORktoNExhcG9XbWFZR1dyQitxSUg1dVA0RmE2V0Z0SzU5QlNXY09wTnBsT0ZhZDZDUHA0K3RVVytWbjZ6MjgyNitEMGt4RUxFSTRTb0ZMQXI4MkFuNW9CTDhYaVBsM2tIbzhJOCsxeG9iOFRqdnA0dWo1d25BRVk3YytQanZabXIxZ1hPREk1RnpiU1RFQXdJa0x4TG9pcmlpSW9PZ0hFYUtuSTlZSUFITU1PTk1FWXRiQlBObHFqMDBtUnIyZEFRb3RUY3BtK2VycXRQcjJIT2wzMCtBWnQvY05hOUxOYW45TkF4c1ArRFJYbm5reUF0bCtlRW42OEFHNHNuZVRsR1VXT1I3M0k0OFB0OGZWMnY2cWlCdDY2Wmt2cnlwbnVhbWRsc0RYNE9MUktPVENId09TY3BLa0VpTmtDbUdGaW1JTDN2TVRvNS9nUWljY3duMlNVaFVpSzhUSGVXRVhYR1ZJU2xleHJzWDBKWnhRWFBRUjhleGdvOUxENW5MN0J5ZjJ3dWY3MDd5MTFEcHlKMHZXQWdaK2JBUCswa0hhOXhsdXRvQjRaYXV2alFuL25YYWZSZHdNZzZhOTBrcFgxM3NlemZyWnFuUWNMYUk3UWNzaWpGWXZPakpoSWNxdjNQckd3YW91KzlaSHdMcUJweE1vS1RGTGtQaUJZTDFDaFp0U05nMjlPZU9YcUlTZjNOenRsSDlaK0t6eDhGVUhmNExRL1hlUktxSWlVQ2NYd3F3M3dNMGZBUDZ1QmU3SElpNGUwNisrbzYzR2hQeUpYa21pSzdmc0RoZTZzVThPTjd1V1ZqZDU3dlF1aTN3b0N4aUh1amxybjFNUzBPY21uVHQySXBDc2l1TVpqTGgwRU5OSGlKQS9XSTFnTDlzTGI4MHFFTFJRZWZxS2VOWE9yTTRyM1lYUDY2WWVGZXNpZm4vVzlJdUdBVStHdEJ3Witxd0IrOGhqNFRBQ09ZM0VYWjV6azRSdE1GWThML2ZIMUozdWxtWUZ6NFMybnVxMDk1NzAwR3d3NzM1RjMwbzdrZFRMNTF0b3BFdmk5WnhnakFZSXFvbFJTNUJ5MUlRcDFaWEU4TGtHa2tLZmlVODhQSUd1ME1MTlV4QXRySmp5a0xUK0wrYk9NeHRNM21jMi9FVjFRbmJxSmwxaHVTS1JONTFRZWEvc2UrSlU1OEJOVDRBOGhBcFVhRDdGb2JtV0cvaDFVNUk4TC9SRzZyajI5aWFPRE9jVXdpd2NzczJ6dDY4RnE5OG5CV3Y1VThES250MGhWQ0JKRjVWazA3Rmxxb3BZOUJtTkVNRzArcTNGd05JTkpEUWFkVkVJTmVMbW80aFlnV2xwUllDakZhQm9QZGc5NmJTM1AzWFNxY1BuVVNYemE2YlAxNUZJUE9jWDFxWlptMlEwMC9oNUhEOGtRZ0svVXdFL1BnSDlSQUcvZ2hOSzZuS2ppSVpvbmJvdThSK0R5Y2V2KytQcXp1STRQaStVSTZRZk1McHJLMmQ0ZzAvMWg1LzFwbXZTOEM5eWFzclF0UEZqUWQ2M0UyYlNsaEhGZ0hCL05zWGN3UTlwSnNEcm9uQUJ6OFlFUVdGUnNJV0RoVkNPbk90QTREMXVHczFobldKNHp6Z0xlbGd2WkxKM01LUmJvT0JJNk1mRlA0ME9nZlptbFU3K2RVT0w0Y004Q3Z6UUhmbklLL0U0RDdPTkVuSExhNTgyM2Z6ZUo1bjhnK1lMSGhmNzQrbE8vT2wwRGt5anlMaXlDWVpicWlNcHBQUnVzOXk1MCs5bXpDRXdjRUZWa1liRnlDekdBTUVzMDBrUU1LWGJ1ajdDek8wYTNuMk5qdFFmeXdwSUR4TWttaExqVEQ3RkVBOFBWalJCcUFNbURxLzNDR3JGMVNGeElUUEZXZGM1WlRoMHRUVGFjYXU4ZitIdTBaQ1J5OHUveTBwNTk2b0RmcllCL1BBTitvUVJ1OG9sWnhQSXBibkhpYmNFdEt0LytYUE4zNFAzenVOQWZrU3ZQTlpnQmE4TloyeWZqckc5czQ4YmRRWDQ5N1NUbmd3OGNHR1JkQURIRitUb3dCNkhVT3V2bzVvMDk3QjlPMFYvcFlYdHpJSngzSDhTUExhYlBuaEI0QktsSDNPbUxhU1hnMmFHdUhkaWVYWnpMeGE0ZUF0Z3RmMTFiNUg0WnJHdXQ3K2xrLzkvTzBQRllyZ0hjYUlCL1BnUCtTUVY4MVFHanBSTzh3aGt4eGlhYUE3VDVFTzBmNG5HaFA3NytySzRrMVNqbURrcFJ1eG5EcWZGVlZiTm0xRjFKTzkxZTlyd3lPZ2VETllGU3BaaEUzUjdxZVRXN2UydXZ1WDNuSUIxUEsxcFpXOEg1YzBQb0NMUzFhakRnWkw3SFVuUnlDQnpORzJLOHN2Y2lkYTBsUGxvdkZiTmFPdG5QNHBxZkJiaTFsRllkVCsya1BjRlBkblRNaUJwem9HSGdYZ1A4NndMNFJ3WHdiNnpzeWRzNXZNVFpxSHFJTno5cnZFUDNhWThML2RHOGJCTVdBUTQ0ZTcyc21NR1R3MkozWmIyNzFoM2t6N1RiTVVYTXRuSE4zcTNEVis3ZlBQeGFaZDJHU3BQKyt0WXFOamNIbEtXSnhFYVJoRU1zQ2p1R013YnJRWnBPVE82SkpMQXdsaXN6b3lrOVZEZ0IzR2pwQmt0UG5mVExsbEd0N25iNWhFOGdjdE0yb0VHZnBMS3dFbDkyNjRGZEIvekNCUGl4RXZpVkdyZ1ZIZ1RicXFWWi9DekRDRzQ3RFBjdGNQODhMdlJINktMb3hVNTBwckNMQWFqZ3c3eWNOenZEOWM0VFdTZTlIQno3NDczeEc3ZGUzdm5NN3UzeFovTFY3dldWYzhQM0RGYjdxcE1ZSXU4bHA4eUlKUlRIbG4zQmFsTUVpbW1ISG5LNjB5bDFTWEFCcnZUUWp0L2lEc000UWVJcm5LRHFldW5YaGQwT3lRa3VYSHd4aEl4NUUyTDFCVFFlMko4ei91MFUrSWtaOEs4YTRKWS9DVk1vem1qVHozSnFaZUJFN0lMSGhmNzRlanRkTFZKT2F1SHVqRk9ISlFOUVRXbDN2QTI3U3RQV2FHLzBsWnN2N2Z6TThVSDVlOXZYTnQrN2RYWGpCN3U5ckpzUlVTZ2IxRVVOYjhVWFRobkpaVis0TThRNWZERWNSNlljUTVENFZ2a1dRb0MxRHFFS0Q2ek8yaC9QeDJJUGVCRHViaXR4dWEvMkJHN045aHNHbFF3dUEyWWxjRmdGL09hVThaTlQ0T2N0OEhJNG9hNHVlNjB2KzYyLzVSVC9sajBrSHBmUG8zZWxLWUVaRkFNRGwzZ2lpMWRHUkJrUnJUR3pZV1pzWGw1OTlza1hMdi9YU3RIN21ubXRmTldRRHVMejdueUFNUnA1TDBmZXo1R21rb3ZrcllkekhqNGk4YUpmano3ejBaMm1hUnhzMDZBNExqSGJMYURDMmU0YTdRaytqNVY0Rm5IbUZMbW1BWERzWlZYMnV3NzRVcERpM28vRjJ5YnJOS2VmRlhqUUpPSmJ1c0RieXp3dW0wZTBGZFBFUkVSTkUxb2N5ZUdVUER1RVlJbW9Cd0NEdGM2VFJ1SEplbHBxVnpYdENvMUpUQ0xKMVE2emVvWjZYcUhiejVGM1U0bHhJb0NEZzQ4eFRjUUJpalFDaWV0aVlqUTBwWEFkQjVVb2hEbzhnTENyVXdVOElObDNOYnhJUWlaekFzUTVCbzRabUhyZ2F4YjRiUXU4NklBN0xDZDJLeXMvWGVBT0Q2YnpmQ054M0xmbS9mTDRMWGowTHU4bGg4eDVCaEVSbjJoTFRuc3h0UC9mdThZRjVXd1NHczhJSVFNamQ5NVJzSjdZZWZiT3dUdEh6YnpFZkR4SE9TdmhhaHVGYm9RUWhBdmZzdWxhVlN0SXZOUURNMnhoNFd2L3dLNDh3VnRjTWJrVHlYVnhwSzlKM0Zadk9lQnpOZkF2SytEbkN1QVhMZkRGQUJ6RXdxN3g0RDc4WVMwNlB5N3V4NjM3TytyS3V3b2hnSnFxRFlNOU0wNjZKWmtaQVAxdVZ6Mnp1dGI5OWpUWDMwa0t6eW5tYlhESXZQY0xHK2dGUVlhQk5FL1paQ2xJS1pqRVFDZUpoRUZIZVNzekU4Qm9hb3ZaL1RuY3FPYmtwTnJvdEhLTkFTUUtsZ2ozcHg1N2NkWit4UU92VytBMmkrQ2tYaXJZNW96VDI1L3hNSHZjcGo4dTlIZHdvWHVncWNQcFVYZDVORFlBRWlMS1dITGhFNGlRN2NwZ0pYayt5K2piUUh5Smc5OEF3bFVpckJJb2FiK0hhbU9zWW5TemhCREtHbzRKQ0lIWk8wSlRCdmpDd3pTQjJubndWQ0psd3hKU2VEOEFMelBoQ3g2NFV6SHVCa0hOTFI0TXhWeE90VDA5ZjRmSHhmMjQwTDgxUDhpNDh5Sml4QXpHTS8zZzQrbWU0WVJpUGlDZ20yYzRsMlo0Uml1Y0I2R25GTTRUMGFZaTlFaVJBWWlJa0lQWmdrWHpFZ0liVy9NVld3THNGcTI1VmNDTWdTTFNUNDhDY0NNQXh3RjR3MHVMZmdkUzNBNFBXcnFkQmFxZGpxN21KZVV0UDY3d3g0WCtMVnZvTVFXV09Kd1ovdGlHUHFhblJ1Z1dHRTlJSVUwVFd0RUtmVkxvRXBDQVNHdE5PVE03WWhBVHNiZWhFeXovZVRoc0VUQm1LZkFkQnU0eE1HSmd3b0tjNy9FSlMyMTVyLzN2VXR4dkNVeFFrZXp5U09RVlB5NzB4OWVmMUpXa0NzNEdPc1dpZTBEYWlnZnozMDVMdXMvVWxEeUlxUUVRWHN1V0JsYmlUcnNPUU1rUFNrQTkzbXJXZW5yVy9rYkZqZE1BV3p1VHVNY2Y5ZU5DLzFhK1RLTGdiRGo5K1o0Vjhhek9lQUNjZnAyVklLT1gvczJIMmJpM0JYdjZsUFo0cTBQemFWRHQ4ZXo5dU5BZlgzOE1uemZoRzJmQm5YNG84RU1LWHVGc294aGVLdkxUcDNRNDlTQjR2UGQrWE9pUHJ6K0Z6LzFocHF0bk9VR2Q5YkE0ZlpMekdhZjZja0kxUCtSckgxK1BDLzN4OVNkOEQvQTNLZWh2OUpBNFhlajRKc1hNRC9tK2o2L0hoZjc0ZWtUdm1jZUYvRGE1L244bi9LYXd5OVB3UEFBQUFFOTBSVmgwWTI5dGJXVnVkQUJHYVd4bElITnZkWEpqWlRvZ2FIUjBjRG92TDJWdUxuZHBhMmx3WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2xSTlRsUk5hV05vWld4aGJtZGxiRzh5TURFeUxuQnVaemdiV1NNQUFBQWxkRVZZZEdSaGRHVTZZM0psWVhSbEFESXdNVFV0TURRdE1UVlVNVEU2TURJNk16TXJNREE2TUREZWJFWUlBQUFBSlhSRldIUmtZWFJsT20xdlpHbG1lUUF5TURFMUxUQTBMVEUxVkRFeE9qQXlPak16S3pBd09qQXdyekgrdEFBQUFFWjBSVmgwYzI5bWRIZGhjbVVBU1cxaFoyVk5ZV2RwWTJzZ05pNDJMamt0TnlBeU1ERTBMVEF6TFRBMklGRXhOaUJvZEhSd09pOHZkM2QzTG1sdFlXZGxiV0ZuYVdOckxtOXlaNEhUczhNQUFBQVlkRVZZZEZSb2RXMWlPanBFYjJOMWJXVnVkRG82VUdGblpYTUFNYWYvdXk4QUFBQVlkRVZZZEZSb2RXMWlPanBKYldGblpUbzZhR1ZwWjJoMEFETTNNK1VBdS9NQUFBQVhkRVZZZEZSb2RXMWlPanBKYldGblpUbzZWMmxrZEdnQU1qWTJVUjlIaHdBQUFCbDBSVmgwVkdoMWJXSTZPazFwYldWMGVYQmxBR2x0WVdkbEwzQnVaeit5Vms0QUFBQVhkRVZZZEZSb2RXMWlPanBOVkdsdFpRQXhOREk1TURrMU56VXpJTHMwY2dBQUFCSjBSVmgwVkdoMWJXSTZPbE5wZW1VQU1UVTVTMEpDUEdhT0JnQUFBRE4wUlZoMFZHaDFiV0k2T2xWU1NRQm1hV3hsT2k4dkwzUnRjQzlzYjJOaGJHTnZjSGxmWlRWbE1tUTJPV0l5TVdaakxURXVjRzVudFR6a0J3QUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9taWNoYWVsYW5nZWxvLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDMwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTWdBQUFEOENBWUFBQUF5cytzbEFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBQklBQUFBU0FCR3lXcytBQUNBQUVsRVFWUjQydXo5ZDVSbDJYWGVDZjdPT2RjOEY5NWxSUHJNeXF6Szh0NERCVnNBQ0U4UUFraVJva2hKTkZLTGxFU05YR3UxdXFkSDZxWFY2dWxlcTJlNjFUTVN1M3RFMlNZcGdSSkJJOElRQlZzR2hTcVV6Y3pLckhUaHpmUFhuWFAyL0hIdmk0d3FvSTBraXN3cTVLbjFWa2FhaUlxNDczNTM3LzN0YjM4YnJwOC82cVBlOUxGNjA1OWRQOWZJbTNQOS9PRmY5KzhIQ0tsZWIvNzQrcmtPa0IrWTY2MnJqODNvWTZYVTZPK2NpRGpBVnkrdWcrU1A3dWpybCtBUDdodzhlUEQvQ0JpNkFrUll2V3JWcXc3VVJTUVNFU1VpbzM5M1BkVzZCbzY1ZmduK0FDNWlhRkFvVHB3NHdjYy85bkZtcG1mVWhRc1hsUGRlZng5Z1JFQmN2VUlnT0hueVpQelRmK3BQTDN6MjAzLzgvVWNQSDY4OTljeTNWcTZuV05mR0NhNWZnbi8vTXo0K3p1VGtKTXVyeXdqQzZkT24xVXN2dllTMVZsdHI5NElqVUVvWklCU1JBTkQxZWkzOHdPTWZtSDczdTk5L2U3M1d1Sy9JM0R0MnR0dnpXV0wvQytEcDZuUGQ5YXQ4SFNCdjZacENSQkF2QUtyWDYrMEZoYW11YndnRVZlcWtqeDQ5MnZ6Z0J6NTQ2S0dIM3ZtaDFaV04rd2JkN05UWmw4L3J5NWN2UDd1eHR2ckxhMXVydjExOURYdjk4bDR2MHQvUzEwNXJyWlJTU2tSMGxVNFpJRlJLalVBUkFIcHFlckwyeDMvc0p3NGVPWHpzdHFuSm1jZDYzZUc5Rnk5Y25MdDg4Vkt2czdQOXJlWFZ5Nyt5MWQ1NllYbnQ4aXFRVitBb3FnaHlQYzI2RHBDMzNQVWFGZDI2aWhMQm0rb01FNFpoZVBqUW9mRS84NmQvOXM2NXVjVjNEZ2JKdmUzdHpyR3paMTh6cXl2TDV3ZTl6aGZiM1oydlhGbTk5TkpPWjJlekFrT3hCeUNXNnl6V2RZQzhoYTZUNG8xc1ZGRFZGcUdJaEtNL3UrbW1HNXNQUGZqSS92dnZlK0RSWm4zOHdZMk43ZHV2WEZtZVAzdm1UTnBwYjcvYzYzZC9QYzBHVDU5NS9jeVpJcytUQ2dTamlESDZkVVR4WG84ZTF3SHlsZ0pGQlF3VkFCRklBSmdvanVzUFBmakE5SWMvOU5IN3hpZW1IMWFZZTY1Y1hqbHcvdHo1YUhuNThuWTZIRHc3VFBxL3RiRzEvdFNWMVVzWFJYYlRKN3NuWW94Nkg0NDNOZ3F2bitzQXVhWlRLTE1ualJyUnRBRmdicjNsMXNtSEhucm84RU1QUHZ5WTkrYmVOTWx1UFhmdXd2aHJaOC9LenZiRzluRFkvNTBzUzcrOHViUHgzTXJhOHNhZUtMRTNqWEo3d01IMXFIRWRJRy9WRkNvRXdrYWpYdnZoVC83dzRidnZ1dmZleWNuWlJ4VG05Z3NYTGs5ZnVuZ3hYTDV5T2UxMGRpNWtXZnJWWHIvenBTdXJsNThkRFB1RFBXQVkxUmhPS2VVb3UrWnlQV0pjQjhoLzBQbk1IL3NzMjl2Ym5IM3RET2ZQbi8vZmUrTHZQWHR2TlBuQTR4L2dpYTgrUVpJa2xQZmo5NEJDOGIzVTdHNjBDSUlnT25ueTVPd25QL0hEcDI0OGVlcGhXL2g3bkpXYlhuN2xUSGpwNGdVMjE5ZlN3YUQzblNRZGZHRjdaK3RyVzUydDE5TTBHVmFSSWQ4Yk1aUlNUaW5sdGRLQ1FyejNvcFRDdWVzdGoydnhYTk45a0dhalNWRVVIRHh3aUNOSGpuRG8wRUgrNGZsLytQMXVia1dwWjZKNkludEFsRkl5TmpiRzNOd2NRUkM4R1JodjdsbUVTcW1vaWhZQkVCMCtmTGp4L3ZlOS80WmJiN250a2FXbGcrL2MydW9zWGJtMHNmRDY2NityMVpVVnQ3Mjl1VFVjOWw1STArUUxXKzNOTDYrdXI2d0IyWnVBTVVxcnZGTEtHMjFrWm5wV25QZml2YVBkMmVHcURPdjZ1UTZRNzNOKzlzLzhHQysrZEpxenIxM2swWGU4aTZlZWZKSXJWeTdUcURmbzJBNWYrTkx2cWMyTkRiYTJ0OVQzdWNGSEx5VWl0b29ldWt4ZjhGRVk4Y3kzbnlGSkVpVWkzNCtlamFwWEtDSW1qdVBtWSs5OGJOKzdIbnZYclhPeit4NXRqVTNjdjdteE0vZmt0NTZMbGk5ZlptdGozWFc2TzVleUl2dm05czdtNzdhNzJ5OTF1cDNOTjlVWGV5T0cxMXI3ZXEwdWVaNmp0WktUTjV6aWlXOThpZkd4Q2J6M2VPK3YzNG5YVTZ6dlBaLzl6S2Y1L09kL20yNnZoNGl3dm5hZXYvU1gvM09lZXZLYm5EOS9Yam5ucUc1cXBaVFNJcUpISGVrOVQzNEQwR2cwMUgvNk4vN1dMZC80K2pjdS9wdlAvNnZsS29wNHBaUW9wZFRlUmg0UUtGUWtTRFJLcDI2NStlYXA5NzczL2JmZmRzdnQ5elhxclhzR3cvVEkxdGJPNU1XTGwyVnRaVVYxT3p2NWNOQTczeHYwdnpaSWVyKzl1YlZ4cnR2djdIeWZhRkdNNmd0QVJFVEd4eVprYm5hQnFhbHBubnYrR1E0Zk9zcms1RFJQZi91YjErL0FIL1FJY3ZzZGR4REhNVkZvZVBIRmwraDB1cnQxd04vOXIvNUx2dmlsTHpOTWhodzh1S1IyZHJxSWlNcXlUSTNBVUFIRWlJaFdTaG1sbEtsQXNodE43cjNuN3ZDbmYvcG43MXhjUFBoWGg0UDA3L3liei8rcjFRb01ybExJanZSUWtVZ0pDa0hDZ3djUFR0eDc3MzJMOTk5Ny85MkhEaDU1T0FwcjkxMitzdFk2ZmZybFlIVmxoYzJOVlFiOVhqZEprOVBEZFBDbFRtZm5pYzJkelF0cG1nejJGTnpGbnBkVFN2azRya2tjeFZLcjFXWC93anhuenA5SHhKTWtRd3BiY1BiYzZldDMzZzhxUUQ3NzZjZElYSWNuZnY4MWRyYjdqSStQVXhRRmUrWWRkblB1VysrNFR5VkpvcndYcmx4WjFYdFpwRDJ5NzkxWEJTeUphM0Z3OE1EQnhxYys5ZW5qYzdPTHQ0cklUUnRyMjQrOCt0S1o1RHZQZi9zS3BZeDhWS3liVVJwVlNUOXE3My9mNDRjZmVlU1JXNDhjUHZhUUVuMlQ5L3JJaFF0cjhlWExsOW5jMkpET3pwYjBCOTN0SkJtK01FeUh2N201dmY3MDF2Ym1pb2lNUUpIdHJTK1VVaDd3Umh0eDNzbkQ5NzlUdlBmODFJLzlMRC81WjM4RWdGNi9lLzF1KzBFSFNEMk91Zi8razd4MitRejFSc1QybHFodmZmTWJtQ0JVNHIzeTNtbGo5TzZUZnpnY0t1ZmNYaFpKVnhGaUJBb05vRFRCbmJmZkdkMXh4MTBMVTFNenh3NGZQbnF6Q0hjTkI4bko4K2RlYjJ4dGJ1eHNySzk5Zm0xOTdTdXZuSG1wRFRTcmduMzBkZUtqeDQ2TlBmcndveWZ2dnV2dWV3NGRPdnJ1TkNtT3JhMXRORmRYMTFsYlhXTm5lNE51cDEwa3lmQktrZzZleVlyOGllM08xdk1iRzJ2cmU2SkZXb0ZqYjhTUWVyM2hqVGFFUVNEYjdXM0sxTkR2Z3VQNitaNTBYcjJaYVh6YjFpQi8vYS8vZFliREFhKysrZ3BQL1A0VEhEZzRxNVN4WEx5d3JaSWszOXRYMEh0U25hdERRU0phM2xoVEtFREZjUlFmUDM3RDJEc2VmZGZTemFkdWVialQ3WitNd3ZCRXQ5dGYybGhmczJ1cks2LzN1dDB6RzF2clg5M1lXRHU5dHJsMmNVL0VVSUJxTkpxTmozemtJNGZ2dWZ1K2UrZG01eDVvTnNadVNwSnM5dUtsNVdCdGRZMk5qWFhwdG5mbzl6cUZMWXJYTTV0OVlYMXo5WW4xemJVelJWSHNUWjlHVVNQYlU0eGJwYlJ2TnByTVRNM0lvNDg4em0vODVqK2pXVyt5dXJIeUE0K0dHOGRiYkdVNW0xbStkL0JyTDhraWIzcGRrMEQ1RHdKSUZFVTgrZVMzK0kzZitCeFBQLzJNK3UzZittMmNkMG9RTGY0cUlMamFmUjY5OXZZZE5LREh4cWVpZ3djT3RBNGVQREIvN09nTng1ZjJIem9WbU9CVXY5ZGZ6TFA4NE1yS2NyRzJ1cnk2dGJYNWIvdjl6bk5iTzVzdjdYUTcyOTY1Z3F2OUMxRktCYmZlZXR2a2d3OCtkT0tCK3g5OFlOKyt4WWQ2bmNHaHpZMmQrTUxseTdLeHRrNTdaMHYxT20wcGlxeWZadW1yV1o1OXJUZm9mdjNpbGRmUE8rdnlxcmd2OXFSVWUwRXlrb080TUFoOXN6a21jUlNoVGNESzZ1WHJjYUk2dDB5TTBTNEtyZ3pUNzhjNDdsVU5lTjQ0WHZ6V0JzaXYvL3F2ODVXdmZJVi84QS8rQVFEdmU5LzcxRFBQUE1QbTVxYktza3g3NzNlYmJYdUs0Z2dJNStabVd4LzV5RWYySFQyNE9EY3pQVGE5c0hSZyt0VVhYOGkvL3BXdkpVZFAzSFRUMk1UQnU2eVltU0pQWjlzNzIzR252VjFzYlcyc2R6cmJMMi92YkgrdFAraTkzaC8wTGhUV0ptLzYvdFdCQXdjbjMvT2U5eHkrL2JZNzdqaDU0c1lIZ3lBK3NyNitOYjY4dkJxc3JLeXl0YmtoN2UxTjFldDJ2UGQyS3kveXJ3K1N3ZGMzTnRlZjNkcloydkxlRlJVd2ZBVU1lL0RnQWZPKzkzMmc1cjM0eGFVbEZ1WVd4NzcweFMrYy80MS84K3NkcFpRM0puQmpyWEhaYVc5ZFI4VGVmT2wvK05zYytzdi9KVDNyVkNjdmxMeng0Y2hmT1g3azBIZTNPOWx2N2V4YzVxcFkwMStMRWVUZnFRYjUrMy8vNzFPdjEzZkJOUmdNK0kzZitBMDFTcCtxSWppa0dpa1ZrYkRWYW82ZE9uWFQ3Qy8rNGkvY2QrclV5WWZtcDV2SHBzYmllUTlqcDE4K0g2OWVLZHc5NzU3eXJhbDFrL1M3Wm0xRmNlSHNXcmEyM1BsT3U5ZCt1dFBwbmVzbjNTdk8rYUhOWFNhZTJ1Z3BGTmNhd1gzM1A3RHY0WWNldnVHZWUrNTk0UERCUS9lc1hGbWJ2bmh4TmJ4NDhSSmJXOXZTM3Q2azA5a2h6MUpYNU5scVh1VGY3Zzk3WDdsNDVjS3pTWkowZUtPMDNBUHVZeC85Mk94NzMvUDR3OTFPLzBIcjNGeTMyNU5CWjZndkR5OFBBeFA5SGVCYmdCTHg2di9xbXhvR2htUHpVOVFDdzNNWDE5N2V4Y2FmL1U5NTkveU0rdHJtdHRwRHJVZEE4RXMzSGovY3lvcS9XdlArbndMTGI2c2kvZURCZy96U0wvMFM3WFpiWlZtbWxGSzdFVU9wM1laYkRZanV2Ly9lK1k5KzVHTzNmL0NIUHZTdXBjVjlwMW8xZlNoU3lVUmNEK2tQQ243cjg3L0dDNWVlWU94d0hpeWMwQ2dERStTeWVMdFN0N3d6MXNOa2NzWXo4YkJZZWRBS2FLV2N5MTI3dloydFhEemZ1UlRZS2ZmNEk1KzZJM0tOazFNekMwdWJXOXVOTDcvNG9sNWUzYURURzlEdDlXanZiQ3ViNTJsV1pCZUg2ZkRiN2M3T1V4dGJHK2V5TEcxWDZSS2dCTVFEL3RGSDM5SDQxQTkvK2wyNDRJOWZ1Yml5Y1BIQytkV2Q5dlkzMFBxbExFbTZ2Vjd2ZkcvWVAxTkZMZzlLOGp6YnZUNjFLRkRPeVc2R1haVHlFUUV3Q2lZYU5lcWhZYklSQTlBZVptOUxnUHpjRFVmNDljc3IyTEsrREJSRUF2R0hsL1l0akJYeU55NTArcmVlSGd6L213bzRCZGV3NU9uL0VrQWV1T2NPdnZ2eWFmN0pQL2tuNnRLbFMvVDcvVkY5c2V2UUlWSzVkR2lhZi80WGYvN21QL05UUC9PakoyODQvbzRnME0ya3M2VzZ5Njh3dFcrZmJLNzMxRy8rN3Iva2N2WXRqajBZbzNRZGhhZGljSlVYSWF6cnNFNTB4RGtoUkZFb1JXaktPMjAvNG83Y09PMVhuMHg0NFl1ZkQ5ekFLdXM5Um1uU1BBZWxxZXNBN2FCV1UvUlV2ckxXM2ZocVozdm4xZlh0N3FZdHU5YWpRajRBNGZiYmI1Lzh4TWMvZGVmMDFQeEhPanZkTzE1NTZaWDE1ZVZMLy8xekx6N3pyOXZkbmZhZTRueWt1aFVSRWVjc3crRmdaTm1qMHR4K2o4ZVZVa29Rb1hBaVoxYTNwQkVHS0tXa0Zob0tyMmpFTVJ1ZHp0c0dISC90aHFOOHRkMm1XeFRLQzdwNmFOWm40cWh4VXhSK2RyM1QrY2hXa241eHc3djJIb0M4dFNQSVQvekVSL2pMZiszdjhVLy82VCtsYXQ0RmU2SkZUUkhXVHh6ZlB6MngyRi84NUdjZWV2elRILzdwOXg1ZE9uWUROc0Zub3Jycmw1Qml5UGFscytyM3Z2MDAzOW42R2pmZTNDUkdVQXJDVUtGVW1hblVBb1hXRUdpRlZob3Ztc0lKM1ZRWU9zL202VlNmLzFKSEQ5Y3lGU3BERUFWRVlVQ2dvUm1IZU84cFhJNjJGa2tTeHBDbDVuVDBxY1htNUk1ZEd0OUtjcnUrM2UyZjMrd096K2RpbGovOUV6OTcrTlNOdDd5NzIrbmQvZUx6TC9uenI1LzdqY3VYei8vejF5NmNlYTBvaXBUdm5lemJPOGlrQk5ISUcxZzR2UWNrWHFTTVR0NTcxeDZrdmdPaXRmTHRnWmVKVm91TlRvZjVlcDMxSkhsYkFLU3BOYWU3ZlpVN3IvWVFOT0ZuNXVmdUsvckpqM2JTTE13Q2ZXNHI5U2x2QVZlZC8wc0ErZHBYdjBPcjBWRGJlV2NFamxncDZpSTA3ci9yemdNUFBuTDAzWWR1TXUrVDVzYkNYVGMvZU9Ud3ZzT1J6M3NvcFVnR0NjbWd4OEsrQTN6bmhXZDVvZmNzdGRrSTd6V0RWQWdDanpnSUtwQWtvZ2hVUUJRSEtQeHU1N0FWS1RhZUhYRGhkOXJLRDJCbVlneXRGVmxtRVMva3JpQXJMUDBrWTNPclRWR2tLRHhSRU1RZ3NlQW5sTkpIWXBUc0c0K0srWlpKVFZqYmpnWWJrNjg4OTUzSjg1ZXZQSFg2N0t2LzY1V1ZpODhteVhDYk53NDB2U0Y2VkwrKzJlc3E1dXJvN2Q0bzRnQXJVQ0JTQ0RqdnhBSSt6WE1acjlWRTZqRzhUUUN5WGhSTVJ4RWJlVEhTdTRXbldxM0pJQzArdnRvZkhNcTlIK3dnNTl4dW1ucHR6Ny84bndMa1l4LzdKRi8rNmxkVnU5dFZWYjBSQVEwUldoOTUvSjBuSDNyMDZKOXQ3Tys5TjU1TVkwOUw3WnU2RFlQQk9rR1VzTEY4bVRpTzZQVjZmUDNGSjRoYmpqQUlLS3lubnpqaVVGR0xOTm9JeG9EU2lqaUF2TEFFV3JBaUtLMjQ4dFNBVi85dG15aUlhRTJFaUlDMWpzQm9jdXZZM09teXNibU45d1dCaHNnbzRpakdPVSthNTVqQTBHaTBDSU9JM0xvUUlRcE1NSDc2TzkrZzhFWld0bnJteXNxR1NjUUgxYzJlN2dHRGV4TkFSdUFZRlo5MUJiWHBzY2JrWkNPZXJrZG1ISlJhN3c1WDF6dURuVDBwMnQ1K2lzM3kzSXN4UG5hUjdCdXZzOXA5NjROa1BjdFp6M09sbE5LSUJBTEJyYzNHL242YTNkMjNoUktsT2gwdkYvZEVaUGsraktxOEpRRHk1LzdVcC9uQzExNWlhN3VEYzI3MHBLd0R6VTkrOUVOSC84eWYvdGhmdkRoNDR0MWQ2WnNzRGFSWnF6RlJuOFhsR2VJZGc4R0F6dFlheDQ4ZjVqc3ZQb1d0YnpEV0NMSGFrUmVBYU5KY1NIS0hNZ3BSaWlBUUF1MHdDSEdvTUZyUlBqUGc5UysyTWNvUVJRRktxYktSWWd6T08xWTJ0dWwydWtUYW9RTmQzdFhPWTRzQ3RHRmlZb29vcnBQbWpwWE9VQTExUVZRekJBcDZ5bUphUmswZnJOK3RGdWZNOG9YZTM5dmFITDVTcFkranB1Q2J4MkJIVDhjYTBEQmF0OTU5eStGM0g1NGIvNHg0bWROYWpWdVBmdkwwNVROVGpmajNKbHUxN2ZYMjhQVDVqZllGWUZoRm1WU2d5SjJUM25CSWFKUk0xbXEwMC9RdERaQzVNS0R3WHUzMnBwUXlNMEZ3V3lySmZ1K0ZJRENEUXJuQi8wN2tVSHNlUVBJV2lDREN6dmFxc3JiUUlydWFwdm9EOTkrOTcyLzhsWi8vc3djT0w3Nzd3dGVmMUZucUNRSlIzbXBja3BMcEx0NWJycngrSG8xalkzV1ZwMTk5Z3VZK0lRd0M0c1lNM2FKRGJndXkzT1BFWTd3aENoU0ZGWHlnTVVwaEMraWY3clA4bFRiYUdjSW93SG5RUnBkQWNaN3Q5UzVTcERRaWhYWFZWYTJpVGhEWFdKaWZ4M25GbGUwZC9MVGp0dmZQc25Cc2pDaldHQ1hrVHNoVVFLRU4zYTY5YmYxaS8rZlBQTFgyajc3NzVjdlBlYmRiMEFlanAvNGVnTVJBS3pSNjdPR1RCeDQ3UGovNTEycWhPVGpJY3RJaXAzQXcxWXFYRHN4TVBCaUd4aDJZSGo5N2FHN2kxNTYvdVA3NW5YNnlPWHBpQ2toV1dHZWRaandPM3ZJVGhmOWlaWjNFK1pFS08yZ0dKZ3hGRGcwOTlVQnJueXUxa2UweWlMdGdNSHRvZHZXV2lTQmhjNFphclE0b0RSSUN0VEFJR24veDUzNzhmVGNlUC95K0lHeWF4ZkZqN09SWDhBV3NkWHRzYksxVHkyTzhVcHc3L1JLSDlzL3h6UE12MG5YTDdHK09ZN1FtQ0gzVlR0VUVTdEZRZ3RFQlZnU3ZJTkNhTVBCMHp3MDU4M3RycUR3a0NBMjVMNmpYRkZtUkU4ZkM5bmFiZm1jYnZNUDVrZ2tyTGR3ME05T3p0TWJHNlBaVDFvY2RibmkweFYzdm1TZHF4UXh6SVMzQU8yRThMMURpNlRraE1hTEg5NDg5ZU90VTdkRHgrL1k5ZWZtRnpkOTYva3VYbmtrSFJaZXJBa1ZYdmFFTm9IbnY4Y1VIYjFxYS9rV3QxTUcwc0RnUlNsMlc1cWFEODFqcll3K01OV3EzVDdicVJ4dHhQUHU3ejUzNVplZDNSMjI5Z0RnUjE4M3l0MzZLbGVjWXBWUWxIOUtIbzdneHI0UDlxOVlwajlvK2E0dC9zZXpjZGdVRTlhN3BLWFAvek5RdEhmRVgvcWV6cjI5ZWF6L1AveUdMY1BuU0N1c2JtOW81RnlpbGFrRGo1My9teDIvN2ljOSs4aGNiY2JSa1RJakM4T3o1WjFuZDd0UHBGeHdaTzh4c2M0YmNXZFpYcjZDODQ4dlBmb245TnhrYXpRZ2ZLTHkyTkdKREdDaVVnbVpzTUVZakNxSlFFeHJZdmpqZytjOWQ1TXJyTzRnT1FBZUVnYUVvUEZsdVFXbTJ0cllaSkgwR2FZNFR3WW1uWHFzek43OUFyVlpudXpOa3ViL04zUitkNFIwZjNvK0pERm5tMFZvUkJxQ1Vwc0NBS09vMXpYaGRVek1vRStueHNkbjZUUWR1bW5ub3lLblpxWFJnTjdkWCt1a2U1cTRKTkk3T1Q5eDA2OEc1dnpCV2oyL0xiSUVUeit6RU9Ha2hpQWhCR09BRXZBZ0N4SEVVYThXcE9BaUc2OTNoR1Y4eVhIWVBkZnkyS05TTlVrWXErdjlFdlQ1elcxVDc5SmwrYjc4Z05sUHFxUlh2endDRmd2VFRjN01uNXVQd2h0L2MySDV4TFUydk9SK3cvOE1Jc3J5Nk9wckxDSlFpanFNd2Z2KzczL0dPMmZuRmszbS9KM20vcTZhQ0dhYURRMXdZUElmTkhKMStGeE5FcksydmtPVVphMW5DMEd6VEdGK2dVSnBHUFNReUdxMFU5Y0FRWVBIaTBlSXhwa3g1T20zSHM1Kzd3TVdYdGpDaEpzb0tXZzFGYmozT09aUlNSTTR6VEJPU3RLQndwVXVuMFlxbHhXbUNJR0tyUGVCeWY0ZmJQNzdJaVlmbXlDdzBJMDFrTkxtQWMwSXpVZ3dNZEZWQTdpRld3cjRwelZUaFNaeFNuWUs1K3MxVFB6RTJWNzl0K2tEclYxNzQ4cVhuQnAwc0FZTGoreVlQbk53MytXUE91VHU3YVVab0RGcmcwa1libEtJZUIrVFdreFVXcFJTQ3NOTWJvb1h4QXpOalA3blc3cDI3dU5YOXloNkdiQlFBSlRhRzdDMDRvMzY4SG5NdXlVYkZSVFhvcGdNUGpUTEN5L2lVMHZjcStLSkFzaEJGWmlvTTcxdE5zdGVlMzJsbjEyTEQ4UHNCWkhlSHhaNmVSMDJFMnMwM25waS83ZVR4aDdKZVd3ODZiYnhYWkduQlBmdnY1L1RsMTdtVXJMSFMzU0hOVXJxZER0WTZsamZXbVZxSzBMV1FXbVNJUThBSFdPZkxta0UwQ2lIUW10UjZocm5pd3VrZExyeXlnZEthTUFncHJDT3pGaThhNXp6R2FMTENVbGlIZGE1c01vcWdURUJtUGIya3g2WE5IVTU4YUpIOXQ4M1JHMnJ5SExJWUdwR2dsS2NXYUxUU0JOb1RHa2l0b2pzVWhzNFFCWnBtNktsSG5sNG1nZGxYdi9mK1R4dy9jdmp1dVNkZi9OTGwzMnV1K1BwdEIyWS9BOXhrdEFrVWl0NGdaWG1uUXhTSHpFK000eng0UEVvcG5QY1UxaUlDc1FtNHN0Rlo3UFNTbjZ3RndldXB0YS90QVluVDVUamlXektVdkpaa1JGcXBvdklxQm5TdUlXakVXUndFRElxQ1VLdkpNZEZqWGUrNzkwNk1Iem93MXByNS9VdkxuNnNJSUhzdEErUjdIRDcyOUR5YXdQaE9wOU84c0h4Qk5Xc1JSWlpURElmb0s1dk12dlFDbjN5aHoydmRJYkc3d002UkRaSThwN0E1NFhTWCtjVXhUQkRUcUlQeUVZTk1jQzdBaVNZcEJvUmFrNHVuMnhmV0I1N2xsOXZZekZPcmhZRENPa2VTNVJUR0VKaXlnTSt0SlM4c1hnVG5IZDU3eHNZbkNZS1FkaTlCaldsdXUvOEE5VkNqbFNjclBHbWh5R1BEWkxPc2dLSWdBSnZSaXFFUmF3U2g3elY5QzFacnhrTmgyamhxdWNQVTFXeDRiUHhEcytuUiszbCtTSjdhV1JGRmtoVm9wVWtLeTc2WlNaSWlZNnZYSXc0Q0JMRE9vUVMwQW9VbWw0SmVtcW5weWRZdG9URVBuRjdaWEdYUGZJbUlTR3lNMkxkWUJQbVhEOTdOLy96YUJYNXpjM3UzL2dETVNwbzZaOVRhWkQyV3hGbzAzRFN2MVBFdXJOelRhdDNhRWFtdml1c3BNSElOdXRrSGJ3TEhibk5IS1dLUk11Y1dvUjVvMVdxRW05TlB2ZkQvU1ErTjN5eExVVmU1YkIxL2VvZjZGeEpxMnpEbmhFdkxMM0NwTlU5eDhqaERzOEhrOFp4RU4wbXRJc3BqY0pyQ09uSUh1YlZvWlhEVzB4bDZPaDNMVHFlZ3U5cEhTVGw1S09MSjBvSkd2UUVvdE5ia2hTUFE1ZDhwRk40TFNobkNxRVkvU1VuU25IZ3BZcGc1Z3NBdzFtZ1FSNUFWR1VrdTVONmpsV095cnFqSG1paUFLR2lpdEJCbENVbWhLUnlrWGxBbzRzaXhZQnhicjZRcStXNHlPK2hsZUMvVTR5cTZGUmxoWU1qekhPYzhlVkhRRzZTTU4yS2FjVXlyM21DWXBBeXpESzAxdHgvWlIyak14R1ozOE5NN25mN0d4akQ5QWxmbjJsMW1yWXFEUURMNzFqSjQzN0ZXcVQwTlZBWEJWbDY0VGVzdXhtR0FCeUpoZGtIcGh5OHAvOXkrdUhacWJaaXR2TnJwR2E3UlZROTdBYUwzZElScklzUkE4NGJGWU9iUGZLUit4dzJIZzN0T0hBenVPTFR2M0kzMTdJelNRMUNGcHJncElyTXhWMzVUY1dZall6VWRzdkZQUDhmc1p4NWs1Z0hRdFJwejBUaVR6U1hTUEdOMXNNNGc4d2dlNXdUckhQMWhRYmVmMCt2a3ROZUdkRmU2ZVBGbCt1U0ZVb2xlRnI1NVhxQzFodEJnZmZuNUhxaEZFVTRnUzFKeTZ3akRpR0ZteVhOTFVYaW14c2FvbTVERVplUlpoaGZJQ2tzdDBrdzFRM0xuS0p3blVnWk1HV0dzQTd3bTgwTDZTc3I2MHdPRzNZSmhsaE1hUTFwWXROSFVnNGdzdHppQk9Jb1lyOWZKclFVdmFLWFpiSGZwRGhMR1d6V01OaVdURnhnMTFhZ2ZYUmh2UHI0eFRKK3F3SkVLV091OWFLM2ZVbWxXcEJXYnp1RXFEd0VnbkkzQytrZG5aajZjNWZsOVJ1bkNpa1FXSDlTMXZ2RlFIQitxYVhWakw4MmZTNTBMOTFDODF5eEFScnFaK2sxSGdya0hiZzFPL3ZoNzZvOGVXSXp1V0p4VXR6Vmlwc1doWEdwSXM0ZzBEUmwwRGNPK1poaHBMaDNNK002NURtY0hROXdONHp5MGZ4TnB6aUZhTVZZZm94Rk8wQjRzZ3loYzRjbTl3MWxIZDVqVDdtWU1Pam1EWGs1M3RVZmFUVkFDMWxyRUdCU1FKa1BpV3AzQUdMejNaSGxGNjRxVUVVUUhwVmdSUlpaYkFxTXFBSG1DSkNOTjg3SUwzNm9UbXhaZVczS1hzOU4yZUN2b3NBU2FOaHFqRlZvMERYRTREYjBybHMwbmUzUjNNa3F4bzhLS1VCU2xFRlVwVUxxa3JBT3RxVVVCL1NSanF6Y2t0WTVHcUFpTkJsV21pN1V3Ukx3b296VVRqZmllZXFCdlNLenZjRlc4NTkxYnlBcm9GdzdzNTFQZmZKWjhEemlBOEhpak1iTm96SWRmMnRpK2UyQUxzZUpKQll4U016TkJzQ1RXelE3eklxa2V5aU5HejE1ckFDblpCZ2dFNG9mdmpHZi9uMzlwNHM4ZE9SeDhkTXJMakhFcVNvcUFYbHRKbm1pU0pDQVphQVlEelRCUkpFTllhMXVlN3laOE9SbFFPem5KUi83OGJTd2RtY1U1dzJTdFJhQWlOcnVYR2FSRHNxS3NGeWc4dzZTZzF5L283MlFNMmltRFRrYm5Tb2RrbUZPUFE2eTFLQlJHUVphbTFPcU5NcSszRHEwVktFMVJPSlJXb0F6T2xmVklJWTVhS3dRQjZ5RE5oVkFFVy9UcDlCTWFqWEdhalJyTlJvMkc5aVRaa0RRckNDTk5xeDRoVG9Gem9BeCtZR2wvczh2cXBSNjVzeWl0eXJsZVVjUlJpTllLbzhFV3Z0eGY0Q3pyN1pROEwyaEVBVW9KazYwNjRvVElsTkZEdktDTlFzY2g0ODNhZ2JsNi9OakZYdkxpbmk2N2N0NHoxNGpadU1ZbDhiZE5qdk5ha2pBZmhlcFNtaW5aTS85eGE2dDE0L29nT2RqUE1ncEU1U0lvcFFpVWlodGFUMDhZTTNlcTJieDNKZ2pPYkZtNzErSCttaG1lQ25iVEswV0FFSHptL1JQM3pLdnh6Mng4VjAvWU1jdGtNMmVuSDlIdUJTb2J3aURSWkJrTUJtWGRzTGxUOE9KeWwrOWU3S0NPamZQNHo5M0c3TUZwUWhVeVVROHhZaGdtT2NPOElNOHNhWmFUVzBlV1c1TEVNdGhKNlc0TTZHME4yZG5vTVZqdTRxMm5NTFpNcFFCUm9KUmdiVUVZeGhYVmE5QW14SW1ndlVMckVFRlJPRWRoSGJXV3dYdEhtbGQxaWxaNEp4VFdzVFBjUVJ2TjlNUVlSK1lXQ1JGUWpyb3hZSE8ya3h5TklnNDB5ZW1VL3FVVUoyQzlweDZHaEpFaENneTFPQ3pwWGFYd3pwSG5aVXBJWFNpOGtCZVd6akJGS1VXakhxTlFSRUZRcHBWWlFWcFlobmtSeEtGNU1EYnExekludlJGQUFxMnVxWTd5Lzk0NTFLanoxRmFiN1R6Zkd6MXFEYU9iWTByZHZlSHNyUFdlQXNFRFNabTdqMGRLelVTSzJxMjErR2ZlTnpYMXlqL2YyUGhTOWJuNXRaUnE3VTJ4REJERVJYaDBheVdxcHlrTWRnelpnc0o1emZxYXBqOFV1Z05QWitqbzlTeHA2dWdNYzdvcHZQT0RINkoxdDJkOGYxbHVCYUhIQUVtV2s5cU12UEFrYVU2UmU5TGNzcjB6cEx1VDBWNGZzSFdsdy9acWgrNU9IMmxiaWtKUTJoR0dVQlFXMGFWbU1NOHl3akRHZTQrMWtHVUZ6bnFDT01CNndSaGRhamNVUkxXUXdqdXM4K1JXNGJUQ0N4U0ZCd1hlQ3h2YkhZYjloTW5BVUorY0l0UjFob1ZGeEtCRHpiQlRzUDVTbjg0d3gzdFBJNDZZbnFoVGowTVVaVGs2R0taMGh6bFpZZG5wRENpc0s1dWVnTE1PdEtaWmo2bEhOYnFEbExYT0p0MUJSaS9KeUt6RGxiS01SYVAwQXJqempBd3VRQlZ5N1FQazM2NXVvRUQ1cThOUnNVRDgrTnpjTVlyaXdlMGtVVTZWY2dGVmhZaWhzMm9lbWo1M1JvVjY4dEg1bVVkL2RYUHpTVmVPT2dkY0hhS1Nhd1VndTFUdjFwYnJxMzE0b3dHbjJGeU8wSkhRN2pqT3JCUU1FMGNBdUVKSWM4dkt4b0FIUC9nSi9zeGYvSXVjNjd6Q04xLy9OV0pUdnZHSldNUkJXbmlHV1VFL3RmU1NnbDQzWldkdFFIc3JZZjMxTFhaV3l4dTF5Q3crVXpndjFDaWJpVmx1c2FxY0cwbVNBV0ZjcDdCbGRERkJnQmV3SG9MQTRMekhhSTFTR210TEVrQnJRWlFudDFXbzFLWXMvTDBuU3h6S2d0UUMxdGZYMFZyVGFFVFU2eEhhR0hwbmUyeGU3S08xcHRXSXFFZUdMQzNZN1BUWjZ2Ykp0YWN3anFIMXBGYklDMCtXT3RKK1R0NHZVQ0tnTmEwNElEVHJETEtjekZhMDcxN0ZtMkpjVUV0Y2xjOHJrZkttdWhiUFVpMW1PUzFUdjl4N3BVcEE3MnIxeG9PZ2VYTWN2Ky84OXZhTmliVmx2VmJsVGFiOEhLKzBSb01CTVF0aGVQdXBpZkc1RjlxZFBsZG5hdHkxRkVFWTVYMDdIYjhwWG5JajFBU0Y5akJvSzlvZHkwNDdwMllVS01Vd0xiaXlNMlJEajNIbmc0OGkxbkZ5NmphNmcyVmUyWGdDcnkzZWdSZUxkY0l3Yy9TU2dvMnRoTjVXd3ZibExodVh0dGxhYTJOemk3anloazRMd1hqSU1vZUk0RHdvTFRqclNDV0ZYcDhnQ05BaUdCT0EwdVdOV1JSbHMxQlJOaEJ6UzgyVU5ZZzJnbE1LN3lrRHZRS3hVaGJ5MXRFZENvV1VUVDNySEdsaGlic0JHeTl1azJTV1Jxelo2ZlE1UFJ3d3ZtUzQrWkVaYmwxWUlweXNNVFlWaytkQ21zRXdGZHFkZ3JYTEExYk9kYm40OGhhYnkzMDZ5VldObGQ1ekIxVHFQUEZDUTVDWlBXeWlFaEdzdmZhWXp4dnFkYzRtQ1ExalNKMVRVczRzNzRKRG9INnFYaiswMlIrODQ4cGdHQWhYQjJzODBGTGdSUTFXYmJFK0VKOFdSVUV0RGc3Y096YTI3NFYyNXhKdjNCRi9UVVNRVWpBblpTZjM2YlBKYSs4KzVWN2JOeEhjbFl0SWJwUktuSkJrUWlBaVNlWlVMN0g1bFY2NnRqRlduNWhvN1J0djFPc2thWUVKWW80MjdtUTF1TWhHZHE2NklSVjVMdlNUZ3AyZGxLMHJYUzZmM21CN2VadGhMeWs3NDZYSkcrSUVmSm1FaWdXbHFwdldDNFgyS0Mrb0xNV0VMWEpyYWRack5KcE51djBFNzBzWlNxQTFJTlFpVGFRVmdTN3JGd2tVMW9QekhtVkt4c21xRVJ0bEdlWU9FNWl5MnkzUTN4aXllYkZObmxuT3IzUnBMTUxqUDNxQWV4NmVaMkcyUmlkWGRCT1Bjb1lrSzNBV2treVltWTg1Y0dTTTltMXpyTnkveE5sbjFubjVHNWNaYkEvUnZIRWtzUUtJa2xJSW1mREdhVVJLcWRhMWRmN2FnUVA4MVF1djA3ZE95WnNpQjlDNnFkV2F1N3ZaK01UTDJ6c25ySlRVL09ndUR4VVNLVTFQOGNwbVVaemZkcmJYVUlvbHo5U2h1SFlNK0haMVQrcHJwUTRKOW9qREhGQjgrYVhlbGNkdm1mamN6QzFqSjBKRHl5clk3QlNzYnFhMCs1bGY2MlduTDdiemI1enUyTzgyeC9RUG5Wb3MzbStkNEwxaTBPc1FxWUFiSnU1amZYbVpRZ3BjWVVoVHo5Wm13dm1YMXJuNDhpbzc2eDE4MVNuV1NpSGVsMnBjWDg1NTJPcVNKaFlDSlJnRlBoWGlTSEJGanJNT3BjQjV3WmdRVFlvdmMvbFNpNjdWeUw4VU5JUWFSQWthQWFPeFhoQXRHRjErRGEwZzFLcVV2eWdGbVNXNzNHVnpzMHZiSjl6OTJEU2YvUEZESERyY3dGbklDNkUvOUJTNVVGaVBzeDd4RUJpb2kwSWorREdGVW5YR21nZG9Ua1E4ODd1djBkOU1kdmM3cTZzWFhpcUQ3ZklpN3BIN1hDdXU3MUt4VHdCLzdyWFhBRkc1TDJzT0lGSmw1SmlZaStPSkQ4OU8vL0JyTysxUGRmTThydThKQWJwU0Exa2wvWjVTenlRaWJZRjhRZ2ZVb0w1UWoyK05qZm4xekxsckJoeHZpQ0RWKzVZQndhOThkZXZmSURUdU90cjg0NzJCbmZ2Q00rdXkyYzJYTzRYNnZkTmIyVmZXQnJMZXJNZjFXZFgweHBmMGFwSG5ZQlJCRkhObzZpU25OMi9pbGExbkVldlpXTzN6MHRNWHVmalNLbGxhRnJ4S1Zlbzg3L0VpZUNkNFVUaTUrZzBsMVNPcUJ0Uk0rZS96TEVjSEtYRzlaTE1jR3FFVUE0NDY3ODRKL1VGQmxwUlFFOUc3enlTUkVvaWpOMTBFY3VjcHZPQkV3Q21VVmJTdmRCaEVHWi85bVpPODgxM3pUSTJWUUJZRmhTdUgwTDJVQUJHbk1NYWdjZFNDY2k1NzNBdGpkYUZkQTMzSEhHazc1Wmt2bk1kbWJuZld0RUtDVWhYejh5WXQzRFZ4bXNiQS8rUFA4OW5GV2ZYYkcyMjYxbzRpeDJqeXNpSFFIQStDaVUvTnpuN2djcmYveDgvMSt1TkJGUktEcW9kZ0JDelludkNWRmVRcDdTVkQ2ZlprR0NMV1VmZ2lDSXpXMTVwSTg4MFJKQWZNU3l2SjZ0Lzh0U3UvZk0raCtqZkozRDNkWVZiMEhNOHVEN2hRdmJmeHhIaHQ3SVpqODZaSUEvSTB4ZGtDN3pRNmlFREJnZmdFVCswOHg0Vnp5NXg5NWhLYnl6dlZVNzU4SXVrcXhmUWl1M0p3cndSYkRkRzRxOS9YN2tWMmdyS0ZKKzhQR2RkVmQ5TVlhclc0akVUVlRlc1JVZ2Z0bmtPTEVOVU0yaWhFbDdlajk3NnFBRFZLU29wRktRaFZ5WUw1MUJIVTRETi85aVR2ZU04U0laWWk4eWhkS29ZREFja2N6cFlWZGhDQU5vNlEwb1VsRERXaWhIb2d4TEVpcmh0TWVKQkJQK1BGcjExQnlrR3MzU1RiZ3pmcVRVV3BVb1NSSWN2K2FQcG1ONCtQYzJVNHdLT0kvOWIvZ0FKbFJaVGZNNE92b0NuUXZHOXlZdDk5amViSHovZDZuN25ZNzgrSjkxZXRMa2Z2bzBJVndqY3Vpdnh5VDFpdks2KzlzSVZXYUJTRDNHNE1DMXVvcTl6RU5UZFJPSW9pS2VDOWlIM3F3dkJKNENtKzEzZzQybTRQOGpEV3o4WW1mbXhqYlROY1hOeEhyZEVrVFZQeU5LWGhJdnk1aUNkLzYyV0tZWXFvY25qTWVVRzhJRnFoa0hKYXFBS0FycXBYZWVPdDRqTlFrVWZIRHB3SDhRNXJIWVV1OE5xamphYXdkdmVPODk1UnBKNUI3cEhDbzRlT01OVG9RSmRkNzBEalVIZzhPR0hReTVCYVFLZzF4aGpFZXg3ODBEN3VlWEFHbXdzT3dTaWhGaWx3WmNTS281aStjMWlmSUNoYWtjYUk0SjNEdWxKMlZ3TjhDTG9ab2c4Wkh2cmtjWVlEeTdsblZ4bDU0dXhlVk5tOUthUnEvYUF4ZnlTTjVUdW5KbG1LYXF5bFEvcldLeWN5b25IMzFoc05wVlRqL2JQVE44eEg0Wjg2M2VtKy8rSmdVQmVSM1p2S1Z6ZFRJS2dDWGx1SC83a0w1d0JTNzdrazl2bGJRL05Eem9xMHJYMnBXb0MwZDZIcE5SVkI0T3JzOVFnc3V3dHFydGFVYUtDV1p0WmYzbXgvNitCRTlQcjY2c2FKTkUweFFZQXRjcm83TzN6M084L1RQcjFPa0JtR28wSmNsZUNnaWlJaUNnL2xFeGU2b2xtTGFseEpDbmV3K24rZVViQmlvVG4wSEVJNHJCVFQ0bjJjSmdWaEdJZ1NVVnByYkpIdkFxM0lIVnVyZmNiMk5SRXZHSUVnSytsVkUyaDhvTXRhQlBBZWhnT0xwSTVhUGNRRXdzSk15TTEzTkJIdnNiWVNwb2FRV1kvM2psNG1lRUxFbHhTejA1QTZUMDBIWkdJUjZ4Q3JpWlFtVTQ1SUs1cWhaM1l1NG9HUDNVQTZ0Rng1ZVdNWElJbzNQSERsS3YxYlBwZmkyR0N0eCsvaGZaVldqRTlHdExmK1lEdnREOC9Nb2JUbjlLRFAwSWtxdkZkU1prZ2pnNG9HMERoUXEwMCtPRDcyR001OSt2bU43WHQ2ZVI2RWUraW5qRjBxMjZidzdTMzQvMjdDMDFXV2dvaW9wNGVEYjM5b2ZLTGRGOW41ZXJmN0NtOTB1ZVJhaXlCdkJvbmRRenZ1ZmJxWjBhL2ZQbjNwdFlXN0o1L3N0bmVPSmNORUs1VHFkanE4K054M2VlcWJUNUlYQmFjV0RuQm1hNVdkWVUrOHR4NkZWd3JsQkN0ZU5wVFdsNTNYVjd4VFQ2Y0RkN2JJWlJOb1ZSZHBSOHFIVUpSQnF4QU9CSEI3SUR4QVZ0eFl0L0dzRGhVNkNERUVaWDFpeWlnMTdCY2tnNkxVWFJ0RmdTSlFvRHk0M0NNVnBXU3JpVDg3c0NoUjZGQTR2RlJqdktuSjgvS1NGTDVNQTRuSzRoL3J5YVNQVnhyUmtLV2VaQ2cwYXdxbHBVd2pIUXk5TDU4b3FnUnZNNEM1K1ppNzNuK010SnV4ZmFVNzRuUnpCVDIreHdaSENFTkRFSVE0bDc4aDYxQ1VFdm93MXJ0LzdMM2c3TlYvVTI4RUJLRkNHMFZuKy85OG5QZFVvMEV6Tkp6dko2eW1xVXFkRzlVYW94cXBFV2pkL09EYzdBMEh0Zjc0eFY3dms2OG55VlRxdkFyM2ZGOTdWSWY5Qkg1ekhmNS8vVEp5Wkh2YUlVRk5LWnM2c1M4UEJ0OStzdE5aNW8wR0dkZWthY05la0x4NWc2enNpU1FheUpPMDZMMXlhZVZmSFR4dzVPR2RyWjJqZVpiejNMZWY1YmxubmlYUGM2STRwQlhVM0dHMThFS3hwbC9kNkd4ZlZrZ21Dc1F6OUo3WDhHckZPOSszdVJ1dFM1YXFrN3JYWGtjQld4NHU1OEt6T2Z4bTd1U0VHcVR2YThYbTBhYklmQlJHUmhzdlhxeFNJcmpNWWpOYk5nNjlKaThUS2hRT0s0SW9oVTh0MW5sMHZiUVJTcE9jaVREaTJQNFFMNURiY3RKUnZLSVFoVElsSTJhQ3NqK2tBa0VWaWxCQXBLU2pqVklvUWh4QzVvVGNLbXpoaVFKRnBEVmpkVmpZMytUR0J3L3luWDk3bHJTYkNVcTF2ZUpTZFlVZFZTM1Z6M0lGZ25OT2VjOGJYQnVkRTlyYk9XVWNWa0pGVWh3ODJwU3h5UWhiQ0hIZFNHY3JKUWdWbloyY0tOTGMvZGdCdEZGOC9iY3V2T0dOZjgvME5PTmE4OUtneStVazAxblo0d2oycEZUTmhqR3RqeS9NUFRBRlAvZnlkdnZXelRTTmM1Q1JHZGllZWRuTXdrczkrTndHZkNHRERhNzZpNVhQTEszMVloVFAvZjdPZHZyTm5aMXZGQ0lEdnRkZTZab0R5UGNEeSs0M2VuaW1xYTdzSkdLOUh6RmU2VXVYVnI1N1pQSEtQemwrY2ZrWGQ3WTJXNisrOUJJb2o2NEZzdTRIYWlWdHY3aXgzUCt2TzV2cCtUUm55TlVGbDlXRmNIN1A3OTJlVk83Tm5rbTdzeXBBMzRvc2J3L3paN3VKK2x3cnR1K2ZiTHFIQThVUjU0clFJT1REbkNMSlVYSDViRE1Lc2RhanBLeUdyQzliMWQ0NjdLQ2NhUElleGhjaW1zMmdqQmdLaGxsWm9JZGh3RVJnRUZkSzZJM1JORU9OV1BCR285QTRMMWdQbWRkazFwY09MUjZDVUVpTFVzbnFQZFJxbXNWREUyeWRuT2UxWjY4b3ZLeDdZZU5OUDdzcTE4NjlZVldFZW1PZlJBUUZVbmtMaXdoWExneTl1amdzMDJTRmFLMm8rQXRCS1JyanBZaXpOUmxUcEk0c3RYenpuUS96WDcxOGxxZTZIYlZURkNvdjA2cWdLc1FiQXMxSHBxY1g3eHR2ZmZ4c3Avdlo1N3E5QTg2NVVjbW5TZ1lYWldEbzRidEQrUDFOK09JUUx1MEJocThFc2RGNEVFUS9zclIwcThyU3YvVHQ3WGIvMWFKNGxxditZOWVVeS91L2szbjFzZjJ6MHM3VzZmU1RFZU0xQlBRM1gzcnBYemJyOGFMMnlTZDMwbTU5SngrR20yblBEMnorU3A3Si85QmVTYitMeU40Rk5JNDNHckx0QmNiM2M5dFQzd2NrRVpCYWtYWTdMVjRjWlBZM0k2MGVESTA4SUo2Yms2MjBkZUg1OWY3a1hLUGRISTluYTdXd3JyUXlDaWtMRmNvV3RvamdDNHZ6bmp6M0JOUnhVa2FGS0tRVUtSWVFCQ0ZKcmlueWhNQUtjUU5Db3dpcTUyYm1CRmVsWW9GeTZGQ2g4U2dIUWFCUUtQcUp4M3FOR0lpYkFmTkhKbGkvdEUxbmZYZ0d4VTZsNTl0cmhST0lsQy9ldUZ0RlZlMko4cis5TjVlU2tzaXJmdTlkQ1I2dGxOamMrMi8remtXcE5VSkVSQjVLOTdGeGQ4R0RYL2s2dDQrUDBiYVc1Q280YWhXRjIzaG9jbnovSFkzYXo3L1E3bno4WXJkWFowODRDNjVHak84VzhKVXQrTjBlckZiMWViRW5WUThGb29PMVd1dVRNN01mWE9zUC92aEd2M2M4OGY1LzNWS3NsZzdHMytOQjl0WUN5QzBIeHZuVzZSVXhSb3R6dTFGRWIvZDdhNy96elNmLys5bnA1bS92Rk1PbHBFaVBtbER0K0VKL05lMjRpeURwbXk2WXI2Zy92K2NOL3A1TlEyL1NHb3plazVFZGFGWjl6UWhJQzVGdTRlUzdPSDVkd3lGQmpxeGZHcXp0ckExMzZzMXdYNjJoYjZvMXdodmplbkFzQ3ZVVVdrMHBwWXlvaXVQMklsbGFxSUFKdk1BZzk5UkRUUzFRNUtFaXN4bktxZEp2cTJIS0ZDck4wVjZURklwQ1BIRXNUTlFWdFZDUldjOHdvL3p4UkxBT2JGT3oxZmRzZTBISGl2cFl5TDdqMDhtd2w3K1dEZ3Y3cG9mQXlQZzVIdFVBQjQ2MFd0T3p0VGhKbkt3dEQ3THVUcDd1ZWFnNHF0WFhnRmRxVitGaFJiQWpoaWdaV0pjTXJGZkFOK3FyM0Z5YmwzMVJqYk9Eb1VxdTFoeHhWWXczZjJUZndvbDlnZm5KSjdmYkgxOFpEbXR4MVU0S1MrS3RuOE9MUS9pZExueDFBR3Q3M3VmUmpiN3J6L3V4bWRsYkZvUHc0MmM2blErc0RBZlRVNmp0Vk91djVTTHVUUTlPM3BJQStkelRWeml5T01YYWRsOTJ1a1B2Uy9VbGdPdG1hZEZkU1RkSHJGZlppdk52WHBGc0tZa3JVUXBSU2lHbFB4UktLNmxQQnd3Mml1L0o4ZmI4ZG04Tk9McW9vOTJCbzZneThIQVorQVlRRkxtWUlzOWY2ZTd3QktUTklHQytWdGY3NDVxK05ZajBRVzNVWVZFeUo4aTRLM3hkckZXRkYrMnNFQnRmRG5oNWh4ZE5aQUpFS1ZJckdLMVF4cUNVd2x0TEdFS3JwbWpXaEdaWXBsaVpnMDVhenJORUFVUWFwc2VnRlVNa21tUTdZdUhBcE10VG01Lzk5c3JlM1NxamFGR2JuSXJHLzhUUDN2amd3ZVBqOTVuUUxFV0JtczZzejVQVWJiUzNrOVVzODhNa3NmMWtVTFN2bk91dnZ2WktaN1BiTGpxZG5YekFWUit2M1UxWjRpV241Q2FjdGQ1ZlB0ZGg0SXFScm1xdmUyYmpzYW1wSTR2Ry9JVnY3M1Rlc3pJY0JvMnJHcktpZ05jSDhLdGI4S1cwQkViMkptQ016UFdpazQzRzFBT04xaVBldTU5OHBiMXowM3FlcVFtQlFxdG5MM243d2g3VzlKb3EwUCtkQVhKcGZadmJqaS91R2ppVnZiczMwTUs3NXMzeXhoOTZ0K1pRQ2pFUllvd21NQUYvODcvN05IL2pULzFqQkVnNy82ZWN2N3lKVWZQZkJ5am0rK1RzbzkvM3JHVzkzL092OUh2K0swQTlDSmsxQWZQR3NOOTdsclkyaXh2VDFML2JLQjhXdGt5TklsTlN2SVd6cFlWZVpjQ2dLL01JNjRVSVJUOFRJbE15RUlLbkdZRVR4VENIWWFGUXFteFFPcU9Zbk5LY3VLbEdvS1U1SEl6ZDlKcGEvVDBSMlRzTEVkN3owT3pTeHo1NzdJZjNIUjM3cERKbVg2UUR3TkxFSThEQ1Vvd3ZJMFB1dk0rTTkzM3h2dFByRmErdlhCcStkdmxDOHRybEM0UHpyNS9wclM1ZkhIYTR1b1EwQTNKWGVMdTVOblNxRER0NkQxdFYvOGpTdmtPUGpJLy9oWC81K3NWM2I2U3BHUytmUGxMQXhoQSt0MU9tVXVla1RMT0xQY1RLNk91RSs4S29kZTlZNjlTU0NYN2szSEQ0eUpWa09LTzhsenBnbE5yc3dHOXVldG5tR2h5VTRqOUUxakE5M2dDdjhDS3FtNlJLeEt1eVhFUy9TWW5wcVJyY1ZhR0lNbFVUekdpTUxsc3M2YkQ0Zy9nWjN2ei8xOStuZmhrQkpYalR4eU4rdjM3ZmV3NDgvUEdmUFBHZlRVM3E4ZkZhcWV0U29rZ0t3U3BWY2thcVhOSGdQZlF6aTdZT1pYUTFrYWdZcTBFekxPMkVDZ2U5SE5ZSEpWQzBDR0toOE9DdHA5L3p2UFpLLy9rdi9lclp2N3Qrb1hNUktKUlM4b2tmTzN6cmV6OTg0R2RxWS9FOXVaZkEybEpRRTRlNmxNdW8wbXBWbGVwWUZFSVVRQndJb1JZUndWa3ZXYmRqMTdZMjg5UG56eWZmK3YzUFgvblM2NiswbHl1Z0RQWTg5YW11UlExb0hXMjFabjVrWWY1blg5emErdWt6N1U1VUswT0JzL0N0VGZobnkvQXRYMzUrL2liR01RQ0M4U0JvUERvNWVmUndFSHhzWlppODUrSndzTlJ6VHNlbGY2MDBJTTIwK1Y5ZUVmbWZodUkzZ2Y2ZTFPeWFTckgrdmZZekpGbkJPMjY1RVkyaDNSK0k5UjdVbTU3cVpiOWpWR05JRUVJY2c4MHBaZkJXc0lYSEZ2NFBCT1hxalZIRmZ4OFNZRzhrMjd1WU05L3o5Tkp4TGRDSGJwcCtkSHc4bUtvRlphL0JHRlhSdnVWckxKckdBWjFoUnBxNGt0b05OR0ZRMnBubWJqUjdVaFlGaFJXMFVpUldrZVhsenc1Q1BTd0wvZVpZT05XWXJEVXV2dFk1cjcxRWYvSS9PZm11ZDN4dzZXZWJFL0Z0Um1rVGFnaTFveDZVKzFNaVUrcHNQSnJDS1RLcnNOVTJiZVhMZm9oNE5LSWlZOHlVcVljM05DZnI5eThjbkRqYWJSZVh0bGFIM1RjOVFIUWxPbXdFV2pkKzdNRCs5MTNwZEgvK3pFNTdMQWFwZzAzZ2R5N0IvN2dPejh0VkcxYS9KMkpFMDNIY2V2Zk05TTJQVDA1OXNzanpQM211MzMvMzVXUTRtVHVIQmxVOWliSUM5YXNYRkwvY0ZiOVZFVDNadGRZZy9BOENDTURoK2RuS21LQ1BFdzgxVU9XRFRZelJvbzBTcFZYWk9hOXVGcVZLUnVnUEtReUtNa2lnRURTaWRObjYyQU1ldXljOUd3RklKWU1pTzNoeSt0amtYUDJXS1BCbHRXd1VhUTc5ekNOb2pBcEwxeElSOHJSVUp6WHFpa1pGNmFTNTdMclFsNnNZU2k4djU2RTNGREtoa3RxVXdJdU1Ncld4Nk1oOHZUN3oyTU16aHgvODhOS1BFNFFIMDBLVTBaWGVTNWRxWVcwTWNXQUlxeVZENHN2K2kwSkdCcVlvUVhsUlNwekNPWEJXVVZnVnFpZzRObmQ0NHM2cGZVMjVmS1o5MFpmcjRrWlJOQVlhajgzTkhBeXQvY1ZYdHJadkRMd25oTTB1L01wNStNZDlXRlhnMU5WaHBnQ0lieHByVFg5Z2Z1NmVPOGRhUDZxZCs5a1h0cmJmZVhrNDNEY3NDcTFGMEtXNU13cldVL2lWQzZqL3BTMnlYRVd4dlVVOWJ4dUFuRi9iWUtQYkxjRlJWUVZLOWhRSmNsVVNJUlgvNy80d1pVVlZraWZWNjhqTnNMTmVmbXZHN05FOHFkMm9BNkNkOVdwc3BxNm5GNXNQbVZEWG8ycjFXK1pBU1lCemltNmFZQlJvcnhtbUJZMmFZclpsYU1ZbHBWdXZLYUxBRUJpRFVoQUhoa0FyUWlVWVU2WnB6bXN5cHlpOHdualA0cm5DM0xKUVA3TDA4T1F0UmFCYVJpREpJWGNLcFRWT05QbElvVlhSMUlGU2FHWFF5aE1nYUR4YWxVMUxxWGpnVWZhanFtWm1FQWN6RTdQMXU2ZjNOV1ZuZmJnODdCVnUxQXhzQm1ic00zTUxuMzF4WitjaldaWUZFUXphOEk5ZmczOWRsRGV6QnlSVVN1MkxvdkU3VzYyamo4OU12M05mRVB6WUlNOS85TFYyNTZIejNlNTRacTNSVmM1ZHZUSUh6L2ZnLzMwZWZqV0ZVZVJJOXhBSjErUWluVCs0RlZqeXBvLzMzSnpYd21sdnZFRW91M3UwWWVRWnZVdXhKdjJpbUQ4OGNYdllDQStGa2NKb2pmT0t3a0tCSWd3Q21uR05KSEY0NzVpZDBEVGljcnkzSGtJalZnUzZyRlZ5cHdoVVZQWklmR214R3BwU09helFlQS83djUweGc1QS9YTmV1cG93U1JhZ2dGNDFIa3pyQmlzS2p5VjNwZ0MraVM2Qkp5WlJvVlVZUkoyVUtXM28rNkYxbkYxZFY0WlZnTFI2YnJ0KytjR0JzYm5ONWNIN1F6VkZRKy9FREIrL1FSZkd6WjNmYTB4RU0ra3I5eG1uNExRK1pSc25oZWoyK1oycHkvNzJONW51T2g5R1BpSE9mdlREb2YrRHlNTGxsdVQ4WXk2eFZZWFVScGN5N3hFQzdELzlpRGY1ZmEvQnRLU1UxZlVvMWZMNUhQWEZORGhnSC9BQ2UwUnhTR0VPUmdWSks1Q29YbjIrdEREWXVuZWwrWVdLNmRrYzlpbHA0d1NJVVVxcUFveEFTVjVDTHcxUWp5RW5oYVNxb2haclE2TW9DeUpGWlRYdVk0OFZqdE1JNUlhRHN3TWRTWi82N1hjYXY1R3grb29VS2RlbldvRFdaRTVRRzd4UjVWYUNIcHF5SEJ0VWdXVUJKQWdSS2xYUTBaYlN4WGlnc2lKTnl1TDFLUXBVcU4yLzVBTVRUMkhkbzdLT1BmdlI0NHl1Zk8vc3JiajF2anl2MWdaZmI3ZjNldTd5ajFHOWVVZnEzajhWaDYyaXRkblJjNjRNQ04xbnhKNjRrNmVKcWtrWmVST25xNmFMM0FLT0Nacy9DMTdiaGMydndsSVYyQllwa1JBNG84S2FVclYyenZ2YUdIK0RqcTZ4M1lxNmhpdFN5aDRrTHVwdHBlK0hneE8yMVpuUkFxcWUwS3dTdk5Fb3JRaDJpZllDdDFrREhzYVlSYXNMQUVPcUFRSmV1aW5taEdXYVd0QkN5VEdoM1lHTlQyR2dMVXk4bUhQdEtoNDEzMTFISGE4VEc0RVF6eklYQ1V4WGc1VnkrVUJvK0dsMjZHSWJWS0xHdk5vajZvaVFDUk1BNlJlN0t5SUVJcWEyaVNOV0dHeGxkV0NlNk5SWWZiazQzNWxwYkxoMGJ1TWZQOWJvenhwaFhKNXF0WjAvVjYvZk9hZk9odnJXUGIrYjVZOHZKOE1UbC9uQ3lXeFRHbEl5VXFxaEJVVmZyakVFT1R3L2hIMStCZjdRRkwzam83b2thdStCUUlIV1V2SWVJczlkbUNmS0REWkJkMm5xeFJWTDY3ZTdTd1ZsUzJPWjRISTFQMSs4M1JvVmxUYTNKL1dpa1Y2T3RRcnpGQkREWjFOUWpqVWpwR2w5Tys0WW9Jam9EeDA1YjJGaUhuYmJRNnp1V1hrMTQ4T3REaWdsTisvRVc5VlpBYWcyRFRDRVNJQ3BnV0RqU290UnhLQUZGdVE0N3FNenJ0Q3JuN2lORDVkcFlqZ09MS0F5Nm5QVDBpcXlBckNqSmc5eUMzUU1ZOGFLYkU5R0I4ZkhheWZUMTd1S1lNbVp1ckNWSlVkeTFuQ1IzWGM3U3BVNmV0NGJXYXVjRkF6NG9JMjFBUlY4RlplRytidUU3ZmZoSHEvRExtL0JrVWRZYWd6M0ZlQTVZRGI2SllnRXRDYkNLNTFyZHpoaGNoMGNaU1NxWnVLL1NyQlNJVHorNzlxV3ArY1o3VVJQdkxJcUFxQ2FvVUpOcmpYY1pLbkdZQ09wUkdWV3NveG9kOWdSYUkrSW9DazgrckxPeTNpZlBISTBNN244bDQ0WlhFcHFaSnAwdG0rYTVyWkhsNVQ2Uk1DaHZiaVdhV0N0aUpRU3F0RGd0bk9COFdZeHJYZjY1Rm8xMXZodzlWcFg4VXlpTndRVVFUMkU5YVQ2YXh5bUZUMW9wQXFOUjRvMDYwamhRUERqRDhwY3VzYlc1dFpDWGVpc0p5anBDeWRVbTArc3AvSmFDeFJpT2UrZ1c4RUlibnVuQ3E4bFY1ZTZvS2JtN0pYZ1VOV0tRQ09FNGhvdGMyd2JkMXlNSVVBdzlRYXhLRHg3WnM5c2l0VFlJVFJJM29qdEY2WEVSUVZXbWNNcDVYT0hRa1dKNlhOT3FkaVI2RVl3cWkyL3JoRFNOdUxUdXNjNFRhczI5VHcrNTZidERnbHh3U29pRGtNNWlRSGN5Sk0wODFwY3NsNGdpVW9aUWxWSVZWV1YvdVpWeVloRklDa1ZhUUpKWGZ5WWxaelFTVGVMTDc2bHdZQXVOZHdyckJHZEJmUGx2ZFZVMEtBRTFHVE1Rb1gyNVcrYVVJQjRTVmRvRHJDczRuY0N2WElMZjZNTFhIWHlsRFo5Zmh0OGZ3RmtMTzFVYU5kaWJUbzNBTVZHbFk2T2hvbGU0OXYySHJ3TUVjTTZ4Y0dRQ1o3MnkyUnZlTkwyOU5salhSaGR4STd6RGFCTXJyWlN1R25VYXhYalRNRDhWVURNbGN6VmlyN3dIcldMYTNaQnUzMkdCVTJkVGJuMm1EOVpYWFV6QllJaFhIYjA1aFp1TWlGUlFXaE5SUnFNUnNJeldwYXlsV2p6a2ZVVUQyOUx3UW54cGR5cStxaldrR2srV3NoZFNGRkttWElYSDVsSld4aFY1cHlodGxyeUZ4blNkTlBmRHJiWCtNMDc0MWhCK0k0SFBEK0JYTy9Eck8vQmRLZXVKWGdwcmVRbUtFV1U3M0FNTXE4Q1pQUlR1ZmtyUjFtaXUrNjF3cmdPa09tUFRkYnFiQ2ZKR3F4MEYwTmtjWGdwQ0hVVzE4RVlUNk5qb2N0Rm9wRFVUWTRiWkNWTjF4U3ZiSVZPcVdISWIwZTRxVXErWTN5eTQ1NGsyUlRmSHEwb3Q2RHhKVm1CNmpsWVcwcDhOc0ExRFZEbEd4a0VMTllvSW50SThXd21CcmlLQks3M0VqQW9JVkVCaHkvMml2bW9ZbG1sV2FVeFJBa3R3UlduYkdPU3EycDlZMGtoS1JnVytJSkVaN3FUMmY3dThsZnhHQWkrazhFb0dsd3JZcnNBeEFzUWJ0RjI4YWRaSGdkUkFKcmpxY0hLWU1nZmpPa0RlV3FlM25XSUNqYk5YUGFCRzNMejM0bmZXaG1mRXVXRllDMDRHb1drWVkyaEVocW1wa0ltR0xqVlFvYXAwVVliQ2FmckRnR0Z1Q0V6Q3pkL3RNblV1SjNPT2JwNnpjbWlKK2Z2dklsdGV4ZWNGTTZwSnVBUDV5UW5xWXpOWUM0TXNKUzBLckhNVXpwYXBtd1RrdVMxZFlhU1NsVWdaYWF5VjBxT3JvckpWdFk0Qk5MN3F3M2dQUm11c2xNVjZPVFFHbW9EY09mbzdHYjN0SkE1QzNkN2VUTDVoQzkrcEdLaTl3TWlBVEpWc1ZLSEx3dHZxa3JiMXVrek5kc1ZaVko4d2VJdUI0enBBdnFkWUY2b0p2RGUzUGhFdnNyTSt2SkFQOHlTc0JUZWJPS3czV3dFSEZwbzBHNHJJK0lwbU5XUUY5Rk5EYmhXbWxqSXVPY2Ura1JOMVBjNTUrbG5LNWczSHVQLy8vcmVRemc3ZDc3eklJTTB4V3lsNUw2TjNxQVZLa2VZT1ExU09DVHVIRTEzdWxjOGRvVGJWMkdFNUdweG12a3lwbEFJcGF4V0RwaVllVzFtNFN0Vk5GeXRrMVZKNThRcG55eDBweWREU1hVL0lobFlGY2VEeTNEM1IzVWxIa3BBaGtDcWxDcVhLbWdMd1VSa2hmRmw0STQwS1NhTXpHaHA2cTU3ckFIblRVVXB4NzkwbmFYY0cyS3NyMEVaSzRMRFh6alo2N2FTZFovYmc3TDc2K0xIRFkycXNvZENxN0hZN3IwZ0xUWlliSk1oUWdhVzI2Vmg4TW9lMHZORUhlVTV4NmladS85U1BFTmZyckh6aHl3eVRCSEdleVE0TWpkQ2JxMlBRS0ZYMlU3eFhGRmFRd3BiejhMN1VkaFZlU1BMU0xHOWs5VnBHRmFxMERKd3ZheUp2WlJkVTFwZHo3YjVLMC9LMFlOak82TGRUUUlocVVaWVgvb25ObGQ1RlZKbE9hYTNzeEV4ZEdsNncxb3ZqNm5qblhzT0M5RzEwUDF5bmVkOGNSYnp3L0F2bnliSTNPUER2alNaMnFqNzE2b0g2M01XZFM4bkJjdFJiVjd0SlNqR21JY0lFWmRHczBLaEFVZURSZVdtd0hhQVlIeDhqaUVJMkQ0elJXWWhvZE10OWlBYkYwdGMzS1FKTjk3WXBBaDJWWTdwMmdQS09XSWZsa2lEcnliMVFJQlNGVUJQQktZMjNwVU9rcGt5bGt0SGdaaVhSMUtLd1VwSUFXb1FrZDRnVmtrNUJmeXZGRlE2bElZeWlPSXlpUnRsaEtkZG9lUzlNVE5lbEpVSTN0Y1I3Q3BDMzY3a09rRGVkL2Z0bldWN2VRa1QyRGxzRlFHaU1Oai81WSsrLzQrNDdqdjVFbGd4dVd1OHRxeWdJS3NPR0FrU2h4S0F3SkQ2bkZta0NJK1RqaHY2VW9ublo0VFdNUnhIcXlqTGI2NnY4cjRPdk0zM1hCTGVjNitDOUo4OXlJaCt3LzhrZDhsalR2V0VjWDNoVXRTaklXaUYzSGwvMU1iU0hRR21zZUp4MWpGd2VuQmRzb0NtOHgvdXlMNk5RaUN2blBBdFhtZmI1MGppdnR6RWtTNHJ5YXlxTlJzZmErbnFGSTYwVTJnUWFVWWF0MUY1N3U5S3VwMWovY2MvZGR4NmdYZ3U1ZUdtTEtBcHh6dS9kMjlnNGRmTEEzTS85OUFjL2NzdXBnejhuUHIvSnVpS1lYZ3lZUFJpaGxjZjZIR3MxaXJBY3RjMEtvckJNYlRJVXJYTUZ6U3NaVmp4b2plcjB1RHhwK1BYb1ZYcFByTFB2d2c0dHJhdDZ3Qk1WQ3RPMzdNeUh1RmlCOStSWlFaNTdVdXNwQ2wvTzFSU3k2M0dzVUxocWpVUlFPYmFVSysvSzZHR2RsTkhJYVpLa0lNOGNOdkZzci9ZWmRKT3JZd05HVVkraU1Gb1pYcnF5Mlh2YVhRMFVidGhOcFp2YUg1ajc0anBBZ0NpS1dObzN4aUFwNlBkejViM1hJakt5Mld6Y2U5ZUovWC82VDd6dkZ4YjNUZjNFWU5oYmJMZTNLSXFjaVNYRjJGU0FzMzJzRlpLODdING5oYkNUT0JxeEpzMkVRaUN5aXRuekhwZlp5djZ4WVB2bGwzbDVLZWNiejV4bTluTEtqWEc5R2hFc25SYkdKSVNOaE01Q1NCRUllZVlvcXJHaUloZUszSmJqdlZLNkxzcklmYkZTVVplMWlNRlZESmV0Nm8yaThCUzVvOWZPMkZrYmtIUlN2Qis1WDRJS0RYRVVxM0M1UDl4b0Q3K1lJRDBnMXlqcm5KY2ZwSHZqT2tDQWd3ZkdPUFBhRnYxK3BxejF5bnNabVJjMGdQcFlLN3J2MFA3Slh3Z0RtZTUxTzlqQzRpaVlQMXJEUkJieFdWbC8yTEtlNzJYQzlyQ2dXZE1ZQmFGWDVDMUZhOWtTYmxreUJLdWdPU3hZdWp3a09UYk9sYnNtdU9sS1Jpc3ZuVk9zMFhnUm1nbTRYczdtWkNseEtYSlh1c3c3ai9hK0dnbXVPbkc2N0dlb2F2N0RPY0hvRUZHQ3N4YURCaEd5M05Gdlo3UlgraVRkbEtJb2tHb252RFlhRXdib3JTRnM1ZCsrbUdSZnlzVVBnVXdwWmVVdHNEZnhPa0QrQU0rakQ5MU1wOXVsMDhsVVViaGR0b3BxSVF3dzJlNE00a3VYMW02eFJYcGdmQ3dHb0RsdW1ENFVJR1FnSHVzVTNpbVUwblJ6enlDenRHcUtlbFNDaEhyQU1MWFVYeDZXUzRQS3hTRFVObk9PYkZ2TzNqUk9ITFk0ZExtUEdFVWhaYkZ0cmFPK2xlT0dscTJHSnRWU3lWdzhWTVcySFMycDBhV216RmxmV1ExNUNsc2d2dEtiT2NIbWpteFkwRjRmME5zZVlxM0RGNVpBNjFJWmJCUnFhNGc1c3lYZGZ2YTdsN3g5UmtUU1BRRHhEelJhWENueTZ3RDVRVGkzM255WVYwOHZxOEo2SlNKN3JUWWJZV0RHd2xEUDF1SmdYc1Fldm54NTY2UjFUdTJiYjNIOHhrbjBXRUhwZkNRNFg4NkZPNlhvSk9XK0VhMDlZVkNDSmkrRVFRak55em5OUWJsZ0kzT2VYTU5ZcnJqbDlZTHRnV1hRNlZFekJxOFZ1aEluRnM3UmFGdG10d3NDSTJRYU1oRUtFYXgzZUZXQktmZWxJN3lVYStqRVFldzllZUhJbmVBS2o4OGN3MDVLWjcxUGx1U01oZzZOTWVqRU10N09tVnhOVWNPQ0ZKNWNFZitkYWdZOUV5Z0NwV1ErQ0ZuNWp6RTdmWjNGdXJiT0xhZVd1SEJ4SGVmWW0xYlZnTmJCcFltampTWS9rcVhaSGJWYWJWOW9aR21RcE9xNUZ5N3owQU1uT0hMREdKZTY2emp2Q0lPeVQrR3ExTWI2Y203RGUraWxsbWFreVFxaEdETnNQakxCekwvdVVQUnpVSXBJU3NPSHB2VWMyZTV6UVVGTHlyM3VvMDBaaFFoNVZtQXVGOXk0bFhQejBoakpXRUFuY093WVI2OEd3NlloRHhTaUxKRUZyTWRKNmZodExiU3hESDFWdEhjeXdvRmx5bW1VMXJRa1lxd0hkbU9JVHkyWnM0UUt4azB3YmJ5TFBMSnJwYVRBRnlJY3c4aTVhM1NHNHpwQS9vRE9xWk5ML1A3WFhsVkptcXU5UmZtTk55ek8vZkNIYi91Wks2dHJQL0xhK2RXZzNVbFViZ3RVb0xqejlqays4VU9IMldGWVByMjlvTHluc0FycnphNFJnMWFsVmlxemduaGJqZHBxZXFmcVhMbVFzZkNrcHg2WVhRZUp3bnNtZ3hyanRSck9PYnpTSks3MDNLcW15ckVhdXM0VHJ3NEpOZzNUWHBqSUxVTnZrVmFNcndlb1VCTm1Ickd1Tk5OMjVmZXpsU1cwWFVaWExMUGVnMWU0UWtoOGp2RlFwQVc5SktHVXVRdE5iVlN6RnUyTGxXc1dXZDZ0N2hWdFJkU0ZMSlVaRkxVb0pNMkw2d0I1dTU0akIvZngyK2tMYW0vZEVSamQrUEQ3YjM3M3duempnODNtZkhody82UnNiSFE0ZjJtVFlacno1My8rWVk2Zm5PQ2JaeFBDMHNJRmp5OVRHTzhKZGJtU1Roc3BiVjY4MEU4c1kvV1FlbFRxb3Jydm1tQzZEYlZYaHRBTXFkVmo4aVFqendwMFlWR2h3UXJnRkxrdnphOWtaQkh0UEtuTFVDZ0s1OGdyUTErM2tWMWRHMTA1VVZnbFpONlRPMGVXRi9TTG5QVXNwZTBzdVZLbEpGNThPUzRyWlpHdUtCdU1Da1Z0ckg3M3FVT3pkejMxd210YlZXVE5CRnhQdkdSS1MwdnB0MVhYL0hvTlVwMm52L0IzZU9YTU1sLzg2c3VxMXgxcTd5VlVxclQ0ZitjakoyOTQ4TDZEdjVUbnhaRlNHVnVvUmlOa1lXR1NqMy93Tmo3MFE4ZXB4WTZaaVpqREN6TWNYcGhqMy9RVVkzRWRyY3IxMWUyaEJlMW9CTlhXWGlzNEZQVzRqREE2VlBUR05jMFZSOXkxR0YwS0Q4V1dIbHNtTE5XOGFlSElmR21zYlN2cXR4QW9SbHIxMG5TWHpIc1NheG02Z2x6SytmbE1DUU5yU2F3dFRlWVFjdS9ZempONjN1SEY3NjYrTTN1OC9xUUNTR2dNcjl1aVhsdVluaHB2MWwvWTJPN3VNUEwvQmU4MVlyVWlNQ1dOZkQyQ3ZJM080WU96Ykc3MTJOenFLTys5QVVJUmF2VmExSHozTys1NGY3MWV2OUc1dmtTeFVkYm1GS2xuYVdHS3g5NXhnbHFRZ0dSTXhkWG9uZzRoYkhKMGJvWkJMcXh0N1BDVmw2OXdmbWVIdkdwQnh4cThjeVJKd2ZSNEE2TVUzU053L2lQVDNQeUZJWEt4aDZjMFlYQkN5VUtoQ0pWQ2k2S2FEaWs3N2Q3UkxTd2VtQXFqa2hLMmptR2VWZnNPUEpFT3kzNkk4MUE0WE9CUjFwRVhCWVBSVWgvMm1oeVh3L2hoNVNhT1VuZ0ZLOE9FZUczcjdpTkw4eCtxMWFLTGFabFBXY0NKRnltczg5NTdPWFZpaVpmUExGK1BJRytYYzl2TmgzbnFPNitwbGJXMkZybTZJT2FENzczdGxqdHZXZnpaSkIzdUd3NEdLa3VIV0Z2UWFOVDU0QWZ1NU9oU2hocXNRSzhIM1RiMDJqRG9nMWdVbGlnd1RFK05NeXpnektWTm5LMGNTUVIwSllZUzhZU0JRU3RvTnp6ZE9ZUHVlR3I5Y2wraTliNGFmdklVbE0wOUw2T3R1bVhVNkR2TDY4bUFsU3psaWkrWVBIVWplbW1PaTJaQTJteHd0cGZ3YXIvTHprMFRiTDNuQ0IvNTBUL05EWGZjeTdtZExhNXNiRERheGpPeVZyUVZPS3BBaGdFNndPdmVzek5JOWVSWTQ4REJmVE92WFY3ZHVzSWI5bmlJakxYcWpJL1YyZHp1WFFmSTIrVzhjbmFaOHhmV2RWRzRFYTNick5maThVLzgwSjBmaXlQNVFKS2t4bnRCOEJSRndkMzMzc0pEOTAralY1NUJ0cmZ3L1FUSlV2QzJ0TlloUWpJTGFRZWxDbnFwNWVsWHR4ajBQRmttNVpvM1Y1YmFXZTVJQzBlekZoSW9UN2Z1V1Y0eUZCWmFsMU93SHFYTCtpQ3hqbHdKWHBYUzlReGZybGxRaHZFNEpqQWFyelhISDN5QUczN3FVL3phUTBQc2JmdDQ0ZmsxenNjRnF6OTJsTWI3N3VRdmYrUVh1UE05SCtEbXh4N0REd2FjZitrbGJMVUE1ODFteWhhSVdqVzJGeWRZN1piNzU5TXNieTdPVFV4cnBaOXQ5NGE5VWFxbHdFZFJJR1BOR3BzNy9lc0FlVHVjNDBmbmFMZFQxZWtPdEloRVZlM1Irc2pqZDkxNjY2bkZueHNNKy9QT2xjczZyYlZNVFl6ejN2ZmR5bFQyTW03dEVqWXI4TDQwU0xDaThkYVZ2RzVlUURxRUlpTXZFcDYvbUxHeG1yRzVQQ0JOaFZ3MHVTL253WWVKcFQrMFJFWVRoeEEwRFozOUFkdmpoc0Jxd2s2Qnp4eWl5bzU3NmJ0dzFZMVBLYzFZRURBVGhrenJnT1RNYTJ3Lzh6eHFzMHQzSWtOdUdVTzkveUR4c1VQOCtScyt5VHZuYnFYb2RwR3RUVjc4L0cveC9LdXZRbW5iczV0cVVRRkVBa1B0dG9NTXgycXNMMjlYVnFxRjhpS0xOeHhlcEQ5TVh4Z21XVnFCeEZycnBEL014TnEzSitYN0ExZURLS1hZYnZlUWt0c1BSS2hGVWRpNDk4N2o3M0hPSGk5eWk2ZVVjM2pudU9QZUV5eE9iR1BQWFNCUFNnTTNGWlE3UTF5VnphdXNTeGlGYUJTU1pzd0dpdjBOT0pkNk5sL3YwT2tNbUQ0OHdkU0JDY2FhSWJWWU1UQ2VUcnRnZnE3R3Z0a2F3YmhsODU0YXk4Y2k1bDRLV1hpbXovaDZqczV6Tk9CVWFlWGp0U0RlVXpoUFZEVVV2UmZjbFRXT25MY2NlQ0prY0tpSlcyaHlZbkdXVzE5N2thZmNpN3owOUZNODgreDNlUEgxQzNqbmRwK01WODFKUVVLTld4cURBMU5rNXphcXFGZWUxYzFPTUQ4OThjbFR4L2UvdXRQcC81cDFQZ2R5NzhVbmFTNk5aaXpEUVhZZElHL2w4MS84OVkveHIzLzd1VXFNdUx2ek83cmoxa09MWTJQNkhjUEIwT2lxb0xhMllIeXN4YW5EQVdyNU9mTCtFTy9LaVR5Y3g2b3lCVU1NU212RU9yUXhhSzBJVk1CU0hjS2FabnQ3d01hbG5LbXhGc3Y5TFNiMnRaaWFxZE9zYTZ5Qks4c0p3NzR3TnFGcDFoVFJsR2J6N2hvYit3Tm1YeHd5ZFRxbHRtMUpCaWs1WUl5bXdPTzhRMm1GMWhwbERGNkQwd0VxYzB5ODBpVTQzYWZMR3Avelg2Ulg1S3drQTdhZEs5MFZLVjNyMmJPanZvZzF3NFVHek5TWUZDRWRsamU3Vm1WMzBGckhtZGVYeHhkbm14K0tRdjBGNi94b0p0MXFyZnhFb3k1b3o3RDM5dXFML01Da1dQZmVjWXpUWnk5eityVU5uZVhXVUxtWk54clJ4RS85NkNNLzBxaWJ4L3Y5WVdoZGdTMHlraVRqcHB0bXVYdDJDN3UxaHBkU2ErV3JTYnlSMXk3VjVnZXhvMVVPWlRkQmE4MUxiYytsQzExcXdTUi8vWmYrSmd0VEIzanl5YWV4V0tJb1JGRWF2ZlVHQmQyZUpTK0V5R2hxa1NJY04zUVBSbXdkak9oUGhQaW9XamFTT3F6MUtGODZLMnFqTVhHQUZVOXVMY3BvbkJHc0VnYmljRURYRmd5ZHc2dVMwalhWZDRsV0ZMR21QeG5TbmEzQldJMW1xMGxqck1ISzVTMTZuYVFFa3FyVXdjN2hYZEVwbkh6Tk91a3hjbVVYZkpvWFlpSk5jNnpHbHpmL0N2L2diejl4UFlLOFZjNzg3QmdYTHErenNkVkhhNldxNkJFQzBmMTNIZDAvTXozMm5qVE42b1cxMkNLbnlETENRSFA3MFFqZHYwemh5elVEZWVHcXNWV0ZJT2hBSWNwWE4wODF3dXJMTWRhRk9PVGtiTUR5WFV1OCt1UXkzM3o2YWY3U1gvcS9NZGFhNHBmLzJmOUlOdGhtYm5FTUUyclFHbGRvdlBVTXVnV05wbUZpd2pCZU14U0xFZDJaZ08xYmFyRGFoT1dFMm9XVTJtYk8yTUF4WmlKUTVjQ1dRMlBDc0dTK3ZNUDVjZ2R0M1FTTTZZQlFDVU10REpSajJBaklhNFpocEFqcU5RSU5ZYWpSV3BObk9iV21ZWGFwaGJkQ05zeXhtVVVoREROM0lnaUM5MnJ0VjcyWEJDZ0VySFhlRzZlWm5LMi9yZFMrYjJ1QXZQT09nN3g2Y1p0YXJWd0ZIWWFCc3RhT2xtUkdZUmpVSDc3LzFLUE8yUnM3M1Ixc2tlRXFsZXFEOXgvZ2FLdEhzWjFCMVIzM3J1d2hlQ2xCb0N1UlgrazZXTTJDNXc0bFVBODFKMnFPVnhjYkZMZlBrc3NBdlBEVFAvMnpUSXhQODNmKzYvK0Mzdm9LQzRlbkNac2hlYUJKSTBNVUtubzlhRzlybW8yQWVsMFQxQXhCWFZNY2lVa1BSR3plT29Za25uZ3JaNnduaEZ1V1lBdGs2TWg5R2NWczVhYTRrNmQwb3pxNWorZ1pJYTFwQ2dXRUFRWkZ2WktLZVBGWTc4bXlqTUZxZ2piQzR1Rko2bzJvOHY2MStHRkdiM3RZMzlsSlB1REZQREZJN01paHZSQVJLVEpuNDFxZ0htejhiYmtPa0d2OC9KT2ZmNXphZEowLyt6LytIdXViUFNXQ3N0YnBhcVZ5RE5RUEg1aVptWnFNM2pzWTltdldGbGliNDYzbDJMRTVIcjJsQnB0WDhPV3VnWElxenlpcXBUT2xqeFJseERDTWV0QlZzV3NkK1NEalJNMHpNY3c1Y3NNa2dWdGpkZnQxWm1hbStlRlBmWXFGK1FYKzIvL3U3L0w4TTg4d2QyaU01bVNESURZWVU4NWsxR05EdjF1T3dFYVJKcW9ab3JwQjF3eWhVYmltcG1qV1dMY2VsNFg0SkNZYk9tem04TU9DSW5NUUdmQk5uQ3E5dWhvZTRzSlI1QVVVcGJvMzZZRXRITTU2ckhYa2FaOWVQNk0xMFFCUmVBZTFWa1JqdG9VSkZJMzFMdWxMYXllOHl6OHdUTGdpZXpaME9ldmx6UE5yYmtTR2lMejFjZksyclVGZVdkbmhIMy81WmRVWlpEcTNYanZualloRVZHcGRvUFh1ZDl4MDMveGMvWThsYVZMUDhneHhEdTg5NzNubkFZN0UyK1RkZnJtV3hrSGhLbWxHUmZzb0JlWDZwekt2bDNKblk3bVhvK3A3TkVLRjd5Zjgva3Q5NWc0YkxxMi9TS0NiekU0dWNlTEVTZTY1ODE1ZVAzMkpiMy9yUlhiVzI2VDlsR0UvSngwVURQc1p3MzVPTXJTa1EwdXZtOVByRktSOVM5S3pKSDJMNUI2S2NzV0JydlkrKzBxM1ZUbVBFc1FCWWFnSkFsUFpFa2s1bG1zZCtiREE1WTZpc09SNXdXQ1FzcjJlTUJnV1JJMlE1a1NkMWxTRDhla2FyZWthamVtWXNZVVc0d3Zqd2N4MDg5QlV2Ym04c3Q2OXlOV05YZFZTb3BJQldEdzJ4YzBQSHVUSzJlM3JBTG1XemszN3BuaDF0YTJ5d2ludlJjdlY5Y29qY0l6WDYrSFU0Kzg5OVluQXFIdlRKTlBPT214aE9YeWd4ZnZ2Q3REOW5YTDRTQVNIWFBXVTh1WE5xRlM1UFV1Wk1wcDRYNW9ncU1vaVZ5aHRldlpQQmx4K3ZjdVh2NzNENUp4bmVlczVYcjkwRnVVaWJqaDJFKzk0NkdIRzZ1TnNYTmxtWTduRDl0bzJuYzBlM2UwaDdjMEJ2ZTBCM1haQ3Y1T1E5RElHdmF3MGQ5dEs2VzRrdE5jR2RGWUhkRGFHOUxhSEpQME1hMHZYRTV0N2lzeVM5RE9TZmthL25iQzkwYU83UFdEWVNjbUdPYjFlbjI0L29kdE42RzRYcEVNaHJJY2N2bldSbzNmc1krYlFPR01MRGNhbTZ0VEdRb0pRMFpxS21kNC8zcHFkSGx0cWJ3K2Y2K3drUGZidWhsU0lFcWkxWXFiM3RZakhhdXlzOUs0RDVGbzVXaW1HdVZXK2xMRHZwbFJBUXlzMWJyU2VYWndmUDNidlhZYytnY2hpbm1kQWxVWVZBeDQ4bklNdDdYQzhMNEZnQW9PdkZ0bm9hdTREcW1VODFSSTNyUlRWVk91bzZZTFNpcHYyMS9qNlUxdjg3cGRYbUJnUGFVd05lZlgxNzdDMTJXYmYvRkZ1di9WMmJqcCtncm1KS1NJaWxOV2t3NXhzV05Eclp2UTdHY1Aya0g1N1FIZG53S0F6M1BOSzZPME02TzhNNlcwTzZHd1A2RzhQNkczMjZXNzEyVm5yc0wzV29iM1pZMmV6UjJlblI3OC9KRTB5MGpSam1HWU1VMHVhQ0RZQkUycU9QM0NBTzk5MUEvTUhtOFN0QUJOcmRGQXljeGFGS3h4T1F6aWhKNmRtYXEyZDllRXIvVzZXVkZlaTlPSlZTQkFZak5Hc3ZycEtVY2gxZ0Z3ckozZGVlUytqWXJ3R05JelM0NHRUWTNjdVRyWCsyRXl0OXFsRCs2Y2VYem80ZmRKN0czaFh6blhjZEhLR2MrZTNXQnh6TEUxSDVMbEhCd0ZCRk9Lck1WZWxLbkJVeGdoS3dJamF0Y3NSeWprUXBjRG9jbXRvTGRMY2Ziekp5K2Q2L1A0M3JxQ1Y0Y1JOYzJ4MHp2SDFwNTRnU1FxT0hEN0owdElTKzJibVdKaVk1dERzUHBhbTU1a2ZuMmFpUGthb0lvcGNVV1NlSk1uSWtwd3N6WEhXNG0yWkdscFh6YXRMYWM0Z3p1T2NLMDBibk1OVnZzT3FTc0dzOXhTRlVHVGdraExrczhjbXVlUHg0OHdkYUtCTjZXYXZmTmtQOFFLaU5Db3c1Y3lMMW1aaU1qNCt0OUFjMzF3WnZEcm81ZW5lU0pLblZ2TE1NYms0VG5kcmVCMGcxOEk1UER2RjlpQlJTcWxScjZNZUIyYnE1TkxNSDV0b1JIK2pXWS9lRlVmbTJJRkQwL016QzYzQTJnS1BaMmF5enFmZU04a05zMFBPWFVvNXVpOEFyNGhhTWQ1RGtSUjRXMUs2WlEraFhLbWtLd1pMZVZXeFFWTFJxK3JxTGtTbG1Ca0x1TzF3bmJOWE1yNzZ6U3VzcjNRNWZIUWZ6UWw0N3VWbldOdllaSEo4Z1RDcW96VFVveHJqalFZTGt6TWNuRnZnNk9KK2ppL3Q1OERjUExQalV6VGlGb2pCRlo2aXNMaEt2dTY4cnpyZzVRbzNWYzE5aUhxais2RnpnclVlbTRHdGxqQ2JXSFBIdXc5eDhzNEZ3a0FqSW9TQnhtaFZlZ0VqRk5aalRGblRpQk1FTWEySitJYVorVVpyYzNudzhyQ2ZaK3lLR1pFaXM2SVZwR25CMUw0V2FUKy9EcEEveW1PZHgzbXZLZWZMWTZDK09EbDIyMWdjL1dVdEhOTmFxV0ZobVZzYVYxTlRUV3hSSUFyZS84QWtON1kybWRJWll3Mk5xZVRpempxc2RiaWlXbEFqNEJGTVVONXhDb1VheVpCMCtYZG8wRnJ2dHFsSG0zNm54d3ozM2pqRzVmV0NKNTliNTlMckc4ek1Uckt3T01iS3hubGV2M3lXUVpLVDU0NWhNc1NMSXdnTm9RbW9SUkhOZW9QcGlYRVdaK2M0TkwrUEkvc1dtWnVjcGg0MTZQY3owaXhENmRJMGJqU3hLeUs3dExUM0pjQUxWKzZvZHpubExzTktuOXVjcW5Ibll3ZVptVzhnSGlKdE1FcFJpOHBJYUpSbVpGdnNTOCtJc3ZaQ3pOaFlkR3hzc3FhdW5HdS9YT1J1MStFZHdlZVpvekVXUzNkenlBZi8zTDJjZldyNU9rRCtLTTdNUkl2dUlCbnRoUW1CaHRHNmRYQjY3S09CMFI4VXdUZ3JhcjA3VVBzT3pEQTNONGJTRVFzemRkNTFza09ZOXJDNW9tRkF1WExYaGkwRWpHRmt2WWtxdStmYTZITGZud05WRFRPNWl0NVNxTXJoVUtFcXEzTVRHRVJnb21GNDlOWnhCaWw4L2R0YnZQVGNGVVNFNlprV2hmUzVjUGtWbHRldjRKd21HU1QwZWp0a1JjSXd5OGp6dkRLR2M0Z1hnakNnMWF3VEJSSGI3WVQxelI3ZU9yUzZ1alMySEVJczB6N25ITTZYdXhadERqYXY2cVdLZjVyYTMrTG92ZnZSWVZET3NSQ1dSbmZWbnZjNERJaUM4bkxFa1NvZFVDb3FXSkN3MlFoUDFacHg1OUxaN1RNaXU3dm5xNjBsY09TT0JlWU9UWERteWVzQStTTTU5VGdpeVhLbDFLN09xbEdQd3VtRnFkWVBoMkZ3QzBxUldjdE9rck4vYVlySnlRYU4xaGczN0RPY211bVZwbXFwTDVmSlZCMXhqOExFUVVuTFNFbFJxV3BKam93MnlWWTdBLzJldGRkS0tYUzV0THgwT294QzRucElrVHZHNmdGM0htdVFGb3JURndlY2UzV1Q1WXR0eE1Qa2RCMVJHWjNoTm9Na1lkQWZNaHdNS1Z4QzdsTjJlaDFXTnRhNXNyN0dkcWREdTlmbmhUUG5PWDlsbFRTektDQ0tLc0pBbFFOUXpwY0xkcHdEVjVUQXNHbTVGMlJVVnV0QWNlVDJlUlp2bU1JRVphUlF1bm9nUUxuRUIwOHRnSHFraUVPRE1vb3dLQWU4dEZJWVExaXJoNGVzNTdXTnk5MVY5c3lPZU9mRkZaNmo5KzdqOU5ldlhBZklIOFZwMUNKeWEwY09KVEhRYU5haXhhbG03Y2UwMFF2T2UvcEpUaWZKaUNPRk1SN3ZFNWFYMnh4ZmltajRGS21jQzhVTDFpdjg2Q1lyUlZmVlFodXE2RkUrRzNWVmsxUmtGb0ZSdXp0R25DdFJveFZFWTNWODRiQ0ZJdzdnb2J1bWVIWFpjZWJTZ0Y1M3lNcUZObHRyQTJxdG1OWlVoSTh5RWpVa1NSUHlwQ2cxV0FwTWFBaENnL1dPelU2SDE1Zlg2U2NwU2tHOUJrRllVczFlS0QxN1hRa09XNVF2bDRFVVZ3dVNvR1k0Y3ZjQ2R6NThnTlo0RENZQTc0a0RYZlpYdkNjMm1yb0JKNTU2VkRZeTR3anFzVUtaYWk3ZUMwR2d4dU5HdU5qWnlaN3Y3NlNkUFNDUmJGakkyVzh1eTlLSkdYcGJ5WFdBL0dHZlZqMG15WXFSYldnZGFNeU5OMC9VVFBBajF0cW1FdWdPYzdwSml0aVM1cHlmYWZEc1MxMjJ0Z1k4ZW5NZGR2ZVRlendLVncwdmFWTlJNMEpsSkQyS0ZvTFIxUjVrU3JaSDZXcXRXYlZ5V1ZFcWdGVVlZbG90OHAwQnRYckFLK3M1Ly93TFczem1zWDBzTkNPMmVqbGJPME5XTDNWSkJobU5zUnBqTTNYaTZSQnBDSm5MNkNjcHZkNlFUcmZQZHIvUDZ0WU9UaGMweHlLaUNJTFE3OTZSenBjMHRMTlFWQ21WejhwMWE3czNRR3c0OFk2RDNQNitvOHd1Tmdnamd4S0lsTUtVNVJTaExwRmt0RERSTU5SalJSd3FhZ0VFUnBpb0diUVdqQUVRaGRiN2dqZ0tOeTczbmk4eXU5dHBCeVJ1Uk5LWWlLOEQ1SStFd1pxZlliUFQxd0toS2dFU0wwMlB2N05aQ3grM1RveFdxSjFCd2lBck84anRic1lQdmZjZ2Q5NDZ4VC81M0dzY1BERE9pYVVHVWkzNTh5SjRYUmJhUVJBUUdJMzRja2xuRUpyZFBCOWRkZGNCWTlUVkFwblIwcHJxbnpnZ0NQQnBSdEEwL0xmLzJ5cExNelYrNHRFWjl0VWlGc2RxaEFwNnc1VHRyUklvMjJ0OWJPRUk2NGJtWEV4akxpS2VNMFJUbXJBSjQ5TXhrOU1OWENXVnNWSTJMSjFjQllkTnE2Z3h1azFINUpwVzNQRGdFbmUrN3dpdHNhajhIQ2VFQ0pFUjRrQm8xSVJXcmR6YzY3elFpQ3EzU0ExaFVHcTQ2Z0dJS2szeXdxQ0twOW9jOHVpMWpZdWQxMFFxMVMrNFNyTWxSZmJXR0xCNlcybXhuSE9qNlZFdFlMUldZVDAwaTFwakFnM1dldEpxOHEyd01ETWU4OGhORTl4Lzd3SVh6MjN5SzE5bzg5Q3RNN1FrQnkwbzV6QWV4Q2lpS0VCVmQ1N3lWMGRvbGFwU0xSR00wYnRyenZ5STcvRmxUOFFpdUNSSDhqWnhxUGlYWCszeDh1c0ZmK3RINTNDSnBkWFUzTERZSUVBUmU4LzV0UjZESWlkWnpibXcwdVgxVUJPUDFXaE0xR2xNeEhqcjZlMGtKTU9jTExNVWVZRWd1emFqSTNCSXhUYnRQU09kMU9UK0pyZTk4d0NUelJBcUtqZUtJTktPOFlaQkcyakdRajJDWHFicHAwSS9kd2pRak12MWJ2V2cvRGxEby9BR2ducTVveVNma2ZIRHh5ZC9vck0yKzhxRmx6ZWVvWlRHRjk2SkczWXp4VnZFNC9mdGxXTFZJdFVkcHBySzQ2b1dSUk1IWjhmZjc4VGZpcUFLNTlWbVA4R0xSeFI4NEYzNytha1BUaERtS1hlZG11QmJ6Mjl5OWxLZkIyNmR4T2JsRHZUQW1GM0hkSnpnTTQvTlhkbU1xeFp4VXJGV0FoV2pVN2FTeTdtUkVrVEdhSnlVeGdnclhlSHYvZm82bjNwc2dWdjNSZVJWQTdKdzdLNkI3ZzR5aXN4UjAyVW9qS3dnZzRKMGMwaDNwVWU2MmNkMVUwZ0xWTzVJTThneWR0a3BQNkp2UjZSQjlRSXcybEJyUnB4NCtBRDdicGpDZVl0UmpsWk5VYXZCV0ZNejF0U29BRkl2WkZMV1hWa2htS0NzY2J5RkpQZFlXNlp5RGtWV1VDNFlGVVdXZVd6R3VIV1NiU3ozbm5XRnI3b3R1ejJTNnhIa0QvdHM5UWRJRlQwb2labVdob05lUkN0QlJoMW5BYUlvNEpHN1ptaWFnbVF3WkZ3Ri9NTEhGL2h2L3VVNm4zdXF5NGZ2YWxBTUM0TFFvYjFDa25MNGlLcSs4SzVzRkk1dXdISnhabG5ZYTZVd1d2QlNQcW05QndLRmlDZXVCZnpxNzI1d2FEYmlvU01CYVZJUVJ1V2QwMnhwcG91QU5LK3pNeHdudFcwNnZhSzA1TkhsRDFXcmFoMEVBblBWdXFjbXNKWkJ2anMvKzhacm80MG1yZ2ZNVEkzejhZOThsUGUrN3pGbURrNHg4SDI2dlRXeVpBdW50N0RCRHBsckV3U1dwaklNQ2tPZ3dGYnIyL3BEWDduR2wyc2FRbDJTRktKS2UxVk1LZld2MXdPQ01BK25aaG8vdFAvbzlHK2ZlM0d0U3ptQm1DdUZHNStPNWVaNzUvbkc3MXk2RHBBL3JETkk4OTBVQzlCanRYQlNpZDlIV2F5cTNGRmFlUW9jT3p6T0kzZE1ZWWQ5eEJaa3RtQmZTL1B6SDVqaVY3NDZaSFkyNXBFak1ma2dKekNsVURFdlBCNWYxUnV5Uyt2cVNzem9xbmExbHpLYWFGMnBmMVc1dGpuVThGcmI4TklseDEvOHhCd0dLVTJxTmRRaXNKSFFyQ21tV2dHSDUxdmsxdkdhNnpCTUhGN0swZGRxdTNPWlJrbEo2U29GMDJGcE1icVNRMVF6MUpzaCsvYTNtRjZvVWFzRnpNdzNtSnF2Yy9qZ0V2ZmRkWlNEK3lZNU1uc3ZZVkREcFFuaUhVaytJQ2wyMkI1ZVppZDltZFMrektEWUlTczBnd3hhTlVWa0xHdWJCYm1VdGNoNFhhRzBrT1VXNXhTNWFKUUlVYVNwTlFPQzBFeU9UOWR2Qjc1VE1Zc1pLS3VVRXEyVlhJOGdmMGpub1ZNSCtlYkxsMER0THR6VUMrUE5mVVpKUzFVRDJJVjNlQ25YUEQ5dzZ6VEhwelI1eitKOStWVE1jc2ZCY2Mxbkh4M243MzkrbmZwSDVybDlVcE1OSFVvN3JDMmYyRnBWTTkwanBrcXoyMlduaWlUaUlUUVZnNlZBZTQrSkRmLzY5OVo1K001cEZxZEN1dTJjUmoxQUcwV1JPdW94NUhVWXl3MExOc0s1TWNUQnhiVXVnOFR1enBBTDRMVENGb0pTRFlJd3hCWURicjlubWtkUFRISGd4aWtXbG1yTXpzYkVOYlBMckdWV3lJdUNWMWFlNEpXVmIzTC9EVHZjZGVoZENCclJpbnB0ak1qVW1henR4N3JieVB3SzI4bXpMUGVlWnRPMEtRcU5WeUZXb0RjUWxDKzM1NXBBMDJ5VXlvTis0aGhrZ3ZLYVdpT1FNTlpCb3huZUhqZWl5V3lZWjBBa0lyYTduY216VDZ6NElOUlNqaXBmQjhoLzFLT1VLdk44NzBjUkpLaUhaaitpV29xUzE4cDlXYUF2TG96eG94ODhoTWtUMHN5WDlqb2VuQ3ZwMkVOTng1OTR4d1JmZkxKTjg4RUpEamZMcHBnV1I1RzZzdWVoeWwwYTVleUgycDNiSHBrY0ZMN3N2Q3NsaUN1N3o1ZXpnTmMzSFgvaHNTYTlib0lXS1BwRnlYOHFCVXFJSXhocmxFb1o1MnZsbTJRVXk1dDl1djJzTExwVitiMGVQWEdTei96VVR6RjNZSjZuWC82SDNQRGdCUE96TlFMbEVPL3dWZjhqdHlVcFVUakI1UTRsbXR3VlBIZit0ems0ZllLRnFSdkpreDdPSnFCaWlrcjZYNHVQY0hqaUJpYmlXM2h4K1Yrd0pldW9RbWpVRkxWUTA5MHFLSWFlVUN0VTlXZU4yTk5Mb2QzM2hFMmxtaE1oWVMyOGRYWmY2L2lWYzl1N2MremVDOE5CWWF0MTBuS3RGdTF2bXlJOUxTekR0TmgxU2xSS05ZOU90OTRycUFjS1VONExtNzJFeERvKytiR2IrZW1QTFdDMzI3aWlWT2w2cjNDVnNXYVd3WFFqWUhJaTVuZWVHM0JzSVNSd1VoWGtnb2xDTUthTUdvNDl1cWZ5U1kwQzY4QTVqVFpsMzZUVkN2aFgzK3hnUlBIQThRYkR4Q0lDUmltVVVWZy91bE5VdGM2NUJIMmdOTFVveEJoTmJoMVphakZCaS9kLzdCUDgwbi81dDNuUGh6L0V5ZHR1WitGWW0zcjRPbzFBeXRSdDVPZnI5TzRxNk14Nk1pc1VEa1EwdzZ4TFhKdmk4TUxkR0cwSTR6R0NxSTZnTUZxampjSzVnb2dwMHMwYS9XU0ZUUGRJczlMd09xb1pyQzFyc1Zxc0NReEVnYUlaSzJweCthUm90QUxpU0VWRjdpOWRPcnR6aHFzbDIvY0RoYm9Pa1A5SUo4a0s5cGd4MUNkYjlhbGpzK01mc2M3Zm1PY2ViejJyM1FGemN5MytzLy9rRm80Myt5UzlGSEVlc1ZJeFAxV1hYQlI1SVV6WEZLMVk4K3ZmMk9ISVlvMVdGT0FLd1FrRW9TR3FoYnMzczZBUVgwNForc3JFd2JzeTdZb0MyUElCLy9Eelc3em41anJqZFlPZ0NjSUFnakpWY2dLaTkzZ2M3ZzVsbGJMNUtBb3dDTE9MQi9tSlAvOVgrWk8vK0JjNGN1SW9SZ3RhR1NJMXpuRDRERTRTY3FmSUxHUU9VaXRrZVdsaFdsUWJidFhJOTdjTVdweFllb2pBeEx0cG90YW1sUFhyb0hMdGhWbzR3V0MxUUdyclNKQmh0TVpFbXFnV2tEbE5VakZZVVZCS2NXcWhVSXNVSmpJMHArSndmcWsyMnh3TDI1dXJ3KzBzY1NON1lIV3QzMWR2RzRCVU5LdXVDc0g2VkxNK3ZUUmUvNkhjMmlQV0t4ekNXcnZQQno1NG5KLzU2QnpGeW5ycFJGS1U4eE41b2JDakJsdlo0YUFvaEgyVEVhclY0TGVlN2JKL01tQ3FGWlQxU3VySVV3ZGFFMFFHRStncWdwVDZMTzlsbCtVS0FzWC84cnZyZFB1ZVR6ODJpNlpzcUFIa3FjTlh3MFJ1ajR4K1YvUm9ORHJRQkFxTzNIUUhmK3dYL2pNZSs4aEhxZGMwVXVTbC9FVkJGRXl4TTFoanMzZVdRYWJwWmtJdkxSZUw1bFpoYllENFdxbklGWS9SVjcyeERpM2VUN014eTJpeXZpUWRSdEthOHVzSHRSckZRT09LUG5waUV3TEZlTjFnak1FcmcwZVhhVzZGT2l0bERSWlVINXNvbU5sL3VIWG5IZmZQSHB1ZHJ4WG5YdTF1ZUNlYXF4YkI2dnRGa25velptWmhuRUUzdlE2UWY5OXorK0Y1MWpyRDBaNlBDS2pQampWbTk0M1ZQNXdXZnNrSG1rSTh2YXpneHo5MWxIZmRQY1ZncTArUkZsaGJQbFU5dW15dWpTUWtVaGFmZWVxNFlhbUphdFQ0MTkvWTROaStHdFBOQUd0SEN0bEtXbTQ5ZWViM3lNRExhTktvR2RhN0JmL3czMjd5SjM1b1AwdVRBZG1nUUp5VUFITmxPamJhTWFnQXJRRlRLb0hMdm9YaTBLMlA4TTRmKzRzY09Ya0tYSW9TaDFJR0ZUWVFGRm84Vy8xdFhsdC9qalFQR0tTYUlndkowaGlidGpCdW1zbjZmcUs2WjJoN3BZdDhsZU1jbkx1TGlkbzhJcnZ0VFlvOEszVzQ0aEJYeW4xTkdMRitzVTAvdkVJWWw3bFZLVkpVUkdHSjdOUkNISXk2N09YWENvS1NGcFpBTityanRSTkhqbzNkZStqNHVGbTVORmpwZC9LaWV0L1VtOEFoVUVicW1mbHgyanVEUDVJcTVXMEJrSVhKSnR1OVZQczlNeUJUelhoK3JsSDdjT2I4dkRXS05DOFlud3I1eGM4Y1lyRUpKbzVJK3lrMkxTWGdoVmRsNTdtU2FQaXFDKzQ5SlAyTW8zTVJSNDVOOGkrZTJLQVdLZzR0TkVwQVZUVk02WWxWZHRXZDdBNm1NelllOHMyTGxvdHJLWjk1WkpyT2RvWXZoRHdiOVU0cU1PbFNObzhySXhDNmJPUm9JeXdjdlplN1B2eHpUTXp1UTV3dGIrU29WWW9LQmNUbG9Bd3JxeXU4dXZJaXZhRmhxNjBaOUVLOHI3NXcyTVBxRFlaRnR3UzJWTjErRlhMRDBpTk1OdVp3MlFCVWFSRG5yQzBicENpVU50Z3NSU3RQcnoza3ViT1hXRTgzbVo4TXkxbVJpcDB3U3VPbExOYW5tNVNnb1JSdWpwaTBYZ0VGcGprMVY3dmoyS25wZy9WV25LeGQ2bmNySmt0L3YvZDNPTWhVWVIwUG5Uaks1YTMyZFJicjMvV1VPd0ZWMVlVdXczWTlDcHBLMDdKYXhCaXRDZ2QzSG05eFpFb1liUGN3VVlBeEJ2eG9zNUpVKzVYSy9zYXVBVVBGVFBXMkJoeVlhdkQrMnliNEYxOWFKU0hnb1dOTmJGR3VXSE91SEU0cTZWOVZpYStFUVNaODRabHRibDZNeUxwNTJXR1hVcHFDTGYrdFNLbXUxVnFxVFZMbC9MZUpMQk1IVG5IOEhUOUpyVFZkUmpZVG9reFUxajNPby9ENG9zQzdETlhYcks0RWJPWGJMRXdGakUxcG1nMVBIRlFkZndGZmpJYW95blF5Y3dWSjFpOGpsd213YVlMZ3NYazV6bXZDQ0swTk9xemh2VERXbW1SYWx2akNTeGZZNlE2NSsyU051Y21BdGI1aktCQUVtdHdydXFsaHZPN0x1UkZ0Z0hMaWNhYWgyQmdJZldkcWpZV3hEOXozZ2ZvZFIyNmQrZEszZnVmQ1AzdjV5YlhUMVQwWkFBbVEyOEpaNTd4dmhFWTU1K1I2QlBuM09QdW14OW5zRHBRVEdhMXZycDNhUDN2M2RDUDZvVjZTeDZLVlNuTEx4eDhaNCs0bFJUck1RVFJaVXVBeVc5cUtpcjdLUkZWU2Rha204aENGVVpBTkMyWnFpcU9MTlQ3M3pTMFM2N241NkRoRjduYW45UlJYUHo4TUZPdlc4TSsvc000UDNUdEZYSm5NaVNvdnZJaENLY0VidFF0S2NZckFhRXdnTk1ibnVlR2RQME56NmhES1JLaWdoZ29pbEtxZXpHaHNPaURwZGVoMCtrU05LYzZ1ZlpNREI0ZnNudzlvTlJSeE5ld1VHVVdreXlFdm9XU1lDa3BieE9Qejl6RFhYTUxhSEhGRlZaaHI4aVRCMlJ5YnBYanJVQ29nUzFMV0xsMWcwN2RaNlE3WTZKVXA2bFE5Wkt4bWlBTk43aUYzaWtGV3VsQkdwcXdSclMrLzY4aUFRNnZVZ3RhMDZtUHh6Wk1ISjI2YzJkZklPdXZEbldSUUZIdjFBRXFRV2hUSy91bEpMbTd1WEFmSXYrdFpuQnBqb3pQUTVScG5WUU5xeHhlbUhocVBndmYwMDF3N3JaVUpIVC8ybmlsbTY2VnNBbVVRVWJoY3F0cERWVUNwRXVHS2ljS3JYYld1VU80aEg2OXJqczJHL041ekhUcVo1NGJGQm1LbEFsZlpNMUZLVVk4MXYvZmRJU3ZyQXo1dzUzUWxHcFJkUnhTaktZZVlLcmJMaXNJRTFZaXJFNEpvbkgzM2ZCSVRqVldoTEN4am5TdEtnKzJrVDdmZHhxdUE4Ym1EOVBvRE52dGZaSEs2WEJvYW0xRlRzeHplS2tTd0tMeldXQ2sxVTZHSk9EWC9JT1BSTlBsd1FCRFgwZHFVN3ZhaTBRcHNVWkFuUTV5MUZGbEdiNmZOVVBWb0p6c29IYkRldGJTN2x0aG9ac2FqVXV5ak5ZVXZGd2o5LzluN3J5RExzenUvRC93Yzh6ZlhwcTNNOGxWZDFkNmcwUmg0ak1FTWg5VFFEWmRreUFRVmpGMXBTVzNFMnRqWW9LZ0hCaDhZZXBFZU54VDdRR2xsZGtWUjFHb3BSOHFNSXdmQXdCQVlBTjFvZ3pibFhmcTg5dStPMjRmenZ6ZXpDNDJad1hCbWhXNzFqY2pvcXVxcW0zbnZQYi96YzErVEtJSFdFWUt6Z1Arbklyb0NsemFnUlpCWnFzOXZuQnQ4OXZMMTFhMnFNUGNPZCtZTG5hQkl1UEloRkhYRHZEN2h0RzhPdWx6YlhtZHZNdis0eFBvOVI3ekdSaVJyQ0tLOW5LVWtyQW9ScFBBT25PVHEyUzduQnREVUZ1Y0ZwaW5SZVlvVk1tcGYrWmFhYXNOeWVvTm9PZVplTExGV0FONEVObnFhdi9LbERmNytONDU0dEYveHIzNTVDNm9HYStPWU5Fa0ZKczM1emQ5OXlOUGJPYWtTTkcxcHN4am1MaXcvRnIvV1dwS2tBdHVxdnMzQ2xFZmpkM21pKzBXY05RaHZvdTJDTVZTekdjWVl1bXRiNUwwVnBOUllXNklUUXorTnlpdU5qWFcvUlZDYVFPMWpZRGpmYmxLbHA1dXMwQmM5VEZsUnpZc1c2aTl3eG1DTVEwclJVbzlkcEJhYnFENjVucXhFK0g3dElKTWNqQnpUb3VCZ1lyaXdsYUV6UlpvcHFncWFWdVhGQm9mUUVpMGpFbUJGQlFJQjA4QkFlUm9oVnBOei9iLzgrVDl6L2Ftc2svMTdyMy9qL2xkQ2lKQkw2ejM3MDdtVllpbU9FYzZ0RGJtMHNjTHVhRW8vUzdoMU1QNDRnM3pRWTF6VXVCT2Y4NjZTc3ZmOGhZMWZ5Slg0NUdoYUN1KzlLSXhBZW5qeWJJcHhzU0d2UzdlRWhUc1hhM0xqNCtFNkdhbTBpdTV0YmVSRFBON1dRVWNKWHI0MjRNYVI0ZFZiYzU3Y3pvaEd0b0kwVGZuNkhjdXZmV2VmLzgydm5HT2xJMmxNV0dLb2xuMTgyd2pMVkpMRW5odmpvSk1wamphN3lNMkxYRng3QVlTTWtqNUFOUzlCS3ZvYjIrVGR6ckxrS3FzcGsvcXJwSWtoQk1oYXFNdWtqUDQrZUVsVkMyb2pxR3ZCYk80WnVyTThrVDVKTVoxaHFwcGlQR1UrbVRBZGoybkttbW8yd3hyRGJEeU91bGpXOCtqdVhYcXJQZDQ2dW9jTkllNUVSQ3dacTlwemVHd29La2VhU0pKTWNlS2ZDN043bHZuZHdQaFJnNVN3c3BxUUtvbEhrQ25RQk5IVW5ITk9yby8yeXU4VXMvcjBmRmNzU01CQ0NIazBLOWtaVFlXV2dvdnJBL1ltQlp2RExwYzJWam1ZRmg5bmtHV1RidDNwUFloUVNpWlpvbnBDUkJWTVg5YzAxdk9QdngxWUgyaSsrR3plSHN4NDhFT2JQWWpUMVZqR0xHUkdPZms5dEdOZ0VUY0dqUk1JYS9uVmx3Yjh4ZzluZk9YZGdqLzVmQzh5OEhUQ1YzLzNQaXVwNEV3bW1SeGFsRzZ6Ull1dkVMWmQybW1CWGhDdGZLRFQwVmdDb3lSajNaVkxvNTdnWVh5NFQ5THAwbHZmUkNYNVlndTAxTkVkajJFamMzU1VvbXdVazBMampNUTJVSm5BcERCVXRhYzJnY3A0WHRxK3lNNjlCeWlkME9uMWtDb09MOHJaSEtVMEVKQmE0eHBMT1prU2hFVHJIT3ZxMkJ3RWtNaEl0eFd4TEsxZDRORk96ZkhJY0dZclo3aWFVaHhhOWw4NzRzSDN4aVErcDl2Tk9WS08vRXJDNExrY3RacmljWFNIaUV1cFlEN09uMTdkN2o1NXNETWV0K2MwSWFLQkRXQkRDTTU2N3labDdaVVFZWDlXaEZUTDBFazE5NDdHSDJlUUR3QmpMWGpvZVM5TE5sNit2UFVYQmY3SzhXUk9ZK0tLM0FiQnU3dWVYaTY1dUpFUUZqM0hNa01zU3F0Mm10VkNOQlpUZWIrWXpyZEJ0RFNTYlR6UFh1Z3kzT3p5ajc1OXpOWjZodGVhLy9CL3VNK1hYMXpobWEwTVl5TUVKSlpUQXRmVzR6cVZwRHFPUWFXVXBLbEVoc0RZSzBhYlE5Sk93dm4rVXlpUk16aytwaWdyVnMrZUo4bjZMQ2NKT0JBQmdlYTl1OS9CcVNuemFzRFJwTU5vS3BuUEpaT3BveWdkODhMUzFGRVpKUXNacjV6OU5OcHJuSzFSU2xPWEpjRjdtcXBrT2hwVGxYTzhzMWhyRVNIdzFodHYwZFFsS2xQY21ONUdKb3R4dE1BQ0prU0JpSTZFdXZGTUo0YnBvV0gvdXpPbWJ6YjRPbEJXSlhWZElaekVId3YyYjgxUkhlaHZkSEJ6eUgxZ2JhaHlMYVhadVRPN1g1WjJBVXRaZUVycVU3c1Q0VTlFc29Wdk05cXdsek92bW84ekNDZFRvMFZwTDFJdGN5WFlkRWdTclVRa05qbjh2T0RZZWY2L1g0dVlsTTg5blVlZVE0aGd3ZUJQMVZiK1pHMFZUdE5uMnlCeExWTVE0aDVnUEdvWWRqVS9jMzNBZDNZOU4zOTNoNnJ4ZlA2Rk5heU4yOGZROGtOb00xQ2F5YmI1ajhzMkllUDIzcFNXYWkzREs4bWsybVYzOUI0YlNqQ1pUdGw2NGluU3ZOdVM0T01DTHpnWHhlYTZLV3ZES3p5Y0hPTnR6bmhhTXA5WEdHTXd4dUtsb0lhb3hCZ2M1d2JuR1NZRFVCTG5NcXl4V0dNb1puT2tFcFRGTExwbkFYVlpzYjk3eUhnMjVva3JGN2szZVlnelBqYmY3ZlpkQzJnUUdBSmVTSUx6VkxXbkNCNTFYdER2ZGVqdmRpaVBhcXF5WWp5WjBPMTJHY2crNDI4VXpOK3EyTzUyMkowME9PSDBzTlMvK3VYbkxsMHZDL3RPNDl5Ymg3UDZuWGNmSHQ2YWx2V0VxQ3BmdDFtbEJvenp3VTNMeHFkYTBjblM4SEVHYVIvOVRpYU1YVHJXNW11OS9NSlQyeXYvb3ZQMEsrTXcxc2FEN1FPK2FUQWk0ZmFCbzkrUm5GM1Y3WWoxRkVnUUNENDJzNkhGei90MmdSamFLQW1uLzI1N3Z6V05aNnV2dUhwdGhiLzNQejVnT3FuNTVaZlg2RW1vbTBBUWNWd3MyeXlsVlN5dmtoYS9WWmFlK2N5QWg4bGFUclhTd1lXR2QzZHU4K2orbUxQYlY5bStjQW04YS9zT1dIQnNnM2U0c21BOEd2UGE3VGVabHpYelNVbFRHUnBqQ1ZLUXBEbVpUaERXNFozanFjM25PTmU5VEYyYm1DRjlkUFVOd1NPa1JLY3BTbW04czl4ODd3YnYzcmpCRTljdWtTY1pyKzI4dzE1NVRGZko5b0tLZnUxU1FaSUlCQW9sSk5ZNGpQRVlHMmc2QXIwdEdmWlRlcTVMbnFWTUpoTnE1K2pvbk5sK3pkN09GS3ltbVlNdGcrN2syYms4VWM4UHU5bm5MbTZ1L3NLMXN5dWY2U1ZxUlFoWnpPcW1DZUY5anRZdDhUTUVId0w5UEtGcTdQdndLNnI5OHY5TENoQWZFTUg3cGRUbzVxQno2ZnJXeXAvMWlGNWpQUzU0RUZHRVFVaUpFSUhLQ0g3NHNHRjdQZUg4aHNZc3hyU2NOTkcrRFFSYU9tM3NFY1J5TEJ1V2dJZ1RyNytpZEt4bzJKODdSS0xvOXhRNkVTUnRZTGdRRUNIeXZ4ZEFKQ25qNXp1Zm1xaEVJbUM4MmNkMFV5cnJlZWZCSVVVVitQS25mNGxPMW10eFd1M1A1UzJ1YVNnbTR5aTJiUUp2M0h1VGcrSTRDc3lwZ0VnbFNpc0VzZEczb1VicmpCYzJYcUVydWkzTE10QlVCYzQ1MGl5UGtxVSswTlFWMWhyZWZlOG0vVUdIODl0YjdJLzIrYzZqdDZtRkpjK1NpRjRtaXNoRlhhN29uWUwzQ09OYlIzVm9Day9SZU9vK3BDYlFEeDNTTkdGdi94QVFEQWRkaklQajJSeEJRQ3RObm1Vb3JUSFdKZDZIb1VCYzBVSjhicjNmK1puejY0T3RWS3ZwMGF3c0h0dkNCMnVkcUl3N0hSdENuQ296Z2hCYzNscmxsZXZudWIxNy9ORU9rQkNDREtkVTNMZUh2V3ZYdDFmL3RCQjBxOGFCRUxFa2tqS0NDWVBIVzRjVGlqc0hsclZod3RaUVJyaElPTkhZWFFiTWdpdXlDSVcyZndndGMzQVJQSXRzMHUwb2JoNDJmT25aRlo3YnpxaFZ3bzBqaS9DT3pXR0tYVW9HQ1pKVUVYeGdQalB0MkRkZ2xPUm9xMC9JRTJhVjVkN0RrZ3NyVC9MbFQvNTgvSUJWQ3M1RUZ1QmtURk1VZU9zd1RVT3FjbmFPOTdsOStCNVN0ZnBZUG1DZHBXa2FqRzJvaldXWWJ2RE15blA0eGxQTVp4aFR4YjZBcU9WbFRJTnNzOE9OOTI0Umd1WGkrUzBTbmJCZmpyZzV2UitiZEMxYXdZZjRlbVFRWkVJU1d6ZEpraWhVaXpGenp0TlVqcUx4RVhweVlBa2k3bHhHa3dsNWx0SEpNcXJHTWpIektML1VPSVFJUWdSRUlFU2pIK2NWUG14cktUKzUxc3VmeTFKOXNEOHA5azZkNStYZEk0U1FVZ3FobEpZSUlRSkNDQ25aWGgrdzJzdjRaLy9CLzQxLzkrLzlCdmJITE9rL0VnSFNyaTBXU3U2ZDdaWHVVeGRYZTMvS09KOVh4aTJoSFZKS2hGU0VFTERHNG1wTDVSVHZQbXdZNUlydHR0eGFITjVZNXkvVVNVNldpSnhxMWdsaUtlMGpSRUFvTUFMKzJidFRydll6S0IxZDZWa2RKcnl6WDNIdm9LR1RSVnF0ZFJIcE81L1pWdU0yZmkrakphUFZEajVUVEdhTzNaMlNpeXVYK01LTFg0aXdEVy94cHFhWXpHbUtFbWM5M2pSNDcyanFDbVVFdC9iZW9iQjFWRlQwclJhdmNaakdVOWVXcmZROGw3b1hLZVlGUWdnVzN2REdORGhuWTNBUStPR2JiM053dU0rVnkrY1o5UHQ0QnovWWVZZkRab1JTa2lDamFKeG9GU1NERC9RU1JTWUUxbnE4aU10UExXZ25neUpxam1ubzFKSmkzQ0NWb2loS3B2TUNJU1NKVGhuUGE4UjVSVmRyZkdHalJaeDFyUStMRjFJS1FnaEtDWGwra0tjdmRySmtQQzdxZlJjcmlhVDkwa0FTQXRwN3Ixb0pieEZDRUVYVjRGemcvLzVmZm9XaldmWFJ6aUNQQlVoK2RXUDRxYk9ydlY4MDFxVlZZN0hPdDJKdW9sVTJqeFdvTlJadlBVNXBidXdhOGtSeWZsMGphSmNVdEI4cWNjb1VpS0lNaFBlVHBKWlUyd0JTU0k1THd4dVBBcDk3ZWtoVkdLb21RT001dDU3Uzd5bGVmMUR5K3IwU3JXQ1lLWXoxbEJIWWk3SHh5WXBoanVsb2pzYU8wWkdoTGcyZi9zVFBNdWdPOE00eG41WE1qZytKL2xaeG9lbU1wYTVLK2xtZmU0L3VjMi95Z0dBRHBuTFVsYU1xSFZVVnAxblhWcTR6cElzeERkN0ZMRHMrUGtZbENtOGRUVlZ4Ny81RDd0Ni94OWFaTmJwNWhwU1JOdkM3TzI5UzBKQjFFNFNXTFErZlV4S25rVkFsak1mWTlrSVhFVUlqMjRXckRZSEVTSmc2NmxZRVlqcWRZYjBueXpOVWtOd2J6ZWc4M1NjWVQyb2tuU3lOL0JnbFNaU09uQlVoa0VLc3JYVHpsL3VkckRxWWxnL2FJRmthdFo0YUV5OG5YNEZJc3B0VkRTSDhlRjdLUnlsQWtrVUdlWHA3OVV0cjNmeUxSZU9VYlQ4d0lhSzNoWlFTS1dRVWhRc09ZdzNlT0lKTWVHK3Z3ZGpBNWMwVXJWcVVhZ3RrWEFaQ2VQOEdQTFFsVnhDQ0xOZjBCd21QSm81N1I0YWZlYUpMT1RkTFVKRjFrQW5CbVY0Q1d2TE45NmJjMmkyNWRDYW4xMVY0QjdhRnp4ZkRqS3FiTWo1MlRFY05SVFhuVTg5L2d1MlY4OHpIWTRycEhPOGN4dFN0ZXJ1bnJrcktvbVEybjZHczVMMzc3MUdVSmRYY1VzNE04N21sS0N6U2ExN2N1SWFkTlJFV0l5VkthZEkwSTBrelROTnc0OFl0YnQ2K3c4YmFnTFhWSVZwcWhKQThtdTN4dytPN0NCVkl1anBLcWxZdUN1YTFxaEl0R0JrdEJJMEIyNHBqU3lYUk91SjJsQVFyUFoxS1VjNE5JY3BaVXRjVlNaS1NwZ25UNDRxNkowbk81ZFRqRWxFSHNrU2pwWXgrOUZyaFEwQnJSWmJvWHA2bzU1ODh1M2I1MnZiNnBlMjEvdGE1OWNINXJaWGUyVFBEN3JiempyS3h2ZzJXSlZuck1SdEY4WkVjODU0ZThRSkNTOWsxMXFteU5nRWxoVlFTNjF6cklTaFJXcE8yWGhwQ1NPcXFvWnJPOGYwT3YvbjZuS29KL1BsUDkybVZiVTZDb2ZVbXhKK01hM1dpU0JLSlVoSnJJbEhxaDNmbnlLcG1mbHpqV2pXU3VNR000TUNtOFZ6SUZadlBybkl3Tjd5eEd5VkhuejNYNWZ4cVJ0MEVtRFVVcTU2cWRwR0E1V3J1N0g2WEs3M3pqUGFPV21oS1FwS21WTVVNNTMwc2s0TEQyb2FWYk1BRmZaRnYzdjl1NjBVWVM2MGsxNXkvZkpaQk9xQ3VTd2dDNXl4bDZlbjErbmpudUhuckRqZnYzdVB5eFMwMlYxZWlnMjhJV0d1NWNmQUFHd0twakwxVEVJS2dZcW5vUklUSktDQ1ZBdWtEdVJCTWphZHBvcDZXU2tCcVNTckJyUVY4QlN0Vnl0R3NKczA3TkthaGFXcTZlYzdabFFIM0h4UlVneHgxSnVYd2ZzVmFBNE04alhNb0g5QktZS3hIS2ttYXFQVlV5VDg3Nk9RQktaMlVvZ3hRV2UrYTBiejYzbHYzOXYrejErL3N2UUVVTFZwNDZkTExpY2ZpUnpLRHlOTVo1TkphLzdPZFJIMjZicHp3UGl5MVpVS0l1d3V0Vk91aElkb0pVcUNwb3hkNDBrbllIVHZHWmVEc1drSTNqYkFTWUJrd1Fzam9ScHNJa2tSaUdrOVJXb3p6Q085NSsxSEZtYlVPNXdlYTRBTkpPd1d6SVRiL3FCT0pvTlZjMGRld2UxVHo5WGNtUEJ4YnJtNmtKQjNOYnBaeGZHeXA1b2JnSUIyT0tNY2xtL2w1RUZCVlZld2I2b3JaZElwekR0czB6Q1lUSnBNeG9mUjgvL1VmY3UvT0kyWkhNNHBaUldVZG43ejJQQmY2bTFqdnNlMFNVRXFKYzQ2SER4L3kxcnZ2Y1daamxhdVhMMElJS0tWSTA1UnhQZWVObzF0WURGa2U3ZFdrakVhaFVwM29yM29YQVprU2ozV2V4Z1dheG1PTVgyWlRMeUJMQkNFSE1YTFkwaUdreGpsRFdjWXMwczF6aWxsTkl3S3FuOUFrVUk4cWZPT2p6YlZ6N1U3S0w4dXRPbmd4cjR5WXptdmx2YzhTSlh0cG9vZURUdmJVMWtydlU5dHJnMkVnVEVmenF1RDk1S3p3VVE4UURXUkNpTjdGWWVjWHRPQ1QxZ2RoZlJEZSsrVWt5M20vSEt1NjFxNU1TSVdVQ2xNM2xMTWFrU2JzVGdJUGp3MVBuTS9wNTJvcE5jb3A3dzlySS9YV3RJaGdxUVFpVGZqT1E4TzFqWVNWbGxYWGFqOUhrdEtwbmlYZ2FVaFIzUzJ1bk52a3FmUHJOR2plZWxCZ25XWGF5em1jTkZTekJ1RTlhNXVhbS9zUG1NOHRXNzJ6cEdsQ1VSUnhkK0VkbzZNalp0TXBrOUdJbzhORGp2YjJtUi9PdVhudlBvMnBNYzZ4dnJISlo1OThDZVVDMCttSXBxbEowZzdPR2Q1NDR5MXUzTDdObGN2bk9YOTJteXlMMEhyWFd0UTluTzF5dDNpSWtISEpxUk9Ga21KcE5lZGFQb3ozZ2NwNmJBQlQyY2ljYkhzKzJ6Z0k4ZEt4RHRKK3ZHakNrYVZwUEVwcFRGUGp2S1BYN1NJOTdCMk9FVjFGT3NnbzZnWmR0Z1MxRnVDcEZnTGpVclpNeWRaOE5RU0t5akNmbHpqcmhHbk1lcitUL016WnRjSFBwRXBWKytOaXo0ZHd5bVh5SXhvZ2JVMnBnRlJKMlRuYlQzOUJFRDVobk1lRHNHNHg2dlhSRXNERklGRktMdThQbFdpY3Q0UVFtQmNOdlZ3ekt1SFdic05hWDdNNTBFdG9oMnVYSHU1OWU1RFlDYWx1eHB2M0M1NFlDRktoOE8zaGthSU5rZ1dLMTN2azZuVzZULzlad3ZtZnBYZmw4M1MzbnVmaUU2OXc3dHJMeVA1VjhzNFpoRSt4TlRocldkL1NUT2VHRy90M0dJOG5iT2JyQ0FSVk9hZVlGMHpHWTZhVENVZjcrK3p0N1BEby9pT0NzVXpLaXVQWkZKRW92dnlGTC9EVTVrWHFxaVpKTkxVeFdFdE5Hd2NBQUc0U1NVUkJWR2U0LzJDSHV3OGZjdUhjRmhmT2JyVWxwYWV1NG1IMXdmUHU4UjBtOVlRczB5UWRIVzBlWkt0UDNQWnBVaERCaTFMR2NYWnA4WlhGS3JIMFRmUXV0SFoyRWZ3cHU1SzBFcFNqSmxya2VrOWQxNmdrSWM4eXhwT1NtYW5JQmhrK1Z6VFRocDVNTWRiUldJY1NDaDBsbjVZM1pwcHFkS0t4QVlLTTNQYW9mRk5McmVWbU4wMC9wWVJZbVZYTlc4YjU1bFNRTEw3RVJ5bEFGa3ZTSklTZzEzUDlDc0g5akhGZVNLbUVrTEtGZHl3NEhYR3NtaVFKUXNRTmNGajJKOUY5cHl4S3BGUlVYdkhEQnpWS3d0WlFvM1VrL21ndDhDSk9iaGE2dkFHd0N0NTZXUFBzK1M3QnhNQU1MV1JjaG9BTUFoRUNYbVYwbnZtTFpPZGU0V2h1V0YzZFlES3UrT0d0UFhZT0NocWYwUW1iWEY1OW1pZlB2OERUVnovQjV2QUtpUmhpak9mTzhRUGVlZlF1UlRGSEdTaW1jMGJIUnp5NGU1OEhkKzl6dEg5SVhVU1lpWkNLQjBkVHpteWY1MWQvNGN2SXhtR2RJMGs3S0tsNStHaVhPL2Z2YzJaempjMzF0YVVJZDFsVlNCbm9kVHJjSCszenh1Rk5KSUdzbzBseWhaU3lMVnZiekNvakdrRUtnWmJ4ZFlxSXEwY0lTUzV5SkFMakxHVnBzTVpoVFpRbkNrb1FEaHZHc3dxdE5VVlp4QU12TmM0R0RrZFRrbjVLZHpXbmRwNjBCQzBrVldPd0xxQzBKZ1NQYVJ5ZE5DWFZVVEN2c2hhVktNNXVySUFQeU5hQVZDZXFzN0hTZjNwOTBHVThxMjVYeGxhYzZBWXZzOGxIU1hwMFlXWnZEdWYxdDRUWGYxbktjTlk2UjVaM0VGNXlDdFFXSFdIckNOQ1RTa1VZcWs1d2pVTnBpZmVTMldnYWI3dCt6di93M1FrUERneS84dWtoZzc1cWI4RW96QmJOTW1QcGxPUVphWjZoUW9UUUN4OTlNMElJclRqRFNZM2x2VWZpVVFLS0txSmpiOTI0eVhRK282a0xxckpFSlFrWExsN2czTGx6bkQ5L2dhdHJWM24rVE1xOEhuRXczV0gvNEFIMzc3MUJXam5Ddk9Kd2I1OXlOc2RaUzlVWVVtdTU2QUtoMCtjVG4vZ1VhVWlZelkvSThnNlR5WlR2dmZvRHlxYm1tV3VYRWQ0eEdZOG81ak95UEd1blJSbmpZczQ3NDdzMEdIcFppa3pqYUZlMHhxRWl5Rll4UGxLZmwvcXZBcnlLN2xUT2dwWVMzOGpvUDIraUNMZ3pIbHQ3YWdmQkdBNlBwM1E2T1UwVG1FeVA2Tll0MHJvTVRQZG1kQWNwZWpXbExoMlpWZmlxcGpJV3FUVERib0tXa3FwcFVGYVNhb2wyQVMwRHRqSG9Gb0hnZzBjS1JaS283dmI2NEY5N1dRajd0ZGR2L2Z2VythVk53NkluK2RCbmtGNnFGbHZRQlNZbktheWJKSUpVaWZDU3RUWjFOcDVpNjJLbVVGSXRleEFoSXV4ajRTZm9YTHhkUll0enFzc2FaeDFKbHJFenNleFBMUnNEelVvL0twdFlFeGx6V1JwbGZ3cHJlZTlSd1pNckdtZml4bGd1YktNSnJXcUtBRnRqeVVpM24wTUt3ZEcwNE96V09vZDdlOXk3YzRlcUxPSTJXMGlLcW1iLzRKQTc5KzV3NTg0OTl2YVBzSTNnL1BwbHJwNTdscXRYbnFNNzJDVHJydEhwRGdsU01TOUxyaFlGdjFRWWZzWUVYaENhN25STzVSeGo3NWpNQzM3NDlqdFVwdUhpdVMxNjNRNHVlUEk4Unl1RmtncGphcFJVL09EUkRXNk1INUlvUlpwclpIVFVRWW1vaGFWVjdBT2NqenVLV0dJSmxJejlTTFNEQStNTWpUWFV4c1gzVk1xbzdsSWFtdEpTN1ZjY0hveVlGeFZGVlZHV05VRW9xcnFtS2h0cVora01VbFN1YWJ3blRBeUppcVBldW1sb2ZPd244MFRUeVJMdUhreW9tb1pVYTRxaVFVdEYwOWpvMUN0bHUzajB1cE1sRjVORTM5azdudDFwbFFLV1Rpb2YrZ0RaN0tYVU5naDNDdkljUU15dHY5M1JNa3NFenh2cnRCRGdmRHo4V2ljdFF6RFdyRkVvTFg2WW9xM1lBbkY1SlJYWUpxSmhkYUk0bkFkdVBLaklVOGxHUjdiTk94R2tweFU3eHpYdjNadnp6R2FHYzlDYTRVYmVTUXVJWENDUW0va3hmbkNWL3ZvVzAxbEptbWFzOUhMZWVmdHRpaUlTZnBUV3BIbStMQWVOdFl6SEV4N3Q3dkxPZXplNTkvQWhaVmt4R0t4eStZbnJuTDl5blN0UFBjK1ZwMTdrNHBWcmRDOC9nVmpwby9zcG9wbmpiOXlpZVBDSTcrL3M0cktFODJmUGtDVUoxanF5TEVVbktXbWFZcTJsMSs5eWI3TFA2M3MzNDZVaFFHY0s2MXVXakd3VkdJVllJSENXeENnaDRscFd0ajJLYm5ja29YVVRVakw2SURyamFXcUxMUnptb0dKMFBLVnBETTVhcEJTb0pLV3BHOHJhNEJMSmNMTWJTN01FOWljVDNOeVNLWVh6RVNGUTFBYXBFNHJhY0RpZWNQbmNLb05PamxJSzQydzBRRkt5TlNSVkpFcWhsUmlDV04wYkYxOXRqSjF6RWlRZmpRd3lqNkMwMDdwS0tvQmNHMmI3bjc2KzhzeGtaaTdNeWlZcWx3Z1JnWHRDdEVJTEp6ZmNZaTI0WEE2MkVwNVNpY2dCYnh5SlZ0aWdlRytucG00OEc0T0VQSk5ZRjROclZudXNFMXpieXBBNmVuMDRGMW96elRqbUZRaUVrSWpRMEpRejBqTlBvN09jYWRsdytmdzJSN3VQdUhmL0FZRjJJWllrYUtWYm9LVkFLclUwNlN6TGtrZVBkcmwzN3dHMzc5eGpWaFQwK2owMnpweEJiNTJsMk54bWZ1VTY1cW5uOE5lZndaNi9nS2hLWmc4ZUlNOXNrSFZ6Q0dDZEpjOXlUTk8wYmxxS1VUbm5kMjY4enJpWUlvanYyd0tmdGVDNSt4QzFoNzJQQ0dEWjBnWVcwNnhBN05jV3pyOVNuS1Q2c05pOHR5V1VPV3FZellwV2dTWEVVYnBLYUdwRFVSdDBONkcvMXFFMmxzWllpcWJtd2NNUm9RbGtVcmFVNkhnREdldlJJdEROY2pwcGlpUStYNUlrUzlFKzFTNk5HK000bmxScWJ6VC9qZHJhdzFON0VmK2hENUI1NDdoNFpkQ1dPMzRaSUVLUVRVcnJ2dkQ4cW5qNTh1QXpqdzdyWkRJejdhdytvTFZHdGJnc0NFdjR1RlJ5aWRKZHJGcTEwaTF5MWxNVk5WcEswSm9iZXpYM2p3eG5WMU9HWGMxZ29EbWNHWDduclFsU3hLQkpzMmpBczBBTCszQ3krMWRLRXViNzFDR2hmL1k2eDlPUy9xREhSaThoUGY0QnJxa29yY1FUMGJoS3RaS2dTMUpYcTkrck5DSEVwbnB2LzREYmQrNnpmM2lNVW9wTVIraU1USFBrY0EyMWRSR2VlQVl4WEtlc0c2cW1SR3VCRW9xcWFtTGdDc0c5dzExKys2M3ZNaTVuS0NIUVdwSm1DYkk5aU00RmJJeDRRbU1SSnFLVVhXc2NGTGZsc2kyeFR2QzA3YndrQnNjU0ZCcFFjNWdkekNuS011NVJBS1ZVSE5zNlIyRWRPdGZrL1JUblk5WnBpb3JKcU9Kb1ZGTTFacGtWeXJLbXJodThoelNKa3FyenNpSUkyVUtIRm5ZVmdkckdrcXVzbXVKZ1Z2N2pzakVIcDVhSC9pTXh4ZnJpbjdyRU96ODR3a2NvN2dMbGtJVkFwM3UrMS8rem56dnpwYWZXODk3dHZZcmpTWTJVQ3p0bnVWd2FXbXRCQ0pUV1MwOTAxZnFqUnh5UmlqZW1jOVJWSFJkM1djS2s4cnh6djhTNndOYUtacS8wM0RzeUpDSXdLanlsaWQ3b3E4T2tSZnd1bG9aeFhDd0kxS05IaU40NWt1RVo1bVhEaFlzWFVNVXVXK2FIZEpTbGNvS2FGS1VTZEpJZ3BFQUt1U1JzaFZaL2RLRndqNERKZE1iOUI0L1lPeHFSNTEwNldZWnVwVUcxVnVUcloraHZua2RsUTV4elZPVWNnc2Y3d083NGlLKzg5VDNHeFJRdEZaNFFEWGp5Sk81NlBLMWxSRHVxYmR4eU9lamtpWFJydE1EMnl3TzVvQlF2bG5xQzl1ZjFFSTQ4bzcwSlRSUFY3cjN6VVYxRlJPeGNhUU5wUjlOYnlYRE9ZNHlMUkxEU1VOZUJlVzBabHpXZFUzc1JyU1JhNi9qM2JIeHRqZlVZNTFGS0xiUGMwV1RPZzcyeDl6TDUrcXlzYnJVQjBueGtBdVRTazZ2VWxSUFRjYjFZR0taQzBKTks5UDdjdi83eW56bi83TWJuejh4SytlVDVyaGpQSGJ0SE5kN2JCVUM3ZFlIeVNLVmFsa2JFYVVYRUtNdGJlL0hCT21jcDV3MjJkdVI1U2hNRXQvZHJSbE5MRWVEcVZzYm5yd3pZNkdsV3U2cDl4a2hMWFd6MExYRk1qQmY0cHFTY0hUTzQrQW1tbFdPNE1rVHFMcU83cnpNVVk5WTdGYU91cFJJZXJFSUpmVkxQYy9MekJlS3lMTFMzcjlJSlVpcUdneUhyWnpaSWs0U0ZLZ2pCa3lRSmcrRWF1ck9PUTJPYWt0dVA3dkhOZDk3Z3VKakc5eUlFaEZhb1ZKTjNkT3dwVG1QOFd5ZGZSR3VhSW1XN0RXMHQ2SnhmL3B6Qit5andIVVJiYXNaL0VwcUEyWE1jSFl5eDFrYVVnd3ZJMXY3T1drZnRBNzErU204MXcxcUhhUWN1eGxoc0UvMVlsQkFNODRSVWE3UnVmOVkyMi9vV3hXRHR5UzRNWUR3dHVIRm5sL21zRXM3NzN5MnNmZlVqRlNEUHZYS0dkMTQ5WkhKY0MrLzhRcHUzQy9UKy9GOTU5dE9mK2ZLbHZ6NXliazBmbGVKOEpuam02b0RqcWVYZWZoa0ZtdHNTSzdSdm9QTnhndVVXckwwMkpjZnQrNktzQVdOZE5NK3NJelJjYWNXamtlTzkyM015QkZvSXRHeUpRaWJRbU9oQklxWEEyTWhyQ0Q2MFVxVUNWeHpqU2VsdVA4SGhhTTdscTFjWWo2WVV1KytnUThDSW1vZk1HSmU3V085SVpJNFNFZEVhRmx1WTl2QkxJWkZLbzVPRTliVjFucmh5aWY2Z0R5cjJFRklJZ3ZNNDY1QUNldDJjd2NvR3FydkJ1QW5zSEI1UUZoUEFJNVJBSjVva1dWd2U4VFVRb2lscWxHY05OQzdDOVgwcjF5SmJDSDFqMjhISHd2alUweHFkaGpiREJFSUo1c0J3ZURTS1czampFWXVkUlZ1ZVdpbFlXYy9KdTNyWk94STh0ckUwVFJRYVh1dG8xcnVkNWRBbFRSS1VqQTI4c2FiZDJjVHJ5bHBQMWNTeDh0SHhETy85dkhUdXYyb0NONGtVM285R2dEei9NMXZjZU9OUVdCdGtDRXZJZSsvaUV5dmJmK0d2UHZPL1ZSbWZPaTZkSU5Wc2xJWnVJcmk4bVdNZDNOdHJGMm1pRFFJUnl3K0lTNmhVYTRTQUpFblFLaUVzK3BFUThENU9kV3pqS09ZMXhycTRZZGFLbmYyRzl4NFZqSXVJY2sxMXUyME9vYjBSUGJZOU9JdXlBd0xWZUlmdXhsVk1za0xleWVnTjFuajB6dmZ3elF6Vk9FWkJVbmNFZFpoaS9CUm5ta2h0VmVseUR5RmF4TExTaXJ6VDQ5ejJPYmEyTnBGSjdGOFE3ZmFiZ0drTVZWMVRGQlZOWXhnTytsdzhmNFZ6VzVmQkM2YnpNY1kzMFpleEZhcEdSZ1prOUdsY0tNTUVqSEh4cm1uVkcyMFQ0U2tpUkFLV2lGUU12QXV0ZDBvTUx1czhidUtaN1paTVp5WE9leXJqRnRvK3NZa240SlZpODB3WGxZbWx3MWZUbVBhU0NtZ0U2M2xDb2lNdUxFdDB2TlJDdkQ0aTM2VmRCcmU5bkpTQ3NqWWNqd3Q4NEU0WitIc09qbG9Rb3dIY2h6cEEvc1JmZnBKaTByRC9jQzZ0OWRIalV0QlhXZ3oreGIvK3dwL1p1anI4Sy9QQzVWcEtYSzVaRTRGc1ZwTnF3VlBuZXlSYWMzdTNvaWdOQW9mM2p0WjVZT2xNR3crRFdKWUtVa2tXbG00UjBoVnZ1TEt4VWRKVVJFK014c1BENDRZYit6V2ptVzNoM3ZIZlJRMnVzTlRZaWpnbWdiY1YxZVNRd1lWbk9ab1pMbDI2eUdSU2Nuei9iYkFXVXhrT0hmSDVUY25vNkJHanlRN3pZb1JFa2FZNVdxY1JWcDRrREFlcmJKL1paakRzeFlGQVd5NkdkZ3JscldVK0w3bDE1eDd2dlh1RGc4TURyRE9zcjYxejdlcXpYTHI0REhuV1kxNk1LYW81aU1pNnhCT1pmVGJxZENrbm9EUUlHNzNVblFzMDFrVVJ2aEJvMm8zNVlrZHRiWndJdW5hUFpBOHN4dzhubEhVZCs0MFcxR2hEWExSYVFDU0s5YTFPOVBOdXNWWk5ZMmdhUzlOQTZxRFhYZ3hTcVJnb0l1NjZ2QThZWjF2VVJLd2FGdjNid1dqS3ZLd1JVbnkxaEY4TE1PTkVYdWpEblVHdXY3RE8yNjhlaU9tNGtZUW9HZ2YwUHZlTGw1Nzl3cCs2L0grZDFWd3dOcENvZ0ZhZXFaZXNUaXEwOXlndHVIYTJ3N20xblBzSE5ZZVRDQWlNd1NHWDhQRTBUZHZKalk5OXltTHkxWUxqVHFOWHJRczBWVU5aTmdUbjRxSDBrdDJ4NGVham1rZEhEVVh0Q1MwVVE0cG9LcXBVTktQeFFkQk1EaENxUTM3bUdoN0IrVXRYdVBmT2E1VFRBN3BDVWs4cjlxdkluN0RHVWMxbVRNYjdIQjNlcDVpUGtUSWhTenQwdW4zVzFqWllYMXVsMjgrV3QzNGtTVVpuSGhFOFpWSHk4TkV1UjRjSDdPL3RNQnBQbU03bk5OYXd1ckxHdFN2UHNyMXhtYUtjTVowZnhiSkxxT1VrU2dDK2R2aktZQnNiRVFhME43K0owQTl2L1ZMMXdqWHh6NXhic0J3OTdzZ3kycDlTVncyRmNUVFd4MWhxN1lwcklPdG9odXZaVWh6Y0dOdG1FSWVwUVJuUUlhQmI2b0ZTQ3AzbzVlY1cya3dTNVpwOGk4c0w3QjFPOE00MVhzci91dkRoZDl2c3NRaVFEKzhlSk84bGpBNUtSb2VWOUhZcDJOQlhpVno1Qy8vcjUvL2x6bHIreTBWbFZhWUZXanNrZ1ZrajBiVmx6ZG9JRHdHMjExSXVuK2x3TkxjY1RnekJ0K1l5VXNTTmV6c2FsSzFycDJ1bE9ZV1U2SFlqSDBMVXBRb0wyNFFRYUJwSFdSdWEya2FCYWcrVHVlUEJzZUgyWWNYT3VHSGVCTFNFUEkyVGw3cUtCMmQrdk12Z3pGWG1QbWQ5YzUwUUZBZTNYaWNFUnc3TUp4WFR4a1ZjVFdQeGRkVE1IWStPT0RoOHlHU3lUL0NlMWRVdFZvWXJEQWFkNWZoNjhUb1dsZ1Ntcm5tMHU4Zk9nd2ZVZFVXV1J3dTIyV3pPYUhSTVZSYWMyejdQaTg5OW1uNitSakdmVVpSVHJEVW9JZkRXWTUyTEpZenp1TFlSZGszTUVyYUpDRjVUVzJ6dEtJdUl3WEltVUZVR1UxbzQ5b3lPeGhoaktJM0h0QnBrQy9xZkFmb3JLYjJWTkU3UHZNYzBEWFZqcVp0QVUwYmRnRlJDcjVQUnlUc2tTVlFoTTlaR1ZROGgzN2ZFbEtJdHIwWXo4T0ZoSS9qL05DSGNhYmtpellkK1VhaFRGUnR6NjJVNGxUMCsrK1dMeno3em1hMi9GcVRZVmtLUXB3RXRQYmFKQi9UWUJiWURKSzJNWndEV0JwcVhyZ3p3WG5CN3I2SnVMSWc0NWwyUVNVS0lQSkxGZ3RHMUNHSHZQUzY0SmFwVmlYWU9KdUtIWnJ5bmJpeFZZNWNrS3c5TTZzRERvNFo3UnczN2t3YnJQRmtTUjg1Vk1hTXBKcXhlZklIS0NxNWNmNHBIZDk1aGV2QUFId1NyV2pCMG5ucFNNaStiZU9PMk5OY1FMRVU1Wm1mbkRyczdkMWxaT2NQRmkrZFFTWVRkSlVrUzl3c3V3bXp3bnRGNHlzTUg5ekZOaldqTE02M2picVVvU2c0T0R3Z0JMcHg3Z2d0YlQ5SHZyRE9iVDVoT2p5SXExM2xzdS9EejFtUHFTQkd1cXhyZk9HeHRxYXVHdW9xUWtybzBsR1ZEMHhpU1d1SW5scVBqTWNaNFNoK1dVTnBrQVFBVnNMcVpvNVBJWnpmR0xQdWVxdkNZMW1zbEVkRE4xRko3WU1FRTlZU2w0cjRQN1NZOXpUZ2N6WmpOUzRMZ3JUS0UvOHJESVNjNlcrNUREVFhSaVNTNElMeG5rVDE2M1o0ZS9zcS84dFMvTk5qcS9wSUlhS2tDUWdhTUNkUjFvQ29ETStPUkRqYXNXMmo2NEd3Z1VaTExaM0k2bllSSEJ6VkZhZkhPc1pCU0VJQ3hacmtic2NZdUoxNkxzbXh4TzRmV2V5TkxFNVJXZUJHRnF4dm5LQnRMWXh5KzdXbXNoYjJKNGMySE04YUZwNmc5c29XaEpIa1h2WHFCWHI5UGt1YmNmL3Y3TFZmQ2swckJVQW5XdEtTTElKZVNUQWthSDFwdWZHQXlQZWJnY0k4bnJseG5ZL05NaTh3WGREb1p4cGpZTHdtb3k1bzdkKzh5blUxaTZTZ2tPbzFMd1VYelB4cVAyTnZieFZuSDVZdFA4c3lUcjJBYXgvSFJIbVV4d3pVRzI1akkrYWpOai96ZU5oWlRHM3dyVG1jYVExblZETW1aandvbWt6bkdCNnBUa0FqVm5sS1pTRlkzVzA2ODgvaDJYMVBYam1JZWNQYms3MmV5SGFjdmxPVGIzWkJvaVc2SlZnZ1JTK2Fkb3pIV091Y0Z2MUVGL2lteC8xZzA2T0ZESFNEYkYvdE1qcHZJSkJSeGN2V1pYN3J3L0l1ZlAvZC9Va3B0UkVld1dHY0dIL0JXVUZjZVUzdDJDMC9mQnJxdGErMkN5eUVUeWFVek9VK2M3WEkwcyt3YzFWSFFJTGhJa0hMeDhDWkpndFl0M0p0QW1xVHROTXBISUppTUNpYytSUFBOYmhyQmMwcEtQR0Njb3pLT2VXT3BHa2ZWYm5Qckd2Wm5sb2NqeDk2a1p2L0JiYzVkZnBxUTlybDQ1U3FIdXp2czMzOEg0eUtNMnpxUENKNnVFcXdvd1hxaTZLcjRQV3hicG96R1Iwd21ZMTU0OWtYeWJvK2lxdWwyY3FRVVdHdmpvczQ1SHU3c3NiKzcwOWJyc2RkU1dpOE5QYVdVVVFqT0dvNlBEbkhXOGNTVjU3bHc3aW1jOVR4NjlKQzZLbU5HTlJacmJEUklkUjV2TGNGN25EMzU4NlkyS0MvWlNBZnM3QjVSVmdiYlh0M3FGTUhIQXAyQnBqZlViWG5sMmhHeVkxWllxdUtFa3hPelRpQk4yaWE5eFE4bFNkeUx4TUdMSWswMDg2TGgrSGlHQ0dGbWhmalBHM2l6TGEvcWp3UlljVzB6RjlOUnJRZ2tDTHBDaXQ3UC92a24vc0taOC8wL21hc2cwdFFMRytLRXlabUFyUU5WRmFIVm83bGwzampPZUk4bW9IV2M3Q3dzbk5lSEtkZk85VEFPZG80YjZ0b1JXdjFidVdqZzJ5MnhkNEVzUy9IRWhWWk03L0c1ckk4YjNycXhnQ0RYaW1HV01PaGtTS1VJQVNybmFkcmF2Ykt1cGFoNnFnYjJqd3Vta3pGUFB2c0MzY0dRTk8venp1dmZwcXBtcmRhVmI1ZHhibG1XOUpSZ0xkWGtXbUphZHQzaDBSSEQvaXJYcnoxRFpSek9CMWFIUGNxcWp2QVBBcFBwbkFmMzdtT3RhUzBRT0FrUUtkOW5EQlJDWURhYk1SNGRrK1U5cmw5N2lmUG5yaktkVEptT2ovRE9SbkxVUWlEYys2V1QxMUpnb25ac0R6WndkZURSL25GYytyVW5VNTdpWVRnQnZZRW15VTVHdGNFSHl0b3ltNFpvM1gyS05aY3JTYmVUUmNFNTFjTHlXOGRnS1FSSml6UGJPUm96TFNxazROMHE4Sjg1MkcrelIzMEs3czZIdVFjUjFkekd4V0NnczdIZDNmN3NuN3p5Vnp1ZDVJazhDd1NjbUZRQmE4QTJBVk5CVmJtSTJhb2RveVl3VklLZTlValpHbkxhTnRzRUdQWTAxODkxNldhYWg2T0c4ZHppVGVUVGhCQWllTEdGeFVmRWFydnJXSTRWSXdaSnQ2U3EyamlxeGthSWRZQitsbkIyMktmZnlhT0NDdEZIbzdTT3lqcEthMm1zNDJCdmo3Tm50M25xMldmUk91ZTlPenU4YytNOW1pQ2lWMGhMSTQ1bW9xM1lYWWpXREdmeWhOVXNKVldCK2VTSXk5ZWVaMzFqazlHMFlIMTFzQXd5S1FYT090NTgrMDFHeDBmTFBZRnU4Vit4MURxaFR3cG9OWHNEeFh6T2RESmhhK3NDTDcvOEJaVEsyTmw5Z0xWTmRMeHRWYjlGMUxIQ3U4aFRUMlRLK2VFR2ovYU9tY3lqWUYxMTZxREx0bE5XaWFBN2lOejNCZml4YWh5VHFhZDV6T0ZBQXgwTmVaNlM1eG1KMW0ySkZlSDdFYjBkQ1hLN2g1TmdyUXRlaVArdWhGOXZzMGV4R085KzZDbTNkV0ZsQ0VHSEVJVWFyankxZXUycFQyMzl5MmtxMTVYeW9yRlFteFpPM2NRZ3NYWFVoL0ltVURhZUl4dllEcDZrM1hCSHRtSDA1ekEyWnBaemF4bFh0N29JQkFjVFExSFoxbm9xamppek5PNGRhSVhSSUM0RG5mZjB1ajE2dlI3ZVI0S1dEVkg5dkxaeHdqVXBhMVFJYkhRN25GMFpzTnJKU0pURStrRHRQRmV1UGNubnZ2VHpiR3h1c2JxeXd0dHYzK0RXN2R2Y3ZYZVB5Z2ptVnRLSUZCTmtGRVl3bmlZcUQrSkRiTTYyZWgxZU9yZEdEOE9EVXZQY2N5OVJWTkhoYk5ETHFlb21Jb1lGM0xoMWl4Kzg5U3F6K1pTcXJxSU1xVXBRV3FOMTBtWVM4YjRnVVNwbW1QbHNCZ2llZWVZbE5qZk9jWEI0eUhSNnZFVHdodEJPdVZ3Z2VNblp3UnBGMGZEZ1lCUXZwVFo3TE1CMEMwcGZyeS9vZENQZXpQbUlvNm9iVHpWdlA0YkhlTmVaRkdScFhCZ21pWTd3R2ltWEVCd0NUT1lGaDZPWlVQRElJUDZqQm02Y0d1L2FqMFNBOEg0dHJPN0xQM2ZoNVkyTGcxL0pVdEdMS256UkxzMllLTFBqMnRtaE16NHVycXhuWmdLTmhXMjUwTWhkd0RhaTFLaHhvRVJncGFPNHNKbVRKcEtEbWFVbzQ1Ukx0RHVGaFNqRUF0TmxYVnlDYVoyeXRibk94dHFBWWI5TGtxWTAxdUpDQkN0YUg2Z2F5N1NvbUZVTmtzQktOd2FKRVpvLzljdC9odTB6RjluZDJlZlY3NzNLM1R0M3VIWDdQUjd0N1ZJMWpzWUZqQk5ZbVdCUTFDU1VWbEEyQXVOYlFLVDNwRnFTSkpwWDcrenp6UE9mb0Q5Y1lWWlViRzJzVXRkMXl3UUVZeXp2dlBzMlIrTkQ1c1dVOGZpWW82TURpdG1ZNEgyVUdjcGllVWliTVJlQ0Yxb25XR3NweTRydDdZczgvL3dyekl1YVIzdVBDTzB3STRSNEFYVmtCeGtVOS9lTzR3YitWRmU4RU5nTlFKYkJjRTIxMnNpaDdkODg1VHhnYW41RVlrRUNIUmt0cVJkWlE3WHcvT1VVeXdlT1JqT3F5b1FnNUQ4dTRMOXBsNFB6QmJ6azlETi9LQVBrQzMvNkN2ZmZHd3NFQ1RHRGRGLzYvUG1mNjI5MmZpSExaR0t0ajNBR0M4WkVGMlRud052SVhURFdVNVlXN3p6SE50QVZzQ1lDaVk0M2xmZEVMdy9SV2hOb1FTZFRiSzluYlBSU2JJQlo0V2dhMTVZMTdTS3EvWXFMcUVCUkd3NUdVeWJUQWlVay9UeGpmZEJqcFplaFpRd3VGd0sxRDVUT1VWUU40NkttcUJ1c2N4enNIZkR3M2gzMmR4K3l1L2VRaDQvdWN2L1JmV3ByYWJ5bnNySFJuNVkxODlwR3BHcVFHQ2VwbmFiMGlya1RUQnJQcUhUY2VIVEVZR1dONTU1N2dlbThZdENQNHRGbFhhTmEwdE9OR3pmWTI5dUpjb1RlNDV1S1lqSmlmL2NoQnpzUG1VM0dPR3RJZEVLU3BHMmZJcEZTaGlSSlJaYm1FQVFiRzJkNDRmbFBNcHVXUE5xNWovY0c3MEJZaWZLYW5kR2NwaFdYWGdUSEluc0lJTlV3V0pQb1ZDNVB2M1dlcWdpVXMzWUF5UWNFaUpMa2VVTGFqcXFWaWtjODlvZXh1ZDg5bXVLOXYrZVUvTHVWOCsrMndmRWoyZU5ER3lBWHJxK3djMmNxUXdqcElrQmUrZEw1WDk3ZXlqK3JkQkRCQmJ5WEdCUE5iWUlIWTJLekhqT0lweXFqMXBUek1Hbzg1N1NncnlPOE5EYUM3WTNYcXJzTEtlaDJOUDFNc2RaTDZHYVNhZVdZbFhFQ0ZVRjdEbXZkc2grZ3hTR1Z4aklwU282bU02Wmx4RzExdEdiWVNWbnQ1dVJKckpWTkNKZ1dyeVZDb0ppTk9SNGRjbkM0eDlIb2tNbDBFakZndkYvUXlZZTRrYTlNSENNWDFsRTZUMlU5bFlWcEE2TzV3MGRTUEMrLzhqTUluVkFVTldjMlZpaUthdm1jUjBjajd0eDhCK25zKzdRNnBmZll1bUowZk1qK3puMzJkaDR3bTAzS05PL2N6ZkpjNnlUTnRGSWlTVks2blM2cnd5Rm50emU0Y1A0S28vR1Vldy91RUdxUGIyQlNSdzJ4c0ZnMlBOWjc1Qks2SzVJa0YxRXFTWUJ4Z1hMbUtXY3NXWm1QbHhNUnhoM0lVa1dhWmt1MXY3QVlNUGpBMFhqR2RGNlZVcXYvYk9yOHI0WEE5TlJ5MEQyZWx6NlVBVEk5cnFsTHE0S1BKVmJhMFN1Zit2bnp2enhjeTE2d0xqTDNyQU5uQXFhSndFQm5JclRCKzRqL01kYTNHMTNQdUhLUmVKV3A5bVkvMGEreXJUMmJYenJUUmwrUFlTZWhueXVNY3hTTml4dmR4bU5hTUo1eEM1cHRmTmN0OGZlTmM4d2J3N1NzS2FwSUxVMmtaSkFsOUZOTkoxSFk0R2w4aUxkcEN3dGZITlJ3NmlDZERwVFRwVW5ya2JITU1xV3hsTVpST2MvaGVNeVZ5MWU0ZlBVYW8xbkIyYzIxMk5NMWNUTWVQTng0NTIycTZmaDlGTTNUQjlGNXo3eXU2djNEL1Y4N09Oejl1MlZWZlUvcnBNN3pUamZMOG02bjA1Rm5OdGZvRFRwc3JLL2dqT0xXelRzY0h4NVR1WlAzMG45QWNLUUNzcjRnNjB1TWp4ZEdiVHp6U1loOXg0OEpqcVVZcjJpVkxGdGFyMVF5bGxwU01wdVg3QnhPZ2tmK2VvWDQ5eHZuRGpqQlhuMTBsQlhyMGk2eWNRcDB1c04wOWFYUGJmL0o0V3J5VkdORE5LdngwUUtzYmp4eGxSRlZTRVNBdXZMWUZndGtqYU9wTER1VEN1VURaM09OMUF2K05FdnVnL1VoQmxvSUNCa1J1cjFPUXIrajZhUWdoY2NCcFJOVTdtUmt1WGpYRjRXdE8vVjcxemJzczlvd3FSb2E0NUN0V0hiWjNyQ2MrdFRFQi96MzhTLzVZLzU4Z1Ircm13YXRGWi85ekdkcGxWa1pEcnJNaTNxcGFYWDc5bTBlUHJpN0RMclRwbHMyWHJYN0Z2NExELzlKV1pYMzluWWYzcmg3NThZM0R3NTJ2OTN2OWMxd3VIcHBZMk10ei9LVVhyL0xiREpqOTlFKzl4L2RqOHJ4cDRKaklZa3BpUWM3NjRQcVJRblQyZ2VhQnFvcG1HcFpoWDFnYWJXOEtBSWtJcEFraWs2ZW94TzluSjd0aldmTXF1WmhFUEwvTWJmMnpiYTArcEhKMVljK1FOcU11VFRNT1h0NWNPYXBsemQvdFQvUUY2Mk5ON2czMGRYSnR2TjRGY0NiS0g5WlZiWkZrdnFXRnhGTHJydUhjMWEwWkx1YkxFK21iMHNsMzJhU0pYVzJkWmpLVTAybU5WSUUrcW5DU1VrMzhTUTZMTE9IYStmNXB3V1hsa0d5eUM0dHkzQ3hGMWxraXRQQkpUN2dOditnZy9KNHdQRFlkcnFZei9uRVM1OWd1THJKdENnNWUyYWRxcTd4TFN4aE5KNXk4NzIzOGRhMHl2R3RuaElVRnI3aDREOE04RjhEdThBVUtKMno1V2gwZEhEbnpvMjNsRlFIbXh2cmx6Zk9iS3htYVVJNW4vSGVlN2U0ZCs4bXpwcjM5UnVMTWc0QmFUY0doeWM0RzlpdkszNjNub0czZFBsOUpLb1d6NWtDaVJTa1dVS1N0Z1N4RUpoWEZmdmplZUc4LzN1Rjk3OFdZTklHeU9tOVIvaW9CVWdLNU9ldXJweDc0dm4xdjVobWNxTXhjWi9oVFNRcXRlWlNlQnZ3TnNLdW5mVlk0MXVMNTBCZFc1cXFZVGFyK09HaktSZFhPcHpwSlcwdjBmSTFGdEk5cmN5L2NaRUE1VU9jOFV1cDZIVlNhdVBwYThjd2c5Vk8vQnJtMEUwZzBUSDF0LzB3aTZjOS9TRy9UOWJ2c2Y4WFB1REc1TEhBRWFkS01mRUJaWWdtYXZxbWFjTExuL3dVMDNuTjJrcVBUcDR6TDZzbzFlUGd4czMzbUkwT0lXWU0yOEI3RHY0akIvOEI4RjFnMUpZbnhTbjhramZHMkZ1MzNyMXo1c3lHZSthWjV6L1Q2WFowc0pZYk4yN3p6bzBmWW15eitIbEN1ekVYWHVCRnlrajJPSGFCVzdiaHYyMHEvdE5temovQzgzWGczZmI3eVBhLytlTm5WNXdhYTZZNkJvaHNRWWtCT0JqTm1OZm1xelg4WFJjRGUvWllZLzZCRGpvZkJlRTRrZVlxVjByMGJjdHNNNjBmdVY2T1hsc2dYU3Q5NmF4Zm5yaW1qdUM1cGpiNGRqL3hQNzU5eUVxMnpXYm5CS3pvRnY0WHhQL2Excytqc1o3S2VMd2tDczRSNVgrQ0RXZ1JFTUtUNlJna1BrUi9FZU1EcFlIU25uelZsbVZ0SGg3ckswNEhpT1JIZzByeXdmL3VkS0NjTHRlRTk3engrZytZSE8yVDk5YloyVC9taWN2blVFb1JnbVo3ZTR1TGw2OXk5KzVOYjUzZHMvQlBIZnczd0Z1UEJjWHB4bGEyaHcxQTNidDM1L1dpbUk5WFZsZTNkSktRcG5vdWhIZ253THFBTGRYYXVIdW9nK0MzaGVEWHF6bTd6ckRuTFkvYXNrY0E5NEFmQVA4WXVBRDBnVDh2NEU4SDZIN2dSZUxCV1lmVE1ST1hWY09rYU40emdmL0V3c05Ua0pJZlcxcDlWQUlrSWlDOER6STQ3MXZGQU9kaUtTUmRKUDhIMzhxSkNKWVFDQ1VDNWJ6R1ZpMndyalk0NjFBQ2JoM1ArWDkvZjRkLythVXR6dldTNVVUTGhraDJXdEJNalF0dDJSVTVEeTRJamt2SFJoWmFZV3hPS0xFaExzeTBqQ1ZBUjhkbTFRWXdIaG9IOHpvR1NtMmhhY1d1M1dOWlpwRmg1SThwczhLcFR6dzhWbjZkRHFqZFI0OTQ3ZFh2OHZsZitCYzRITTI0Y3NuVDczVVlUd3o5UVkrbm5uaytmTy8xNzMvdDhIRHZINFFZR0x0dFNUSS94WmR3UXNRdUxZUWdUcDJwZEc5dmQyYzhQcjU3N3Z5RnJjRndRSy9YbTNmeTduOCtMNlpId0Jid3JJTlZEKzhGenoveUZidW5EdTJpTXZXbmt0K1VDQWZwQUhjREhBajRpOEJtU3pBOEtUR2xhTTFOSS96bmVGcE1qUTkvejhEM09MRSthQUF2MysrQjlJSDl6WWM1T05ybGo3Y3VoS1pwUjduUlQ2UE5HcDZvMjJROTNvWldiaWNLS1p2R1lwb0l5MjdxcGkyN0lKR0IrK001Zi8rMVhkNDdxcGExbFdyM3lDN0VzV1BUT01yU1J0Sk80NmdyczhSSGVVSXI2Qnd4U0JIbUhyRkl4Z2RNcTI3dTIzNUptQmFTckdBbGdZR092ODVWYkY0Znp5VHVWQS9qVG8xTFQvY3NwL3VkeHh2OXVxcjRuYTkvRFZ2UGtWSndlRFJoT09nanBFSW5DZGV1UGhGZS9zVFB2TjRHeDdnOVdJdVJhQzJFc0ZJcTErMzIvTXB3MVFzaFRyVXFtQnMzYis0ZkhSMisxalExVWlvNm5VN2U3L1lOOEc2QVh6Znc3eGo0bXc3K1BSODMyV05pWHpBNTlldnBxZDh2L213RTNBZitud0grVm9EdnRDM2g4dkpZdk5JUUFrVlorcW8yWDJuZ044Tko5bXNBS3lOak1JU1BjQWFKTDBKTDVUM1NOZ0hiZUt4cHVkQXRQMEVHbHFVVzdlalVHb2QxSWJMYm1vZ3diVjBmNDhUSHc2MkRnbjlRNy9HbnJxL3ppWE05Rmp1cmhRdVViT1dCckhGTVM0dnhnVTRpRWJTSTA3RFl5NGZsSEo0RjI4NUIxY0E0U09pbGRGYzdrQ2k2dllRMDE2MW9TTURaYUp0bVRmeFpUV1d3amFjdUcyd1p5MFhYY3NQOWo3bEJ4QWVVWGtvSWJ0Kzh5YTBiNzNMMW1VK3dmemptN0prMU9ubEdhUzFyYTZ2eStoTlB2dkxkNzYzL2Q4ZWpvNFVuZVhQcWhnOUprZ1JhNStBUVFoQkMrQkNDQTB3SW9TNW0weDFyYkUwbnovSnVGNTFtL2xTSlZweHFrTzNwV2NVSDlBVGlGRHlyT2ZWemZBMFlCL2pyd00rS2FPQWxGa29tTG5qS3lyeFp1dkFmT3RnNUJVWTBSTkYzTWlDVE1QTWZ2UUJabHRYT2htQnR2RE9yeHNmbFhvdjNqcVBUTm9PWXFPUlJscGI1M0ZLVmhxWnFzTzNTUXJYdWRXRWhQQzFnZDE3eDkxL2I1ZVpvbFQveDVDb3JxYUlJanJxSmNCWGo0dTZqTXA3ZG1hVzBudldleERWUjYxY0tFZW14THVCQ0ZHa3Vxb0R4QW5tbXp4T2ZPc3ZHaFFHRDFRNUpKa2xUdWRRTGhrZ1FhcG9ZekkzeDFJMGpHRTlkR0twcHpleWc0SGluWUhKUU1wL1UxS1Zkb21oNXJGbGZzUFFDVVdtK21zM2MxNy8rdGVMYVU4OTNSL05HemVZbGF5dERxcktpMSt0dytkS2xaNTU1K29VcjMveG5YNzJ6ZURvcFpWZzhBTEs4dzlIUndmTGJDU0ZjR3lUMmVIUjgxeGd6VHBKa2EzTjlMU2dsRitYTnZBMlUrbFF5REk4bGdjY0Q1SFN5dEtleTFlOENqNEF2QjNnWitFd2dYSGJXMFJoL2YxcTdmNytDMTl2dnVlQjZlQzBJN1VDU3VmL29acEFBaE1aNDZ4eEd0ZFlFenJSOVI4c1Y5eTNqcmpFT1V6dnFNbEpBNjZxaHFwcmxocmxsMEVZbGs1UldJQTBDanEvZlB1TFJwT2FYbjFwak5aSE1heGVPcHRWb1Z0bFIyZGhRT2Q4a1VzMHFHNTU5TUF2OVNSbDdET01EdFhQWVZtSFFlcWdkbkwyMndvdS9kSVZMVDYvUjZTcHNnRVRKcFpJSG9YVnBFb29RMGhiQ0VpM2NuUE90Q0lKRE9JK3RMT1A5a3NPOWt2MUhNdzd1VHhqdkY3Z3Faa1hIeWV1S20ybUJncWtqZlBPdHQ5KzZOVDdlLzlOWmYvUFMvdEdFNjFmUG83UWlaRm5ZV0ZzYlhMbDg5YVh2ZlBjYjM3RFdxbFA3eWxpbTFkRTYrdlRuMGVaSkM5aTMzMzdyMFpkKzloZEhTcC9mNm5RN1NacW12Vk1IZTVHVkhnK0lINmw0cmtHNHRjUUZ2MjlLdm5pdXU4Qi80ZUMvcXdLdktCditWUk9jYlFML2NPTERWMC90TzJvaVFkSG5Xb2JDZU9hL1gzWHlFY2dnSUtUd0ZvRnNPUkkyWm9NUVFQb1ExOXJFaHIycWJMejlUU3l0bkRVdGl5NSs5TXVOdVlnUWg5RGFWNkVDdDBZei91SGJocTMxSG9sS2JoODhMUC9qeWF6WkNRRnBmSkFPK2FuR3VCZHNPSUZtZjlBanlSVFhYem5MaFdzcmRIT0pWQUlsSkZuclhlRjhET1lURFZ3SklzSm4raWtrMmpPWkcrcGEwWkVaUGpIa1dyQjJ2c2ZsNTllWkh0ZnMzcDN3OE4wakRoL01LT2NSWEpsbEFtcElwYUtUcDgyOE1kOS90TFB6OXYwN3Q1NTQ5dVd0QzBmSFUzbjVncVhYNnpKdWpPZ1Blc21GY3hlL2NQbnlFLy9vNXMxM3B4R2U1UmRFdi9DWC90SmY0aC8rdzMrNGZGMXJxNnVNeG1NZkZZNUNlT3V0TjNlS1luNHpTWktuKzRPK1ROTlVudzRFSVVSSTA4elhkZjNqcHF3QTNQN1J6L3p4RnN5MGg3ODA4RThubmxlRER6WkVDWi9GLzZ0UDdXM0R6UGcvV1BuK1lZdUt5eGRXdWZ0ZzlMNC9LNlpOV1pWK25Bb1puV0xiRFoxb3NTS2h0TEZ6YkJ6emVVTXhyV2lLQnRjWXZJbmpvaWpoRXlkTkorNjJweTBMSU1za0lkVWNDWVd0M0xmdUhkVGZ4bmtIcUc0bnV6TE0xQmNiVTNhY0Q3L25hK2l2NXB4OVlvaVdDeU1lUVJEUStFQWlGWW1LNm9XNkZhN3pCTFFHNFNMeFBsR2dCNHFwaW1Vak1tb0FheTNwRFdCdE5XVjFvOFA1cXlzOHVqdmx3YnRIakhkbU5NYWdjd0ZWUUVtNW1xZjY2bXhhdnZvYi8rUTN2dmJFVTgrOVpFVG43Tkh4aEszTk5TYVRHVmtuNDl5NTdXdWZlUEdUTDl5OCtlN054VjVQQ0NIVzE5ZUZ0VGFjR09oQW51Y3dIb2UyeEhMajhXUmVGUFBkc2loOUo4LzE2c3JxWm16emhBb2h5QkNDY002SjM2ZFBmcnkzQ28vTks4TEpnaDhOYUIrYitkUC9iOUUzZVJWbk51L2I1djllancvVkZLdmZUM24xMS83UEM3bjlaYXJmdVRzcHBwUG1UdDIwdTQ1MjYrMXNvTEd4UHpDMXBTd01WZEZRRlUzc1BScXo5TG9UQ05SQ09iRGxNQ3dGR05yeUs4MFVTWmFnRTNWc1N2dGRuSjhCZGFJMVcrdURYMVJLUHVsL24rQUFXRDNUSmU5R3hiL0doUmFqNWJFdGpFVVFGVldrRkdTcFpwZ25ERkpOSnhFZ0F2TXFNQytqbllLUUlET0p5aVZKSXBFaVFyd0hnNFQxTTEzT1A3bk85VTlmNElVdlhlYkNFK3RrZ3dRdkE4NTVsV3IxWEtwbC91b1BmdkR1N3FQNzczVHloUDNETVZJS3V0ME9VbXRXaDRPVmM5dm5YaG9NaHIxMk1hc2lkakdJSzFldXZ2OHdxY1c3aFJkQ1dPZDl0YisvZDJpOWMydnJhM0o5YlgyYjkzdVhLMnVOK0hFUWt0K3Z0RDQxMEZ0bWtGUGxWSGxxWDJPa2xFNEtFWFFjUytQL2dOL29ReEVnV2FxNXVENUExWEQxQy84dVNzdlRDVm1HSm9qNjJBaGJ4d1doQ0N5WGdvMzFWRUJSTzZiamtuSmU0eHNETGdvbnlDZ1JoU09TbEt4dlllcytZTDFmZ3VPU1JOTHBaS2hVKzJEOTl5ZDd4WnVMRDJaclkrWHFvTnY1K2VCRDhudXYvK1BBdnJlYVI3Y2x3TkhhR2JUV0FyVU4yQ0JKRWtVMzAvUlNUU2VOcXVWU3gyRFFtVVFyU1NMamY5TkVrYVhSWFVraVNHU0NWb284VFZnWlpwelo2ck42WVlWTHoyMXo4Wmt0T21zNWRkMEVRamlYYXJWbXJaMTg0NXUvOHpYaG10bGtYaktaemxsYkdTQ1VwdGZ2aTYweld6Lzc3RFBQWHdWU0lVUWFRbEN6Mll6QllQaitURjRXd2NmMHUyeWtIejY0ZjZPdTYzTGp6THA0NXBtbjFwVlVuVFpBc2xPQjhvY0pFajRBNXJiSUpMV0lYMGFBVlVyNTFlRXdiSzZ0aFovMEcvelVRMDB1YkE2cEcwdVdLR3JueEt4c2hITitBZVBwQU4zdDFlNlZEWm44WlFQYklWTnhoRnJIMGEyckhmTlpUVEd0bVU5THlxTEcxVEZBRm5UWlZoejlaRmZRTnJPdHl6QkNRcmVUa0hVenBOYlQyVkg5OTQ1M2l4OENRUW9oTHAzZCtITmF5Uy9ONXdWbFpZVDdjY0hScnNFdlByUEI5dVUrUWdxU1R1UXNlQlEyU0h5SW0vaCtxdWhvalZZc0ZRSURVWVp6SVZ6dENLMVdmUHdobFZRb0laY2NjdWVqN3ErU09zcmdLRW1hcDNnWG1PeE1VVUlrTm9Udk5OYmZMb3I1OUJNdnZmUmMybDNkeG51eHViSEt2S2p3M2djOHZkRm85TzZiUDN6OXJaTkRHUHhYdi9xVjhIZi83bi9BZERvQm9DeXIweGV2QWhMdlhQV0pGMS8rMHVyNnh0bEU2b0cxOXRZNzc3NTlQMFIzV2ZkN3dUeitzRU1iQ1NHSlVKYWdXdlBXcXE0cHFpcVczeCtGQVBuVkx6emY4b2tGczdKaFdqV2lOazc0RUZRYkhMbUlzSVAraGZYK0o5ZlQ5SC9GMkdTeldTMGFHZE45MHpoTVl5bW5GYk5KUlRtdmNZMGgyTGdRVkZJc2U0MFRhWmdGODZ6OTFDU2txYVRYeVpDSnhsUmgvL2pCL0w4MjFoOEFEQWZkelV2bnp2d1ZZK3o1dXE0cHFrYll4ejRESVNIdENKU0NYai9qeVZlMkdHeDJTRElGaWFSeUVGUnJsaU1GbVpJa1FwQ295UFFMcmFpMjlTNEtiaU9XcFdDc05RV3lsVGdMN1JMWnVNV2lVa1RwL3hEd1VvS0lsZzlIRDZaNFk1RkszcXlNZTMxZUZNVlQxNjUxTDF5OC9NbDViZFgybVRXRUVCSEVhSzFxakoyLzlmYnIvNnlxcXNVVzJna2h2TmFhc2l6YkpuMERhNjN3M2kvMkZtb3lHVGRibTF1cmdlUlRHMmZPckYwNmQrR2xLNWN1ajc3MzZuZmZjd3RSNHZkUHAvNW80QldMZDBtSWY2NEkvS2tOa0ovL3hCUGMyeC94OEdBaWFtT2xjMTZHRnNiUVpvNCtNQVE2RjljR256d3o2UDVDS21XU040R2RCeU9tUlhUMkxhdllsRmZ6R3RzWWhJdVFjaW5GOG9EUjZscUZjR0xCdGlpdElwc3dJVTBUUktJNTNpbWFhbUsrNHVQc1hWNDV2L1hwOVpYQnIxYU55YTB4b3B4WDJIQnloU0poc0pvd0hDWmtQY1ZuL3NSVnpsOWZBeVhRdWNJcEJUSWFUa284ZVJJUGVMQXVidU9EaXlhZ0luYVhpeUFPQkJJcENGNjBaV0VyRmxGWmZCTUlyYWpDWXVnZ1pKUWhjaUdLVHhkSGxTaEhoWlJDRnFYMXZ4MUNxQVZoOXNJTEw3NXMwQnZkTEdWamZZWHhaQ3FVUU14bjgyNVJWZCs5YytmV28wWDVKSVR3V1phSHYvRTMvZ1pmK2NwdnM3YXl3WFEyUml4dUdSRE9PZkhlamZkdUJpOWRZOEt6NjVzYjI1Y3ZYSHJoaWF2WEp1L2VlT2ZtdkpnYmZoVG8vTStkUnZ4akNBTStTZ0Z5YVhPRjMzbnpMck95Rm1WdHBQTW5XWU00eU9rRHZRc2JnMHVmdUxMMUp6YUhuUy8xTzhrMXJiWE1zd1JsQSsrOHM4L3VveW5Wdk1ZWmd6VVJheFZjcE5LcVZoUk55Q2o1RXdpdDY5SENTeUxlL0VtaW9ubE9xakVOalBiTFI5NzUvemJBVkN2VmVmcmFoVCtubFhyRkdDTzlOYmk2UklaQTJscU45Ylk2bkgxaXlNcHFqMmMvdGMyMWw4NWdna0FsRWhKSjBsVU1zZ1FSQWxKTE9qcVN0clNTSkVxU0tCM05MZ1BMcVZvZ0xKMlpuQS9ZMmtaREdSY0l0U2NZRzFISUFvTDFKQ29Lcm1tcGtVTEdpZG5jTXJvL0FpSHVsTmIvRnRBOGVQUm8rc2tYWHp5N2NlYmNDOFpZdVgxbWxicXhXR3NKeHVmVDJmeitHMisrOWxvSW9Xa0R4SjQvZnk0a1NjcWJiNzdCYkQ3aDB0bkxWRTBsdlBQTG5xS3FxK2JPN1J0dnpTZkZ2YnB4Rjg5c2IxMi9lUEhpcDU5NytybHVNWis5ZXYvaC9lS1BJNVA4VVR4K0tnTmtwWnN6cnhwUk5WYWN5aG81MEFQNncyNjI5WVZuTHZ6U2N4YzIvbmZicTcyLzFNblNKNVZXV2lmUkhVcHJoYmVlMGFoZ1BHcW81elp5UDFyMWpJWGhmZHdPTGd4bFdpWmlPOUlOeE9CUWtVV0VSekhhcmF3dDdLOEYrTzBBZm50ejdmekZzMmYrSlFIYlBuaUNNeEFNZVFKWktnaDV3dlV2WG1MNzZqcmJsMVk0Lzh3YVRxc28rSkJJc280aXpUVGRUSk9tRXEyaUttQS9WZlFTSGZjVldwTW92U1F6ZVJFMzhqR0R4TjdFRlE3UkFHM1EwY0pjSEFJUllwa3FpWDZKbWdUckhFMXBPYjR6SW9Td1d6bi82eUhFTGJNMXpleTU1MTc4ckFscXVEcm9NUmowbU00S0pDaGpqTjNaZmZpdHc2UERHU2MrZm1GbFpTVnNiVzN4NE1FRHRqZTJNZFpRTi9VQ2FCT0FZS3l4RHg3ZGVXOXlkUFRHZEZwMWZSQVh6Mnh1ZlhGajQyenYvb043M3h5Tmo4dkhNc25IQWZMakF5U2ppSmxEbnNvY1BTRVlmUEtKc3k5KzV0clp2N2E5MHZ2WGxCVFBHT3VTaGZobjlQR1Q3YmhSa2lvWjNhQXFoMmtpTUhCeCtGdFlWTVJUdFl6QkJYcFdDRWgwVkFuM0l0YnhzMk5ETlRXdmljaUpPQVRDbFF2YkwyeXVEZitjOTY0akJBaG5FQUk2blJTdEZMMHJRNTc4NGdWVzF6TzZxd21pcTNHdDRMTktCV2lGeWhScEtza1R3U0RUWkZxd2tpVU1zNXlrTmNYTWRiYkVpV25abGt3Q1V0bGE1MGlKU0dKbWNHM1FTOVdXWGtTclpSb0lGbW9mSjMydXRoemNHZUVhYzc5eC9Mb1BZUzZFOEllSGg1TlBmdUlUVHcvWHpqd05JV3lkV1JmemVZbDNscnBzOHFQeDZQczNicjU3WHdoaFF3aTJhUnAzKy9hdGNQMzZkZTdjdWNQRzZnYlcyUWp0ajVxZ3B6TUR4K1BEM2R1MzN2bnFkRHgvZlQ0djBxWnEranU3RC83cHdlSCs2UEcvKzFPQjgvdHBESkJIeDdNRnNIQkJpdXBjUDdkKzhlV3JXNys2bXFmL29qWHVDV09zWERncUw4enJnNDF6SFNHZ2x5V3NEM3BvS2VnbWMvWW1KVlVUaGVTVUJxZEI1Q0RieVZDcnp0L0svNENRc1RGdUdxam1ubURZazBMOGZSUEMzUVdjcVpPbmw1V1NRNlhqQkNra0N0bk5TYlJtVXRXYysreFpWczlteU5wamhFUWtLa0o0bGNDS1NDc2RLRUVuRWF5bUNWMnRzTjZRaE9pOW5xb001MlBYN1VQOFNaV1FhQ3VSd1pPbkFoOGtUa2RSSE8xQldORk93Z0pDQktZemk2OENNZ2hjRFFFWnpUWjlpR1Vlb3ZLeFpESWhCRjlXbFh2bm5UZC82K3pGSjc0NG51aTF1cTdwOTd2VVpSbFdWMWMydDg5c3Y1SWt5YmVNTVFtZ3ZQZXkyKzM2bzZPakFQRHVuWGZZV0ZtbjErbUhFSUt2Nm5LQjIxcTBCVW5WVlBWM1gvMzZmLy9ldTY5L2JYMTFJM2wwOFBEUmo0T1ovTS85K0tuYmcveXJQLzhTMW5rUlRoUW8wMjZxaDg5ZFdQL1h6NjRQL3k4cVRhOExLV1ZBTHQxUW8rSzNwYXFhMkdlMHVDY3RCWjFPem9XdGRhNXRyM0ttbDVFS2dUTlFsekNmd213V3FPc1dldDZDZmF5RG9vVHBLREFiQlh3ZEdPcmtJTXZ5bTRzUFVTc2xVNjB1S3ltVWtoTGRtbU4yT3pscGtqQzgyT1hzMDBNNlNSd2xKNWxHNnpoRmtpMEJPMGtFeUlEU2tHcUxFazFzdk52emxDU1NOSWs3a1N4TmtFb3V4U1NFaDZJU2VDZGIxeVNKRkxIQ1VpRmc2bmJMSGdKTmFTa2J6enpBdkRFWWEzSEdvV001MXB6U2xhaUIrcC8rOWovNTl0SEI3cXZ6c3VaNE5HVmwyRWVsaWVqM3UrcnFsU2QrYm1QanpFWjdjU1VoQkZuWHRWakk2d0FNQnV2TWlpbDVuZ1d0OWVsbFh0VXU4RXFnbVJTVC9kc1BiOTJybTdvNU5mTDlPRUIrcjhmR3NMc1l0UzZVWEpKK25wN2YyeC85NHJ0M2Rqb3FTVUtuMTFreXg3eHRZZUFtTGkxRXUvbnpRSllxZW5sS0o4OVlIZmE1dkxYSzVmVWVxNmxFQTlaQ1dVSXhnM0lXZzZZcW9KaENPUTAwRlNnZkc1OWNzTmxOOUxuMlF4UlpxanVkUEQwbnBRcUpWa0VKMEVxUVpRbldPRmF1RCtpdkpHQ2lOMFhTZWdPbVNxQzFJTkZSSFVYcGFCWWpvck0waVc1MW5WS0ZrdEJKRlVtN1JFelRCS2wwOUN5SkppYnRKa1NjYk5uYXhXY0ViVUt1SloxQkFncThqR0oxVFcxcDVrMTdrWWhZbVoxYXN1M3RIeHcvdW4vN1d6SzQ0dkJvaWxLS1BNL1JlY2JxeXNyVlZ6NzU2WmNYbDVjQUZVSVFCd2NIeXgvaDl2MzNLS3VDRUFLRC9pQW9xYnlTeXAvK0htMncxQUp4R3VvZWZ0cXl5RTlkZ0h6NzNRZW9pQ1ZaTHB2NmVYcTJNWDdqNXQwZFhudnJscGdXTllsV3FOYlNMTFI2dU5aNVp2T0syYXpBR29zU2dsNnF5YlZDUzBtYUpHeXM5TGwwWnNqNVljYUtsdWdReDZldUFWUEdMOWZFUDFORVRtY2lJQVEzMU1KZkVDS2l0dnJkL0Z3M3p5NURFRklpdkxOUnBEbUFTNkIzTmtNUjhDYTZIdVdwSUZPQ1hFZEpVOSt5SGlzcktLeG5hZ05LSjJTSklFMmlYWFBBdFJ6MmdBdVd4bm1rbE5FblVTWlVWbElZUWRVeUVLV00yVVRJNkZnbGs0ZzQwRWtNU09takowaGROcGpTWWhvWEVCU250dEJMeU1iWHYvNjFyNXRxZHZkNE9tYzBuakljOUpGS2hkV1ZZZi9KYTA5OWZqZ2M5b0drSGFLb2h3OGYvc2huT1JxUE9Ebys0di93bWI5S0luVUF2QlRTU1NHdEVNSUlJWXlRd2lpbG5GTEtLNlVXR2VmakFQbHhqMis4Zlg5QlYxMEVpTTVUZlJaQkpxVGc0ZTQrMzMzOVhlN3RIaUcwSk05VGtsU1JwaEdzQjFGQzAxamJHa1Y2WlBCa0tqclBLaUVaZExxYzNWamx5cGtobDFZN2JQY3locGttYVRWcUUzRXlOdE1ueUI4dENTdENSaXhTbmlaYlNvbzFTZnhCZlNzZ1hWVU5NaE5zYjJZa3hxT2tRTW5JVDFmQ2s0aEFxbHNnWlZ2VEtjQUV5Y2c0NmhEd3dxTzBKOUZFd1UwUnM0enp4SjVFcGxSQk0zZVNpUVZEN0VXVTFDQVVQa1N3WTdSYWk2bFdLNEgwMGZNdkJvY053VGp2UFhmQ0NTOWpBVU0zcjc3K2c5dTNicno5MWVDOTJ6c1kwZTkxU05KTWRIczl1YlY1NW9YTEY2K2ViUWNvaWZkK3FTUHh3Z3N2L01obituZC85KyszbUU3STB5eWtPdkdwVHJ4QWVPKzlkODU1NTF4d3ppMW9KaDhIeU8rekMxMHNRaFdnTXlVdlNTRVMxZDZRVlYxeisvNE9QN3oxaUlQeERJRWdVUXFsWXgrUXBnbkpRbkxTV0pRSWRCSkZxdVd5RkVtMHB0K0xnWEx0M0FiUFhOamt5Yk9yYlBZeWNpV1dJS0ZGd3ZjK1NHdGNaeEc0dlc1blBRUmtuSEZGZUxzZ3ltUEtORERJSk5yRlBpaFJBaVVDQ1FFbEJEb1JaTGxxSFpNaVgxMGhJVVFzbGhBU2o0Y1dZaElWVk9MR2ZXNEY0eVl3ZDJDRkJCWGZrK0FsWlJPNTdjWkJZeUllemJlN0hRRUlIWTFqYkdXQUlFS2dhYnk3RlVJd2oyV1JDaWhmZi8zN1h3MjJHaCtONTBzWFhKMmxyQXlIVHp6MTFMTXZuK3BEVkFoQjVubk9HMis4d2VPSHZMSTFwdldsRHlIOG5qV1VjKzdqQVBtRDdVS1hORXRaTm5icVFuQ3lGU01PTFdmaThIak0yN2NmOGRhZEhRN0dCYzdGUU1rVDNZTDFOSjA4WGNxLzVJa2kwUklSYUVsSjBaSXN5eklHL1I3YjY2djBlbDFxOXlNaXJTR0VZSzExNC9hS2s2bFdBeCs4OUMxR2FnRXY5ajZnMHppT2xTNGcyd1Zmb2dSaExtbkc4ZjhwRlh1SHBsVnlGMEtRcW9ST2twR3FGQzBVQkkrU0d1ZGhXalZNQ3NmK3BPRndWbE5WRG1HaEV5UXFTRndWbUUwOTR4b21CZ29ycUt6QVdVRndBdTlqTURyVE51OCtCTy84YmdqYzU0UjhkTG9YYVg3d2cxZmZmWFQvenRlYXhuQTBudEx2ZDVGYU0xd1pEcDY0Y3UwWHpwelpYbWxCaHpxRUlJVVE4dC84Ry8vbTcvbkpsazFGYldwcTArQ0Q1NmY5OGRPTTVoVXQza2dOZS9sR3Y1c3JpQVkyY3NHOEN3RnJMVWVqQ2UvZWZjaUR2V09NOTVnb0o0S1dpbFRycFpHS0ZKQXBSWnJFY2l3R1cyUWIwdkxXdFJBNFlyT3Z4YkpyRkFGcTQvMWVDNFlLMWpyanZRL09PdUc5Yi9XWDRyZzQ2MmxFaUdqaVJJU2xjdnpSalpyREJ4TmM2NDZyWmNTRDFjN1RPSWNMbmt5bjlMTWhpcFRnVTlhNno5TlVYWGIyeCt3ZlRObmJuM0owV0RBZlYxUXpRekd6ekdhTzBnbHFCUE02TUM4QzVkd3hxNkV1QTFVVEozTUlpU2tzTW9DcnJmQSszRGMrN1BGK091c3lTQTZQUjhmMzd0ejRhbDBWazczREVWbVcwdXQyNlhRN2JHNXV2bkQxNnJYelFDS0VTSVFRMGxvcmJ0MitKZmdJUGZSUGIyekVMZXhLSit1YXVuNVI1Nm5PT3duSG8zbHNBa1JjaEFrZm9SZDE3Ym43Y0orRG93bURRWStOMVI2cW04ZGF2ejN3Q2tXZUs1UjExTVlTaEl5YVdTR205Z0NVZFlNZ0d0TVRUbjRTRDd0TldKTGJ2TEcyRGlFRVkyendRWWlXUm9kV2txeWpFUjZFalR3U2xZS1pldzV2VEJtK29BaENrTFJMU2hzbnZWU054U1FwdFlDZDZZUnhVVEtkMXpqL1ZlcmFSQ1NBOWNnUUVFNWdnbzlVNGpiaFJsL0VXRko1NS9FbVlCUjRvUW5HZ2cxNEwyaG1CdXM5OWJ6eHp2bTNqQThqVGpqZWl5WGRjdVQ3OVc5KzdYdlB2ZmpLbTZOSjcvUFRlY0hLeW9EcFpCSTJOOWEzbjdyKzlHZS8rOTEvOXJaekxnTXE1NXo5amQvNERWNTU1WldQQStUL1h3OFBwbTVzUFp2Tm8xbUwwaFIxUTlJcWQvdFRWWmx6bnZHazRIaFNzcnMvWm4yMXo3bXRWWHFkaER5UEhJbXlObmp2U0xXS0FTWWxXa2Z5VWxGV2xHV05Xc2p6dEYwb1VwQVA4L0cwc3FPb0NFRUkzbWx2blpBNldxa1JGb0xYMFE4eHVGYVJVVWU4Y0hYSFU0OHJrczRhZUpaYjhpQmlRMTAzZ1dQcm1MZzVWVlcxcnJVUzY0dW9GR2tEMGtNaUJGNUdJNTdHK1ZOKzVlMnkxSGs4QVJLSjhKRVQ3eDI0eHVGcVJ6T3Q4SGlhd295Y0MyOTY3eGNhVjZlRkU1YTg4VnUzNyt3OHZIZnJuL2JYdGovNWFPY3dmL3I2SlpJMHBkUHA2Q2V2UGZYRjFkWDFmM3g0dUQ5ZmxGbWowY2pQWnJQd1VRa1ErZE1kRy9oSldjOGM0UWZPT2pNWkZkamEwZTEwcUpHVUx2YnpzbFVqVVFxa0VnZ0NSZGx3ZStlSTc3NTluN2Z2N0hNNEthaU1KZEdSU0tSMUpCc3BkWUtRcmFyb3l3SFFJSkE2TnZwS1N6YXZyQTdXdDN1OXhieGVFRnhSUkUycExOR2NIRkhCZkd5aVYzZ3J4NE1SVEI4NGxKUWthUjZoSDBvUUpQUVNnZkRRVklIalNjMjB0RFJPWUszQVdaQStNbElYeVBDRndTWE9JMzJVSGZJdHljdTNNa2UrY1VqblVkNUhIL1VRQ0VKUUhNeGJtckhETmY1aEUvamhLVXpWYWVuLzB6VFcrcXRmKyszZktXYmpPL3ZIRTBLQTRjcEE1SjFjcksrdVhYL2xrNSs2c3BobXRjMjZjTTd4aTcvNFN4OEh5Qjl6bDk0S29BYzdhK3hyUXNwNkFWK2ZUVW9TQkdtYVVBZEI3VnIvanhab1NJdkVEUUhtZGNQTlIwZDg2ODI3ZlBQTk83ejc0SURLZW9iOUhtdXJRL0lzUXhBOUI0dXFqdktpTFpBeFhYQ3RPd245emJ5YjVhcTNDRnpydzl3WTQyMXJwNHlRTGZaSUlJU2tpbG9RTVJQTkZlV29abld0ajhna1FRcVU5WFMxSkpVeVN2YkxxT05VV3hQMXZBZ0VFZnVTRUNMOFJVcFFLcUNGSTVXZ1pJUzg2OVllMlpwb1hTMGg2bVZaai9mUkY4U1dodmxSZ1ZjQ1o3d3psWHVqOW43M1ZMYndRRkJTQnZFK0lYZWE5MjY4ZSsvUi9WdGZyK3ZHN1IwZWg3VzFGV1NTMEIvMHoxeTcrdVRuMGpUdHRoTXRMWVFRbTV1YjR1TU04c2NaSFNmWUhRdTRVV0Z1TlM1ODI0TWxSTCsvcW16QU9GS2xzRkpTSXFOY1o4c0pYK3BOaDhXbzBiRXptdlBhblYxKzU4Mjd2SGJ6RVVmVEFxMGpuZFU3UjFVM05DRjY3eVh0aUZoS3dlclpQaktSenRaMllZYmtsSlMybTJlaEttdU1zVXRic2hBODlkeFNsTkZJeDN2d0U4bTZsS3owTlRJTHBJbGtRUm8yTGxvcUtCbm81VG82N2dKQ1NVTEwwVTFTVFpKRjlHKzNvK2wzTlN2OWxGUUxNaG43bWFUbHorUGJDVjBMMnc4K1lLMm5HbFZNSnlXMXNaaktGYlZ6dnhOQ1dLQnlsOHkrSnk5ZElNOHlUcjMvVlZuVnhadXZmLzgzNTlQUnpxUGRJNkdWb3RQdDBPMTIwdTB6MjErNmV2WDZtY1hJRjFDajBVaTg5dHFyL00yLytUYy83a0grdUdLa1Zla3pnSm5YNWlCVjJYL2E2M1N1MmFLNnNuQ2lyUnVIc0o0azA2U2RsTkk0akxIb1ZrUHFOTE4vb1E4VmZHQlcxcnoxWUorYk8wZXNyL1JZNzNkd3hsRFZiVG5pUEhrN0t1aXQ1S3llRzZDRVFFWEN2d09vclJ2bFdkSVVWZE10cTVvOFQwRkk2c2JnNTRKaTVwQTlSZW9GZW00UnBhR1dnbzdNVUZvaEVuWGlrV0VEblZUU3lWb2RZQ2ZvSnhuV04yUmEwYy83VE1vamFtTXdWdUN0cHFjM2VUamVZMTdNY1I1OGlKNG4wZXdubk94QXZNZFZqdEgrRkdNTUtsZVl4cjFXTnU3MVUxbkNDU0ZDbERkSzZIUTZWRTBUUWdqTE11czczL2xuTno3emhWOTQ5WGk0ZHFGcURCc2JhOHdtVTdhM3Q2OCsvZVF6VDcvenpsdjNoQkJKQ0VGWmE5MWtNZ2w1bm9lUE04Z2Y4ZU5YUC9NTVQ1M2JXTmhTK0FYOFlkanJOR2MzQjZyYnkyaE8rVzVZSHloS1Exa2FPbHFTcElwQ0NzcFRZeG5QKzRFK1VWa1FhdXQ0Y0RqaGpidDczTndiNFp5bkk2SWVyaFRScXFoL3BvdktGTjc1dXFuc2ZISGJsclhaTXk0Y1pvbG1QaStwalVPcUJHc054YVJrOUtpSVM4RFNVZHdmVTVSMWhMbDdnVXdrc3UyQnRKSjBPaW1EVGtJL2xheDBVamFIWFRaWGVweGI3N014MUdSSlJUOFhERHVhYmdaSzE4enNFUTZMbFNLcXk3Y3dmZHZDU1hTMGxzVTFucVA3eDh5T1psRXhSWWlpdHY1L3FwM2JhdysvalJBUVFpOUxnRURaMkFnRlBubi9tL0YwT3JyejNnKy9WbGZsK05IT0FiMWVoeVRMUXIvZlg3dDg4Y3JQOTNxOWZnaWh0VGIwTW9SQTA5aVBTNncvcmhKTFMvbStpVXJkTkVlalVURlJDUEpFWXNTSldHd0RGTlp4UEc5b3JFZkxxRE5seGZzNzBNZTkvUllEWlI4Q3J0WG1UWWpxOEFnWW5zbEpoeHJuSGQ3Nm5lbWtYZ2lSMmNhNFVXUGRDQ0dDRklUeGVBNGlBZ2x0WXpsNlVGRFhIdi9JTUhrNHA3S1d1akRVOTByTVRvV2IyMGpHVVlJMFYrU0pwSk5BUHhPc2RoWHJneTVQYkQzRFNyZERvbXJ5eExQV0czQis1UnpkRkJ3VGdxaElGU1JkRmJVMFd6ZFhiMzNFbHhuUFpIZks2TUVvTnU1Q0VCRDNTMlBlNHVUdGkrNXdJWUxLM3I1NUN5RUVpZEtoRmFSMmk3ZjVLMS85SjkrWWpRN2ZmTGg3aFBlQlhyOG5zandUbHk5ZCtmVFdtYk1MU1ovV01FckliMzd6RytMakFQbGplRHl4dllLSjA2U2xDZE84Y2Z0RjFkd2V6V3VrRVBTVXdJdFRuekJ4OURrM25zSkVYd2pOaVZibWFZN3k0eUt3cDIzS1FvQWdCTDIxbE01YUNsS0U0SU9aelpydnp3c3pYZ1JJVWRYanVqRzdVZ2lSYWdYZTBWaFBFQnJySFVjUFoweU9HcW9EZzJzaUM3Q2NGeHgrOVlCNy8rQWhkLzdMQjl6L0gzWTQvdjRJZTlDUUtFbXFCWU1NVnZLRVRpTHBacHBCcDBlZWFRS2VjWG5JcE5xTElFWVJZbkRJUUtKREZIZndjUnlzSWpZR00yOG85dWY0eHFHa1FDcEpnQWVUL1dMaHYyRUFKNVVrNjZmTGhxMllUN2w4K1RKWm1yRjRhNFVROWNPZFIzc1A3OTM4UmxtVTltZzBZWHRyZ3lUUFdWMFpibi95NVU4OWY3b1BjYzZLYjM3ekcveGIvOWFIdXcvNXFXTVV2djN3a0p1N280VXowQUtQbFRUV3liVkJaMlZXbTg4V3pxZU9hQm92eFNrOXlWTXJ4dFBtRW85YmtYaytXQWcyeWdaQzBrOVlPWk9qdENiSkVxRVNPZDdmbWYrbjQ2UHFWbnZ6T2grQ1dCLzJ0b2ZkL0RQT0IrMjlwNm9iZ3BDVVJZbHpualRSZEJxRktSMk5zeFMxaWVOZ0MvVzRvZDV2bU4rY003azlZK1ZLbjVYMWxFUUt1bG1IRUdxTUhkUFlnc3FVV0dld3ptS2N3ZGdUZ1R6VHRHYWx0Y2Mwbmd6b3B3TGJPTVo3QmJQOU9kNDZBcDZzbXhvWCtKOTJiNCsrUml2bUxBUkdhZW1INngyT2o0cmxlL0hjczg4eEdvMklzcURMdDFBclFYbnR5V2QrUnVwczgrTDVNMHhtYzF4ajBxYTI3dWJ0OTc0OW44K0tOcUJjbnVlK2FXcnUzcjMzY1FiNUk5K2xDeEJDaEJiNVlRRXpxWnEzRU9MSUJXZ0NGQzZpb1BveWFnQ2RQdnlQKy9zOWJpWnpPbWdXbVVTMTIrMUJWNk5hcUhnUWdhcXlieDhkbE8rZUxqZENDRTFSbXpkODREQlIwVVZWaVFoYjBUcWxLbXFPNzgwSkJqeXRabkNyUG9LTUw4cTBFUDNwbzRMM2Z2TVIwM2xEaldWbUp0aFFVOXVHMnRuWWhMZEN3Y0ZIeFJVWklxY2xZQW5PSWF4RCtvQXhqcWJ4bExPR3llRU1VeldFRVBzU3BOZ2JINVJmSnl3TmNLeVEwZzgyT2p5dUNHbXRwU2lMY0VxL3lnRE5xNjk5Ly9hakIzZS92bjg0Y3ZPaVltMXRoYXpURVJ0cjY4OXNibXhkT0xVVGtmUDVYSDdqRzk5a1pianljWUQ4VVQvaXVIYmgxQkVUd3J5MkQ5T3UvdlgrYXRZZ285NVI3VnY1ZWhGUmMrcXhnSGhjUXgvZUx3LysvcUNNZUNxVlJNVVRIenhCaXRBWS84Tmkxa3hPbFNVR01FZVRZa2ZvOUVHU3h1WTIwVHJhU012bzBUNDlMcUlwajRBczBTMW9NaXJCYWFWYVlwaEFLY1hrVnNHTnJ4NnljMlBDMGNHTXNxcHhRaUJVaWxleDUycDhkTVUxSnFCRG4xVG1LTmtLeWJtQXJRekZ6SEJ3V0hHMFA2ZVlGRmhuNkNaZDhyeERZL3lyQnc4bTc1M3E3UUloaEdyV2hLTkgwL2U5RjkvNjlyZVdxRnh4YWxqU1dGZmN1ZlhPTitmVHlkN3UzakhyYTZ1a2VjYkc1dnI1cDY0LzlZbTJ6Rm8wNjBJZ1JLS1RqOGU4Znp6TitzblNVQWlDOGI3ODFKZlB2ZnZzeXh2MmplOGZwcTk5WTVmeFFZa0RxbkFTQU1salpkYmpEckhpc1F5ek1KOW9mQ0NWQXFtakFJTFFFcUZWWTBwencxbC9PamdFWUE1SDA0TjUxYnkzT3VoOFNtdXRwSW9iOWNZWXBOWlVqYU5wWWpPZWFrMHZENlJ0dHZGQ1VCdURKMFFlaHd2Yy9xMGQ3bjlkMEZ2SkdHeG05Rlk2U0NYdzBrUHFVUU9KNkVwQ3BnbGFFRWlRVWlDQ3d6Y2VWM3RzNVNqbUZkT2pBbE1hdkE4a09zTXFPNStNNWw4M2xUMU5idzNlQjhwcDg0SHZmOU0waTQvaGZZdkRyM3psdDE1OTdzVlBmZWZ1b3pOLzd2TEZMZEh0OWVnUGg1MXJWNi8vM05yYSt2OTBIR3MxRFVqbm5UOGFIWVdQQStTUHFkSTYzVVlJZ2RqYzdsdzlkN21mYjE3cWgydlByb252ZlhXSGQxNC9wSnlkZk1qdUEwcW9EM0o5UFIwb2dWaTJaVklnMjRtUVREVkpOekdpdE9XcFE3VjRPZ1BNSCs0ZGZTVkx6djZLME5tYWRKWkVKeVJKU3EvcndGcTg5NUg5S0FTOUxNVTZ0NFN6S0NteDFtS0NKVThTc2tTamhjU01QWHVIYzNEVE9KcVZBcTBsTGdSSVFLOW84dlU1NlhxRzdWbHFDMVhwS09hRytheGhjbHd3UFppUk50RkhhRnFNOEtuNjRlU2dmUE1ERUFzL0NiTEJBczFrTmgrLzg5WVB2ckp4N3ZJdkhvMm0vZTJ0RGFiak1aY3ZYWDdoMG9YTGw0K1BqL1lXTFYycjlDNzRLUlJrK0ZBMjZZK2Q0ZE1hdlAzQlNyYisyUytmLzlWOGtGNFBRakJjU2NXbGF5dXNiL1ZvYWs5ZE81ejF5eXVQRHlpdk9QVnBoY2VhZXcxMGM4bGdvMGRRRXRGSjZLMTJ5L21rK2MzRGg5TWJuTEk3WHZ3VEpXUllYeGw4UHNEWnFDYWk4ZDYxRXArQ1FiNFFhNHNTb01zOWpKQ2tiZG0xRUFjV1JNblVKRkdrV2VTbDZ6UnU2RVcwdjhJMkhqTjFGTHNscy9zemlnY1Y5cURCVEN6VGNjbGtVbkowTUNhckJKZnlJVDJaa25pSmFxZ3pMNXNRdUZkWmQ4U0pYNGIvQ1Q4VEJTUjFYVFRQUGZ2Q3AvTHU0TnpWeTJjNUhrMkM4Q0lkajZjUFgzL3oxZThMSVJiOW12dXdCc2RQZTRBc1ZFMFdnbkc5NTUvZC9NU0xuOS82VjN3cUIwSUlZVzBVbU82dFpKeTd1c0wybFRXU1hHTnR3RFlSNmlGK1RKQndhZ1M4YU5vem9OZFBHVzZzMEFoSE5zenBEdkppZWxUOWs2T0gwOXVjV0I4dk5tQzZia3l6dHRJL2x5WEpaNHkxQ0NtRlZoRzZFcnduT01mZTRaU2phY254dEdSY05CU2xvV2djUmRXMDRHQ3hGTTlXVWlCbGhLeTRFQ2RWMW5sc2k5d1ZMV1pMcXFoMDB0VXBmdVpRYzB2ZkNIcE9Na1J6YVRoa3BadlR5Uko2YVVvdlNWY0huZlNWYnBhYXZVbnhyUkRDVHhvZzRxUlZFOGw0TkdvdVhib3lHSzV0ZmZiTTVycFNTb3BpWGloblhmamhPMjkrYXo2ZlRmbFJHUDNIQWZKSG1EMFdpb3Bkb1BmVSthMXJQLzl6bC8rTi9zWGtlU2VGcEZWZnR6WXFtN2dBS3RjTU43dXNuT21TcFFwaG9nbG1hSG15UVh4d2ZTRVhYd0k2UTQzUEF6TFRkSWRkMGs0aWl1UHkrd2NQcHo4OHRWeGJlb08zVExwSm5xWFBTeW5QZU8rbER5Q2xRaXVCcld1c2lTQkdheDJOdGRUR1VsUU4wN0ptV2pZVXRZMCtKbzNGK1doSUU5cmdRQWlVa2lndEVlTEV6RGxKb2lvOHhLd2xwQVFmeUtWbWtHVExWNmVFSU5FcUlwZWwwRlZqN3o4Y3piOGFRaWc0WmNqNWg4a2lxOE5CT0h2aDZ1Y0dnK0hhcFl2YmpNWVRndldkbmQyZE4rN2V1MzM3OUs3bDR3RDU0eW10Y21Dd3VUYlkrdklyMS82TmM4LzAvb3phRU5vNGxud0xaeU13MFFVd0ZxckdnNUFrV3BKcGdaYVdMQTkwT3BvOGtVZ1pENkJvUjhtY2F1NlZGdlRYRXRJOEljbFNkRGNselpRZTNaODBvLzNpbXlIdUR0NW41UVdJYVZIT0p2UGlWWEF1U2VWVEFwR0dGaE5ycXdydkl4TnljYmlYQnowc2xwTUM2d0x6cW1aV05veG5NWENxeGxMVk1hQXE0NWFLOUZGb0c0eTExSFVUUmF0dFZILzNlSXlQRjdhV0o4eExZNTI0dFhPMGQvdGcvUCthRzN1SHh4eHIvNEFIK0xSaHJ0N1plVlEvOSt4elczbHY5YVVyRjdkbFl3eW1hVHJ6V1hIOHZWZC85enU4My9mOFF4a2crcWMwUUJaaTFWMmcrN092WFArVmxXSHlLL1NEUXNybHh0aTdRUFRmakUyMXAwWEJCbytVQ3RzcU4ybGlrMHdJNURZU2lMd0ZZMzMwQUFsUlppZkpGRHBYQ0JVYlkwbkVOQ1Y1OHFsVXl5Y3E2eCtjcXN4T2k2M05aMFYxMDlqbVAxN2RraGRsNW41NU5yRW9FNkpaVDVSMVlHRlg1cnpEQjQ5b1BUMWkzK0tYUXdVWEFtVnRtSmNOM3JmS0tGcEdreHdWSll5aW1tUkFpa0FuUzFzSjFiQXMxYnozN1dSRExZMkN0bFo3NXFBMGhyTEoyc3ZuTkZucUQ5Skl2NjlacjV0bTlzWVB2dmM3NXk0OStXZjNEa1pidytHQTQyNUhYTHh3NFpVbnJqNTU3dWF0ZHlmdDUxaC9XQnQxOVZNYUhNdlM2c1duTGo3OS9OVXovMGVkK011OTZ3bFdnVGNpaWcrNGdMRXhRSXdMMUUwRTdWa1h2Y3ZMMGtRN0FPdFFRa1NlZUd0eElGUlVOTXh6UlpKRDFwV2tIWTNTR3AwbzBBcWRLUHE5TkFUdnhlSEQ2YmNhNDkvbFJCckhQYmFIRk00RmwzZVQ0L1d6M2VkSXc0YVpON2pLeHBLcFJSTXVMTmFrVUVpaWhtNk0zWllVSllqTXlaYUxFa0pjMnJuZ2FheGxWbFNNaXpuVGVjbnh2R0JlTjh3clMxSGJaYS9pUTBETE9FNk9KcUFSbzlYTmsvNmdrMjZVdFgxdlZwc2pmcnd2K1I5MHNwaE1KNlA2bWFkZmVHNjR0bkg5NnVXellUeWVDaEZDNytEdzRNMzNicnp6bmhEaWZYeVRqd1BrajZZeHo0RGUxc2J3ek05LytxbS9xcno3c3M2RHpwOUlNQjVjSFoxc3ZZOW8zdWpuRWIwSUd4T3dMbUxkdmZGSUQ5NDZaRXZlWHZCRnBJaDJaUXVBbjJnRjE3SWtSV2dWL1R1MG90dk5tRTlxdjM5djhtMWovWnVjNENQdFl3RVNBREU2cmtaU3kySjFvL3VpbW9WK1BUY0lFWmFzeFlWbXBHeUZHMFJMV2hGdHZTZVZPckUzOEI0cEYyV1liMHV6RUtWN1hJUDNqaEFrem5pcXhqQXJHeVpGemFTc21GZVdzckhMOXlkK2Z5azZpYnE0MnNzdlZOYi9ZRnJXazhlQzVDZWRhT215cXNMNjJwbytjL2JpejEyNmVDNXBlZnI2OE9CZzh2M1h2dnV0VSsvWFQ2VzA2SWNwUUpiWlF3aDZRUGRmK0xtWC9zeUZ6ZUZmSzZlemZwSUpzZ3NhaThEYlFHZ0R4UHNvOFk4VW1OclROQzcrUG9Cc0Q0YVBUS3FvWGtLSUpZczQ4UVVSTWlxY0tDWFJhWXB1dVJwWmxqTG9kOFhoemtTVVIvV2QydnB2aHhBV28xNjdmSXJIWHNONFZCM2tYc3FPazU4VUhyVW9yWHlJMHAraHRZZ08vdFRZVjZrb0xLRlVMQ0dkZjkreld1Y1JJc1RBQ3RIZVFBbE5vcExvczlpS3hJWDJFb2lEZ0pwNTFWQTJsdHFHR0RET2kxVEpjeXVkN0tMei91MXgyUnc4RmlEaEo3ak1GSkFFNzh5bEswLyt6TWJtNXZiWjdRMXhmRHdXdU5ENTRUcy8vTlo0TWpvODFheC82TEtJK21uTkh0dWJLMmUvOU1wVC8zdHI3RE5WV1FXdHBFZzJORDREVjBjSFcrZmpvWXVUVWtsVk82cW1oYnNUVUxTQ0NMWEJXWThJVWQ1bmFiTzJjSldWRXEwMVNpdWtqcG5FQTNtV2ttako0YjJSZEhNenE1ei9KOTZIR2RBSWdkMWNIWHBBMkpQREhGOURRUFdGM2t5MS9oeEM1TUY3c2NnUXJqVSs5TjdIYmIyVXkvTGN0MXdPUWRzRFNSbWRiTnNTVFN3TVAxdUI2NFdQZWdpUkpxeUVqQmJXYlN1dDI2Q1RRdUk5MU1ZeEsydkdzMG9hWTY5NDYvTnBiYjdoNHNqM0oyMm1GMldXSGsvRzl2ejV5MnRuenB4NzVmcTFTM3BXbEhocnU1UEo5TjdiNzd6MTVvZDVtaVYveWpMSVlucVZ2UERrK1JjNldmSmNXZFhValJWMTRiRFRzRFQ0Y0cydjRYemJjempmK21kSU1pVVk1dEYzUTZlS3RKT1NaZ2xhcStWTkhoRHRaQ2tlTXFsa0ZMNG1zdlBpcHg4WUgwK1pIQlpJSVZLQjBLZldKbUplMW1KN2JSaWtGS2ZoWFI0SU85UGk3ZU9pK3RiT2VCWjI1elY3MDVKNTdSQlNSYmFFYUF1ZmxrUWZ4OUUrZnNIaUwrQzl4WG5iVHI5aW9JVGdZMCtGd0RzWFN5MGZsdHJBVVE4c052U0pUbHFZZTBESWVEbDQ3Nm1hUnRSTmMxVkxNVGoxbW42U3g2SlpyNTF6MVd2Zi85Wlg3OTY3ZC9kNE5HRmpmWlZ1djU4OWVlMnB6NjBNVnpjNDRZa28vbkJ1dHYvTERaQTBUZDkzR3kwMjU5Y3VibjFlQ3RhcXFxYXhGbXNjOVo3RjI4WFpDVFRXMHhpLzVIN3JKTjZ1MWthdFd5c2lyaXJMTlhtbWwyVk1OSFpzaFJIYTNtQ2hIT0phbFJDRndCckx3YU1aOWF4QktwVW5XaTJZdURJRVJGSFZISTFuN2UzKy9nYjI4cG5obWF0bkJwY0htWkx6ZWNYK3ZPYnV1T0RtOFp6NzA1ckQyakp0NHZpMk1WSDRXclJCZTdwcEQ0QXhaam41YWt6VHFxVklsRkl4bzdUK2loSENFdG9wMWdtY1pRSEM5SzJHbUZBeFNJeDEwOFo1ODRjNHVEL2lVWDdqdlhkdVA3aDM5OXYzSHV6NmJyZERwOWZsOHFWTHp6Nzd6UFBYT09HSkxNOWJ2OS8vT0VEK3dLa2oxaC9MbXZiSytZMHpLLzN1OHdHaG1zWVNmTUI0VC9Hb3dlODVYRGlSOUxRdUJzb0NyWjIwdGdER3hjbWxVQkhTa2VVWmVaYTNCNnFGZHJUalVpbmpxakJSU1d1eEhKKzdtRlljUDV6R1VrM0tWRXJST2JWWEZBQzFzU0lRUkdoMWhJRmtwWmYzcjI2dS9HV3Q1SE5yTFhWMkxkZGtDcHgxekNyRC9yVGkvcVRnOXZHY3UrT0NuWG5OWVZGelBDdW9Hck1RY0d3SENQRm5YRTYyZkloSTR4WWpzeENuQ042L0x5R0x0a0h5L2dTSkZnUFA0NXdMQ1BISW5hQUNmdExINlFCcGpEV3oxMS83emo5NThHRG5PQ0FZREFlc3JxOXZQZnZVczU4VFFpeTgwVFVnaFJBaXZ1Y2Y3MEgrTUQySWZ2cksyU3Q1bGx3MzFvRVFWSTFGYThWa1dwUGUwZWhuTk83VWFzc2FqM05SZ1VTMHMxRmpQS0VWZ3RaWkVwR0l1YUJ1bWxnODJUaCtGU0ZXUlVvbTVEcW45bFUweDdTT3c1MDU5Y3pRVFJPVWtzTnVsbTVPaTBxZURwS3FNZUdVcVcwS3BKZldCNitZeG55bU5vMGd3TnBLajE0dnAyb2FxdHBpWEtBeGpzWTRhdTh4MWxQWmhsSFZicjVWVFNkUmRIUjB2MVVoUkRGdUVXSVQzd2F4OTY2ZGFMbldSS2ZOS0RKbUZFNWxEaUVXLzhhMy96NDRGL3h1Q0g5b0tNanBMTklBelp0dnZ2YjZyWnMzZnZmNEU4Lzl5WTJOVlk0T0R0WDE2MC8rd3ZsekYvL2hnNGYzcG0wV2FZUVFmamFiOFdIb1IvNW5EK1AySmhHMFpENGgwT3ZEL2pPcDFxdldlZElzd3pnZmlVRFdjdmhnanJudGNFM3NSWUtOWElqR1JOY2taejNXUjNLU2MzSE1HMFRBYXdnNmtHVUpTc2Vza2laUkRGdEpRUWlXeHBXdFZxL2pjSGZPYUs5Q1NZbE9OQUt4bWliSnBUWVFsbjFJZUgvdmxHNnY5TFp5R2Y3QzRmRjBvNndpMlNuNGdKYWFicGF4TnVoeWRtM0FwVE9yWE5sZTVlcm1nRXRyUGM0TmNsWXpUU0lFeGxwR1JjMmpTY21kNDRMYm81TGJ4M01lakVzT0NzT29hR0pwWmwwY1c1K1NWNFYyanlKbE5QaTBEdWRzRkpVTGNUcm1yTVA2WUdvYjlpSDg4MHlYbGxsRUNOSE01OVBSemZmZS9zcXQyL2ZLYnJjaitzTUJXMXZibDY1ZmUrclpEK3BEL3ZiZi90c2ZaNURmNzJHTVdTTFBBK2dzMFdtZUo5ZUZFdG82RjZRVVFnaEIyVmlVRkpUVEN2dU9aN1BwSXpZVmRtSGY3QUtOZE9EYmtpSUV0QkpvS3hIRWZpU29nRTRWbVU5YUlHSEFCR0o5NzJNV01qNHdPYTZaSDF1UzBCS2RKQ0JFb29VOHM1QzI0ZjBzM3NYbVAxbnJKQytWWmZYcHNxaUVsSW8wU3hkcUlqR3FWTHVwYjkxNGhZeW1uNkxWQ2E0YlEyTU14anBxNDJJZ3VHaUJVRG5QY1dYaWhrNks1Ymc2RVlGTU9US242S1JwTytHSzN1KytMYWxDcTBKdm5ZVWdhTytRK2dQMk9UL3B3d08yQlQvV3I3NzZuVzkvK2pPZmUrT3BwNjUrWm1WMUdJYXJLOTJucmovMTJhOTg3YmQrbTJpOXBnR2psUHBRN0VSK1drcXNwZFhCbWZYaDZ1cEs5NUwzSHFVVVdacWhrNFRaZEU0M1R6SGVjVEFwS04rMnJCLzM2RzRxeWl6Z2hNY0ZFUWtRSHJ5eGNSRkl0QnFRU3FCVGlVQWhRNEkxbGlZNGtLTGRZQXZLc21GOGJLbG5EdTJqSW51RWlFaUVFSWxVNnBKV0tqWFdubWJ0aGtXQURMcFpUeEcrVkpmMWluTStDcmJWRFVyRlpqbDRvdEo4VkJkcEE2UUZJeXFOa2hHaDI4bmlJZmV0ZXYwSnlORlJObzdLZWF3UDFEYWNFcDd3eU1xU1NrTXFvOVZibG1pNldVcWFhSUozV0d1UlVzWU00cHh4SVN4a2pOdy9SNW5GNlY3azd0MmJEMjdkZVBkM2RsNTg3cFBYbnJpY2RIcGQ4ZVQxSno5MStkTFZDM2Z2M1I0dHN1LzYrdnJIUGNnZnNFRS9mUXVMbFVGM0k4L1NDODRGb2FRa3pWSjZ2UzZIeHhPb1RieXlQQnhOQzhhemd2V0REcDJWbEhTWVVQZkF5ZEI2aWd1b0EwNDVORkhjUVNsSlVBTFhMdFI4Ni9EbmpLZWFPWXFwd3pidEFFQzBTNklXbmhMTFFiR21sY3lNZlgranZnanVZWlpzbXNhK09DOXQyeDZmRElaOHE0dHFGNXlRRUZBdHpFVEp1SDlaMktkRlRraUtsUEdDU0pOQUh1SUVLamhQYlV5YzdGbFA3VHlWZFhIVTdXT1dLZHZqS2lxTG5qZVJkeEtYTDNReTVYVmd2N0grb1lkOS9qbTl5U053MGk4cHVVRDExYS85NW05OTZZdGYvTk1YTDV4OUpsR1NMT3RlZk9uRlR6NS85OTd0TnhmdlZldHBHRDRPa0o5czZVU2E2SjVXcWgvOVBBUktTckk4Sjg4elpyT0NUcFpHa0tIMzFOWXkzYTFJOWlWNWxpQTdLZWtnSlJ0cWtrUmdiY3dzV2t0MEVISHA1dHV4anhXRU1qQWZXK1l6UzFXNnBjdHRxNks0L1B5OGo5QVVKZVhaYnA2dGwzWHpnQjlsOEdLTTNSeGJkMzdlU3UrSTFwNU51dE12TXB4Q0VzZm5kOEtodkk4TFFPTGlUMnREa21wMGtrVEFvb3J3ZHBrb2trUmpYYnN6YWYzSVE0aDJFRTFibHRVMndreU1ENVJOczV6eXpZd1RXYUpmQzE3OEErUGNmZjQ1dmNtbGxNRTV2d1F3Q2lIcWUvZnUzTHgxODkydm45dmVlbW84blhIdndjNVF5ZXpKMDk4amhNRGYrVHQvNStNTThnZHAwcDF6eXo1RUs1a3FJVlhjY3F1bythUTFxeXNyekdZbHMzbEYzc254emxOSHBDSmVPT1pWalR1R1RPdDR3QktKMGd1SFdKWU5yVzBjZGQxUVZKYTZjcFNOUFJId1hjNmFXN1YwSUxoQXI1dWl0WTc3YlNFVTd3ZnNMUit6eWdoQ1VNM2pxU1djTkN5bnUzc1ZCVTRRaFBiWHNYY0FjTlpnakNHRWtoQmk5bHVNZTVXS3ZZV1VFcDBtQ0IvNUlaa1FETHVkT0dpSVBvODAxbEZiUTludVhJd0xLQ21mOVZxRnVpekx4MHFsbi9nUnA0Y0tIN0V4aGtEVk5JMzgxamUvOGQ4RXA3NVlOdWFaQjNmdlZhUERnM3Z0dEdzWmpIL3JiLzB0L3UxLys5LytPRUIra2t6U05OYjZFSHhvTjh3QjBFcVNaQ2tiRzJzOGVMaExNeTNJMGxpekx4eWlwRlFJSEM0NHJERlVUWVRETyt2YVd0NUhwcUVMaXpibFIwNUdOT1pwRWJSeFlFK1dwV2pkTHVNSXRZdUxOZkVCNDA0ODRUREFMUTh2dDRaVzcrUEhodzlJTzR2Z0VhNDFQeFNMWUFwSWUvTHZUQ3VHUjF2K0xjbGVyVGFZbEpHcW02UXR4VGY0bG15bEdXUVpLNTA4eWcvRjZkZjVvckYvb2tSODM1KzYxUDh3Z2ZLbEwvMFMzLzcyMTBMVHVBQzRRS2dCK1Z0ZitjM3Y3KzBkL1R2OWJ2L1BlV3R1N2gzdS92ZjgvOW83MHg3SnJyT08vNTV6N3IyMTlUTGRNNTZ4VFNZNG1UZ2tJZ3NRQ1JFSnhBZmdPL0FsK0JyQU96WkZTRWpoRlJCRmtWaGVJQkdFa3hqaUVEQ1R4SW9keCtQSmJEM1RleTIzN3RrZVhweGIzYmRyZXBMWURuWVByak1xMWUycWJ2V2Q2dk0vei83L2R5WU1MMTI2OUZTMG5IemdBT2tJUGtyZUp4b1ZTY1lJdEtkZ3I5ZWpiQUs5d1pEdEs1ZlplYmlIT2s5bExRbEJUU3ZPYVMyeHJXL1FjVUcwMWM5WTZIV2M1L3llNUc1YjhHVDZUVXRoN1VtR3l4YmxTZi90T2JXQTFJVDA0TXJtNkMrMit1VWZQRG9ZdnpoMjhjdzAwdkx2alR3K0szOENtS1ZyUGZPWmRlNDU1WmdMelZyeHR2SHRhTzVwZ1ZESTF0Ull5YlhId3RnVTlGZkt3bzZhRUpUMzFQNmhtZjBrRjFvV05SRlVOZDU4N2J2L1dHSy83b2tMYmZRRkUyeHFDZWxXQVBrNUFITG1qOU1yeTZLcVN1TmNwcXhaNVBaN1pVSG9WZlQ3UTU1NVJ0amIzYU51UEZYWkNvRzBZWEZvd1lESWlkOGRrdEwyQ0Q3MldJNjJFN21Cc0RKQ1lTVzNiRVFoeGtpRTJrYy9YL0xiRjBGdXNOYlVONjV1UHQ4elBHZVNVN2RmeXpUcVl5a2ZXZHIwWjNpQ2w5NlhjMzVta1RaTFM4VVlFdGlVTFpHWTludFRpMThmendCVGpSRlRGc0o3NUpmKzVqZS96a2x2ekdsLzF1S2p0SjQ0N3h3aWk5WjZuVTZuSzRDOHU2d0lSa1JNVVpTNWhhUnRRclRXMHV0VkRBZVJFQk1ibTVlbzUvTWNRZnY1YVNlczVKUFRtT3l1aEZiQUx6ZnJDU0dyTHVkbUtqMUxKaWNpbE1aZ0YvSnVLZVdnUGlXOEQ1QTREaUhWNTdnakNRaEdwTG05YzNDdE1LcWlxbTJTYWlFaEtPY0JaZmxhbHNDN0RLTEY5M1NISy9TY2xGcEtwK0RuUEdDcXhoQ2lmdy8xajhkTjJ1bnRoQTUrdTYrZjFGdU1NWHJSNDQrTG1NVVNZOFJXaFNHSVV1VVdEMXpqY1Q0ZlRFV3JiMTZXSlZYZHd6bFBqRDNjdk1ZM1RXc3BGdUtjZ29yRkZwbjl2RFFGNGh4aFVZSHVBTU1DaFlBaFplVnoxVFp6WlZzUm1wQ0FlejZjNGNnNlVjSUNuQS9SUGppdXZ5VEN0dzM4RHNxbkRId1UyRkpZaUdYSWVheVBYYUJ3enZ1eXRObVgwWm5PQWR5eTlaRU9tQ3drVGNueGk1M1JlSkkzZWVhMk5hK1ZCWGszTWNqNmFMQlpXR3Z6ekhiTzNsUzlIbXNpR0dQeFBqS3JIZDdIbGx1cUpCaERTbG1idHFnVWF3M3pwZ0VYc0VWQk0zY2s1L0NOdy9sd0ltWnZXMkNZN2trb2VkWjdNWStCUUlwSlNkSUVIOTZJS1RVOFhubE9nRy9sb20rajdFUjRHYmdzOERHQmp3dDhCdmhsNEVVRGE5cjU3RlBIbTlLZkFoQTl4L1U2enhyeEJLdHpTaHRCaUtvM0F4enpmMFBMOHpPdFVyL2ZaejZmcndEeWp0Tyt3cnFtWkdEUlFpNklKS3F5cENySy9GelZqQ2Mxem1lV3dwUWlhOE1oYytlejRwSVBWTDArVlpXeWhMSXF0aWlKS2xsM01HYmR2Z1hWenpuM2dMVGRzNEpnYlNIRzJvbEw2VUhIbDA0Q2FxMGw1T2gvVVUybTQ0dFBGZTRydkFKOERkZ1d1QTdjRVBpc3dNY1Zuak93SmpBNHg3Sm8xK3JvejFOSVduTFQ1TlIzVFFrbWttWFgvajNBWHdQdmx2cm5QUitLVHdNNExtU2ExL3ZBZU5iUTYxY1pIS2JkSGUybUhmUXJGS1VzTEVmakdZMXJGV0Zqd2hyRCttaUVNWmFxeW9USjg4WXhuYzZZVGFZY0hZMXhJUTlibVRienBlMk9NaTE1VzA0dFoyc2x4cEw1ZGhWanpWSElxa3dManlhSkVSMzFlOHptallZWWs1NmV4b0ZPK3p1bnZWcEhDcmNWdmcxOEZialN1bUNmVVBpazVPdVBDRndSS0ZxMzZZelgxWEdsNUowYzJSYVNpUHhkVVAxWDRJMEU5emtsd251cTJROC9UQURSYWQwYzdSOU40MVlibUllWVFBMWlUb25VcXFKQSt5QU1tTmFldXZFNUZra1JIeUx6cG1ZMm14SkNEcTVkNC9ET0lTbFJ5S0tPa0Z2aHBjME1MRVpUQWNTMkxPeENPNWNCeHRqRHVac2RkR0lPVFVrSk1XaFpXSEptT2NXWVR1UUNwSk1rczUxSDBRSE9ZWUszeU83WVVHQWJlRjdnb3dxZkJGNEFMZ09id0VqQTJIWXMrVHdyMGYxNmtSdzRpWTVWYlNGU0IzaTE1ZmVhdFFCNXAvU2pLNEI4a0N2NGtIYjNEbmp3NklEbnIxMWhjMk9Fc2Zub1RHMkZXOGtGc2w1Vm9waVd4ZEJTRkpiRzVXdE5lZjY3Y1o2cUt2R3VvcW9xbkhOb1RJVGcybU00VDljdGd2VkZhMWp1aURWdHM2TlZVNWhkNS96a3hMMXFKM2QvNDhVYmZPZjFOL20xNjlmMDV0MkhXZC92MU5QcEtyOTFHeHk3Z0ZsWW1HT0ZYZUJOUFcwTjc1TkJzeWx3U1ROSXJpcmNNUEJzKzk1VnpkekZCV0FOclFKRGEyMDY5N0tqcW0rMzRKaHl5b24xVG9qalZnQjUvOU82WjdLZmFrbVYrcmxVeG5EMzlsMzJOOWI0eVBOWDZWY1ZFaU9lSEhka2FmSzhrYTNKbXVtTDBWTnA1WmhKQlZWVlpiNm9FTExpYTNzZFFpQ0d6RmFvS2VGYkx0MlVFdDdsOTF0S2ViWFd4S1M4MWJaMHR4a3NVVkJldXZrYUFLL2QzeVhFTXdleHRyV0tSUnl4clBobWxoNWRDOU45ZnNScHpkQzA0T25GYkhFMmdlZkk0QmtJckN0Y1ZuZzI1ZGQ2d0Z6Z2JZR1hndXEvY0dvOUZ0UkZLM0E4QlJia2hQVEFoVEFUVlIyV2htRXBUS2JIM0xrMXgvU0diS3l2c2I0MnlQb2FMVEI2VllGSWhKQm5IcXF5eUFXM2xFZ21ZZElwKzRjeE9WWkpNUkpUd25sUERCRnJEQ01SZk14VW5qSFZXRFN6RlNZVlk2MmJodkNtdHZKcjdlTk01bWc4ZHovUC81R2x6QmRQc0RCZDBKeDMzZTFTZVczeC9tTHN0d1ZSMWY3TW5KeXRxbW03YlZuUUZ1V1NrSzc4cTR0dFFicU1JSG84YWZaVW1Tc3lTa2twck1Gb1pIYXd4OEhlUHFic3NiR3h6dVh0RGNyS1lxeWhzSmFtclJRcm1nR1VZbXNWRkdQMXBIa1BJakZGaWpMVC9OVDFuS0t3REhwOUp0TXBQa1I2Z3g3QjVia0pnMklMdTkvVXpkdDBTTmFNaUE3N1BjYjFrN014OGIwQlp2bGhPdGYySEFza1M5ZXlWS2RaTUVLZXRIc3Nab1JuS3h4Y1hJQ2tsT2o4SVZOSU9sSDB3SVY0T2FhczNncmtKcnlrN0I4Zk1wMGNNemsrcHV6MTJkeFlwOS92WlV0aUJHc3l5VnBLQldYTVk2bWxhbTVsYjhWc3lzS2M2QVVhNmVORHdBV0hzWWJSYU1pOG5sTzNvNm5HR3B3UGI4MmI1bjY3c1lJSXlWcWpXeHVqbndxUWQyRkZ6eXQvUENtVGV4NXdsaDkwczI3ZEJFTWJJT25LdDNwNlhLd0U2TGh1ZG1lTnYxMlZ4UTFqaEtJb0pNWjRRdHU1UGh4U1NLS1FnSytQMlcrbWxMMCtaZGtETWFTVzY2cXdCcXpGRmtyd250QzJvbVNRRkVoTWhLZ25UQ0RHV1ByOWd1QkRTK2JXN2tTRHExM3o4cXh4KzkzVFYwUVl6NXIzNDNONTdQcWNOSytjQTZJblpZRzFrOTJtWG1IZ3FRRklCR0k5OTlOcDdYWkh2UXByYmN0WTNrNEVsZ1ZpbGFvd2pJYjlscDFROEQ1U054T2NDN2k0SUpJREVadHJJcjJTc2l3d2JURHZuS051NXNRWXNkWXc3UGN3WW1qYUJrblQzcEdxRW9KL3UvWitRZVh2eU9UcjZuelFZYS8zUVg5bTUxMmZkV0dYcnJ2eHhpcjJlQW9BWW96UmxQdXlFK0JkaUs0SjZUL0xYdlY3MXRqUm9GKzI5WW9za2hOanl0YUJQTzdwZmViTnFvb3NDMkJjSU5uTWxkVTBEZlU4TUJsbkxZMmdyV0NtUUZsYVJzUGhDU0cwZDRIZ0F6RkdwcE1waytsVU5mcUFrWDg3cnYyYmRPZ3pSVkFqd3NGNDhvRWo0NTB1eTZvcStEU21lYlVUQVB1am1iczE5M0czVjhob01Va1gyd25DMHRyc0ZyVU1pVEcxTE9qU0VqcGJpNGhTU3VhMUxhb0M1eHpTQ0RZcEticE0xNmtsMCtEenBHSElxZCtVSWlGNDZsbE5uRHV4cGQyYkJQMUdTanFtbyttbmVrcXhjOUdYL29LQTlXRmRIemg1dGJVMkV6cWZabWVLOFd5dTE2OXVmVWFFR3lMSXNOY2poTWg4N2pFaWpHYzF4MDJOVmhGSHBJbUJ1Z2xNRzRkMzRZVDEzZmx3SW4vV0t5eWxOUlNtWlJOcHd4NGhZU1FuQXdRbGVJZDNIazJSSlBMU3NVdC9rMVNQMjJSUFkwVFM5cWl2MDhhdmRzL0tncnp2aDEwQS9MengrL2NlSGYzekM4OXRmM0h2WUxKUis0Yitoa1cyQXJJWldTK0Y5ZTBSL1dGQjlJbTZqa3dua2JGTEJJUithV0Fhc2Z2QzRaN0RlVVdzSWNXRXppT3V6bXp2Vlo0emJ3ZDdJY1RXbXZpSXd0NDhwSC93TVIxMjRvOWtSTFFvWkxWelZnQjVmOVpDcko2ell2WE4yenY3LzNGcGZmRDlSMGZIWC96NEwxM2ljNy85TExab3B3TVRGTWJnWFVJTjlFckQ5dFlhWTJPb2kwQ2xpbTBDY1ZaeExZendZcGtGWlR4MWxQUEkvTERoNk5HTTZhTWFkeHlvVEN1SXFZcjNnUmhTRTBXK01vbnBaWEpocmRPenBMcHp0TXI5ckZ5c0R6QXNBY3k4OFdFOHFmMzZML1UvY2Uyam0xdVhOZ3BaV3k5eXpHSUVGU2dsVHcxYXdCUVZjNFM1RHhSUktYekNCaUVseWZNaUlsU2xaZGdyR0l4S05pNFB1SFIxeUdpenhJZkEwVkdObXdlYXV0R28rcTFwNHM5ZDRoNjVOYU51QWFKSllWRFlWcmxwdFZZQWVYK0IwWDAyTStmdlhYMXViWGJweXVnTDAxa2NiRzZXbEpVbFNyN3RGQkxxY3h4ejdCd1BEeHNHQTVzNy9ieFNwaXJ6YTJwa2Y3Zk9EQ0F0YllrZ1ZLVmhmYTFpc0ZadzU4NCtPenN6ak9yTnVmS0hkZFFmZHNEaEJWSmhSSk95QXNjS0lCY2k4WkxsekE3bXU5dlBESzRGTVorZVRvSnNidmRRMjhxd05UR3IzWXJoZTkvYjAwYmg4bFpmREFrYkVzbEhFa3FUWU9mdWhHcFUwQjhXa0RKUGJsbFltdHJ6OXVzNzdEMGM3ODFtZWl2Q1g4NFNMN1ZCK2F5TlA2SUkybXRuMmxkckJaQ0xZRWtBaUNIRlp1YnZiMThiL2Zxc2pzOU02OEJ3VkdGRElqUzVWMm95ai9FNzMzN3c2SmtYTm0yL1owdVpSMmdpTVFmYkJEVzZjMythMXJiNlpqZ29LY1FnQ3RQalJ0LzYvbjE1ZE9kZ2I5N29uMHhxL1ZPdnZBcU02V2lpQzJoaFJLV2wvbDJ0RlVBdTBqS3ppWnYyZTBXOXRsNTlibmJZakE0ZnpyQUordTNrdzczNzA0ZTNmakwrOFkxUGJ6L2ZFeW1NUzBTZmlBRlVEU0VsLzZQWDltWmIxMFpWV1ZocEpnMzNmclRIN2UvZGs4T0h4NGVONTYvMmo5TFhZbUtIM1BrNjY0QWpXY210NjgycTlMd0N5QVYwdHhTUWc5M1ozYlcxTXE2TnFzL014MDF2ZjJjcXZrbXExdXFyLzdYenl0clZ0Zkw2OWZXUDlaT1NYQ0lscGFSSG9RTmM3Y2V2L1dEbndaWG4xemNQN3gvYkgzLzNObnUzZC9GTnZEZjNmT25SWHZ5S0Q3cmJXbzRUdHdxSWhVRFA1REhkdU5vdks0QmN3RmdFV3ZLVGc5MzYxbWk5MHRHbC9xOGFvVGNaTi9MZzNtVHYxbHRITDExNWR2UjVEWEZyL0dqRzRhTUpldy9HSE83TzJMbHp3TzBmUDl5OWMyZjhocHZVMS9kdlBTekQxS0hLblptWFAzdTRINzhhZ2g0Q2t5NDRqRUVIQTBPL2IvU3psWEtyV1cyV0QrTXFMdmo5TFdqMUJURE9SWDd3UHcrLy9LblBYNXM5Kzh6ZzkxRjk3c0ZQRGw0T1BoMGUzTnE3c3Z1R2E1dFdFdEdITEJVZEVvM1R5WFRDcTBjUHdoYzIrbElGbFc4ZTErbkxCOGYrbFpRNGJzRlJ0NzhyR0NOcUJCME5MWU9CNFZzL1dkbU9sUVc1YUpHNlBHWkpGRWd4cXR1NU83NVpsZVlPcExXSE8vWGZibTMxWHl3SVgvUXVTRXFxSVNhSklaRmlacW9TYTE2Zk9mNStVUEJwTWZLTnZiSCs4ZUU0L2JjcWt5VndSQUcxeHFnQ3ZWNU9DNDhuSzRDc0xNaEY4NjhVck0wa2hERnE2SUlFOEsvL2NQK2ZSc1BpcGd2YWJHLzNmOU83dUE4NkVLVWthZjZYS2M2bktabnZ4QkIvTkczNG8rTjVlcjJlNnc2bmdpK0xKc1FvZ29wQlUweHNYRmxqYjNleTJpRWY4bldobTRwKzYzYy93aXZmdUV1TTJoMDFQZEVEQkVvUjZhK3RGWmN0NlFWcjlibzFQQnVqTmpISEZmT1UySmtIZWN0NVBlS1V5U04wbmhjc0pkcnlYNU5XMmFyVmVob0FNaGlXeEpCdzdxVGJ0enRpMnVXWDZpcW9MdWF5bHhuRnU4Qll2TDZ3U0FBcXNwcEJYYTJuQ0NBLzQ1NjdUQjlGNTJHVzNMSFlzUlFMMHVuRStUUGdxN1ZhVHoxQXV2ZTlURjdRbFdidXlvQ2twYTlYd0ZpdC85Y0FlUkpZbmhqenIwQ3hXdTltL1M5WmhaWklDVmZrUXdBQUFFcDBSVmgwWTI5dGJXVnVkQUJHYVd4bElITnZkWEpqWlRvZ2FIUjBjRG92TDJWdUxuZHBhMmx3WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2xSTlRsUlNZWEJvWVdWc01qQXhNaTV3Ym1la2JYL0hBQUFBSlhSRldIUmtZWFJsT21OeVpXRjBaUUF5TURFMUxUQXpMVEEzVkRJek9qVXdPalEyS3pBd09qQXdwVGJwTWdBQUFDVjBSVmgwWkdGMFpUcHRiMlJwWm5rQU1qQXhOUzB3TXkwd04xUXlNem8xTURvME5pc3dNRG93TU5SclVZNEFBQUJHZEVWWWRITnZablIzWVhKbEFFbHRZV2RsVFdGbmFXTnJJRFl1Tmk0NUxUY2dNakF4TkMwd015MHdOaUJSTVRZZ2FIUjBjRG92TDNkM2R5NXBiV0ZuWlcxaFoybGpheTV2Y21lQjA3UERBQUFBR0hSRldIUlVhSFZ0WWpvNlJHOWpkVzFsYm5RNk9sQmhaMlZ6QURHbi83c3ZBQUFBR0hSRldIUlVhSFZ0WWpvNlNXMWhaMlU2T21obGFXZG9kQUF6TlRSSlVrelNBQUFBRjNSRldIUlVhSFZ0WWpvNlNXMWhaMlU2T2xkcFpIUm9BREk0TVZINC82b0FBQUFaZEVWWWRGUm9kVzFpT2pwTmFXMWxkSGx3WlFCcGJXRm5aUzl3Ym1jL3NsWk9BQUFBRjNSRldIUlVhSFZ0WWpvNlRWUnBiV1VBTVRReU5UYzNNakkwTnJkRDcwTUFBQUFTZEVWWWRGUm9kVzFpT2pwVGFYcGxBREUxTkV0Q1FzNE1WdHNBQUFBemRFVllkRlJvZFcxaU9qcFZVa2tBWm1sc1pUb3ZMeTkwYlhBdmJHOWpZV3hqYjNCNVgyUm1aalV3WkRFME9UTmtaaTB4TG5CdVovWlhFbzBBQUFBQVNVVk9SSzVDWUlJPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvcmFwaGFlbC5wbmdcbiAqKiBtb2R1bGUgaWQgPSAzMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXG4gKiogbW9kdWxlIGlkID0gMjg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcbiAgICAgIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICE9IG9iamVjdFRhZyB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9