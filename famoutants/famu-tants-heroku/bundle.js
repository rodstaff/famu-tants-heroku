/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(152);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactRedux = __webpack_require__(30);
	
	var _app = __webpack_require__(146);
	
	var _app2 = _interopRequireDefault(_app);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_reactDom2.default.render(_react2.default.createElement(
	  _reactRedux.Provider,
	  { store: _store2.default },
	  _react2.default.createElement(_app2.default, null)
	), document.getElementById('root'));

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule reactProdInvariant
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(207);


/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentTree
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentFlags = __webpack_require__(103);
	
	var invariant = __webpack_require__(2);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(197);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 9 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstrumentation
	 */
	
	'use strict';
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(228);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentTreeHook
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var itemMap;
	var rootIDSet;
	
	var itemByKey;
	var rootByKey;
	
	if (canUseCollections) {
	  itemMap = new Map();
	  rootIDSet = new Set();
	} else {
	  itemByKey = {};
	  rootByKey = {};
	}
	
	var unmountedIDs = [];
	
	// Use non-numeric keys to prevent V8 performance issues:
	// https://github.com/facebook/react/pull/7232
	function getKeyFromID(id) {
	  return '.' + id;
	}
	function getIDFromKey(key) {
	  return parseInt(key.substr(1), 10);
	}
	
	function get(id) {
	  if (canUseCollections) {
	    return itemMap.get(id);
	  } else {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  }
	}
	
	function remove(id) {
	  if (canUseCollections) {
	    itemMap['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  }
	}
	
	function create(id, element, parentID) {
	  var item = {
	    element: element,
	    parentID: parentID,
	    text: null,
	    childIDs: [],
	    isMounted: false,
	    updateCount: 0
	  };
	
	  if (canUseCollections) {
	    itemMap.set(id, item);
	  } else {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  }
	}
	
	function addRoot(id) {
	  if (canUseCollections) {
	    rootIDSet.add(id);
	  } else {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  }
	}
	
	function removeRoot(id) {
	  if (canUseCollections) {
	    rootIDSet['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  }
	}
	
	function getRegisteredIDs() {
	  if (canUseCollections) {
	    return Array.from(itemMap.keys());
	  } else {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  }
	}
	
	function getRootIDs() {
	  if (canUseCollections) {
	    return Array.from(rootIDSet.keys());
	  } else {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  }
	}
	
	function purgeDeep(id) {
	  var item = get(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    remove(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = get(id);
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = get(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent ID is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    create(id, element, parentID);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = get(id);
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = get(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = get(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var type = topElement.type;
	      var name = typeof type === 'function' ? type.displayName || type.name : type;
	      var owner = topElement._owner;
	      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = get(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = get(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = get(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = get(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = get(id);
	    return item ? item.updateCount : 0;
	  },
	
	
	  getRegisteredIDs: getRegisteredIDs,
	
	  getRootIDs: getRootIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactCurrentOwner = __webpack_require__(18);
	
	var warning = __webpack_require__(3);
	var canDefineProperty = __webpack_require__(68);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      Object.defineProperty(element, '_shadowChildren', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: shadowChildren
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._shadowChildren = shadowChildren;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.createElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(
	      /* eslint-disable no-proto */
	      config.__proto__ == null || config.__proto__ === Object.prototype,
	      /* eslint-enable no-proto */
	      'React.cloneElement(...): Expected props argument to be a plain object. ' + 'Properties defined in its prototype chain will be ignored.') : void 0;
	    }
	
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactReconciler = __webpack_require__(29);
	var Transaction = __webpack_require__(35);
	
	var invariant = __webpack_require__(2);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.props === component._renderedComponent._currentElement) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topAnimationEnd: null,
	  topAnimationIteration: null,
	  topAnimationStart: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topInvalid: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topTransitionEnd: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function (target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function (constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function (target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function () {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(5);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMLazyTree
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(57);
	var setInnerHTML = __webpack_require__(48);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setTextContent = __webpack_require__(123);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(241);
	var ReactInstrumentation = __webpack_require__(11);
	
	var warning = __webpack_require__(3);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function (internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.connect = exports.Provider = undefined;
	
	var _Provider = __webpack_require__(153);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _connect = __webpack_require__(154);
	
	var _connect2 = _interopRequireDefault(_connect);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	exports.Provider = _Provider2["default"];
	exports.connect = _connect2["default"];

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventPluginRegistry = __webpack_require__(43);
	var EventPluginUtils = __webpack_require__(58);
	var ReactErrorUtils = __webpack_require__(63);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var invariant = __webpack_require__(2);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function (inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function (inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (inst, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function (inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	
	var accumulateInto = __webpack_require__(116);
	var forEachAccumulated = __webpack_require__(118);
	var warning = __webpack_require__(3);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 33 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compose = exports.applyMiddleware = exports.bindActionCreators = exports.combineReducers = exports.createStore = undefined;
	
	var _createStore = __webpack_require__(128);
	
	var _createStore2 = _interopRequireDefault(_createStore);
	
	var _combineReducers = __webpack_require__(287);
	
	var _combineReducers2 = _interopRequireDefault(_combineReducers);
	
	var _bindActionCreators = __webpack_require__(286);
	
	var _bindActionCreators2 = _interopRequireDefault(_bindActionCreators);
	
	var _applyMiddleware = __webpack_require__(285);
	
	var _applyMiddleware2 = _interopRequireDefault(_applyMiddleware);
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/*
	* This is a dummy function to check if the function name has been altered by minification.
	* If the function has been minified and NODE_ENV !== 'production', warn the user.
	*/
	function isCrushed() {}
	
	if (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
	  (0, _warning2["default"])('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
	}
	
	exports.createStore = _createStore2["default"];
	exports.combineReducers = _combineReducers2["default"];
	exports.bindActionCreators = _bindActionCreators2["default"];
	exports.applyMiddleware = _applyMiddleware2["default"];
	exports.compose = _compose2["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(180);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(194);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(24);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && typeof object[p] === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DisabledInputUtils
	 */
	
	'use strict';
	
	var disableableMouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var DisabledInputUtils = {
	  getHostProps: function (inst, props) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var hostProps = {};
	    for (var key in props) {
	      if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
	        hostProps[key] = props[key];
	      }
	    }
	
	    return hostProps;
	  }
	};
	
	module.exports = DisabledInputUtils;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventConstants = __webpack_require__(17);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactEventEmitterMixin = __webpack_require__(231);
	var ViewportMetrics = __webpack_require__(115);
	
	var getVendorPrefixedEventName = __webpack_require__(263);
	var isEventSupported = __webpack_require__(74);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = document.createEvent && 'pageX' in document.createEvent('MouseEvent');
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	var ViewportMetrics = __webpack_require__(115);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var DOMNamespaces = __webpack_require__(57);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var newNodes = reusableSVGContainer.firstChild.childNodes;
	    for (var i = 0; i < newNodes.length; i++) {
	      node.appendChild(newNodes[i]);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(5);
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _Actions = __webpack_require__(27);
	
	var _computeChangedRoutes2 = __webpack_require__(178);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(175);
	
	var _isActive2 = __webpack_require__(182);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(179);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(184);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  function createLocationFromRedirectInfo(location) {
	    return history.createLocation(location, _Actions.REPLACE);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, createLocationFromRedirectInfo(redirectInfo));
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.transitionTo(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(28);
	var Danger = __webpack_require__(202);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(69);
	var setInnerHTML = __webpack_require__(48);
	var setTextContent = __webpack_require__(123);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function (parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
	          }
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
	          }
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMNamespaces
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(63);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function (Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function (Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function (node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function (node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function (a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function (a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function (inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function (target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 59 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule KeyEscapeUtils
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypes = __webpack_require__(113);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var canDefineProperty = __webpack_require__(68);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 66 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypesSecret
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg;
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function (callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 69 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createMicrosoftUnsafeLocalFunction
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function (func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 70 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 71 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 75 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	
	var getIteratorFn = __webpack_require__(73);
	var invariant = __webpack_require__(2);
	var KeyEscapeUtils = __webpack_require__(59);
	var warning = __webpack_require__(3);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var emptyFunction = __webpack_require__(14);
	var warning = __webpack_require__(3);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      if (childTag !== '#text') {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>. ' + 'See %s.%s', tagDisplayName, ancestorTag, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reduxLogger = __webpack_require__(281);
	
	var _reduxLogger2 = _interopRequireDefault(_reduxLogger);
	
	var _reduxThunk = __webpack_require__(284);
	
	var _reduxThunk2 = _interopRequireDefault(_reduxThunk);
	
	var _reduxPromiseMiddleware = __webpack_require__(282);
	
	var _reduxPromiseMiddleware2 = _interopRequireDefault(_reduxPromiseMiddleware);
	
	var _reducers = __webpack_require__(141);
	
	var _reducers2 = _interopRequireDefault(_reducers);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var middleware = (0, _redux.applyMiddleware)((0, _reduxPromiseMiddleware2.default)(), _reduxThunk2.default, (0, _reduxLogger2.default)());
	
	exports.default = (0, _redux.createStore)(_reducers2.default);
	//export default createStore(reducer, middleware)

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	exports["default"] = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  dispatch: _react.PropTypes.func.isRequired,
	  getState: _react.PropTypes.func.isRequired
	});

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that you can use this stack
	    // to find the callsite that caused this warning to fire.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * This action type will be dispatched by the history actions below.
	 * If you're writing a middleware to watch for navigation events, be sure to
	 * look for actions of this type.
	 */
	var CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';
	
	function updateLocation(method) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    return {
	      type: CALL_HISTORY_METHOD,
	      payload: { method: method, args: args }
	    };
	  };
	}
	
	/**
	 * These actions correspond to the history API.
	 * The associated routerMiddleware will capture these events before they get to
	 * your reducer and reissue them as the matching function on your history.
	 */
	var push = exports.push = updateLocation('push');
	var replace = exports.replace = updateLocation('replace');
	var go = exports.go = updateLocation('go');
	var goBack = exports.goBack = updateLocation('goBack');
	var goForward = exports.goForward = updateLocation('goForward');
	
	var routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;
	
	var _reducer = __webpack_require__(84);
	
	Object.defineProperty(exports, 'LOCATION_CHANGE', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.LOCATION_CHANGE;
	  }
	});
	Object.defineProperty(exports, 'routerReducer', {
	  enumerable: true,
	  get: function get() {
	    return _reducer.routerReducer;
	  }
	});
	
	var _actions = __webpack_require__(82);
	
	Object.defineProperty(exports, 'CALL_HISTORY_METHOD', {
	  enumerable: true,
	  get: function get() {
	    return _actions.CALL_HISTORY_METHOD;
	  }
	});
	Object.defineProperty(exports, 'push', {
	  enumerable: true,
	  get: function get() {
	    return _actions.push;
	  }
	});
	Object.defineProperty(exports, 'replace', {
	  enumerable: true,
	  get: function get() {
	    return _actions.replace;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _actions.go;
	  }
	});
	Object.defineProperty(exports, 'goBack', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goBack;
	  }
	});
	Object.defineProperty(exports, 'goForward', {
	  enumerable: true,
	  get: function get() {
	    return _actions.goForward;
	  }
	});
	Object.defineProperty(exports, 'routerActions', {
	  enumerable: true,
	  get: function get() {
	    return _actions.routerActions;
	  }
	});
	
	var _sync = __webpack_require__(165);
	
	var _sync2 = _interopRequireDefault(_sync);
	
	var _middleware = __webpack_require__(164);
	
	var _middleware2 = _interopRequireDefault(_middleware);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	exports.syncHistoryWithStore = _sync2['default'];
	exports.routerMiddleware = _middleware2['default'];

/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.routerReducer = routerReducer;
	/**
	 * This action type will be dispatched when your history
	 * receives a location change.
	 */
	var LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';
	
	var initialState = {
	  locationBeforeTransitions: null
	};
	
	/**
	 * This reducer will update the state with the most recent location history
	 * has transitioned to. This may not be in sync with the router, particularly
	 * if you have asynchronously-loaded routes, so reading from and relying on
	 * this state is discouraged.
	 */
	function routerReducer() {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? initialState : arguments[0];
	
	  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	
	  var type = _ref.type;
	  var payload = _ref.payload;
	
	  if (type === LOCATION_CHANGE) {
	    return _extends({}, state, { locationBeforeTransitions: payload });
	  }
	
	  return state;
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]).isRequired,
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	
	    if (router) {
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(190);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(92);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(20);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(51);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(26);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(173);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(85);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(167);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(186);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(168);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(169);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(86);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(171);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(166);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(170);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(172);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(185);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(38);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(174);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(183);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(92);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(176);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(177);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(181);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(88);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(39);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(97);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(191);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(24);
	
	var _AsyncUtils = __webpack_require__(187);
	
	var _Actions = __webpack_require__(27);
	
	var _createLocation2 = __webpack_require__(189);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if (typeof action === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _PathUtils = __webpack_require__(24);
	
	var _runTransitionHook = __webpack_require__(55);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(54);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	_assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  checkpoint: function () {
	    return this._callbacks ? this._callbacks.length : 0;
	  },
	
	  rollback: function (len) {
	    if (this._callbacks) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstrumentation = __webpack_require__(11);
	
	var quoteAttributeValueForBrowser = __webpack_require__(265);
	var warning = __webpack_require__(3);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function () {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function (node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function (node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(21);
	var ReactElement = __webpack_require__(13);
	
	var emptyFunction = __webpack_require__(14);
	var traverseAllChildren = __webpack_require__(76);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var keyMirror = __webpack_require__(49);
	var keyOf = __webpack_require__(22);
	var warning = __webpack_require__(3);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec;
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function () {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponentFlags
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function (inst, props) {
	    return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function (inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocations = __webpack_require__(45);
	
	var checkReactTypeSpec = __webpack_require__(117);
	
	var canDefineProperty = __webpack_require__(68);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function (factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function (instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 107 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactFeatureFlags
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var invariant = __webpack_require__(2);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(223);
	
	var containsNode = __webpack_require__(269);
	var focusNode = __webpack_require__(125);
	var getActiveElement = __webpack_require__(126);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var DOMProperty = __webpack_require__(25);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMContainerInfo = __webpack_require__(215);
	var ReactDOMFeatureFlags = __webpack_require__(218);
	var ReactElement = __webpack_require__(13);
	var ReactFeatureFlags = __webpack_require__(107);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMarkupChecksum = __webpack_require__(236);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdateQueue = __webpack_require__(67);
	var ReactUpdates = __webpack_require__(16);
	
	var emptyObject = __webpack_require__(36);
	var instantiateReactComponent = __webpack_require__(121);
	var invariant = __webpack_require__(2);
	var setInnerHTML = __webpack_require__(48);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function () {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(49);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNodeTypes
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function (node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (ReactElement.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var emptyFunction = __webpack_require__(14);
	var getIteratorFn = __webpack_require__(73);
	var warning = __webpack_require__(3);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '15.3.1';

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule checkReactTypeSpec
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactPropTypeLocationNames = __webpack_require__(65);
	var ReactPropTypesSecret = __webpack_require__(66);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(12);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 118 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getHostComponentFromComposite
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(112);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactCompositeComponent = __webpack_require__(211);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactHostComponent = __webpack_require__(108);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function (element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	var nextDebugID = 1;
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 122 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var setInnerHTML = __webpack_require__(48);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(14);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 127 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = compose;
	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	
	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  } else {
	    var _ret = function () {
	      var last = funcs[funcs.length - 1];
	      var rest = funcs.slice(0, -1);
	      return {
	        v: function v() {
	          return rest.reduceRight(function (composed, f) {
	            return f(composed);
	          }, last.apply(undefined, arguments));
	        }
	      };
	    }();
	
	    if (typeof _ret === "object") return _ret.v;
	  }
	}

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports["default"] = createStore;
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _symbolObservable = __webpack_require__(292);
	
	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'
	};
	
	/**
	 * Creates a Redux store that holds the state tree.
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [initialState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} enhancer The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */
	function createStore(reducer, initialState, enhancer) {
	  var _ref2;
	
	  if (typeof initialState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = initialState;
	    initialState = undefined;
	  }
	
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	
	    return enhancer(createStore)(reducer, initialState);
	  }
	
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	
	  var currentReducer = reducer;
	  var currentState = initialState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }
	
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	
	    var isSubscribed = true;
	
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	
	      isSubscribed = false;
	
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }
	
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2["default"])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i]();
	    }
	
	    return action;
	  }
	
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	
	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }
	
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/zenparsing/es-observable
	   */
	  function observable() {
	    var _ref;
	
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2["default"]] = function () {
	      return this;
	    }, _ref;
	  }
	
	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });
	
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2["default"]] = observable, _ref2;
	}

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = warning;
	/**
	 * Prints a warning in the console if it exists.
	 *
	 * @param {String} message The warning message.
	 * @returns {void}
	 */
	function warning(message) {
	  /* eslint-disable no-console */
	  if (typeof console !== 'undefined' && typeof console.error === 'function') {
	    console.error(message);
	  }
	  /* eslint-enable no-console */
	  try {
	    // This error was thrown as a convenience so that if you enable
	    // "break on all exceptions" in your console,
	    // it would pause the execution at this line.
	    throw new Error(message);
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	}

/***/ },
/* 130 */
[306, 288, 289, 291],
/* 131 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 132 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectTurtle = exports.selectTurtle = function selectTurtle(turtle) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "TURTLE_SELECTED",
	    payload: turtle
	  };
	};

/***/ },
/* 133 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var selectUser = exports.selectUser = function selectUser(user) {
	
	  // console.log("You clicked on user: ", 
	  // 	user.first + ", " + 
	  // 	user.description
	  // );
	  return {
	    type: "USER_SELECTED",
	    payload: user
	  };
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _turtleList = __webpack_require__(137);
	
	var _turtleList2 = _interopRequireDefault(_turtleList);
	
	var _turtleDetail = __webpack_require__(136);
	
	var _turtleDetail2 = _interopRequireDefault(_turtleDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompTurtle = function CompTurtle() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Ninja Turtles List:'
	    ),
	    _react2.default.createElement(_turtleList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_turtleDetail2.default, null)
	  );
	};
	exports.default = CompTurtle;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _userList = __webpack_require__(139);
	
	var _userList2 = _interopRequireDefault(_userList);
	
	var _userDetail = __webpack_require__(138);
	
	var _userDetail2 = _interopRequireDefault(_userDetail);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	//require('../../scss/style.scss');
	
	var CompUser = function CompUser() {
	  return _react2.default.createElement(
	    'div',
	    null,
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Influential Persons List:'
	    ),
	    _react2.default.createElement(_userList2.default, null),
	    _react2.default.createElement('hr', null),
	    _react2.default.createElement(
	      'h3',
	      null,
	      'Bio:'
	    ),
	    _react2.default.createElement(_userDetail2.default, null)
	  );
	};
	exports.default = CompUser;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var TurtleDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    turtle: state.activeTurtle
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(TurtleDetail, _React$Component);
	
	  function TurtleDetail() {
	    _classCallCheck(this, TurtleDetail);
	
	    return _possibleConstructorReturn(this, (TurtleDetail.__proto__ || Object.getPrototypeOf(TurtleDetail)).apply(this, arguments));
	  }
	
	  _createClass(TurtleDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.turtle) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite Ninja and click...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.turtle.image, width: '250', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.turtle.name,
	            ' aka "',
	            this.props.turtle.aka,
	            '"'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Age: ',
	            this.props.turtle.age
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description: ',
	            this.props.turtle.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Images and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return TurtleDetail;
	}(_react2.default.Component)) || _class);
	exports.default = TurtleDetail;
	// function mapStateToProps(state) {
	//   return {
	//     turtle: state.activeTurtle
	//   };
	// }
	// export default connect(mapStateToProps)(TurtleDetail);

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _turtle = __webpack_require__(132);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var TurtleList = function (_React$Component) {
	  _inherits(TurtleList, _React$Component);
	
	  function TurtleList() {
	    _classCallCheck(this, TurtleList);
	
	    return _possibleConstructorReturn(this, (TurtleList.__proto__ || Object.getPrototypeOf(TurtleList)).apply(this, arguments));
	  }
	
	  _createClass(TurtleList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.turtles.map(function (turtle) {
	        return _react2.default.createElement(
	          'li',
	          { key: turtle.id, onClick: function onClick() {
	              return _this2.props.selectTurtle(turtle);
	            } },
	          turtle.name
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return TurtleList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    turtles: state.turtles
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectTurtle: _turtle.selectTurtle }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(TurtleList);

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _dec, _class;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRedux = __webpack_require__(30);
	
	var _SmileyFace = __webpack_require__(131);
	
	var _SmileyFace2 = _interopRequireDefault(_SmileyFace);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//alternative code
	var UserDetail = (_dec = (0, _reactRedux.connect)(function (state) {
	  return {
	    user: state.activeUser
	  };
	}), _dec(_class = function (_React$Component) {
	  _inherits(UserDetail, _React$Component);
	
	  function UserDetail() {
	    _classCallCheck(this, UserDetail);
	
	    return _possibleConstructorReturn(this, (UserDetail.__proto__ || Object.getPrototypeOf(UserDetail)).apply(this, arguments));
	  }
	
	  _createClass(UserDetail, [{
	    key: 'render',
	    value: function render() {
	      if (!this.props.user) {
	        return _react2.default.createElement(
	          'h4',
	          null,
	          'Place the cursor over your favorite famous person and select...'
	        );
	      }
	      return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement('img', { className: 'img-responsive', src: this.props.user.image, width: '300', alt: _SmileyFace2.default }),
	        _react2.default.createElement(
	          'em',
	          null,
	          _react2.default.createElement(
	            'h4',
	            null,
	            this.props.user.name,
	            ' ',
	            this.props.user.last
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Born: ',
	            this.props.user.bornMonth,
	            ' ',
	            this.props.user.bornDay,
	            ', ',
	            this.props.user.bornYear,
	            this.props.user.age[2]
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Would have been around ',
	            this.props.user.age[0],
	            ' years and ',
	            this.props.user.age[1],
	            ' months old now, if were still alive.'
	          ),
	          _react2.default.createElement(
	            'h4',
	            null,
	            'Description: ',
	            this.props.user.description
	          ),
	          _react2.default.createElement(
	            'h5',
	            null,
	            '(Photos and descriptions courtesy of Wikipedia)'
	          )
	        )
	      );
	    }
	  }]);
	
	  return UserDetail;
	}(_react2.default.Component)) || _class);
	exports.default = UserDetail;
	
	// function mapStateToProps(state) {
	//   return {
	//     user: state.activeUser
	//   };
	// }
	// export default connect(mapStateToProps)(UserDetail);

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(37);
	
	var _reactRedux = __webpack_require__(30);
	
	var _user = __webpack_require__(133);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import store from '../store'
	
	// store.subscribe( () => {
	// console.log("Store changed", store.getState())
	// });
	// //below snippet is a sample of how to add a state into the code
	// //but should be matched by a corresponding reducer function to record and update this new state
	// store.dispatch({type: "ADD_USER_NAME", payload: "Rod"})
	// store.dispatch({type: "ADD_USER_AGE", payload: 23})
	
	var UserList = function (_React$Component) {
	  _inherits(UserList, _React$Component);
	
	  function UserList() {
	    _classCallCheck(this, UserList);
	
	    return _possibleConstructorReturn(this, (UserList.__proto__ || Object.getPrototypeOf(UserList)).apply(this, arguments));
	  }
	
	  _createClass(UserList, [{
	    key: 'createListItems',
	    value: function createListItems() {
	      var _this2 = this;
	
	      return this.props.users.map(function (user) {
	        return _react2.default.createElement(
	          'li',
	          { key: user.id, onClick: function onClick() {
	              return _this2.props.selectUser(user);
	            } },
	          user.name,
	          ' ',
	          user.last
	        );
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'h4',
	        null,
	        _react2.default.createElement(
	          'ul',
	          null,
	          this.createListItems()
	        )
	      );
	    }
	  }]);
	
	  return UserList;
	}(_react2.default.Component);
	
	function mapStateToProps(state) {
	  return {
	    users: state.users
	  };
	}
	function matchDispatchToProps(dispatch) {
	  return (0, _redux.bindActionCreators)({ selectUser: _user.selectUser }, dispatch);
	}
	exports.default = (0, _reactRedux.connect)(mapStateToProps, matchDispatchToProps)(UserList);

/***/ },
/* 140 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = function (_ref) {
	  var _ref2 = _slicedToArray(_ref, 3);
	
	  var a = _ref2[0];
	  var b = _ref2[1];
	  var c = _ref2[2];
	
	  //This calculation is roughly accurate to months,as you can see...
	  var d = "";
	
	  if (b < 0) {
	    a = a - 1, b = 12 - Math.abs(b);
	  }
	  if (c < 0) {
	    b = b + 1;
	  }
	  if (b === 0 && c === 0) {
	    d = ": Hey, Happy Birthday!!!";
	  } else {
	    d = ".";
	  }
	  return [a, b, d];
	};
	
	;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _redux = __webpack_require__(37);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _reducerUsers = __webpack_require__(145);
	
	var _reducerUsers2 = _interopRequireDefault(_reducerUsers);
	
	var _reducerTurtles = __webpack_require__(144);
	
	var _reducerTurtles2 = _interopRequireDefault(_reducerTurtles);
	
	var _reducerActiveUser = __webpack_require__(143);
	
	var _reducerActiveUser2 = _interopRequireDefault(_reducerActiveUser);
	
	var _reducerActiveTurtle = __webpack_require__(142);
	
	var _reducerActiveTurtle2 = _interopRequireDefault(_reducerActiveTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var allReducers = (0, _redux.combineReducers)({
	  users: _reducerUsers2.default,
	  turtles: _reducerTurtles2.default,
	  activeUser: _reducerActiveUser2.default,
	  activeTurtle: _reducerActiveTurtle2.default,
	  routing: _reactRouterRedux.routerReducer
	});
	
	exports.default = allReducers;

/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "TURTLE_SELECTED":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 143 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  var state = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	  var action = arguments[1];
	
	
	  switch (action.type) {
	
	    case "USER_SELECTED":
	      return action.payload;
	      break;
	    case "ADD_USER_NAME":
	      return action.payload;
	      break;
	    case "ADD_USER_AGE":
	      return action.payload;
	      break;
	  }
	  return state;
	};

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return [{
	    id: 1,
	    name: "Leonardo",
	    aka: "Leo",
	    age: "eternally < 20",
	    image: _leonardo2.default,
	    description: "Leonardo is the cool, courageous leader of the Ninja Turtles and a devoted student of Ninjutsu, usually wearing a blue mask and wielding two katanas. Leader in blue."
	  }, {
	    id: 2,
	    name: "Michaelangelo",
	    aka: "Mickey",
	    age: "eternally < 20",
	    image: _michaelangelo2.default,
	    description: "Michelangelo is the most comical of the Ninja Turtles, usually wearing an orange mask and wielding a pair of nunchucks."
	  }, {
	    id: 3,
	    name: "Donatello",
	    aka: "Donnie",
	    age: "eternally < 20",
	    image: _donatello2.default,
	    description: "Donatello is the scientist, inventor, engineer and technological genius of the Ninja Turtles, usually wearing a purple mask and wielding a bo-staff."
	  }, {
	    id: 4,
	    name: "Raphael",
	    aka: "Raph",
	    age: "eternally < 20",
	    image: _raphael2.default,
	    description: "Raphael is the bad boy of the Ninja Turtles, wearing a red mask and wielding a pair of sais."
	  }];
	};
	
	var _leonardo = __webpack_require__(302);
	
	var _leonardo2 = _interopRequireDefault(_leonardo);
	
	var _michaelangelo = __webpack_require__(303);
	
	var _michaelangelo2 = _interopRequireDefault(_michaelangelo);
	
	var _donatello = __webpack_require__(301);
	
	var _donatello2 = _interopRequireDefault(_donatello);
	
	var _raphael = __webpack_require__(304);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	
	  var today = new Date(),
	      dd = today.getDate(),
	      mm = today.getMonth() + 1,
	      yyyy = today.getFullYear();
	
	  return [{
	    id: 1,
	    name: "Leonardo",
	    last: "Da Vinci",
	    bornMonth: "April",
	    bornDay: 15,
	    bornYear: 1452,
	    age: (0, _ageCalculator2.default)([yyyy - 1452, mm - 4, dd - 15]),
	    image: _daVinci2.default,
	    description: "Leonardo di ser Piero da Vinci, more commonly Leonardo a Vinci or simply Leonardo, was an Italian polymath whose areas of interest included invention, painting, sculpting, architecture, science, music, mathematics, engineering, literature, anatomy, geology, astronomy, botany, writing, history, and cartography. He has been variously called the father of palaeontology, ichnology, and architecture, and is widely considered one of the greatest painters of all time. Sometimes credited with the inventions of the parachute, helicopter and tank, he epitomised the Renaissance humanist ideal."
	  }, {
	    id: 2,
	    name: "Isaac",
	    last: "Newton",
	    bornMonth: "January",
	    bornDay: 4,
	    bornYear: 1643,
	    age: (0, _ageCalculator2.default)([yyyy - 1643, mm - 1, dd - 4]),
	    image: _Newton2.default,
	    description: "Sir Isaac Newton was an English physicist and mathematician (described in his own day as a \"natural philosopher\") who is widely recognised as one of the most influential scientists of all time and a key figure in the scientific revolution. His book Philosophi Naturalis Principia Mathematica (\"Mathematical Principles of Natural Philosophy\"), first published in 1687, laid the foundations for classical mechanics. Newton made seminal contributions to optics, and he shares credit with Gottfried Wilhelm Leibniz for the development of calculus."
	  }, {
	    id: 3,
	    name: "Leonhard",
	    last: "Euler",
	    bornMonth: "April",
	    bornDay: 15,
	    bornYear: 1707,
	    age: (0, _ageCalculator2.default)([yyyy - 1707, mm - 4, dd - 15]),
	    image: _Euler2.default,
	    description: "Leonhard Euler was a Swiss mathematician, physicist, astronomer, logician and engineer who made important and influential discoveries in many branches of mathematics like infinitesimal calculus and graph theory while also making pioneering contributions to several branches such as topology and analytic number theory. He also introduced much of the modern mathematical terminology and notation, particularly for mathematical analysis, such as the notion of a mathematical function.  He is also known for his work in mechanics, fluid dynamics, optics, astronomy, and music theory."
	  }, {
	    id: 4,
	    name: "Albert",
	    last: "Einstein",
	    bornMonth: "March",
	    bornDay: 14,
	    bornYear: 1879,
	    age: (0, _ageCalculator2.default)([yyyy - 1879, mm - 3, dd - 14]),
	    image: _Einstein2.default,
	    description: "Albert Einstein was a German-born theoretical physicist. He developed the general theory of relativity, one of the two pillars of modern physics (alongside quantum mechanics).  Einstein's work is also known for its influence on the philosophy of science.  Einstein is best known in popular culture for his massenergy equivalence formula E = mc2 (which has been dubbed \"the world's most famous equation\").  He received the 1921 Nobel Prize in Physics for his \"services to theoretical physics\", in particular his discovery of the law of the photoelectric effect, a pivotal step in the evolution of quantum theory."
	  }, {
	    id: 5,
	    name: "Erwin",
	    last: "Schroedinger",
	    bornMonth: "August",
	    bornDay: 12,
	    bornYear: 1887,
	    age: (0, _ageCalculator2.default)([yyyy - 1887, mm - 8, dd - 12]),
	    image: _Schroedinger2.default,
	    description: "Erwin Rudolf Josef Alexander Schrdinger, sometimes written as Erwin Schrodinger or Erwin Schroedinger, was a Nobel Prize-winning Austrian physicist who developed a number of fundamental results in the field of quantum theory, which formed the basis of wave mechanics: he formulated the wave equation (stationary and time-dependent Schrdinger equation) and revealed the identity of his development of the formalism and matrix mechanics. Schrdinger proposed an original interpretation of the physical meaning of the wave function."
	  }, {
	    id: 6,
	    name: "Georges",
	    last: "Lemaitre",
	    bornMonth: "July",
	    bornDay: 17,
	    bornYear: 1894,
	    age: (0, _ageCalculator2.default)([yyyy - 1894, mm - 7, dd - 17]),
	    image: _Lemaitre2.default,
	    description: "Georges Henri Joseph douard Lematre was a Belgian priest, astronomer and professor of physics at the Catholic University of Leuven.  He proposed the theory of the expansion of the universe, widely misattributed to Edwin Hubble.  He was the first to derive what is now known as Hubble's law and made the first estimation of what is now called the Hubble constant, which he published in 1927, two years before Hubble's article.  Lematre also proposed what became known as the Big Bang theory of the origin of the universe, which he called his \"hypothesis of the primeval atom\" or the \"Cosmic Egg\"."
	  }, {
	    id: 7,
	    name: "Mother",
	    last: "Teresa",
	    bornMonth: "August",
	    bornDay: 26,
	    bornYear: 1910,
	    age: (0, _ageCalculator2.default)([yyyy - 1910, mm - 8, dd - 26]),
	    image: _MTeresa2.default,
	    description: "Mother Teresa MC, known in the Catholic Church as Saint Teresa of Calcutta was an Albanian-Indian Roman Catholic nun and missionary.  She was born in Skopje (now capital of the Republic of Macedonia), then part of the Kosovo Vilayet in the Ottoman Empire. After having lived in Macedonia for eighteen years, she moved to Ireland and then to India, where she lived for most of her life.  In 1950, Teresa founded the Missionaries of Charity, a Roman Catholic religious congregation, which in 2012 consisted of over 4,500 sisters and was active in 133 countries. They run homes for people dying of HIV/AIDS, leprosy and tuberculosis; soup kitchens; dispensaries and mobile clinics; children's and family counselling programmes; orphanages; and schools. Members must adhere to the vows of chastity, poverty, and obedience, as well as a fourth vow, to give \"wholehearted free service to the poorest of the poor.\""
	  }];
	};
	
	var _daVinci = __webpack_require__(300);
	
	var _daVinci2 = _interopRequireDefault(_daVinci);
	
	var _Einstein = __webpack_require__(294);
	
	var _Einstein2 = _interopRequireDefault(_Einstein);
	
	var _Euler = __webpack_require__(295);
	
	var _Euler2 = _interopRequireDefault(_Euler);
	
	var _Lemaitre = __webpack_require__(296);
	
	var _Lemaitre2 = _interopRequireDefault(_Lemaitre);
	
	var _MTeresa = __webpack_require__(297);
	
	var _MTeresa2 = _interopRequireDefault(_MTeresa);
	
	var _Newton = __webpack_require__(298);
	
	var _Newton2 = _interopRequireDefault(_Newton);
	
	var _Schroedinger = __webpack_require__(299);
	
	var _Schroedinger2 = _interopRequireDefault(_Schroedinger);
	
	var _ageCalculator = __webpack_require__(140);
	
	var _ageCalculator2 = _interopRequireDefault(_ageCalculator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	var _reactRouterRedux = __webpack_require__(83);
	
	var _container = __webpack_require__(147);
	
	var _home = __webpack_require__(148);
	
	var _user = __webpack_require__(151);
	
	var _turtles = __webpack_require__(150);
	
	var _notfound = __webpack_require__(149);
	
	var _store = __webpack_require__(79);
	
	var _store2 = _interopRequireDefault(_store);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var history = (0, _reactRouterRedux.syncHistoryWithStore)(_reactRouter.browserHistory, _store2.default);
	
	var App = function (_React$Component) {
	  _inherits(App, _React$Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        _reactRouter.Router,
	        { history: history },
	        _react2.default.createElement(
	          _reactRouter.Route,
	          { path: '/', component: _container.Container },
	          _react2.default.createElement(_reactRouter.IndexRoute, { component: _home.Home }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'user', component: _user.User }),
	          _react2.default.createElement(_reactRouter.Route, { path: 'turtles(/:name)', component: _turtles.Turtles }),
	          _react2.default.createElement(_reactRouter.Route, { path: '*', component: _notfound.NotFound })
	        )
	      );
	    }
	  }]);
	
	  return App;
	}(_react2.default.Component);
	
	exports.default = App;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Container = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(90);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  fontFamily: 'Dosis'
	};
	
	var Container = exports.Container = function Container(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement(Nav, null),
	    props.children
	  );
	};
	var Nav = function Nav() {
	  return _react2.default.createElement(
	    'nav',
	    { className: 'navbar navbar-inverse' },
	    _react2.default.createElement(
	      'div',
	      { className: 'container-fluid' },
	      _react2.default.createElement(
	        'div',
	        { className: 'navbar-header' },
	        _react2.default.createElement(
	          'button',
	          { type: 'button', className: 'navbar-toggle', 'data-toggle': 'collapse', 'data-target': '#myNavbar' },
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' }),
	          _react2.default.createElement('span', { className: 'icon-bar' })
	        )
	      )
	    ),
	    _react2.default.createElement(
	      'div',
	      { className: 'collapse navbar-collapse', id: 'myNavbar' },
	      _react2.default.createElement(
	        'ul',
	        { className: 'nav navbar-nav' },
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/' },
	            'Home'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/user' },
	            'Famous People'
	          )
	        ),
	        _react2.default.createElement(
	          'li',
	          null,
	          _react2.default.createElement(
	            _reactRouter.IndexLink,
	            { activeClassName: 'active', to: '/turtles' },
	            'Mutant Turtles'
	          )
	        )
	      )
	    )
	  );
	};

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Home = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Home = exports.Home = function Home() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'Welcome to the World of famE and muTAatIoNs!'
	    ),
	    _react2.default.createElement(
	      'h4',
	      null,
	      '> click on navigation to see more...'
	    )
	  );
	};

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NotFound = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NotFound = exports.NotFound = function NotFound() {
	  return _react2.default.createElement(
	    'h2',
	    null,
	    '404: This page is not found!'
	  );
	};

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Turtles = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compTurtle = __webpack_require__(134);
	
	var _compTurtle2 = _interopRequireDefault(_compTurtle);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var Turtles = exports.Turtles = function Turtles(props) {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Turtles Page'
	    ),
	    _react2.default.createElement(_compTurtle2.default, null)
	  );
	};

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.User = undefined;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _compUser = __webpack_require__(135);
	
	var _compUser2 = _interopRequireDefault(_compUser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var myStyle = {
	  marginLeft: 30,
	  marginRight: 25,
	  fontFamily: 'Dosis'
	};
	
	var User = exports.User = function User() {
	  return _react2.default.createElement(
	    'div',
	    { style: myStyle },
	    _react2.default.createElement('br', null),
	    _react2.default.createElement(
	      'h2',
	      null,
	      'This is the Famous People Page'
	    ),
	    _react2.default.createElement(_compUser2.default, null)
	  );
	};

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(212);


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = undefined;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var didWarnAboutReceivingStore = false;
	function warnAboutReceivingStore() {
	  if (didWarnAboutReceivingStore) {
	    return;
	  }
	  didWarnAboutReceivingStore = true;
	
	  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
	}
	
	var Provider = function (_Component) {
	  _inherits(Provider, _Component);
	
	  Provider.prototype.getChildContext = function getChildContext() {
	    return { store: this.store };
	  };
	
	  function Provider(props, context) {
	    _classCallCheck(this, Provider);
	
	    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	    _this.store = props.store;
	    return _this;
	  }
	
	  Provider.prototype.render = function render() {
	    var children = this.props.children;
	
	    return _react.Children.only(children);
	  };
	
	  return Provider;
	}(_react.Component);
	
	exports["default"] = Provider;
	
	if (process.env.NODE_ENV !== 'production') {
	  Provider.prototype.componentWillReceiveProps = function (nextProps) {
	    var store = this.store;
	    var nextStore = nextProps.store;
	
	    if (store !== nextStore) {
	      warnAboutReceivingStore();
	    }
	  };
	}
	
	Provider.propTypes = {
	  store: _storeShape2["default"].isRequired,
	  children: _react.PropTypes.element.isRequired
	};
	Provider.childContextTypes = {
	  store: _storeShape2["default"].isRequired
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.__esModule = true;
	exports["default"] = connect;
	
	var _react = __webpack_require__(5);
	
	var _storeShape = __webpack_require__(80);
	
	var _storeShape2 = _interopRequireDefault(_storeShape);
	
	var _shallowEqual = __webpack_require__(155);
	
	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);
	
	var _wrapActionCreators = __webpack_require__(156);
	
	var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);
	
	var _warning = __webpack_require__(81);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _isPlainObject = __webpack_require__(163);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _hoistNonReactStatics = __webpack_require__(157);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _invariant = __webpack_require__(158);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var defaultMapStateToProps = function defaultMapStateToProps(state) {
	  return {};
	}; // eslint-disable-line no-unused-vars
	var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
	  return { dispatch: dispatch };
	};
	var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
	  return _extends({}, parentProps, stateProps, dispatchProps);
	};
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	var errorObject = { value: null };
	function tryCatch(fn, ctx) {
	  try {
	    return fn.apply(ctx);
	  } catch (e) {
	    errorObject.value = e;
	    return errorObject;
	  }
	}
	
	// Helps track hot reloading.
	var nextVersion = 0;
	
	function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
	  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
	
	  var shouldSubscribe = Boolean(mapStateToProps);
	  var mapState = mapStateToProps || defaultMapStateToProps;
	
	  var mapDispatch = undefined;
	  if (typeof mapDispatchToProps === 'function') {
	    mapDispatch = mapDispatchToProps;
	  } else if (!mapDispatchToProps) {
	    mapDispatch = defaultMapDispatchToProps;
	  } else {
	    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
	  }
	
	  var finalMergeProps = mergeProps || defaultMergeProps;
	  var _options$pure = options.pure;
	  var pure = _options$pure === undefined ? true : _options$pure;
	  var _options$withRef = options.withRef;
	  var withRef = _options$withRef === undefined ? false : _options$withRef;
	
	  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;
	
	  // Helps track hot reloading.
	  var version = nextVersion++;
	
	  return function wrapWithConnect(WrappedComponent) {
	    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';
	
	    function checkStateShape(props, methodName) {
	      if (!(0, _isPlainObject2["default"])(props)) {
	        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
	      }
	    }
	
	    function computeMergedProps(stateProps, dispatchProps, parentProps) {
	      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
	      if (process.env.NODE_ENV !== 'production') {
	        checkStateShape(mergedProps, 'mergeProps');
	      }
	      return mergedProps;
	    }
	
	    var Connect = function (_Component) {
	      _inherits(Connect, _Component);
	
	      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
	        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
	      };
	
	      function Connect(props, context) {
	        _classCallCheck(this, Connect);
	
	        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));
	
	        _this.version = version;
	        _this.store = props.store || context.store;
	
	        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));
	
	        var storeState = _this.store.getState();
	        _this.state = { storeState: storeState };
	        _this.clearCache();
	        return _this;
	      }
	
	      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
	        if (!this.finalMapStateToProps) {
	          return this.configureFinalMapState(store, props);
	        }
	
	        var state = store.getState();
	        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(stateProps, 'mapStateToProps');
	        }
	        return stateProps;
	      };
	
	      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
	        var mappedState = mapState(store.getState(), props);
	        var isFactory = typeof mappedState === 'function';
	
	        this.finalMapStateToProps = isFactory ? mappedState : mapState;
	        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeStateProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedState, 'mapStateToProps');
	        }
	        return mappedState;
	      };
	
	      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
	        if (!this.finalMapDispatchToProps) {
	          return this.configureFinalMapDispatch(store, props);
	        }
	
	        var dispatch = store.dispatch;
	
	        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(dispatchProps, 'mapDispatchToProps');
	        }
	        return dispatchProps;
	      };
	
	      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
	        var mappedDispatch = mapDispatch(store.dispatch, props);
	        var isFactory = typeof mappedDispatch === 'function';
	
	        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
	        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;
	
	        if (isFactory) {
	          return this.computeDispatchProps(store, props);
	        }
	
	        if (process.env.NODE_ENV !== 'production') {
	          checkStateShape(mappedDispatch, 'mapDispatchToProps');
	        }
	        return mappedDispatch;
	      };
	
	      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
	        var nextStateProps = this.computeStateProps(this.store, this.props);
	        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
	          return false;
	        }
	
	        this.stateProps = nextStateProps;
	        return true;
	      };
	
	      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
	        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
	        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
	          return false;
	        }
	
	        this.dispatchProps = nextDispatchProps;
	        return true;
	      };
	
	      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
	        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
	        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
	          return false;
	        }
	
	        this.mergedProps = nextMergedProps;
	        return true;
	      };
	
	      Connect.prototype.isSubscribed = function isSubscribed() {
	        return typeof this.unsubscribe === 'function';
	      };
	
	      Connect.prototype.trySubscribe = function trySubscribe() {
	        if (shouldSubscribe && !this.unsubscribe) {
	          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
	          this.handleChange();
	        }
	      };
	
	      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
	        if (this.unsubscribe) {
	          this.unsubscribe();
	          this.unsubscribe = null;
	        }
	      };
	
	      Connect.prototype.componentDidMount = function componentDidMount() {
	        this.trySubscribe();
	      };
	
	      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
	          this.haveOwnPropsChanged = true;
	        }
	      };
	
	      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
	        this.tryUnsubscribe();
	        this.clearCache();
	      };
	
	      Connect.prototype.clearCache = function clearCache() {
	        this.dispatchProps = null;
	        this.stateProps = null;
	        this.mergedProps = null;
	        this.haveOwnPropsChanged = true;
	        this.hasStoreStateChanged = true;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	        this.renderedElement = null;
	        this.finalMapDispatchToProps = null;
	        this.finalMapStateToProps = null;
	      };
	
	      Connect.prototype.handleChange = function handleChange() {
	        if (!this.unsubscribe) {
	          return;
	        }
	
	        var storeState = this.store.getState();
	        var prevStoreState = this.state.storeState;
	        if (pure && prevStoreState === storeState) {
	          return;
	        }
	
	        if (pure && !this.doStatePropsDependOnOwnProps) {
	          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
	          if (!haveStatePropsChanged) {
	            return;
	          }
	          if (haveStatePropsChanged === errorObject) {
	            this.statePropsPrecalculationError = errorObject.value;
	          }
	          this.haveStatePropsBeenPrecalculated = true;
	        }
	
	        this.hasStoreStateChanged = true;
	        this.setState({ storeState: storeState });
	      };
	
	      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
	        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');
	
	        return this.refs.wrappedInstance;
	      };
	
	      Connect.prototype.render = function render() {
	        var haveOwnPropsChanged = this.haveOwnPropsChanged;
	        var hasStoreStateChanged = this.hasStoreStateChanged;
	        var haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated;
	        var statePropsPrecalculationError = this.statePropsPrecalculationError;
	        var renderedElement = this.renderedElement;
	
	        this.haveOwnPropsChanged = false;
	        this.hasStoreStateChanged = false;
	        this.haveStatePropsBeenPrecalculated = false;
	        this.statePropsPrecalculationError = null;
	
	        if (statePropsPrecalculationError) {
	          throw statePropsPrecalculationError;
	        }
	
	        var shouldUpdateStateProps = true;
	        var shouldUpdateDispatchProps = true;
	        if (pure && renderedElement) {
	          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
	          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
	        }
	
	        var haveStatePropsChanged = false;
	        var haveDispatchPropsChanged = false;
	        if (haveStatePropsBeenPrecalculated) {
	          haveStatePropsChanged = true;
	        } else if (shouldUpdateStateProps) {
	          haveStatePropsChanged = this.updateStatePropsIfNeeded();
	        }
	        if (shouldUpdateDispatchProps) {
	          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
	        }
	
	        var haveMergedPropsChanged = true;
	        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
	          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
	        } else {
	          haveMergedPropsChanged = false;
	        }
	
	        if (!haveMergedPropsChanged && renderedElement) {
	          return renderedElement;
	        }
	
	        if (withRef) {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
	            ref: 'wrappedInstance'
	          }));
	        } else {
	          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
	        }
	
	        return this.renderedElement;
	      };
	
	      return Connect;
	    }(_react.Component);
	
	    Connect.displayName = connectDisplayName;
	    Connect.WrappedComponent = WrappedComponent;
	    Connect.contextTypes = {
	      store: _storeShape2["default"]
	    };
	    Connect.propTypes = {
	      store: _storeShape2["default"]
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
	        if (this.version === version) {
	          return;
	        }
	
	        // We are hot reloading!
	        this.version = version;
	        this.trySubscribe();
	        this.clearCache();
	      };
	    }
	
	    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 155 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = shallowEqual;
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var hasOwn = Object.prototype.hasOwnProperty;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = wrapActionCreators;
	
	var _redux = __webpack_require__(37);
	
	function wrapActionCreators(actionCreators) {
	  return function (dispatch) {
	    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
	  };
	}

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {
	
	                }
	            }
	        }
	    }
	
	    return targetComponent;
	};


/***/ },
/* 158 */
10,
/* 159 */
[305, 161],
/* 160 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	module.exports = isHostObject;


/***/ },
/* 161 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ },
/* 163 */
[306, 159, 160, 162],
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports['default'] = routerMiddleware;
	
	var _actions = __webpack_require__(82);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	/**
	 * This middleware captures CALL_HISTORY_METHOD actions to redirect to the
	 * provided history object. This will prevent these actions from reaching your
	 * reducer or any middleware that comes after this one.
	 */
	function routerMiddleware(history) {
	  return function () {
	    return function (next) {
	      return function (action) {
	        if (action.type !== _actions.CALL_HISTORY_METHOD) {
	          return next(action);
	        }
	
	        var _action$payload = action.payload;
	        var method = _action$payload.method;
	        var args = _action$payload.args;
	
	        history[method].apply(history, _toConsumableArray(args));
	      };
	    };
	  };
	}

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports['default'] = syncHistoryWithStore;
	
	var _reducer = __webpack_require__(84);
	
	var defaultSelectLocationState = function defaultSelectLocationState(state) {
	  return state.routing;
	};
	
	/**
	 * This function synchronizes your history state with the Redux store.
	 * Location changes flow from history to the store. An enhanced history is
	 * returned with a listen method that responds to store updates for location.
	 *
	 * When this history is provided to the router, this means the location data
	 * will flow like this:
	 * history.push -> store.dispatch -> enhancedHistory.listen -> router
	 * This ensures that when the store state changes due to a replay or other
	 * event, the router will be updated appropriately and can transition to the
	 * correct router state.
	 */
	function syncHistoryWithStore(history, store) {
	  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	  var _ref$selectLocationSt = _ref.selectLocationState;
	  var selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt;
	  var _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay;
	  var adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;
	
	  // Ensure that the reducer is mounted on the store and functioning properly.
	  if (typeof selectLocationState(store.getState()) === 'undefined') {
	    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');
	  }
	
	  var initialLocation = void 0;
	  var isTimeTraveling = void 0;
	  var unsubscribeFromStore = void 0;
	  var unsubscribeFromHistory = void 0;
	
	  // What does the store say about current location?
	  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {
	    var locationState = selectLocationState(store.getState());
	    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);
	  };
	
	  // Init currentLocation with potential location in store
	  var currentLocation = getLocationInStore();
	
	  // If the store is replayed, update the URL in the browser to match.
	  if (adjustUrlOnReplay) {
	    var handleStoreChange = function handleStoreChange() {
	      var locationInStore = getLocationInStore(true);
	      if (currentLocation === locationInStore) {
	        return;
	      }
	
	      // Update address bar to reflect store state
	      isTimeTraveling = true;
	      currentLocation = locationInStore;
	      history.transitionTo(_extends({}, locationInStore, {
	        action: 'PUSH'
	      }));
	      isTimeTraveling = false;
	    };
	
	    unsubscribeFromStore = store.subscribe(handleStoreChange);
	    handleStoreChange();
	  }
	
	  // Whenever location changes, dispatch an action to get it in the store
	  var handleLocationChange = function handleLocationChange(location) {
	    // ... unless we just caused that location change
	    if (isTimeTraveling) {
	      return;
	    }
	
	    // Remember where we are
	    currentLocation = location;
	
	    // Are we being called for the first time?
	    if (!initialLocation) {
	      // Remember as a fallback in case state is reset
	      initialLocation = location;
	
	      // Respect persisted location, if any
	      if (getLocationInStore()) {
	        return;
	      }
	    }
	
	    // Tell the store to update by dispatching an action
	    store.dispatch({
	      type: _reducer.LOCATION_CHANGE,
	      payload: location
	    });
	  };
	  unsubscribeFromHistory = history.listen(handleLocationChange);
	
	  // The enhanced history uses store as source of truth
	  return _extends({}, history, {
	    // The listeners are subscribed to the store instead of history
	
	    listen: function listen(listener) {
	      // Copy of last location.
	      var lastPublishedLocation = getLocationInStore(true);
	
	      // Keep track of whether we unsubscribed, as Redux store
	      // only applies changes in subscriptions on next dispatch
	      var unsubscribed = false;
	      var unsubscribeFromStore = store.subscribe(function () {
	        var currentLocation = getLocationInStore(true);
	        if (currentLocation === lastPublishedLocation) {
	          return;
	        }
	        lastPublishedLocation = currentLocation;
	        if (!unsubscribed) {
	          listener(lastPublishedLocation);
	        }
	      });
	
	      // History listeners expect a synchronous call. Make the first call to the
	      // listener after subscribing to the store, in case the listener causes a
	      // location change (e.g. when it redirects)
	      listener(lastPublishedLocation);
	
	      // Let user unsubscribe later
	      return function () {
	        unsubscribed = true;
	        unsubscribeFromStore();
	      };
	    },
	
	
	    // It also provides a way to destroy internal listeners
	    unsubscribe: function unsubscribe() {
	      if (adjustUrlOnReplay) {
	        unsubscribeFromStore();
	      }
	      unsubscribeFromHistory();
	    }
	  });
	}

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(85);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(86);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(23);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(38);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(188);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(26);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(95);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(89);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(26);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(88);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(20);
	
	var _RouterUtils = __webpack_require__(87);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation, nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(50);
	
	var _makeStateWithLocation = __webpack_require__(91);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(26);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(20);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _useQueries = __webpack_require__(41);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(52);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(8);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(5);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(196);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(51);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 187 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	var _ExecutionEnvironment = __webpack_require__(40);
	
	var _DOMUtils = __webpack_require__(53);
	
	var _DOMStateStorage = __webpack_require__(93);
	
	var _createDOMHistory = __webpack_require__(94);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	          window.history.pushState(historyState, null, path);
	        }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	          window.history.replaceState(historyState, null, path);
	        }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(27);
	
	var _PathUtils = __webpack_require__(24);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if (typeof action === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(15);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(10);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(24);
	
	var _Actions = __webpack_require__(27);
	
	var _createHistory = __webpack_require__(96);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if (typeof entry === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(193);
	var isArguments = __webpack_require__(192);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ },
/* 192 */
/***/ function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ },
/* 193 */
/***/ function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;
	
	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strictUriEncode = __webpack_require__(195);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};


/***/ },
/* 195 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};


/***/ },
/* 196 */
157,
/* 197 */
15,
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var focusNode = __webpack_require__(125);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function () {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var FallbackCompositionState = __webpack_require__(205);
	var SyntheticCompositionEvent = __webpack_require__(249);
	var SyntheticInputEvent = __webpack_require__(252);
	
	var keyOf = __webpack_require__(22);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactInstrumentation = __webpack_require__(11);
	
	var camelizeStyleName = __webpack_require__(268);
	var dangerousStyleValue = __webpack_require__(258);
	var hyphenateStyleName = __webpack_require__(275);
	var memoizeStringOnly = __webpack_require__(278);
	var warning = __webpack_require__(3);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function (name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function (name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function (owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function (name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function (node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	var SyntheticEvent = __webpack_require__(19);
	
	var getEventTarget = __webpack_require__(72);
	var isEventSupported = __webpack_require__(74);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var DOMLazyTree = __webpack_require__(28);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createNodesFromMarkup = __webpack_require__(271);
	var emptyFunction = __webpack_require__(14);
	var invariant = __webpack_require__(2);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(22);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticMouseEvent = __webpack_require__(46);
	
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactComponent = __webpack_require__(61);
	var ReactPureComponent = __webpack_require__(239);
	var ReactClass = __webpack_require__(102);
	var ReactDOMFactories = __webpack_require__(217);
	var ReactElement = __webpack_require__(13);
	var ReactPropTypes = __webpack_require__(113);
	var ReactVersion = __webpack_require__(114);
	
	var onlyChild = __webpack_require__(264);
	var warning = __webpack_require__(3);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function () {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(29);
	
	var instantiateReactComponent = __webpack_require__(121);
	var KeyEscapeUtils = __webpack_require__(59);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(12);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildrenMutationWarningHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element._shadowChildren === undefined) {
	    return;
	  }
	  if (element._shadowChildren === element.props.children) {
	    return;
	  }
	  var isMutated = false;
	  if (Array.isArray(element._shadowChildren)) {
	    if (element._shadowChildren.length === element.props.children.length) {
	      for (var i = 0; i < element._shadowChildren.length; i++) {
	        if (element._shadowChildren[i] !== element.props.children[i]) {
	          isMutated = true;
	        }
	      }
	    } else {
	      isMutated = true;
	    }
	  }
	  if (!Array.isArray(element._shadowChildren) || isMutated) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Component\'s children should not be mutated.%s', ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	var ReactChildrenMutationWarningHook = {
	  onMountComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  },
	  onUpdateComponent: function (debugID) {
	    handleElement(debugID, ReactComponentTreeHook.getElement(debugID));
	  }
	};
	
	module.exports = ReactChildrenMutationWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMIDOperations = __webpack_require__(219);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactElement = __webpack_require__(13);
	var ReactErrorUtils = __webpack_require__(63);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactNodeTypes = __webpack_require__(112);
	var ReactPropTypeLocations = __webpack_require__(45);
	var ReactReconciler = __webpack_require__(29);
	
	var checkReactTypeSpec = __webpack_require__(117);
	var emptyObject = __webpack_require__(36);
	var invariant = __webpack_require__(2);
	var shallowEqual = __webpack_require__(78);
	var shouldUpdateReactComponent = __webpack_require__(75);
	var warning = __webpack_require__(3);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || ReactElement.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function invokeComponentDidMountWithTimer() {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	  publicInstance.componentDidMount();
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidMount');
	  }
	}
	
	function invokeComponentDidUpdateWithTimer(prevProps, prevState, prevContext) {
	  var publicInstance = this._instance;
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	  publicInstance.componentDidUpdate(prevProps, prevState, prevContext);
	  if (this._debugID !== 0) {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentDidUpdate');
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || ReactElement.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidMountWithTimer, this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	    var instanceOrElement;
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	      instanceOrElement = new Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'ctor');
	        }
	      }
	    } else {
	      // This can still be an instance in case of factory components
	      // but we'll count this as time spent rendering as the more common case.
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	      instanceOrElement = Component(publicProps, publicContext, updateQueue);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	        }
	      }
	    }
	    return instanceOrElement;
	  },
	
	  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onError();
	        }
	      }
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      inst.componentWillMount();
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillMount');
	        }
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var selfDebugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      selfDebugID = this._debugID;
	    }
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function () {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        inst.componentWillUnmount();
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUnmount');
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	    }
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onEndProcessingChildContext();
	    }
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function (typeSpecs, values, location) {
	    checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	      inst.componentWillReceiveProps(nextProps, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillReceiveProps');
	        }
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	        shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        if (process.env.NODE_ENV !== 'production') {
	          if (this._debugID !== 0) {
	            ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'shouldComponentUpdate');
	          }
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'componentWillUpdate');
	        }
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(invokeComponentDidUpdateWithTimer.bind(this, prevProps, prevState, prevContext), this);
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = this._debugID;
	      }
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), selfDebugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._debugID !== 0) {
	          ReactInstrumentation.debugTool.onSetChildren(this._debugID, child._debugID !== 0 ? [child._debugID] : []);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeginLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      if (this._debugID !== 0) {
	        ReactInstrumentation.debugTool.onEndLifeCycleTimer(this._debugID, 'render');
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedComponent === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDefaultInjection = __webpack_require__(230);
	var ReactMount = __webpack_require__(110);
	var ReactReconciler = __webpack_require__(29);
	var ReactUpdates = __webpack_require__(16);
	var ReactVersion = __webpack_require__(114);
	
	var findDOMNode = __webpack_require__(259);
	var getHostComponentFromComposite = __webpack_require__(119);
	var renderSubtreeIntoContainer = __webpack_require__(266);
	var warning = __webpack_require__(3);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function (inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(9);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(11);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(227);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(221);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var DisabledInputUtils = __webpack_require__(42);
	
	/**
	 * Implements a <button> host component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getHostProps: DisabledInputUtils.getHostProps
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var AutoFocusUtils = __webpack_require__(198);
	var CSSPropertyOperations = __webpack_require__(200);
	var DOMLazyTree = __webpack_require__(28);
	var DOMNamespaces = __webpack_require__(57);
	var DOMProperty = __webpack_require__(25);
	var DOMPropertyOperations = __webpack_require__(100);
	var EventConstants = __webpack_require__(17);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactDOMButton = __webpack_require__(213);
	var ReactDOMComponentFlags = __webpack_require__(103);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMInput = __webpack_require__(220);
	var ReactDOMOption = __webpack_require__(222);
	var ReactDOMSelect = __webpack_require__(104);
	var ReactDOMTextarea = __webpack_require__(225);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChild = __webpack_require__(237);
	var ReactServerRenderingTransaction = __webpack_require__(242);
	
	var emptyFunction = __webpack_require__(14);
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var isEventSupported = __webpack_require__(74);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(3);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setContentChildForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setContentChildForInstrumentation = function (content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setContentChildForInstrumentation.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getHostProps(this, props, hostParent);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getHostProps(this, lastProps);
	        nextProps = ReactDOMButton.getHostProps(this, nextProps);
	        break;
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setContentChildForInstrumentation.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setContentChildForInstrumentation.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function () {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function (safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setContentChildForInstrumentation.call(this, null);
	    }
	  },
	
	  getPublicInstance: function () {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMContainerInfo
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(77);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMEmptyComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var ReactDOMEmptyComponent = function (instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function () {},
	  getHostNode: function () {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function () {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(13);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(105);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 218 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(56);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var DOMPropertyOperations = __webpack_require__(100);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked !== undefined : props.value !== undefined;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function (inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, DisabledInputUtils.getHostProps(inst, props), {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMNullInputValuePropHook
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactChildren = __webpack_require__(101);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMSelect = __webpack_require__(104);
	
	var warning = __webpack_require__(3);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  ReactChildren.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function (inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function (inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var getNodeForCharacterOffset = __webpack_require__(262);
	var getTextContentAccessor = __webpack_require__(120);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DOMChildrenOperations = __webpack_require__(56);
	var DOMLazyTree = __webpack_require__(28);
	var ReactDOMComponentTree = __webpack_require__(7);
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	var invariant = __webpack_require__(2);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting('#text', this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function () {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function () {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4),
	    _assign = __webpack_require__(6);
	
	var DisabledInputUtils = __webpack_require__(42);
	var LinkedValueUtils = __webpack_require__(60);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function (inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function (inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTreeTraversal
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], false, arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], true, arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], true, argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], false, argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMUnknownPropertyHook
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginRegistry = __webpack_require__(43);
	var ReactComponentTreeHook = __webpack_require__(12);
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function (tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function (debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDebugTool
	 */
	
	'use strict';
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(235);
	var ReactHostOperationHistoryHook = __webpack_require__(233);
	var ReactComponentTreeHook = __webpack_require__(12);
	var ReactChildrenMutationWarningHook = __webpack_require__(209);
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performanceNow = __webpack_require__(280);
	var warning = __webpack_require__(3);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = null;
	var currentFlushStartTime = null;
	var currentTimerDebugID = null;
	var currentTimerStartTime = null;
	var currentTimerNestedFlushDuration = null;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || ReactComponentTreeHook.getOwnerID(parentID),
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements || [];
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = null;
	    currentFlushMeasurements = null;
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = null;
	  currentTimerNestedFlushDuration = null;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop();
	
	  var startTime = _lifeCycleTimerStack$.startTime;
	  var nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime;
	  var debugID = _lifeCycleTimerStack$.debugID;
	  var timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var ReactDebugTool = {
	  addHook: function (hook) {
	    hooks.push(hook);
	  },
	  removeHook: function (hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function () {
	    return isProfiling;
	  },
	  beginProfiling: function () {
	    if (isProfiling) {
	      return;
	    }
	
	    isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function () {
	    if (!isProfiling) {
	      return;
	    }
	
	    isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function () {
	    return flushHistory;
	  },
	  onBeginFlush: function () {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function () {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function (debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onError: function (debugID) {
	    if (currentTimerDebugID != null) {
	      endLifeCycleTimer(currentTimerDebugID, currentTimerType);
	    }
	    emitEvent('onError', debugID);
	  },
	  onBeginProcessingChildContext: function () {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function () {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function (debugID, type, payload) {
	    checkDebugID(debugID);
	    emitEvent('onHostOperation', debugID, type, payload);
	  },
	  onSetState: function () {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function (debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function (debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	  },
	  onMountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function (debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	  },
	  onUpdateComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	  },
	  onUnmountComponent: function (debugID) {
	    checkDebugID(debugID);
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function () {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	ReactDebugTool.addHook(ReactChildrenMutationWarningHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactUpdates = __webpack_require__(16);
	var Transaction = __webpack_require__(35);
	
	var emptyFunction = __webpack_require__(14);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(199);
	var ChangeEventPlugin = __webpack_require__(201);
	var DefaultEventPluginOrder = __webpack_require__(203);
	var EnterLeaveEventPlugin = __webpack_require__(204);
	var HTMLDOMPropertyConfig = __webpack_require__(206);
	var ReactComponentBrowserEnvironment = __webpack_require__(210);
	var ReactDOMComponent = __webpack_require__(214);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactDOMEmptyComponent = __webpack_require__(216);
	var ReactDOMTreeTraversal = __webpack_require__(226);
	var ReactDOMTextComponent = __webpack_require__(224);
	var ReactDefaultBatchingStrategy = __webpack_require__(229);
	var ReactEventListener = __webpack_require__(232);
	var ReactInjection = __webpack_require__(234);
	var ReactReconcileTransaction = __webpack_require__(240);
	var SVGDOMPropertyConfig = __webpack_require__(244);
	var SelectEventPlugin = __webpack_require__(245);
	var SimpleEventPlugin = __webpack_require__(246);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(31);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var EventListener = __webpack_require__(124);
	var ExecutionEnvironment = __webpack_require__(9);
	var PooledClass = __webpack_require__(21);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactUpdates = __webpack_require__(16);
	
	var getEventTarget = __webpack_require__(72);
	var getUnboundedScrollPosition = __webpack_require__(273);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 233 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactHostOperationHistoryHook
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function (debugID, type, payload) {
	    history.push({
	      instanceID: debugID,
	      type: type,
	      payload: payload
	    });
	  },
	  clearHistory: function () {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function () {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(25);
	var EventPluginHub = __webpack_require__(31);
	var EventPluginUtils = __webpack_require__(58);
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactClass = __webpack_require__(102);
	var ReactEmptyComponent = __webpack_require__(106);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactHostComponent = __webpack_require__(108);
	var ReactUpdates = __webpack_require__(16);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInvalidSetStateWarningHook
	 */
	
	'use strict';
	
	var warning = __webpack_require__(3);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function () {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function () {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function () {
	    processingChildContext = false;
	  },
	  onSetState: function () {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(257);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactComponentEnvironment = __webpack_require__(62);
	var ReactInstanceMap = __webpack_require__(33);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactMultiChildUpdateTypes = __webpack_require__(111);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactReconciler = __webpack_require__(29);
	var ReactChildReconciler = __webpack_require__(208);
	
	var emptyFunction = __webpack_require__(14);
	var flattenChildren = __webpack_require__(260);
	var invariant = __webpack_require__(2);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function (inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function (children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function (safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPureComponent
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var ReactComponent = __webpack_require__(61);
	var ReactNoopUpdateQueue = __webpack_require__(64);
	
	var emptyObject = __webpack_require__(36);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var CallbackQueue = __webpack_require__(99);
	var PooledClass = __webpack_require__(21);
	var ReactBrowserEventEmitter = __webpack_require__(44);
	var ReactInputSelection = __webpack_require__(109);
	var ReactInstrumentation = __webpack_require__(11);
	var Transaction = __webpack_require__(35);
	var ReactUpdateQueue = __webpack_require__(67);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function () {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function (checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(238);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement.ref !== prevElement.ref ||
	    // If owner changes but we have an unchanged function ref, don't update refs
	    typeof nextElement.ref === 'string' && nextElement._owner !== prevElement._owner
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(6);
	
	var PooledClass = __webpack_require__(21);
	var Transaction = __webpack_require__(35);
	var ReactInstrumentation = __webpack_require__(11);
	var ReactServerUpdateQueue = __webpack_require__(243);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function () {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function () {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {},
	
	  checkpoint: function () {},
	
	  rollback: function () {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerUpdateQueue
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ReactUpdateQueue = __webpack_require__(67);
	var Transaction = __webpack_require__(35);
	var warning = __webpack_require__(3);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  /* :: transaction: Transaction; */
	
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 244 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(17);
	var EventPropagators = __webpack_require__(32);
	var ExecutionEnvironment = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInputSelection = __webpack_require__(109);
	var SyntheticEvent = __webpack_require__(19);
	
	var getActiveElement = __webpack_require__(126);
	var isTextInputElement = __webpack_require__(122);
	var keyOf = __webpack_require__(22);
	var shallowEqual = __webpack_require__(78);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var EventConstants = __webpack_require__(17);
	var EventListener = __webpack_require__(124);
	var EventPropagators = __webpack_require__(32);
	var ReactDOMComponentTree = __webpack_require__(7);
	var SyntheticAnimationEvent = __webpack_require__(247);
	var SyntheticClipboardEvent = __webpack_require__(248);
	var SyntheticEvent = __webpack_require__(19);
	var SyntheticFocusEvent = __webpack_require__(251);
	var SyntheticKeyboardEvent = __webpack_require__(253);
	var SyntheticMouseEvent = __webpack_require__(46);
	var SyntheticDragEvent = __webpack_require__(250);
	var SyntheticTouchEvent = __webpack_require__(254);
	var SyntheticTransitionEvent = __webpack_require__(255);
	var SyntheticUIEvent = __webpack_require__(34);
	var SyntheticWheelEvent = __webpack_require__(256);
	
	var emptyFunction = __webpack_require__(14);
	var getEventCharCode = __webpack_require__(70);
	var invariant = __webpack_require__(2);
	var keyOf = __webpack_require__(22);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  animationEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationEnd: true }),
	      captured: keyOf({ onAnimationEndCapture: true })
	    }
	  },
	  animationIteration: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationIteration: true }),
	      captured: keyOf({ onAnimationIterationCapture: true })
	    }
	  },
	  animationStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAnimationStart: true }),
	      captured: keyOf({ onAnimationStartCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  invalid: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInvalid: true }),
	      captured: keyOf({ onInvalidCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  transitionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTransitionEnd: true }),
	      captured: keyOf({ onTransitionEndCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topAnimationEnd: eventTypes.animationEnd,
	  topAnimationIteration: eventTypes.animationIteration,
	  topAnimationStart: eventTypes.animationStart,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topInvalid: eventTypes.invalid,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topTransitionEnd: eventTypes.transitionEnd,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topInvalid:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topAnimationEnd:
	      case topLevelTypes.topAnimationIteration:
	      case topLevelTypes.topAnimationStart:
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case topLevelTypes.topTransitionEnd:
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (inst, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticAnimationEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventCharCode = __webpack_require__(70);
	var getEventKey = __webpack_require__(261);
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(34);
	
	var getEventModifierState = __webpack_require__(71);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTransitionEvent
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(19);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(46);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 257 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var warning = __webpack_require__(3);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactCurrentOwner = __webpack_require__(18);
	var ReactDOMComponentTree = __webpack_require__(7);
	var ReactInstanceMap = __webpack_require__(33);
	
	var getHostComponentFromComposite = __webpack_require__(119);
	var invariant = __webpack_require__(2);
	var warning = __webpack_require__(3);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 * 
	 */
	
	'use strict';
	
	var KeyEscapeUtils = __webpack_require__(59);
	var traverseAllChildren = __webpack_require__(76);
	var warning = __webpack_require__(3);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(12);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && typeof traverseContext === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(12);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(70);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 262 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getVendorPrefixedEventName
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(4);
	
	var ReactElement = __webpack_require__(13);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(47);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(110);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 267 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(267);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(277);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var createArrayFromMixed = __webpack_require__(270);
	var getMarkupWrap = __webpack_require__(272);
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var invariant = __webpack_require__(2);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 273 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 274 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(274);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 276 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(276);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(9);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(279);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 281 */
/***/ function(module, exports) {

	"use strict";
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }
	
	var repeat = function repeat(str, times) {
	  return new Array(times + 1).join(str);
	};
	var pad = function pad(num, maxLength) {
	  return repeat("0", maxLength - num.toString().length) + num;
	};
	var formatTime = function formatTime(time) {
	  return "@ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
	};
	
	// Use the new performance api to get better precision if available
	var timer = typeof performance !== "undefined" && typeof performance.now === "function" ? performance : Date;
	
	/**
	 * parse the level option of createLogger
	 *
	 * @property {string | function | object} level - console[level]
	 * @property {object} action
	 * @property {array} payload
	 * @property {string} type
	 */
	
	function getLogLevel(level, action, payload, type) {
	  switch (typeof level === "undefined" ? "undefined" : _typeof(level)) {
	    case "object":
	      return typeof level[type] === "function" ? level[type].apply(level, _toConsumableArray(payload)) : level[type];
	    case "function":
	      return level(action);
	    default:
	      return level;
	  }
	}
	
	/**
	 * Creates logger with followed options
	 *
	 * @namespace
	 * @property {object} options - options for logger
	 * @property {string | function | object} options.level - console[level]
	 * @property {boolean} options.duration - print duration of each action?
	 * @property {boolean} options.timestamp - print timestamp with each action?
	 * @property {object} options.colors - custom colors
	 * @property {object} options.logger - implementation of the `console` API
	 * @property {boolean} options.logErrors - should errors in action execution be caught, logged, and re-thrown?
	 * @property {boolean} options.collapsed - is group collapsed?
	 * @property {boolean} options.predicate - condition which resolves logger behavior
	 * @property {function} options.stateTransformer - transform state before print
	 * @property {function} options.actionTransformer - transform action before print
	 * @property {function} options.errorTransformer - transform error before print
	 */
	
	function createLogger() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var _options$level = options.level;
	  var level = _options$level === undefined ? "log" : _options$level;
	  var _options$logger = options.logger;
	  var logger = _options$logger === undefined ? console : _options$logger;
	  var _options$logErrors = options.logErrors;
	  var logErrors = _options$logErrors === undefined ? true : _options$logErrors;
	  var collapsed = options.collapsed;
	  var predicate = options.predicate;
	  var _options$duration = options.duration;
	  var duration = _options$duration === undefined ? false : _options$duration;
	  var _options$timestamp = options.timestamp;
	  var timestamp = _options$timestamp === undefined ? true : _options$timestamp;
	  var transformer = options.transformer;
	  var _options$stateTransfo = options.stateTransformer;
	  var // deprecated
	  stateTransformer = _options$stateTransfo === undefined ? function (state) {
	    return state;
	  } : _options$stateTransfo;
	  var _options$actionTransf = options.actionTransformer;
	  var actionTransformer = _options$actionTransf === undefined ? function (actn) {
	    return actn;
	  } : _options$actionTransf;
	  var _options$errorTransfo = options.errorTransformer;
	  var errorTransformer = _options$errorTransfo === undefined ? function (error) {
	    return error;
	  } : _options$errorTransfo;
	  var _options$colors = options.colors;
	  var colors = _options$colors === undefined ? {
	    title: function title() {
	      return "#000000";
	    },
	    prevState: function prevState() {
	      return "#9E9E9E";
	    },
	    action: function action() {
	      return "#03A9F4";
	    },
	    nextState: function nextState() {
	      return "#4CAF50";
	    },
	    error: function error() {
	      return "#F20404";
	    }
	  } : _options$colors;
	
	  // exit if console undefined
	
	  if (typeof logger === "undefined") {
	    return function () {
	      return function (next) {
	        return function (action) {
	          return next(action);
	        };
	      };
	    };
	  }
	
	  if (transformer) {
	    console.error("Option 'transformer' is deprecated, use stateTransformer instead");
	  }
	
	  var logBuffer = [];
	  function printBuffer() {
	    logBuffer.forEach(function (logEntry, key) {
	      var started = logEntry.started;
	      var startedTime = logEntry.startedTime;
	      var action = logEntry.action;
	      var prevState = logEntry.prevState;
	      var error = logEntry.error;
	      var took = logEntry.took;
	      var nextState = logEntry.nextState;
	
	      var nextEntry = logBuffer[key + 1];
	      if (nextEntry) {
	        nextState = nextEntry.prevState;
	        took = nextEntry.started - started;
	      }
	      // message
	      var formattedAction = actionTransformer(action);
	      var isCollapsed = typeof collapsed === "function" ? collapsed(function () {
	        return nextState;
	      }, action) : collapsed;
	
	      var formattedTime = formatTime(startedTime);
	      var titleCSS = colors.title ? "color: " + colors.title(formattedAction) + ";" : null;
	      var title = "action " + (timestamp ? formattedTime : "") + " " + formattedAction.type + " " + (duration ? "(in " + took.toFixed(2) + " ms)" : "");
	
	      // render
	      try {
	        if (isCollapsed) {
	          if (colors.title) logger.groupCollapsed("%c " + title, titleCSS);else logger.groupCollapsed(title);
	        } else {
	          if (colors.title) logger.group("%c " + title, titleCSS);else logger.group(title);
	        }
	      } catch (e) {
	        logger.log(title);
	      }
	
	      var prevStateLevel = getLogLevel(level, formattedAction, [prevState], "prevState");
	      var actionLevel = getLogLevel(level, formattedAction, [formattedAction], "action");
	      var errorLevel = getLogLevel(level, formattedAction, [error, prevState], "error");
	      var nextStateLevel = getLogLevel(level, formattedAction, [nextState], "nextState");
	
	      if (prevStateLevel) {
	        if (colors.prevState) logger[prevStateLevel]("%c prev state", "color: " + colors.prevState(prevState) + "; font-weight: bold", prevState);else logger[prevStateLevel]("prev state", prevState);
	      }
	
	      if (actionLevel) {
	        if (colors.action) logger[actionLevel]("%c action", "color: " + colors.action(formattedAction) + "; font-weight: bold", formattedAction);else logger[actionLevel]("action", formattedAction);
	      }
	
	      if (error && errorLevel) {
	        if (colors.error) logger[errorLevel]("%c error", "color: " + colors.error(error, prevState) + "; font-weight: bold", error);else logger[errorLevel]("error", error);
	      }
	
	      if (nextStateLevel) {
	        if (colors.nextState) logger[nextStateLevel]("%c next state", "color: " + colors.nextState(nextState) + "; font-weight: bold", nextState);else logger[nextStateLevel]("next state", nextState);
	      }
	
	      try {
	        logger.groupEnd();
	      } catch (e) {
	        logger.log(" log end ");
	      }
	    });
	    logBuffer.length = 0;
	  }
	
	  return function (_ref) {
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        // exit early if predicate function returns false
	        if (typeof predicate === "function" && !predicate(getState, action)) {
	          return next(action);
	        }
	
	        var logEntry = {};
	        logBuffer.push(logEntry);
	
	        logEntry.started = timer.now();
	        logEntry.startedTime = new Date();
	        logEntry.prevState = stateTransformer(getState());
	        logEntry.action = action;
	
	        var returnedValue = undefined;
	        if (logErrors) {
	          try {
	            returnedValue = next(action);
	          } catch (e) {
	            logEntry.error = errorTransformer(e);
	          }
	        } else {
	          returnedValue = next(action);
	        }
	
	        logEntry.took = timer.now() - logEntry.started;
	        logEntry.nextState = stateTransformer(getState());
	
	        printBuffer();
	
	        if (logEntry.error) throw logEntry.error;
	        return returnedValue;
	      };
	    };
	  };
	}
	
	module.exports = createLogger;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = promiseMiddleware;
	
	var _isPromise = __webpack_require__(283);
	
	var _isPromise2 = _interopRequireDefault(_isPromise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var defaultTypes = ['PENDING', 'FULFILLED', 'REJECTED'];
	
	/**
	 * @function promiseMiddleware
	 * @description
	 * @returns {function} thunk
	 */
	function promiseMiddleware() {
	  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  var promiseTypeSuffixes = config.promiseTypeSuffixes || defaultTypes;
	
	  return function (ref) {
	    var dispatch = ref.dispatch;
	
	
	    return function (next) {
	      return function (action) {
	        if (action.payload) {
	          if (!(0, _isPromise2.default)(action.payload) && !(0, _isPromise2.default)(action.payload.promise)) {
	            return next(action);
	          }
	        } else {
	          return next(action);
	        }
	
	        // Deconstruct the properties of the original action object to constants
	        var type = action.type;
	        var payload = action.payload;
	        var meta = action.meta;
	
	        // Assign values for promise type suffixes
	
	        var _promiseTypeSuffixes = _slicedToArray(promiseTypeSuffixes, 3);
	
	        var PENDING = _promiseTypeSuffixes[0];
	        var FULFILLED = _promiseTypeSuffixes[1];
	        var REJECTED = _promiseTypeSuffixes[2];
	
	        /**
	         * @function getAction
	         * @description Utility function for creating a rejected or fulfilled
	         * flux standard action object.
	         * @param {boolean} Is the action rejected?
	         * @returns {object} action
	         */
	
	        var getAction = function getAction(newPayload, isRejected) {
	          return _extends({
	            type: type + '_' + (isRejected ? REJECTED : FULFILLED)
	          }, newPayload ? {
	            payload: newPayload
	          } : {}, !!meta ? { meta: meta } : {}, isRejected ? {
	            error: true
	          } : {});
	        };
	
	        /**
	         * Assign values for promise and data variables. In the case the payload
	         * is an object with a `promise` and `data` property, the values of those
	         * properties will be used. In the case the payload is a promise, the
	         * value of the payload will be used and data will be null.
	         */
	        var promise = void 0;
	        var data = void 0;
	
	        if (!(0, _isPromise2.default)(action.payload) && _typeof(action.payload) === 'object') {
	          promise = payload.promise;
	          data = payload.data;
	        } else {
	          promise = payload;
	          data = null;
	        }
	
	        /**
	         * First, dispatch the pending action. This flux standard action object
	         * describes the pending state of a promise and will include any data
	         * (for optimistic updates) and/or meta from the original action.
	         */
	        next(_extends({
	          type: type + '_' + PENDING
	        }, !!data ? { payload: data } : {}, !!meta ? { meta: meta } : {}));
	
	        /*
	         * @function handleReject
	         * @description Dispatch the rejected action and return
	         * an error object. The error object is the original error
	         * that was thrown. The user of the library is responsible for
	         * best practices in ensure that they are throwing an Error object.
	         * @params reason The reason the promise was rejected
	         * @returns {object}
	         */
	        var handleReject = function handleReject(reason) {
	          var rejectedAction = getAction(reason, true);
	          dispatch(rejectedAction);
	          throw reason;
	        };
	
	        /*
	         * @function handleFulfill
	         * @description Dispatch the fulfilled action and
	         * return the success object. The success object should
	         * contain the value and the dispatched action.
	         * @param value The value the promise was resloved with
	         * @returns {object}
	         */
	        var handleFulfill = function handleFulfill() {
	          var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	
	          var resolvedAction = getAction(value, false);
	          dispatch(resolvedAction);
	
	          return { value: value, action: resolvedAction };
	        };
	
	        /**
	         * Second, dispatch a rejected or fulfilled action. This flux standard
	         * action object will describe the resolved state of the promise. In
	         * the case of a rejected promise, it will include an `error` property.
	         *
	         * In order to allow proper chaining of actions using `then`, a new
	         * promise is constructed and returned. This promise will resolve
	         * with two properties: (1) the value (if fulfilled) or reason
	         * (if rejected) and (2) the flux standard action.
	         *
	         * Rejected object:
	         * {
	         *   reason: ...
	         *   action: {
	         *     error: true,
	         *     type: 'ACTION_REJECTED',
	         *     payload: ...
	         *   }
	         * }
	         *
	         * Fulfilled object:
	         * {
	         *   value: ...
	         *   action: {
	         *     type: 'ACTION_FULFILLED',
	         *     payload: ...
	         *   }
	         * }
	         */
	        return promise.then(handleFulfill, handleReject);
	      };
	    };
	  };
	}

/***/ },
/* 283 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isPromise;
	function isPromise(value) {
	  if (value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	    return value && typeof value.then === 'function';
	  }
	
	  return false;
	}

/***/ },
/* 284 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	function createThunkMiddleware(extraArgument) {
	  return function (_ref) {
	    var dispatch = _ref.dispatch;
	    var getState = _ref.getState;
	    return function (next) {
	      return function (action) {
	        if (typeof action === 'function') {
	          return action(dispatch, getState, extraArgument);
	        }
	
	        return next(action);
	      };
	    };
	  };
	}
	
	var thunk = createThunkMiddleware();
	thunk.withExtraArgument = createThunkMiddleware;
	
	exports['default'] = thunk;

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports["default"] = applyMiddleware;
	
	var _compose = __webpack_require__(127);
	
	var _compose2 = _interopRequireDefault(_compose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  return function (createStore) {
	    return function (reducer, initialState, enhancer) {
	      var store = createStore(reducer, initialState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = _compose2["default"].apply(undefined, chain)(store.dispatch);
	
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

/***/ },
/* 286 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports["default"] = bindActionCreators;
	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}
	
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports["default"] = combineReducers;
	
	var _createStore = __webpack_require__(128);
	
	var _isPlainObject = __webpack_require__(130);
	
	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);
	
	var _warning = __webpack_require__(129);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
	}
	
	function getUnexpectedStateShapeWarningMessage(inputState, reducers, action) {
	  var reducerKeys = Object.keys(reducers);
	  var argumentName = action && action.type === _createStore.ActionTypes.INIT ? 'initialState argument passed to createStore' : 'previous state received by the reducer';
	
	  if (reducerKeys.length === 0) {
	    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
	  }
	
	  if (!(0, _isPlainObject2["default"])(inputState)) {
	    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
	  }
	
	  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
	    return !reducers.hasOwnProperty(key);
	  });
	
	  if (unexpectedKeys.length > 0) {
	    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
	  }
	}
	
	function assertReducerSanity(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, { type: _createStore.ActionTypes.INIT });
	
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
	    }
	
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, { type: type }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + _createStore.ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
	    }
	  });
	}
	
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	
	  var sanityError;
	  try {
	    assertReducerSanity(finalReducers);
	  } catch (e) {
	    sanityError = e;
	  }
	
	  return function combination() {
	    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var action = arguments[1];
	
	    if (sanityError) {
	      throw sanityError;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action);
	      if (warningMessage) {
	        (0, _warning2["default"])(warningMessage);
	      }
	    }
	
	    var hasChanged = false;
	    var nextState = {};
	    for (var i = 0; i < finalReducerKeys.length; i++) {
	      var key = finalReducerKeys[i];
	      var reducer = finalReducers[key];
	      var previousStateForKey = state[key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 288 */
[305, 290],
/* 289 */
160,
/* 290 */
161,
/* 291 */
162,
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';
	
	module.exports = __webpack_require__(293)(global || window || this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 293 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;
	
		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}
	
		return result;
	};


/***/ },
/* 294 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 295 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 296 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD//gBKRmlsZSBzb3VyY2U6IGh0dHA6Ly9jb21tb25zLndpa2ltZWRpYS5vcmcvd2lraS9GaWxlOk1vdGhlclRlcmVzYV8wOTQuanBn/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxobIxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgA5QDcAwEiAAIRAQMRAf/EAB0AAAAHAQEBAAAAAAAAAAAAAAABAgMFBgcECAn/xABDEAABAgQEAwUFBQYFAwUAAAABAgMABAURBhIhMUFRYQcTInGBFDKRobEIFSNCwTNDUmLR4RYkcoLwosLiNHOSsvH/xAAbAQACAwEBAQAAAAAAAAAAAAACAwEEBQAGB//EADIRAAICAQQBAgQFAgcBAAAAAAABAhEDBBIhMUETUQUiMvAjcZHB4WGBBhQkQlKx0fH/2gAMAwEAAhEDEQA/AL12a15iYllUw+BcvokEZdDtpF9HnGVYnpzkkiQxDSEnvGkDvUJ/OjiP1i94crTVYpjMyyvMFJBOsYDRp3bdk6nYQYBHCGEv2hYeGsRRw5qNjpEbiShSeJKS7Tagm6HNUqGim1cFA847lPISkrcUlCBuomwA6mMc7UO2Wn0mXmKfhdwTdSIKVTQ1aZ52/iMMx45TdRIlNQ5Zj1cWimz87K9+JhuWeWyH0DReU2vaGKVXJVV0u6FJ/NxiiCpTDTjtnM4WsqWF6hRJ1Jh6WnJVxX42Zk23GojTel45Dxa26LxNYgls2UJvpplgSdfmVoeTL5hfw3J2Jinyy5a5zqWu/um28SMlOewsuZ0gNq1B3MA8EUqSH+vKXb4LHWptmXw37HcEuqSbcSoG5MPYS7SMSYfBZptUe7hpXhYe/EbtysdvSM/nJ9c3MZ1mwGiE32EIlnCl0n+KHR06UalyZ2fP6krj4PQ8j2/1nu/8zSpB88ShakH4axX692rVituk5lSjR/K2q/zjLJdwhXQ8I2bsP7OGsRP/AH7X2SuisLsywrQTbg3v/InjzOnAwmeLFjW5oGEpS4QWCsJYpxplm5NT0tIE/wDrZpRShX+gbr9NOsbdhbs6FBcbd/xDVH3R74AQltX+0gkfGLi0+kNoQ2hCG0gJQlAsABsAOUPBZPL6xTb3DW5IMMJGy136gQsJUjY5hBBUHmsNY5RAdnJWp6YlJFx6XDae7SVrKwTYAa6DePKHap2t1fFKHadJPqlqQFEKDfhU/b+LiB0+MeuiQbkHWMb7aOyaXxOw9VsPNty1dSMy2kgJROdDyXyPHjD8TSl8wLja4PIM2rMTf6xHuWvptErUWXZeYdYmG1tPNqKFoWmykqGhBHAxFOaKPKNSHRWYyreC3g16wR4wZJ3USoLpNWlZ5DYcLKr5CbZha1rxc5rtPnC2UyVNl2Fn87jhct6aRnxgcdoCWKE3ckGpyXCZ01GdmalOOzc88p59z3ln6AcI5r23gecHYHjDEkuEA37nvKkNBdBlWnRdKmRe/WKTLKdwXibuVX+6pxfgPBtZ4eRi7yM7JqpDEy1NMGUS0k97nATYDe8ZX2o9peHnKY9Tqan7zmzoHU6NNnnm4kdI87HHKfCRoTkk7ZsvtDQlTMLdQ2wBmK1qAAHUxneLO2PD1Ezs08qqs2nSzOjYPVfH0vHnSvYurFYYQxPz77ss2LJZvZA9Bv6xXXXSTvpyEXcei8zK887/ANpdsbdo1dxS6oTs0WZO5yyjBKUAdeKvWKM89fcw2tdhr8IZcOo1i/DGoqkVnJvsDamy4Q+CEK/MN0Hn18oeqlNmKc42H0pU26nO08g3Q4nmD+kch3iTplXVLSbkjNNiaprxuplW7av4kHgfrBytcxCVeS0dmTkmtqoMTiZZS7pWjvrXta2l4lMU1GmMUqZl0zEsHHElIbYsSfhGeT1OUw03NNfjyTps29bj/CocFQwhFhcJHwhHoxlLfYbyNR2hsjVObyjtQNiN7xzI1ULbXvHe0m46Q6QtFs7PMLzOL8TylKlsyW1nPMOj90yPeUfoOpEezpFmUp0hLSko0GZGWQllltI0CRp/znGV9guG/uLBAqTqCJ+skO6jVDA9weuqvURqTSUqQXppWRlsaA6X6xlZp75f0LuOO1EkzMhSFKSlKUDdSzoBzjmTXG1OFLKHXkjdY8KfQbxUa/iSUSgqnJlqTp6dg4rLn9NzEdJYpn6inu8LUGZm0HQTEx+Az566mJjhbVnNqzTmpvvLEoKPMw6HCToCfSMrnZ2sS3ixBjWkURPFmUQlSx0urX5RH/e+HHD48a4sm1cVy6F5fki0WI6W/wD4xTmkbIVqG/zhLigpJzeUZGxVqOlQEn2iVqTc/KmoMkp/6kiLFI1DEzbXfykxR8UyQF1Kk1hl+3lcpJgnpWvtr/vghZEzKPtP4OZQ0zimSQEulaZedAFs9/ccPXTKeekea5i5UeYj2xjl+SxpgCvyMql1E6JdWaVfRkeacT4khST1GhGhjxNMG6s1uGoh2FNfK/AvJy7QyrnCYUdRCeEWAEGYKDEEdo46xVrwV+kBJ09YV62jiCaVPzHsiZfvne5GoaznJ8No5lPFXGEkFS0oSCVqNkpAuSeQEOzMjNSqErmpWYZQvVCnGyAfWELah6xTlFyStIYKobdVvfbpBqsdiCOYhkkk63hiEyVBlYPDWGzqYO46Qk76wQIR2EH1gHYwE66GJJJOiVZdMW4240mZkHxlmJVfurHMHgocDHbUKKgSyqnQnVTlL/Ok/tZb+VxP/cNIgI7aTUZqmTaZmQeLTydLjZQ5EbEdIVKDT3R7CUvDEoAK0kcfnF37M8MKxbjCn0ogiWWrvZlY/KyjVfx0HrEeiWkMSKC6elqnVndUoTZmYPNsn3VfymNu+ztSPuuiVqqzzKmZmYfEknOkhSG2wFLsOqiPhCMuX5a6Y3HDm/BtkuyjJnyIZlGUhKASEoSgaC54AARQca16eqhMvR5lmm0hs3mKrNC3eW4NIP5RzO/CI7EuLa9XqzOUmlU1iUkZDKFOTblkC4uFED3zax5CKpN1Ci098TNUml4kqiDZCDZMs0r+VI8P1MLw4HdtDJTLHh2Rk3HRMUGlTFfndzVqqvKyDzTm4f6R6w5WqrTm3Ft4txjMTWU2+7KC2UN+RWNT8YpFbxHXK2nu5h4tMH3ZZvwNJHUDVXrDFPoTiwlbYsbD3lhI+JIAi8sFfNkdffv/AOCd98RRaWMW0Ona4ewYwi2z9QWMx621Pzh9XadiG4DCadLp4Jbl1KHzMR0lgucfRmXPyDKOk039bmJBnASr2FSk1qPHvwr6GGKWmj3z+rBaysfb7Tq0tJTPyVMnWuKXGCn9TDktWsIzz6XZmmTeHp4nwzlPcypB5nLw8xC09ndRcRaXmZVy+3iI+cRNdwTX6NKqmJySvLDUutLCwnqbbQ6P+Xn9Lp/oLfqx75Lg7NTDc/KO1SZZnSlBclKuyAPaWBqtp0DTMB4h5R40qDqXpp9xvRC3FqSOhUSPlG3VnES6NgivSxUbPICZZJ/I6s5FW5eEk+kYSvQW4WivLHsm0FutIJOuljCRtrfWDB8XWARY24xxwSd9doVa/WEwoapvHEMJO/nC7np6wg6WMLB62jjmabghdMYk+8RMyrr6lAuMTLLfeNOWtdCjqR0+hvFvS6slSkuqFxrrcfOGpJimFx2XmqbIySgQGkhlO3nbeETNLmGlqWy4FJANkr1SfI7iPP5JKcmz6z8PxvT4IwjTr2v9/v2ILGlEbmpJtyTpqHZ1ZsHEKDQAI94nQK5AHnGXTjDsrMOMTDZbdbVZaFDUGNIrleqlDQ04lhtyUmBa+cqQVcUqBHL46xms2938y873bbWdRVkaGVCb8AOAjS0antp9Hjf8SPTyy7oJqflVS/Prm/exsnnBXvAvBH1i8eYBBp0IN+m0A8bbwXAgRxw5bSDbtnN+MEnxJBvrC0DxDrobRxx2MWF1EaJ8XWPYGDpB+mYMokpOrWuYRLJdeKlXJWoZiCelwPSPKuFZRE/iGlyagVIfm2W1DmCsA/KPZdTtnXl0Fz8Io6j5nRZw8KzAe1+ZfRjNxLSnPZvZ2kuthRyFVib22JsREDK+EoWtKrnYAeMjklPAdYsnaPMBWM6uylRzJblzYcDksf0g8Ly6O7czpSXDlJXbUi0Fk1vpQpLkdh0iyStvgOgUxc+smZUtho/ukHxf7lfoIsMzRWJeXSmTkpRRG/fN30894bQn2Z0FF8mxymJRmbStNs1lbaRi5tRkyy3SZs4cMMa2pUZ3iSjTKlqcWxIrUDbui0e7SOluPUxEN0KykqYYZ7zQHuz4bnlxjVH5GZmHCGZgNM291TYVbyvrDLFIlWlEN3LiVWW5YEk8ukNjqGo0TPCrsr0xSRI0lc2XlIDaLghZT/wxA0TH2K5CooNKrKi1eypN1ffNLTxSpKiflaNNqkgmapS2bWBtbz4RU5LDErPuqRMOWeCgTZsJUCDp52gsOZRTbFZMLycFB7YKmzNzkmiTaMsh3NMOyt79yvQZb8r3t0MZ0esTuOptM7iqpLQfw23lNo1vok2v6kExAGNzG24pv2PPZElN10FxhatReG+IMOCDAYgwaDrvA8/nBcY4kURoeEGkAiALG/WEpUQLaxwJs2Kau6qZqE6mXb+6W33GfalL3WkC4SOZUdPWKM5jarFd23UNptbLbNf1MaxVMIyk5gmeZS2JZJbU/KlR9wg5s6ieKra9LR58JuBGXo/Sz7qXTNrJ8R1uOMVvaVcVx1+RZp7Fbs5QH6fNNpW46pJDgsAmxvcfS0VgkX3hN4BjQhjjDiJR1Oqy6pqWV20q/sGDpB36wj0geesMKtC7jygA67wgR0S0o9M/skeHitRskescdQlsgKINoeYZW6qzKCsje3D1jvZp8uwEqdvMOchoi/1MPGZAbUltASgflToPlEfkFt9ywdnbKZfG1AcmFpSEzzRyg3J148o9YuqS4LkjxHXoOMeK5ebdYdbdZOVxlQWg22Uk3Eeoq1XsuCHao3oqYlkqaA4rdSAAPUn4RVyQbml7jYSW38jIXH3aziPElUsVNOO5+iQVFKfkkRP0hYYdbBNgpFrdRE/g/DaJPD70rNN5HpsZnjxAIskeh+ZiBnJV2VUth1JS+yqx8xxirrordx0X9DK1T7Jx4lTOdI21AvuYKQBAS6F2FrFN9yNzDdLcDzba1HwpN1J4XEOTSkutOJlVhB0KllQBF97Rl1zRqxfFs6puaedYW3JqU2kDxOJ3BtsOsO0iak/YkNy76A8ACq51KuNxEdLzaGmQhKZkEaFHcEgiIuoIkZtaVKdRLzKFZgpxBQbjlcQajfALk27LvPvJbkHngoXSkEAHjcCKljvFbWG6epbSkGdmEEMItrf+I9BHHVZ9MhTlzU06t2XZAdWpChZRv4UjqTGMYkq8xXKq9OzWil+FCAbhtA2SP+bxZ0um9SVvpFXVav04VHtkS+oqUpSlZiTck8TxMMGFKhBGojdXBgA047wsHa+nSGjvCgY46rFmEmDI0EJMSchSDrCykK10ENCHEnTe0cQ0bZ2gSdVqUomnqnnGJCWJStpsb67qB1I2trbpGS1Gluy884042ZaXbAUXVKzjLte/Ek8BxjXam/OP1OYmnpwLU+lNm8oLYtp4SOFrC2u0ZfiedmKjNMSHsTzcxLqUO7BzFd7WISOnUxk6Nyj8seg8mSU5u3ZAvqQpZ7pBQ2NEgm5PUnnDVxaJhmlJaf7qbKnpoAqMpLqF0AcXHPdQBx3PO0RcyEB9YbKSjmgEJ9L626mNGMk+ECNmBfaC4GwiRprCQkzLoBA9wHiecMslcj0nINto72d1J2a2+P8ASOh6c91IHhAsANh0AjkemA4rxW3uq5OsMZxrbQX2JiVG+wnJLo6HJhWpHh6nWEtu6WvYEeUc5UlRO176QbZOawBiaAbH2D4rHnG+YDQ7iTCdCl3vFK05twrOvidCilsf7U6+ojAmRZ60eoOwaXDnZwldtUzrqfTMD+sLnSaYUPKLQzLqugm1y2FC+xvuIicX0AzzaZySTeZQMqkbFxI4f6h84uDst/lWFAfsyUHyJt/SEOIK2lE5cwFiefnFTLFZFyWcc3jdoxulPKYceCkKP5Sk6EHlrtEg2tpaEISiyxfUKItpt1i4VanMzAcW+yUrAt3zYAWP6+sVaSoc5cpM6Xbn33Ui4HXKBGbLTyvg04auNcgaaminQBYGwB/4DDTiZvvT36XFBR0BSIjqXXE1CeVJSKi7MIc7rJlIub2FjtYxD47r1Qakp6Spks6p1gWnZpoZky6CbGxGm+l+EdDSZXKttEy1WKMbUinY+ryKnNfd8jlRISzhN0fvXNio+WoHqYo7x1N946HE5FC0IcAWkbchG3ixrHHajFyzeSW5nCbcYbVDihlURbbeGydIYKQR30hQOkJG28AGIRw4COI0gjaAk66wdoI4R62tCgqw1+kFbeEkkHS0ccbS6whhPctOuOki5cIFio626HjYxVa0Jppbyw4iTklJHfTaRd1f8nMcotgnGZxtwTbbzEqlwlK0LKVLKRpmJvm14Db4RA1Ss09plbVTBW074C0PGopvvw23jExbovhWMzxju3R8/f2ylrdenmVydJllNSKPEsXAzW/M6s6ehNhES4nIsoC0rt+ZJuPjxizyLzFQKnqopKaJLOpR7HLOhkqKrhKz4T4QbXURfWw1iLrlLVIr7xhqZMp3i2e8cR4C4k6pQoHxjKUm+m/qdOEkntASdWRiElawlOpJsI75t26UtoyhKfDYRxy1wrMNybCFOizilCwPUxYSOukDS++g4wPL4wkKueWutoVsd7waAEi4ubjhxhxBsoWPWGl8xDjJ8XHWOOO1pNnEHe/GPVn2bUd/2czbdh4Kg5l63Skx5UZ3T0Meq/ssBZwfVCRdCahYdD3aYTkDgzSA0FtOoVxcIt5i8cbTZbcXnsLJsq4v6xNlkCYmMu10q+sKQwkzCSQQFeE28oTGIxyK3OySJplQQtSVJGYcRFKxo45S6A6pJHtT/wCG1bfUakeQjUZ6gJWlSm1ODQjLfQmMm7SptgNsSyUIL7QyoO5GYeL00hmPB6j2oCWVRVsx2mJckHsiH1MLmJxllLoPiQkXK1D4xe8U1mWVXJOksNpThEIMm6JQ5XX0FQzEK0vcjYbmKispRXWFBouolUqWUD8xI2+gjfcUYYbqPZ2ZKWZQ043KocYAT7jiUhSbeoi7q8Xp/LH7oRhybuWeS8UUlFMnnGmHC4wVLLOcWcSgKIAWngq1ukQR4/Ixt/bdKmp0DCWKe6LT03KmSm0kWIdb1F/nGJOpyLI5RUxu0mOZyqHeJ094QwbbiOhRyu3HHWG5hAScw0B5Q1oGxkHqbwL/AAghB77QsIAOosYWDpDYOghSTrBIgXx0gvj6Qq9+sGATtHEJm1SshIzM4HZ1b6kEAJaChkPQ7G22gIiOxTg6kVCcE0iouygKB4ESucqAvYEAghXLQ3GsS9Lpz7TCXJqbs8snOgAKCdtb733+USEzU5NEsEy0w2m7qW3O4aC8oVpqL+7bMbbXA4mMCGSUZfK+jRjgksb9Ti/1Zl0/hd6RknXpWVtNyjpamm5gpcUlWa1mwLpXpqdOOlxrHBRapNEVFifq83LFctZoqmFpV3iU5W02AJIyKUi3hACt9LHUKnU2KW3necRnA7lpGUrkzckFzLkOXYlQVqORjNcVTIqtNkp3vkvqZWqWze2oJy3KhlYP4iRc+8SocL7AaGKbycSX9ypKKj0R1Zl6dLT6U0yaD7KUDNlzFIUAAbKUBmBNzsLbdYjFWJJtfpBI9xR5m0C+msaEVSoU2JN0nUbwaeO/lCT8eUEDY2giBxXunjaCa963zhQuYQ3cL0iSCVl75Uf6rajaPVv2XfBgioGytakrXhbu0x5Ulh+G31Jj1t9m1kNdmq3tPxJ96/OwCR+kKydkro1Fkd47NqI4JH1g1I95NtdweRhymeOXmXP4nLegFoYnXA24CTp5wmKJbOPEFS7uTUsuBBKb3OgTpqTHnjENQ+8am/NhRU0k5WydLgcfUmLz2mVlbk4/SWFeEqCnSDsCL5f1MQU1Rm5fs5TUVgF6pTyWE6e403cm3UqHyjZ0eJY0pvz0Uc891xXghOzqme14rkVOIuXniqyv4Qkn9I9LSkqnuQhab2Qn6RhvZaxnxnTyPyJcWf8A4H+sehG0BLqgRYZEgxX+ISrIkvYZpl8hnXbjhxurdmFTal2kJdkUicZCU21QbqtbmkmPE86gBYOhChpH0cqEsiakXGHBdD6FNKHMKBH6x88q7JqkpyalFgpXLvLZIPDKoiKEWWkQLmqQd7G0EDdBBNxaHFg5VDca/wD7DKCRc66CLKBYwtOVWXrvCeEPOC6QRvtDRHpC5KmEuUFY+cC9zeAOkH01iDgINocBvDY+EGLHheJONaZNRqzyQ9nbks13CPAk/qqJ+VpEpIlS2287tiO9WbnU6gchDMtNZXO7d8DqRqhGZShbmLXhDlfprF2luuBSTYoDRJB8t489PfLiK4NvBHDB78kk5f1ZTe072n7wZqCXXEqWhUsvKs+6b+HyIKh1igg2J6RpeNZmVqVHeTL993ibLTnYWi9upFucZokXNvpGro23BJ+CjrYxWS49MXfwhOmmsFc84CjdV4Tyi8UheY8N4JV9ecAQe/CJ7IEoUdhDmzsMnRUOp98Ry9iGTEoDlbvzJMeyex2X+6Oy2kJcuC9LGYVcfmWoqH1EeOae0X3GWke84Q2OYKjb9Y9xUtgJRJyTekpJtNo88oCYCZ0ei10hotU1pKveKbnzMVDH9XFHlVOHKVg2Qm/vK4D+sXJx1MvJ3VbbTSMCxxV11uvOqbKlsMq7ppKdcx2uPM6QzRYPVnz0Lz5NivyIwbSV4jxKfbllTKErnZtZOpSNT8SQIlcTjuOzDBctYhbpdmLdDcj5LES2GaQrDjGN1PuAzMtSEpcI2QtaFKKR5aDzjh7TLM07B0iBZTFLSogjmED/ALTGn6nqZopdLr9P5Kjjsxtvv+f4EdjcuXMVvuEaNSqrX6kCN1Cfx1gblGl/OMj7FGrTVWmD+VDTYJ5lRMa62bzqwTsLRmfEHedlrTr8NBzA/AB5EH5x4m+0DSmqdjypllGRbswsrHA3AUk+diR6R7cmB/l1/GPJv2qZLLitMyBo4w05fn7yT9BCcHKkhkuGjz2q99dTfaOa9r6x1LBCjY+LeOQ7q84aiRSdRrseMIUN4UCetoJXMbRMlwcuxuxAuYA6DeHONt+cIUlQJMLfASEm+kGPOBfSDBNtxA8E8o9BVfDzlHddmnZVqYZcUFh/KVJSSDa99uPmbRzsLSknuGktZjeyP6xqrhZ9nXLrQFNqBSUHW4O94zKtU9dGqPda+yukllZ4j+E9RGHlxtKzb0bjF7UqZGVltcxKPIWVeJJGp3uIxQIU0txCtCglJ8xpG5P3UknhbSMkxXLCUq8zbZ1QXbgL7xa+HyqTiB8ShcVL2IWAAYIGFA/DrGsjGCsRCgecKgrgcoNIEQ4DbSFtDxJ1IEIUU2sDDjBsoHe2sD5OfReOzinqqmM6PKpsc00lRvponxH/AOseyGZaqIRnl0yicwzWJVxjzX9mqlGfxyJhSbiTlHHf9yiEj6mPVNdqctQ6O/OzirMsI2G6jsEjqTYQEuXRHRTcb4wnpOiLp8zJsNzzyMjbrTlwE7FRB1H9YieyDDpn6iqqzLYMtKLyMJI/aP8A8XkkfMjlFPkxPYzxKtbpyuOXcdUnVLDSeA8hoOZMegqQzL4dwznQhLcvJyynLX2sCo369Yu5f9Nh9GP1S7K0fxZ730jP5x1U1hfG8wkkuVSropzR/iAUhH0Kog+119K8bvS6PclZdphI4AWKv+6J+hsKVRez+nKH41RqK6s8CPyozOXPxTFBxnP+3YurL7RK+8m1obCdSrKcgt8IsaZfit+Ff7L9heZ/Il9+/wC5p3YlK3odSmlD9pNpQk88oH6mNHY0mlq11I+cU+jKlcDYGpbNSKi+tWZTbYBU46q6iBrbTn0jjmsfupzGWpiEKVaxeeJtboB+sYOs1eNZpOTNXTaPLkxrYjQ39WXLcown7QNDFUeAW2CV0aayKI911qzqfkFD1h2tYhnam629UZ4AJBKEoORCfIA79TeOR2ofeTKUzT03NtJbW2M4W4Mq05VW5AgkesU8fxKEJO4ui8/hGSUU9ys8juozWUAdReOFVgTfePUcvg3A74CHaPKt65bFbjah/wBV4yHtowtQ8M1yTTh2ZUtmZaLjjCnM5ZINhqdbHgDyMW9PrY5ntSoVqNBPDDe2mjOM4BO8HmB4WheUFMNEZTrw4xddoocBg3uBtDluV4ZGm0LSva8AnZLTApPKEbaXt6Q+nxC4+MWih4CxDW6eiekZEGWcJyKcWEZgOIB4dYGc4w5k6JhGU3UVZ6L9pdl30MvqKkuHK26BYqV/ArkeRGh6GIrHriE0UtFF1p/EKiCSkjkeGkTRlfaWHvaU5S4MqCFWF7ixHIggH0iuV1ap2kITMWEy6laHUhZuF2IIvtv9RFXJBU0izDI1JMq0i6l9q1wQYzTtCITXu7BJytpvpzi64VcLkvdVyU6GKLj5xK8UTSUahCUIJvfUAX+sVtHGszX9DQ10rworwFyP1gyq0J223gsvO8a5ihkmAE63JMF0FvWFZdQFE3O0ciGBYATpC2tVACAWVW8BBHU2gk+A2I16wVckeD059lVhtqRrtQdKUJzNs51WACUgqVr6iO/tHxa5iiqsylOC1U5hzKwhI1mHDpnt8kjrGWYOxKqTwK1RZFSkGYmHH51drZhcBDd+Vk3J8hzjW+zmmppUgxiOeZD9QmldxR5RWhccUP2hHK1zfgkE7kRcwYo416suX4RUyzcpbF15NDwbhhvD1DVLPhJqL+Vc2pJvY/lbB5JvrzJvHX2nTjiMBTMmyQH59bckgA6qLiwPpeIkYyw/IPJk6hX6eH0H8RS305lr/Mo22udhyEZh2idq9OnpqR+5HnXVyL6nw9kAQXALJtfcJ1N7bmK8all3zYxxahtii9YqxVL4Zx8XEsl8UilpkJNsHKkOrsVKJ5BIA0iq4GYbZUnENUJTJtulTQOpdVqSeuugjMKJWfv/ABQw1UnHFofUpTi8xU44QCcoPNW1+EahUXXZ1hi+RtptJS0y2PA2BpYeltd4TrNfj00NmPlst6PQTzy3T6R0YkxHO4hqLc3M3S01pLyyDcNJ4+ajpc9OUOrmgqXzlSuQtbUxXu7XnUGgSu1swOgHIR30h1LILb+UpVtc9dbR5bI3ke6R6fEljW2KEGossvZm2W0qJuVKACocGKKbIgLnJ0Ic3yp8R6+XrHZMexrbU3MyiFoVshdiT8rxytydGSrMikygJN1Zmws/O8QtvlDLkuh3/GFEmmrGYbcFv3iQq0VntEouFqhgqr1AS8tLz7KAuXm2UhBWvQBBt719rH9IsszSqJPrS/MU6WS62R+M22Gz/wBIFx5xTe1ejyjGBHZmUc7ssTjRUg694CCAAeYvfyEWNMl6sdror6jnFLcr4MEcZKV2KhCPEN/EOUdb2VWh1B2tHOdDY68jHpdp5hsZOlrbQIUsaXhEImtrGLlE7guRlqhiGWan7+xo/EdA/MBw9TaPRctXZfuEBstBAFkhJsABsLcI8vSU49JTAel15Vj4EcjFvlsZS5aHtMs8l3iGlDL6Rn6vBLLJNco09Dnx4otPhnpJ0JcUtISFIy2UMvTgeBHOKrXZhaJlhp90qWSVpXmALgBFweo+Y1izPTDWdTEuC+tI/EKfElI6na8VfEKC622FZvBZYy2BBGx+H1i3OC7KFlRosm3Ie1sjdLy1a6WBNwPnGTYkdL1dn3FCxLytLW2Nv0jUm3F/eFQSohKg5fQWBFuXCMnrtxWJzMbkuqJPmYraRVkky7rH+FE4LmDtc6wQsbQq+kaKRmBg5fOFI97XeGxpqd/OFg2STxMEiBST3ruUHKmHpVICxnTdW2ojnbNiDvrHWFgm4AuePWDXIL4JFp5TRTkUUjbQxZZ/GdfqRZXO1WbcWwyWGyFZMrZ3AygbjQxUAomwPA8o6m7EAC8DJs5M6S+QNNPSEJWVFVwTY/lMICb2ve54wpIAKhrw90wsM7KZMrkp5iZRZCmnEuX3OhvHoEK71VgLpKQUkmwXcXAI8r/8Eedm0gnRFweKo3LDNVE1hmlOgq71DKW3VZbpBTpc8xpr0MZfxGFqMkavw6dXE63ELNmlLDRNykEXvbU29PlHLLLRLLb/AM0oeIqzADKLnrHVMMrLpKciyCRnzJujpbeEutoWLTa1kaAZrJ4chr8zGco+DRc65ZKPvy02woTTaHW7AKukkExDzFGw882EJYS02ATlS8tAHoDDilFlSRT5NxtVj+KDYn04+sVqsV5ch4Kg/U3F5iFhmXCMnmSbH0hscE/AuWpx+WTAwpQVKQ8l+dQsWOcTqwEpvqbk6C3OMYxnWFVCsTjEtPTExSJd4olUqcJSUp07y3M66xMY1r6arLpkaeqbMoDnccmF2W6eAy3Nkj5mKQ5onw6WMamj08ovfPszNZqlJbIdDS773v1hpQ6bwq+ptsdoSdhpGkZgg6i1tYbhazfbeECE5ORsQQIAgQFBHslinqYZSw8oKzAqCk7E8U26cOnrHBUpNCWlosASk65R+sSs/PJW0pphJU8LEZibtngbAH4RWqq7OTLClFxLK7lKktt2socLqN9f6R0mqpA0/JQZ+VLc5Pd0lalKsvwJJJsLfpGQ1zKarMFBulSrgxomIq8/hqroQGu+Q8xbMdDmBPHY78IzmpzK5+cem1ICM6tQNhFbBBxm2+mXs+SM8MYrtHFBjz1gQOO8XLKFAvzhepAv8Yb47QsbWJtBRZApHK8OJNtfhDaTr5wrfaDTBZ1INyL6k6x2sr0FrgbkERwNkWTvzjrRfS2ttI6R0TpLliAQIDaiXt7ZhvaEJF/6mHMllJJTfpwMKYY8g66qJMa32PU2arUo+xLONoblXPGFJubLGnpcGMoaaUSLItfbmY3D7OlMq8tiaZdep76KW9LZXXXUFACgQUZb6qN7jTneFyhGfElaCU5Y+YumaFJYHUpd5p3NbQJSkDSJEYMaS+AjLpubcY0BEulLiNNb2Pwh5UuDMKtvx+AjksceIxFyy5JcyZSF4SSlItYqAKvhHLUsFy86lRW0lWdKgARxABEaMtoBz/arh0htpoJlEKAuULCvTQQe9ewt7muzzfj3sdTNM+1UOzM4W1L7q3hdKRe3QkR5vnGiRmNz57jpH0PnpVNghJCVJdKW1ciQcvztHlH7RWC2KLVJWv0psNSNWUrvmdgxMAXUB0VqfMGDuPaREW7pmHK3O0IUdNrx0TjLrASXQm6trGOTfjrEPIq4HqDTpgJgvSAL8IEL75CBB+cFxMCOJR7LlFoTLLACApAUpCra6ee8R8yVKcDiXEqQ6MqklAHiA8O3w+EKK1yzDq/CAtBQCSbkn+gHziPmHcqMqtb+HWBcfFApmZdslKQmWp803L2LbhS47mNlZgNANtCPPWKBT5Bh6nVFxayEhGnGyhrf9I2quzEnNyLrVVSHJcNnvWUqsVCx1vwsQDcaxi83Npk8PMy7Ns79ySBuOcIuX0ouadRqUpeF/BXBrrAvvwgQLxasqUAbkcIAOsAWgenpEpkULG8LTqIaSQNTc2i803AE/MMMOvOhHfJCkpS2SSCNIPfGPbBab6Kk2kmw42jvZbURqPjGhSHZi6pwBbr2W+pKQI0TDnZNJt5XHmS5/wC6bj4RG/d9KB+ntmJUqjTlScSiSlXH1fyDQeZ2jUsIdj85UO7XUlhCT+7b2Hmr+kbTRcLyMgyhCWk6aAJFhFlp7amSpOVAaBGQJBChzv68o7bX1EPJ/wASo4S7MKNRlhaGkl5O7hGZZ9T+kX+lU5mVRdpGt+OtodSgJUFC2vzjrZUB4YXKXFIhW+zoUmz7Y53MPJA9rWOFh9I5nV3mWCDre14ebUTPO8gAPlCWwxaxdYvwSYS2n/KqT0/SDWdNNSQRCWVDurHiD9IizqOGopSpJWRoUoUfRQvGS/aMpYmezmrkp8cm81NJ6ArsT81xq08T7EbnUNKHwF/0iCxxTGa5JzVOf/Y1GSdllcgT4kn0IixB8ULfZ4BqCs0rlO7ZFjxtEWecTFblHpGbmZSZRkfYWplxPJSTY/MRDxzVclhSclyCDgoB2gbJBAvA48oOJOPVk1NKVNstkHI2krSL7HWOOeXZKlch/eBAiU3yC10UutOqbl59SQmyJVyybC37NX9Yxd9SlLCSolKBZIJ2ECBC2HD6RojrAt84ECOfZAAIMCBAgo9HBoHiAPlHqzs1KJzA+Hn5hGZwygQTffISkfJIgQIsR6sTkLeCygrCWdttf7RLUqojuspaJymw8X9oECIlJ0QopkkmpoGZPcHY695/aHBV0lor9nOYfz/2gQIrSm7GKCoe+/7IB9nNlbjvP7Q6cQghKhKkG4/e/wBoECAbC2oDeJR7YFGUPg0A73/xhZxQG5hxXsZJNh+16f6YECAbCUUK/wAUgq1kzsf3v/jCV4oDaUj2Mm4P73p/pgQI6ztiI6cxUCyUexboV++6W/hjmqeJ0vOSt5KwSbftdxseECBBxkwXCJ5O7fww32jTb0uz3QnJdmZWkHQLKbKPrlv6xmlrwIEOk/lREVQVoAgQIAMMwBAgR1s4/9k="

/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 299 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAZABkAAD//gBYRmlsZSBzb3VyY2U6IGh0dHBzOi8vY29tbW9ucy53aWtpbWVkaWEub3JnL3dpa2kvRmlsZTpFcndpbl9TY2hyJUMzJUI2ZGluZ2VyXygxOTMzKS5qcGf/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAE3ANwDAREAAhEBAxEB/8QAHAAAAgMBAQEBAAAAAAAAAAAABQYDBAcCAQAI/8QAPhAAAQMDAwIFAQYFBAIBBAMAAQIDEQAEIQUSMQZBEyJRYXGBBxQykaGxI0LB0fAVUuHxJDOCCBZiciWS0v/EABQBAQAAAAAAAAAAAAAAAAAAAAD/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwBQUkmSMehFBXWnJA3GcfNB8kgqPmx6UF22yuBzH0oCLIUoiEJLWZPJ/L0oJHWymZBChx3oB9wnEGefyoAt0iM9pJxiaAU8kgkkGJx8UFfmEiAR780FhkKCQrOPb9f+KAlbkj0J4jigvtDjtGMmgsJEoAgycmT+1B6ROAYPxQeE8wo+aRIPJ9KDxMGDGFDBB5/6oK7iQUK3AQU9+f8AOaCuttU9yJ7D+lBA83Inie4yKCqtsATPft3oIFIgSJwO/NByBAwRHtQdJOZPl9e80EqfKmBz6ig7TEEACOPUigkRAVOcDkfvQShJIHPFAaSggmeT29RQRLQMkHHEH1oIwnjMpnuBQWbYHcCIHpQFbcJCT8igsuMgg7YjgQO9BRuG+d44oBF6wcjETzxQBrtoIBUo7YmVHigDK1Cz8QDx0GPSgtNXto20f46YiYSc/T2oIWteZSva2grQB/NxPzQTtdVNoeQHbdwA/wAwzigle6ttmsNNqVj4ig4PVrDqTDbgURjgj86Cza9R2pR5gsEZyM/SgmZ6js3Xg2jcD3UKAq0628Bs2wR6596Dl0EgQAdxxtoKrqJTKIPxg0FdaNoI4Bz6j60EC05/saCFYPeM9qDxMgA5Bnj2oJ0znH9qCQAkf15oOk95Ge0UEgBIyiT68UDFtg8Z4xQV3QMEyT3/ALUHATuUThRiSMZoLLIIGTOMf2oCdoE/zAcjExIoCCU7kBKoyIJB5PvQUrpIQN68JgyowP8AO1Ak9SdS2unrU03/ABXOClOQDFBn2p62/qiyl1bgQP5BhNBSWwlITsBUY5J4xQXWGfEbVuCt6YIUk596CB9pewEqKgexoIWXVBZSopKSJBJj8qD3UCUoaW2AFo5jvQcsvtv+JKdsJk/8UE7dyGTtc3BBwYPFB0oncC3JTySP3oJmdRvmChxl1aIxBNAc0vqp8OAX5SponKwnIPrQNjbzb6EuMkOBQ3YEiOeKDxxsAKj5oK6m4jcO3PFBCpBgEHjvQRKQCoZz37UEqExgpnOBNBICACTz2ig6CTHsOKD2duN0fpQMxE5H096Cq8mVACCD3n9qDkJmIMHjFBZbBgEQpMcxQErYgJSFjnB7Qe2aAX1P1ba6Sz4bSfGfP8oMAY4NBluqdT6vqb6z94WlB/lQYA9hQRWemXF60txhEkDPrQTM6X93Cg63K4GT2oCJ0VlFqpeVJA3KxlAPeKD2z0xSrQNFKQpUFJ7kE/5igp2+kO3KlkwGGSpM+4zA/KgpP6YWrdb6W5QlzwyT6+lBE/pq39QFu0CraN5KRx6/1oAzjHgXRIO5UyJwJP8AxQXG2CoIJQrP4oHagrOhaNpTJSFbYSM/FBItY8AkebgiT+lBwHNu1JhRySk9x6fSgvaPrj2mXAEqUxMFAyI9RQP2lapbXydzbon0PNBdcSqVTnvAoIFJPpjkUEUCZg47jNB9PkBIj5oPRkDMjiglQnHGaDsNjMic4kTQMoGBGD8UEC0Sf91Bxs4BHH6UFhraCJIoBPU+uDTLFW0jecAAyT8Cgx2+v7jUbtTzm5KCYgKJIoGHQmUkBDpauExIWQQoD8oP1oLzmufdkuMoQlJSZSQOfn3oB7GsOXSEocWVLkkFBGe9BcuNSNq94bLyVt3LYaUk4JEgj60A9zVXUvi4a8nggDBnaoExQHbXVVW6+n7U7j/7HniFcqWOJoKmm3ZdsrxN0TtJKoIyFJVHPYzFBfv0/cL5DjCkeI822yExIlZg/oc0AZ/TlKuA62g7XX1BKowQDyPbEUETzO1heyVurVAUAYSPQepoKC7Pw0nxEq3nmMAfNBRcBLKisQkQoRkn2oI1pULdtRT51bpgSY/yaCuoFR/CFEH8cUE9k8402fCVt9FpPBoHPpvqM3EW14CHZASrsaBnWkTODPqaCJSCDxn8hQcgKBPoKD1OTJE0EgPGe/aglAB5UfyFA0bZBEHAkxxQVlkzIIPYCKCLiNh57UHlw6i3tXH3PKhCTzQZL1hr51S68OyCoSPOuOT6CgHaTaXodS4bMrakBSuaB71HUbfT7JDSbFrYtIkjmaBE1m4RdrUtlICgZxzQC7fxE3aChO1W7gcUBe1Su5dQnaVDKhtGZoClpody+XQyhxQd2nacxQX7nSL0qZ3tKStuUj2yP1oPXtHvEvqRkD/2kA+pmfftQXdYaduNSDobcLVvsCAU5kI598zQcvhy20dDSyptS2isrwDCuP0GKCzb2Knn7RpTYCkoSlLREJQCMJPrPJoOdf0kNKWlpollMlS0iAqIBj2kwKAOzpDYs2nHVwtZW4lIz5RiY9OfyoBLliq6e2skEhPmPoB2HxQVLhlLCQkeacCDkjuYoIHPLk4PYRJNB60rwVtqQlZM9jxQaRol59+05tZIKx5figvEbskEjuaDhSfXMd6DmEghU8+1BIiYiINBKFY8xAPeRQMzoOwcGBxxFBXWRgyP70EDkiASPTFAi/aLrSm9tihQA5XQZtvK3gEgkTMAdqBz015DVhLqrtrHPafg80AnUNZfU4EJuGrlpBIT4rcFI9J/vQCFXL7ilGRHMJAA/SgaejulbrXLgAIcQ3iVqE7RQbRo3QFnb2LaWwlDyQVFakyV0DtonSVo2UDwEEFBnGUntP6mRigKX3SVteJcXcIPjJRIUE5BAjNACX0OUHwwuVLATtRncmZMk98cUHFz0Jbt6WlZa8S4UncpGUneSYTH1H5UAW/6L8Bdqq0YS8+laQpLicbgO84IxQL+s6Le2dw+Ltt9alA71qP4yrzKMjiZ/tQAdeauXW2wwnYhKdoSBG4gRJHaOAB7nvQI17bXocWpalpxBUJ4iAPiKCuEuttllKVTET6jsPigpXHiSVqACjGd049PagqIXIVCSD69/rQclagskAp24kigO9M6kqzuChSwG3MEGgfUKCkBSSlQVkCg9WZVuSZxPNB4EwMxnM+tBIlO4Qce6u3xQStJOwQSn2IJoGNaQEyrBiBnJoK6wZxBzGTQVHjDmQMd+1Bi3Wr5e118FUgUFjpa2aFyHnXkiIJEZoDGv3SLtOwuJ2x5QmZoF8aWCyp1xKlJ4B3UBnorpb/XNabtmAvwwrzriAfjvQfofpzSLbTbVDFogqTv2CD+KOSfbtQOun24KP4u9KcfwyiBxwPegMstEoOwQmNwJz2yPSglQw+62XVJcKEwZE9/T0/agIWqEIbKFT5RO+JKif3/AOKCK6iUlW0ngg5x3I/zvQVLtLbjY3lS4AMnCgPTFAIvrAXFu+hbbaYlW0Cc+/17/NApv9KWzzrwWg7jwRAg9yP296Add9CNw6prLawko35jtPxQJ2u9DBhHm2JUCTHASaBJ1bpssQEt5iZj96BO1jT3bOVpCggH049jQBW3nC5tVk9ge9BYt3yCJJSff1oHLRtXdaaS2tJUmPXPxQNNs+3cthSRB42+h9aCePwyD7ZoPW0bcQnI5nmgsFsTHcexNAxOIUWDIOScenvQVHRtjg/HFAPuBtjaDJmPegxzqq3QNadCysLJ/CkZoLWjWyGG9y0OIHO4/vQdpbZeukhaiUTgHypHzQG722cvG2bazQpTIMIbSOT/ALlH9hQaz9nGjNaRoC3/ADB1XlUtI2lRjiaDRNCtg4EulGxRIABMx6fFAyW9v94hKRCjlSiSeDzxQMOnaKFMy6QpRGZE/wCfSgJCw2oAAQDEGPSeKCveWJVtKVJbCB+HjHvQBr1sJUpCDvAJSREnie31oAt1dSh1KgQ5uEAHKgYwR/nFBJpzo8ElQUSo7t4iTnk0HyihG5a0fzSlIEAj0n070FUvqFuoeGFSAdxEgDJx7iRQANWZS40kKWC4oztChJH9ooM+1e3bLijubjdx6egigR9bsWXFqG3HeeaDONS01VndKSMt7on2mgrrCAoIWIPpHNARsLgobSiQYOJzigcdNfBtkrxgTjmgYGVBxCVCfwyTQSbREERPI9qCcQQP/wDUUDIEnwhEmMTyfyoKdyBnHlxn196CmoTuEQrIAoMc65t3GdVU5BAKt248n60C+Lh9zHiObJA2hWKBr6YtmnHELuv4iuAk/pQaL07prdzqjrT10q1ZQmFKQ3uOOAn/APInE0GtvWjSbBltlI8NKQiCiNx5JHr6fnQH9Fb220JAIBUFSZ7c/lQNOlISy2gAn8OSJzPoP60DRZLUpEq2hIwAOABQWFrSlMnImDHb5oKN8ttdurZsWE5gCT8UCbqSxKiQqAP5lAkpPf2jFABS8pICtoCXB/8A17Tj9/egmsHgAsBle4AICyRt5IJNBZudii4tESNsqKu4EftQV30KFgVJIKYhKQd0A4z8UC1qFytKnUvJ2gHCEiQBEH4McQaBO1RYc3pAAKon1UO2KBQ1NKkrgCCfQzAoF7U7VDoIg7gmc0CffsgK/DntFBUbOxcmOcAmPpQM3T7iFHaqSjkbTxQO+mqJZ2DKZx6UFxSc4iDPtQS7SsTP50DMGwWogkA8AYoKNwkgFIHMgkH3oKZSZMSDPNAA6i0yyubRx28gJQmZI4oMfu3GE3KvASduQmMRQF+nnyy+0VLgtjeonuRxQbP0Fc7kG5cTvWkFbizk7j2/zNBpdi8p/TEeOlKULMpRuG6Y5Hx6UDFpDpWhKj5UnclSJ5gce9ActHlW5DbzhQSj8eOIxHb2n2oLrL7nikl0SoCROPyHtQW1XimG4QhQVBCSQAD7iTQUdQuFqnxFQlsDIXk/Md+OPWgB3lskhJ8NSSfxGSpSB2EH2/egCLZO0hazt3EJbUAcD37Se1B7aKAtElLhICPEAWmdySQJTBzHpQd3QWhZHiMvoUhO0AKREDIgjHvQDH7sCW3UGFJIlOUmO/8A3QCX723UFpSEyqQncN0QcfX+tAl3l2VPnGFc7s596ALqW+dvmSQJ4jHzQA3gS5wR2oE/WUpDioVA7+1AHWveQCuf93egOdPJQu4QjeYKsx6UGpWzKW2oQIRH/dB6tAM+5jBoOgDH4j+c0DUwiWAoiSYUM4nsZ/OgqXKMmcpEiO30oKKwEkiPn+lAudeWz9xoDqbUxP4z3IFBkDLKEtK8QDy4+tBLpKlKuQTELUBHaJ5oNk6TuEpacbZWpe+eMCBgmg1fp1barUKcQ0zlLfhpTJT2j+tA0Wa1tPp8ilpwnarEHtnt8UBSSpKwo+KSkJICYAA+f2mgn0x1e9KkhLYV6GAocYxQTLccUk+IFrcOFrAKh7AGMUEYtnXmEqbauF7TBCUQFk/PbIoK95aXLYQ0u3dlROVDdiTBVn9vSgpOW6w1uUxcJdKcwySnnkmczigHm3Qz4oK3Wv5VKKSlQjPwcTxHIoKt24i4bWlL6N8BIRJlJ959Y4oBd8Qi38QPFsKkbQrj2j59aBW1IhtsqUEF4okTzM96BacRtMpUo4H4jM0Aq8dW4o8nJwTg45NAGuyUOiCPie9AqaxCnlApmO1ADcCUHdtABVyMRQPnQ+nNvI8d3Ck8GgetoAKYGPQRQcKOVRzzNB6kY8oFAzWhUYBQD7RyOePWg5uZElJkjkxQC31yskYI7zIoK90gLsn0kTKTAigxVSIvrhl8K2lRISnvmgr25UzckgJSlswkDigfuktRcbSgJjepPhgAx3mT60Gp9OXSgUIShzwnVbVqjJxn4mg0ixVvbbWiQvYmT4gUSQe/fkiKBisy44FbfDISTBBmc5/I8fWg8atVIeBBDpBMBWAc/pHpmgYrEKnA2qgqndj6e1BbSyPDBCt+dx25mgr3NkDuec2KUDgRPl/qaBfu20rKm0gpCMbSuT8K7UFZpoOuNhXCuQpU7THYT+tBS1OzU7uS54a9p2gHgDiBPt9fegVrywADRSomBCz4hJcBweQfagXdV07wClvaSpQlQUM4PtjiM0CzqVu4gAKQACDwcgfXmKAHtKnSpYiJnOD70C/fqBWoiAfU5zQKWrE71ER8UFbTLX71etsCBuEj3oNT0SzRaWaEAkKEz80BIE8GPQx60HBMTAGDyOPmg5XyNyhMfzcmgb7VKQ4rcS2mQJOfk/56UEd6iAZMYmQSR3oBjyUrUBtAHr/n7UESl+GytShuhPrQYnqCXLzXX1NkIUpZiTAT/agies3m1HY424kcqQoHFAe6YcKFlTZB2rEf0/Wg37pWz/8A41h9QBcUretfHmPc9vb60DrYbLgDwm0wW43D+VU8HvGaBm0u0AbSPCCkJT5kj+X1HJ9qAgxblAGChJBUd8hQERnPvQF7ZsoUBiCARI4/z0oLYKSDEGOYoKeoXLTVs646pJQkHCRJOKBOW4l9TiVq2gpk99x57dv7UA+0ui5dt+OoJYiU7hkAQIj9fyoLOrulaFQ6kJV5iYAg/TuaADfJP3dCkBe6IKEAz8exigV9ZeSh4pjyQBAkxjP58fWgVLuXVEKSoEcSQYHb6UFV+3LbSiG4jBPc0CVqI2rUBGSRxQJ2s/w3sycfnQXuirfxr7xDMIMHMmg05JG0ZweBGKD4FW+QeDEcUHi4kenzFB7Cf5on3FA7MKUXSVkbiApJ7/l2oI7tkJhLYVtHOBiTQC1tAKwlMSTHGB60FHVV+DYvLQJKUk+vagxhlLFxqDir18sMlRJ2pK1H4A70HN60lu8bLaVJ3CIWmMepoGXpW1Kn7cmNqwYITGJ5oP0b0tYH/SLfx0AbkEg/iHOOfg5FA02ts5421CQV4UIAISeSB29aB00y2DTIWsZVkEAT7gUEzlzbIwooKuVAiIHwaD5WoNbT/KuAQNpJz64igoudRWv4Q62MkAbske0UAq+1q2uGXA0tG1pOdsEpPbvj60C2zcBd6koQfCUCdqVQESYETyc0Ay6fQu8SGwoRuBM5j1+mKC5e3SD4JdAJMHcvORg4+nzxQVLh9LrT6kr3oRJCmzG33Mc0Cvqa21vPAALggOKjce3PpQL154m9ZDa0AqJHH7/XNBSdQtLSkySO8n8QoErWBDxKjJkxNAm9RAJdbJGCJM0E3SdyWrhQSfxQOOaDULBKlMoUVEz9BFBOckT3PzFB8pMfrmg+8Mn/AL5oHdKEiFJWnYryzJg+tB1dAEDaDxgTEe1ALWgNklIJ3ZgD9P2oB96A8hbaoIKYIJ/pQYxrlubbU30KBCicBIwBPNAPXdKgpe864gL4I9qB++zJ1Nz1JY25Vv3JCNomSAZig/TmlsOKZKF7UutElQ24j0OaAgy+ixlZTtjncYSExJ+aCw91Ow1bp8O5b25UAZScAkn8hNAkdRdTX6L28trAXl3qiGQ7cNB7wGNPSQNhungCUqVMhpHmIGSkGgxfqWyvNQdU/qnVWtaldkecG5LbaSMEISCQE9qBaZ0/UrUKNjq+p2pI4LxcR+R/pmgv6V1frmj3zdtrCAvxcNOAS2+B6T3HpQa70Fr3+tXjS1kK8BJWUBJgR+2cxQFL26W5cIQHYcUFErKDLeQewyKBI6o6lctGkkKS2Ubso9yKBfa6q1XUbK9v7dxi0022Ulty8fBhTihKWGkjLjygDCRwJJIGaBXv7PXNUdU9qt3dtqcyhtKgkweASMflj3oPbPRb5htBY1TUWGwJTsuT5RP+04NBYe1jW9FCFak6nUtOUkAvoTtWj/8AYdxxQcajftXoSWCCCQZPJ9IoE7qQf+QynEcE0FvpW2K7nxYBKV8Gg1VpIDCNgABECMYoOkjakyRnv6mg8MwP6d6DmPcD4FA92QlpY8IbEjaOP3oPrwAGAMQPcmaARdrIVJAlOJPb0g0FbTLJzVL5Fs0nzKOVTHzPoKAR1v0ay224pu5SH0mNyZP0nvQZ5cdF3jaQ44824tw4SDk0EPT9yOluqWL90Oi2t1fxko8xIOPL60H6i6M6r6f6maaVo/UWnXF0pIDlo4vwXiIEwlcEx7TQM3UJ/wBOacW60pbaYQGNuVGP5fn070GW9R3N5Y2rF22+zZOXT33OxTcLkhzJW6oZ/htJBWoQZIQnvFACttTNulXSPT+nL1NdupTt5cXyyPEdkuF5QQqXSRmVR6RQId71I84+w1bO2DRu2yS3Z2IaUhU8KUqSZ5x60Fffet27L/3p0pdBJadAIUQYIBHA96C09p41e2cslbmw8kLaKp/huD8Kx9cGO1A1/YR1bpa/vmmXmnXb+vraUlltJbSwsjBkkghWfwgGc0FX7QuttS6b1+70ZVjpnjMpSFG2uFOBMjAJGNw4jtQZ/qnUqNeWw3crVprSnEpfeeRuS2Jyry+ZUDMASYigaWtZ01LqXtPt1uaTpjRtNHYulQoqX/7LlwceI4qVH0GxPAoBurahdurvri41IW14yZdaUlKUlJ27AjklRkyDjAzQfaY5qd5auvIU1cG3KSvG1RSrgz/xQGGHbe4Z3Ntn8B8RtcFJA/f3oFe8tm9J1ZyybXNu42l+2KhkIVyj6EEUCzrj4evEhtMhA57UBXo98C8S3uhCskkT/wB0Go26t7YIHlAwYoJOcZ/tQRxPMRxz7UHxOTgH/wCUUD5YT4CfKlMDISMT8/lQcXPhkDuoYJ3RP+f0oAl8sqUEqIJ5IFBQ1S/d0zpe/ubZWy5X/DQpIyCTGKABpTeti2SblxxxlZklZnPegr9QXR0+zWpCJxgnFAX+yPRmNaS8/fMofWZCW1CU5GTHtQS9f/YdaeIbrSnFWQcPBTvQk+6eQPccTxQJtzafaLpnT7unWNrqtw0LjxBqFndvvjwtsBoAKhKQRuykK47UBj7I1K6m+160tNX1G+ubKy09xu1RfKSlSNiUktxwkEz7kc5NB+kH2LTSr9d+/pKH7hR3JvNPYSHzMBQUIgggAQcYoM76r6U0l3VXrqw/1SxQ6lagwNPbUlsKxDa58ucd47UChrWjaZ93S0y3d+GhKEpSva0I7nuScTNAzdEaPYPJR4aA4tpwlRW5uKAYxHuZjtzQZh9mnRuq9TfbH1DYdO3SdPtbe4uk3N4phLhZty4pO1KVAjergHkQTOKDe9T+wX7OtM0dLf8ApFy7cBJm7XfOB1R/3GDtB+EgUH5d+0zpZHS+pFuyecudMfV/DU8QXEH/AGqI5xMHHBoCunaW1dWjQcuFMhpSVQACFDvNAfvenmLkuvl4KdUfDUrwt6CMQSJ5j0NAX0bTdMsLO6tXLlcOwFuIRtL0A7UgHKBBjvQD9Xsm0PB20b8NkNqSEpEAJiBQLf2g2TCdJ6d1C+W6hpNwq2d+7gF3wiUrJTOCqCqAYFAk3SSLq4DSLn7opS0sLuGwhxSJ8pWBgKiOO9AR6SY8XVGkKP0oNdQ0ltEJGAKD5XfBj9aCNWQT+RoOAD22/VNA82SB4Z2/iJyDI4Pag5uSoeUD8YnieaADfpIJUZzJ29uc0HDdl/qtsiywdrm6PQY/5oNT0zRLZxbdlcNIFohoQVJmDHPsOM0GN/aTpSr7XhoelFLji8Ntpkn60BX7Gm39IfcsNQbU0+lwhST7DtQbyLdi+YR4iQvaiVT2n1Pc/FApav089bXqrqy3bSrcSkYTOCkx7d5oEz7T2v8A7a6h6Y+0W3ZSp7TXvuetNtjzrtnJQlxUcwFFE8yUUGn3/UKGLEvs3CFWjjKHGHUEFC0kAhSVgweaBY1nq2zt7dblo4X3VSCn+Qnic+3pQZk6zf6/qqwpAC1qHkTP4RgT6wPWg0NFjadHdJ3+pXzqWrTTWfHuXCYU86P/AFtiOCV7QB9KC5/9NHS69E+z5es6kiNV198375VhQbJPhj91f/Kg1TqC2Tc6eVKE7eQRO4HEfrQfj/7UNOQ9qOpaeBClSpsk5ChwfbP70C90E4Ly2QtCUm4bG1YKZKFDH0oHC3eXZn+LbB2QfMDz7mggcvWF3CU+EUqMFBgJgzyTQeN3F1qOoIt2WyvxFBKikhQSmc5FBR63ZC+p02sJUzo7It4KYAuF+Zf/AMkgpE+p9qBO6gQVvsTJIBn1NB10Wwo67lJPbFBqKgkRkEzGP6UEas8AenPNBwpIggnsTmggUMzxQO2mHaVT/uMkGSo8knOKDt+BAMZVyeQTQAr9U78gCY9SfTNB70u6U67bokAOEpPPpQaw+8WLHUHj5i032/cUCj9nGhKvuvG9YuUnaw0pSNw5UaAn11Yos9bs9TZSWleIpLpnKiMgzQNmj3YW02+RG6N8KkGf7nvQFvES4iVLT4ZydpzgcH9f1oAutm3etXv4TL1vctlp23dSYcbOFoUO4I9PY0GMs6fr3RDdy1olg91B0oFrU1YL2O3lgnklAk70c4ifgySFF3rLprUlueN1A1pzwklm9tXmltqJ4gAjAk880DZ0r1v0No7JVobusdS3YAS5/pmmOq25PKnQlIGc0FC+utQ+1brHS9Dv2E2HTlk797d09h0PYSMF5wYWtRkQPKkE5UcgP0m0wGmyEISg/wC1JwB6UHV4ndpz6Y3y2qAe+OKD8f8AX7Ln/wByXDq0kAKKVEmcGgztpF/pOq/f9EIRcjDrRPld+fmgaW+ubW4KRqyDpt0rbuQ+g7TA5CgP3oJLnqLp0ghzVLUiJ/hIUpRJ7AAGaA9o/Uj+m2DiumdGXpy3AEq1jUkjxjk5Yt+B7KUY75IFAtvJRb26UoJVEjzKlSiTkknkkySe5NAtayQh9tR4nFAd6Gs9106+R9aB1WJJA9aDhQ2nt/agjUBBkZ4+tBEUJJ8yTPtFA7achaAVEEpUjdhO3EA/Wg9uoCDiAY25wQO4/OKAFqKlKAKsE8jn1oB9o74GoWzsgbHEndxHvQbQ2yb7Tnmk4U6ErTOD+Q57UB3RrVu0ZbQhqVJEBYTx7UC11gv71bXSN0rGdqU5SfQnvQAOmtSLVuhClyoLgngTxknjmgaXLsoK0gpzIAkR8T6UELVyl1/wnFFa9oSNmTPbb3A96Cr/AKGXFeI2EkhRO3zjI7mIxz+lBy+xfMIcUkN3Ts7ZuWkvCYE/iE0AXWhquqNOs/fn0tOhXkRLTe0j/bwCCPTt70Dl9m/TlnpReNs2n7w42FKdye44oNFWS22n3596Dy2UHbYckGRM80H50+2uwFs/cOtoSAlQkgRP96DHmWUvXI3AgKHA9KAwm1WylwLCVsqgALAUPyPFBbYUhs722WWl8eI00lG38hQVtVu1KIKgPw4g7sfJoATrxUTu9TMfpQBNSbcubhJAVtT3mgfOiWdunSQQVDv/AEoDxOJ9e9BHwP5h2Iig5IkgdyYj1oIVpk4J/OgcNHUqYMSmeefwj9KCxcoMEJTkq79zHf3oF+9UEkIVEK4j8v8APigEvCZP60GnfZ9rttfss2V+8GblkQCo4cHaD2NBoi1XlktSmXApgjG5O4TExQId3b3LbV5fXbgh9whCQcRPNAv6G2EOuqbjdun0Pece+M0DXdsLVboUFbQEbgZ5JOfigp2F25b3KlLSUx+CHQeOJP5Yn2oHbTXG0NnegmESBPmmeM4oLd4xbv24CklON525UD6UCpq1wxpygGNzr4UQEQCpajwDn1zE+lA2dPrTp9ow06oeJtDjsiPMrn4A4A9qBiddbW0ShaSOf+KDvc2y1uKglJzJ70GDfblcW7jaSVlTawYB7nmR7UGM72haWTiQPFSSOxlPegP2aC8xmDOeMHHEH/ug+ubdthKlJUVJIAUo8/4KBcvijeQAQPUiKAYpUNrJIA7R6ig409QumduCuY4oNB0e2+56alI5MCJ7UEq+YHHImg8IG0CIxJg0EZBHoO0RQRkdgPnn+lA36U14QO4lK3FJWEQVTiCaCxdbAlRUIzGE4I9/U9qAPeolR42j8o/pQBnWxJg9/wAxQQtS24lbZKFJMgjsaB10fru8ZsRZ6gpTqR+BwCT9f0zQDtX6jutUeYDcM2rMrSCPxKjmgt6W4lV0VpJE9zAA4x+s0DvaPJcbaSoBRJyCYCldo+OaCslKHBASryKK9qU4IPaPSZmgLacC4AoStoK8xyATOSfcntnvQXdTvfu1mFBCQojcJTmBzPp9ZoOeg9DN+4nW9TByrfbNnj/9oOfigIfaDomo3OkXF304tX+qITIaKpDgHYSY3ek4NBhOjdc/aJot84NT022uNMDgCmlyh9AnkKmCecHnigaOo/tMU+wz91KiwtOCRBH649xQY7111bd6ipBeQpf+xkRMevxQBre8D6G/DThIlVA0aZclDLU7wDxmRH170Hl8+4lEjCYxnJoADrm8TMx2JoKbgU6ktNnc4vypEUDR0n0+bdkP3Qz6RxQNi+IED0EUFcgkYHl7UHIycnETMDFBGoZI4I5ighIJPKvpQN1nEFQSSQnaEniSQf39KC06SlSSmFQIyI4PPxQB70yo7ULTHcnJ+vegEPgqUNpJB/mHegqnBEZ9JoOkZIgz2FBdbVtQVKJUn8UHuBQF+n17m4Sole7bt9Z9+1A22z6/CWUJjOHNsQf70FhSocJQU+cbCuSkfMz6H86A7ZJbQguFwFISCSYOOI+aD7T9OPUF8EpT4WlsEB5ZJ/iqGSgevaT+VA+F9AQhLW0NjCQnER/Sg+dfUCdo3QN1Am9csWT+lvpu0gocQoJTthQjOIzQfmSztDfatdMjfsTPl7TzmgXNV09VneL3FRMwDEzQQWjcEiYFAx6U54luG1eZHMKOaCNx1W0NqEkJlKlemYoA6nIBAMdyDQX+lUFzqG3KQYQlSjFBoiQE43Yjmg4g7D5gAcZgUESiCT+iZ/tQcKJIkHjse9BGsQJPPb1oISAD5h8RQMOn3G1pKlBe8qhMk5jtHpQE3F4IdJSZjIMevH+c0A+7Cl4KTzJk/rQB30Ewrd5fT0oKjqIGZ459qD5IkyYHcd6C0yJR+ARzHOKC9o6vCvQgpSUqEnHcyP0oH20Zj+LtEKASUk4Hr+f70BG0s1MrCxCQhwObgOwIGf8AmgLOWy3EqQ2kuKMJECcnmSeOYFAYSpuwtWbdgNIQwPOZ49SRM5NAOvdcTaBQ8RCVBWCpXPp9MmgkRqDamS9erQ0whIO91zbInkzBI9qBeuerek/vSbS81Bq5fd8qQkjYcfzEYTJigHdKdC6TZazdX148ybRzxFNyobUgAYPvkn6UGLddP6U/1PdjSLgPW5M8Y/PvQLJb8FaRCQDJOMT60Fi3dKAFYJH0oI7haVuJWlUKGCR6Ef3oKZSC6oggxjcaBg6EZ36hd3CgfIjwx8mgd1EqyJjie9Bw6MgGJ/Mk+9BEpPmUUjjsOaD5Q80DAGBQQuJ9ZAAmKCBYM4UB80BuwggAFSVTHOD3/OgJeKfLHPIzgnmKCrchIJEBsHgZmf6CgEXX4QAEg5MUA9xWY7QB/wA0HiVYmffNAS05gvKmF7R+Q+tAY16zOlotLgf+t1QRuA/DicflQM2j6oHLE7YUlY3RPB/zMUBi1uCEqKkpJASQgZMTMzQMmlOjxiSUrSCRkZJngD470C91r1ArSWnHkpUvbkHjcAPwEnM8enFBhbmt9T6pqId0toBaCSC+TCAc8DvQX0dKfaJ1K4hzVbcXTMGR4pKUgcSkevx2oDrH2bdesIdXYWOnNoW0QWy8QtUEDbBwJB7+lArdSaR11o4b0+50563ZUFhO25K0EHkCBFAoLZ1hCC0uybSlJhW5RHHzQUbgX7A3LZREQB4h83xig5trx8qJeZSAceRU/vQEWWVKbUpQxggAxmaCo4othZJ+aB86QtFWWht7wUrf/iq9YPAoD+1QWkEx8D9KDmSgGOT3jNBGhP4ROZj3An9qD5SByczn0oK7iRPlT2nj9qCFQMjPaKAnbL2o/CdhIJKiOM4PbNAUwEJTKeIxzH/E0EF2BuUlKgROT6/lQBroSshWO+BkigoLI3YgGgiQCtYSkEk4oNM0nQlMdMre2pC1oIkyOe360Dqjpf8A1T7N2WHEJVfIQHE9yVo7E+pEj60GSl1zRnHLRRAt1Q40v1HcfSgd+mbsvWqXErSCElCgrsI/z86A7b3yAypB/mAgRgdzJ9c9qAV1KwNVeKAFqYUqFkJyoA+vaf2oDfT+jWzLDSlNtLIRCwG0jGYHx3zmgmvWAyx4jSwlI8yTBTAMcRnP5YoF/qbqu7skLcYN0XEEgpdSYjiff4oM9vftC6vLCktu2bVshwFIDQlB9vWgStR1rUb9JVeuJ3qUVQlIGScz6fFAv3Dbj5lZO0GBn86Dpu0EoSBjuDQSPO7WlNEfpn60HWi2B1TVG2R/6GgFu4/Sg0RKSN20FIEDHbtQSiTEnJ9I/wAmg9KJSSBOYOKDkoz+JRByIx9aCPkBKk9s/wBqCEpnaSIjsQaDgtgkyUn3I5oLNkNqgB/N5vSgLpKltnnyjPfn1oKdyoRkDbMnvjtQC7s+YkkTEx6UA51RJ9oOKA70Lo69W1hBWFBlBHORPtQbau1SzaG2QklAT5Z/WgcdJM6bbmIlAoMz+1HpRo7rtCIs3VblbR/6XPX2B/KaDN9E1FzSb0tPuR4c7VJ7zH0mgd13xX4dw2lxxtSYWIhM9/j1oOWn3HrlPiKa3qTEJTEDGJ7E9xmgabW7Q0ytLXmcIEgYg8GfX3+KCwu1eeWpSjCQYSVCZV8d8UA5/pdOpOhLyhtmVO7ZcI4x2HxwKAdq/wBnOli3ltbxWlO1Jx2+O/HzQZf1B0ki1dSfFJkFRBxJjJ+negVrnSVJCSEqSlQ3bl8UAh4eGlYVkxg+1ANXucISkFSyYSPWgfunbBvTrFDaSlTygFuqPJV7UBdCT4cRg4+aDtASpIlW3BmM+1BOlMhSFAhAwM8Cg82DfMEnuMCMf9UHiWwENgwSQcR74oI1tqDnmHlnvxPcUETjC5G1RAIk5PNBDJmARO36zQX7eQ35pBHY+tB4+rBOeDzzMZoBVySJ3emcd/70FNFuu6fDLYJUs4CRP+YoNw6C0AaRYJWraHiJJJg55oG3wQtA8XA4z2FAW0cgWxZxLZiPbmgtXVuzd2ztvctpdYdSULQoSFA8ig/Pf2k9GXfTdyq6YC39KUr+HcTKmv8A8V/0V3+aBf0nXFEFl8kuAYCjukfHfHrQOVlqbRLYbcKgUiSmCQP6e/NA36S4lTO6PC/mCSoeaY7Gga7W4bUR4xSJHlSSD7UFly6bBKgqQDOAP8/6oFfXtUQ694aVlCTGUOQVCeQByRH70CJ1M6wlQIKRuISR+IbRGJ+Yx80CBrV60yHWh4ZAJhYPPb6igQtSdC1KVJOeT6UFXpx/71qqksp2obO2e5oGRWpKtnghcgJVEmgLWWrgjzKH50Bxm7YcjzAke+IoLbakxKVQIges0EgQFpJ2nJAE/wCYoJW9peCZ8sSSaDpLcKKieDIBMCAewig58AnISROT2oADHAmAR3maC6yTsQVAJM4xOKD14hQwAn0PrQDLhO9QbbbKlk8D+tBof2c9Lbf/ADLoJJgcqyB9O9Bq1o35e0JGEjjNB3sSGQSoA/5igqi4NrqCHUA+GcKAONvagZEkKAIyDkUHFwy1cMLZuG0OtOApWhYkKB7EUGB/aZ9k11YeJqPSjRuLFMrXYg/xGu8tnuPbkUGW6brjls8kuBSkpVG9JhST3ChQaH0v1aAhBYe8YoPmVAKpk5UCCQMxge9Azo19LYcKbgFKkkDacc95zyKDy+6oSWi2h9bgI3K/iRgCIEc5oFzWOpGUPJ8NMuqIkqElPIwJgYz60Cp1H1M2toIt0jyLlvvie/vxQJF/dreBUVwkDnuPY0ADULhRbUoHyxzPNBd+z9ve5cLwZE8UBLqRMS6n8JgzPFBVt3nFIC2jBAoL1tqzjJTJINAYt9cB5UccZxQF7XXSAmVTHHtQFWdZSdpUvny5HAoCLGoNOr3KAPmMmc+/zQWNzRyTk84NArMHA9pPyaAmyAtpIA8x9vag6bZXcq8JhJUr2z/1QNXTHTJ+9ofuwkkngjH+TQaXasJZS2m3CQgj8MQTHr/agINShZMiSZ4/Sg8kqWpSoUk9ieKCpcsktRhKVc+ses0F3p6/8TxLV1e5SD5FHG4UBug+oMv+1H7KrPqdDuo6N4djrYE7gIQ/HZQ9cc0H5wfsbiw1Jyyv2XLLUGT5hO1Xyk+lBbVqF/bhKXFfeW0HClYV+Y5+ooK7utuoJlLg9hQUHtX3yCVCfSgoP3m4TsJzMzigprdU5lw49szQC9Xe2tKEkUDF0ChTdncPEQkJOZoLGvPMq0mVrSFyRE0AzRngWoJx+tBceQFKnv39qCBJKD5pMe2KC61ckhKUqI5xQWmn3EyUq7wKC6xqa21JnAHf+1AWGsqAhJkDvHNBbaIUpIPrFAW0xhy5KWm4JiJH8v1oND0DQ27dkF1B34nE5oG9tAbQAG1BJxBEmgvtkKblMTxj/OaCymI85mfUTQecjdjbBInEUFBayk+JuUqQUyBIxmTQUNQS/bOIubRskIO8qCvXv8UDRpOopvWgFjY8keZP9qAhQfUCZ9of2f6X1nYnxx921FA/gXbYhSD6H1FB+a+penNd6RuDb67aKLHCbpobm3PfHHNAvvpQtO5sgg8QcUA9bQM8g8UECwkDaTI5A9aCjdvbEkiAB7UC5cuKubhDLe4lZjFBoVy4jpzpZLTkeO6Mg0GeuPOXLilOLOwmdtAX0q4CCAqRQMzZStAKQCD3oOHUSPMBOeKCotXhqO32NBds3/ESMCZPHxQTq7kZ9BQd7sCgdLG3W8oBBISTBIxj/O9Bp3R+lIskeIUBRKZ8x/b296BoaQlbyFCFNjzbRgA/NBfWvw3f4YTHYg98UBBsqcSCN3qZ5B9/agl86GShW1aVTmaDh1KVIlawncJ2UECISJO0iMKmBM/2oKq2nAl1EhPiYBSMc0FRku2twHAXEuIMAep7/Q+lA0aLqadRaUFJLdw2YcbP8poCVB8aCnqFnb3dspq5YbeaVgocEg0GKdb/AGM6deFy46eeOnXBn+HyhZOeO1BjGudI9SaE4fvtmp1rs6z5gcUCtd3cEhYWhf8AtUmDQA9Vux4cA80DX9m/TG9B1nUkEMJ/BI5NAB631RWqa04lOWGztSDnFAJbaCYA+aCRsDxEjiDNA36dhhOBJ7k0FxY3fhmDQV1MAjMiZnPFBz4SkDymB60EyHJ5/Q0EuDkFP1FBt/TGjC3YDziFJUcTPPeKB20ghKdie4kpAJI9/wBaDnU71bagWEwCdpKuJigvWd0ldulbqQDEkpJj6fWgLWVw0tKYVG7zfB4igtKGyECdh7zgYoIHAHSVNwCDkdx70Edy0pTrakxBwqcRxgehoOn/AAy02kneUpwUjuO9BWdbWJWAoJx5TiI4oKT6bi0Uq/ZcUXEGQ2Exv9iaBq0nVGb+2CwQh1MJcbJylUZFBbcO1YWmCDjmg9cUNkiIPrkGgA6u35NylpQMwo96BF1e705p0tP6vbBZI8inAZPeaBVvOl9P6gecCBaPNzG8EExQY39o/SWh6D1O1as3K1lKgp1Ce1BJ1H12lzSU6Tptr4FshITu/wB0Dk0GeAFUkqSCoZPegkQmIGfyoIwYcT7UDZpjhU0kK/6oCSCMQJHYig6Ce+BPvmgjUAcYxQRLBntE4oO0qMdgO0mg/SbB27g4mEp98ex/egM6eEbVbSZEEf5+dAK15LvgrbhSkrTuBT6/9UFzpNQe01Ikh0fikmI70Bq0KitBwiDBAzj1oCbu5C0pAC957/vQfJbcQpSZABPlA70HdytSFISHCrdhMj/OaCAsqW0+kLBkDMUEDjYQk+fYEI3EqGSZ4oKirbxHWGGnz4byt5bKZBA9PQ+9BNqVkqzT/qFiv/y0ETOQtPoR8UAvqP7StA6eZSm9cdcvXEBabRlG5X1PA+aDJ+oPt61VIdZ0xm2t1TCDlxwDtPagyrqHqfqnXj4mp6jeoZWTtQVFM/QUC7c2xTsR4rjj5EncomKDy2uL62WVWd/dNlOVLSsxQUbx29e1FL7ri3Vr5U4qSoUE3kfQWzgEYA7GgoNbmlkGAknkigtqH8xJIoKhVteSJ4oG/QgCzJEmJx3oCcAlWAPig6RKAQTj9TQfKQDBBH0FB94cwT2H1oBrrqUrI3RHag/TdshW5x1O4yOARBH9KAmEhKikAFKiCI5j096AVrT62mVlkKTtV5gczPeg66MvAPEZdJRkCY496BjS1D60BxKFTvQfxQCc5+RQWnPGSS648dqZgjj5oOrd15taVoWkjBUog/pQX3nm3Q2ZAjg+h9/1oOW3j4yYWBgkkSR8fFBE+lPjA+KSUmQrb/X0oKO9376txcoU2goQuJBKjmfSguB7dua8qlJQCDxKieaBH+1PoG06u054sbrfVGElxt5CgC4r/aR6Gg/N9iwnSXLhq9Y8K9Zc8NTKhkq9BPY+tB9q929cvh15KTdFMBsYS0PU+9AJS0HQvzENzLjvdZ9BQTOWgS0la2ylB/8AU1OVe59qCldtlpZ3R4sSQOED0oFx1xds8rZ5kqk0F22U0/bAJTC0nzZnNBaXAYSJIV6EUAp1W25GQP6UDt02jc2MEe4FAWW2AvAx7UHKWwucD3IoO22vNtyRQdPIAbWfbigWn0qLpgT70H6n0t+bdeSl1KiNq8hQJx+/NBaZdO5CFJ8yRgA9v6RQCerG3gx4rbpT5SkpAgiO59qAL0xfPF3a2kpKEwQoz64+KDRGGkldrdL3LRcM7dgMpkH19aC22sLQCRCQSlO4zBHIoLfiLKyr+EU4AjM4oJbdC3BuUhKkoJChz70HN6pNvakIDaWk+YEKGSO0UEV1qCEWyXbhEEoKkFJBPHJ9qCpZKS9YtPPPFD7ySoTkRzkfFBJbw26hshwFA3BZyZ/qKC+2F3JHCgDJKYg/8H0FBj32zdAKvnF6/pTyHNTQlRWkiApP+0+hHY0GALcCkkDd4YPnUfxrX6UBW1tAUtqcbCnD/wCq3Twn3NBacaKXVoCkLuD/AOxw/haGMCgX9SaQGyGgrwJytXK1UC1qafDiZUojgUFWyQ6ysqQSD6UBH7z4oAKoUO1BSvPK4hRMUGk9FNIXaAxJiBHNAWv7YBBKcjkA0FBMpBjyk8x2oLDTW4ETk8nuaD64Qosq5B4igCrtCXFSkEgxzQfocrU3dNpUpKHVg+HIMLIyUxkTHA/KgItrEbklw8BSVDBPb4PvQSa42XmNjrQdVsH8QHgc/TvQZ/p94q315LW8BO4zPIPvQaBpw8RhDqNxQ25CEBWI9v2oDV0XEuFMBDRSVoJH8w7Y+tB9pid1y862+tSSnapMwndE7gPTkUFy2F4lTqFuhTSY3SIUCTyI9qCZ1TKtwV5kxACUg5PegH6674mnIslt7nX1paSAYhJOeOMUH1ylti2Nq2hO1KYQFKhREx5T60EzylNIIXtKxCQpfYmO9Bbs2vuTD7YcWZMlCo8qj2TFB4+2bpQSA4lKUytak7So0GE/a70Gti4e6i0uwUsNqh5poAIUYneE8zFBmtrdpSgpYcCnFJCn7jskegoJ1Fp23EHwrEYBjzPGf2NBT1FlwuNFxseMrDVunOwepoFXWWgl1Lchah+In1oIGmg4iO47UEL9uptIWkZHvQUnypaU9iKDU/s3Qp20CTAHPzQOOtWCRZBSCncDmOc0Cw0yUlW4AEAjzUErIIXHxk0E5SVSDwaD5TDYiQnIoNjhJKi++pTiTuAE4Ejv6zBoLVutz76yh4AJdEKUgnnOQO1BNefdmmUtrRG9CmN8kzIkZmQfegROrLdxLzd64G2HgQg+GJBI7/pQHOgbxOptv27wWrcwpZCTABH/AH2oHC2dJtGXSSQ4gfiOd3v7cUHjN0y0W2rZDibhJJVITBMxAoCdk09cOKlSg2DtJMSJ4mOfmg6NuwVOJU6tqCUqSkSfgGgp2jCUPOagy44+qPDCXcJ8Tur2wYkUETqYUp9aim5ZR5gFEpn1HpzQWLYuNWxK2mlWuz+IByVckj/mgtm4KXGkoCHGMKkgjtIMUF9Siu3W2yoNrTBIySAqYj8jQR3dslVuhLjpW04AlMpkicd/Wg/NX2udCL6Xuv8AVLIJGiPuFTzQgFtwnsO4NAq2jhbQ24tKV3a/Kyg/gaB4NB88CFPJQqXAP/IfPKfZPtQKF263cPLKEbQn8J7ketBJbs8KA83cUFpy23JCo3E9sUFe60VTVsXVJAB4zQNn2RuBTzja0yUyYoNSvNKKrVSkkA7cyeZoEC8Spl6D5T3igkQIAoJZClceYdu1BK3t2+aJ+JoP/9k="

/***/ },
/* 300 */
/***/ function(module, exports) {

	module.exports = "data:image/jpeg;base64,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"

/***/ },
/* 301 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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jZdlgrzQv7myFldfJQFOk+E0XjLx/wO6IG3XnQWvfQAAAEx0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlREb25hdGVsbG8yMDEyLnBuZ1IQ5DAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDMtMDdUMjM6NTA6NTkrMDA6MDCf1JlFAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTAzLTA3VDIzOjUwOjU5KzAwOjAw7okh+QAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi42LjktNyAyMDE0LTAzLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ4HTs8MAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADQwNDFqrhIAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMjQ3FC4VkwAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNDI1NzcyMjU5PufDkwAAABJ0RVh0VGh1bWI6OlNpemUAMTIzS0JC4fuycgAAADN0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3RtcC9sb2NhbGNvcHlfYjg3YzQ1OWM0MzQ1LTEucG5nEZaXyAAAAABJRU5ErkJggg=="

/***/ },
/* 302 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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eUFugqPpskfsJlc6HA5vyaOo/69Ysnn/gkJVadt2cWVI17ArEK58Y/valW9sfxIo3/n4mYesSJtZGTStaohRQqdtlVsDMdK66HwbJr1evtrcqLLZ1pR2XKkgYnJDNPhq7r40uVF9bOfl8Vdi1L3FcEDTj23350dVjR2x8pYmJS4zyH/l2N3dXXy52A8ePss9UE5vA/v9jX5Z9osTYmQYvJoYYkdYjESUat7uXX966wvH3nL09PzyuLfzwg2id5KXWS2ZfXmy3/yLrZcn/3R8bfYtVcZdr7FoyBdlVTj05zIej7lx48byjVoC5Lsq4quAEveuTOfP/8crX53O3FMms9MQVULUvNXYd5kiGdTbzZVLX776r4+c27hr/4WdE9Or402MPOmb+K92r1X/dO/y/Pd95Te7UmrGTYbugUoJt6jfx39pyPJ/wX/1//8HVgkkVesS6AMFMDr14Im7jr/5yJvy4/378rXirlGeHZ9fmW8/+enn/7eTj5x4pN6cnNs9v/uVttGnmpm/3vUWflFScVPbKvJK+dAlOJYA+Z4JcwgktgNH2QGmI7VTDE4OV1ePDQf4aG+8uHMNRWNUr1GrQwBwh8qoP88AZxlLgHzPgkReBZTsEEjkVf2LHAJF7ICweL26x1iCYwmQN9R7sQCLPZRdzKtA8mf6l0M/F181CFjGEiBvyPdF/pwXf87Dr4dAw7LHWALkVm7oX/3wL4HwOsb/C6yPRSDGvMY7AAAARnRFWHRjb21tZW50AEZpbGUgc291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZpbGU6VE1OVExlbzIwMTIucG5nJXHGFgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxMy0wOS0xNlQyMzoyNzo0MSswMDowMI1cwmAAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTMtMDktMTZUMjM6Mjc6NDErMDA6MDD8AXrcAAAARnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjYuOS03IDIwMTItMDgtMTcgUTE2IGh0dHA6Ly93d3cuaW1hZ2VtYWdpY2sub3JnnL25SAAAABh0RVh0VGh1bWI6OkRvY3VtZW50OjpQYWdlcwAxp/+7LwAAABh0RVh0VGh1bWI6OkltYWdlOjpoZWlnaHQAMzkze4OWfQAAABd0RVh0VGh1bWI6OkltYWdlOjpXaWR0aAAyNTJ9X9BdAAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAABd0RVh0VGh1bWI6Ok1UaW1lADEzNzkzNzQwNjFNTtgfAAAAEnRFWHRUaHVtYjo6U2l6ZQAxMzJLQkJkJ/ynAAAAM3RFWHRUaHVtYjo6VVJJAGZpbGU6Ly8vdG1wL2xvY2FsY29weV82YWIzYWMxMThhYzAtMS5wbmf+cubjAAAAAElFTkSuQmCC"

/***/ },
/* 303 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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/n8n/Kawy9PwPAAAAE90RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlRNaWNoZWxhbmdlbG8yMDEyLnBuZzgbWSMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTUtMDQtMTVUMTE6MDI6MzMrMDA6MDDebEYIAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE1LTA0LTE1VDExOjAyOjMzKzAwOjAwrzH+tAAAAEZ0RVh0c29mdHdhcmUASW1hZ2VNYWdpY2sgNi42LjktNyAyMDE0LTAzLTA2IFExNiBodHRwOi8vd3d3LmltYWdlbWFnaWNrLm9yZ4HTs8MAAAAYdEVYdFRodW1iOjpEb2N1bWVudDo6UGFnZXMAMaf/uy8AAAAYdEVYdFRodW1iOjpJbWFnZTo6aGVpZ2h0ADM3M+UAu/MAAAAXdEVYdFRodW1iOjpJbWFnZTo6V2lkdGgAMjY2UR9HhwAAABl0RVh0VGh1bWI6Ok1pbWV0eXBlAGltYWdlL3BuZz+yVk4AAAAXdEVYdFRodW1iOjpNVGltZQAxNDI5MDk1NzUzILs0cgAAABJ0RVh0VGh1bWI6OlNpemUAMTU5S0JCPGaOBgAAADN0RVh0VGh1bWI6OlVSSQBmaWxlOi8vL3RtcC9sb2NhbGNvcHlfZTVlMmQ2OWIyMWZjLTEucG5ntTzkBwAAAABJRU5ErkJggg=="

/***/ },
/* 304 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,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fjL+8Y1Pbz/fEymMS0SfiAFUDSEl/6PX9mZb10ZVWVhpJg33frTH7e/dk8OHx4eN56/2j9LXYmKH3Pk664AjWcmt682q9LwCyAV0txSQg93Z3bW1Mq6Nqs/Mx01vf2cqvkmq1uqr/7XzytrVtfL69fWP9ZOSXCIlpaRHoQNc7cev/WDnwZXn1zcP7x/bH3/3Nnu3d/FNvDf3fOnRXvyKD7rbWo4TtwqIhUDP5DHduNovK4BcwFgEWvKTg9361mi90tGl/q8aoTcZN/Lg3mTv1ltHL115dvR5DXFr/GjG4aMJew/GHO7O2LlzwO0fP9y9c2f8hpvU1/dvPSzD1KHKnZmXP3u4H78agh4Cky44jEEHA0O/b/SzlXKrWW2WD+MqLvj9LWj1BTDORX7wPw+//KnPX5s9+8zg91F97sFPDl4OPh0e3Nq7svuGa5tWEtGHLBUdEo3TyXTCq0cPwhc2+lIFlW8e1+nLB8f+lZQ4bsFRt78rGCNqBB0NLYOB4Vs/WdmOlQW5aJG6PGZJFEgxqtu5O75ZleYOpLWHO/Xfbm31XywIX/QuSEqqISaJIZFiZqoSa16fOf5+UPBpMfKNvbH+8eE4/bcqkyVwRAG1xqgCvV5OC48nK4CsLMhF868UrM0khDFq6IIE8K//cP+fRsPipgvabG/3f9O7uA86EKUkaf6XKc6nKZnvxBB/NG34o+N5er2e6w6ngi+LJsQogopBU0xsXFljb3ey2iEf8nWhm4p+63c/wivfuEuM2h01PdEDBEoR6a+tFZct6QVr9bo1PBujNjHHFfOU2JkHect5PeKUySN0nhcsJdryX5NW2arVehoAMhiWxJBw7qTbtzti2uWX6iqoLuaylxnFu8BYvL6wSAAqsppBXa2nCCA/4567TB9F52GW3LHYsRQL0unE+TPgq7VaTz1Auve9TF7QlWbuyoCkpa9XwFit/9cAeRJYnhjzr0CxWu9m/S9ZhZZICVfkQwAAAEp0RVh0Y29tbWVudABGaWxlIHNvdXJjZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxlOlRNTlRSYXBoYWVsMjAxMi5wbmekbX/HAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE1LTAzLTA3VDIzOjUwOjQ2KzAwOjAwpTbpMgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxNS0wMy0wN1QyMzo1MDo0NiswMDowMNRrUY4AAABGdEVYdHNvZnR3YXJlAEltYWdlTWFnaWNrIDYuNi45LTcgMjAxNC0wMy0wNiBRMTYgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmeB07PDAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAGHRFWHRUaHVtYjo6SW1hZ2U6OmhlaWdodAAzNTRJUkzSAAAAF3RFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADI4MVH4/6oAAAAZdEVYdFRodW1iOjpNaW1ldHlwZQBpbWFnZS9wbmc/slZOAAAAF3RFWHRUaHVtYjo6TVRpbWUAMTQyNTc3MjI0NrdD70MAAAASdEVYdFRodW1iOjpTaXplADE1NEtCQs4MVtsAAAAzdEVYdFRodW1iOjpVUkkAZmlsZTovLy90bXAvbG9jYWxjb3B5X2RmZjUwZDE0OTNkZi0xLnBuZ/ZXEo0AAAAASUVORK5CYII="

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var overArg = __webpack_require__(__webpack_module_template_argument_0__);
	
	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	
	module.exports = getPrototype;


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var getPrototype = __webpack_require__(__webpack_module_template_argument_0__),
	    isHostObject = __webpack_require__(__webpack_module_template_argument_1__),
	    isObjectLike = __webpack_require__(__webpack_module_template_argument_2__);
	
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';
	
	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}
	
	module.exports = isPlainObject;


/***/ }
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTcyNGFlZmFhZmM0YjkzODU0YWMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvcm91dGVyV2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NTGF6eVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2tleU1pcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTU5hbWVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc3RvcmVTaGFwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9hY3Rpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvcmVkdWNlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvTGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlRE9NSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2NyZWF0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWciLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2FjdGlvbnMvdHVydGxlLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9hY3Rpb25zL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC11c2VyLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9jb250YWluZXJzL3R1cnRsZS1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdHVydGxlLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1kZXRhaWwuanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL2NvbnRhaW5lcnMvdXNlci1saXN0LmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9hZ2UtY2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZGV2L2pzL3JlZHVjZXJzL3JlZHVjZXItYWN0aXZlLXR1cnRsZS5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci1hY3RpdmUtdXNlci5qcyIsIndlYnBhY2s6Ly8vLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci10dXJ0bGVzLmpzIiwid2VicGFjazovLy8uL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLXVzZXJzLmpzIiwid2VicGFjazovLy8uL3JvdXRlcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL2NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvaG9tZS5qcyIsIndlYnBhY2s6Ly8vLi9yb3V0ZXMvbm90Zm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL3R1cnRsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vcm91dGVzL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L2xpYi9jb21wb25lbnRzL2Nvbm5lY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvbGliL3V0aWxzL3dyYXBBY3Rpb25DcmVhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJlZHV4L34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9faXNIb3N0T2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtcmVkdXgvfi9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL21pZGRsZXdhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXItcmVkdXgvbGliL3N5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0hpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9UcmFuc2l0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2lzQWN0aXZlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2hSb3V0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9xdWVyeS1zdHJpbmcvfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EYW5nZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtbG9nZ2VyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4LXByb21pc2UtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtcHJvbWlzZS1taWRkbGV3YXJlL2Rpc3QvaXNQcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgtdGh1bmsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L2xpYi9iaW5kQWN0aW9uQ3JlYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzIiwid2VicGFjazovLy8uL34vcmVkdXgvfi9zeW1ib2wtb2JzZXJ2YWJsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9FaW5zdGVpbi5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9FdWxlci5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9MZW1haXRyZS5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9NVGVyZXNhLmpwZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL05ld3Rvbi5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9TY2hyb2VkaW5nZXIuanBnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvZGFWaW5jaS5qcGciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9kb25hdGVsbG8ucG5nIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvbGVvbmFyZG8ucG5nIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvbWljaGFlbGFuZ2Vsby5wbmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9yYXBoYWVsLnBuZyIsIndlYnBhY2s6Ly8vLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWR1eC9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIl0sIm5hbWVzIjpbInJlbmRlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJtaWRkbGV3YXJlIiwic2VsZWN0VHVydGxlIiwidHVydGxlIiwidHlwZSIsInBheWxvYWQiLCJzZWxlY3RVc2VyIiwidXNlciIsIkNvbXBUdXJ0bGUiLCJDb21wVXNlciIsIlR1cnRsZURldGFpbCIsInN0YXRlIiwiYWN0aXZlVHVydGxlIiwicHJvcHMiLCJpbWFnZSIsIm5hbWUiLCJha2EiLCJhZ2UiLCJkZXNjcmlwdGlvbiIsIkNvbXBvbmVudCIsIlR1cnRsZUxpc3QiLCJ0dXJ0bGVzIiwibWFwIiwiaWQiLCJjcmVhdGVMaXN0SXRlbXMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXRjaERpc3BhdGNoVG9Qcm9wcyIsImRpc3BhdGNoIiwiVXNlckRldGFpbCIsImFjdGl2ZVVzZXIiLCJsYXN0IiwiYm9ybk1vbnRoIiwiYm9ybkRheSIsImJvcm5ZZWFyIiwiVXNlckxpc3QiLCJ1c2VycyIsImEiLCJiIiwiYyIsImQiLCJNYXRoIiwiYWJzIiwiYWxsUmVkdWNlcnMiLCJyb3V0aW5nIiwiYWN0aW9uIiwidG9kYXkiLCJEYXRlIiwiZGQiLCJnZXREYXRlIiwibW0iLCJnZXRNb250aCIsInl5eXkiLCJnZXRGdWxsWWVhciIsImhpc3RvcnkiLCJBcHAiLCJteVN0eWxlIiwiZm9udEZhbWlseSIsIkNvbnRhaW5lciIsImNoaWxkcmVuIiwiTmF2IiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiSG9tZSIsIk5vdEZvdW5kIiwiVHVydGxlcyIsIlVzZXIiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsb0JBQVNBLE1BQVQsQ0FDRTtBQUFBO0FBQUEsS0FBVSxzQkFBVjtBQUNFO0FBREYsRUFERixFQUlFQyxTQUFTQyxjQUFULENBQXdCLE1BQXhCLENBSkYsRTs7Ozs7O0FDTkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUMvSnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXFEO0FBQ3JELE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUEsNEI7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5RkFBd0YsYUFBYTtBQUNyRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWU7QUFDZjs7QUFFQTtBQUNBLCtGQUE4RixlQUFlO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLDBCOzs7Ozs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBb0Q7O0FBRXBELHVCQUFzQixtQkFBbUI7QUFDekM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCOztBQUV4QjtBQUNBOztBQUVBLHFDOzs7Ozs7QUN0Q0E7O0FBRUE7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUSxnQkFBZ0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7QUMzTEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxRkFBb0YsYUFBYTtBQUNqRztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUM7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyx5QkFBeUIsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQWtCLHdCOzs7Ozs7O0FDcEJsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUEseUM7Ozs7Ozs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixZQUFXLGNBQWM7QUFDekIsWUFBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYjtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLG9CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLG9CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFFBQVE7QUFDbkIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0I7Ozs7Ozs7QUMzV0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxlQUFlO0FBQzFCLFlBQVcsZUFBZTtBQUMxQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBbUMsZ0NBQWdDOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDLCtCQUE4QjtBQUM5QjtBQUNBLGlCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0Esc0VBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLG9EQUFvRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUEsOEI7Ozs7Ozs7QUM3TUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBLG1DQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRTs7Ozs7OztBQ25OQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUM7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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RUEsc0M7Ozs7Ozs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWlDO0FBQ2pDLGlCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDOzs7Ozs7O0FDaFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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Q0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7QUFFRDs7QUFFQSxnQzs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsWUFBVyxlQUFlO0FBQzFCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDOzs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUM7Ozs7Ozs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkI7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDOzs7Ozs7QUNuWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWEsT0FBTztBQUNwQixjQUFhLEVBQUU7QUFDZixjQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsMEJBQTBCO0FBQzFELHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGNBQWEsa0JBQWtCO0FBQy9CLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsT0FBTztBQUNwQixjQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Qzs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IsaUJBQWlCO0FBQ3ZDLHdCQUF1Qix3QkFBd0I7QUFDL0MsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWEsMERBQTBEO0FBQ3ZFLGNBQWEsUUFBUTtBQUNyQixjQUFhLFFBQVE7QUFDckIsY0FBYSxRQUFRO0FBQ3JCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLHFEQUFvRDtBQUNwRDtBQUNBLHdCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qzs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELHlDOzs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQzs7Ozs7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUM7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Qzs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJHQUEwRztBQUMxRztBQUNBO0FBQ0E7QUFDQSw2R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsa0JBQWtCO0FBQ3JD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQsd0M7Ozs7Ozs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7QUMxSkE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esb0JBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDOzs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Qzs7Ozs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxlQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLGVBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCOztBQUU1Qiw2QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0Q7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQSxrQ0FBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGVBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QixjQUFhLFVBQVU7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsV0FBVztBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxXQUFXO0FBQ3hCLGNBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFDOztBQUVELHlDOzs7Ozs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQsdUM7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLGlCQUFpQjtBQUN2Qyx3QkFBdUIsd0JBQXdCO0FBQy9DLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxXQUFXO0FBQ3RCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsZ0JBQWdCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DOzs7Ozs7O0FDMW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDOzs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUM7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0M7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUM7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDOzs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkM7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQzs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQjs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLFlBQVcsa0JBQWtCO0FBQzdCLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDOzs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsMEJBQTBCO0FBQ3JDLGFBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsZ0JBQWdCO0FBQzNCLFlBQVcsUUFBUTtBQUNuQixZQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdLQUF1SztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0M7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Qjs7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHVCQUF1QjtBQUNsQyxhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsdUJBQXVCO0FBQ2xDLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRDOzs7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDOzs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsUUFBUTtBQUNuQixhQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCOzs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRDs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdEOzs7Ozs7QUNmQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLDJCOzs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0M7Ozs7OztBQ3RDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLCtCOzs7Ozs7QUN0Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyx5QkFBeUI7QUFDcEMsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0xBQW1MOztBQUVuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHVDOzs7Ozs7O0FDN0hBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsVUFBVTtBQUNyQixhQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDOzs7Ozs7O0FDbEZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDOzs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxxQkFBcUI7QUFDaEMsYUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Qzs7Ozs7O0FDckNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEI7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUM7Ozs7OztBQ3JDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGFBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Qjs7Ozs7O0FDckJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsYUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCOzs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DOzs7Ozs7QUNyQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7QUNoQ0E7O0FBRUEsbUNBQWtDLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLE9BQU8sa0JBQWtCLEVBQUUsYUFBYSxFQUFFLE9BQU8sd0JBQXdCLEVBQUU7O0FBRWpNLHdCQUF1QixtR0FBbUc7O0FBRTFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWMsMkJBQTJCO0FBQ3pDLGVBQWMsT0FBTztBQUNyQixlQUFjLE1BQU07QUFDcEIsZUFBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsMkJBQTJCO0FBQ3pDLGVBQWMsUUFBUTtBQUN0QixlQUFjLFFBQVE7QUFDdEIsZUFBYyxPQUFPO0FBQ3JCLGVBQWMsT0FBTztBQUNyQixlQUFjLFFBQVE7QUFDdEIsZUFBYyxRQUFRO0FBQ3RCLGVBQWMsUUFBUTtBQUN0QixlQUFjLFNBQVM7QUFDdkIsZUFBYyxTQUFTO0FBQ3ZCLGVBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBLHlFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQSxtRkFBa0Y7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFO0FBQzNFLFVBQVM7QUFDVCxtRUFBa0U7QUFDbEU7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1IQUFrSCxnQ0FBZ0M7QUFDbEo7O0FBRUE7QUFDQSw0R0FBMkcsc0NBQXNDO0FBQ2pKOztBQUVBO0FBQ0EseUdBQXdHLDRCQUE0QjtBQUNwSTs7QUFFQTtBQUNBLG1IQUFrSCxnQ0FBZ0M7QUFDbEo7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQjs7Ozs7O0FDbk9BOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVELHFHQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsa0dBQWtHOztBQUU5TyxvREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UCxtQ0FBa0MsaUNBQWlDLGVBQWUsZUFBZSxnQkFBZ0Isb0JBQW9CLE1BQU0sMENBQTBDLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLHlDQUF5QyxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhLEVBQUUsMkJBQTJCLDBCQUEwQixZQUFZLEVBQUUsMkNBQTJDLDhCQUE4QixFQUFFLE9BQU8sNkVBQTZFLEVBQUUsR0FBRyxFQUFFOztBQUVycEI7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esd0VBQXVFOztBQUV2RTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixzQkFBcUIsT0FBTztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxZQUFXLEtBQUssWUFBWSxhQUFhLEtBQUs7QUFDOUM7QUFDQSxZQUFXLEtBQUs7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUyxZQUFZLGdCQUFnQixLQUFLLFlBQVksYUFBYSxLQUFLOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUN4S0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQscUdBQW9HLG1CQUFtQixFQUFFLG1CQUFtQixrR0FBa0c7O0FBRTlPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFOzs7Ozs7QUNmQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEI7Ozs7OztBQ3RCQTs7QUFFQTs7QUFFQSxvREFBbUQsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELDJCQUEyQixFQUFFLEVBQUUsRUFBRSxlQUFlOztBQUU5UDs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFlBQVk7QUFDdkIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSx5RUFBd0UsYUFBYTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQSx5QkFBd0I7QUFDeEI7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEU7Ozs7OztBQ3pEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLGNBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDbERBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLHNDQUFzQzs7QUFFakY7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHlFQUF3RTtBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7Ozs7Ozs7Ozs7O0FDOUhBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDSEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbEJBLG1DQUFrQyxvK2Y7Ozs7OztBQ0FsQyxtQ0FBa0Msd3VtQjs7Ozs7O0FDQWxDLG1DQUFrQyw0bW9COzs7Ozs7QUNBbEMsbUNBQWtDLGdoZDs7Ozs7O0FDQWxDLG1DQUFrQyxvMW1DOzs7Ozs7QUNBbEMsbUNBQWtDLGdxb0I7Ozs7OztBQ0FsQyxtQ0FBa0MsdzE3Qzs7Ozs7O0FDQWxDLGtDQUFpQyxvcXhGOzs7Ozs7QUNBakMsa0NBQWlDLG8yNUY7Ozs7OztBQ0FqQyxrQ0FBaUMsNDM2STs7Ozs7O0FDQWpDLGtDQUFpQyxvdGdGOzs7Ozs7QUNBakM7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGE3MjRhZWZhYWZjNGI5Mzg1NGFjXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSAncmVhY3QtcmVkdXgnXG5pbXBvcnQgQXBwIGZyb20gJy4vYXBwLmpzJ1xuaW1wb3J0IHN0b3JlIGZyb20gJy4uL2Rldi9qcy9zdG9yZSdcblxuUmVhY3RET00ucmVuZGVyKFxuICA8UHJvdmlkZXIgc3RvcmU9e3N0b3JlfT5cbiAgICA8QXBwIC8+XG4gIDwvUHJvdmlkZXI+LFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpXG4pXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvaW5kZXguanNcbiAqKi8iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaW52YXJpYW50LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcmVhY3RQcm9kSW52YXJpYW50XG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9yZWFjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFRyZWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZE5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhjaGlsZElEKSB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC10ZXh0OiAnICsgY2hpbGRJRCArICcgJyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIGNoaWxkSUQgKyAnICcpIHtcbiAgICAgICAgcHJlY2FjaGVOb2RlKGNoaWxkSW5zdCwgY2hpbGROb2RlKTtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgRE9NIGNoaWxkcmVuIHdpdGhvdXQgZmluZGluZyBhbiBJRCBtYXRjaC5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpIDogX3Byb2RJbnZhcmlhbnQoJzMyJywgY2hpbGRJRCkgOiB2b2lkIDA7XG4gIH1cbiAgaW5zdC5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0O1xuICB2YXIgaW5zdDtcbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiBpbnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gICEoaW5zdC5faG9zdE5vZGUgIT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIGlmIChpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBET00gbm9kZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHBhcmVudHMucHVzaChpbnN0KTtcbiAgICAhaW5zdC5faG9zdFBhcmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBET00gdHJlZSByb290IHNob3VsZCBhbHdheXMgaGF2ZSBhIG5vZGUgcmVmZXJlbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzM0JykgOiB2b2lkIDA7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cblxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxuICAvLyBub2RlLCBhbmQgYGluc3RgIGlzIHRoZSBkZWVwZXN0IGFuY2VzdG9yIHRoYXQgZG9lcy5cbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9ob3N0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSB7XG4gIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbiAgcHJlY2FjaGVDaGlsZE5vZGVzOiBwcmVjYWNoZUNoaWxkTm9kZXMsXG4gIHByZWNhY2hlTm9kZTogcHJlY2FjaGVOb2RlLFxuICB1bmNhY2hlTm9kZTogdW5jYWNoZU5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRUcmVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSByb3V0ZXJXYXJuaW5nO1xuZXhwb3J0cy5fcmVzZXRXYXJuZWQgPSBfcmVzZXRXYXJuZWQ7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgd2FybmVkID0ge307XG5cbmZ1bmN0aW9uIHJvdXRlcldhcm5pbmcoZmFsc2VUb1dhcm4sIG1lc3NhZ2UpIHtcbiAgLy8gT25seSBpc3N1ZSBkZXByZWNhdGlvbiB3YXJuaW5ncyBvbmNlLlxuICBpZiAobWVzc2FnZS5pbmRleE9mKCdkZXByZWNhdGVkJykgIT09IC0xKSB7XG4gICAgaWYgKHdhcm5lZFttZXNzYWdlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFttZXNzYWdlXSA9IHRydWU7XG4gIH1cblxuICBtZXNzYWdlID0gJ1tyZWFjdC1yb3V0ZXJdICcgKyBtZXNzYWdlO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgX3dhcm5pbmcyLmRlZmF1bHQuYXBwbHkodW5kZWZpbmVkLCBbZmFsc2VUb1dhcm4sIG1lc3NhZ2VdLmNvbmNhdChhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIF9yZXNldFdhcm5lZCgpIHtcbiAgd2FybmVkID0ge307XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0cnVtZW50YXRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50VHJlZUhvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGlzTmF0aXZlKGZuKSB7XG4gIC8vIEJhc2VkIG9uIGlzTmF0aXZlKCkgZnJvbSBMb2Rhc2hcbiAgdmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nXG4gIC8vIFRha2UgYW4gZXhhbXBsZSBuYXRpdmUgZnVuY3Rpb24gc291cmNlIGZvciBjb21wYXJpc29uXG4gIC5jYWxsKGhhc093blByb3BlcnR5KVxuICAvLyBTdHJpcCByZWdleCBjaGFyYWN0ZXJzIHNvIHdlIGNhbiB1c2UgaXQgZm9yIHJlZ2V4XG4gIC5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC8vIFJlbW92ZSBoYXNPd25Qcm9wZXJ0eSBmcm9tIHRoZSB0ZW1wbGF0ZSB0byBtYWtlIGl0IGdlbmVyaWNcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnKTtcbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gZnVuY1RvU3RyaW5nLmNhbGwoZm4pO1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3Qoc291cmNlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciBjYW5Vc2VDb2xsZWN0aW9ucyA9XG4vLyBBcnJheS5mcm9tXG50eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuLy8gTWFwXG50eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcCkgJiZcbi8vIE1hcC5wcm90b3R5cGUua2V5c1xuTWFwLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwLnByb3RvdHlwZS5rZXlzKSAmJlxuLy8gU2V0XG50eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldCkgJiZcbi8vIFNldC5wcm90b3R5cGUua2V5c1xuU2V0LnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0LnByb3RvdHlwZS5rZXlzKTtcblxudmFyIGl0ZW1NYXA7XG52YXIgcm9vdElEU2V0O1xuXG52YXIgaXRlbUJ5S2V5O1xudmFyIHJvb3RCeUtleTtcblxuaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gIGl0ZW1NYXAgPSBuZXcgTWFwKCk7XG4gIHJvb3RJRFNldCA9IG5ldyBTZXQoKTtcbn0gZWxzZSB7XG4gIGl0ZW1CeUtleSA9IHt9O1xuICByb290QnlLZXkgPSB7fTtcbn1cblxudmFyIHVubW91bnRlZElEcyA9IFtdO1xuXG4vLyBVc2Ugbm9uLW51bWVyaWMga2V5cyB0byBwcmV2ZW50IFY4IHBlcmZvcm1hbmNlIGlzc3Vlczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbmZ1bmN0aW9uIGdldEtleUZyb21JRChpZCkge1xuICByZXR1cm4gJy4nICsgaWQ7XG59XG5mdW5jdGlvbiBnZXRJREZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBwYXJzZUludChrZXkuc3Vic3RyKDEpLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGdldChpZCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJldHVybiBpdGVtQnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSBpdGVtQnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gIHZhciBpdGVtID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHRleHQ6IG51bGwsXG4gICAgY2hpbGRJRHM6IFtdLFxuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgdXBkYXRlQ291bnQ6IDBcbiAgfTtcblxuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvb3QoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcm9vdEJ5S2V5W2tleV0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJvb3QoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcm9vdElEU2V0WydkZWxldGUnXShpZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIHJvb3RCeUtleVtrZXldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRJRHMoKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbUJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSb290SURzKCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdEJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXJnZURlZXAoaWQpIHtcbiAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICBpZiAoaXRlbSkge1xuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XG5cbiAgICByZW1vdmUoaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyBuYW1lICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcklEKSB7XG4gICAgb3duZXJOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2UsIG93bmVyTmFtZSk7XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0ge1xuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXQobmV4dENoaWxkSUQpO1xuICAgICAgIW5leHRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob29rIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MCcpIDogdm9pZCAwO1xuICAgICAgIShuZXh0Q2hpbGQuY2hpbGRJRHMgIT0gbnVsbCB8fCB0eXBlb2YgbmV4dENoaWxkLmVsZW1lbnQgIT09ICdvYmplY3QnIHx8IG5leHRDaGlsZC5lbGVtZW50ID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uU2V0Q2hpbGRyZW4oKSB0byBmaXJlIGZvciBhIGNvbnRhaW5lciBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQxJykgOiB2b2lkIDA7XG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbk1vdW50Q29tcG9uZW50KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCc3MScpIDogdm9pZCAwO1xuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZC5wYXJlbnRJRCA9IGlkO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXG4gICAgICAgIC8vIGJlIHB1cmdlZCBmcm9tIG91ciB0cmVlIGRhdGEgc28gdGhlaXIgcGFyZW50IElEIGlzIG1pc3NpbmcuXG4gICAgICB9XG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uQmVmb3JlTW91bnRDb21wb25lbnQoKSBwYXJlbnQgYW5kIG9uU2V0Q2hpbGRyZW4oKSB0byBiZSBjb25zaXN0ZW50ICglcyBoYXMgcGFyZW50cyAlcyBhbmQgJXMpLicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IF9wcm9kSW52YXJpYW50KCcxNDInLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gICAgY3JlYXRlKGlkLCBlbGVtZW50LCBwYXJlbnRJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaXRlbS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGFkZFJvb3QoaWQpO1xuICAgIH1cbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0udXBkYXRlQ291bnQrKztcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5IGNoaWxkIHRocmV3IHdoaWxlIG1vdW50aW5nLiBUaGVuIHRoaXMgaW5zdGFuY2UgbmV2ZXJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxuICAgICAgaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZW1vdmVSb290KGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudGVkSURzLnB1c2goaWQpO1xuICB9LFxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RDb21wb25lbnRUcmVlSG9vay5fcHJldmVudFB1cmdpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHVubW91bnRlZElEc1tpXTtcbiAgICAgIHB1cmdlRGVlcChpZCk7XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICB9LFxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNNb3VudGVkIDogZmFsc2U7XG4gIH0sXG4gIGdldEN1cnJlbnRTdGFja0FkZGVuZHVtOiBmdW5jdGlvbiAodG9wRWxlbWVudCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHRvcEVsZW1lbnQpIHtcbiAgICAgIHZhciB0eXBlID0gdG9wRWxlbWVudC50eXBlO1xuICAgICAgdmFyIG5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIDogdHlwZTtcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xuICAgICAgaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUgfHwgJ1Vua25vd24nLCB0b3BFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcblxuICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChpZCk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHdoaWxlIChpZCkge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRDaGlsZElEczogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgfSxcbiAgZ2V0T3duZXJJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5fb3duZXIuX2RlYnVnSUQ7XG4gIH0sXG4gIGdldFBhcmVudElEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBhcmVudElEIDogbnVsbDtcbiAgfSxcbiAgZ2V0U291cmNlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0udXBkYXRlQ291bnQgOiAwO1xuICB9LFxuXG5cbiAgZ2V0UmVnaXN0ZXJlZElEczogZ2V0UmVnaXN0ZXJlZElEcyxcblxuICBnZXRSb290SURzOiBnZXRSb290SURzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcbiAgICB2YXIgc2hhZG93Q2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KHByb3BzLmNoaWxkcmVuKSA/IHByb3BzLmNoaWxkcmVuLnNsaWNlKDApIDogcHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NoYWRvd0NoaWxkcmVuJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2hhZG93Q2hpbGRyZW5cbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NoYWRvd0NoaWxkcmVuID0gc2hhZG93Q2hpbGRyZW47XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoLi4uKTogRXhwZWN0ZWQgcHJvcHMgYXJndW1lbnQgdG8gYmUgYSBwbGFpbiBvYmplY3QuICcgKyAnUHJvcGVydGllcyBkZWZpbmVkIGluIGl0cyBwcm90b3R5cGUgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICAgIGNvbmZpZy5fX3Byb3RvX18gPT0gbnVsbCB8fCBjb25maWcuX19wcm90b19fID09PSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICAgICAgJ1JlYWN0LmNsb25lRWxlbWVudCguLi4pOiBFeHBlY3RlZCBwcm9wcyBhcmd1bWVudCB0byBiZSBhIHBsYWluIG9iamVjdC4gJyArICdQcm9wZXJ0aWVzIGRlZmluZWQgaW4gaXRzIHByb3RvdHlwZSBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cblJlYWN0RWxlbWVudC5SRUFDVF9FTEVNRU5UX1RZUEUgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vd2FybmluZy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gbWF0Y2ggZGlydHktY29tcG9uZW50cyBhcnJheSBsZW5ndGggKCVzKS4nLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogX3Byb2RJbnZhcmlhbnQoJzEyNCcsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiB2b2lkIDA7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICAvLyBBbnkgdXBkYXRlcyBlbnF1ZXVlZCB3aGlsZSByZWNvbmNpbGluZyBtdXN0IGJlIHBlcmZvcm1lZCBhZnRlciB0aGlzIGVudGlyZVxuICAvLyBiYXRjaC4gT3RoZXJ3aXNlLCBpZiBkaXJ0eUNvbXBvbmVudHMgaXMgW0EsIEJdIHdoZXJlIEEgaGFzIGNoaWxkcmVuIEIgYW5kXG4gIC8vIEMsIEIgY291bGQgdXBkYXRlIHR3aWNlIGluIGEgc2luZ2xlIGJhdGNoIGlmIEMncyByZW5kZXIgZW5xdWV1ZXMgYW4gdXBkYXRlXG4gIC8vIHRvIEIgKHNpbmNlIEIgd291bGQgaGF2ZSBhbHJlYWR5IHVwZGF0ZWQsIHdlIHNob3VsZCBza2lwIGl0LCBhbmQgdGhlIG9ubHlcbiAgLy8gd2F5IHdlIGNhbiBrbm93IHRvIGRvIHNvIGlzIGJ5IGNoZWNraW5nIHRoZSBiYXRjaCBjb3VudGVyKS5cbiAgdXBkYXRlQmF0Y2hOdW1iZXIrKztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgdmFyIG1hcmtlck5hbWU7XG4gICAgaWYgKFJlYWN0RmVhdHVyZUZsYWdzLmxvZ1RvcExldmVsUmVuZGVycykge1xuICAgICAgdmFyIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgLy8gRHVjayB0eXBlIFRvcExldmVsV3JhcHBlci4gVGhpcyBpcyBwcm9iYWJseSBhbHdheXMgdHJ1ZS5cbiAgICAgIGlmIChjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnByb3BzID09PSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50Ll9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IHVwZGF0ZTogJyArIG5hbWVkQ29tcG9uZW50LmdldE5hbWUoKTtcbiAgICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBSZWFjdFJlY29uY2lsZXIucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KGNvbXBvbmVudCwgdHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24sIHVwZGF0ZUJhdGNoTnVtYmVyKTtcblxuICAgIGlmIChtYXJrZXJOYW1lKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrc1tqXSwgY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAvLyBhcnJheSBhbmQgcGVyZm9ybSBhbnkgdXBkYXRlcyBlbnF1ZXVlZCBieSBtb3VudC1yZWFkeSBoYW5kbGVycyAoaS5lLixcbiAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgd2hpbGUgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGggfHwgYXNhcEVucXVldWVkKSB7XG4gICAgaWYgKGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKHJ1bkJhdGNoZWRVcGRhdGVzLCBudWxsLCB0cmFuc2FjdGlvbik7XG4gICAgICBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICBhc2FwQ2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gICAgICBxdWV1ZS5ub3RpZnlBbGwoKTtcbiAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50KSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgaWYgKGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCkge1xuICAgIGNvbXBvbmVudC5fdXBkYXRlQmF0Y2hOdW1iZXIgPSB1cGRhdGVCYXRjaE51bWJlciArIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJldXBkYXRlcyBhcmUgbm90IGJlaW5nIGJhdGNoZWQuJykgOiBfcHJvZEludmFyaWFudCgnMTI1JykgOiB2b2lkIDA7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBfcHJvZEludmFyaWFudCgnMTI2JykgOiB2b2lkIDA7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyNycpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nKSA6IF9wcm9kSW52YXJpYW50KCcxMjgnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogX3Byb2RJbnZhcmlhbnQoJzEyOScpIDogdm9pZCAwO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3IoeyBidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbCB9KTtcblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IGtleU1pcnJvcih7XG4gIHRvcEFib3J0OiBudWxsLFxuICB0b3BBbmltYXRpb25FbmQ6IG51bGwsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogbnVsbCxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcEJsdXI6IG51bGwsXG4gIHRvcENhblBsYXk6IG51bGwsXG4gIHRvcENhblBsYXlUaHJvdWdoOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BFbXB0aWVkOiBudWxsLFxuICB0b3BFbmNyeXB0ZWQ6IG51bGwsXG4gIHRvcEVuZGVkOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BJbnZhbGlkOiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcExvYWRlZERhdGE6IG51bGwsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBudWxsLFxuICB0b3BMb2FkU3RhcnQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUGF1c2U6IG51bGwsXG4gIHRvcFBsYXk6IG51bGwsXG4gIHRvcFBsYXlpbmc6IG51bGwsXG4gIHRvcFByb2dyZXNzOiBudWxsLFxuICB0b3BSYXRlQ2hhbmdlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWVrZWQ6IG51bGwsXG4gIHRvcFNlZWtpbmc6IG51bGwsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wU3RhbGxlZDogbnVsbCxcbiAgdG9wU3VibWl0OiBudWxsLFxuICB0b3BTdXNwZW5kOiBudWxsLFxuICB0b3BUZXh0SW5wdXQ6IG51bGwsXG4gIHRvcFRpbWVVcGRhdGU6IG51bGwsXG4gIHRvcFRvdWNoQ2FuY2VsOiBudWxsLFxuICB0b3BUb3VjaEVuZDogbnVsbCxcbiAgdG9wVG91Y2hNb3ZlOiBudWxsLFxuICB0b3BUb3VjaFN0YXJ0OiBudWxsLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBudWxsLFxuICB0b3BWb2x1bWVDaGFuZ2U6IG51bGwsXG4gIHRvcFdhaXRpbmc6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IGZhbHNlO1xudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSB2YWxpZC10eXBlb2ZcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCAnVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3VcXCdyZSAnICsgJ3NlZWluZyB0aGlzLCB5b3VcXCdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuICcgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAgKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAgKlxuICAqIEBwYXJhbSB7b2JqZWN0fSBTeW50aGV0aWNFdmVudFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzLCAnICsgJ3lvdVxcJ3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gJyArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuaXNSZWFjdENoaWxkcmVuID0gaXNSZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQgPSBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW47XG5leHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGNyZWF0ZVJvdXRlcztcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc1ZhbGlkQ2hpbGQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQob2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENoaWxkcmVuKG9iamVjdCkge1xuICByZXR1cm4gaXNWYWxpZENoaWxkKG9iamVjdCkgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpICYmIG9iamVjdC5ldmVyeShpc1ZhbGlkQ2hpbGQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZShkZWZhdWx0UHJvcHMsIHByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIgcm91dGUgPSBjcmVhdGVSb3V0ZSh0eXBlLmRlZmF1bHRQcm9wcywgZWxlbWVudC5wcm9wcyk7XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkUm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4ocm91dGUuY2hpbGRyZW4sIHJvdXRlKTtcblxuICAgIGlmIChjaGlsZFJvdXRlcy5sZW5ndGgpIHJvdXRlLmNoaWxkUm91dGVzID0gY2hpbGRSb3V0ZXM7XG5cbiAgICBkZWxldGUgcm91dGUuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gcm91dGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHJvdXRlcyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gUmVhY3RDaGlsZHJlbi4gSlNYXG4gKiBwcm92aWRlcyBhIGNvbnZlbmllbnQgd2F5IHRvIHZpc3VhbGl6ZSBob3cgcm91dGVzIGluIHRoZSBoaWVyYXJjaHkgYXJlXG4gKiBuZXN0ZWQuXG4gKlxuICogICBpbXBvcnQgeyBSb3V0ZSwgY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4gfSBmcm9tICdyZWFjdC1yb3V0ZXInXG4gKlxuICogICBjb25zdCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihcbiAqICAgICA8Um91dGUgY29tcG9uZW50PXtBcHB9PlxuICogICAgICAgPFJvdXRlIHBhdGg9XCJob21lXCIgY29tcG9uZW50PXtEYXNoYm9hcmR9Lz5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwibmV3c1wiIGNvbXBvbmVudD17TmV3c0ZlZWR9Lz5cbiAqICAgICA8L1JvdXRlPlxuICogICApXG4gKlxuICogTm90ZTogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSB1c2VkIHdoZW4geW91IHByb3ZpZGUgPFJvdXRlPiBjaGlsZHJlblxuICogdG8gYSA8Um91dGVyPiBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKGNoaWxkcmVuLCBwYXJlbnRSb3V0ZSkge1xuICB2YXIgcm91dGVzID0gW107XG5cbiAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKF9yZWFjdDIuZGVmYXVsdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gQ29tcG9uZW50IGNsYXNzZXMgbWF5IGhhdmUgYSBzdGF0aWMgY3JlYXRlKiBtZXRob2QuXG4gICAgICBpZiAoZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkge1xuICAgICAgICB2YXIgcm91dGUgPSBlbGVtZW50LnR5cGUuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKTtcblxuICAgICAgICBpZiAocm91dGUpIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlcy5wdXNoKGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygcm91dGVzIGZyb20gdGhlIGdpdmVuIG9iamVjdCB3aGljaFxuICogbWF5IGJlIGEgSlNYIHJvdXRlLCBhIHBsYWluIG9iamVjdCByb3V0ZSwgb3IgYW4gYXJyYXkgb2YgZWl0aGVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMocm91dGVzKSB7XG4gIGlmIChpc1JlYWN0Q2hpbGRyZW4ocm91dGVzKSkge1xuICAgIHJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlcyk7XG4gIH0gZWxzZSBpZiAocm91dGVzICYmICFBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBbcm91dGVzXTtcbiAgfVxuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvc2luZyB0aGUgYWJpbGl0eSB0byBkeW5hbWljYWxseSB1c2Uga2V5IHN0cmluZ3MgYXMgdmFsdWVzXG4gKiB0aGVtc2VsdmVzLiBQYXNzIGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleS92YWwgcGFpciBhbmQgaXQgd2lsbCByZXR1cm5cbiAqIHlvdSB0aGUgc3RyaW5nIGtleSBvZiB0aGF0IHNpbmdsZSByZWNvcmQuIFN1cHBvc2UgeW91IHdhbnQgdG8gZ3JhYiB0aGVcbiAqIHZhbHVlIGZvciBhIGtleSAnY2xhc3NOYW1lJyBpbnNpZGUgb2YgYW4gb2JqZWN0LiBLZXkvdmFsIG1pbmlmaWNhdGlvbiBtYXlcbiAqIGhhdmUgYWxpYXNlZCB0aGF0IGtleSB0byBiZSAneGExMicuIGtleU9mKHtjbGFzc05hbWU6IG51bGx9KSB3aWxsIHJldHVyblxuICogJ3hhMTInIGluIHRoYXQgY2FzZS4gUmVzb2x2ZSBrZXlzIHlvdSB3YW50IHRvIHVzZSBvbmNlIGF0IHN0YXJ0dXAgdGltZSwgdGhlblxuICogcmV1c2UgdGhvc2UgcmVzb2x1dGlvbnMuXG4gKi9cbnZhciBrZXlPZiA9IGZ1bmN0aW9uIGtleU9mKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlPZi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMuaGlzdG9yeSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIGFycmF5T2YgPSBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2Y7XG52YXIgb25lT2ZUeXBlID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGU7XG52YXIgZWxlbWVudCA9IF9yZWFjdC5Qcm9wVHlwZXMuZWxlbWVudDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG5mdW5jdGlvbiBmYWxzeShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkgcmV0dXJuIG5ldyBFcnJvcignPCcgKyBjb21wb25lbnROYW1lICsgJz4gc2hvdWxkIG5vdCBoYXZlIGEgXCInICsgcHJvcE5hbWUgKyAnXCIgcHJvcCcpO1xufVxuXG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IHNoYXBlKHtcbiAgbGlzdGVuOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnQgPSBvbmVPZlR5cGUoW2Z1bmMsIHN0cmluZ10pO1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBvbmVPZlR5cGUoW2NvbXBvbmVudCwgb2JqZWN0XSk7XG52YXIgcm91dGUgPSBleHBvcnRzLnJvdXRlID0gb25lT2ZUeXBlKFtvYmplY3QsIGVsZW1lbnRdKTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IG9uZU9mVHlwZShbcm91dGUsIGFycmF5T2Yocm91dGUpXSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbnRlcm5hbFByb3BUeXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmV4dHJhY3RQYXRoID0gZXh0cmFjdFBhdGg7XG5leHBvcnRzLnBhcnNlUGF0aCA9IHBhcnNlUGF0aDtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gZXh0cmFjdFBhdGgoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXmh0dHBzPzpcXC9cXC9bXlxcL10qLyk7XG5cbiAgaWYgKG1hdGNoID09IG51bGwpIHJldHVybiBzdHJpbmc7XG5cbiAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gZXh0cmFjdFBhdGgocGF0aCk7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocGF0aCA9PT0gcGF0aG5hbWUsICdBIHBhdGggbXVzdCBiZSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggb25seSwgbm90IGEgZnVsbHkgcXVhbGlmaWVkIFVSTCBsaWtlIFwiJXNcIicsIHBhdGgpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIGlmIChwYXRobmFtZSA9PT0gJycpIHBhdGhuYW1lID0gJy8nO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2hcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBpbGVQYXR0ZXJuID0gY29tcGlsZVBhdHRlcm47XG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcbmV4cG9ydHMuZ2V0UGFyYW1OYW1lcyA9IGdldFBhcmFtTmFtZXM7XG5leHBvcnRzLmdldFBhcmFtcyA9IGdldFBhcmFtcztcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBfY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICB2YXIgcmVnZXhwU291cmNlID0gJyc7XG4gIHZhciBwYXJhbU5hbWVzID0gW107XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICBsYXN0SW5kZXggPSAwLFxuICAgICAgbWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyRdKil8XFwqXFwqfFxcKnxcXCh8XFwpL2c7XG4gIHdoaWxlIChtYXRjaCA9IG1hdGNoZXIuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyhbXi9dKyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKionKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKiknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLio/KSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyg/Oic7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyknKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyk/JztcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChtYXRjaFswXSk7XG5cbiAgICBsYXN0SW5kZXggPSBtYXRjaGVyLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogcGF0dGVybixcbiAgICByZWdleHBTb3VyY2U6IHJlZ2V4cFNvdXJjZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHRva2VuczogdG9rZW5zXG4gIH07XG59XG5cbnZhciBDb21waWxlZFBhdHRlcm5zQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dKSBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0gPSBfY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgcmV0dXJuIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBtYXRjaCBhIHBhdHRlcm4gb24gdGhlIGdpdmVuIHBhdGhuYW1lLiBQYXR0ZXJucyBtYXkgdXNlXG4gKiB0aGUgZm9sbG93aW5nIHNwZWNpYWwgY2hhcmFjdGVyczpcbiAqXG4gKiAtIDpwYXJhbU5hbWUgICAgIE1hdGNoZXMgYSBVUkwgc2VnbWVudCB1cCB0byB0aGUgbmV4dCAvLCA/LCBvciAjLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgY2FwdHVyZWQgc3RyaW5nIGlzIGNvbnNpZGVyZWQgYSBcInBhcmFtXCJcbiAqIC0gKCkgICAgICAgICAgICAgV3JhcHMgYSBzZWdtZW50IG9mIHRoZSBVUkwgdGhhdCBpcyBvcHRpb25hbFxuICogLSAqICAgICAgICAgICAgICBDb25zdW1lcyAobm9uLWdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHRcbiAqICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWZcbiAqICAgICAgICAgICAgICAgICAgdGhlcmUgaXMgbm9uZVxuICogLSAqKiAgICAgICAgICAgICBDb25zdW1lcyAoZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAqICAgICAgICAgICAgICAgICAgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZiB0aGVyZSBpcyBub25lXG4gKlxuICogIFRoZSBmdW5jdGlvbiBjYWxscyBjYWxsYmFjayhlcnJvciwgbWF0Y2hlZCkgd2hlbiBmaW5pc2hlZC5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcmVtYWluaW5nUGF0aG5hbWVcbiAqIC0gcGFyYW1OYW1lc1xuICogLSBwYXJhbVZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgLy8gRW5zdXJlIHBhdHRlcm4gc3RhcnRzIHdpdGggbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kgd2l0aCBwYXRobmFtZS5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gJy8nICsgcGF0dGVybjtcbiAgfVxuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlO1xuICB2YXIgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcztcbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnLz8nOyAvLyBBbGxvdyBvcHRpb25hbCBwYXRoIHNlcGFyYXRvciBhdCBlbmQuXG4gIH1cblxuICAvLyBTcGVjaWFsLWNhc2UgcGF0dGVybnMgbGlrZSAnKicgZm9yIGNhdGNoLWFsbCByb3V0ZXMuXG4gIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1hdGNoZWRQYXRoID0gbWF0Y2hbMF07XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcbiAgICAvLyB0aGUgZnVsbCBwYXRoLCBzbyBhbnkgcmVtYWluaW5nIHBhdGhuYW1lIGlzIGEgbmV3IHBhdGggc2VnbWVudC5cbiAgICBpZiAobWF0Y2hlZFBhdGguY2hhckF0KG1hdGNoZWRQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxuICAgIC8vIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgZm9yIHByb3Blcmx5IGNvbnRpbnVpbmcgdGhlIG1hdGNoLlxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJy8nICsgcmVtYWluaW5nUGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHBhcmFtVmFsdWVzOiBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbU5hbWVzKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXM7XG4gIHZhciBwYXJhbVZhbHVlcyA9IG1hdGNoLnBhcmFtVmFsdWVzO1xuXG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBwYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXR0ZXJuKHBhdHRlcm4sIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjMgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICB2YXIgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMy50b2tlbnM7XG5cbiAgdmFyIHBhcmVuQ291bnQgPSAwLFxuICAgICAgcGF0aG5hbWUgPSAnJyxcbiAgICAgIHNwbGF0SW5kZXggPSAwO1xuXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcbiAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMCxcbiAgICAgIHBhcmFtVmFsdWUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XG4gICAgICBwYXJhbVZhbHVlID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3BsYXQpID8gcGFyYW1zLnNwbGF0W3NwbGF0SW5kZXgrK10gOiBwYXJhbXMuc3BsYXQ7XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSShwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKScpIHtcbiAgICAgIHBhcmVuQ291bnQgLT0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5wdXNoLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUFVTSCA9ICdQVVNIJztcblxuZXhwb3J0cy5QVVNIID0gUFVTSDtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnJlcGxhY2UuXG4gKi9cbnZhciBSRVBMQUNFID0gJ1JFUExBQ0UnO1xuXG5leHBvcnRzLlJFUExBQ0UgPSBSRVBMQUNFO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgc29tZSBvdGhlciBhY3Rpb24gc3VjaFxuICogYXMgdXNpbmcgYSBicm93c2VyJ3MgYmFjay9mb3J3YXJkIGJ1dHRvbnMgYW5kL29yIG1hbnVhbGx5IG1hbmlwdWxhdGluZ1xuICogdGhlIFVSTCBpbiBhIGJyb3dzZXIncyBsb2NhdGlvbiBiYXIuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dFdmVudEhhbmRsZXJzL29ucG9wc3RhdGVcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG52YXIgUE9QID0gJ1BPUCc7XG5cbmV4cG9ydHMuUE9QID0gUE9QO1xuZXhwb3J0c1snZGVmYXVsdCddID0ge1xuICBQVVNIOiBQVVNILFxuICBSRVBMQUNFOiBSRVBMQUNFLFxuICBQT1A6IFBPUFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9BY3Rpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01MYXp5VHJlZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG4vKipcbiAqIEluIElFICg4LTExKSBhbmQgRWRnZSwgYXBwZW5kaW5nIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gaXMgZHJhbWF0aWNhbGx5XG4gKiBmYXN0ZXIgdGhhbiBhcHBlbmRpbmcgYSBmdWxsIHN1YnRyZWUsIHNvIHdlIGVzc2VudGlhbGx5IHF1ZXVlIHVwIHRoZVxuICogLmFwcGVuZENoaWxkIGNhbGxzIGhlcmUgYW5kIGFwcGx5IHRoZW0gc28gZWFjaCBub2RlIGlzIGFkZGVkIHRvIGl0cyBwYXJlbnRcbiAqIGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLlxuICpcbiAqIEluIG90aGVyIGJyb3dzZXJzLCBkb2luZyBzbyBpcyBzbG93ZXIgb3IgbmV1dHJhbCBjb21wYXJlZCB0byB0aGUgb3RoZXIgb3JkZXJcbiAqIChpbiBGaXJlZm94LCB0d2ljZSBhcyBzbG93KSBzbyB3ZSBvbmx5IGRvIHRoaXMgaW52ZXJzaW9uIGluIElFLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3BpY3lqL2lubmVyaHRtbC12cy1jcmVhdGVlbGVtZW50LXZzLWNsb25lbm9kZS5cbiAqL1xudmFyIGVuYWJsZUxhenkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiAvXFxiRWRnZVxcL1xcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuZnVuY3Rpb24gaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpIHtcbiAgaWYgKCFlbmFibGVMYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBub2RlID0gdHJlZS5ub2RlO1xuICB2YXIgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaW5zZXJ0VHJlZUJlZm9yZShub2RlLCBjaGlsZHJlbltpXSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRyZWUuaHRtbCAhPSBudWxsKSB7XG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIHRyZWUuaHRtbCk7XG4gIH0gZWxzZSBpZiAodHJlZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCB0cmVlLnRleHQpO1xuICB9XG59XG5cbnZhciBpbnNlcnRUcmVlQmVmb3JlID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgdHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmVuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgRE9NIGFmdGVyIGluc2VydGlvbiBzb1xuICAvLyBhcHBlbmRpbmcgY2hpbGRyZW4gd29uJ3QgdXBkYXRlIHRoZSBET00uIFdlIG5lZWQgdG8gZW5zdXJlIHRoZSBmcmFnbWVudFxuICAvLyBpcyBwcm9wZXJseSBwb3B1bGF0ZWQgZmlyc3QsIGJyZWFraW5nIG91dCBvZiBvdXIgbGF6eSBhcHByb2FjaCBmb3IganVzdFxuICAvLyB0aGlzIGxldmVsLiBBbHNvLCBzb21lIDxvYmplY3Q+IHBsdWdpbnMgKGxpa2UgRmxhc2ggUGxheWVyKSB3aWxsIHJlYWRcbiAgLy8gPHBhcmFtPiBub2RlcyBpbW1lZGlhdGVseSB1cG9uIGluc2VydGlvbiBpbnRvIHRoZSBET00sIHNvIDxvYmplY3Q+XG4gIC8vIG11c3QgYWxzbyBiZSBwb3B1bGF0ZWQgcHJpb3IgdG8gaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgaWYgKHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIHx8IHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgJiYgdHJlZS5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICYmICh0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09IG51bGwgfHwgdHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSkge1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkTm9kZSwgbmV3VHJlZSkge1xuICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1RyZWUubm9kZSwgb2xkTm9kZSk7XG4gIGluc2VydFRyZWVDaGlsZHJlbihuZXdUcmVlKTtcbn1cblxuZnVuY3Rpb24gcXVldWVDaGlsZChwYXJlbnRUcmVlLCBjaGlsZFRyZWUpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICBwYXJlbnRUcmVlLmNoaWxkcmVuLnB1c2goY2hpbGRUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmVlLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGRUcmVlLm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSFRNTCh0cmVlLCBodG1sKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS5odG1sID0gaHRtbDtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbm5lckhUTUwodHJlZS5ub2RlLCBodG1sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZVRleHQodHJlZSwgdGV4dCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUudGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGV4dENvbnRlbnQodHJlZS5ub2RlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubm9kZS5ub2RlTmFtZTtcbn1cblxuZnVuY3Rpb24gRE9NTGF6eVRyZWUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGh0bWw6IG51bGwsXG4gICAgdGV4dDogbnVsbCxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcbn1cblxuRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZSA9IGluc2VydFRyZWVCZWZvcmU7XG5ET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZSA9IHJlcGxhY2VDaGlsZFdpdGhUcmVlO1xuRE9NTGF6eVRyZWUucXVldWVDaGlsZCA9IHF1ZXVlQ2hpbGQ7XG5ET01MYXp5VHJlZS5xdWV1ZUhUTUwgPSBxdWV1ZUhUTUw7XG5ET01MYXp5VHJlZS5xdWV1ZVRleHQgPSBxdWV1ZVRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTGF6eVRyZWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTUxhenlUcmVlLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdGhlIGNvbnRhaW5pbmcgaG9zdCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgcGFyZW50RGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudCh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXG4gICAqIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwLlxuICAgKi9cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0SG9zdE5vZGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHNhZmVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoc2FmZWx5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBuZXh0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciAhPT0gdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQncyBlbnF1ZXVlZCBiYXRjaCBudW1iZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY3VycmVudFxuICAgICAgLy8gYmF0Y2ggb3IgdGhlIGZvbGxvd2luZyBvbmUuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IFVuZXhwZWN0ZWQgYmF0Y2ggbnVtYmVyIChjdXJyZW50ICVzLCAnICsgJ3BlbmRpbmcgJXMpJywgdXBkYXRlQmF0Y2hOdW1iZXIsIGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29ubmVjdCA9IGV4cG9ydHMuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUHJvdmlkZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUHJvdmlkZXInKTtcblxudmFyIF9Qcm92aWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm92aWRlcik7XG5cbnZhciBfY29ubmVjdCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb25uZWN0Jyk7XG5cbnZhciBfY29ubmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25uZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUHJvdmlkZXIgPSBfUHJvdmlkZXIyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29ubmVjdCA9IF9jb25uZWN0MltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpbkh1YlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzk1JykgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0gRXZlbnRDb25zdGFudHMuUHJvcGFnYXRpb25QaGFzZXM7XG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlTWFwXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJykgOiBfcHJvZEludmFyaWFudCgnMjcnKSA6IHZvaWQgMDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyOCcpIDogdm9pZCAwO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIFRyYW5zYWN0aW9uID0ge1xuXG4gIE1peGluOiBNaXhpbixcblxuICAvKipcbiAgICogVG9rZW4gdG8gbG9vayBmb3IgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBvc2UgPSBleHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGV4cG9ydHMuYmluZEFjdGlvbkNyZWF0b3JzID0gZXhwb3J0cy5jb21iaW5lUmVkdWNlcnMgPSBleHBvcnRzLmNyZWF0ZVN0b3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZVN0b3JlID0gcmVxdWlyZSgnLi9jcmVhdGVTdG9yZScpO1xuXG52YXIgX2NyZWF0ZVN0b3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVN0b3JlKTtcblxudmFyIF9jb21iaW5lUmVkdWNlcnMgPSByZXF1aXJlKCcuL2NvbWJpbmVSZWR1Y2VycycpO1xuXG52YXIgX2NvbWJpbmVSZWR1Y2VyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21iaW5lUmVkdWNlcnMpO1xuXG52YXIgX2JpbmRBY3Rpb25DcmVhdG9ycyA9IHJlcXVpcmUoJy4vYmluZEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfYmluZEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpbmRBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfYXBwbHlNaWRkbGV3YXJlID0gcmVxdWlyZSgnLi9hcHBseU1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseU1pZGRsZXdhcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlNaWRkbGV3YXJlKTtcblxudmFyIF9jb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJyk7XG5cbnZhciBfY29tcG9zZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wb3NlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gICgwLCBfd2FybmluZzJbXCJkZWZhdWx0XCJdKSgnWW91IGFyZSBjdXJyZW50bHkgdXNpbmcgbWluaWZpZWQgY29kZSBvdXRzaWRlIG9mIE5PREVfRU5WID09PSBcXCdwcm9kdWN0aW9uXFwnLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3IgRGVmaW5lUGx1Z2luIGZvciB3ZWJwYWNrIChodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMwMDMwMDMxKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydHMuY3JlYXRlU3RvcmUgPSBfY3JlYXRlU3RvcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tYmluZVJlZHVjZXJzID0gX2NvbWJpbmVSZWR1Y2VyczJbXCJkZWZhdWx0XCJdO1xuZXhwb3J0cy5iaW5kQWN0aW9uQ3JlYXRvcnMgPSBfYmluZEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl07XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IF9hcHBseU1pZGRsZXdhcmUyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29tcG9zZSA9IF9jb21wb3NlMltcImRlZmF1bHRcIl07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtcyA9IHJlcXVpcmUoJy4vZ2V0Um91dGVQYXJhbXMnKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSb3V0ZVBhcmFtcyk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgYXJyYXkgPSBfUmVhY3QkUHJvcFR5cGVzLmFycmF5O1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyQ29udGV4dD4gcmVuZGVycyB0aGUgY29tcG9uZW50IHRyZWUgZm9yIGEgZ2l2ZW4gcm91dGVyIHN0YXRlXG4gKiBhbmQgc2V0cyB0aGUgaGlzdG9yeSBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlckNvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlckNvbnRleHQnLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlczogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBwYXJhbXM6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGNvbXBvbmVudHM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50XG4gICAgfTtcbiAgfSxcblxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGxvY2F0aW9uOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJvdXRlciA9IF9wcm9wcy5yb3V0ZXI7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb247XG5cbiAgICBpZiAoIXJvdXRlcikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgPFJvdXRlckNvbnRleHQ+YCBleHBlY3RzIGEgYHJvdXRlcmAgcmF0aGVyIHRoYW4gYSBgaGlzdG9yeWAnKSA6IHZvaWQgMDtcblxuICAgICAgcm91dGVyID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgICAgc2V0Um91dGVMZWF2ZUhvb2s6IGhpc3RvcnkubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSByb3V0ZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBsb2NhdGlvbiA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkobG9jYXRpb24sICdgY29udGV4dC5sb2NhdGlvbmAgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhIHJvdXRlIGNvbXBvbmVudFxcJ3MgYHByb3BzLmxvY2F0aW9uYCBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItYWNjZXNzaW5nbG9jYXRpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiBoaXN0b3J5LCBsb2NhdGlvbjogbG9jYXRpb24sIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBjb21wb25lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLnByb3BzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMyLmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gX3Byb3BzMi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGVzID0gX3Byb3BzMi5yb3V0ZXM7XG4gICAgdmFyIHBhcmFtcyA9IF9wcm9wczIucGFyYW1zO1xuICAgIHZhciBjb21wb25lbnRzID0gX3Byb3BzMi5jb21wb25lbnRzO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgIGVsZW1lbnQgPSBjb21wb25lbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChlbGVtZW50LCBjb21wb25lbnRzLCBpbmRleCkge1xuICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSByZXR1cm4gZWxlbWVudDsgLy8gRG9uJ3QgY3JlYXRlIG5ldyBjaGlsZHJlbjsgdXNlIHRoZSBncmFuZGNoaWxkcmVuLlxuXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpbmRleF07XG4gICAgICAgIHZhciByb3V0ZVBhcmFtcyA9ICgwLCBfZ2V0Um91dGVQYXJhbXMyLmRlZmF1bHQpKHJvdXRlLCBwYXJhbXMpO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICAgIHJvdXRlUGFyYW1zOiByb3V0ZVBhcmFtcyxcbiAgICAgICAgICByb3V0ZXM6IHJvdXRlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgoMCwgX1JvdXRlVXRpbHMuaXNSZWFjdENoaWxkcmVuKShlbGVtZW50KSkge1xuICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnQsIHByb3ApKSBwcm9wc1twcm9wXSA9IGVsZW1lbnRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgY29tcG9uZW50cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29tcG9uZW50cykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29tcG9uZW50cywga2V5KSkge1xuICAgICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggdGhlIGtleSBhcyBhIHByb3AgdG8gY3JlYXRlRWxlbWVudCB0byBhbGxvd1xuICAgICAgICAgICAgICAvLyBjdXN0b20gY3JlYXRlRWxlbWVudCBmdW5jdGlvbnMgdG8ga25vdyB3aGljaCBuYW1lZCBjb21wb25lbnRcbiAgICAgICAgICAgICAgLy8gdGhleSdyZSByZW5kZXJpbmcsIGZvciBlLmcuIG1hdGNoaW5nIHVwIHRvIGZldGNoZWQgZGF0YS5cbiAgICAgICAgICAgICAgZWxlbWVudHNba2V5XSA9IF90aGlzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c1trZXldLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgfSwgcHJvcHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzLCBwcm9wcyk7XG4gICAgICB9LCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICAhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgcm9vdCByb3V0ZSBtdXN0IHJlbmRlciBhIHNpbmdsZSBlbGVtZW50JykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXJDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjYW5Vc2VNZW1icmFuZSA9IGV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSBmYWxzZTtcblxuLy8gTm8tb3AgYnkgZGVmYXVsdC5cbnZhciBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkueCkge1xuICAgICAgZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IGNhblVzZU1lbWJyYW5lID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG4gIGlmIChjYW5Vc2VNZW1icmFuZSkge1xuICAgIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKG9iamVjdCwgbWVzc2FnZSkge1xuICAgICAgLy8gV3JhcCB0aGUgZGVwcmVjYXRlZCBvYmplY3QgaW4gYSBtZW1icmFuZSB0byB3YXJuIG9uIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgIHZhciBtZW1icmFuZSA9IHt9O1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gQ2FuJ3QgdXNlIGZhdCBhcnJvdyBoZXJlIGJlY2F1c2Ugb2YgdXNlIG9mIGFyZ3VtZW50cyBiZWxvdy5cbiAgICAgICAgICBtZW1icmFuZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF0uYXBwbHkob2JqZWN0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub24tZW51bWVyYWJsZSB0byBwcmV2ZW50IFJlYWN0IGRldiB0b29scyBmcm9tXG4gICAgICAgIC8vIHNlZWluZyB0aGVtIGFuZCBjYXVzaW5nIHNwdXJpb3VzIHdhcm5pbmdzIHdoZW4gYWNjZXNzaW5nIHRoZW0uIEluXG4gICAgICAgIC8vIHByaW5jaXBsZSB0aGlzIGNvdWxkIGJlIGRvbmUgd2l0aCBhIHByb3h5LCBidXQgc3VwcG9ydCBmb3IgdGhlXG4gICAgICAgIC8vIG93bktleXMgdHJhcCBvbiBwcm94aWVzIGlzIG5vdCB1bml2ZXJzYWwsIGV2ZW4gYW1vbmcgYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBvdGhlcndpc2Ugc3VwcG9ydCBwcm94aWVzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVtYnJhbmUsIHByb3AsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09ICdjb250aW51ZScpIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVtYnJhbmU7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmV4cG9ydHMuY2FuVXNlRE9NID0gY2FuVXNlRE9NO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9xdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5LXN0cmluZycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbnZhciBTRUFSQ0hfQkFTRV9LRVkgPSAnJHNlYXJjaEJhc2UnO1xuXG5mdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuIF9xdWVyeVN0cmluZy5zdHJpbmdpZnkocXVlcnkpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuXG52YXIgZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcucGFyc2U7XG5cbmZ1bmN0aW9uIGlzTmVzdGVkT2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSAmJiB0eXBlb2Ygb2JqZWN0W3BdID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmplY3RbcF0pICYmIG9iamVjdFtwXSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byBoYW5kbGUgVVJMIHF1ZXJpZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXJpZXMoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBvcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gb3B0aW9ucy5wYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpbmdpZnlRdWVyeSAhPT0gJ2Z1bmN0aW9uJykgc3RyaW5naWZ5UXVlcnkgPSBkZWZhdWx0U3RyaW5naWZ5UXVlcnk7XG5cbiAgICBpZiAodHlwZW9mIHBhcnNlUXVlcnlTdHJpbmcgIT09ICdmdW5jdGlvbicpIHBhcnNlUXVlcnlTdHJpbmcgPSBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZztcblxuICAgIGZ1bmN0aW9uIGFkZFF1ZXJ5KGxvY2F0aW9uKSB7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkgPT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuXG4gICAgICAgIGxvY2F0aW9uLnF1ZXJ5ID0gcGFyc2VRdWVyeVN0cmluZyhzZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6ICcnIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgYWxsIHRoZSBib29rLWtlZXBpbmcgaGVyZSwgdGhpcyBzaG91bGQganVzdCBzdHJpcCB0aGVcbiAgICAgIC8vIHN0cmluZ2lmaWVkIHF1ZXJ5IGZyb20gdGhlIHNlYXJjaC5cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIHNlYXJjaEJhc2VTcGVjID0gbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXTtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5ID8gc3RyaW5naWZ5UXVlcnkocXVlcnkpIDogJyc7XG4gICAgICBpZiAoIXNlYXJjaEJhc2VTcGVjICYmICFxdWVyeVN0cmluZykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShzdHJpbmdpZnlRdWVyeSAhPT0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5IHx8ICFpc05lc3RlZE9iamVjdChxdWVyeSksICd1c2VRdWVyaWVzIGRvZXMgbm90IHN0cmluZ2lmeSBuZXN0ZWQgcXVlcnkgb2JqZWN0cyBieSBkZWZhdWx0OyAnICsgJ3VzZSBhIGN1c3RvbSBzdHJpbmdpZnlRdWVyeSBmdW5jdGlvbicpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBzZWFyY2hCYXNlID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlYXJjaEJhc2VTcGVjICYmIGxvY2F0aW9uLnNlYXJjaCA9PT0gc2VhcmNoQmFzZVNwZWMuc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaEJhc2UgPSBzZWFyY2hCYXNlU3BlYy5zZWFyY2hCYXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoQmFzZSA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlYXJjaCA9IHNlYXJjaEJhc2U7XG4gICAgICBpZiAocXVlcnlTdHJpbmcpIHtcbiAgICAgICAgc2VhcmNoICs9IChzZWFyY2ggPyAnJicgOiAnPycpICsgcXVlcnlTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIChfZXh0ZW5kczIgPSB7XG4gICAgICAgIHNlYXJjaDogc2VhcmNoXG4gICAgICB9LCBfZXh0ZW5kczJbU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6IHNlYXJjaEJhc2UgfSwgX2V4dGVuZHMyKSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10oaG9vaywgYWRkUXVlcnkobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIoYWRkUXVlcnkobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5wdXNoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZShhcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKCFxdWVyeSwgJ3RoZSBxdWVyeSBhcmd1bWVudCB0byBjcmVhdGVQYXRoIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oIXF1ZXJ5LCAndGhlIHF1ZXJ5IGFyZ3VtZW50IHRvIGNyZWF0ZUhyZWYgaXMgZGVwcmVjYXRlZDsgdXNlIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bGxMb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW2FwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSldLmNvbmNhdChhcmdzKSk7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkpIHtcbiAgICAgICAgZnVsbExvY2F0aW9uLnF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkUXVlcnkoZnVsbExvY2F0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHVzZVF1ZXJpZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEaXNhYmxlZElucHV0VXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lcyA9IHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG5cbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgaG9zdCBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgcHJvcHMsIGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzXG4gICAgdmFyIGhvc3RQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFkaXNhYmxlYWJsZU1vdXNlTGlzdGVuZXJOYW1lc1trZXldICYmIHByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaG9zdFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzYWJsZWRJbnB1dFV0aWxzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EaXNhYmxlZElucHV0VXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk3JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk5JywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFFdmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgIGZvciAodmFyIGxvd2VyQ2FzZWROYW1lIGluIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50RW1pdHRlck1peGluJyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lID0gcmVxdWlyZSgnLi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZScpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBoYXNFdmVudFBhZ2VYWTtcbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gX2Fzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiAncGFnZVgnIGluIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgfVxuICAgIGlmICghaGFzRXZlbnRQYWdlWFkgJiYgIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcblxudmFyIFdISVRFU1BBQ0VfVEVTVCA9IC9eWyBcXHJcXG5cXHRcXGZdLztcbnZhciBOT05WSVNJQkxFX1RFU1QgPSAvPCghLS18bGlua3xub3NjcmlwdHxtZXRhfHNjcmlwdHxzdHlsZSlbIFxcclxcblxcdFxcZlxcLz5dLztcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIG5ld05vZGVzID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZC5jaGlsZE5vZGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0ZXN0RWxlbWVudCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbiBrZXlNaXJyb3Iob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgIShvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2tleU1pcnJvci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9vcEFzeW5jID0gbG9vcEFzeW5jO1xuZXhwb3J0cy5tYXBBc3luYyA9IG1hcEFzeW5jO1xuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZnVuY3Rpb24gbWFwQXN5bmMoYXJyYXksIHdvcmssIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciB2YWx1ZXMgPSBbXTtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcblxuICB2YXIgaXNEb25lID0gZmFsc2UsXG4gICAgICBkb25lQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSkge1xuICAgIGlmIChpc0RvbmUpIHJldHVybjtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaXNEb25lID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICBpc0RvbmUgPSArK2RvbmVDb3VudCA9PT0gbGVuZ3RoO1xuXG4gICAgICBpZiAoaXNEb25lKSBjYWxsYmFjayhudWxsLCB2YWx1ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgd29yayhpdGVtLCBpbmRleCwgZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgZG9uZShpbmRleCwgZXJyb3IsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucm91dGVyID0gZXhwb3J0cy5yb3V0ZXMgPSBleHBvcnRzLnJvdXRlID0gZXhwb3J0cy5jb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnQgPSBleHBvcnRzLmxvY2F0aW9uID0gZXhwb3J0cy5oaXN0b3J5ID0gZXhwb3J0cy5mYWxzeSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG52YXIgSW50ZXJuYWxQcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfSW50ZXJuYWxQcm9wVHlwZXMpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVuYyA9IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfcmVhY3QuUHJvcFR5cGVzLm9iamVjdDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG52YXIgcm91dGVyU2hhcGUgPSBleHBvcnRzLnJvdXRlclNoYXBlID0gc2hhcGUoe1xuICBwdXNoOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHJlcGxhY2U6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ286IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29CYWNrOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvRm9yd2FyZDogZnVuYy5pc1JlcXVpcmVkLFxuICBzZXRSb3V0ZUxlYXZlSG9vazogZnVuYy5pc1JlcXVpcmVkLFxuICBpc0FjdGl2ZTogZnVuYy5pc1JlcXVpcmVkXG59KTtcblxudmFyIGxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBzaGFwZSh7XG4gIHBhdGhuYW1lOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgc2VhcmNoOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgc3RhdGU6IG9iamVjdCxcbiAgYWN0aW9uOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAga2V5OiBzdHJpbmdcbn0pO1xuXG4vLyBEZXByZWNhdGVkIHN0dWZmIGJlbG93OlxuXG52YXIgZmFsc3kgPSBleHBvcnRzLmZhbHN5ID0gSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3k7XG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IEludGVybmFsUHJvcFR5cGVzLmhpc3Rvcnk7XG52YXIgbG9jYXRpb24gPSBleHBvcnRzLmxvY2F0aW9uID0gbG9jYXRpb25TaGFwZTtcbnZhciBjb21wb25lbnQgPSBleHBvcnRzLmNvbXBvbmVudCA9IEludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudDtcbnZhciBjb21wb25lbnRzID0gZXhwb3J0cy5jb21wb25lbnRzID0gSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cztcbnZhciByb3V0ZSA9IGV4cG9ydHMucm91dGUgPSBJbnRlcm5hbFByb3BUeXBlcy5yb3V0ZTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IEludGVybmFsUHJvcFR5cGVzLnJvdXRlcztcbnZhciByb3V0ZXIgPSBleHBvcnRzLnJvdXRlciA9IHJvdXRlclNoYXBlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZXByZWNhdGVQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBwcm9wVHlwZS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocHJvcFR5cGUpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGVQcm9wVHlwZShwcm9wVHlwZSwgJ1RoaXMgcHJvcCB0eXBlIGlzIG5vdCBpbnRlbmRlZCBmb3IgZXh0ZXJuYWwgdXNlLCBhbmQgd2FzIHByZXZpb3VzbHkgZXhwb3J0ZWQgYnkgbWlzdGFrZS4gVGhlc2UgaW50ZXJuYWwgcHJvcCB0eXBlcyBhcmUgZGVwcmVjYXRlZCBmb3IgZXh0ZXJuYWwgdXNlLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbi4nKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZSA9IGZ1bmN0aW9uIGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShwcm9wVHlwZSwgbmFtZSkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCAnVGhlIGAnICsgbmFtZSArICdgIHByb3AgdHlwZSBpcyBub3cgZXhwb3J0ZWQgYXMgYCcgKyBuYW1lICsgJ1NoYXBlYCB0byBhdm9pZCBuYW1lIGNvbmZsaWN0cy4gVGhpcyBleHBvcnQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgbGF0ZXIgdmVyc2lvbi4nKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5mYWxzeSA9IGZhbHN5ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShmYWxzeSk7XG4gICAgZXhwb3J0cy5oaXN0b3J5ID0gaGlzdG9yeSA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoaGlzdG9yeSk7XG4gICAgZXhwb3J0cy5jb21wb25lbnQgPSBjb21wb25lbnQgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGNvbXBvbmVudCk7XG4gICAgZXhwb3J0cy5jb21wb25lbnRzID0gY29tcG9uZW50cyA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoY29tcG9uZW50cyk7XG4gICAgZXhwb3J0cy5yb3V0ZSA9IHJvdXRlID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShyb3V0ZSk7XG4gICAgZXhwb3J0cy5yb3V0ZXMgPSByb3V0ZXMgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHJvdXRlcyk7XG5cbiAgICBleHBvcnRzLmxvY2F0aW9uID0gbG9jYXRpb24gPSBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUobG9jYXRpb24sICdsb2NhdGlvbicpO1xuICAgIGV4cG9ydHMucm91dGVyID0gcm91dGVyID0gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKHJvdXRlciwgJ3JvdXRlcicpO1xuICB9KSgpO1xufVxuXG52YXIgZGVmYXVsdEV4cG9ydCA9IHtcbiAgZmFsc3k6IGZhbHN5LFxuICBoaXN0b3J5OiBoaXN0b3J5LFxuICBsb2NhdGlvbjogbG9jYXRpb24sXG4gIGNvbXBvbmVudDogY29tcG9uZW50LFxuICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICByb3V0ZTogcm91dGUsXG4gIC8vIEZvciBzb21lIHJlYXNvbiwgcm91dGVzIHdhcyBuZXZlciBoZXJlLlxuICByb3V0ZXI6IHJvdXRlclxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVmYXVsdEV4cG9ydCA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkoZGVmYXVsdEV4cG9ydCwgJ1RoZSBkZWZhdWx0IGV4cG9ydCBmcm9tIGByZWFjdC1yb3V0ZXIvbGliL1Byb3BUeXBlc2AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgbmFtZWQgZXhwb3J0cyBpbnN0ZWFkLicpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0RXhwb3J0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL0FjdGlvbnMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczIgPSByZXF1aXJlKCcuL2NvbXB1dGVDaGFuZ2VkUm91dGVzJyk7XG5cbnZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyKTtcblxudmFyIF9UcmFuc2l0aW9uVXRpbHMgPSByZXF1aXJlKCcuL1RyYW5zaXRpb25VdGlscycpO1xuXG52YXIgX2lzQWN0aXZlMiA9IHJlcXVpcmUoJy4vaXNBY3RpdmUnKTtcblxudmFyIF9pc0FjdGl2ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FjdGl2ZTIpO1xuXG52YXIgX2dldENvbXBvbmVudHMgPSByZXF1aXJlKCcuL2dldENvbXBvbmVudHMnKTtcblxudmFyIF9nZXRDb21wb25lbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldENvbXBvbmVudHMpO1xuXG52YXIgX21hdGNoUm91dGVzID0gcmVxdWlyZSgnLi9tYXRjaFJvdXRlcycpO1xuXG52YXIgX21hdGNoUm91dGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoUm91dGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaGFzQW55UHJvcGVydGllcyhvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihoaXN0b3J5LCByb3V0ZXMpIHtcbiAgdmFyIHN0YXRlID0ge307XG5cbiAgLy8gU2lnbmF0dXJlIHNob3VsZCBiZSAobG9jYXRpb24sIGluZGV4T25seSksIGJ1dCBuZWVkcyB0byBzdXBwb3J0IChwYXRoLFxuICAvLyBxdWVyeSwgaW5kZXhPbmx5KVxuICBmdW5jdGlvbiBpc0FjdGl2ZShsb2NhdGlvbikge1xuICAgIHZhciBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZXByZWNhdGVkSW5kZXhPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICAgIHZhciBpbmRleE9ubHkgPSB2b2lkIDA7XG4gICAgaWYgKGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICYmIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ICE9PSB0cnVlIHx8IGRlcHJlY2F0ZWRJbmRleE9ubHkgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5KSBpcyBkZXByZWNhdGVkOyB1c2UgYGlzQWN0aXZlKGxvY2F0aW9uLCBpbmRleE9ubHkpYCB3aXRoIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG4gICAgICBsb2NhdGlvbiA9IHsgcGF0aG5hbWU6IGxvY2F0aW9uLCBxdWVyeTogaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgfTtcbiAgICAgIGluZGV4T25seSA9IGRlcHJlY2F0ZWRJbmRleE9ubHkgfHwgZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICBpbmRleE9ubHkgPSBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9pc0FjdGl2ZTMuZGVmYXVsdCkobG9jYXRpb24sIGluZGV4T25seSwgc3RhdGUubG9jYXRpb24sIHN0YXRlLnJvdXRlcywgc3RhdGUucGFyYW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uRnJvbVJlZGlyZWN0SW5mbyhsb2NhdGlvbikge1xuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFKTtcbiAgfVxuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0gdm9pZCAwO1xuXG4gIGZ1bmN0aW9uIG1hdGNoKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIGlmIChwYXJ0aWFsTmV4dFN0YXRlICYmIHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAvLyBDb250aW51ZSBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmLlxuICAgICAgZmluaXNoTWF0Y2gocGFydGlhbE5leHRTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgZmluaXNoTWF0Y2goX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hNYXRjaChuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlcyA9ICgwLCBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzLmRlZmF1bHQpKHN0YXRlLCBuZXh0U3RhdGUpO1xuXG4gICAgdmFyIGxlYXZlUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmxlYXZlUm91dGVzO1xuICAgIHZhciBjaGFuZ2VSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMuY2hhbmdlUm91dGVzO1xuICAgIHZhciBlbnRlclJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5lbnRlclJvdXRlcztcblxuXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuTGVhdmVIb29rcykobGVhdmVSb3V0ZXMsIHN0YXRlKTtcblxuICAgIC8vIFRlYXIgZG93biBjb25maXJtYXRpb24gaG9va3MgZm9yIGxlZnQgcm91dGVzXG4gICAgbGVhdmVSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmV0dXJuIGVudGVyUm91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICB9KS5mb3JFYWNoKHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUpO1xuXG4gICAgLy8gY2hhbmdlIGFuZCBlbnRlciBob29rcyBhcmUgcnVuIGluIHNlcmllc1xuICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkNoYW5nZUhvb2tzKShjaGFuZ2VSb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5FbnRlckhvb2tzKShlbnRlclJvdXRlcywgbmV4dFN0YXRlLCBmaW5pc2hFbnRlckhvb2tzKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpbmlzaEVudGVySG9va3MoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykgcmV0dXJuIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKTtcblxuICAgICAgLy8gVE9ETzogRmV0Y2ggY29tcG9uZW50cyBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAgKDAsIF9nZXRDb21wb25lbnRzMi5kZWZhdWx0KShuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogTWFrZSBtYXRjaCBhIHB1cmUgZnVuY3Rpb24gYW5kIGhhdmUgc29tZSBvdGhlciBBUElcbiAgICAgICAgICAvLyBmb3IgXCJtYXRjaCBhbmQgdXBkYXRlIHN0YXRlXCIuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCwgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yKSBjYWxsYmFjayhlcnJvcik7ZWxzZSBjYWxsYmFjayhudWxsLCBjcmVhdGVMb2NhdGlvbkZyb21SZWRpcmVjdEluZm8ocmVkaXJlY3RJbmZvKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFJvdXRlR3VpZCA9IDE7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xuICAgIHZhciBjcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcbiAgfVxuXG4gIHZhciBSb3V0ZUhvb2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHJvdXRlcykge1xuICAgIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICAgIGhvb2tzLnB1c2guYXBwbHkoaG9va3MsIFJvdXRlSG9va3NbZ2V0Um91dGVJRChyb3V0ZSldKTtcbiAgICAgIHJldHVybiBob29rcztcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vayhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIGRpZG4ndCBhY3R1YWxseSBtYXRjaCBhbnl0aGluZywgYnV0IGhhbmdcbiAgICAgICAgLy8gb250byBlcnJvci9uZXh0U3RhdGUgc28gd2UgZG9uJ3QgaGF2ZSB0byBtYXRjaFJvdXRlc1xuICAgICAgICAvLyBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHNvbWUgc3RhdGUgaGVyZSBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBtYXRjaFJvdXRlcygpIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICBwYXJ0aWFsTmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG5cbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSBsb2NhdGlvbiBhcmcgaGVyZSBpbmRpY2F0ZXMgdG9cbiAgICAgICAgLy8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiBob29rLlxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gIGZ1bmN0aW9uIGJlZm9yZVVubG9hZEhvb2soKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcbiAgICAvLyB0byBwcmV2ZW50IHRoZSBjdXJyZW50IHdpbmRvdy90YWIgZnJvbSBjbG9zaW5nLlxuICAgIGlmIChzdGF0ZS5yb3V0ZXMpIHtcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3Npbmcgbm8gYXJncyBpbmRpY2F0ZXMgdG8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGFcbiAgICAgICAgLy8gYmVmb3JldW5sb2FkIGhvb2suIFdlIGRvbid0IGtub3cgdGhlIG5leHQgbG9jYXRpb24uXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5saXN0ZW5CZWZvcmUgPSB2b2lkIDAsXG4gICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlLCBmYWxzZSk7XG4gICAgaWYgKCFyb3V0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcykpIHtcbiAgICAgIC8vIHRlYXJkb3duIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZVVubG9hZCkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaG9vayBmdW5jdGlvbiB0byBydW4gYmVmb3JlIGxlYXZpbmcgdGhlIGdpdmVuIHJvdXRlLlxuICAgKlxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cbiAgICogYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIGNhbiByZXR1cm4gZWl0aGVyIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykgdG8gc2hvdyB0aGUgdXNlcixcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgd2FudCB0byBsZWF2ZSB0aGUgcGFnZTsgb3IgYGZhbHNlYCwgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICogQW55IG90aGVyIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoaW4gYnJvd3NlcnMpIHRoZSBob29rIHJlY2VpdmVzIG5vIGFyZ3VtZW50cy5cbiAgICogSW4gdGhpcyBjYXNlIGl0IG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gdW5iaW5kIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgaG9vaykge1xuICAgIC8vIFRPRE86IFdhcm4gaWYgdGhleSByZWdpc3RlciBmb3IgYSByb3V0ZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGFjdGl2ZS4gVGhleSdyZSBwcm9iYWJseSBkb2luZyBzb21ldGhpbmcgd3JvbmcsIGxpa2UgcmUtY3JlYXRpbmdcbiAgICAvLyByb3V0ZSBvYmplY3RzIG9uIGV2ZXJ5IGxvY2F0aW9uIGNoYW5nZS5cbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUpO1xuICAgIHZhciBob29rcyA9IFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhvb2tzKSB7XG4gICAgICB2YXIgdGhlcmVXZXJlTm9Sb3V0ZUhvb2tzID0gIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcyk7XG5cbiAgICAgIFJvdXRlSG9va3Nbcm91dGVJRF0gPSBbaG9va107XG5cbiAgICAgIGlmICh0aGVyZVdlcmVOb1JvdXRlSG9va3MpIHtcbiAgICAgICAgLy8gc2V0dXAgdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKHRyYW5zaXRpb25Ib29rKTtcblxuICAgICAgICBpZiAoaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQpIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQoYmVmb3JlVW5sb2FkSG9vayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChob29rcy5pbmRleE9mKGhvb2spID09PSAtMSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2FkZGluZyBtdWx0aXBsZSBsZWF2ZSBob29rcyBmb3IgdGhlIHNhbWUgcm91dGUgaXMgZGVwcmVjYXRlZDsgbWFuYWdlIG11bHRpcGxlIGNvbmZpcm1hdGlvbnMgaW4geW91ciBvd24gY29kZSBpbnN0ZWFkJykgOiB2b2lkIDA7XG5cbiAgICAgICAgaG9va3MucHVzaChob29rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIHZhciBuZXdIb29rcyA9IGhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmV3SG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IG5ld0hvb2tzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBBUEkgZm9yIHN0YXRlZnVsIGVudmlyb25tZW50cy4gQXMgdGhlIGxvY2F0aW9uXG4gICAqIGNoYW5nZXMsIHdlIHVwZGF0ZSBzdGF0ZSBhbmQgY2FsbCB0aGUgbGlzdGVuZXIuIFdlIGNhbiBhbHNvXG4gICAqIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9ycyBhbmQgcmVkaXJlY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgLy8gVE9ETzogT25seSB1c2UgYSBzaW5nbGUgaGlzdG9yeSBsaXN0ZW5lci4gT3RoZXJ3aXNlIHdlJ2xsXG4gICAgLy8gZW5kIHVwIHdpdGggbXVsdGlwbGUgY29uY3VycmVudCBjYWxscyB0byBtYXRjaC5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoc3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKG51bGwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaGlzdG9yeS50cmFuc2l0aW9uVG8ocmVkaXJlY3RMb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG51bGwsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnTG9jYXRpb24gXCIlc1wiIGRpZCBub3QgbWF0Y2ggYW55IHJvdXRlcycsIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCkgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaXNBY3RpdmU6IGlzQWN0aXZlLFxuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU6IGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xufVxuXG4vL2V4cG9ydCBkZWZhdWx0IHVzZVJvdXRlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5nZXRIYXNoUGF0aCA9IGdldEhhc2hQYXRoO1xuZXhwb3J0cy5yZXBsYWNlSGFzaFBhdGggPSByZXBsYWNlSGFzaFBhdGg7XG5leHBvcnRzLmdldFdpbmRvd1BhdGggPSBnZXRXaW5kb3dQYXRoO1xuZXhwb3J0cy5nbyA9IGdvO1xuZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZ2V0VXNlckNvbmZpcm1hdGlvbjtcbmV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5O1xuZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoO1xuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzFdIHx8ICcnO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1BhdGgoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2g7XG59XG5cbmZ1bmN0aW9uIGdvKG4pIHtcbiAgaWYgKG4pIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JhY2t0L3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufVxuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgcmV0dXJuIHVhLmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gJyArIG1lc3NhZ2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBkZXByZWNhdGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uSG9vayhob29rLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJlc3VsdCA9IGhvb2sobG9jYXRpb24sIGNhbGxiYWNrKTtcblxuICBpZiAoaG9vay5sZW5ndGggPCAyKSB7XG4gICAgLy8gQXNzdW1lIHRoZSBob29rIHJ1bnMgc3luY2hyb25vdXNseSBhbmQgYXV0b21hdGljYWxseVxuICAgIC8vIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHJldHVybiB2YWx1ZS5cbiAgICBjYWxsYmFjayhyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShyZXN1bHQgPT09IHVuZGVmaW5lZCwgJ1lvdSBzaG91bGQgbm90IFwicmV0dXJuXCIgaW4gYSB0cmFuc2l0aW9uIGhvb2sgd2l0aCBhIGNhbGxiYWNrIGFyZ3VtZW50OyBjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gcnVuVHJhbnNpdGlvbkhvb2s7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NQ2hpbGRyZW5PcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbmZ1bmN0aW9uIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCBub2RlKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGV4dCBjb21wb25lbnRzLCB3aGljaCByZXR1cm4gW29wZW4sIGNsb3NlXSBjb21tZW50c1xuICAvLyBmcm9tIGdldEhvc3ROb2RlLlxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlWzFdO1xuICB9XG4gIHJldHVybiBub2RlID8gbm9kZS5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbnZhciBpbnNlcnRDaGlsZEF0ID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIFdlIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIChVc2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGwgYnJvd3NlcnMgc29cbiAgLy8gd2UgYXJlIGNhcmVmdWwgdG8gdXNlIGBudWxsYC4pXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59KTtcblxuZnVuY3Rpb24gaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZVswXSwgY2hpbGROb2RlWzFdLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBjaGlsZE5vZGVbMV07XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlWzBdO1xuICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBjbG9zaW5nQ29tbWVudCk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9zaW5nQ29tbWVudCk7XG4gIH1cbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbm9kZSA9IG5leHROb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgc3RhcnROb2RlLCBjbG9zaW5nQ29tbWVudCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgLy8gVGhlIGNsb3NpbmcgY29tbWVudCBpcyByZW1vdmVkIGJ5IFJlYWN0TXVsdGlDaGlsZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlRGVsaW1pdGVkVGV4dChvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHN0cmluZ1RleHQpIHtcbiAgdmFyIHBhcmVudE5vZGUgPSBvcGVuaW5nQ29tbWVudC5wYXJlbnROb2RlO1xuICB2YXIgbm9kZUFmdGVyQ29tbWVudCA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICBpZiAobm9kZUFmdGVyQ29tbWVudCA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gdGV4dCBub2RlcyBiZXR3ZWVuIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGNvbW1lbnRzOyBpbnNlcnRcbiAgICAvLyBhIG5ldyBvbmUgaWYgc3RyaW5nVGV4dCBpc24ndCBlbXB0eS5cbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdUZXh0KSwgbm9kZUFmdGVyQ29tbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgb3BlbmluZyBjb21tZW50LCBhbmRcbiAgICAgIC8vIHJlbW92ZSBhbGwgZm9sbG93aW5nIG5vZGVzIHVwIHVudGlsIHRoZSBjbG9zaW5nIGNvbW1lbnQuXG4gICAgICBzZXRUZXh0Q29udGVudChub2RlQWZ0ZXJDb21tZW50LCBzdHJpbmdUZXh0KTtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgbm9kZUFmdGVyQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCwgJ3JlcGxhY2UgdGV4dCcsIHN0cmluZ1RleHQpO1xuICB9XG59XG5cbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcbiAgICBpZiAocHJldkluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHByZXZJbnN0YW5jZS5fZGVidWdJRCwgJ3JlcGxhY2Ugd2l0aCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihuZXh0SW5zdGFuY2UuX2RlYnVnSUQsICdtb3VudCcsIG1hcmt1cC50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHJlcGxhY2VEZWxpbWl0ZWRUZXh0OiByZXBsYWNlRGVsaW1pdGVkVGV4dCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB1cGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlRGVidWdJRCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHBhcmVudE5vZGUpLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNba107XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUDpcbiAgICAgICAgICBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdpbnNlcnQgY2hpbGQnLCB7IHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4LCBjb250ZW50OiB1cGRhdGUuY29udGVudC50b1N0cmluZygpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdtb3ZlIGNoaWxkJywgeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXgsIHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIGNoaWxkcmVuJywgdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24ocGFyZW50Tm9kZURlYnVnSUQsICdyZXBsYWNlIHRleHQnLCB1cGRhdGUuY29udGVudC50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihwYXJlbnROb2RlRGVidWdJRCwgJ3JlbW92ZSBjaGlsZCcsIHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NTmFtZXNwYWNlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9ET01OYW1lc3BhY2VzLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgQ29tcG9uZW50VHJlZWA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBpbnN0YW5jZXNcbiAqICAgYW5kIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBDb21wb25lbnRUcmVlO1xudmFyIFRyZWVUcmF2ZXJzYWw7XG52YXIgaW5qZWN0aW9uID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBDb21wb25lbnRUcmVlID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2UgJiYgSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBpbmplY3RUcmVlVHJhdmVyc2FsOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBUcmVlVHJhdmVyc2FsID0gSW5qZWN0ZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkICYmIEluamVjdGVkLmlzQW5jZXN0b3IgJiYgSW5qZWN0ZWQuZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RUcmVlVHJhdmVyc2FsKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgaXNBbmNlc3RvciBvciBnZXRMb3dlc3RDb21tb25BbmNlc3Rvci4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgS2V5RXNjYXBlVXRpbHNcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcykge1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZExpbmsgPT0gbnVsbCB8fCBpbnB1dFByb3BzLnZhbHVlTGluayA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBfcHJvZEludmFyaWFudCgnODcnKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJykgOiBfcHJvZEludmFyaWFudCgnODgnKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSBjaGVja2VkTGluaycpIDogX3Byb2RJbnZhcmlhbnQoJzg5JykgOiB2b2lkIDA7XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3AsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogX3Byb2RJbnZhcmlhbnQoJzg1JykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSkgOiB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHN3YXBwaW5nIG91dCBtb3VudCBpbWFnZXMgaW4gdGhlIG1pZGRsZSBvZlxuICAgKiB0aGUgdHJlZS5cbiAgICovXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDQnKSA6IHZvaWQgMDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzID0gZW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzXG4gKiogbW9kdWxlIGlkID0gNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVycm9yVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHs/U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gYSBGaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIHsqfSBiIFNlY29uZCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgYSwgYikge1xuICB0cnkge1xuICAgIHJldHVybiBmdW5jKGEsIGIpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYnkgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUgc28gdGhhdCBhbnkgZXJyb3JzIHRocm93biBieSB0aGUgZXZlbnRcbiAgICogaGFuZGxlciBhcmUgc3VyZSB0byBiZSByZXRocm93biBieSByZXRocm93Q2F1Z2h0RXJyb3IuXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2g6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8qKlxuICAgKiBUbyBoZWxwIGRldmVsb3BtZW50IHdlIGNhbiBnZXQgYmV0dGVyIGRldnRvb2xzIGludGVncmF0aW9uIGJ5IHNpbXVsYXRpbmcgYVxuICAgKiByZWFsIGJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgICAgIHZhciBib3VuZEZ1bmMgPSBmdW5jLmJpbmQobnVsbCwgYSwgYik7XG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgbmFtZTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVycm9yVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNTZWNyZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4gKiogbW9kdWxlIGlkID0gNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB2YXIgZGlzcGxheU5hbWUgPSBhcmcuY29uc3RydWN0b3IgJiYgYXJnLmNvbnN0cnVjdG9yLm5hbWUgfHwgdHlwZTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMubGVuZ3RoIDwgMjApIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWUgKyAnIChrZXlzOiAnICsga2V5cy5qb2luKCcsICcpICsgJyknO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGN0b3IgJiYgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyAnICsgJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciAnICsgJ3NpZGUtZWZmZWN0cyBhcmUgYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvICcgKyAnYGNvbXBvbmVudFdpbGxNb3VudGAuJywgY2FsbGVyTmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAvLyBEdXJpbmcgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXIgdGhpcyB3aWxsIHN0aWxsIGJlIG51bGwgYnV0IGFmdGVyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcbiAgICAgIC8vIHRoaXMgaGFjay5cbiAgICAgIHJldHVybiAhIWludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhbGxlck5hbWUgTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcblxuICAgIC8vIFByZXZpb3VzbHkgd2Ugd291bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgZGlkbid0IGhhdmUgYW4gaW50ZXJuYWxcbiAgICAvLyBpbnN0YW5jZS4gU2luY2Ugd2Ugd2FudCB0byBtYWtlIGl0IGEgbm8tb3AgaW5zdGVhZCwgd2UgbWlycm9yIHRoZSBzYW1lXG4gICAgLy8gYmVoYXZpb3Igd2UgaGF2ZSBpbiBvdGhlciBlbnF1ZXVlKiBtZXRob2RzLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBpZ25vcmUgY2FsbGJhY2tzIGluIGNvbXBvbmVudFdpbGxNb3VudC4gU2VlXG4gICAgLy8gZW5xdWV1ZVVwZGF0ZXMuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldFN0YXRlKCk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwYXJ0aWFsU3RhdGUgIT0gbnVsbCwgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICsgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIC8vIFRPRE86IGludHJvZHVjZSBfcGVuZGluZ0NvbnRleHQgaW5zdGVhZCBvZiBzZXR0aW5nIGl0IGRpcmVjdGx5LlxuICAgIGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIHZhbGlkYXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IF9wcm9kSW52YXJpYW50KCcxMjInLCBjYWxsZXJOYW1lLCBmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQoY2FsbGJhY2spKSA6IHZvaWQgMDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvblxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50Q2hhckNvZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qc1xuICoqIG1vZHVsZSBpZCA9IDcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0SXRlcmF0b3JGblxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qc1xuICoqIG1vZHVsZSBpZCA9IDc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdmFsaWRhdGVET01OZXN0aW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcblxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuXG4gICAgICBjYXNlICd0YWJsZSc6XG5cbiAgICAgIGNhc2UgJ2hyJzpcblxuICAgICAgY2FzZSAneG1wJzpcblxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGRvIHtcbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICAgIGlmIChjaGlsZFRhZyAhPT0gJyN0ZXh0Jykge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8sIGluZm8pIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL3ZhbGlkYXRlRE9NTmVzdGluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanNcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IGxvZ2dlciBmcm9tICdyZWR1eC1sb2dnZXInXG5pbXBvcnQgdGh1bmsgZnJvbSAncmVkdXgtdGh1bmsnXG5pbXBvcnQgcHJvbWlzZSBmcm9tICdyZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUnXG5cbmltcG9ydCByZWR1Y2VyIGZyb20gJy4vcmVkdWNlcnMvJ1xuXG5jb25zdCBtaWRkbGV3YXJlID0gYXBwbHlNaWRkbGV3YXJlKHByb21pc2UoKSwgdGh1bmssIGxvZ2dlcigpKVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTdG9yZShyZWR1Y2VyKVxuLy9leHBvcnQgZGVmYXVsdCBjcmVhdGVTdG9yZShyZWR1Y2VyLCBtaWRkbGV3YXJlKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL3N0b3JlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRTdGF0ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy9zdG9yZVNoYXBlLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2FybmluZztcbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93YXJuaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogVGhpcyBhY3Rpb24gdHlwZSB3aWxsIGJlIGRpc3BhdGNoZWQgYnkgdGhlIGhpc3RvcnkgYWN0aW9ucyBiZWxvdy5cbiAqIElmIHlvdSdyZSB3cml0aW5nIGEgbWlkZGxld2FyZSB0byB3YXRjaCBmb3IgbmF2aWdhdGlvbiBldmVudHMsIGJlIHN1cmUgdG9cbiAqIGxvb2sgZm9yIGFjdGlvbnMgb2YgdGhpcyB0eXBlLlxuICovXG52YXIgQ0FMTF9ISVNUT1JZX01FVEhPRCA9IGV4cG9ydHMuQ0FMTF9ISVNUT1JZX01FVEhPRCA9ICdAQHJvdXRlci9DQUxMX0hJU1RPUllfTUVUSE9EJztcblxuZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IENBTExfSElTVE9SWV9NRVRIT0QsXG4gICAgICBwYXlsb2FkOiB7IG1ldGhvZDogbWV0aG9kLCBhcmdzOiBhcmdzIH1cbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIFRoZXNlIGFjdGlvbnMgY29ycmVzcG9uZCB0byB0aGUgaGlzdG9yeSBBUEkuXG4gKiBUaGUgYXNzb2NpYXRlZCByb3V0ZXJNaWRkbGV3YXJlIHdpbGwgY2FwdHVyZSB0aGVzZSBldmVudHMgYmVmb3JlIHRoZXkgZ2V0IHRvXG4gKiB5b3VyIHJlZHVjZXIgYW5kIHJlaXNzdWUgdGhlbSBhcyB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gb24geW91ciBoaXN0b3J5LlxuICovXG52YXIgcHVzaCA9IGV4cG9ydHMucHVzaCA9IHVwZGF0ZUxvY2F0aW9uKCdwdXNoJyk7XG52YXIgcmVwbGFjZSA9IGV4cG9ydHMucmVwbGFjZSA9IHVwZGF0ZUxvY2F0aW9uKCdyZXBsYWNlJyk7XG52YXIgZ28gPSBleHBvcnRzLmdvID0gdXBkYXRlTG9jYXRpb24oJ2dvJyk7XG52YXIgZ29CYWNrID0gZXhwb3J0cy5nb0JhY2sgPSB1cGRhdGVMb2NhdGlvbignZ29CYWNrJyk7XG52YXIgZ29Gb3J3YXJkID0gZXhwb3J0cy5nb0ZvcndhcmQgPSB1cGRhdGVMb2NhdGlvbignZ29Gb3J3YXJkJyk7XG5cbnZhciByb3V0ZXJBY3Rpb25zID0gZXhwb3J0cy5yb3V0ZXJBY3Rpb25zID0geyBwdXNoOiBwdXNoLCByZXBsYWNlOiByZXBsYWNlLCBnbzogZ28sIGdvQmFjazogZ29CYWNrLCBnb0ZvcndhcmQ6IGdvRm9yd2FyZCB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvYWN0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLnJvdXRlckFjdGlvbnMgPSBleHBvcnRzLmdvRm9yd2FyZCA9IGV4cG9ydHMuZ29CYWNrID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMucmVwbGFjZSA9IGV4cG9ydHMucHVzaCA9IGV4cG9ydHMuQ0FMTF9ISVNUT1JZX01FVEhPRCA9IGV4cG9ydHMucm91dGVyUmVkdWNlciA9IGV4cG9ydHMuTE9DQVRJT05fQ0hBTkdFID0gZXhwb3J0cy5zeW5jSGlzdG9yeVdpdGhTdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWR1Y2VyID0gcmVxdWlyZSgnLi9yZWR1Y2VyJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnTE9DQVRJT05fQ0hBTkdFJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3JlZHVjZXIuTE9DQVRJT05fQ0hBTkdFO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyUmVkdWNlcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWR1Y2VyLnJvdXRlclJlZHVjZXI7XG4gIH1cbn0pO1xuXG52YXIgX2FjdGlvbnMgPSByZXF1aXJlKCcuL2FjdGlvbnMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdDQUxMX0hJU1RPUllfTUVUSE9EJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuQ0FMTF9ISVNUT1JZX01FVEhPRDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3B1c2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYWN0aW9ucy5wdXNoO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmVwbGFjZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLnJlcGxhY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLmdvO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ29CYWNrJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuZ29CYWNrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ29Gb3J3YXJkJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FjdGlvbnMuZ29Gb3J3YXJkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyQWN0aW9ucycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hY3Rpb25zLnJvdXRlckFjdGlvbnM7XG4gIH1cbn0pO1xuXG52YXIgX3N5bmMgPSByZXF1aXJlKCcuL3N5bmMnKTtcblxudmFyIF9zeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bmMpO1xuXG52YXIgX21pZGRsZXdhcmUgPSByZXF1aXJlKCcuL21pZGRsZXdhcmUnKTtcblxudmFyIF9taWRkbGV3YXJlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21pZGRsZXdhcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmV4cG9ydHMuc3luY0hpc3RvcnlXaXRoU3RvcmUgPSBfc3luYzJbJ2RlZmF1bHQnXTtcbmV4cG9ydHMucm91dGVyTWlkZGxld2FyZSA9IF9taWRkbGV3YXJlMlsnZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLnJvdXRlclJlZHVjZXIgPSByb3V0ZXJSZWR1Y2VyO1xuLyoqXG4gKiBUaGlzIGFjdGlvbiB0eXBlIHdpbGwgYmUgZGlzcGF0Y2hlZCB3aGVuIHlvdXIgaGlzdG9yeVxuICogcmVjZWl2ZXMgYSBsb2NhdGlvbiBjaGFuZ2UuXG4gKi9cbnZhciBMT0NBVElPTl9DSEFOR0UgPSBleHBvcnRzLkxPQ0FUSU9OX0NIQU5HRSA9ICdAQHJvdXRlci9MT0NBVElPTl9DSEFOR0UnO1xuXG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBsb2NhdGlvbkJlZm9yZVRyYW5zaXRpb25zOiBudWxsXG59O1xuXG4vKipcbiAqIFRoaXMgcmVkdWNlciB3aWxsIHVwZGF0ZSB0aGUgc3RhdGUgd2l0aCB0aGUgbW9zdCByZWNlbnQgbG9jYXRpb24gaGlzdG9yeVxuICogaGFzIHRyYW5zaXRpb25lZCB0by4gVGhpcyBtYXkgbm90IGJlIGluIHN5bmMgd2l0aCB0aGUgcm91dGVyLCBwYXJ0aWN1bGFybHlcbiAqIGlmIHlvdSBoYXZlIGFzeW5jaHJvbm91c2x5LWxvYWRlZCByb3V0ZXMsIHNvIHJlYWRpbmcgZnJvbSBhbmQgcmVseWluZyBvblxuICogdGhpcyBzdGF0ZSBpcyBkaXNjb3VyYWdlZC5cbiAqL1xuZnVuY3Rpb24gcm91dGVyUmVkdWNlcigpIHtcbiAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gaW5pdGlhbFN0YXRlIDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XG5cbiAgdmFyIHR5cGUgPSBfcmVmLnR5cGU7XG4gIHZhciBwYXlsb2FkID0gX3JlZi5wYXlsb2FkO1xuXG4gIGlmICh0eXBlID09PSBMT0NBVElPTl9DSEFOR0UpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7IGxvY2F0aW9uQmVmb3JlVHJhbnNpdGlvbnM6IHBheWxvYWQgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9yZWR1Y2VyLmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGJvb2wgPSBfUmVhY3QkUHJvcFR5cGVzLmJvb2w7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvbmVPZlR5cGUgPSBfUmVhY3QkUHJvcFR5cGVzLm9uZU9mVHlwZTtcblxuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8vIFRPRE86IERlLWR1cGxpY2F0ZSBhZ2FpbnN0IGhhc0FueVByb3BlcnRpZXMgaW4gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIGZhbHNlO1xuICB9cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgX3JlZikge1xuICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5O1xuICB2YXIgaGFzaCA9IF9yZWYuaGFzaDtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICBpZiAocXVlcnkgfHwgaGFzaCB8fCBzdGF0ZSkge1xuICAgIHJldHVybiB7IHBhdGhuYW1lOiB0bywgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfTtcbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiBpcyB1c2VkIHRvIGNyZWF0ZSBhbiA8YT4gZWxlbWVudCB0aGF0IGxpbmtzIHRvIGEgcm91dGUuXG4gKiBXaGVuIHRoYXQgcm91dGUgaXMgYWN0aXZlLCB0aGUgbGluayBnZXRzIHRoZSB2YWx1ZSBvZiBpdHNcbiAqIGFjdGl2ZUNsYXNzTmFtZSBwcm9wLlxuICpcbiAqIEZvciBleGFtcGxlLCBhc3N1bWluZyB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHJvdXRlOlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvcG9zdHMvOnBvc3RJRFwiIGNvbXBvbmVudD17UG9zdH0gLz5cbiAqXG4gKiBZb3UgY291bGQgdXNlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50IHRvIGxpbmsgdG8gdGhhdCByb3V0ZTpcbiAqXG4gKiAgIDxMaW5rIHRvPXtgL3Bvc3RzLyR7cG9zdC5pZH1gfSAvPlxuICpcbiAqIExpbmtzIG1heSBwYXNzIGFsb25nIGxvY2F0aW9uIHN0YXRlIGFuZC9vciBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xuICogaW4gdGhlIHN0YXRlL3F1ZXJ5IHByb3BzLCByZXNwZWN0aXZlbHkuXG4gKlxuICogICA8TGluayAuLi4gcXVlcnk9e3sgc2hvdzogdHJ1ZSB9fSBzdGF0ZT17eyB0aGU6ICdzdGF0ZScgfX0gLz5cbiAqL1xudmFyIExpbmsgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxuXG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlXG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdG86IG9uZU9mVHlwZShbc3RyaW5nLCBvYmplY3RdKS5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgaGFzaDogc3RyaW5nLFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgYWN0aXZlU3R5bGU6IG9iamVjdCxcbiAgICBhY3RpdmVDbGFzc05hbWU6IHN0cmluZyxcbiAgICBvbmx5QWN0aXZlT25JbmRleDogYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uQ2xpY2s6IGZ1bmMsXG4gICAgdGFyZ2V0OiBzdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25seUFjdGl2ZU9uSW5kZXg6IGZhbHNlLFxuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykgdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAhdGhpcy5jb250ZXh0LnJvdXRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8TGluaz5zIHJlbmRlcmVkIG91dHNpZGUgb2YgYSByb3V0ZXIgY29udGV4dCBjYW5ub3QgbmF2aWdhdGUuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzTW9kaWZpZWRFdmVudChldmVudCkgfHwgIWlzTGVmdENsaWNrRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICAvLyBJZiB0YXJnZXQgcHJvcCBpcyBzZXQgKGUuZy4gdG8gXCJfYmxhbmtcIiksIGxldCBicm93c2VyIGhhbmRsZSBsaW5rLlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gICAgaWYgKHRoaXMucHJvcHMudGFyZ2V0KSByZXR1cm47XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRvID0gX3Byb3BzLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wcy5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wcy5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IF9wcm9wcy5zdGF0ZTtcblxuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgeyBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9KTtcblxuICAgIHRoaXMuY29udGV4dC5yb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdG8gPSBfcHJvcHMyLnRvO1xuICAgIHZhciBxdWVyeSA9IF9wcm9wczIucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBfcHJvcHMyLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gX3Byb3BzMi5zdGF0ZTtcbiAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gX3Byb3BzMi5hY3RpdmVDbGFzc05hbWU7XG4gICAgdmFyIGFjdGl2ZVN0eWxlID0gX3Byb3BzMi5hY3RpdmVTdHlsZTtcbiAgICB2YXIgb25seUFjdGl2ZU9uSW5kZXggPSBfcHJvcHMyLm9ubHlBY3RpdmVPbkluZGV4O1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczIsIFsndG8nLCAncXVlcnknLCAnaGFzaCcsICdzdGF0ZScsICdhY3RpdmVDbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnb25seUFjdGl2ZU9uSW5kZXgnXSk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghKHF1ZXJ5IHx8IGhhc2ggfHwgc3RhdGUpLCAndGhlIGBxdWVyeWAsIGBoYXNoYCwgYW5kIGBzdGF0ZWAgcHJvcHMgb24gYDxMaW5rPmAgYXJlIGRlcHJlY2F0ZWQsIHVzZSBgPExpbmsgdG89e3sgcGF0aG5hbWUsIHF1ZXJ5LCBoYXNoLCBzdGF0ZSB9fS8+LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZ25vcmUgaWYgcmVuZGVyZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiByb3V0ZXIsIHNpbXBsaWZpZXMgdW5pdCB0ZXN0aW5nLlxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuXG5cbiAgICBpZiAocm91dGVyKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIHsgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfSk7XG4gICAgICBwcm9wcy5ocmVmID0gcm91dGVyLmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuXG4gICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lIHx8IGFjdGl2ZVN0eWxlICE9IG51bGwgJiYgIWlzRW1wdHlPYmplY3QoYWN0aXZlU3R5bGUpKSB7XG4gICAgICAgIGlmIChyb3V0ZXIuaXNBY3RpdmUobG9jYXRpb24sIG9ubHlBY3RpdmVPbkluZGV4KSkge1xuICAgICAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lICs9ICcgJyArIGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb3BzLmNsYXNzTmFtZSA9IGFjdGl2ZUNsYXNzTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWN0aXZlU3R5bGUpIHByb3BzLnN0eWxlID0gX2V4dGVuZHMoe30sIHByb3BzLnN0eWxlLCBhY3RpdmVTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljayB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8UmVkaXJlY3Q+IGlzIHVzZWQgdG8gZGVjbGFyZSBhbm90aGVyIFVSTCBwYXRoIGEgY2xpZW50IHNob3VsZFxuICogYmUgc2VudCB0byB3aGVuIHRoZXkgcmVxdWVzdCBhIGdpdmVuIFVSTC5cbiAqXG4gKiBSZWRpcmVjdHMgYXJlIHBsYWNlZCBhbG9uZ3NpZGUgcm91dGVzIGluIHRoZSByb3V0ZSBjb25maWd1cmF0aW9uXG4gKiBhbmQgYXJlIHRyYXZlcnNlZCBpbiB0aGUgc2FtZSBtYW5uZXIuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWRpcmVjdCcsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHJvdXRlID0gKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkoZWxlbWVudCk7XG5cbiAgICAgIGlmIChyb3V0ZS5mcm9tKSByb3V0ZS5wYXRoID0gcm91dGUuZnJvbTtcblxuICAgICAgcm91dGUub25FbnRlciA9IGZ1bmN0aW9uIChuZXh0U3RhdGUsIHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uO1xuICAgICAgICB2YXIgcGFyYW1zID0gbmV4dFN0YXRlLnBhcmFtcztcblxuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHJvdXRlLnRvLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShyb3V0ZS50bywgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm91dGUudG8pIHtcbiAgICAgICAgICBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByb3V0ZUluZGV4ID0gbmV4dFN0YXRlLnJvdXRlcy5pbmRleE9mKHJvdXRlKTtcbiAgICAgICAgICB2YXIgcGFyZW50UGF0dGVybiA9IFJlZGlyZWN0LmdldFJvdXRlUGF0dGVybihuZXh0U3RhdGUucm91dGVzLCByb3V0ZUluZGV4IC0gMSk7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXJlbnRQYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHJvdXRlLnRvO1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocGF0dGVybiwgcGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcGxhY2Uoe1xuICAgICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgICAgICBxdWVyeTogcm91dGUucXVlcnkgfHwgbG9jYXRpb24ucXVlcnksXG4gICAgICAgICAgc3RhdGU6IHJvdXRlLnN0YXRlIHx8IGxvY2F0aW9uLnN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH0sXG4gICAgZ2V0Um91dGVQYXR0ZXJuOiBmdW5jdGlvbiBnZXRSb3V0ZVBhdHRlcm4ocm91dGVzLCByb3V0ZUluZGV4KSB7XG4gICAgICB2YXIgcGFyZW50UGF0dGVybiA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gcm91dGVJbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICAgICAgcGFyZW50UGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGFyZW50UGF0dGVybjtcblxuICAgICAgICBpZiAocGF0dGVybi5pbmRleE9mKCcvJykgPT09IDApIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJy8nICsgcGFyZW50UGF0dGVybjtcbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZyb206IHN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGhcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmNyZWF0ZVJvdXRlck9iamVjdCA9IGNyZWF0ZVJvdXRlck9iamVjdDtcbmV4cG9ydHMuY3JlYXRlUm91dGluZ0hpc3RvcnkgPSBjcmVhdGVSb3V0aW5nSGlzdG9yeTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIHNldFJvdXRlTGVhdmVIb29rOiB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgaXNBY3RpdmU6IHRyYW5zaXRpb25NYW5hZ2VyLmlzQWN0aXZlXG4gIH0pO1xufVxuXG4vLyBkZXByZWNhdGVkXG5mdW5jdGlvbiBjcmVhdGVSb3V0aW5nSGlzdG9yeShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcikge1xuICBoaXN0b3J5ID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGhpc3RvcnkgPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGhpc3RvcnksICdgcHJvcHMuaGlzdG9yeWAgYW5kIGBjb250ZXh0Lmhpc3RvcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlcmAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jb250ZXh0Y2hhbmdlcycpO1xuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJVdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIC8vIHNpZ25hdHVyZXMgYW5kIHR5cGUgY2hlY2tpbmcgZGlmZmVyIGJldHdlZW4gYHVzZVJvdXRlc2AgYW5kXG4gIC8vIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCwgaGF2ZSB0byBjcmVhdGUgYG1lbW9yeUhpc3RvcnlgIGZpcnN0IGJlY2F1c2VcbiAgLy8gYHVzZVF1ZXJpZXNgIGRvZXNuJ3QgdW5kZXJzdGFuZCB0aGUgc2lnbmF0dXJlXG4gIHZhciBtZW1vcnlIaXN0b3J5ID0gKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgIHJldHVybiBtZW1vcnlIaXN0b3J5O1xuICB9O1xuICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY3JlYXRlSGlzdG9yeSkge1xuICB2YXIgaGlzdG9yeSA9IHZvaWQgMDtcbiAgaWYgKGNhblVzZURPTSkgaGlzdG9yeSA9ICgwLCBfdXNlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoKTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGV4cG9ydHMuaGFzaEhpc3RvcnkgPSBleHBvcnRzLmJyb3dzZXJIaXN0b3J5ID0gZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBleHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMuUHJvcFR5cGVzID0gZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IGV4cG9ydHMuUm91dGVyQ29udGV4dCA9IGV4cG9ydHMuY3JlYXRlUm91dGVzID0gZXhwb3J0cy51c2VSb3V0ZXMgPSBleHBvcnRzLlJvdXRlQ29udGV4dCA9IGV4cG9ydHMuTGlmZWN5Y2xlID0gZXhwb3J0cy5IaXN0b3J5ID0gZXhwb3J0cy5Sb3V0ZSA9IGV4cG9ydHMuUmVkaXJlY3QgPSBleHBvcnRzLkluZGV4Um91dGUgPSBleHBvcnRzLkluZGV4UmVkaXJlY3QgPSBleHBvcnRzLndpdGhSb3V0ZXIgPSBleHBvcnRzLkluZGV4TGluayA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMuUm91dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXM7XG4gIH1cbn0pO1xuXG52YXIgX1Byb3BUeXBlczIgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2xvY2F0aW9uU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5sb2NhdGlvblNoYXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5yb3V0ZXJTaGFwZTtcbiAgfVxufSk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRQYXR0ZXJuJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuO1xuICB9XG59KTtcblxudmFyIF9Sb3V0ZXIyID0gcmVxdWlyZSgnLi9Sb3V0ZXInKTtcblxudmFyIF9Sb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyMik7XG5cbnZhciBfTGluazIgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmsyKTtcblxudmFyIF9JbmRleExpbmsyID0gcmVxdWlyZSgnLi9JbmRleExpbmsnKTtcblxudmFyIF9JbmRleExpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhMaW5rMik7XG5cbnZhciBfd2l0aFJvdXRlcjIgPSByZXF1aXJlKCcuL3dpdGhSb3V0ZXInKTtcblxudmFyIF93aXRoUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dpdGhSb3V0ZXIyKTtcblxudmFyIF9JbmRleFJlZGlyZWN0MiA9IHJlcXVpcmUoJy4vSW5kZXhSZWRpcmVjdCcpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSZWRpcmVjdDIpO1xuXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XG5cbnZhciBfSW5kZXhSb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJvdXRlMik7XG5cbnZhciBfUmVkaXJlY3QyID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0Mik7XG5cbnZhciBfUm91dGUyID0gcmVxdWlyZSgnLi9Sb3V0ZScpO1xuXG52YXIgX1JvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlMik7XG5cbnZhciBfSGlzdG9yeTIgPSByZXF1aXJlKCcuL0hpc3RvcnknKTtcblxudmFyIF9IaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hpc3RvcnkyKTtcblxudmFyIF9MaWZlY3ljbGUyID0gcmVxdWlyZSgnLi9MaWZlY3ljbGUnKTtcblxudmFyIF9MaWZlY3ljbGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlmZWN5Y2xlMik7XG5cbnZhciBfUm91dGVDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlQ29udGV4dDIpO1xuXG52YXIgX3VzZVJvdXRlczIgPSByZXF1aXJlKCcuL3VzZVJvdXRlcycpO1xuXG52YXIgX3VzZVJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXMyKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dDIpO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGluZ0NvbnRleHQnKTtcblxudmFyIF9Sb3V0aW5nQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0aW5nQ29udGV4dDIpO1xuXG52YXIgX1Byb3BUeXBlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm9wVHlwZXMyKTtcblxudmFyIF9tYXRjaDIgPSByZXF1aXJlKCcuL21hdGNoJyk7XG5cbnZhciBfbWF0Y2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2gyKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeTIpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTIgPSByZXF1aXJlKCcuL2FwcGx5Um91dGVyTWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseVJvdXRlck1pZGRsZXdhcmUyKTtcblxudmFyIF9icm93c2VySGlzdG9yeTIgPSByZXF1aXJlKCcuL2Jyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfYnJvd3Nlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3Nlckhpc3RvcnkyKTtcblxudmFyIF9oYXNoSGlzdG9yeTIgPSByZXF1aXJlKCcuL2hhc2hIaXN0b3J5Jyk7XG5cbnZhciBfaGFzaEhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzaEhpc3RvcnkyKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlJvdXRlciA9IF9Sb3V0ZXIzLmRlZmF1bHQ7IC8qIGNvbXBvbmVudHMgKi9cblxuZXhwb3J0cy5MaW5rID0gX0xpbmszLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4TGluayA9IF9JbmRleExpbmszLmRlZmF1bHQ7XG5leHBvcnRzLndpdGhSb3V0ZXIgPSBfd2l0aFJvdXRlcjMuZGVmYXVsdDtcblxuLyogY29tcG9uZW50cyAoY29uZmlndXJhdGlvbikgKi9cblxuZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gX0luZGV4UmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4Um91dGUgPSBfSW5kZXhSb3V0ZTMuZGVmYXVsdDtcbmV4cG9ydHMuUmVkaXJlY3QgPSBfUmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlID0gX1JvdXRlMy5kZWZhdWx0O1xuXG4vKiBtaXhpbnMgKi9cblxuZXhwb3J0cy5IaXN0b3J5ID0gX0hpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLkxpZmVjeWNsZSA9IF9MaWZlY3ljbGUzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlQ29udGV4dCA9IF9Sb3V0ZUNvbnRleHQzLmRlZmF1bHQ7XG5cbi8qIHV0aWxzICovXG5cbmV4cG9ydHMudXNlUm91dGVzID0gX3VzZVJvdXRlczMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGVyQ29udGV4dCA9IF9Sb3V0ZXJDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IF9Sb3V0aW5nQ29udGV4dDMuZGVmYXVsdDtcbmV4cG9ydHMuUHJvcFR5cGVzID0gX1Byb3BUeXBlczMuZGVmYXVsdDtcbmV4cG9ydHMubWF0Y2ggPSBfbWF0Y2gzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBfdXNlUm91dGVySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gX2FwcGx5Um91dGVyTWlkZGxld2FyZTMuZGVmYXVsdDtcblxuLyogaGlzdG9yaWVzICovXG5cbmV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBfYnJvd3Nlckhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmhhc2hIaXN0b3J5ID0gX2hhc2hIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VTdGF0ZVdpdGhMb2NhdGlvbjtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdpdGhMb2NhdGlvbihzdGF0ZSwgbG9jYXRpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuY2FuVXNlTWVtYnJhbmUpIHtcbiAgICB2YXIgc3RhdGVXaXRoTG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgc3RhdGUpO1xuXG4gICAgLy8gSSBkb24ndCB1c2UgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyBoZXJlIGJlY2F1c2UgSSB3YW50IHRvIGtlZXAgdGhlXG4gICAgLy8gc2FtZSBjb2RlIHBhdGggYmV0d2VlbiBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiwgaW4gdGhhdCB3ZSBqdXN0XG4gICAgLy8gYXNzaWduIGV4dHJhIHByb3BlcnRpZXMgdG8gdGhlIGNvcHkgb2YgdGhlIHN0YXRlIG9iamVjdCBpbiBib3RoIGNhc2VzLlxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYXRpb24sIHByb3ApKSB7XG4gICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGVXaXRoTG9jYXRpb24sIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBY2Nlc3NpbmcgbG9jYXRpb24gcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgZ2V0Q29tcG9uZW50YCwgYGdldENvbXBvbmVudHNgLCBgZ2V0Q2hpbGRSb3V0ZXNgLCBhbmQgYGdldEluZGV4Um91dGVgIGlzIGRlcHJlY2F0ZWQuIFRoYXQgYXJndW1lbnQgaXMgbm93IHRoZSByb3V0ZXIgc3RhdGUgKGBuZXh0U3RhdGVgIG9yIGBwYXJ0aWFsTmV4dFN0YXRlYCkgcmF0aGVyIHRoYW4gdGhlIGxvY2F0aW9uLiBUbyBhY2Nlc3MgdGhlIGxvY2F0aW9uLCB1c2UgYG5leHRTdGF0ZS5sb2NhdGlvbmAgb3IgYHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb25gLicpIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gbG9jYXRpb24pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVXaXRoTG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBsb2NhdGlvbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21ha2VTdGF0ZVdpdGhMb2NhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VSb3V0ZXJIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB1c2VSb3V0ZXJIaXN0b3J5KGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKCgwLCBfdXNlQmFzZW5hbWUyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKmVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbmV4cG9ydHMucmVhZFN0YXRlID0gcmVhZFN0YXRlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgS2V5UHJlZml4ID0gJ0BASGlzdG9yeS8nO1xudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSBbJ1F1b3RhRXhjZWVkZWRFcnJvcicsICdRVU9UQV9FWENFRURFRF9FUlInXTtcblxudmFyIFNlY3VyaXR5RXJyb3IgPSAnU2VjdXJpdHlFcnJvcic7XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIEtleVByZWZpeCArIGtleTtcbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFF1b3RhRXhjZWVkZWRFcnJvcnMuaW5kZXhPZihlcnJvci5uYW1lKSA+PSAwICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFNhZmFyaSBcInByaXZhdGUgbW9kZVwiIHRocm93cyBRdW90YUV4Y2VlZGVkRXJyb3IuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gU2FmYXJpIHByaXZhdGUgbW9kZScpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICB2YXIganNvbiA9IHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICBqc29uID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gcmVhZCBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIEpTT04uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVET01IaXN0b3J5KG9wdGlvbnMpIHtcbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7XG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogX0RPTVV0aWxzLmdldFVzZXJDb25maXJtYXRpb25cbiAgfSwgb3B0aW9ucywge1xuICAgIGdvOiBfRE9NVXRpbHMuZ29cbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdET00gaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZURPTUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZURPTUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZURPTUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBpc0Fic29sdXRlUGF0aChwYXRoKSB7XG4gIHJldHVybiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2goKSB7XG4gIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgaWYgKGlzQWJzb2x1dGVQYXRoKHBhdGgpKSByZXR1cm4gdHJ1ZTtcblxuICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKCcvJyArIHBhdGgpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBwYXRoICsgKHBhdGguaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyAoa2V5ICsgJz0nICsgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdbPyZdPycgKyBrZXkgKyAnPVthLXpBLVowLTldKycpLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBrZXkpIHtcbiAgdmFyIG1hdGNoID0gcGF0aC5tYXRjaChuZXcgUmVnRXhwKCdcXFxcPy4qP1xcXFxiJyArIGtleSArICc9KC4rPylcXFxcYicpKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuXG52YXIgRGVmYXVsdFF1ZXJ5S2V5ID0gJ19rJztcblxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHF1ZXJ5S2V5ID0gb3B0aW9ucy5xdWVyeUtleTtcblxuICBpZiAocXVlcnlLZXkgPT09IHVuZGVmaW5lZCB8fCAhIXF1ZXJ5S2V5KSBxdWVyeUtleSA9IHR5cGVvZiBxdWVyeUtleSA9PT0gJ3N0cmluZycgPyBxdWVyeUtleSA6IERlZmF1bHRRdWVyeUtleTtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICAgIHZhciBrZXkgPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YXRlID0gdW5kZWZpbmVkO1xuICAgIGlmIChxdWVyeUtleSkge1xuICAgICAga2V5ID0gZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoKHBhdGgsIHF1ZXJ5S2V5KTtcbiAgICAgIHBhdGggPSBzdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBxdWVyeUtleSk7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc3RhdGUgPSBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuICAgICAgICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwgcXVlcnlLZXksIGtleSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lcihfcmVmKSB7XG4gICAgdmFyIHRyYW5zaXRpb25UbyA9IF9yZWYudHJhbnNpdGlvblRvO1xuXG4gICAgZnVuY3Rpb24gaGFzaENoYW5nZUxpc3RlbmVyKCkge1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSByZXR1cm47IC8vIEFsd2F5cyBtYWtlIHN1cmUgaGFzaGVzIGFyZSBwcmVjZWVkZWQgd2l0aCBhIC8uXG5cbiAgICAgIHRyYW5zaXRpb25UbyhnZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gICAgfVxuXG4gICAgZW5zdXJlU2xhc2goKTtcbiAgICBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgaGFzaENoYW5nZUxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgaGFzaENoYW5nZUxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhbnNpdGlvbihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gICAgdmFyIGFjdGlvbiA9IGxvY2F0aW9uLmFjdGlvbjtcbiAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIHNlYXJjaDtcblxuICAgIGlmIChxdWVyeUtleSkge1xuICAgICAgcGF0aCA9IGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwgcXVlcnlLZXksIGtleSk7XG4gICAgICBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZShrZXksIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRHJvcCBrZXkgYW5kIHN0YXRlLlxuICAgICAgbG9jYXRpb24ua2V5ID0gbG9jYXRpb24uc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SGFzaCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgaWYgKGN1cnJlbnRIYXNoICE9PSBwYXRoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1lvdSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoIHVzaW5nIGhhc2ggaGlzdG9yeScpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudEhhc2ggIT09IHBhdGgpIHtcbiAgICAgIC8vIFJFUExBQ0VcbiAgICAgIF9ET01VdGlscy5yZXBsYWNlSGFzaFBhdGgocGF0aCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlRE9NSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZVxuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IGxvY2F0aW9uLnN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnB1c2gobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBsb2NhdGlvbi5zdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgfVxuXG4gIHZhciBnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCA9IF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkuZ28obik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICByZXR1cm4gJyMnICsgaGlzdG9yeS5jcmVhdGVIcmVmKHBhdGgpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyID0gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICBoaXN0b3J5LnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaGlzdG9yeS51bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG5cbiAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wSGFzaENoYW5nZUxpc3RlbmVyKCk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBzdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHBhdGgpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcblxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHB1c2hTdGF0ZTogcHVzaFN0YXRlLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgcmVwbGFjZVN0YXRlOiByZXBsYWNlU3RhdGUgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgX2RlZXBFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWVwRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjIgPSByZXF1aXJlKCcuL2NyZWF0ZUxvY2F0aW9uJyk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTG9jYXRpb24yKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tS2V5KGxlbmd0aCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmXG4gIC8vYS5hY3Rpb24gPT09IGIuYWN0aW9uICYmIC8vIERpZmZlcmVudCBhY3Rpb24gIT09IGxvY2F0aW9uIGNoYW5nZS5cbiAgYS5rZXkgPT09IGIua2V5ICYmIF9kZWVwRXF1YWwyWydkZWZhdWx0J10oYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbnZhciBEZWZhdWx0S2V5TGVuZ3RoID0gNjtcblxuZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IG9wdGlvbnMuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgZmluaXNoVHJhbnNpdGlvbiA9IG9wdGlvbnMuZmluaXNoVHJhbnNpdGlvbjtcbiAgdmFyIHNhdmVTdGF0ZSA9IG9wdGlvbnMuc2F2ZVN0YXRlO1xuICB2YXIgZ28gPSBvcHRpb25zLmdvO1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IG9wdGlvbnMuZ2V0VXNlckNvbmZpcm1hdGlvbjtcbiAgdmFyIGtleUxlbmd0aCA9IG9wdGlvbnMua2V5TGVuZ3RoO1xuXG4gIGlmICh0eXBlb2Yga2V5TGVuZ3RoICE9PSAnbnVtYmVyJykga2V5TGVuZ3RoID0gRGVmYXVsdEtleUxlbmd0aDtcblxuICB2YXIgdHJhbnNpdGlvbkhvb2tzID0gW107XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBhbGxLZXlzID0gW107XG4gIHZhciBjaGFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAmJiBwZW5kaW5nTG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgIHJldHVybiBhbGxLZXlzLmluZGV4T2YocGVuZGluZ0xvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV3TG9jYXRpb24pIHtcbiAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnQoKTtcblxuICAgIGxvY2F0aW9uID0gbmV3TG9jYXRpb247XG5cbiAgICBpZiAobG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBhbGxLZXlzID0gW10uY29uY2F0KGFsbEtleXMuc2xpY2UoMCwgY3VycmVudCArIDEpLCBbbG9jYXRpb24ua2V5XSk7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgY2hhbmdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcihsb2NhdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBjaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9sb2NhdGlvbiA9IGdldEN1cnJlbnRMb2NhdGlvbigpO1xuICAgICAgYWxsS2V5cyA9IFtfbG9jYXRpb24ua2V5XTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKF9sb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5nZUxpc3RlbmVycyA9IGNoYW5nZUxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgX0FzeW5jVXRpbHMubG9vcEFzeW5jKHRyYW5zaXRpb25Ib29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKHRyYW5zaXRpb25Ib29rc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgIGRvbmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICBjYWxsYmFjayhvayAhPT0gZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBwZW5kaW5nTG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiAmJiBsb2NhdGlvbnNBcmVFcXVhbChsb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgcGVuZGluZ0xvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgY29uZmlybVRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKHBlbmRpbmdMb2NhdGlvbiAhPT0gbmV4dExvY2F0aW9uKSByZXR1cm47IC8vIFRyYW5zaXRpb24gd2FzIGludGVycnVwdGVkLlxuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gdHJlYXQgUFVTSCB0byBjdXJyZW50IHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgICAgIHZhciBuZXh0UGF0aCA9IGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShsb2NhdGlvbi5zdGF0ZSwgbmV4dExvY2F0aW9uLnN0YXRlKSkgbmV4dExvY2F0aW9uLmFjdGlvbiA9IF9BY3Rpb25zLlJFUExBQ0U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmluaXNoVHJhbnNpdGlvbihuZXh0TG9jYXRpb24pICE9PSBmYWxzZSkgdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gJiYgbmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobG9jYXRpb24ua2V5KTtcbiAgICAgICAgdmFyIG5leHRJbmRleCA9IGFsbEtleXMuaW5kZXhPZihuZXh0TG9jYXRpb24ua2V5KTtcblxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSAmJiBuZXh0SW5kZXggIT09IC0xKSBnbyhwcmV2SW5kZXggLSBuZXh0SW5kZXgpOyAvLyBSZXN0b3JlIHRoZSBVUkwuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5QVVNILCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgX0FjdGlvbnMuUkVQTEFDRSwgY3JlYXRlS2V5KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJhbmRvbUtleShrZXlMZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBsb2NhdGlvbjtcblxuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gICAgdmFyIHJlc3VsdCA9IHBhdGhuYW1lO1xuXG4gICAgaWYgKHNlYXJjaCkgcmVzdWx0ICs9IHNlYXJjaDtcblxuICAgIGlmIChoYXNoKSByZXN1bHQgKz0gaGFzaDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBjcmVhdGVLZXkoKSA6IGFyZ3VtZW50c1syXTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24gaXMgZGVwcmVjYXRlZDsgdXNlIGEgJyArICdsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgICBhY3Rpb24gPSBrZXk7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbM10gfHwgY3JlYXRlS2V5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbjNbJ2RlZmF1bHQnXShsb2NhdGlvbiwgYWN0aW9uLCBrZXkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpO1xuICAgICAgdXBkYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGdldEN1cnJlbnRMb2NhdGlvbigpLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTG9jYXRpb25TdGF0ZShsb2NhdGlvbiwgc3RhdGUpIHtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbi5zdGF0ZSwgc3RhdGUpO1xuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKHRyYW5zaXRpb25Ib29rcy5pbmRleE9mKGhvb2spID09PSAtMSkgdHJhbnNpdGlvbkhvb2tzLnB1c2goaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgdHJhbnNpdGlvbkhvb2tzID0gdHJhbnNpdGlvbkhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgfSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgdHJhbnNpdGlvblRvOiB0cmFuc2l0aW9uVG8sXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjcmVhdGVLZXk6IGNyZWF0ZUtleSxcbiAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgc2V0U3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10oc2V0U3RhdGUsICdzZXRTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgbG9jYXRpb24ua2V5IHRvIHNhdmUgc3RhdGUgaW5zdGVhZCcpLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3JlZ2lzdGVyVHJhbnNpdGlvbkhvb2sgaXMgZGVwcmVjYXRlZDsgdXNlIGxpc3RlbkJlZm9yZSBpbnN0ZWFkJyksXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vaywgJ3VucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZyb20gbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gdXNlQmFzZW5hbWUoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgYmFzZW5hbWUgPSBvcHRpb25zLmJhc2VuYW1lO1xuXG4gICAgdmFyIGNoZWNrZWRCYXNlSHJlZiA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tCYXNlSHJlZigpIHtcbiAgICAgIGlmIChjaGVja2VkQmFzZUhyZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHVzZSB0aGUgdmFsdWUgb2YgPGJhc2UgaHJlZj4gaW4gSFRNTFxuICAgICAgLy8gZG9jdW1lbnRzIGFzIGJhc2VuYW1lIGlmIGl0J3Mgbm90IGV4cGxpY2l0bHkgZ2l2ZW4uXG4gICAgICBpZiAoYmFzZW5hbWUgPT0gbnVsbCAmJiBfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgICAgIHZhciBiYXNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgICAgICAgdmFyIGJhc2VIcmVmID0gYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICAgIGlmIChiYXNlSHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgYmFzZW5hbWUgPSBiYXNlSHJlZjtcblxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0F1dG9tYXRpY2FsbHkgc2V0dGluZyBiYXNlbmFtZSB1c2luZyA8YmFzZSBocmVmPiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsICcgKyAnYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBUaGUgc2VtYW50aWNzIG9mIDxiYXNlIGhyZWY+IGFyZSAnICsgJ3N1YnRseSBkaWZmZXJlbnQgZnJvbSBiYXNlbmFtZS4gUGxlYXNlIHBhc3MgdGhlIGJhc2VuYW1lIGV4cGxpY2l0bHkgaW4gJyArICd0aGUgb3B0aW9ucyB0byBjcmVhdGVIaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2tlZEJhc2VIcmVmID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgY2hlY2tCYXNlSHJlZigpO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgJiYgbG9jYXRpb24uYmFzZW5hbWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlbmFtZSkgPT09IDApIHtcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZyhiYXNlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gYmFzZW5hbWU7XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09ICcnKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGNoZWNrQmFzZUhyZWYoKTtcblxuICAgICAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBwbmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRCYXNlbmFtZSA9IGJhc2VuYW1lLnNsaWNlKC0xKSA9PT0gJy8nID8gYmFzZW5hbWUgOiBiYXNlbmFtZSArICcvJztcbiAgICAgIHZhciBub3JtYWxpemVkUGF0aG5hbWUgPSBwbmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IHBuYW1lLnNsaWNlKDEpIDogcG5hbWU7XG4gICAgICB2YXIgcGF0aG5hbWUgPSBub3JtYWxpemVkQmFzZW5hbWUgKyBub3JtYWxpemVkUGF0aG5hbWU7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIF9ydW5UcmFuc2l0aW9uSG9vazJbJ2RlZmF1bHQnXShob29rLCBhZGRCYXNlbmFtZShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihhZGRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnB1c2gocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkQmFzZW5hbWUoaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKV0uY29uY2F0KGFyZ3MpKSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgICAgcmVwbGFjZVN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlcGxhY2VTdGF0ZSwgJ3JlcGxhY2VTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcmVwbGFjZSBpbnN0ZWFkJylcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gdXNlQmFzZW5hbWU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogTW9zdCBzdHlsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1bnNldCBieSBkb2luZyAuc3R5bGVbcHJvcF0gPSAnJyBidXQgSUU4XG4gKiBkb2Vzbid0IGxpa2UgZG9pbmcgdGhhdCB3aXRoIHNob3J0aGFuZCBwcm9wZXJ0aWVzIHNvIGZvciB0aGUgcHJvcGVydGllcyB0aGF0XG4gKiBJRTggYnJlYWtzIG9uLCB3aGljaCBhcmUgbGlzdGVkIGhlcmUsIHdlIGluc3RlYWQgdW5zZXQgZWFjaCBvZiB0aGVcbiAqIGluZGl2aWR1YWwgcHJvcGVydGllcy4gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzg1LlxuICogVGhlIDQtdmFsdWUgJ2Nsb2NrJyBwcm9wZXJ0aWVzIGxpa2UgbWFyZ2luLCBwYWRkaW5nLCBib3JkZXItd2lkdGggc2VlbSB0b1xuICogYmVoYXZlIHdpdGhvdXQgYW55IHByb2JsZW1zLiBDdXJpb3VzbHksIGxpc3Qtc3R5bGUgd29ya3MgdG9vIHdpdGhvdXQgYW55XG4gKiBzcGVjaWFsIHByb2RkaW5nLlxuICovXG52YXIgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zID0ge1xuICBiYWNrZ3JvdW5kOiB7XG4gICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZVxuICB9LFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IHtcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblk6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgb3V0bGluZVdpZHRoOiB0cnVlLFxuICAgIG91dGxpbmVTdHlsZTogdHJ1ZSxcbiAgICBvdXRsaW5lQ29sb3I6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENhbGxiYWNrUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuX2Fzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogX3Byb2RJbnZhcmlhbnQoJzI0JykgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcyA/IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggOiAwO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAobGVuKSB7XG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9IGxlbjtcbiAgICAgIHRoaXMuX2NvbnRleHRzLmxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzXG4gKiogbW9kdWxlIGlkID0gOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpIDogdm9pZCAwO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIGNyZWF0ZU1hcmt1cEZvclJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSArICc9XCJcIic7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9yUm9vdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FLCAnJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAndXBkYXRlIGF0dHJpYnV0ZScsIHBheWxvYWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELCAncmVtb3ZlIGF0dHJpYnV0ZScsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQ7XG4gIHZhciBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXg7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsOiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2YoeyBtaXhpbnM6IG51bGwgfSk7XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBob3N0IGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHRUeXBlcyk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuLy8gbm9vcFxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgb25seSBpbiBfX0RFVl9fXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSBgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyBkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzMnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzQnLCBuYW1lKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICB2YXIgaXNNaXhpblZhbGlkID0gdHlwZW9mU3BlYyA9PT0gJ29iamVjdCcgJiYgc3BlYyAhPT0gbnVsbDtcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaXNNaXhpblZhbGlkLCAnJXM6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gaW5jbHVkZSBhIG1peGluIHRoYXQgaXMgZWl0aGVyIG51bGwgJyArICdvciBub3QgYW4gb2JqZWN0LiBDaGVjayB0aGUgbWl4aW5zIGluY2x1ZGVkIGJ5IHRoZSBjb21wb25lbnQsICcgKyAnYXMgd2VsbCBhcyBhbnkgbWl4aW5zIHRoZXkgaW5jbHVkZSB0aGVtc2VsdmVzLiAnICsgJ0V4cGVjdGVkIG9iamVjdCBidXQgZ290ICVzLicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJywgc3BlYyA9PT0gbnVsbCA/IG51bGwgOiB0eXBlb2ZTcGVjKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBjbGFzcyBvciBmdW5jdGlvbiBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc1JykgOiB2b2lkIDA7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzYnKSA6IHZvaWQgMDtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBhdXRvQmluZFBhaXJzID0gcHJvdG8uX19yZWFjdEF1dG9CaW5kUGFpcnM7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmUuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID0gaXNGdW5jdGlvbiAmJiAhaXNSZWFjdENsYXNzTWV0aG9kICYmICFpc0FscmVhZHlEZWZpbmVkICYmIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgYXV0b0JpbmRQYWlycy5wdXNoKG5hbWUsIHByb3BlcnR5KTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUuXG4gICAgICAgICAgIShpc1JlYWN0Q2xhc3NNZXRob2QgJiYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc3Jywgc3BlY1BvbGljeSwgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAhIWlzUmVzZXJ2ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkIHByb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc4JywgbmFtZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OScsIG5hbWUpIDogdm9pZCAwO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBfcHJvZEludmFyaWFudCgnODAnKSA6IHZvaWQgMDtcblxuICBmb3IgKHZhciBrZXkgaW4gdHdvKSB7XG4gICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAhKG9uZVtrZXldID09PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvIGdldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBfcHJvZEludmFyaWFudCgnODEnLCBrZXkpIDogdm9pZCAwO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIHZhciBwYWlycyA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRQYWlycztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgIHZhciBtZXRob2QgPSBwYWlyc1tpICsgMV07XG4gICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAqIHRoZXJlZm9yZSBub3QgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2Rlcm4gUmVhY3RDb21wb25lbnQuXG4gKi9cbnZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFRPRE86IFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGJlY2F1c2Ugc3RhdGUgc2hvdWxkIGFsd2F5cyBrZWVwIGEgY29uc2lzdGVudFxuICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5fYXNzaWduKFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q2xhc3NNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDbGFzc1xuICovXG52YXIgUmVhY3RDbGFzcyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0aGlzIGluc3RhbmNlb2YgQ29uc3RydWN0b3IsICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICsgJ0pTWCBpbnN0ZWFkLiBTZWU6IGh0dHBzOi8vZmIubWUvcmVhY3QtbGVnYWN5ZmFjdG9yeScpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFN0YXRlLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzgyJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IF9wcm9kSW52YXJpYW50KCc4MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudEZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHtcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHNlbGVjdGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXG4gKiBAcGFyYW0geyp9IHByb3BWYWx1ZSBBIHN0cmluZ2FibGUgKHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ2FibGVzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoaW5zdCwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wcyhpbnN0LCBwcm9wcyksIHtcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXG4gICAgfTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGdldFNlbGVjdFZhbHVlQ29udGV4dDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBSZWFjdERPTU9wdGlvbiBsb29rcyBhdCB0aGlzIGluaXRpYWwgdmFsdWUgc28gdGhlIGluaXRpYWwgZ2VuZXJhdGVkXG4gICAgLy8gbWFya3VwIGhhcyBjb3JyZWN0IGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuICAgIHJldHVybiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICB9LFxuXG4gIHBvc3RVcGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gICAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB3YXNNdWx0aXBsZSA9IGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IHRydWU7XG4gIH1cbiAgUmVhY3RVcGRhdGVzLmFzYXAodXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlDb21wb25lbnRGYWN0b3J5O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5OiBmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGVtcHR5Q29tcG9uZW50RmFjdG9yeSA9IGZhY3Rvcnk7XG4gIH1cbn07XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBlbXB0eUNvbXBvbmVudEZhY3RvcnkoaW5zdGFudGlhdGUpO1xuICB9XG59O1xuXG5SZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbiA9IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RmVhdHVyZUZsYWdzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEhvc3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZ2VuZXJpY0NvbXBvbmVudENsYXNzID0gbnVsbDtcbi8vIFRoaXMgcmVnaXN0cnkga2VlcHMgdHJhY2sgb2Ygd3JhcHBlciBjbGFzc2VzIGFyb3VuZCBob3N0IHRhZ3MuXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgX2Fzc2lnbih0YWdUb0NvbXBvbmVudENsYXNzLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBob3N0IGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IF9wcm9kSW52YXJpYW50KCcxMTEnLCBlbGVtZW50LnR5cGUpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0ge1xuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEhvc3RDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NQ29udGFpbmVySW5mbyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db250YWluZXJJbmZvJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoJy4vUmVhY3RNYXJrdXBDaGVja3N1bScpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIFJPT1RfQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIG1hcmtlck5hbWU7XG4gIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICB2YXIgd3JhcHBlZEVsZW1lbnQgPSB3cmFwcGVySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB0eXBlID0gd3JhcHBlZEVsZW1lbnQudHlwZTtcbiAgICBtYXJrZXJOYW1lID0gJ1JlYWN0IG1vdW50OiAnICsgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSk7XG4gICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICB9XG5cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh3cmFwcGVySW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBudWxsLCBSZWFjdERPTUNvbnRhaW5lckluZm8od3JhcHBlckluc3RhbmNlLCBjb250YWluZXIpLCBjb250ZXh0LCAwIC8qIHBhcmVudERlYnVnSUQgKi9cbiAgKTtcblxuICBpZiAobWFya2VyTmFtZSkge1xuICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHdyYXBwZXJJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IHdyYXBwZXJJbnN0YW5jZTtcbiAgUmVhY3RNb3VudC5fbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCB3cmFwcGVySW5zdGFuY2UsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi9cbiAgIXNob3VsZFJldXNlTWFya3VwICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQpO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgc2FmZWx5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCgpO1xuICB9XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlLCBzYWZlbHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoKCk7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIGlmIChyb290RWwpIHtcbiAgICB2YXIgaW5zdCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCk7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5faG9zdFBhcmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIFJlYWN0IERPTSBlbGVtZW50IGFuZFxuICogaXQgaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBoYXMgYmVlbiByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3RcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsICYmIGlzUmVhY3ROb2RlKHJvb3RFbCkgJiYgIVJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHJvb3RFbCkpO1xufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIFJlYWN0IG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBSZWFjdCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1JlYWN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpICYmIChub2RlLmhhc0F0dHJpYnV0ZShST09UX0FUVFJfTkFNRSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RSb290SW5zdGFuY2VJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICB2YXIgcHJldkhvc3RJbnN0YW5jZSA9IHJvb3RFbCAmJiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICByZXR1cm4gcHJldkhvc3RJbnN0YW5jZSAmJiAhcHJldkhvc3RJbnN0YW5jZS5faG9zdFBhcmVudCA/IHByZXZIb3N0SW5zdGFuY2UgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgdmFyIHJvb3QgPSBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3QgPyByb290Ll9ob3N0Q29udGFpbmVySW5mby5fdG9wTGV2ZWxXcmFwcGVyIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFJvb3RDb3VudGVyID0gMTtcbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdElEID0gdG9wTGV2ZWxSb290Q291bnRlcisrO1xufTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhpcy5wcm9wcyBpcyBhY3R1YWxseSBhIFJlYWN0RWxlbWVudFxuICByZXR1cm4gdGhpcy5wcm9wcztcbn07XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcblxuICBUb3BMZXZlbFdyYXBwZXI6IFRvcExldmVsV3JhcHBlcixcblxuICAvKipcbiAgICogVXNlZCBieSBkZXZ0b29scy4gVGhlIGtleXMgYXJlIG5vdCBpbXBvcnRhbnQuXG4gICAqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS4gSG9va2VkIGJ5IGhvb2tzIVxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNycpIDogdm9pZCAwO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIGZhbHNlKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuXG4gICAgdmFyIHdyYXBwZXJJRCA9IGNvbXBvbmVudEluc3RhbmNlLl9pbnN0YW5jZS5yb290SUQ7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFt3cmFwcGVySURdID0gY29tcG9uZW50SW5zdGFuY2U7XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBSZWFjdEluc3RhbmNlTWFwLmhhcyhwYXJlbnRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzM4JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssICdSZWFjdERPTS5yZW5kZXInKTtcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6XG4gICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYW4gZWxlbWVudFxuICAgIG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzM5JywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgXFwnZGl2XFwnLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChcXCdkaXZcXCcpIG9yIDxkaXYgLz4uJyA6IHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/ICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY2xhc3MgbGlrZSBGb28sIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KEZvbykgb3IgPEZvbyAvPi4nIDogbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IFJlYWN0RWxlbWVudChUb3BMZXZlbFdyYXBwZXIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG5leHRFbGVtZW50KTtcblxuICAgIHZhciBuZXh0Q29udGV4dDtcbiAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcGFyZW50SW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gICAgICBuZXh0Q29udGV4dCA9IHBhcmVudEluc3QuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50SW5zdC5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcztcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgdXBkYXRlZENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9IHJlYWN0Um9vdEVsZW1lbnQgJiYgISFpbnRlcm5hbEdldElEKHJlYWN0Um9vdEVsZW1lbnQpO1xuICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKCFjb250YWluZXJIYXNSZWFjdE1hcmt1cCB8fCByZWFjdFJvb3RFbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciByb290RWxlbWVudFNpYmxpbmcgPSByZWFjdFJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAocm9vdEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgaWYgKGludGVybmFsR2V0SUQocm9vdEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdEVsZW1lbnRTaWJsaW5nID0gcm9vdEVsZW1lbnRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFJldXNlTWFya3VwID0gY29udGFpbmVySGFzUmVhY3RNYXJrdXAgJiYgIXByZXZDb21wb25lbnQgJiYgIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkO1xuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgbmV4dENvbnRleHQpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5yZW5kZXJcbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlcjogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20udW5tb3VudGNvbXBvbmVudGF0bm9kZVxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQwJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIW5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlKGNvbnRhaW5lciksICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBnZXRUb3BMZXZlbFdyYXBwZXJJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGlmICghcHJldkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGNvbnRhaW5lci5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCAnICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcHJldkNvbXBvbmVudC5faW5zdGFuY2Uucm9vdElEXTtcbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBwcmV2Q29tcG9uZW50LCBjb250YWluZXIsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIGluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBfcHJvZEludmFyaWFudCgnNDEnKSA6IHZvaWQgMDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCByb290RWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uIHRoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3Ugc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyBhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogX3Byb2RJbnZhcmlhbnQoJzQyJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0IGF0dGVtcHRlZCB0byByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICsgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICsgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgKyAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgKyAnb3Igc2VydmVyOlxcbiVzJywgZGlmZmVyZW5jZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0IHlvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzIHdpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzQzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShjb250YWluZXIsIG1hcmt1cCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKGluc3RhbmNlLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBob3N0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIGlmIChob3N0Tm9kZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKGhvc3ROb2RlLl9kZWJ1Z0lELCAnbW91bnQnLCBtYXJrdXAudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vZGVUeXBlc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb2RlVHlwZXMgPSB7XG4gIEhPU1Q6IDAsXG4gIENPTVBPU0lURTogMSxcbiAgRU1QVFk6IDIsXG5cbiAgZ2V0VHlwZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkVNUFRZO1xuICAgIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICBpZiAodHlwZW9mIG5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkhPU1Q7XG4gICAgICB9XG4gICAgfVxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIG5vZGU6ICVzJywgbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMjYnLCBub2RlKSA6IHZvaWQgMDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vZGVUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb2RlVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG4vKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuLyoqXG4gKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyIHdlIGRvbid0IHVzZSByZWFsXG4gKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gJyc7XG59XG4vLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG5Qcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICBpZiAoIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArICdhbmQgd2lsbCBub3Qgd29yayBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBZb3UgbWF5IGJlICcgKyAnc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgbGlicmFyeS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgZm9yIGRldGFpbHMuJywgcHJvcEZ1bGxOYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUmVxdWlyZWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCB3YXMgbm90IHNwZWNpZmllZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gQU5PTllNT1VTO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFZlcnNpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjMuMSc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiBfcHJvZEludmFyaWFudCgnMzAnKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNoZWNrUmVhY3RUeXBlU3BlY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qc1xuICoqIG1vZHVsZSBpZCA9IDExN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvckVhY2hBY2N1bXVsYXRlZFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xuXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KSB7XG4gIHZhciB0eXBlO1xuXG4gIHdoaWxlICgodHlwZSA9IGluc3QuX3JlbmRlcmVkTm9kZVR5cGUpID09PSBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEUpIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuSE9TVCkge1xuICAgIHJldHVybiBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuY29uc3RydWN0KGVsZW1lbnQpO1xufTtcbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQuTWl4aW4sIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbnZhciBuZXh0RGVidWdJRCA9IDE7XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiB2b2lkIDA7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBuZXh0RGVidWdJRCsrIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzVGV4dElucHV0RWxlbWVudFxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG5cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0VGV4dENvbnRlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIHNldElubmVySFRNTChub2RlLCBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUZXh0Q29udGVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvZm9jdXNOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY29tcG9zZTtcbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmVzdCA9IGZ1bmNzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHY6IGZ1bmN0aW9uIHYoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3QucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGNvbXBvc2VkLCBmKSB7XG4gICAgICAgICAgICByZXR1cm4gZihjb21wb3NlZCk7XG4gICAgICAgICAgfSwgbGFzdC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGlmICh0eXBlb2YgX3JldCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQudjtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jb21wb3NlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkFjdGlvblR5cGVzID0gdW5kZWZpbmVkO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjcmVhdGVTdG9yZTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUgPSByZXF1aXJlKCdzeW1ib2wtb2JzZXJ2YWJsZScpO1xuXG52YXIgX3N5bWJvbE9ic2VydmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sT2JzZXJ2YWJsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIEFjdGlvblR5cGVzID0gZXhwb3J0cy5BY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtpbml0aWFsU3RhdGVdIFRoZSBpbml0aWFsIHN0YXRlLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAqIHByZXZpb3VzbHkgc2VyaWFsaXplZCB1c2VyIHNlc3Npb24uXG4gKiBJZiB5b3UgdXNlIGBjb21iaW5lUmVkdWNlcnNgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlciBmdW5jdGlvbiwgdGhpcyBtdXN0IGJlXG4gKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuaGFuY2VyIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gaW5pdGlhbFN0YXRlO1xuICAgIGluaXRpYWxTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpIHtcbiAgICBpZiAobmV4dExpc3RlbmVycyA9PT0gY3VycmVudExpc3RlbmVycykge1xuICAgICAgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG5cbiAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgbmV4dExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG5cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHsgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG4gICAgICB9XG4gICAgfSwgX3JlZltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMltfc3ltYm9sT2JzZXJ2YWJsZTJbXCJkZWZhdWx0XCJdXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L2xpYi9jcmVhdGVTdG9yZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3YXJuaW5nO1xuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRQUFBUUFCQUFELzJ3Q0VBQWtHQndnSEJna0lCd2dLQ2drTERSWVBEUXdNRFJzVUZSQVdJQjBpSWlBZEh4OGtLRFFzSkNZeEp4OGZMVDB0TVRVM09qbzZJeXMvUkQ4NFF6UTVPamNCQ2dvS0RRd05HZzhQR2pjbEh5VTNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTnpjM056YzNOemMzTi8vQUFCRUlBRm9BV2dNQklnQUNFUUVERVFIL3hBQWNBQUFDQWdNQkFRQUFBQUFBQUFBQUFBQUdCd0FGQVFJRUF3ai94QUJERUFBQkFnVUFCd01JQndRTEFBQUFBQUFCQWdNQUJBVUdFUWNTSVRGQlVXRVRJbkVVRmpJemdaR2h3UWdWSTBKaXNmQlNZNkxSSmpSRFJGTnpkSUtTc3ZIL3hBQWJBUUFDQXdFQkFRQUFBQUFBQUFBQUFBQUNCQUVEQlFZQUIvL0VBQ2tSQUFJQ0FnRUNCUU1GQUFBQUFBQUFBQUFCQWdNRUVTRVNNUVVHRTFHaEZVRnhGQ0lqTW1ILzJnQU1Bd0VBQWhFREVRQS9BSEpFaVFLWHpkL20raGlRcHN1WjZ1enAxSlNUVC8zVnlTUGowQUpGcmVpc3RianVTazIxSmVWVm1jUXdnK2dqZXR3OGtwM21CRk53WHRkU1FxMktNM1I1QlIyVHRVOVlzYzB0alB6SFdPNjFOSHdibkJYcndkVFZxODVoUkx2ZWFsOGJrb1R1MmM4Yk9IT0QwaUZiYm12NmxrWUlYS05IVlZuc0t1RzlheE5MNHR5cXV3UjdobjhoR0RvZHRnOTV4MnByWCsyWnZiK1VNVXhvWXk3cjd2Y3NTUXZGYU0zSk1hMUN1MnV5QzAraUZQOEFhSXoxVHN6SGtaN1NKYlIxcDZWbExsa0Vla3VXSFpUQUhQVnhnK0FCaGpLanpVTThJVitwMzFQbmxFK21tVU5xM3BSYm5TcEVnK3B1YlI2MlRtQnFQTm5qczQrSWdpZ1B1Nng2ZmNKOHFaVXFuMWR2dk1WQ1c3cmlWRGRyWXhyRDQ4akhMWmwzVDRxUnRpOFVKWXJiWSt4ZlQ2dWRTUHZKUDdYNTlOMGJHRjRoVmxMUzRmc1ZUcmNRNmlSSWthSlVWVjAxNld0cWd6ZFZtOEZEQ082ak9DNHM3RXBIaWZuQS9vMHR1WmJRNWRGeER0YTlVeDJoS3gvVjJqdFMya0gwZG1Namh1NFJYM00zNTJhU2FYYnlnVlU2a0krc0owWTdxM0RqVVNmZVBZb3d5eHVoUEl0MCtsRnNJOEhvTVlnRzBwWDJMS3B6SGt6TGI5UW15UXkyNW5WU0J2VXJHM2lOa0cyWStkdnBFTFdiMWswRW5VVFRrRkk0YlhITW45Y29HRFVub2w4RFUwWTN5bTlhVSt0OWxERS9LS1NsOXR2T3FRYzZxazU0SEIyZElNVENCK2pvNDRtNUtvMk05bXFUQlVPb1dNZm1ZZnhqUHpZcU10SU9JQzZXcnVmdE8za3JrRkpUVUp0enNtRktTRmRtQU1xWGc3OERZT3BFRCtoMi9aKzRYNXFrMXQ4UHpUYU8yWWUxQWtyVG5Da25BQTJaQjlwNVJVL1NQU3Z0NkNyQjFOVjhBOWNvZ1gwSEJadjZYS053bDNTdncxZjU0aWYwOWJ3bTJ1ZE5udHZxUG84d01YMWF6Tnkwb0lRcnNhakxIdFpLYVNjS2FjRzBiZVJ4OCtFRThhSzNSeVN2blJZcklQVFJlMG53RHVqcTVYYmhvcWtWQWRuV0tlc3kwKzJjQWh4T3pXd05tM0hEWURrUVZiWVc5V0htdHBNcGxYYU9wSTEwZVJUZzNEdGRtb3J4T3orS0dSdDVIM1I5QXc4bU9UVEcxZmNTbkhwbG9BZEZ5ZkxxemQ5ZFdNcW1xbXBoQ3YzYmVRTWU4ZTZHR0RDNzBIa3Fza3JYNnhjODhwZmprUXdzeGo1RjM4MGkrSzROOHdyZE4xa3p0eHNTZFVvekhiemtva3RPTXA5Snhzbkl4eklPZG5Vd3pFUElXdFNFbkpRY0s2SGZIcG1QUXlYVzludWtXbWhXekoyMjZmT1Q5WGFMTTVPNnFVc0t4ck50cHp2NmtuZHd3SVpSakdZd1RDdVJrT3lUa3lVdEFucEt0QVhoUVBKRzNVdFRiS3c3THVMSGQxdHhCeHdJK1VVV2lyUjg5YVJtWjZxT3RPVDc2ZXpTbG81UzJqT2QvRWs0OTBNY3hvWVRzenJJMHVwZG1Fb3JlekVlWmlQT3BhUVZyT0VnWko1UmpJTVlkejQyV29DdEwwbXFZc2libUc4ZHZKT056TFN1S1NsUUJJOWhNRzFKbkdaK2xTYzRWSE13d2gwNC9Fa0g1d082UUFGV1RYTmJkNUU1K1VWdHBPdWkxYU1BUDdneHgvZHBqcmZMTmpsaXlUKzBtTFhyOXhwb25WNUk1YzFHVU5WVWpWbkNsSEpDL1JQOEpnK2NXVXRxVUJuQXpqbkM5bXo1c2FXVVREbmNrTGpsdzBWYmdKaEdNZThZL3dDVU1IT1JGZmlhOUhJMit6NUNyNWlWVnV1dU5TTXV4TjQ3ZGJmYmF3L3ROYnZLUGlGS09mWWVNWE90SEZOeWJjeXdHc3FiS01GcHhzNFUyb2JpbjlZTzQ1QklpdVhYQlNscFp1QW9sa0hZaWUzUzYraWlmVnE2SzJIZ1R3WDYzZHpEdjdCYTBYaE1ZalZLMHFTbFNWQlNWYlFRY2d4Q1lSc3RhNFpLUmt4b1RFSjZ4VlZDdVNrck1pVGFLcHFmVU83S1M0MW5CMVZ3UW44U2lCQ3VwMnZVRnNMc2RzMCtsaHNyVmxYQktSdlVlQUhXT0tocGVSVDB0ekFTRnRPT05nSk9RRXBVUWtEd0dCRzBuTFBxY0UxVVNnekJIZGJSdFF5RHZBNW5tcmp3d0k3QUFnYk9lWVV5TFlRZzZseS9jSklFOUswNzVIWWRVSTJyZVFsaElIRXJVQWZobUNXMzZReEowR215cmllK3hLTk5xMmNRZ0Q1UUUzai9BRWl2YTNyWWE3elRMdjFoUEFIMFVJOUVIeDJqL2NJWmV0MGp0dkwyTTZzRk9YZVhJcGZMY2djdjIyeGM5dk95YlMrem5XVkIrVGR6alVlVHUyOEFkM3RqanNDNS9PS2txUk5nTlZhU1YyRSt3ZGlrT0RabkhJNFB0eU9FRjhBbDZXdFBOMVZOMTJpRW9yTFNjVEV0OTJkYjRnL2l3QjQ0SEVDSC9FY0paVldsM1hZR3VmU3cwekdyamFIVUtiY1NsYUZEQ2txR1FSeUlnY3RHOEtmYzBzb002MHZQTTdKbVNlMk9OS0cvWnhIWDM0T3lDTE1jSGQ2bVBOd210TkRhMCt3TXZXWEtzcks2RlVLaFJWRTUxSkozN0VuL0FDbFpTUFppT2MwUzhVQW9idk5wU2VCZHBhQ3Iya0t4QmRtTVpndnF0eVhPbitVbWU5TkFvM2FWUm1jZlhsMTFTY1Q5NW1XMVpWQ3VoMU85ajJ4ZlV1bFNGSVlMRk5sR3Bac25XVUcwNDFqekozazlUSFlZd1RDZVI0aGZhdWx5NDlsd3ZnSlFTSkZWY3RjbExlbzh4VTU1WDJiUTdxQWRyaXVDUjFNUzRhL1RiZGtGVHRWbUV0TmpZaE85VGg1SkhFd0xXL1E2bGVsWVp1TzZaY3kxTGx6clUybHIzay80amcvV2VnRzEzd2p3aXpOc1ZrMXFDK2Y4UU50aWlpeTBZVVNiWlluTGtyU2NWYXRLRHFra1k3Rm5laEhUaDhCd2c1aWVNU1BwRVlxS1NRZzN0a2lSSWtFeUFUdXl3NmJYNWdWQ1hjZHBsWlJ0YnFFcDNWNXhnYTJNYTJ6QTU0NHhRaXJYdmF3N092VWNWeVNUdW5xYjZ6SDRtK2ZzQTZ3eVR2alBLRk1uRG95WTlOc2RoeG00OWdCa2RKOXFUUjFIcWd1VGU0dHpiS2tGUGljRWZHTFFYbmJCR1JYNmRqL1VKaStxTkxwOCswZkxwQ1ZtZGl2WE1wWHc2aUF0eTJhQUhnQlE2WmpsNUczL0FDakRuNVl4WlBpVFJlcjVIdFA2U2JTazlpcXcyOHJPeE11aFRoUHRBeDhZcnZPdTVyaSt6dEMzSG1XbGJQckNxL1pJVDFDZVBzejRRYlVPaVVtVGxFcmxLWEpNTEc1VFV1aEorQWkxenNQakYyUDVld3FkU2E2dnlCSytUQWUzOUhqTEUraXNYVE91VnlyREJTcDhaWlpPZnVJUEwvd0NEaUpFamZqRlJXa2lsdHZ1U0pFaVFSQi8vOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9TbWlsZXlGYWNlLmpwZWdcbiAqKiBtb2R1bGUgaWQgPSAxMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydCBjb25zdCBzZWxlY3RUdXJ0bGUgPSAodHVydGxlKSA9PiB7XG5cbiAgLy8gY29uc29sZS5sb2coXCJZb3UgY2xpY2tlZCBvbiB1c2VyOiBcIiwgXG4gIC8vIFx0dXNlci5maXJzdCArIFwiLCBcIiArIFxuICAvLyBcdHVzZXIuZGVzY3JpcHRpb25cbiAgLy8gKTtcbiAgcmV0dXJuIHtcbiAgXHR0eXBlOiBcIlRVUlRMRV9TRUxFQ1RFRFwiLFxuICBcdHBheWxvYWQ6IHR1cnRsZVxuICB9O1xufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9hY3Rpb25zL3R1cnRsZS5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBzZWxlY3RVc2VyID0gKHVzZXIpID0+IHtcblxuICAvLyBjb25zb2xlLmxvZyhcIllvdSBjbGlja2VkIG9uIHVzZXI6IFwiLCBcbiAgLy8gXHR1c2VyLmZpcnN0ICsgXCIsIFwiICsgXG4gIC8vIFx0dXNlci5kZXNjcmlwdGlvblxuICAvLyApO1xuICByZXR1cm4ge1xuICBcdHR5cGU6IFwiVVNFUl9TRUxFQ1RFRFwiLFxuICBcdHBheWxvYWQ6IHVzZXJcbiAgfTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvYWN0aW9ucy91c2VyLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFR1cnRsZUxpc3QgZnJvbSAnLi4vY29udGFpbmVycy90dXJ0bGUtbGlzdCdcbmltcG9ydCBUdXJ0bGVEZXRhaWwgZnJvbSAnLi4vY29udGFpbmVycy90dXJ0bGUtZGV0YWlsJ1xuLy9yZXF1aXJlKCcuLi8uLi9zY3NzL3N0eWxlLnNjc3MnKTtcblxuY29uc3QgQ29tcFR1cnRsZSA9ICgpID0+IChcbiAgPGRpdj5cbiAgICA8aDM+TmluamEgVHVydGxlcyBMaXN0OjwvaDM+XG4gICAgPFR1cnRsZUxpc3QgLz5cbiAgICA8aHIgLz5cbiAgICA8aDM+QmlvOjwvaDM+XG4gICAgPFR1cnRsZURldGFpbCAvPlxuICA8L2Rpdj5cbik7XG5leHBvcnQgZGVmYXVsdCBDb21wVHVydGxlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbXBvbmVudHMvY29tcC10dXJ0bGUuanNcbiAqKi8iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgVXNlckxpc3QgZnJvbSAnLi4vY29udGFpbmVycy91c2VyLWxpc3QnXG5pbXBvcnQgVXNlckRldGFpbCBmcm9tICcuLi9jb250YWluZXJzL3VzZXItZGV0YWlsJ1xuLy9yZXF1aXJlKCcuLi8uLi9zY3NzL3N0eWxlLnNjc3MnKTtcblxuY29uc3QgQ29tcFVzZXIgPSAoKSA9PiAoXG4gICA8ZGl2PlxuICAgICA8aDM+SW5mbHVlbnRpYWwgUGVyc29ucyBMaXN0OjwvaDM+XG4gICAgIDxVc2VyTGlzdCAvPlxuICAgICA8aHIvPlxuICAgICA8aDM+QmlvOjwvaDM+XG4gICAgIDxVc2VyRGV0YWlsIC8+XG4gICA8L2Rpdj5cbik7XG5leHBvcnQgZGVmYXVsdCBDb21wVXNlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb21wb25lbnRzL2NvbXAtdXNlci5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBTbWlsZXlGYWNlIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL1NtaWxleUZhY2UuanBlZ1wiXG5cbi8vYWx0ZXJuYXRpdmUgY29kZVxuQGNvbm5lY3QoKHN0YXRlKSA9PiB7ICAgIFxuICByZXR1cm4geyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICB0dXJ0bGU6IHN0YXRlLmFjdGl2ZVR1cnRsZVxuICB9O1xufSlcblxuY2xhc3MgVHVydGxlRGV0YWlsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy50dXJ0bGUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxoND5cbiAgICAgICAgICAgUGxhY2UgdGhlIGN1cnNvciBvdmVyIHlvdXIgZmF2b3JpdGUgTmluamEgYW5kIGNsaWNrLi4uXG4gICAgICAgIDwvaDQ+KTtcbiAgICB9XG4gIFx0cmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxpbWcgY2xhc3M9XCJpbWctcmVzcG9uc2l2ZVwiIHNyYz17dGhpcy5wcm9wcy50dXJ0bGUuaW1hZ2V9IHdpZHRoPVwiMjUwXCIgYWx0PXtTbWlsZXlGYWNlfSAvPlxuICAgICAgICA8ZW0+XG4gICAgICAgICAgPGg0Pnt0aGlzLnByb3BzLnR1cnRsZS5uYW1lfSBha2EgXCJ7dGhpcy5wcm9wcy50dXJ0bGUuYWthfVwiPC9oND5cbiAgICAgICAgICA8aDQ+QWdlOiAmbmJzcDsmbmJzcDt7dGhpcy5wcm9wcy50dXJ0bGUuYWdlfTwvaDQ+XG4gICAgICAgICAgPGg0PkRlc2NyaXB0aW9uOiAmbmJzcDsmbmJzcDt7dGhpcy5wcm9wcy50dXJ0bGUuZGVzY3JpcHRpb259PC9oND5cbiAgICAgICAgICA8aDU+KEltYWdlcyBhbmQgZGVzY3JpcHRpb25zIGNvdXJ0ZXN5IG9mIFdpa2lwZWRpYSk8L2g1PlxuICAgICAgICA8L2VtPlxuICAgICAgPC9kaXY+XG4gIFx0KTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVHVydGxlRGV0YWlsO1xuLy8gZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdHVydGxlOiBzdGF0ZS5hY3RpdmVUdXJ0bGVcbi8vICAgfTtcbi8vIH1cbi8vIGV4cG9ydCBkZWZhdWx0IGNvbm5lY3QobWFwU3RhdGVUb1Byb3BzKShUdXJ0bGVEZXRhaWwpO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZGV2L2pzL2NvbnRhaW5lcnMvdHVydGxlLWRldGFpbC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IHsgc2VsZWN0VHVydGxlIH0gZnJvbSAnLi4vYWN0aW9ucy90dXJ0bGUnXG5cbmNsYXNzIFR1cnRsZUxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjcmVhdGVMaXN0SXRlbXMoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMucHJvcHMudHVydGxlcy5tYXAodHVydGxlID0+IHtcbiAgXHQgICAgcmV0dXJuICggICBcbiAgICAgICAgICAgIDxsaSBrZXk9e3R1cnRsZS5pZH0gb25DbGljaz17KCkgPT4gdGhpcy5wcm9wcy5zZWxlY3RUdXJ0bGUodHVydGxlKX0gPiBcbiAgICAgICAgICAgIHt0dXJ0bGUubmFtZX0gXG4gICAgICAgICAgICA8L2xpPiAgICAgXG4gIFx0ICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICBcdHJldHVybiAoXG4gICAgICA8aDQ+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7dGhpcy5jcmVhdGVMaXN0SXRlbXMoKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvaDQ+XG4gIFx0KTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdHVydGxlczogc3RhdGUudHVydGxlc1xuICB9O1xufVxuZnVuY3Rpb24gbWF0Y2hEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIChcbiAgICBiaW5kQWN0aW9uQ3JlYXRvcnMoe3NlbGVjdFR1cnRsZTogc2VsZWN0VHVydGxlfSwgZGlzcGF0Y2gpXG4gICk7XG59XG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWF0Y2hEaXNwYXRjaFRvUHJvcHMpKFR1cnRsZUxpc3QpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvY29udGFpbmVycy90dXJ0bGUtbGlzdC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCdcbmltcG9ydCBTbWlsZXlGYWNlIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL1NtaWxleUZhY2UuanBlZ1wiXG5cbi8vYWx0ZXJuYXRpdmUgY29kZVxuQGNvbm5lY3QoKHN0YXRlKSA9PiB7ICAgIFxuICByZXR1cm4geyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICB1c2VyOiBzdGF0ZS5hY3RpdmVVc2VyXG4gIH07XG59KVxuXG5jbGFzcyBVc2VyRGV0YWlsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy51c2VyKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8aDQ+XG4gICAgICAgICAgUGxhY2UgdGhlIGN1cnNvciBvdmVyIHlvdXIgZmF2b3JpdGUgZmFtb3VzIHBlcnNvbiBhbmQgc2VsZWN0Li4uXG4gICAgICAgIDwvaDQ+KTtcbiAgICB9XG4gIFx0cmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxpbWcgY2xhc3M9XCJpbWctcmVzcG9uc2l2ZVwiIHNyYz17dGhpcy5wcm9wcy51c2VyLmltYWdlfSB3aWR0aD1cIjMwMFwiIGFsdD17U21pbGV5RmFjZX0gLz5cbiAgICAgICAgPGVtPlxuICAgICAgICAgICA8aDQ+e3RoaXMucHJvcHMudXNlci5uYW1lfSB7dGhpcy5wcm9wcy51c2VyLmxhc3R9PC9oND5cbiAgICAgICAgICAgPGg0PkJvcm46ICZuYnNwOyZuYnNwO3t0aGlzLnByb3BzLnVzZXIuYm9ybk1vbnRofSB7dGhpcy5wcm9wcy51c2VyLmJvcm5EYXl9LCB7dGhpcy5wcm9wcy51c2VyLmJvcm5ZZWFyfXt0aGlzLnByb3BzLnVzZXIuYWdlWzJdfTwvaDQ+XG4gICAgICAgICAgIDxoND5Xb3VsZCBoYXZlIGJlZW4gYXJvdW5kIHt0aGlzLnByb3BzLnVzZXIuYWdlWzBdfSB5ZWFycyBhbmQge3RoaXMucHJvcHMudXNlci5hZ2VbMV19IG1vbnRocyBvbGQgbm93LCBpZiB3ZXJlIHN0aWxsIGFsaXZlLjwvaDQ+XG4gICAgICAgICAgIDxoND5EZXNjcmlwdGlvbjogJm5ic3A7Jm5ic3A7e3RoaXMucHJvcHMudXNlci5kZXNjcmlwdGlvbn08L2g0PlxuICAgICAgICAgICA8aDU+KFBob3RvcyBhbmQgZGVzY3JpcHRpb25zIGNvdXJ0ZXN5IG9mIFdpa2lwZWRpYSk8L2g1PlxuICAgICAgICA8L2VtPlxuICAgICAgPC9kaXY+XG4gIFx0KTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVXNlckRldGFpbDtcblxuLy8gZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgdXNlcjogc3RhdGUuYWN0aXZlVXNlclxuLy8gICB9O1xuLy8gfVxuLy8gZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMpKFVzZXJEZXRhaWwpO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvY29udGFpbmVycy91c2VyLWRldGFpbC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4J1xuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuaW1wb3J0IHsgc2VsZWN0VXNlciB9IGZyb20gJy4uL2FjdGlvbnMvdXNlcidcbi8vIGltcG9ydCBzdG9yZSBmcm9tICcuLi9zdG9yZSdcblxuLy8gc3RvcmUuc3Vic2NyaWJlKCAoKSA9PiB7XG4vLyBjb25zb2xlLmxvZyhcIlN0b3JlIGNoYW5nZWRcIiwgc3RvcmUuZ2V0U3RhdGUoKSlcbi8vIH0pO1xuLy8gLy9iZWxvdyBzbmlwcGV0IGlzIGEgc2FtcGxlIG9mIGhvdyB0byBhZGQgYSBzdGF0ZSBpbnRvIHRoZSBjb2RlXG4vLyAvL2J1dCBzaG91bGQgYmUgbWF0Y2hlZCBieSBhIGNvcnJlc3BvbmRpbmcgcmVkdWNlciBmdW5jdGlvbiB0byByZWNvcmQgYW5kIHVwZGF0ZSB0aGlzIG5ldyBzdGF0ZVxuLy8gc3RvcmUuZGlzcGF0Y2goe3R5cGU6IFwiQUREX1VTRVJfTkFNRVwiLCBwYXlsb2FkOiBcIlJvZFwifSlcbi8vIHN0b3JlLmRpc3BhdGNoKHt0eXBlOiBcIkFERF9VU0VSX0FHRVwiLCBwYXlsb2FkOiAyM30pXG5cbmNsYXNzIFVzZXJMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY3JlYXRlTGlzdEl0ZW1zKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLnByb3BzLnVzZXJzLm1hcCh1c2VyID0+IHtcbiAgXHQgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxsaSBrZXk9e3VzZXIuaWR9IG9uQ2xpY2s9eygpID0+IHRoaXMucHJvcHMuc2VsZWN0VXNlcih1c2VyKX0gPiBcbiAgICAgICAgICAgICAge3VzZXIubmFtZX0ge3VzZXIubGFzdH1cbiAgICAgICAgICAgIDwvbGk+XG4gIFx0ICAgICk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICBcdHJldHVybiAoXG4gICAgICA8aDQ+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7dGhpcy5jcmVhdGVMaXN0SXRlbXMoKX1cbiAgICAgICAgPC91bD5cbiAgICAgIDwvaDQ+XG4gIFx0KTtcbiAgfVxufVxuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdXNlcnM6IHN0YXRlLnVzZXJzXG4gIH07XG59XG5mdW5jdGlvbiBtYXRjaERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4gKFxuICAgIGJpbmRBY3Rpb25DcmVhdG9ycyh7c2VsZWN0VXNlcjogc2VsZWN0VXNlcn0sIGRpc3BhdGNoKVxuICApO1xufVxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hdGNoRGlzcGF0Y2hUb1Byb3BzKShVc2VyTGlzdCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9jb250YWluZXJzL3VzZXItbGlzdC5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFthLGIsY10pIHtcbi8vVGhpcyBjYWxjdWxhdGlvbiBpcyByb3VnaGx5IGFjY3VyYXRlIHRvIG1vbnRocyxhcyB5b3UgY2FuIHNlZS4uLlxudmFyIGQgPSBcIlwiO1xuXG4gIGlmKGI8MCkge1xuICBcdGE9YS0xLFxuICBcdGI9MTItTWF0aC5hYnMoYilcbiAgfVxuICBpZihjPDApIHtcbiAgXHRiPWIrMVxuICB9XG4gIGlmIChiPT09MCAmJiBjPT09MCkge1xuICAgIGQ9XCI6IEhleSwgSGFwcHkgQmlydGhkYXkhISFcIlxuICB9IGVsc2Uge1xuICBcdGQ9XCIuXCJcbiAgfVxuICByZXR1cm4gKFxuICAgIFthLGIsZF1cbiAgKTtcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvYWdlLWNhbGN1bGF0b3IuanNcbiAqKi8iLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQgeyBzeW5jSGlzdG9yeVdpdGhTdG9yZSwgcm91dGVyUmVkdWNlciB9IGZyb20gJ3JlYWN0LXJvdXRlci1yZWR1eCc7XG5pbXBvcnQgUmVkdWNlclVzZXJzIGZyb20gJy4vcmVkdWNlci11c2Vycyc7XG5pbXBvcnQgUmVkdWNlclR1cnRsZXMgZnJvbSAnLi9yZWR1Y2VyLXR1cnRsZXMnO1xuaW1wb3J0IEFjdGl2ZVVzZXJSZWR1Y2VyIGZyb20gJy4vcmVkdWNlci1hY3RpdmUtdXNlcic7XG5pbXBvcnQgQWN0aXZlVHVydGxlUmVkdWNlciBmcm9tICcuL3JlZHVjZXItYWN0aXZlLXR1cnRsZSc7XG5cbmNvbnN0IGFsbFJlZHVjZXJzID0gY29tYmluZVJlZHVjZXJzKHtcbiAgdXNlcnM6IFJlZHVjZXJVc2VycyxcbiAgdHVydGxlczogUmVkdWNlclR1cnRsZXMsXG4gIGFjdGl2ZVVzZXI6IEFjdGl2ZVVzZXJSZWR1Y2VyLFxuICBhY3RpdmVUdXJ0bGU6IEFjdGl2ZVR1cnRsZVJlZHVjZXIsXG4gIHJvdXRpbmc6IHJvdXRlclJlZHVjZXJcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhbGxSZWR1Y2VycztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9yZWR1Y2Vycy9pbmRleC5qc1xuICoqLyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChzdGF0ZT1udWxsLCBhY3Rpb24pIHtcblxuICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICBcbiAgXHRjYXNlIFwiVFVSVExFX1NFTEVDVEVEXCI6XG4gIFx0ICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG4gIFx0ICBicmVhaztcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59ICBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLWFjdGl2ZS10dXJ0bGUuanNcbiAqKi8iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoc3RhdGU9bnVsbCwgYWN0aW9uKSB7XG5cbiAgc3dpdGNoKGFjdGlvbi50eXBlKSB7XG4gICAgXG4gIFx0Y2FzZSBcIlVTRVJfU0VMRUNURURcIjpcbiAgXHQgIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbiAgXHQgIGJyZWFrO1xuICBcdGNhc2UgXCJBRERfVVNFUl9OQU1FXCI6XG4gIFx0ICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG4gIFx0ICBicmVhaztcbiAgXHRjYXNlIFwiQUREX1VTRVJfQUdFXCI6XG4gIFx0ICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG4gIFx0ICBicmVhaztcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59ICBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLWFjdGl2ZS11c2VyLmpzXG4gKiovIiwiaW1wb3J0IExlb25hcmRvIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL2xlb25hcmRvLnBuZ1wiXG5pbXBvcnQgTWljaGFlbGFuZ2VsbyBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9taWNoYWVsYW5nZWxvLnBuZ1wiXG5pbXBvcnQgRG9uYXRlbGxvIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL2RvbmF0ZWxsby5wbmdcIlxuaW1wb3J0IFJhcGhhZWwgZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvcmFwaGFlbC5wbmdcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6IFwiTGVvbmFyZG9cIixcbiAgICAgIGFrYTogXCJMZW9cIixcbiAgICAgIGFnZTogXCJldGVybmFsbHkgPCAyMFwiLFxuICAgICAgaW1hZ2U6IExlb25hcmRvLFxuICAgICAgZGVzY3JpcHRpb246IFwiTGVvbmFyZG8gaXMgdGhlIGNvb2wsIGNvdXJhZ2VvdXMgbGVhZGVyIG9mIHRoZSBOaW5qYSBUdXJ0bGVzIGFuZCBhIGRldm90ZWQgc3R1ZGVudCBvZiBOaW5qdXRzdSwgdXN1YWxseSB3ZWFyaW5nIGEgYmx1ZSBtYXNrIGFuZCB3aWVsZGluZyB0d28ga2F0YW5hcy4gTGVhZGVyIGluIGJsdWUuXCIgXG4gICAgfSxcbiAgICB7XG4gIFx0ICBpZDogMixcbiAgICAgIG5hbWU6IFwiTWljaGFlbGFuZ2Vsb1wiLFxuICAgICAgYWthOiBcIk1pY2tleVwiLFxuICAgICAgYWdlOiBcImV0ZXJuYWxseSA8IDIwXCIsXG4gICAgICBpbWFnZTogTWljaGFlbGFuZ2VsbyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk1pY2hlbGFuZ2VsbyBpcyB0aGUgbW9zdCBjb21pY2FsIG9mIHRoZSBOaW5qYSBUdXJ0bGVzLCB1c3VhbGx5IHdlYXJpbmcgYW4gb3JhbmdlIG1hc2sgYW5kIHdpZWxkaW5nIGEgcGFpciBvZiBudW5jaHVja3MuXCJcbiAgICB9LFxuICAgIHtcbiAgXHQgIGlkOiAzLFxuICAgICAgbmFtZTogXCJEb25hdGVsbG9cIixcbiAgICAgIGFrYTogXCJEb25uaWVcIixcbiAgICAgIGFnZTogXCJldGVybmFsbHkgPCAyMFwiLFxuICAgICAgaW1hZ2U6IERvbmF0ZWxsbyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkRvbmF0ZWxsbyBpcyB0aGUgc2NpZW50aXN0LCBpbnZlbnRvciwgZW5naW5lZXIgYW5kIHRlY2hub2xvZ2ljYWwgZ2VuaXVzIG9mIHRoZSBOaW5qYSBUdXJ0bGVzLCB1c3VhbGx5IHdlYXJpbmcgYSBwdXJwbGUgbWFzayBhbmQgd2llbGRpbmcgYSBiby1zdGFmZi5cIlxuICAgICB9LFxuICAgICB7XG4gICAgICBpZDogNCxcbiAgICAgIG5hbWU6IFwiUmFwaGFlbFwiLFxuICAgICAgYWthOiBcIlJhcGhcIixcbiAgICAgIGFnZTogXCJldGVybmFsbHkgPCAyMFwiLFxuICAgICAgaW1hZ2U6IFJhcGhhZWwsXG4gICAgICBkZXNjcmlwdGlvbjogXCJSYXBoYWVsIGlzIHRoZSBiYWQgYm95IG9mIHRoZSBOaW5qYSBUdXJ0bGVzLCB3ZWFyaW5nIGEgcmVkIG1hc2sgYW5kIHdpZWxkaW5nIGEgcGFpciBvZiBzYWlzLlwiXG4gICAgIH1cbiAgXVxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2Rldi9qcy9yZWR1Y2Vycy9yZWR1Y2VyLXR1cnRsZXMuanNcbiAqKi8iLCJpbXBvcnQgZGFWaW5jaSBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9kYVZpbmNpLmpwZ1wiXG5pbXBvcnQgRWluc3RlaW4gZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9pbWFnZXMvRWluc3RlaW4uanBnXCJcbmltcG9ydCBFdWxlciBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9FdWxlci5qcGdcIlxuaW1wb3J0IExlbWFpdHJlIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL0xlbWFpdHJlLmpwZ1wiXG5pbXBvcnQgTVRlcmVzYSBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9NVGVyZXNhLmpwZ1wiXG5pbXBvcnQgTmV3dG9uIGZyb20gXCIuLi8uLi8uLi9wdWJsaWMvaW1hZ2VzL05ld3Rvbi5qcGdcIlxuaW1wb3J0IFNjaHJvZWRpbmdlciBmcm9tIFwiLi4vLi4vLi4vcHVibGljL2ltYWdlcy9TY2hyb2VkaW5nZXIuanBnXCJcbmltcG9ydCBhZ2VDYWxjIGZyb20gXCIuL2FnZS1jYWxjdWxhdG9yXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpLFxuICAgICAgICBkZCA9IHRvZGF5LmdldERhdGUoKSxcbiAgICAgICAgbW0gPSB0b2RheS5nZXRNb250aCgpKzEsXG4gICAgICAgIHl5eXkgPSB0b2RheS5nZXRGdWxsWWVhcigpO1xuXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaWQ6IDEsXG4gICAgICBuYW1lOiBcIkxlb25hcmRvXCIsXG4gICAgICBsYXN0OiBcIkRhIFZpbmNpXCIsXG4gICAgICBib3JuTW9udGg6IFwiQXByaWxcIixcbiAgICAgIGJvcm5EYXk6IDE1LCBcbiAgICAgIGJvcm5ZZWFyOiAxNDUyLFxuICAgICAgYWdlOiBhZ2VDYWxjKFt5eXl5LTE0NTIsIG1tLTQsIGRkLTE1XSksXG4gICAgICBpbWFnZTogZGFWaW5jaSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxlb25hcmRvIGRpIHNlciBQaWVybyBkYSBWaW5jaSwgbW9yZSBjb21tb25seSBMZW9uYXJkbyBhIFZpbmNpIG9yIHNpbXBseSBMZW9uYXJkbywgd2FzIGFuIEl0YWxpYW4gcG9seW1hdGggd2hvc2UgYXJlYXMgb2YgaW50ZXJlc3QgaW5jbHVkZWQgaW52ZW50aW9uLCBwYWludGluZywgc2N1bHB0aW5nLCBhcmNoaXRlY3R1cmUsIHNjaWVuY2UsIG11c2ljLCBtYXRoZW1hdGljcywgZW5naW5lZXJpbmcsIGxpdGVyYXR1cmUsIGFuYXRvbXksIGdlb2xvZ3ksIGFzdHJvbm9teSwgYm90YW55LCB3cml0aW5nLCBoaXN0b3J5LCBhbmQgY2FydG9ncmFwaHkuIEhlIGhhcyBiZWVuIHZhcmlvdXNseSBjYWxsZWQgdGhlIGZhdGhlciBvZiBwYWxhZW9udG9sb2d5LCBpY2hub2xvZ3ksIGFuZCBhcmNoaXRlY3R1cmUsIGFuZCBpcyB3aWRlbHkgY29uc2lkZXJlZCBvbmUgb2YgdGhlIGdyZWF0ZXN0IHBhaW50ZXJzIG9mIGFsbCB0aW1lLiBTb21ldGltZXMgY3JlZGl0ZWQgd2l0aCB0aGUgaW52ZW50aW9ucyBvZiB0aGUgcGFyYWNodXRlLCBoZWxpY29wdGVyIGFuZCB0YW5rLCBoZSBlcGl0b21pc2VkIHRoZSBSZW5haXNzYW5jZSBodW1hbmlzdCBpZGVhbC5cIlxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDIsXG4gICAgICBuYW1lOiBcIklzYWFjXCIsXG4gICAgICBsYXN0OiBcIk5ld3RvblwiLFxuICAgICAgYm9ybk1vbnRoOiBcIkphbnVhcnlcIixcbiAgICAgIGJvcm5EYXk6IDQsIFxuICAgICAgYm9yblllYXI6IDE2NDMsXG4gICAgICBhZ2U6IGFnZUNhbGMoW3l5eXktMTY0MywgbW0tMSwgZGQtNF0pLFxuICAgICAgaW1hZ2U6IE5ld3RvbixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlNpciBJc2FhYyBOZXd0b24gd2FzIGFuIEVuZ2xpc2ggcGh5c2ljaXN0IGFuZCBtYXRoZW1hdGljaWFuIChkZXNjcmliZWQgaW4gaGlzIG93biBkYXkgYXMgYSBcXFwibmF0dXJhbCBwaGlsb3NvcGhlclxcXCIpIHdobyBpcyB3aWRlbHkgcmVjb2duaXNlZCBhcyBvbmUgb2YgdGhlIG1vc3QgaW5mbHVlbnRpYWwgc2NpZW50aXN0cyBvZiBhbGwgdGltZSBhbmQgYSBrZXkgZmlndXJlIGluIHRoZSBzY2llbnRpZmljIHJldm9sdXRpb24uIEhpcyBib29rIFBoaWxvc29waGnDpiBOYXR1cmFsaXMgUHJpbmNpcGlhIE1hdGhlbWF0aWNhIChcXFwiTWF0aGVtYXRpY2FsIFByaW5jaXBsZXMgb2YgTmF0dXJhbCBQaGlsb3NvcGh5XFxcIiksIGZpcnN0IHB1Ymxpc2hlZCBpbiAxNjg3LCBsYWlkIHRoZSBmb3VuZGF0aW9ucyBmb3IgY2xhc3NpY2FsIG1lY2hhbmljcy4gTmV3dG9uIG1hZGUgc2VtaW5hbCBjb250cmlidXRpb25zIHRvIG9wdGljcywgYW5kIGhlIHNoYXJlcyBjcmVkaXQgd2l0aCBHb3R0ZnJpZWQgV2lsaGVsbSBMZWlibml6IGZvciB0aGUgZGV2ZWxvcG1lbnQgb2YgY2FsY3VsdXMuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAzLFxuICAgICAgbmFtZTogXCJMZW9uaGFyZFwiLFxuICAgICAgbGFzdDogXCJFdWxlclwiLFxuICAgICAgYm9ybk1vbnRoOiBcIkFwcmlsXCIsXG4gICAgICBib3JuRGF5OiAxNSwgXG4gICAgICBib3JuWWVhcjogMTcwNyxcbiAgICAgIGFnZTogYWdlQ2FsYyhbeXl5eS0xNzA3LCBtbS00LCBkZC0xNV0pLFxuICAgICAgaW1hZ2U6IEV1bGVyLFxuICAgICAgZGVzY3JpcHRpb246IFwiTGVvbmhhcmQgRXVsZXIgd2FzIGEgU3dpc3MgbWF0aGVtYXRpY2lhbiwgcGh5c2ljaXN0LCBhc3Ryb25vbWVyLCBsb2dpY2lhbiBhbmQgZW5naW5lZXIgd2hvIG1hZGUgaW1wb3J0YW50IGFuZCBpbmZsdWVudGlhbCBkaXNjb3ZlcmllcyBpbiBtYW55IGJyYW5jaGVzIG9mIG1hdGhlbWF0aWNzIGxpa2UgaW5maW5pdGVzaW1hbCBjYWxjdWx1cyBhbmQgZ3JhcGggdGhlb3J5IHdoaWxlIGFsc28gbWFraW5nIHBpb25lZXJpbmcgY29udHJpYnV0aW9ucyB0byBzZXZlcmFsIGJyYW5jaGVzIHN1Y2ggYXMgdG9wb2xvZ3kgYW5kIGFuYWx5dGljIG51bWJlciB0aGVvcnkuIEhlIGFsc28gaW50cm9kdWNlZCBtdWNoIG9mIHRoZSBtb2Rlcm4gbWF0aGVtYXRpY2FsIHRlcm1pbm9sb2d5IGFuZCBub3RhdGlvbiwgcGFydGljdWxhcmx5IGZvciBtYXRoZW1hdGljYWwgYW5hbHlzaXMsIHN1Y2ggYXMgdGhlIG5vdGlvbiBvZiBhIG1hdGhlbWF0aWNhbCBmdW5jdGlvbi4gIEhlIGlzIGFsc28ga25vd24gZm9yIGhpcyB3b3JrIGluIG1lY2hhbmljcywgZmx1aWQgZHluYW1pY3MsIG9wdGljcywgYXN0cm9ub215LCBhbmQgbXVzaWMgdGhlb3J5LlwiXG4gICAgfSwgIFxuICAgIHtcbiAgICAgIGlkOiA0LFxuICAgICAgbmFtZTogXCJBbGJlcnRcIixcbiAgICAgIGxhc3Q6IFwiRWluc3RlaW5cIixcbiAgICAgIGJvcm5Nb250aDogXCJNYXJjaFwiLFxuICAgICAgYm9ybkRheTogMTQsIFxuICAgICAgYm9yblllYXI6IDE4NzksXG4gICAgICBhZ2U6IGFnZUNhbGMoW3l5eXktMTg3OSwgbW0tMywgZGQtMTRdKSxcbiAgICAgIGltYWdlOiBFaW5zdGVpbixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkFsYmVydCBFaW5zdGVpbiB3YXMgYSBHZXJtYW4tYm9ybiB0aGVvcmV0aWNhbCBwaHlzaWNpc3QuIEhlIGRldmVsb3BlZCB0aGUgZ2VuZXJhbCB0aGVvcnkgb2YgcmVsYXRpdml0eSwgb25lIG9mIHRoZSB0d28gcGlsbGFycyBvZiBtb2Rlcm4gcGh5c2ljcyAoYWxvbmdzaWRlIHF1YW50dW0gbWVjaGFuaWNzKS4gIEVpbnN0ZWluJ3Mgd29yayBpcyBhbHNvIGtub3duIGZvciBpdHMgaW5mbHVlbmNlIG9uIHRoZSBwaGlsb3NvcGh5IG9mIHNjaWVuY2UuICBFaW5zdGVpbiBpcyBiZXN0IGtub3duIGluIHBvcHVsYXIgY3VsdHVyZSBmb3IgaGlzIG1hc3PigJNlbmVyZ3kgZXF1aXZhbGVuY2UgZm9ybXVsYSBFID0gbWMyICh3aGljaCBoYXMgYmVlbiBkdWJiZWQgXFxcInRoZSB3b3JsZCdzIG1vc3QgZmFtb3VzIGVxdWF0aW9uXFxcIikuICBIZSByZWNlaXZlZCB0aGUgMTkyMSBOb2JlbCBQcml6ZSBpbiBQaHlzaWNzIGZvciBoaXMgXFxcInNlcnZpY2VzIHRvIHRoZW9yZXRpY2FsIHBoeXNpY3NcXFwiLCBpbiBwYXJ0aWN1bGFyIGhpcyBkaXNjb3Zlcnkgb2YgdGhlIGxhdyBvZiB0aGUgcGhvdG9lbGVjdHJpYyBlZmZlY3QsIGEgcGl2b3RhbCBzdGVwIGluIHRoZSBldm9sdXRpb24gb2YgcXVhbnR1bSB0aGVvcnkuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA1LFxuICAgICAgbmFtZTogXCJFcndpblwiLFxuICAgICAgbGFzdDogXCJTY2hyb2VkaW5nZXJcIixcbiAgICAgIGJvcm5Nb250aDogXCJBdWd1c3RcIixcbiAgICAgIGJvcm5EYXk6IDEyLCBcbiAgICAgIGJvcm5ZZWFyOiAxODg3LFxuICAgICAgYWdlOiBhZ2VDYWxjKFt5eXl5LTE4ODcsIG1tLTgsIGRkLTEyXSksXG4gICAgICBpbWFnZTogU2Nocm9lZGluZ2VyLFxuICAgICAgZGVzY3JpcHRpb246IFwiRXJ3aW4gUnVkb2xmIEpvc2VmIEFsZXhhbmRlciBTY2hyw7ZkaW5nZXIsIHNvbWV0aW1lcyB3cml0dGVuIGFzIEVyd2luIFNjaHJvZGluZ2VyIG9yIEVyd2luIFNjaHJvZWRpbmdlciwgd2FzIGEgTm9iZWwgUHJpemUtd2lubmluZyBBdXN0cmlhbiBwaHlzaWNpc3Qgd2hvIGRldmVsb3BlZCBhIG51bWJlciBvZiBmdW5kYW1lbnRhbCByZXN1bHRzIGluIHRoZSBmaWVsZCBvZiBxdWFudHVtIHRoZW9yeSwgd2hpY2ggZm9ybWVkIHRoZSBiYXNpcyBvZiB3YXZlIG1lY2hhbmljczogaGUgZm9ybXVsYXRlZCB0aGUgd2F2ZSBlcXVhdGlvbiAoc3RhdGlvbmFyeSBhbmQgdGltZS1kZXBlbmRlbnQgU2NocsO2ZGluZ2VyIGVxdWF0aW9uKSBhbmQgcmV2ZWFsZWQgdGhlIGlkZW50aXR5IG9mIGhpcyBkZXZlbG9wbWVudCBvZiB0aGUgZm9ybWFsaXNtIGFuZCBtYXRyaXggbWVjaGFuaWNzLiBTY2hyw7ZkaW5nZXIgcHJvcG9zZWQgYW4gb3JpZ2luYWwgaW50ZXJwcmV0YXRpb24gb2YgdGhlIHBoeXNpY2FsIG1lYW5pbmcgb2YgdGhlIHdhdmUgZnVuY3Rpb24uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiA2LFxuICAgICAgbmFtZTogXCJHZW9yZ2VzXCIsXG4gICAgICBsYXN0OiBcIkxlbWFpdHJlXCIsXG4gICAgICBib3JuTW9udGg6IFwiSnVseVwiLFxuICAgICAgYm9ybkRheTogMTcsIFxuICAgICAgYm9yblllYXI6IDE4OTQsXG4gICAgICBhZ2U6IGFnZUNhbGMoW3l5eXktMTg5NCwgbW0tNywgZGQtMTddKSxcbiAgICAgIGltYWdlOiBMZW1haXRyZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkdlb3JnZXMgSGVucmkgSm9zZXBoIMOJZG91YXJkIExlbWHDrnRyZSB3YXMgYSBCZWxnaWFuIHByaWVzdCwgYXN0cm9ub21lciBhbmQgcHJvZmVzc29yIG9mIHBoeXNpY3MgYXQgdGhlIENhdGhvbGljIFVuaXZlcnNpdHkgb2YgTGV1dmVuLiAgSGUgcHJvcG9zZWQgdGhlIHRoZW9yeSBvZiB0aGUgZXhwYW5zaW9uIG9mIHRoZSB1bml2ZXJzZSwgd2lkZWx5IG1pc2F0dHJpYnV0ZWQgdG8gRWR3aW4gSHViYmxlLiAgSGUgd2FzIHRoZSBmaXJzdCB0byBkZXJpdmUgd2hhdCBpcyBub3cga25vd24gYXMgSHViYmxlJ3MgbGF3IGFuZCBtYWRlIHRoZSBmaXJzdCBlc3RpbWF0aW9uIG9mIHdoYXQgaXMgbm93IGNhbGxlZCB0aGUgSHViYmxlIGNvbnN0YW50LCB3aGljaCBoZSBwdWJsaXNoZWQgaW4gMTkyNywgdHdvIHllYXJzIGJlZm9yZSBIdWJibGUncyBhcnRpY2xlLiAgTGVtYcOudHJlIGFsc28gcHJvcG9zZWQgd2hhdCBiZWNhbWUga25vd24gYXMgdGhlIEJpZyBCYW5nIHRoZW9yeSBvZiB0aGUgb3JpZ2luIG9mIHRoZSB1bml2ZXJzZSwgd2hpY2ggaGUgY2FsbGVkIGhpcyBcXFwiaHlwb3RoZXNpcyBvZiB0aGUgcHJpbWV2YWwgYXRvbVxcXCIgb3IgdGhlIFxcXCJDb3NtaWMgRWdnXFxcIi5cIlxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDcsXG4gICAgICBuYW1lOiBcIk1vdGhlclwiLFxuICAgICAgbGFzdDogXCJUZXJlc2FcIixcbiAgICAgIGJvcm5Nb250aDogXCJBdWd1c3RcIixcbiAgICAgIGJvcm5EYXk6IDI2LCBcbiAgICAgIGJvcm5ZZWFyOiAxOTEwLFxuICAgICAgYWdlOiBhZ2VDYWxjKFt5eXl5LTE5MTAsIG1tLTgsIGRkLTI2XSksXG4gICAgICBpbWFnZTogTVRlcmVzYSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk1vdGhlciBUZXJlc2EgTUMsIGtub3duIGluIHRoZSBDYXRob2xpYyBDaHVyY2ggYXMgU2FpbnQgVGVyZXNhIG9mIENhbGN1dHRhIHdhcyBhbiBBbGJhbmlhbi1JbmRpYW4gUm9tYW4gQ2F0aG9saWMgbnVuIGFuZCBtaXNzaW9uYXJ5LiAgU2hlIHdhcyBib3JuIGluIFNrb3BqZSAobm93IGNhcGl0YWwgb2YgdGhlIFJlcHVibGljIG9mIE1hY2Vkb25pYSksIHRoZW4gcGFydCBvZiB0aGUgS29zb3ZvIFZpbGF5ZXQgaW4gdGhlIE90dG9tYW4gRW1waXJlLiBBZnRlciBoYXZpbmcgbGl2ZWQgaW4gTWFjZWRvbmlhIGZvciBlaWdodGVlbiB5ZWFycywgc2hlIG1vdmVkIHRvIElyZWxhbmQgYW5kIHRoZW4gdG8gSW5kaWEsIHdoZXJlIHNoZSBsaXZlZCBmb3IgbW9zdCBvZiBoZXIgbGlmZS4gIEluIDE5NTAsIFRlcmVzYSBmb3VuZGVkIHRoZSBNaXNzaW9uYXJpZXMgb2YgQ2hhcml0eSwgYSBSb21hbiBDYXRob2xpYyByZWxpZ2lvdXMgY29uZ3JlZ2F0aW9uLCB3aGljaCBpbiAyMDEyIGNvbnNpc3RlZCBvZiBvdmVyIDQsNTAwIHNpc3RlcnMgYW5kIHdhcyBhY3RpdmUgaW4gMTMzIGNvdW50cmllcy4gVGhleSBydW4gaG9tZXMgZm9yIHBlb3BsZSBkeWluZyBvZiBISVYvQUlEUywgbGVwcm9zeSBhbmQgdHViZXJjdWxvc2lzOyBzb3VwIGtpdGNoZW5zOyBkaXNwZW5zYXJpZXMgYW5kIG1vYmlsZSBjbGluaWNzOyBjaGlsZHJlbidzIGFuZCBmYW1pbHkgY291bnNlbGxpbmcgcHJvZ3JhbW1lczsgb3JwaGFuYWdlczsgYW5kIHNjaG9vbHMuIE1lbWJlcnMgbXVzdCBhZGhlcmUgdG8gdGhlIHZvd3Mgb2YgY2hhc3RpdHksIHBvdmVydHksIGFuZCBvYmVkaWVuY2UsIGFzIHdlbGwgYXMgYSBmb3VydGggdm93LCB0byBnaXZlIFxcXCJ3aG9sZWhlYXJ0ZWQgZnJlZSBzZXJ2aWNlIHRvIHRoZSBwb29yZXN0IG9mIHRoZSBwb29yLlxcXCJcIlxuICAgIH0sXG4gIF1cbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9kZXYvanMvcmVkdWNlcnMvcmVkdWNlci11c2Vycy5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFJvdXRlciwgUm91dGUsIEluZGV4Um91dGUsIGJyb3dzZXJIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuaW1wb3J0IHsgc3luY0hpc3RvcnlXaXRoU3RvcmUsIHJvdXRlclJlZHVjZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXItcmVkdXgnXG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tICcuL2NvbnRhaW5lcidcbmltcG9ydCB7IEhvbWUgfSBmcm9tICcuL2hvbWUnXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi91c2VyJ1xuaW1wb3J0IHsgVHVydGxlcyB9IGZyb20gJy4vdHVydGxlcydcbmltcG9ydCB7IE5vdEZvdW5kIH0gZnJvbSAnLi9ub3Rmb3VuZCdcbmltcG9ydCBzdG9yZSBmcm9tICcuLi9kZXYvanMvc3RvcmUnXG5cbmNvbnN0IGhpc3RvcnkgPSBzeW5jSGlzdG9yeVdpdGhTdG9yZShicm93c2VySGlzdG9yeSwgc3RvcmUpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxSb3V0ZXIgaGlzdG9yeT17aGlzdG9yeX0+XG4gICAgICAgIDxSb3V0ZSBwYXRoPScvJyBjb21wb25lbnQ9e0NvbnRhaW5lcn0+XG5cbiAgICAgICAgICA8SW5kZXhSb3V0ZSBjb21wb25lbnQ9e0hvbWV9IC8+XG4gICAgICAgICAgPFJvdXRlIHBhdGg9J3VzZXInIGNvbXBvbmVudD17VXNlcn0gLz4gIFxuICAgICAgICAgIDxSb3V0ZSBwYXRoPSd0dXJ0bGVzKC86bmFtZSknIGNvbXBvbmVudD17VHVydGxlc30gLz5cbiAgICAgICAgICA8Um91dGUgcGF0aD0nKicgY29tcG9uZW50PXtOb3RGb3VuZH0gLz5cblxuICAgICAgICA8L1JvdXRlPlxuICAgICAgPC9Sb3V0ZXI+XG4gICAgKVxuICB9XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9yb3V0ZXMvYXBwLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgSW5kZXhMaW5rIH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuXG52YXIgbXlTdHlsZSA9IHtcbiAgICBmb250RmFtaWx5OiAnRG9zaXMnXG4gIH1cblxuZXhwb3J0IGNvbnN0IENvbnRhaW5lciA9IChwcm9wcykgPT4gKFxuICA8ZGl2IHN0eWxlPXtteVN0eWxlfT5cbiAgICA8TmF2IC8+IFxuICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgPC9kaXY+XG4pXG5jb25zdCBOYXYgPSAoKSA9PiAoXG4gIDxuYXYgY2xhc3M9XCJuYXZiYXIgbmF2YmFyLWludmVyc2VcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWhlYWRlclwiPlxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm5hdmJhci10b2dnbGVcIiBkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCIgZGF0YS10YXJnZXQ9XCIjbXlOYXZiYXJcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24tYmFyXCI+PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbi1iYXJcIj48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uLWJhclwiPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sbGFwc2UgbmF2YmFyLWNvbGxhcHNlXCIgaWQ9XCJteU5hdmJhclwiPlxuICAgICAgPHVsIGNsYXNzPVwibmF2IG5hdmJhci1uYXZcIj5cbiAgICAgICAgPGxpPjxJbmRleExpbmsgYWN0aXZlQ2xhc3NOYW1lPSdhY3RpdmUnIHRvPScvJz5Ib21lPC9JbmRleExpbms+PC9saT5cbiAgICAgICAgPGxpPjxJbmRleExpbmsgYWN0aXZlQ2xhc3NOYW1lPSdhY3RpdmUnIHRvPScvdXNlcic+RmFtb3VzIFBlb3BsZTwvSW5kZXhMaW5rPjwvbGk+XG4gICAgICAgIDxsaT48SW5kZXhMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nYWN0aXZlJyB0bz0nL3R1cnRsZXMnPk11dGFudCBUdXJ0bGVzPC9JbmRleExpbms+PC9saT5cbiAgICAgIDwvdWw+XG4gICAgPC9kaXY+XG4gIDwvbmF2PlxuKVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vcm91dGVzL2NvbnRhaW5lci5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbiAgXG52YXIgbXlTdHlsZSA9IHtcbiAgXHRtYXJnaW5MZWZ0OiAzMCxcbiAgXHRtYXJnaW5SaWdodDogMjUsXG4gIFx0Zm9udEZhbWlseTogJ0Rvc2lzJ1xufVxuXG5leHBvcnQgY29uc3QgSG9tZSA9ICgpID0+IChcbiAgPGRpdiBzdHlsZT17bXlTdHlsZX0+XG4gICAgPGJyIC8+XG4gICAgPGgyPldlbGNvbWUgdG8gdGhlIFdvcmxkIG9mIGZhbUUgYW5kIG11VEFhdElvTnMhPC9oMj5cbiAgICA8aDQ+PiBjbGljayBvbiBuYXZpZ2F0aW9uIHRvIHNlZSBtb3JlLi4uPC9oND5cbiAgPC9kaXY+XG4pXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy9ob21lLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5leHBvcnQgY29uc3QgTm90Rm91bmQgPSAoKSA9PiAoXG4gIDxoMj40MDQ6IFRoaXMgcGFnZSBpcyBub3QgZm91bmQhPC9oMj5cbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy9ub3Rmb3VuZC5qc1xuICoqLyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBDb21wVHVydGxlIGZyb20gJy4uL2Rldi9qcy9jb21wb25lbnRzL2NvbXAtdHVydGxlJ1xuXG52YXIgbXlTdHlsZSA9IHtcbiAgXHRtYXJnaW5MZWZ0OiAzMCxcbiAgXHRtYXJnaW5SaWdodDogMjUsXG4gIFx0Zm9udEZhbWlseTogJ0Rvc2lzJ1xufVxuXG5leHBvcnQgY29uc3QgVHVydGxlcyA9IChwcm9wcykgPT4gKFxuICA8ZGl2IHN0eWxlPXtteVN0eWxlfT5cbiAgICA8YnIgLz5cbiAgICA8aDI+VGhpcyBpcyB0aGUgVHVydGxlcyBQYWdlPC9oMj5cbiAgICA8Q29tcFR1cnRsZSAvPlxuICA8L2Rpdj5cbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy90dXJ0bGVzLmpzXG4gKiovIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IENvbXBVc2VyIGZyb20gJy4uL2Rldi9qcy9jb21wb25lbnRzL2NvbXAtdXNlcidcblxudmFyIG15U3R5bGUgPSB7XG4gIFx0bWFyZ2luTGVmdDogMzAsXG4gIFx0bWFyZ2luUmlnaHQ6IDI1LFxuICBcdGZvbnRGYW1pbHk6ICdEb3Npcydcbn1cblxuZXhwb3J0IGNvbnN0IFVzZXIgPSAoKSA9PiAoXG4gIDxkaXYgc3R5bGU9e215U3R5bGV9PlxuICAgIDxiciAvPlxuICAgIDxoMj5UaGlzIGlzIHRoZSBGYW1vdXMgUGVvcGxlIFBhZ2U8L2gyPlxuICAgIDxDb21wVXNlciAvPlxuICA8L2Rpdj5cbilcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3JvdXRlcy91c2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdERPTScpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtZG9tL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfc3RvcmVTaGFwZSA9IHJlcXVpcmUoJy4uL3V0aWxzL3N0b3JlU2hhcGUnKTtcblxudmFyIF9zdG9yZVNoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0b3JlU2hhcGUpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuLi91dGlscy93YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gZmFsc2U7XG5mdW5jdGlvbiB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpIHtcbiAgaWYgKGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5BYm91dFJlY2VpdmluZ1N0b3JlID0gdHJ1ZTtcblxuICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkoJzxQcm92aWRlcj4gZG9lcyBub3Qgc3VwcG9ydCBjaGFuZ2luZyBgc3RvcmVgIG9uIHRoZSBmbHkuICcgKyAnSXQgaXMgbW9zdCBsaWtlbHkgdGhhdCB5b3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgdXBkYXRlZCB0byAnICsgJ1JlZHV4IDIueCBhbmQgUmVhY3QgUmVkdXggMi54IHdoaWNoIG5vIGxvbmdlciBob3QgcmVsb2FkIHJlZHVjZXJzICcgKyAnYXV0b21hdGljYWxseS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJlZHV4L3JlbGVhc2VzLycgKyAndGFnL3YyLjAuMCBmb3IgdGhlIG1pZ3JhdGlvbiBpbnN0cnVjdGlvbnMuJyk7XG59XG5cbnZhciBQcm92aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgUHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4geyBzdG9yZTogdGhpcy5zdG9yZSB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFByb3ZpZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb3ZpZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgX3RoaXMuc3RvcmUgPSBwcm9wcy5zdG9yZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICByZXR1cm4gX3JlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBQcm92aWRlcjtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHJvdmlkZXI7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFByb3ZpZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgdmFyIG5leHRTdG9yZSA9IG5leHRQcm9wcy5zdG9yZTtcblxuICAgIGlmIChzdG9yZSAhPT0gbmV4dFN0b3JlKSB7XG4gICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXS5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbn07XG5Qcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl0uaXNSZXF1aXJlZFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvY29tcG9uZW50cy9Qcm92aWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb25uZWN0O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9zdG9yZVNoYXBlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RvcmVTaGFwZScpO1xuXG52YXIgX3N0b3JlU2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RvcmVTaGFwZSk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBfc2hhbGxvd0VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dFcXVhbCk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7fTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4geyBkaXNwYXRjaDogZGlzcGF0Y2ggfTtcbn07XG52YXIgZGVmYXVsdE1lcmdlUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHBhcmVudFByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn07XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG52YXIgZXJyb3JPYmplY3QgPSB7IHZhbHVlOiBudWxsIH07XG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgY3R4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGN0eCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvck9iamVjdC52YWx1ZSA9IGU7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0O1xuICB9XG59XG5cbi8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG52YXIgbmV4dFZlcnNpb24gPSAwO1xuXG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbM107XG5cbiAgdmFyIHNob3VsZFN1YnNjcmliZSA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcbiAgdmFyIG1hcFN0YXRlID0gbWFwU3RhdGVUb1Byb3BzIHx8IGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHM7XG5cbiAgdmFyIG1hcERpc3BhdGNoID0gdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1hcERpc3BhdGNoID0gbWFwRGlzcGF0Y2hUb1Byb3BzO1xuICB9IGVsc2UgaWYgKCFtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgICBtYXBEaXNwYXRjaCA9IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgbWFwRGlzcGF0Y2ggPSAoMCwgX3dyYXBBY3Rpb25DcmVhdG9yczJbXCJkZWZhdWx0XCJdKShtYXBEaXNwYXRjaFRvUHJvcHMpO1xuICB9XG5cbiAgdmFyIGZpbmFsTWVyZ2VQcm9wcyA9IG1lcmdlUHJvcHMgfHwgZGVmYXVsdE1lcmdlUHJvcHM7XG4gIHZhciBfb3B0aW9ucyRwdXJlID0gb3B0aW9ucy5wdXJlO1xuICB2YXIgcHVyZSA9IF9vcHRpb25zJHB1cmUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfb3B0aW9ucyRwdXJlO1xuICB2YXIgX29wdGlvbnMkd2l0aFJlZiA9IG9wdGlvbnMud2l0aFJlZjtcbiAgdmFyIHdpdGhSZWYgPSBfb3B0aW9ucyR3aXRoUmVmID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9vcHRpb25zJHdpdGhSZWY7XG5cbiAgdmFyIGNoZWNrTWVyZ2VkRXF1YWxzID0gcHVyZSAmJiBmaW5hbE1lcmdlUHJvcHMgIT09IGRlZmF1bHRNZXJnZVByb3BzO1xuXG4gIC8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG4gIHZhciB2ZXJzaW9uID0gbmV4dFZlcnNpb24rKztcblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICB2YXIgY29ubmVjdERpc3BsYXlOYW1lID0gJ0Nvbm5lY3QoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tTdGF0ZVNoYXBlKHByb3BzLCBtZXRob2ROYW1lKSB7XG4gICAgICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbXCJkZWZhdWx0XCJdKShwcm9wcykpIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKG1ldGhvZE5hbWUgKyAnKCkgaW4gJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICcgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuICcgKyAoJ0luc3RlYWQgcmVjZWl2ZWQgJyArIHByb3BzICsgJy4nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1lcmdlZFByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIHBhcmVudFByb3BzKSB7XG4gICAgICB2YXIgbWVyZ2VkUHJvcHMgPSBmaW5hbE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1lcmdlZFByb3BzLCAnbWVyZ2VQcm9wcycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH1cblxuICAgIHZhciBDb25uZWN0ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0cyhDb25uZWN0LCBfQ29tcG9uZW50KTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gIXB1cmUgfHwgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkIHx8IHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQ7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBDb25uZWN0KHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25uZWN0KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgICAgICBfdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgX3RoaXMuc3RvcmUgPSBwcm9wcy5zdG9yZSB8fCBjb250ZXh0LnN0b3JlO1xuXG4gICAgICAgICgwLCBfaW52YXJpYW50MltcImRlZmF1bHRcIl0pKF90aGlzLnN0b3JlLCAnQ291bGQgbm90IGZpbmQgXCJzdG9yZVwiIGluIGVpdGhlciB0aGUgY29udGV4dCBvciAnICsgKCdwcm9wcyBvZiBcIicgKyBjb25uZWN0RGlzcGxheU5hbWUgKyAnXCIuICcpICsgJ0VpdGhlciB3cmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhIDxQcm92aWRlcj4sICcgKyAoJ29yIGV4cGxpY2l0bHkgcGFzcyBcInN0b3JlXCIgYXMgYSBwcm9wIHRvIFwiJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICdcIi4nKSk7XG5cbiAgICAgICAgdmFyIHN0b3JlU3RhdGUgPSBfdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9O1xuICAgICAgICBfdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH1cblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZVN0YXRlUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlU3RhdGVQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIHN0YXRlUHJvcHMgPSB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzKHN0YXRlKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShzdGF0ZVByb3BzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcFN0YXRlID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBTdGF0ZShzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZFN0YXRlID0gbWFwU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSwgcHJvcHMpO1xuICAgICAgICB2YXIgaXNGYWN0b3J5ID0gdHlwZW9mIG1hcHBlZFN0YXRlID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMgPSBpc0ZhY3RvcnkgPyBtYXBwZWRTdGF0ZSA6IG1hcFN0YXRlO1xuICAgICAgICB0aGlzLmRvU3RhdGVQcm9wc0RlcGVuZE9uT3duUHJvcHMgPSB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzLmxlbmd0aCAhPT0gMTtcblxuICAgICAgICBpZiAoaXNGYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVN0YXRlUHJvcHMoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1hcHBlZFN0YXRlLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZFN0YXRlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcHV0ZURpc3BhdGNoUHJvcHMgPSBmdW5jdGlvbiBjb21wdXRlRGlzcGF0Y2hQcm9wcyhzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoID0gc3RvcmUuZGlzcGF0Y2g7XG5cbiAgICAgICAgdmFyIGRpc3BhdGNoUHJvcHMgPSB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMgPyB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBwcm9wcykgOiB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShkaXNwYXRjaFByb3BzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoUHJvcHM7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb25maWd1cmVGaW5hbE1hcERpc3BhdGNoID0gZnVuY3Rpb24gY29uZmlndXJlRmluYWxNYXBEaXNwYXRjaChzdG9yZSwgcHJvcHMpIHtcbiAgICAgICAgdmFyIG1hcHBlZERpc3BhdGNoID0gbWFwRGlzcGF0Y2goc3RvcmUuZGlzcGF0Y2gsIHByb3BzKTtcbiAgICAgICAgdmFyIGlzRmFjdG9yeSA9IHR5cGVvZiBtYXBwZWREaXNwYXRjaCA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gaXNGYWN0b3J5ID8gbWFwcGVkRGlzcGF0Y2ggOiBtYXBEaXNwYXRjaDtcbiAgICAgICAgdGhpcy5kb0Rpc3BhdGNoUHJvcHNEZXBlbmRPbk93blByb3BzID0gdGhpcy5maW5hbE1hcERpc3BhdGNoVG9Qcm9wcy5sZW5ndGggIT09IDE7XG5cbiAgICAgICAgaWYgKGlzRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVEaXNwYXRjaFByb3BzKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNoZWNrU3RhdGVTaGFwZShtYXBwZWREaXNwYXRjaCwgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWREaXNwYXRjaDtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHRTdGF0ZVByb3BzID0gdGhpcy5jb21wdXRlU3RhdGVQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0U3RhdGVQcm9wcywgdGhpcy5zdGF0ZVByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCgpIHtcbiAgICAgICAgdmFyIG5leHREaXNwYXRjaFByb3BzID0gdGhpcy5jb21wdXRlRGlzcGF0Y2hQcm9wcyh0aGlzLnN0b3JlLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hQcm9wcyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0RGlzcGF0Y2hQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQcm9wcyA9IG5leHREaXNwYXRjaFByb3BzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQgPSBmdW5jdGlvbiB1cGRhdGVNZXJnZWRQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dE1lcmdlZFByb3BzID0gY29tcHV0ZU1lcmdlZFByb3BzKHRoaXMuc3RhdGVQcm9wcywgdGhpcy5kaXNwYXRjaFByb3BzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VkUHJvcHMgJiYgY2hlY2tNZXJnZWRFcXVhbHMgJiYgKDAsIF9zaGFsbG93RXF1YWwyW1wiZGVmYXVsdFwiXSkobmV4dE1lcmdlZFByb3BzLCB0aGlzLm1lcmdlZFByb3BzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcHMgPSBuZXh0TWVyZ2VkUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudW5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbic7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmIChzaG91bGRTdWJzY3JpYmUgJiYgIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudHJ5U3Vic2NyaWJlKCk7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICEoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0UHJvcHMsIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLm1lcmdlZFByb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdG9yZVN0YXRlID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgcHJldlN0b3JlU3RhdGUgPSB0aGlzLnN0YXRlLnN0b3JlU3RhdGU7XG4gICAgICAgIGlmIChwdXJlICYmIHByZXZTdG9yZVN0YXRlID09PSBzdG9yZVN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB1cmUgJiYgIXRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcykge1xuICAgICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0cnlDYXRjaCh0aGlzLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFoYXZlU3RhdGVQcm9wc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBlcnJvck9iamVjdC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgc3RvcmVTdGF0ZTogc3RvcmVTdGF0ZSB9KTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmdldFdyYXBwZWRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICAgKDAsIF9pbnZhcmlhbnQyW1wiZGVmYXVsdFwiXSkod2l0aFJlZiwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ3sgd2l0aFJlZjogdHJ1ZSB9IGFzIHRoZSBmb3VydGggYXJndW1lbnQgb2YgdGhlIGNvbm5lY3QoKSBjYWxsLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMud3JhcHBlZEluc3RhbmNlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgaGF2ZU93blByb3BzQ2hhbmdlZCA9IHRoaXMuaGF2ZU93blByb3BzQ2hhbmdlZDtcbiAgICAgICAgdmFyIGhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZDtcbiAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQ7XG4gICAgICAgIHZhciBzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgIHZhciByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLnJlbmRlcmVkRWxlbWVudDtcblxuICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlU3RhdGVQcm9wcyA9IHRydWU7XG4gICAgICAgIHZhciBzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHB1cmUgJiYgcmVuZGVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlU3RhdGVQcm9wcyA9IGhhc1N0b3JlU3RhdGVDaGFuZ2VkIHx8IGhhdmVPd25Qcm9wc0NoYW5nZWQgJiYgdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzO1xuICAgICAgICAgIHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMgPSBoYXZlT3duUHJvcHNDaGFuZ2VkICYmIHRoaXMuZG9EaXNwYXRjaFByb3BzRGVwZW5kT25Pd25Qcm9wcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCkge1xuICAgICAgICAgIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkVXBkYXRlU3RhdGVQcm9wcykge1xuICAgICAgICAgIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZURpc3BhdGNoUHJvcHMpIHtcbiAgICAgICAgICBoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZURpc3BhdGNoUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkIHx8IGhhdmVEaXNwYXRjaFByb3BzQ2hhbmdlZCB8fCBoYXZlT3duUHJvcHNDaGFuZ2VkKSB7XG4gICAgICAgICAgaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCA9IHRoaXMudXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGF2ZU1lcmdlZFByb3BzQ2hhbmdlZCAmJiByZW5kZXJlZEVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpdGhSZWYpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9ICgwLCBfcmVhY3QuY3JlYXRlRWxlbWVudCkoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHRoaXMubWVyZ2VkUHJvcHMsIHtcbiAgICAgICAgICAgIHJlZjogJ3dyYXBwZWRJbnN0YW5jZSdcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKFdyYXBwZWRDb21wb25lbnQsIHRoaXMubWVyZ2VkUHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWRFbGVtZW50O1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbm5lY3Q7XG4gICAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBjb25uZWN0RGlzcGxheU5hbWU7XG4gICAgQ29ubmVjdC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICBDb25uZWN0LmNvbnRleHRUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdXG4gICAgfTtcbiAgICBDb25uZWN0LnByb3BUeXBlcyA9IHtcbiAgICAgIHN0b3JlOiBfc3RvcmVTaGFwZTJbXCJkZWZhdWx0XCJdXG4gICAgfTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gdmVyc2lvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFyZSBob3QgcmVsb2FkaW5nIVxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLnRyeVN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyW1wiZGVmYXVsdFwiXSkoQ29ubmVjdCwgV3JhcHBlZENvbXBvbmVudCk7XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHNoYWxsb3dFcXVhbDtcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCBvYmpBW2tleXNBW2ldXSAhPT0gb2JqQltrZXlzQVtpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzXG4gKiogbW9kdWxlIGlkID0gMTU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHdyYXBBY3Rpb25DcmVhdG9ycztcblxudmFyIF9yZWR1eCA9IHJlcXVpcmUoJ3JlZHV4Jyk7XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuICgwLCBfcmVkdXguYmluZEFjdGlvbkNyZWF0b3JzKShhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9O1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L2xpYi91dGlscy93cmFwQWN0aW9uQ3JlYXRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICBuYW1lOiB0cnVlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgY2FsbGVyOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGN1c3RvbVN0YXRpY3MpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXlzW2ldXSAmJiAhS05PV05fU1RBVElDU1trZXlzW2ldXSAmJiAoIWN1c3RvbVN0YXRpY3MgfHwgIWN1c3RvbVN0YXRpY3Nba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tcG9uZW50W2tleXNbaV1dID0gc291cmNlQ29tcG9uZW50W2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L34vaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNIb3N0T2JqZWN0O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QtcmVkdXgvfi9sb2Rhc2gvX2lzSG9zdE9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJlZHV4L34vbG9kYXNoL19vdmVyQXJnLmpzXG4gKiogbW9kdWxlIGlkID0gMTYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yZWR1eC9+L2xvZGFzaC9pc09iamVjdExpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJvdXRlck1pZGRsZXdhcmU7XG5cbnZhciBfYWN0aW9ucyA9IHJlcXVpcmUoJy4vYWN0aW9ucycpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuLyoqXG4gKiBUaGlzIG1pZGRsZXdhcmUgY2FwdHVyZXMgQ0FMTF9ISVNUT1JZX01FVEhPRCBhY3Rpb25zIHRvIHJlZGlyZWN0IHRvIHRoZVxuICogcHJvdmlkZWQgaGlzdG9yeSBvYmplY3QuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZXNlIGFjdGlvbnMgZnJvbSByZWFjaGluZyB5b3VyXG4gKiByZWR1Y2VyIG9yIGFueSBtaWRkbGV3YXJlIHRoYXQgY29tZXMgYWZ0ZXIgdGhpcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIHJvdXRlck1pZGRsZXdhcmUoaGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSBfYWN0aW9ucy5DQUxMX0hJU1RPUllfTUVUSE9EKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfYWN0aW9uJHBheWxvYWQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgdmFyIG1ldGhvZCA9IF9hY3Rpb24kcGF5bG9hZC5tZXRob2Q7XG4gICAgICAgIHZhciBhcmdzID0gX2FjdGlvbiRwYXlsb2FkLmFyZ3M7XG5cbiAgICAgICAgaGlzdG9yeVttZXRob2RdLmFwcGx5KGhpc3RvcnksIF90b0NvbnN1bWFibGVBcnJheShhcmdzKSk7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyLXJlZHV4L2xpYi9taWRkbGV3YXJlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHN5bmNIaXN0b3J5V2l0aFN0b3JlO1xuXG52YXIgX3JlZHVjZXIgPSByZXF1aXJlKCcuL3JlZHVjZXInKTtcblxudmFyIGRlZmF1bHRTZWxlY3RMb2NhdGlvblN0YXRlID0gZnVuY3Rpb24gZGVmYXVsdFNlbGVjdExvY2F0aW9uU3RhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLnJvdXRpbmc7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc3luY2hyb25pemVzIHlvdXIgaGlzdG9yeSBzdGF0ZSB3aXRoIHRoZSBSZWR1eCBzdG9yZS5cbiAqIExvY2F0aW9uIGNoYW5nZXMgZmxvdyBmcm9tIGhpc3RvcnkgdG8gdGhlIHN0b3JlLiBBbiBlbmhhbmNlZCBoaXN0b3J5IGlzXG4gKiByZXR1cm5lZCB3aXRoIGEgbGlzdGVuIG1ldGhvZCB0aGF0IHJlc3BvbmRzIHRvIHN0b3JlIHVwZGF0ZXMgZm9yIGxvY2F0aW9uLlxuICpcbiAqIFdoZW4gdGhpcyBoaXN0b3J5IGlzIHByb3ZpZGVkIHRvIHRoZSByb3V0ZXIsIHRoaXMgbWVhbnMgdGhlIGxvY2F0aW9uIGRhdGFcbiAqIHdpbGwgZmxvdyBsaWtlIHRoaXM6XG4gKiBoaXN0b3J5LnB1c2ggLT4gc3RvcmUuZGlzcGF0Y2ggLT4gZW5oYW5jZWRIaXN0b3J5Lmxpc3RlbiAtPiByb3V0ZXJcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdoZW4gdGhlIHN0b3JlIHN0YXRlIGNoYW5nZXMgZHVlIHRvIGEgcmVwbGF5IG9yIG90aGVyXG4gKiBldmVudCwgdGhlIHJvdXRlciB3aWxsIGJlIHVwZGF0ZWQgYXBwcm9wcmlhdGVseSBhbmQgY2FuIHRyYW5zaXRpb24gdG8gdGhlXG4gKiBjb3JyZWN0IHJvdXRlciBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gc3luY0hpc3RvcnlXaXRoU3RvcmUoaGlzdG9yeSwgc3RvcmUpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcblxuICB2YXIgX3JlZiRzZWxlY3RMb2NhdGlvblN0ID0gX3JlZi5zZWxlY3RMb2NhdGlvblN0YXRlO1xuICB2YXIgc2VsZWN0TG9jYXRpb25TdGF0ZSA9IF9yZWYkc2VsZWN0TG9jYXRpb25TdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFNlbGVjdExvY2F0aW9uU3RhdGUgOiBfcmVmJHNlbGVjdExvY2F0aW9uU3Q7XG4gIHZhciBfcmVmJGFkanVzdFVybE9uUmVwbGEgPSBfcmVmLmFkanVzdFVybE9uUmVwbGF5O1xuICB2YXIgYWRqdXN0VXJsT25SZXBsYXkgPSBfcmVmJGFkanVzdFVybE9uUmVwbGEgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJGFkanVzdFVybE9uUmVwbGE7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHJlZHVjZXIgaXMgbW91bnRlZCBvbiB0aGUgc3RvcmUgYW5kIGZ1bmN0aW9uaW5nIHByb3Blcmx5LlxuICBpZiAodHlwZW9mIHNlbGVjdExvY2F0aW9uU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcm91dGluZyBzdGF0ZSB0byBiZSBhdmFpbGFibGUgZWl0aGVyIGFzIGBzdGF0ZS5yb3V0aW5nYCAnICsgJ29yIGFzIHRoZSBjdXN0b20gZXhwcmVzc2lvbiB5b3UgY2FuIHNwZWNpZnkgYXMgYHNlbGVjdExvY2F0aW9uU3RhdGVgICcgKyAnaW4gdGhlIGBzeW5jSGlzdG9yeVdpdGhTdG9yZSgpYCBvcHRpb25zLiAnICsgJ0Vuc3VyZSB5b3UgaGF2ZSBhZGRlZCB0aGUgYHJvdXRlclJlZHVjZXJgIHRvIHlvdXIgc3RvcmVcXCdzICcgKyAncmVkdWNlcnMgdmlhIGBjb21iaW5lUmVkdWNlcnNgIG9yIHdoYXRldmVyIG1ldGhvZCB5b3UgdXNlIHRvIGlzb2xhdGUgJyArICd5b3VyIHJlZHVjZXJzLicpO1xuICB9XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IHZvaWQgMDtcbiAgdmFyIGlzVGltZVRyYXZlbGluZyA9IHZvaWQgMDtcbiAgdmFyIHVuc3Vic2NyaWJlRnJvbVN0b3JlID0gdm9pZCAwO1xuICB2YXIgdW5zdWJzY3JpYmVGcm9tSGlzdG9yeSA9IHZvaWQgMDtcblxuICAvLyBXaGF0IGRvZXMgdGhlIHN0b3JlIHNheSBhYm91dCBjdXJyZW50IGxvY2F0aW9uP1xuICB2YXIgZ2V0TG9jYXRpb25JblN0b3JlID0gZnVuY3Rpb24gZ2V0TG9jYXRpb25JblN0b3JlKHVzZUluaXRpYWxJZkVtcHR5KSB7XG4gICAgdmFyIGxvY2F0aW9uU3RhdGUgPSBzZWxlY3RMb2NhdGlvblN0YXRlKHN0b3JlLmdldFN0YXRlKCkpO1xuICAgIHJldHVybiBsb2NhdGlvblN0YXRlLmxvY2F0aW9uQmVmb3JlVHJhbnNpdGlvbnMgfHwgKHVzZUluaXRpYWxJZkVtcHR5ID8gaW5pdGlhbExvY2F0aW9uIDogdW5kZWZpbmVkKTtcbiAgfTtcblxuICAvLyBJbml0IGN1cnJlbnRMb2NhdGlvbiB3aXRoIHBvdGVudGlhbCBsb2NhdGlvbiBpbiBzdG9yZVxuICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0TG9jYXRpb25JblN0b3JlKCk7XG5cbiAgLy8gSWYgdGhlIHN0b3JlIGlzIHJlcGxheWVkLCB1cGRhdGUgdGhlIFVSTCBpbiB0aGUgYnJvd3NlciB0byBtYXRjaC5cbiAgaWYgKGFkanVzdFVybE9uUmVwbGF5KSB7XG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlU3RvcmVDaGFuZ2UoKSB7XG4gICAgICB2YXIgbG9jYXRpb25JblN0b3JlID0gZ2V0TG9jYXRpb25JblN0b3JlKHRydWUpO1xuICAgICAgaWYgKGN1cnJlbnRMb2NhdGlvbiA9PT0gbG9jYXRpb25JblN0b3JlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGFkZHJlc3MgYmFyIHRvIHJlZmxlY3Qgc3RvcmUgc3RhdGVcbiAgICAgIGlzVGltZVRyYXZlbGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbkluU3RvcmU7XG4gICAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgbG9jYXRpb25JblN0b3JlLCB7XG4gICAgICAgIGFjdGlvbjogJ1BVU0gnXG4gICAgICB9KSk7XG4gICAgICBpc1RpbWVUcmF2ZWxpbmcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdW5zdWJzY3JpYmVGcm9tU3RvcmUgPSBzdG9yZS5zdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xuICAgIGhhbmRsZVN0b3JlQ2hhbmdlKCk7XG4gIH1cblxuICAvLyBXaGVuZXZlciBsb2NhdGlvbiBjaGFuZ2VzLCBkaXNwYXRjaCBhbiBhY3Rpb24gdG8gZ2V0IGl0IGluIHRoZSBzdG9yZVxuICB2YXIgaGFuZGxlTG9jYXRpb25DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2NhdGlvbkNoYW5nZShsb2NhdGlvbikge1xuICAgIC8vIC4uLiB1bmxlc3Mgd2UganVzdCBjYXVzZWQgdGhhdCBsb2NhdGlvbiBjaGFuZ2VcbiAgICBpZiAoaXNUaW1lVHJhdmVsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtZW1iZXIgd2hlcmUgd2UgYXJlXG4gICAgY3VycmVudExvY2F0aW9uID0gbG9jYXRpb247XG5cbiAgICAvLyBBcmUgd2UgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZT9cbiAgICBpZiAoIWluaXRpYWxMb2NhdGlvbikge1xuICAgICAgLy8gUmVtZW1iZXIgYXMgYSBmYWxsYmFjayBpbiBjYXNlIHN0YXRlIGlzIHJlc2V0XG4gICAgICBpbml0aWFsTG9jYXRpb24gPSBsb2NhdGlvbjtcblxuICAgICAgLy8gUmVzcGVjdCBwZXJzaXN0ZWQgbG9jYXRpb24sIGlmIGFueVxuICAgICAgaWYgKGdldExvY2F0aW9uSW5TdG9yZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUZWxsIHRoZSBzdG9yZSB0byB1cGRhdGUgYnkgZGlzcGF0Y2hpbmcgYW4gYWN0aW9uXG4gICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogX3JlZHVjZXIuTE9DQVRJT05fQ0hBTkdFLFxuICAgICAgcGF5bG9hZDogbG9jYXRpb25cbiAgICB9KTtcbiAgfTtcbiAgdW5zdWJzY3JpYmVGcm9tSGlzdG9yeSA9IGhpc3RvcnkubGlzdGVuKGhhbmRsZUxvY2F0aW9uQ2hhbmdlKTtcblxuICAvLyBUaGUgZW5oYW5jZWQgaGlzdG9yeSB1c2VzIHN0b3JlIGFzIHNvdXJjZSBvZiB0cnV0aFxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAvLyBUaGUgbGlzdGVuZXJzIGFyZSBzdWJzY3JpYmVkIHRvIHRoZSBzdG9yZSBpbnN0ZWFkIG9mIGhpc3RvcnlcblxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICAvLyBDb3B5IG9mIGxhc3QgbG9jYXRpb24uXG4gICAgICB2YXIgbGFzdFB1Ymxpc2hlZExvY2F0aW9uID0gZ2V0TG9jYXRpb25JblN0b3JlKHRydWUpO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgd2UgdW5zdWJzY3JpYmVkLCBhcyBSZWR1eCBzdG9yZVxuICAgICAgLy8gb25seSBhcHBsaWVzIGNoYW5nZXMgaW4gc3Vic2NyaXB0aW9ucyBvbiBuZXh0IGRpc3BhdGNoXG4gICAgICB2YXIgdW5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB2YXIgdW5zdWJzY3JpYmVGcm9tU3RvcmUgPSBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0TG9jYXRpb25JblN0b3JlKHRydWUpO1xuICAgICAgICBpZiAoY3VycmVudExvY2F0aW9uID09PSBsYXN0UHVibGlzaGVkTG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFB1Ymxpc2hlZExvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuICAgICAgICBpZiAoIXVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgIGxpc3RlbmVyKGxhc3RQdWJsaXNoZWRMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaXN0b3J5IGxpc3RlbmVycyBleHBlY3QgYSBzeW5jaHJvbm91cyBjYWxsLiBNYWtlIHRoZSBmaXJzdCBjYWxsIHRvIHRoZVxuICAgICAgLy8gbGlzdGVuZXIgYWZ0ZXIgc3Vic2NyaWJpbmcgdG8gdGhlIHN0b3JlLCBpbiBjYXNlIHRoZSBsaXN0ZW5lciBjYXVzZXMgYVxuICAgICAgLy8gbG9jYXRpb24gY2hhbmdlIChlLmcuIHdoZW4gaXQgcmVkaXJlY3RzKVxuICAgICAgbGlzdGVuZXIobGFzdFB1Ymxpc2hlZExvY2F0aW9uKTtcblxuICAgICAgLy8gTGV0IHVzZXIgdW5zdWJzY3JpYmUgbGF0ZXJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHVuc3Vic2NyaWJlRnJvbVN0b3JlKCk7XG4gICAgICB9O1xuICAgIH0sXG5cblxuICAgIC8vIEl0IGFsc28gcHJvdmlkZXMgYSB3YXkgdG8gZGVzdHJveSBpbnRlcm5hbCBsaXN0ZW5lcnNcbiAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoYWRqdXN0VXJsT25SZXBsYXkpIHtcbiAgICAgICAgdW5zdWJzY3JpYmVGcm9tU3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHVuc3Vic2NyaWJlRnJvbUhpc3RvcnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci1yZWR1eC9saWIvc3luYy5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEEgbWl4aW4gdGhhdCBhZGRzIHRoZSBcImhpc3RvcnlcIiBpbnN0YW5jZSB2YXJpYWJsZSB0byBjb21wb25lbnRzLlxuICovXG52YXIgSGlzdG9yeSA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBfSW50ZXJuYWxQcm9wVHlwZXMuaGlzdG9yeVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAndGhlIGBIaXN0b3J5YCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgYWNjZXNzIGBjb250ZXh0LnJvdXRlcmAgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWhpc3RvcnltaXhpbicpIDogdm9pZCAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuY29udGV4dC5oaXN0b3J5O1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9IaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9MaW5rID0gcmVxdWlyZSgnLi9MaW5rJyk7XG5cbnZhciBfTGluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaW5rKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBBbiA8SW5kZXhMaW5rPiBpcyB1c2VkIHRvIGxpbmsgdG8gYW4gPEluZGV4Um91dGU+LlxuICovXG52YXIgSW5kZXhMaW5rID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleExpbmsnLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX0xpbmsyLmRlZmF1bHQsIF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IG9ubHlBY3RpdmVPbkluZGV4OiB0cnVlIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4TGluaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhMaW5rLmpzXG4gKiogbW9kdWxlIGlkID0gMTY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9SZWRpcmVjdCA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcblxudmFyIF9SZWRpcmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWRpcmVjdCk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBbiA8SW5kZXhSZWRpcmVjdD4gaXMgdXNlZCB0byByZWRpcmVjdCBmcm9tIGFuIGluZGV4Um91dGUuXG4gKi9cblxudmFyIEluZGV4UmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4UmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQsIHBhcmVudFJvdXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogc2FuaXR5IGNoZWNrICovXG4gICAgICBpZiAocGFyZW50Um91dGUpIHtcbiAgICAgICAgcGFyZW50Um91dGUuaW5kZXhSb3V0ZSA9IF9SZWRpcmVjdDIuZGVmYXVsdC5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJlZGlyZWN0PiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgb25FbnRlcjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVuYyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMuZnVuYztcblxuLyoqXG4gKiBBbiA8SW5kZXhSb3V0ZT4gaXMgdXNlZCB0byBzcGVjaWZ5IGl0cyBwYXJlbnQncyA8Um91dGUgaW5kZXhSb3V0ZT4gaW5cbiAqIGEgSlNYIHJvdXRlIGNvbmZpZy5cbiAqL1xuXG52YXIgSW5kZXhSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhSb3V0ZScsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBzYW5pdHkgY2hlY2sgKi9cbiAgICAgIGlmIChwYXJlbnRSb3V0ZSkge1xuICAgICAgICBwYXJlbnRSb3V0ZS5pbmRleFJvdXRlID0gKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJvdXRlPiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjb21wb25lbnQ6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnQsXG4gICAgY29tcG9uZW50czogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHMsXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jLFxuICAgIGdldENvbXBvbmVudHM6IGZ1bmNcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSb3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSb3V0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgTGlmZWN5Y2xlIG1peGluIGFkZHMgdGhlIHJvdXRlcldpbGxMZWF2ZSBsaWZlY3ljbGUgbWV0aG9kIHRvIGFcbiAqIGNvbXBvbmVudCB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCBhIHRyYW5zaXRpb24gb3IgcHJvbXB0IHRoZSB1c2VyXG4gKiBmb3IgY29uZmlybWF0aW9uLlxuICpcbiAqIE9uIHN0YW5kYXJkIHRyYW5zaXRpb25zLCByb3V0ZXJXaWxsTGVhdmUgcmVjZWl2ZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZVxuICogbG9jYXRpb24gd2UncmUgdHJhbnNpdGlvbmluZyB0by4gVG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLCByZXR1cm4gZmFsc2UuXG4gKiBUbyBwcm9tcHQgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbiwgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykuXG4gKlxuICogRHVyaW5nIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgKGFzc3VtaW5nIHlvdSdyZSB1c2luZyB0aGUgdXNlQmVmb3JlVW5sb2FkXG4gKiBoaXN0b3J5IGVuaGFuY2VyKSwgcm91dGVyV2lsbExlYXZlIGRvZXMgbm90IHJlY2VpdmUgYSBsb2NhdGlvbiBvYmplY3RcbiAqIGJlY2F1c2UgaXQgaXNuJ3QgcG9zc2libGUgZm9yIHVzIHRvIGtub3cgdGhlIGxvY2F0aW9uIHdlJ3JlIHRyYW5zaXRpb25pbmdcbiAqIHRvLiBJbiB0aGlzIGNhc2Ugcm91dGVyV2lsbExlYXZlIG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudFxuICogdGhlIHVzZXIgZnJvbSBjbG9zaW5nIHRoZSB3aW5kb3cvdGFiLlxuICovXG5cbnZhciBMaWZlY3ljbGUgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgLy8gTmVzdGVkIGNoaWxkcmVuIHJlY2VpdmUgdGhlIHJvdXRlIGFzIGNvbnRleHQsIGVpdGhlclxuICAgIC8vIHNldCBieSB0aGUgcm91dGUgY29tcG9uZW50IHVzaW5nIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW5cbiAgICAvLyBvciBieSBzb21lIG90aGVyIGFuY2VzdG9yLlxuICAgIHJvdXRlOiBvYmplY3RcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICAvLyBSb3V0ZSBjb21wb25lbnRzIHJlY2VpdmUgdGhlIHJvdXRlIG9iamVjdCBhcyBhIHByb3AuXG4gICAgcm91dGU6IG9iamVjdFxuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ3RoZSBgTGlmZWN5Y2xlYCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlci5zZXRSb3V0ZUxlYXZlSG9vayhyb3V0ZSwgaG9vaylgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItbGlmZWN5Y2xlbWl4aW4nKSA6IHZvaWQgMDtcbiAgICAhdGhpcy5yb3V0ZXJXaWxsTGVhdmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiByZXF1aXJlcyB5b3UgdG8gZGVmaW5lIGEgcm91dGVyV2lsbExlYXZlIG1ldGhvZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciByb3V0ZSA9IHRoaXMucHJvcHMucm91dGUgfHwgdGhpcy5jb250ZXh0LnJvdXRlO1xuXG4gICAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBMaWZlY3ljbGUgbWl4aW4gbXVzdCBiZSB1c2VkIG9uIGVpdGhlciBhKSBhIDxSb3V0ZSBjb21wb25lbnQ+IG9yICcgKyAnYikgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlIGNvbXBvbmVudD4gdGhhdCB1c2VzIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSA9IHRoaXMuY29udGV4dC5oaXN0b3J5Lmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXJXaWxsTGVhdmUpO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKSB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSgpO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaWZlY3ljbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0xpZmVjeWNsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcblxuLyoqXG4gKiBBIDxSb3V0ZT4gaXMgdXNlZCB0byBkZWNsYXJlIHdoaWNoIGNvbXBvbmVudHMgYXJlIHJlbmRlcmVkIHRvIHRoZVxuICogcGFnZSB3aGVuIHRoZSBVUkwgbWF0Y2hlcyBhIGdpdmVuIHBhdHRlcm4uXG4gKlxuICogUm91dGVzIGFyZSBhcnJhbmdlZCBpbiBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZS4gV2hlbiBhIG5ldyBVUkwgaXNcbiAqIHJlcXVlc3RlZCwgdGhlIHRyZWUgaXMgc2VhcmNoZWQgZGVwdGgtZmlyc3QgdG8gZmluZCBhIHJvdXRlIHdob3NlXG4gKiBwYXRoIG1hdGNoZXMgdGhlIFVSTC4gIFdoZW4gb25lIGlzIGZvdW5kLCBhbGwgcm91dGVzIGluIHRoZSB0cmVlXG4gKiB0aGF0IGxlYWQgdG8gaXQgYXJlIGNvbnNpZGVyZWQgXCJhY3RpdmVcIiBhbmQgdGhlaXIgY29tcG9uZW50cyBhcmVcbiAqIHJlbmRlcmVkIGludG8gdGhlIERPTSwgbmVzdGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIGluIHRoZSB0cmVlLlxuICovXG5cbnZhciBSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGUnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cyxcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG9iamVjdCA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIFRoZSBSb3V0ZUNvbnRleHQgbWl4aW4gcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSBmb3Igcm91dGVcbiAqIGNvbXBvbmVudHMgdG8gc2V0IHRoZSByb3V0ZSBpbiBjb250ZXh0LiBUaGlzIGlzIG5lZWRlZCBmb3JcbiAqIHJvdXRlcyB0aGF0IHJlbmRlciBlbGVtZW50cyB0aGF0IHdhbnQgdG8gdXNlIHRoZSBMaWZlY3ljbGVcbiAqIG1peGluIHRvIHByZXZlbnQgdHJhbnNpdGlvbnMuXG4gKi9cblxudmFyIFJvdXRlQ29udGV4dCA9IHtcblxuICBwcm9wVHlwZXM6IHtcbiAgICByb3V0ZTogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIHJvdXRlOiBvYmplY3QuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZTogdGhpcy5wcm9wcy5yb3V0ZVxuICAgIH07XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIGBSb3V0ZUNvbnRleHRgIG1peGluIGlzIGRlcHJlY2F0ZWQuIFlvdSBjYW4gcHJvdmlkZSBgdGhpcy5wcm9wcy5yb3V0ZWAgb24gY29udGV4dCB3aXRoIHlvdXIgb3duIGBjb250ZXh0VHlwZXNgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItcm91dGVjb250ZXh0bWl4aW4nKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZUNvbnRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGFzaEhpc3RvcnkpO1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUm91dGVyVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlclV0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gaXNEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gIHJldHVybiAhaGlzdG9yeSB8fCAhaGlzdG9yeS5fX3YyX2NvbXBhdGlibGVfXztcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICAvLyB2MyBoaXN0b3JpZXMgZXhwb3NlIGdldEN1cnJlbnRMb2NhdGlvbiwgYnV0IGFyZW4ndCBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICByZXR1cm4gaGlzdG9yeSAmJiBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbjtcbn1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyPiBpcyBhIGhpZ2gtbGV2ZWwgQVBJIGZvciBhdXRvbWF0aWNhbGx5IHNldHRpbmcgdXBcbiAqIGEgcm91dGVyIHRoYXQgcmVuZGVycyBhIDxSb3V0ZXJDb250ZXh0PiB3aXRoIGFsbCB0aGUgcHJvcHNcbiAqIGl0IG5lZWRzIGVhY2ggdGltZSB0aGUgVVJMIGNoYW5nZXMuXG4gKi9cblxudmFyIFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGVyJyxcblxuXG4gIHByb3BUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdCxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcyxcbiAgICByb3V0ZXM6IF9JbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXMsIC8vIGFsaWFzIGZvciBjaGlsZHJlblxuICAgIHJlbmRlcjogZnVuYyxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLFxuICAgIG9uRXJyb3I6IGZ1bmMsXG4gICAgb25VcGRhdGU6IGZ1bmMsXG5cbiAgICAvLyBEZXByZWNhdGVkOlxuICAgIHBhcnNlUXVlcnlTdHJpbmc6IGZ1bmMsXG4gICAgc3RyaW5naWZ5UXVlcnk6IGZ1bmMsXG5cbiAgICAvLyBQUklWQVRFOiBGb3IgY2xpZW50LXNpZGUgcmVoeWRyYXRpb24gb2Ygc2VydmVyIG1hdGNoLlxuICAgIG1hdGNoQ29udGV4dDogb2JqZWN0XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHByb3BzKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgcHJvcHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhdGlvbjogbnVsbCxcbiAgICAgIHJvdXRlczogbnVsbCxcbiAgICAgIHBhcmFtczogbnVsbCxcbiAgICAgIGNvbXBvbmVudHM6IG51bGxcbiAgICB9O1xuICB9LFxuICBoYW5kbGVFcnJvcjogZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRocm93IGVycm9ycyBieSBkZWZhdWx0IHNvIHdlIGRvbid0IHNpbGVudGx5IHN3YWxsb3cgdGhlbSFcbiAgICAgIHRocm93IGVycm9yOyAvLyBUaGlzIGVycm9yIHByb2JhYmx5IG9jY3VycmVkIGluIGdldENoaWxkUm91dGVzIG9yIGdldENvbXBvbmVudHMuXG4gICAgfVxuICB9LFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBfcHJvcHMucGFyc2VRdWVyeVN0cmluZztcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBfcHJvcHMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSghKHBhcnNlUXVlcnlTdHJpbmcgfHwgc3RyaW5naWZ5UXVlcnkpLCAnYHBhcnNlUXVlcnlTdHJpbmdgIGFuZCBgc3RyaW5naWZ5UXVlcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgY3JlYXRlIGEgY3VzdG9tIGhpc3RvcnkuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jdXN0b21xdWVyeXN0cmluZycpIDogdm9pZCAwO1xuXG4gICAgdmFyIF9jcmVhdGVSb3V0ZXJPYmplY3RzID0gdGhpcy5jcmVhdGVSb3V0ZXJPYmplY3RzKCk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLmhpc3Rvcnk7XG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gX2NyZWF0ZVJvdXRlck9iamVjdHMudHJhbnNpdGlvbk1hbmFnZXI7XG4gICAgdmFyIHJvdXRlciA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLnJvdXRlcjtcblxuXG4gICAgdGhpcy5fdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW4oZnVuY3Rpb24gKGVycm9yLCBzdGF0ZSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlLCBfdGhpcy5wcm9wcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB9LFxuICBjcmVhdGVSb3V0ZXJPYmplY3RzOiBmdW5jdGlvbiBjcmVhdGVSb3V0ZXJPYmplY3RzKCkge1xuICAgIHZhciBtYXRjaENvbnRleHQgPSB0aGlzLnByb3BzLm1hdGNoQ29udGV4dDtcblxuICAgIGlmIChtYXRjaENvbnRleHQpIHtcbiAgICAgIHJldHVybiBtYXRjaENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLnByb3BzLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciByb3V0ZXMgPSBfcHJvcHMyLnJvdXRlcztcbiAgICB2YXIgY2hpbGRyZW4gPSBfcHJvcHMyLmNoaWxkcmVuO1xuXG5cbiAgICAhIWlzVW5zdXBwb3J0ZWRIaXN0b3J5KGhpc3RvcnkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBoYXZlIHByb3ZpZGVkIGEgaGlzdG9yeSBvYmplY3QgY3JlYXRlZCB3aXRoIGhpc3RvcnkgdjMueC4gJyArICdUaGlzIHZlcnNpb24gb2YgUmVhY3QgUm91dGVyIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdjMgaGlzdG9yeSAnICsgJ29iamVjdHMuIFBsZWFzZSB1c2UgaGlzdG9yeSB2Mi54IGluc3RlYWQuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgaWYgKGlzRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkpIHtcbiAgICAgIGhpc3RvcnkgPSB0aGlzLndyYXBEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMgfHwgY2hpbGRyZW4pKTtcbiAgICB2YXIgcm91dGVyID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgICB2YXIgcm91dGluZ0hpc3RvcnkgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiByb3V0aW5nSGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXI6IHRyYW5zaXRpb25NYW5hZ2VyLCByb3V0ZXI6IHJvdXRlciB9O1xuICB9LFxuICB3cmFwRGVwcmVjYXRlZEhpc3Rvcnk6IGZ1bmN0aW9uIHdyYXBEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gICAgdmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gX3Byb3BzMy5wYXJzZVF1ZXJ5U3RyaW5nO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IF9wcm9wczMuc3RyaW5naWZ5UXVlcnk7XG5cblxuICAgIHZhciBjcmVhdGVIaXN0b3J5ID0gdm9pZCAwO1xuICAgIGlmIChoaXN0b3J5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0l0IGFwcGVhcnMgeW91IGhhdmUgcHJvdmlkZWQgYSBkZXByZWNhdGVkIGhpc3Rvcnkgb2JqZWN0IHRvIGA8Um91dGVyLz5gLCBwbGVhc2UgdXNlIGEgaGlzdG9yeSBwcm92aWRlZCBieSAnICsgJ1JlYWN0IFJvdXRlciB3aXRoIGBpbXBvcnQgeyBicm93c2VySGlzdG9yeSB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYCBvciBgaW1wb3J0IHsgaGFzaEhpc3RvcnkgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2AuICcgKyAnSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSBoaXN0b3J5IHBsZWFzZSBjcmVhdGUgaXQgd2l0aCBgdXNlUm91dGVySGlzdG9yeWAsIHNlZSBodHRwOi8vdGlueS5jYy9yb3V0ZXItdXNpbmdoaXN0b3J5IGZvciBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgUm91dGVyYCBubyBsb25nZXIgZGVmYXVsdHMgdGhlIGhpc3RvcnkgcHJvcCB0byBoYXNoIGhpc3RvcnkuIFBsZWFzZSB1c2UgdGhlIGBoYXNoSGlzdG9yeWAgc2luZ2xldG9uIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1kZWZhdWx0aGlzdG9yeScpIDogdm9pZCAwO1xuICAgICAgY3JlYXRlSGlzdG9yeSA9IF9jcmVhdGVIYXNoSGlzdG9yeTIuZGVmYXVsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSh7IHBhcnNlUXVlcnlTdHJpbmc6IHBhcnNlUXVlcnlTdHJpbmcsIHN0cmluZ2lmeVF1ZXJ5OiBzdHJpbmdpZnlRdWVyeSB9KTtcbiAgfSxcblxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShuZXh0UHJvcHMuaGlzdG9yeSA9PT0gdGhpcy5wcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KSgobmV4dFByb3BzLnJvdXRlcyB8fCBuZXh0UHJvcHMuY2hpbGRyZW4pID09PSAodGhpcy5wcm9wcy5yb3V0ZXMgfHwgdGhpcy5wcm9wcy5jaGlsZHJlbiksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIHJvdXRlcz47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdm9pZCAwO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuKSB0aGlzLl91bmxpc3RlbigpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgbG9jYXRpb24gPSBfc3RhdGUubG9jYXRpb247XG4gICAgdmFyIHJvdXRlcyA9IF9zdGF0ZS5yb3V0ZXM7XG4gICAgdmFyIHBhcmFtcyA9IF9zdGF0ZS5wYXJhbXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBfc3RhdGUuY29tcG9uZW50cztcbiAgICB2YXIgX3Byb3BzNCA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGNyZWF0ZUVsZW1lbnQgPSBfcHJvcHM0LmNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIHJlbmRlciA9IF9wcm9wczQucmVuZGVyO1xuXG4gICAgdmFyIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wczQsIFsnY3JlYXRlRWxlbWVudCcsICdyZW5kZXInXSk7XG5cbiAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkgcmV0dXJuIG51bGw7IC8vIEFzeW5jIG1hdGNoXG5cbiAgICAvLyBPbmx5IGZvcndhcmQgbm9uLVJvdXRlci1zcGVjaWZpYyBwcm9wcyB0byByb3V0aW5nIGNvbnRleHQsIGFzIHRob3NlIGFyZVxuICAgIC8vIHRoZSBvbmx5IG9uZXMgdGhhdCBtaWdodCBiZSBjdXN0b20gcm91dGluZyBjb250ZXh0IHByb3BzLlxuICAgIE9iamVjdC5rZXlzKFJvdXRlci5wcm9wVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BUeXBlKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIHByb3BzW3Byb3BUeXBlXTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZW5kZXIoX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICByb3V0ZXI6IHRoaXMucm91dGVyLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcm91dGVzOiByb3V0ZXMsXG4gICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50XG4gICAgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgUm91dGluZ0NvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRpbmdDb250ZXh0JyxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgUm91dGluZ0NvbnRleHRgIGhhcyBiZWVuIHJlbmFtZWQgdG8gYFJvdXRlckNvbnRleHRgLiBQbGVhc2UgdXNlIGBpbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItcm91dGVyY29udGV4dCcpIDogdm9pZCAwO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHRoaXMucHJvcHMpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGluZ0NvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMTc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJ1bkVudGVySG9va3MgPSBydW5FbnRlckhvb2tzO1xuZXhwb3J0cy5ydW5DaGFuZ2VIb29rcyA9IHJ1bkNoYW5nZUhvb2tzO1xuZXhwb3J0cy5ydW5MZWF2ZUhvb2tzID0gcnVuTGVhdmVIb29rcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25Ib29rKGhvb2ssIHJvdXRlLCBhc3luY0FyaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaG9vay5hcHBseShyb3V0ZSwgYXJncyk7XG5cbiAgICBpZiAoaG9vay5sZW5ndGggPCBhc3luY0FyaXR5KSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAvLyBBc3N1bWUgaG9vayBleGVjdXRlcyBzeW5jaHJvbm91c2x5IGFuZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBjYWxsIHRoZSBjYWxsYmFjay5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbnRlckhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uRW50ZXIpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25FbnRlciwgcm91dGUsIDMpKTtcblxuICAgIHJldHVybiBob29rcztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkNoYW5nZSkgaG9va3MucHVzaChjcmVhdGVUcmFuc2l0aW9uSG9vayhyb3V0ZS5vbkNoYW5nZSwgcm91dGUsIDQpKTtcbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2tzKGxlbmd0aCwgaXRlciwgY2FsbGJhY2spIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWRpcmVjdEluZm8gPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24sIGRlcHJlY2F0ZWRQYXRobmFtZSwgZGVwcmVjYXRlZFF1ZXJ5KSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRQYXRobmFtZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRobmFtZSwgcXVlcnkpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBgcmVwbGFjZShsb2NhdGlvbilgIHdpdGggYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcbiAgICAgIHJlZGlyZWN0SW5mbyA9IHtcbiAgICAgICAgcGF0aG5hbWU6IGRlcHJlY2F0ZWRQYXRobmFtZSxcbiAgICAgICAgcXVlcnk6IGRlcHJlY2F0ZWRRdWVyeSxcbiAgICAgICAgc3RhdGU6IGxvY2F0aW9uXG4gICAgICB9O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVkaXJlY3RJbmZvID0gbG9jYXRpb247XG4gIH1cblxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShsZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIGl0ZXIoaW5kZXgsIHJlcGxhY2UsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykge1xuICAgICAgICBkb25lKGVycm9yLCByZWRpcmVjdEluZm8pOyAvLyBObyBuZWVkIHRvIGNvbnRpbnVlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25FbnRlciBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXG4gKiB3aXRoIG9uRW50ZXIobmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RJbmZvKSB3aGVuIGZpbmlzaGVkLiBUaGUgZmlyc3QgaG9va1xuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXG4gKlxuICogSWYgYSBob29rIG5lZWRzIHRvIHJ1biBhc3luY2hyb25vdXNseSwgaXQgbWF5IHVzZSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXG4gKi9cbmZ1bmN0aW9uIHJ1bkVudGVySG9va3Mocm91dGVzLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldEVudGVySG9va3Mocm91dGVzKTtcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xuICAgIGhvb2tzW2luZGV4XShuZXh0U3RhdGUsIHJlcGxhY2UsIG5leHQpO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25DaGFuZ2UgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkNoYW5nZShwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5DaGFuZ2VIb29rcyhyb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldENoYW5nZUhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICBob29rc1tpbmRleF0oc3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgbmV4dCk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkxlYXZlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHJ1bkxlYXZlSG9va3Mocm91dGVzLCBwcmV2U3RhdGUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChyb3V0ZXNbaV0ub25MZWF2ZSkgcm91dGVzW2ldLm9uTGVhdmUuY2FsbChyb3V0ZXNbaV0sIHByZXZTdGF0ZSk7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1RyYW5zaXRpb25VdGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goZnVuY3Rpb24gKG1pZGRsZXdhcmUsIGluZGV4KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShtaWRkbGV3YXJlLnJlbmRlclJvdXRlckNvbnRleHQgfHwgbWlkZGxld2FyZS5yZW5kZXJSb3V0ZUNvbXBvbmVudCwgJ1RoZSBtaWRkbGV3YXJlIHNwZWNpZmllZCBhdCBpbmRleCAnICsgaW5kZXggKyAnIGRvZXMgbm90IGFwcGVhciB0byBiZSAnICsgJ2EgdmFsaWQgUmVhY3QgUm91dGVyIG1pZGRsZXdhcmUuJykgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2l0aENvbnRleHQgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZXJDb250ZXh0O1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIHZhciB3aXRoQ29tcG9uZW50ID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmUucmVuZGVyUm91dGVDb21wb25lbnQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICB2YXIgbWFrZUNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBtYWtlQ3JlYXRlRWxlbWVudCgpIHtcbiAgICB2YXIgYmFzZUNyZWF0ZUVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBfcmVhY3QuY3JlYXRlRWxlbWVudCA6IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiB3aXRoQ29tcG9uZW50LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclJvdXRlQ29tcG9uZW50KHByZXZpb3VzLCBwcm9wcyk7XG4gICAgICB9LCBiYXNlQ3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHdpdGhDb250ZXh0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVyQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlbmRlclJvdXRlckNvbnRleHQocHJldmlvdXMsIHJlbmRlclByb3BzKTtcbiAgICB9LCBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgX2V4dGVuZHMoe30sIHJlbmRlclByb3BzLCB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBtYWtlQ3JlYXRlRWxlbWVudChyZW5kZXJQcm9wcy5jcmVhdGVFbGVtZW50KVxuICAgIH0pKSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVCcm93c2VySGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUJyb3dzZXJIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5mdW5jdGlvbiByb3V0ZVBhcmFtc0NoYW5nZWQocm91dGUsIHByZXZTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBwYXJhbU5hbWVzID0gKDAsIF9QYXR0ZXJuVXRpbHMuZ2V0UGFyYW1OYW1lcykocm91dGUucGF0aCk7XG5cbiAgcmV0dXJuIHBhcmFtTmFtZXMuc29tZShmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgcmV0dXJuIHByZXZTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXSAhPT0gbmV4dFN0YXRlLnBhcmFtc1twYXJhbU5hbWVdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB7IGxlYXZlUm91dGVzLCBjaGFuZ2VSb3V0ZXMsIGVudGVyUm91dGVzIH0gZGV0ZXJtaW5lZCBieVxuICogdGhlIGNoYW5nZSBmcm9tIHByZXZTdGF0ZSB0byBuZXh0U3RhdGUuIFdlIGxlYXZlIHJvdXRlcyBpZiBlaXRoZXJcbiAqIDEpIHRoZXkgYXJlIG5vdCBpbiB0aGUgbmV4dCBzdGF0ZSBvciAyKSB0aGV5IGFyZSBpbiB0aGUgbmV4dCBzdGF0ZVxuICogYnV0IHRoZWlyIHBhcmFtcyBoYXZlIGNoYW5nZWQgKGkuZS4gL3VzZXJzLzEyMyA9PiAvdXNlcnMvNDU2KS5cbiAqXG4gKiBsZWF2ZVJvdXRlcyBhcmUgb3JkZXJlZCBzdGFydGluZyBhdCB0aGUgbGVhZiByb3V0ZSBvZiB0aGUgdHJlZVxuICogd2UncmUgbGVhdmluZyB1cCB0byB0aGUgY29tbW9uIHBhcmVudCByb3V0ZS4gZW50ZXJSb3V0ZXMgYXJlIG9yZGVyZWRcbiAqIGZyb20gdGhlIHRvcCBvZiB0aGUgdHJlZSB3ZSdyZSBlbnRlcmluZyBkb3duIHRvIHRoZSBsZWFmIHJvdXRlLlxuICpcbiAqIGNoYW5nZVJvdXRlcyBhcmUgYW55IHJvdXRlcyB0aGF0IGRpZG4ndCBsZWF2ZSBvciBlbnRlciBkdXJpbmdcbiAqIHRoZSB0cmFuc2l0aW9uLlxuICovXG5mdW5jdGlvbiBjb21wdXRlQ2hhbmdlZFJvdXRlcyhwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xuICB2YXIgcHJldlJvdXRlcyA9IHByZXZTdGF0ZSAmJiBwcmV2U3RhdGUucm91dGVzO1xuICB2YXIgbmV4dFJvdXRlcyA9IG5leHRTdGF0ZS5yb3V0ZXM7XG5cbiAgdmFyIGxlYXZlUm91dGVzID0gdm9pZCAwLFxuICAgICAgY2hhbmdlUm91dGVzID0gdm9pZCAwLFxuICAgICAgZW50ZXJSb3V0ZXMgPSB2b2lkIDA7XG4gIGlmIChwcmV2Um91dGVzKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnRJc0xlYXZpbmcgPSBmYWxzZTtcbiAgICAgIGxlYXZlUm91dGVzID0gcHJldlJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChwYXJlbnRJc0xlYXZpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaXNMZWF2aW5nID0gbmV4dFJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTEgfHwgcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgaWYgKGlzTGVhdmluZykgcGFyZW50SXNMZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaXNMZWF2aW5nO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gb25MZWF2ZSBob29rcyBzdGFydCBhdCB0aGUgbGVhZiByb3V0ZS5cbiAgICAgIGxlYXZlUm91dGVzLnJldmVyc2UoKTtcblxuICAgICAgZW50ZXJSb3V0ZXMgPSBbXTtcbiAgICAgIGNoYW5nZVJvdXRlcyA9IFtdO1xuXG4gICAgICBuZXh0Um91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHZhciBpc05ldyA9IHByZXZSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuICAgICAgICB2YXIgcGFyYW1zQ2hhbmdlZCA9IGxlYXZlUm91dGVzLmluZGV4T2Yocm91dGUpICE9PSAtMTtcblxuICAgICAgICBpZiAoaXNOZXcgfHwgcGFyYW1zQ2hhbmdlZCkgZW50ZXJSb3V0ZXMucHVzaChyb3V0ZSk7ZWxzZSBjaGFuZ2VSb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGxlYXZlUm91dGVzID0gW107XG4gICAgY2hhbmdlUm91dGVzID0gW107XG4gICAgZW50ZXJSb3V0ZXMgPSBuZXh0Um91dGVzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsZWF2ZVJvdXRlczogbGVhdmVSb3V0ZXMsXG4gICAgY2hhbmdlUm91dGVzOiBjaGFuZ2VSb3V0ZXMsXG4gICAgZW50ZXJSb3V0ZXM6IGVudGVyUm91dGVzXG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvbXB1dGVDaGFuZ2VkUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24gPSByZXF1aXJlKCcuL21ha2VTdGF0ZVdpdGhMb2NhdGlvbicpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlU3RhdGVXaXRoTG9jYXRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzRm9yUm91dGUobmV4dFN0YXRlLCByb3V0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNvbXBvbmVudCB8fCByb3V0ZS5jb21wb25lbnRzKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXRDb21wb25lbnQgPSByb3V0ZS5nZXRDb21wb25lbnQgfHwgcm91dGUuZ2V0Q29tcG9uZW50cztcbiAgaWYgKCFnZXRDb21wb25lbnQpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsb2NhdGlvbiA9IG5leHRTdGF0ZS5sb2NhdGlvbjtcblxuICB2YXIgbmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKG5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gIGdldENvbXBvbmVudC5jYWxsKHJvdXRlLCBuZXh0U3RhdGVXaXRoTG9jYXRpb24sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBmZXRjaGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgdGhlIGdpdmVuIHJvdXRlclxuICogc3RhdGUgYW5kIGNhbGxzIGNhbGxiYWNrKGVycm9yLCBjb21wb25lbnRzKSB3aGVuIGZpbmlzaGVkLlxuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENvbXBvbmVudHMgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgKDAsIF9Bc3luY1V0aWxzLm1hcEFzeW5jKShuZXh0U3RhdGUucm91dGVzLCBmdW5jdGlvbiAocm91dGUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjayk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Q29tcG9uZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbi8qKlxuICogRXh0cmFjdHMgYW4gb2JqZWN0IG9mIHBhcmFtcyB0aGUgZ2l2ZW4gcm91dGUgY2FyZXMgYWJvdXQgZnJvbVxuICogdGhlIGdpdmVuIHBhcmFtcyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdXRlUGFyYW1zKHJvdXRlLCBwYXJhbXMpIHtcbiAgdmFyIHJvdXRlUGFyYW1zID0ge307XG5cbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gcm91dGVQYXJhbXM7XG5cbiAgKDAsIF9QYXR0ZXJuVXRpbHMuZ2V0UGFyYW1OYW1lcykocm91dGUucGF0aCkuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBwKSkge1xuICAgICAgcm91dGVQYXJhbXNbcF0gPSBwYXJhbXNbcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcm91dGVQYXJhbXM7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFJvdXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWN0aXZlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSkpID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIHAgaW4gYSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgcCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhW3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGJbcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChhW3BdLCBiW3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHBhdGhuYW1lIG1hdGNoZXMgdGhlIHN1cHBsaWVkIG9uZSwgbmV0IG9mXG4gKiBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaCBub3JtYWxpemF0aW9uLiBUaGlzIGlzIHN1ZmZpY2llbnQgZm9yIGFuXG4gKiBpbmRleE9ubHkgcm91dGUgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIHBhdGhJc0FjdGl2ZShwYXRobmFtZSwgY3VycmVudFBhdGhuYW1lKSB7XG4gIC8vIE5vcm1hbGl6ZSBsZWFkaW5nIHNsYXNoIGZvciBjb25zaXN0ZW5jeS4gTGVhZGluZyBzbGFzaCBvbiBwYXRobmFtZSBoYXNcbiAgLy8gYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgaW4gaXNBY3RpdmUuIFNlZSBjYXZlYXQgdGhlcmUuXG4gIGlmIChjdXJyZW50UGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBjdXJyZW50UGF0aG5hbWUgPSAnLycgKyBjdXJyZW50UGF0aG5hbWU7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgdGhlIGVuZCBvZiBib3RoIHBhdGggbmFtZXMgdG9vLiBNYXliZSBgL2Zvby9gIHNob3VsZG4ndCBzaG93XG4gIC8vIGAvZm9vYCBhcyBhY3RpdmUsIGJ1dCBpbiB0aGlzIGNhc2UsIHdlIHdvdWxkIGFscmVhZHkgaGF2ZSBmYWlsZWQgdGhlXG4gIC8vIG1hdGNoLlxuICBpZiAocGF0aG5hbWUuY2hhckF0KHBhdGhuYW1lLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICBwYXRobmFtZSArPSAnLyc7XG4gIH1cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoY3VycmVudFBhdGhuYW1lLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICBjdXJyZW50UGF0aG5hbWUgKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRQYXRobmFtZSA9PT0gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRobmFtZSBtYXRjaGVzIHRoZSBhY3RpdmUgcm91dGVzIGFuZCBwYXJhbXMuXG4gKi9cbmZ1bmN0aW9uIHJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSB7XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLFxuICAgICAgcGFyYW1OYW1lcyA9IFtdLFxuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcblxuICAvLyBmb3IuLi5vZiB3b3VsZCB3b3JrIGhlcmUgYnV0IGl0J3MgcHJvYmFibHkgc2xvd2VyIHBvc3QtdHJhbnNwaWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICAgIHBhcmFtVmFsdWVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsICYmIHBhdHRlcm4pIHtcbiAgICAgIHZhciBtYXRjaGVkID0gKDAsIF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKShwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09ICcnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gZXhhY3QgbWF0Y2ggb24gdGhlIHJvdXRlLiBKdXN0IGNoZWNrIHRoYXQgYWxsIHRoZSBwYXJhbXNcbiAgICAgICAgLy8gbWF0Y2guXG4gICAgICAgIC8vIEZJWE1FOiBUaGlzIGRvZXNuJ3Qgd29yayBvbiByZXBlYXRlZCBwYXJhbXMuXG4gICAgICAgIHJldHVybiBwYXJhbU5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbVZhbHVlc1tpbmRleF0pID09PSBTdHJpbmcocGFyYW1zW3BhcmFtTmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFsbCBrZXkvdmFsdWUgcGFpcnMgaW4gdGhlIGdpdmVuIHF1ZXJ5IGFyZVxuICogY3VycmVudGx5IGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gcXVlcnlJc0FjdGl2ZShxdWVyeSwgYWN0aXZlUXVlcnkpIHtcbiAgaWYgKGFjdGl2ZVF1ZXJ5ID09IG51bGwpIHJldHVybiBxdWVyeSA9PSBudWxsO1xuXG4gIGlmIChxdWVyeSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICByZXR1cm4gZGVlcEVxdWFsKHF1ZXJ5LCBhY3RpdmVRdWVyeSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgPExpbms+IHRvIHRoZSBnaXZlbiBwYXRobmFtZS9xdWVyeSBjb21iaW5hdGlvbiBpc1xuICogY3VycmVudGx5IGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNBY3RpdmUoX3JlZiwgaW5kZXhPbmx5LCBjdXJyZW50TG9jYXRpb24sIHJvdXRlcywgcGFyYW1zKSB7XG4gIHZhciBwYXRobmFtZSA9IF9yZWYucGF0aG5hbWU7XG4gIHZhciBxdWVyeSA9IF9yZWYucXVlcnk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBhIGJpdCB1Z2x5LiBJdCBrZWVwcyBhcm91bmQgc3VwcG9ydCBmb3IgdHJlYXRpbmcgcGF0aG5hbWVzXG4gIC8vIHdpdGhvdXQgcHJlY2VkaW5nIHNsYXNoZXMgYXMgYWJzb2x1dGUgcGF0aHMsIGJ1dCBwb3NzaWJseSBhbHNvIHdvcmtzXG4gIC8vIGFyb3VuZCB0aGUgc2FtZSBxdWlya3Mgd2l0aCBiYXNlbmFtZXMgYXMgaW4gbWF0Y2hSb3V0ZXMuXG4gIGlmIChwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH1cblxuICBpZiAoIXBhdGhJc0FjdGl2ZShwYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgIC8vIFRoZSBwYXRoIGNoZWNrIGlzIG5lY2Vzc2FyeSBhbmQgc3VmZmljaWVudCBmb3IgaW5kZXhPbmx5LCBidXQgb3RoZXJ3aXNlXG4gICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBjaGVjayB0aGUgcm91dGVzLlxuICAgIGlmIChpbmRleE9ubHkgfHwgIXJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBjdXJyZW50TG9jYXRpb24ucXVlcnkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUm91dGVyVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlclV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyoqXG4gKiBBIGhpZ2gtbGV2ZWwgQVBJIHRvIGJlIHVzZWQgZm9yIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIG1hdGNoZXMgYSBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgcmVuZGVyUHJvcHMpIHdoZW4gZmluaXNoZWQuXG4gKlxuICogTm90ZTogWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgaW4gYSBicm93c2VyIHVubGVzcyB5b3UncmUgdXNpbmdcbiAqIHNlcnZlci1zaWRlIHJlbmRlcmluZyB3aXRoIGFzeW5jIHJvdXRlcy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goX3JlZiwgY2FsbGJhY2spIHtcbiAgdmFyIGhpc3RvcnkgPSBfcmVmLmhpc3Rvcnk7XG4gIHZhciByb3V0ZXMgPSBfcmVmLnJvdXRlcztcbiAgdmFyIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbjtcblxuICB2YXIgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2hpc3RvcnknLCAncm91dGVzJywgJ2xvY2F0aW9uJ10pO1xuXG4gICEoaGlzdG9yeSB8fCBsb2NhdGlvbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnbWF0Y2ggbmVlZHMgYSBoaXN0b3J5IG9yIGEgbG9jYXRpb24nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaGlzdG9yeSA9IGhpc3RvcnkgPyBoaXN0b3J5IDogKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykocm91dGVzKSk7XG5cbiAgdmFyIHVubGlzdGVuID0gdm9pZCAwO1xuXG4gIGlmIChsb2NhdGlvbikge1xuICAgIC8vIEFsbG93IG1hdGNoKHsgbG9jYXRpb246ICcvdGhlL3BhdGgnLCAuLi4gfSlcbiAgICBsb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIFBpY2sgdXAgdGhlIGxvY2F0aW9uIGZyb20gdGhlIGhpc3RvcnkgdmlhIHN5bmNocm9ub3VzIGhpc3RvcnkubGlzdGVuXG4gICAgLy8gY2FsbCBpZiBuZWVkZWQuXG4gICAgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoaGlzdG9yeUxvY2F0aW9uKSB7XG4gICAgICBsb2NhdGlvbiA9IGhpc3RvcnlMb2NhdGlvbjtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByb3V0ZXIgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdCkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICBoaXN0b3J5ID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0aW5nSGlzdG9yeSkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gIHRyYW5zaXRpb25NYW5hZ2VyLm1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCBuZXh0U3RhdGUgJiYgX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogcm91dGVyLFxuICAgICAgbWF0Y2hDb250ZXh0OiB7IGhpc3Rvcnk6IGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfVxuICAgIH0pKTtcblxuICAgIC8vIERlZmVyIHJlbW92aW5nIHRoZSBsaXN0ZW5lciB0byBoZXJlIHRvIHByZXZlbnQgRE9NIGhpc3RvcmllcyBmcm9tIGhhdmluZ1xuICAgIC8vIHRvIHVud2luZCBET00gZXZlbnQgbGlzdGVuZXJzIHVubmVjZXNzYXJpbHksIGluIGNhc2UgY2FsbGJhY2sgcmVuZGVycyBhXG4gICAgLy8gPFJvdXRlcj4gYW5kIGF0dGFjaGVzIGFub3RoZXIgaGlzdG9yeSBsaXN0ZW5lci5cbiAgICBpZiAodW5saXN0ZW4pIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21hdGNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaFJvdXRlcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uID0gcmVxdWlyZSgnLi9tYWtlU3RhdGVXaXRoTG9jYXRpb24nKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFrZVN0YXRlV2l0aExvY2F0aW9uKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgcmV0dXJuIFtudWxsLCByb3V0ZS5jaGlsZFJvdXRlc107XG4gIH1cbiAgaWYgKCFyb3V0ZS5nZXRDaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBzeW5jID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IHZvaWQgMDtcblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gIH07XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkocGFydGlhbE5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gIHJvdXRlLmdldENoaWxkUm91dGVzKHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICBjaGlsZFJvdXRlcyA9ICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShjaGlsZFJvdXRlcyk7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHJlc3VsdCA9IFtlcnJvciwgY2hpbGRSb3V0ZXNdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycm9yLCBjaGlsZFJvdXRlcyk7XG4gIH0pO1xuXG4gIHN5bmMgPSBmYWxzZTtcbiAgcmV0dXJuIHJlc3VsdDsgLy8gTWlnaHQgYmUgdW5kZWZpbmVkLlxufVxuXG5mdW5jdGlvbiBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5pbmRleFJvdXRlKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuaW5kZXhSb3V0ZSk7XG4gIH0gZWxzZSBpZiAocm91dGUuZ2V0SW5kZXhSb3V0ZSkge1xuICAgIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gICAgfTtcblxuICAgIHZhciBwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKHBhcnRpYWxOZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICAgIHJvdXRlLmdldEluZGV4Um91dGUocGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgIWVycm9yICYmICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGluZGV4Um91dGUpWzBdKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aGxlc3MgPSByb3V0ZS5jaGlsZFJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkUm91dGUpIHtcbiAgICAgICAgcmV0dXJuICFjaGlsZFJvdXRlLnBhdGg7XG4gICAgICB9KTtcblxuICAgICAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocGF0aGxlc3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShwYXRobGVzc1tpbmRleF0sIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yIHx8IGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZXMgPSBbcGF0aGxlc3NbaW5kZXhdXS5jb25jYXQoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSA/IGluZGV4Um91dGUgOiBbaW5kZXhSb3V0ZV0pO1xuICAgICAgICAgICAgZG9uZShlcnJvciwgcm91dGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyLCByb3V0ZXMpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcm91dGVzKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25QYXJhbXMocGFyYW1zLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gcGFyYW1OYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcGFyYW1OYW1lLCBpbmRleCkge1xuICAgIHZhciBwYXJhbVZhbHVlID0gcGFyYW1WYWx1ZXMgJiYgcGFyYW1WYWx1ZXNbaW5kZXhdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zW3BhcmFtTmFtZV0pKSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXS5wdXNoKHBhcmFtVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBbcGFyYW1zW3BhcmFtTmFtZV0sIHBhcmFtVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKSB7XG4gIHJldHVybiBhc3NpZ25QYXJhbXMoe30sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZURlZXAocm91dGUsIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgIHBhcmFtVmFsdWVzID0gW107XG4gIH1cblxuICAvLyBPbmx5IHRyeSB0byBtYXRjaCB0aGUgcGF0aCBpZiB0aGUgcm91dGUgYWN0dWFsbHkgaGFzIGEgcGF0dGVybiwgYW5kIGlmXG4gIC8vIHdlJ3JlIG5vdCBqdXN0IHNlYXJjaGluZyBmb3IgcG90ZW50aWFsIG5lc3RlZCBhYnNvbHV0ZSBwYXRocy5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsICYmIHBhdHRlcm4pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBCeSBhc3N1bXB0aW9uLCBwYXR0ZXJuIGlzIG5vbi1lbXB0eSBoZXJlLCB3aGljaCBpcyB0aGUgcHJlcmVxdWlzaXRlIGZvclxuICAgIC8vIGFjdHVhbGx5IHRlcm1pbmF0aW5nIGEgbWF0Y2guXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSAnJykge1xuICAgICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgICAgcm91dGVzOiBbcm91dGVdLFxuICAgICAgICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICAgICAgICB9O1xuXG4gICAgICAgIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4Um91dGUpKSB7XG4gICAgICAgICAgICAgIHZhciBfbWF0Y2gkcm91dGVzO1xuXG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGluZGV4Um91dGUuZXZlcnkoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFyb3V0ZS5wYXRoO1xuICAgICAgICAgICAgICB9KSwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgKF9tYXRjaCRyb3V0ZXMgPSBtYXRjaC5yb3V0ZXMpLnB1c2guYXBwbHkoX21hdGNoJHJvdXRlcywgaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoIWluZGV4Um91dGUucGF0aCwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgbWF0Y2gucm91dGVzLnB1c2goaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0MikpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT0gbnVsbCB8fCByb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIC8vIEVpdGhlciBhKSB0aGlzIHJvdXRlIG1hdGNoZWQgYXQgbGVhc3Qgc29tZSBvZiB0aGUgcGF0aCBvciBiKVxuICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gbG9hZCB0aGlzIHJvdXRlJ3MgY2hpbGRyZW4gYXN5bmNocm9ub3VzbHkuIEluXG4gICAgLy8gZWl0aGVyIGNhc2UgY29udGludWUgY2hlY2tpbmcgZm9yIG1hdGNoZXMgaW4gdGhlIHN1YnRyZWUuXG4gICAgdmFyIG9uQ2hpbGRSb3V0ZXMgPSBmdW5jdGlvbiBvbkNoaWxkUm91dGVzKGVycm9yLCBjaGlsZFJvdXRlcykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRSb3V0ZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGNoaWxkIHJvdXRlcyB0byBzZWUgaWYgYW55IG9mIHRoZW0gbWF0Y2guXG4gICAgICAgIG1hdGNoUm91dGVzKGNoaWxkUm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEEgY2hpbGQgcm91dGUgbWF0Y2hlZCEgQXVnbWVudCB0aGUgbWF0Y2ggYW5kIHBhc3MgaXQgdXAgdGhlIHN0YWNrLlxuICAgICAgICAgICAgbWF0Y2gucm91dGVzLnVuc2hpZnQocm91dGUpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRDaGlsZFJvdXRlcyhyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBvbkNoaWxkUm91dGVzKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBvbkNoaWxkUm91dGVzLmFwcGx5KHVuZGVmaW5lZCwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IG1hdGNoZXMgdGhlIGdpdmVuIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCBzdGF0ZSkgd2hlbiBmaW5pc2hlZC4gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIHJvdXRlcyAgICAgICBBbiBhcnJheSBvZiByb3V0ZXMgdGhhdCBtYXRjaGVkLCBpbiBoaWVyYXJjaGljYWwgb3JkZXJcbiAqIC0gcGFyYW1zICAgICAgIEFuIG9iamVjdCBvZiBVUkwgcGFyYW1ldGVyc1xuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENoaWxkUm91dGVzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbiwgY2FsbGJhY2ssIHJlbWFpbmluZ1BhdGhuYW1lKSB7XG4gIHZhciBwYXJhbU5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbNF07XG4gIHZhciBwYXJhbVZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNSB8fCBhcmd1bWVudHNbNV0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzVdO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBhIGxpdHRsZSBiaXQgdWdseSwgYnV0IGl0IHdvcmtzIGFyb3VuZCBhIHF1aXJrIGluIGhpc3RvcnlcbiAgICAvLyB0aGF0IHN0cmlwcyB0aGUgbGVhZGluZyBzbGFzaCBmcm9tIHBhdGhuYW1lcyB3aGVuIHVzaW5nIGJhc2VuYW1lcyB3aXRoXG4gICAgLy8gdHJhaWxpbmcgc2xhc2hlcy5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiAnLycgKyBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIH1cblxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShyb3V0ZXMubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICBtYXRjaFJvdXRlRGVlcChyb3V0ZXNbaW5kZXhdLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIG1hdGNoKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgbWF0Y2gpIHtcbiAgICAgICAgZG9uZShlcnJvciwgbWF0Y2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBjYWxsYmFjayk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21hdGNoUm91dGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBhYm91dCByb3V0aW5nLlxuICpcbiAqIEVuaGFuY2VzIGhpc3Rvcnkgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqXG4gKiAtIGxpc3RlbigoZXJyb3IsIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgKG5leHRMb2NhdGlvbikgPT4ge30pXG4gKiAtIG1hdGNoKGxvY2F0aW9uLCAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5PWZhbHNlKVxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZXMoY3JlYXRlSGlzdG9yeSkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2B1c2VSb3V0ZXNgIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciByb3V0ZXMgPSBfcmVmLnJvdXRlcztcblxuICAgIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsncm91dGVzJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKG9wdGlvbnMpO1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksIHJvdXRlcyk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHdpdGhSb3V0ZXI7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG5mdW5jdGlvbiB3aXRoUm91dGVyKFdyYXBwZWRDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHdpdGhSZWYgPSBvcHRpb25zICYmIG9wdGlvbnMud2l0aFJlZjtcblxuICB2YXIgV2l0aFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdXaXRoUm91dGVyJyxcblxuICAgIGNvbnRleHRUeXBlczogeyByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGUgfSxcbiAgICBwcm9wVHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG5cbiAgICBnZXRXcmFwcGVkSW5zdGFuY2U6IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICF3aXRoUmVmID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ2B7IHdpdGhSZWY6IHRydWUgfWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgd2l0aFJvdXRlcigpIGNhbGwuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnByb3BzLnJvdXRlciB8fCB0aGlzLmNvbnRleHQucm91dGVyO1xuICAgICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgcm91dGVyOiByb3V0ZXIgfSk7XG5cbiAgICAgIGlmICh3aXRoUmVmKSB7XG4gICAgICAgIHByb3BzLnJlZiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgX3RoaXMud3JhcHBlZEluc3RhbmNlID0gYztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuXG4gIFdpdGhSb3V0ZXIuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XG4gIFdpdGhSb3V0ZXIuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG5cbiAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyLmRlZmF1bHQpKFdpdGhSb3V0ZXIsIFdyYXBwZWRDb21wb25lbnQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi93aXRoUm91dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5leHBvcnRzLmxvb3BBc3luYyA9IGxvb3BBc3luYztcblxuZnVuY3Rpb24gbG9vcEFzeW5jKHR1cm5zLCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudFR1cm4gPSAwLFxuICAgICAgaXNEb25lID0gZmFsc2U7XG4gIHZhciBzeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBkb25lKCkge1xuICAgIGlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IFtdLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzTmV4dCA9IHRydWU7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luYyA9IHRydWU7XG5cbiAgICB3aGlsZSAoIWlzRG9uZSAmJiBjdXJyZW50VHVybiA8IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGhhc05leHQgPSBmYWxzZTtcbiAgICAgIHdvcmsuY2FsbCh0aGlzLCBjdXJyZW50VHVybisrLCBuZXh0LCBkb25lKTtcbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBUaGlzIG1lYW5zIHRoZSBsb29wIGZpbmlzaGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9ET01TdGF0ZVN0b3JhZ2UgPSByZXF1aXJlKCcuL0RPTVN0YXRlU3RvcmFnZScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZURPTUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZURPTUhpc3RvcnkpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgSFRNTDUncyBoaXN0b3J5IEFQSVxuICogKHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50KSB0byBtYW5hZ2UgaGlzdG9yeS5cbiAqIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIG1ldGhvZCBvZiBtYW5hZ2luZyBoaXN0b3J5IGluIGJyb3dzZXJzIGJlY2F1c2VcbiAqIGl0IHByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICpcbiAqIE5vdGU6IEluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGZ1bGxcbiAqIHBhZ2UgcmVsb2FkcyB3aWxsIGJlIHVzZWQgdG8gcHJlc2VydmUgVVJMcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgIV9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGZvcmNlUmVmcmVzaCA9IG9wdGlvbnMuZm9yY2VSZWZyZXNoO1xuXG4gIHZhciBpc1N1cHBvcnRlZCA9IF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIHVzZVJlZnJlc2ggPSAhaXNTdXBwb3J0ZWQgfHwgZm9yY2VSZWZyZXNoO1xuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB0cnkge1xuICAgICAgaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlIHx8IHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldFdpbmRvd1BhdGgoKTtcbiAgICB2YXIgX2hpc3RvcnlTdGF0ZSA9IGhpc3RvcnlTdGF0ZTtcbiAgICB2YXIga2V5ID0gX2hpc3RvcnlTdGF0ZS5rZXk7XG5cbiAgICB2YXIgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGtleSkge1xuICAgICAgc3RhdGUgPSBfRE9NU3RhdGVTdG9yYWdlLnJlYWRTdGF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuXG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgaGlzdG9yeVN0YXRlLCB7IGtleToga2V5IH0pLCBudWxsKTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihfcmVmKSB7XG4gICAgdmFyIHRyYW5zaXRpb25UbyA9IF9yZWYudHJhbnNpdGlvblRvO1xuXG4gICAgZnVuY3Rpb24gcG9wU3RhdGVMaXN0ZW5lcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cblxuICAgICAgdHJhbnNpdGlvblRvKGdldEN1cnJlbnRMb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICAgIH1cblxuICAgIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgcG9wU3RhdGVMaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAncG9wc3RhdGUnLCBwb3BTdGF0ZUxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoVHJhbnNpdGlvbihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICAgIHZhciBhY3Rpb24gPSBsb2NhdGlvbi5hY3Rpb247XG4gICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUoa2V5LCBzdGF0ZSk7XG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG4gICAgdmFyIGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgIGtleToga2V5XG4gICAgfTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGlmICh1c2VSZWZyZXNoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gcGF0aDtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQcmV2ZW50IGxvY2F0aW9uIHVwZGF0ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgbnVsbCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUkVQTEFDRVxuICAgICAgaWYgKHVzZVJlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UocGF0aCk7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gUHJldmVudCBsb2NhdGlvbiB1cGRhdGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlRE9NSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZVxuICB9KSk7XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwLFxuICAgICAgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIGhpc3RvcnkucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBoaXN0b3J5LnVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKTtcblxuICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICByZWdpc3RlclRyYW5zaXRpb25Ib29rOiByZWdpc3RlclRyYW5zaXRpb25Ib29rLFxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4gKiogbW9kdWxlIGlkID0gMTg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKCkge1xuICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnLycgOiBhcmd1bWVudHNbMF07XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBfZm91cnRoQXJnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1szXTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGNyZWF0ZUxvY2F0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhICcgKyAnbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgYWN0aW9uID0ga2V5IHx8IF9BY3Rpb25zLlBPUDtcbiAgICBrZXkgPSBfZm91cnRoQXJnO1xuICB9XG5cbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoIHx8ICcnO1xuICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2ggfHwgJyc7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlIHx8IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAga2V5OiBrZXlcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlTG9jYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVMb2NhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnN0YXRlO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGVudHJ5KSB7XG4gICAgbWVtb1tlbnRyeS5rZXldID0gZW50cnkuc3RhdGU7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IG9wdGlvbnMgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBbb3B0aW9uc10gfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogc2F2ZVN0YXRlLFxuICAgIGdvOiBnb1xuICB9KSk7XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucztcbiAgdmFyIGVudHJpZXMgPSBfb3B0aW9ucy5lbnRyaWVzO1xuICB2YXIgY3VycmVudCA9IF9vcHRpb25zLmN1cnJlbnQ7XG5cbiAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnc3RyaW5nJykge1xuICAgIGVudHJpZXMgPSBbZW50cmllc107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICBlbnRyaWVzID0gWycvJ107XG4gIH1cblxuICBlbnRyaWVzID0gZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykgcmV0dXJuIHsgcGF0aG5hbWU6IGVudHJ5LCBrZXk6IGtleSB9O1xuXG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ29iamVjdCcgJiYgZW50cnkpIHJldHVybiBfZXh0ZW5kcyh7fSwgZW50cnksIHsga2V5OiBrZXkgfSk7XG5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ1VuYWJsZSB0byBjcmVhdGUgaGlzdG9yeSBlbnRyeSBmcm9tICVzJywgZW50cnkpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH0pO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICBjdXJyZW50ID0gZW50cmllcy5sZW5ndGggLSAxO1xuICB9IGVsc2Uge1xuICAgICEoY3VycmVudCA+PSAwICYmIGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSwgJ0N1cnJlbnQgaW5kZXggbXVzdCBiZSA+PSAwIGFuZCA8ICVzLCB3YXMgJXMnLCBlbnRyaWVzLmxlbmd0aCwgY3VycmVudCkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBzdG9yYWdlID0gY3JlYXRlU3RhdGVTdG9yYWdlKGVudHJpZXMpO1xuXG4gIGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gICAgc3RvcmFnZVtrZXldID0gc3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2N1cnJlbnRdO1xuICAgIHZhciBiYXNlbmFtZSA9IGVudHJ5LmJhc2VuYW1lO1xuICAgIHZhciBwYXRobmFtZSA9IGVudHJ5LnBhdGhuYW1lO1xuICAgIHZhciBzZWFyY2ggPSBlbnRyeS5zZWFyY2g7XG5cbiAgICB2YXIgcGF0aCA9IChiYXNlbmFtZSB8fCAnJykgKyBwYXRobmFtZSArIChzZWFyY2ggfHwgJycpO1xuXG4gICAgdmFyIGtleSA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGVudHJ5LmtleSkge1xuICAgICAga2V5ID0gZW50cnkua2V5O1xuICAgICAgc3RhdGUgPSByZWFkU3RhdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGVudHJ5LmtleSA9IGtleTtcbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogc3RhdGUgfSksIHVuZGVmaW5lZCwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgaW5kZXggPSBjdXJyZW50ICsgbjtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IGVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIGlmIChuKSB7XG4gICAgICBpZiAoIWNhbkdvKG4pKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0Nhbm5vdCBnbyglcykgdGhlcmUgaXMgbm90IGVub3VnaCBoaXN0b3J5JywgbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCArPSBuO1xuXG4gICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG5cbiAgICAgIC8vIGNoYW5nZSBhY3Rpb24gdG8gUE9QXG4gICAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhfZXh0ZW5kcyh7fSwgY3VycmVudExvY2F0aW9uLCB7IGFjdGlvbjogX0FjdGlvbnMuUE9QIH0pKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgc3dpdGNoIChsb2NhdGlvbi5hY3Rpb24pIHtcbiAgICAgIGNhc2UgX0FjdGlvbnMuUFVTSDpcbiAgICAgICAgY3VycmVudCArPSAxO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3Qgb24gdGhlIHRvcCBvZiBzdGFja1xuICAgICAgICAvLyByZW1vdmUgcmVzdCBhbmQgcHVzaCBuZXdcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBlbnRyaWVzLmxlbmd0aCkgZW50cmllcy5zcGxpY2UoY3VycmVudCk7XG5cbiAgICAgICAgZW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX0FjdGlvbnMuUkVQTEFDRTpcbiAgICAgICAgZW50cmllc1tjdXJyZW50XSA9IGxvY2F0aW9uO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRyZXR1cm4gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XG5cdFx0dmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcblx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuXHRcdHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkO1xuXG5cdFx0a2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cblx0XHQvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdHJldFtrZXldLnB1c2godmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSwge30pO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiBvYmogPyBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0cmV0dXJuIHZhbC5zbGljZSgpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKHZhbDIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmljdFVyaUVuY29kZShrZXkpICsgJz0nICsgc3RyaWN0VXJpRW5jb2RlKHZhbDIpO1xuXHRcdFx0fSkuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuXHR9KS5qb2luKCcmJykgOiAnJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNVdGlsc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0F1dG9Gb2N1c1V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUgPSByZXF1aXJlKCcuL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZScpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNJbnB1dEV2ZW50Jyk7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZV1cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25TdGFydENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGU6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0OlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24gJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIGZhbGxiYWNrIG9iamVjdCwgaWYgYW55LlxudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0OlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kIHx8IGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5yZWxlYXNlKGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMTk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlPcGVyYXRpb25zXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKCcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoJ2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG52YXIgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSBmYWxzZTtcbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHRyeSB7XG4gICAgLy8gSUU4IHRocm93cyBcIkludmFsaWQgYXJndW1lbnQuXCIgaWYgcmVzZXR0aW5nIHNob3J0aGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IHRydWU7XG4gIH1cbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uJXMgJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lciksIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciBjaGVja1JlbmRlck1lc3NhZ2UgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgICB2YXIgb3duZXI7XG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICB9XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIG93bmVyKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbihjb21wb25lbnQuX2RlYnVnSUQsICd1cGRhdGUgc3R5bGVzJywgc3R5bGVzKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DaGFuZ2U6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNoYW5nZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UsIHRvcExldmVsVHlwZXMudG9wQ2xpY2ssIHRvcExldmVsVHlwZXMudG9wRm9jdXMsIHRvcExldmVsVHlwZXMudG9wSW5wdXQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VdXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgLy8gSUUxMCsgZmlyZSBpbnB1dCBldmVudHMgdG8gb2Z0ZW4sIHN1Y2ggd2hlbiBhIHBsYWNlaG9sZGVyXG4gIC8vIGNoYW5nZXMgb3Igd2hlbiBhbiBpbnB1dCB3aXRoIGEgcGxhY2Vob2xkZXIgaXMgZm9jdXNlZC5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gMTEpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XG4gIC8vIG9uIERPTSBlbGVtZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgaWYgKGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkZWxldGUgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlZmluaXRpb25cbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XG5cbiAgaWYgKGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcElucHV0KSB7XG4gICAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzIChpLmUuLCBub3QgSUU4IG9yIElFOSksIHRoZSBpbnB1dCBldmVudCBpcyBleGFjdGx5XG4gICAgLy8gd2hhdCB3ZSB3YW50IHNvIGZhbGwgdGhyb3VnaCBoZXJlIGFuZCB0cmlnZ2VyIGFuIGFic3RyYWN0IGV2ZW50XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LTExLCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5VXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24pIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnZhbHVlICE9PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudEluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDbGljaykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMjAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGFuZ2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZSgnZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIERhbmdlciA9IHtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzU2JykgOiB2b2lkIDA7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IF9wcm9kSW52YXJpYW50KCc1NycpIDogdm9pZCAwO1xuICAgICEob2xkQ2hpbGQubm9kZU5hbWUgIT09ICdIVE1MJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSA8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlIGFuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogX3Byb2RJbnZhcmlhbnQoJzU4JykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EYW5nZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEVudGVyTGVhdmVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJiB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbl9hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEhUTUxET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQobmV3IFJlZ0V4cCgnXihkYXRhfGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKSksXG4gIFByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWNjZXB0OiAwLFxuICAgIGFjY2VwdENoYXJzZXQ6IDAsXG4gICAgYWNjZXNzS2V5OiAwLFxuICAgIGFjdGlvbjogMCxcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGFsbG93VHJhbnNwYXJlbmN5OiAwLFxuICAgIGFsdDogMCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiAwLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogMCxcbiAgICBjZWxsU3BhY2luZzogMCxcbiAgICBjaGFyU2V0OiAwLFxuICAgIGNoYWxsZW5nZTogMCxcbiAgICBjaGVja2VkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNpdGU6IDAsXG4gICAgY2xhc3NJRDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29sU3BhbjogMCxcbiAgICBjb250ZW50OiAwLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogMCxcbiAgICBjb250ZXh0TWVudTogMCxcbiAgICBjb250cm9sczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29vcmRzOiAwLFxuICAgIGNyb3NzT3JpZ2luOiAwLFxuICAgIGRhdGE6IDAsIC8vIEZvciBgPG9iamVjdCAvPmAgYWN0cyBhcyBgc3JjYC5cbiAgICBkYXRlVGltZTogMCxcbiAgICAnZGVmYXVsdCc6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRlZmVyOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkaXI6IDAsXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogMCxcbiAgICBlbmNUeXBlOiAwLFxuICAgIGZvcm06IDAsXG4gICAgZm9ybUFjdGlvbjogMCxcbiAgICBmb3JtRW5jVHlwZTogMCxcbiAgICBmb3JtTWV0aG9kOiAwLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiAwLFxuICAgIGZyYW1lQm9yZGVyOiAwLFxuICAgIGhlYWRlcnM6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGhpZGRlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogMCxcbiAgICBocmVmOiAwLFxuICAgIGhyZWZMYW5nOiAwLFxuICAgIGh0bWxGb3I6IDAsXG4gICAgaHR0cEVxdWl2OiAwLFxuICAgIGljb246IDAsXG4gICAgaWQ6IDAsXG4gICAgaW5wdXRNb2RlOiAwLFxuICAgIGludGVncml0eTogMCxcbiAgICBpczogMCxcbiAgICBrZXlQYXJhbXM6IDAsXG4gICAga2V5VHlwZTogMCxcbiAgICBraW5kOiAwLFxuICAgIGxhYmVsOiAwLFxuICAgIGxhbmc6IDAsXG4gICAgbGlzdDogMCxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb3c6IDAsXG4gICAgbWFuaWZlc3Q6IDAsXG4gICAgbWFyZ2luSGVpZ2h0OiAwLFxuICAgIG1hcmdpbldpZHRoOiAwLFxuICAgIG1heDogMCxcbiAgICBtYXhMZW5ndGg6IDAsXG4gICAgbWVkaWE6IDAsXG4gICAgbWVkaWFHcm91cDogMCxcbiAgICBtZXRob2Q6IDAsXG4gICAgbWluOiAwLFxuICAgIG1pbkxlbmd0aDogMCxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogMCxcbiAgICBub25jZTogMCxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcHRpbXVtOiAwLFxuICAgIHBhdHRlcm46IDAsXG4gICAgcGxhY2Vob2xkZXI6IDAsXG4gICAgcG9zdGVyOiAwLFxuICAgIHByZWxvYWQ6IDAsXG4gICAgcHJvZmlsZTogMCxcbiAgICByYWRpb0dyb3VwOiAwLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWZlcnJlclBvbGljeTogMCxcbiAgICByZWw6IDAsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb2xlOiAwLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNhbmRib3g6IDAsXG4gICAgc2NvcGU6IDAsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IDAsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiAwLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiAwLFxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IDAsXG4gICAgc3JjOiAwLFxuICAgIHNyY0RvYzogMCxcbiAgICBzcmNMYW5nOiAwLFxuICAgIHNyY1NldDogMCxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogMCxcbiAgICBzdHlsZTogMCxcbiAgICBzdW1tYXJ5OiAwLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHRhcmdldDogMCxcbiAgICB0aXRsZTogMCxcbiAgICAvLyBTZXR0aW5nIC50eXBlIHRocm93cyBvbiBub24tPGlucHV0PiB0YWdzXG4gICAgdHlwZTogMCxcbiAgICB1c2VNYXA6IDAsXG4gICAgdmFsdWU6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgd21vZGU6IDAsXG4gICAgd3JhcDogMCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiAwLFxuICAgIGRhdGF0eXBlOiAwLFxuICAgIGlubGlzdDogMCxcbiAgICBwcmVmaXg6IDAsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IDAsXG4gICAgcmVzb3VyY2U6IDAsXG4gICAgJ3R5cGVvZic6IDAsXG4gICAgdm9jYWI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IDAsXG4gICAgYXV0b0NvcnJlY3Q6IDAsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IDAsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiAwLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiAwLFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IDAsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiAwLFxuICAgIGl0ZW1SZWY6IDAsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiAwXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RQdXJlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdFB1cmVDb21wb25lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmVkLCAnUmVhY3QuX19zcHJlYWQgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiBVc2UgJyArICdPYmplY3QuYXNzaWduIGRpcmVjdGx5IG9yIGFub3RoZXIgaGVscGVyIGZ1bmN0aW9uIHdpdGggc2ltaWxhciAnICsgJ3NlbWFudGljcy4gWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byB5b3VyIGNvbXBpbGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXNwcmVhZC1kZXByZWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgIHdhcm5lZCA9IHRydWU7XG4gICAgcmV0dXJuIF9hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0UHVyZUNvbXBvbmVudCxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgaXNWYWxpZEVsZW1lbnQ6IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCxcblxuICAvLyBDbGFzc2ljXG5cbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3MsXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnksXG4gIGNyZWF0ZU1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAvLyBDdXJyZW50bHkgYSBub29wLiBXaWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRyYWNlIG1peGlucy5cbiAgICByZXR1cm4gbWl4aW47XG4gIH0sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvLyBEZXByZWNhdGVkIGhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZy5cbiAgX19zcHJlYWQ6IF9fc3ByZWFkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRSZWNvbmNpbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RhbmNlcywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICB9XG4gICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcbiAgICBjaGlsZEluc3RhbmNlc1tuYW1lXSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY2hpbGQsIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXG4gKiBjaGlsZHJlbi4gSXRzIG91dHB1dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpdCBvbnRvIFJlYWN0TXVsdGlDaGlsZCB3aGljaFxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxuICovXG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIH0sIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gICkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIHByZXZDaGlsZDtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbCAmJiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gcHJldkNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICAgIC8vIENyZWF0aW5nIG1vdW50IGltYWdlIG5vdyBlbnN1cmVzIHJlZnMgYXJlIHJlc29sdmVkIGluIHJpZ2h0IG9yZGVyXG4gICAgICAgIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzEwMSBmb3IgZXhwbGFuYXRpb24pLlxuICAgICAgICB2YXIgbmV4dENoaWxkTW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChuZXh0Q2hpbGRJbnN0YW5jZSwgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobmV4dENoaWxkTW91bnRJbWFnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICBpZiAocmVuZGVyZWRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHJlbmRlcmVkQ2hpbGQsIHNhZmVseSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2tcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPT09IGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlzTXV0YXRlZCA9IGZhbHNlO1xuICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbikpIHtcbiAgICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4ubGVuZ3RoID09PSBlbGVtZW50LnByb3BzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudC5fc2hhZG93Q2hpbGRyZW5baV0gIT09IGVsZW1lbnQucHJvcHMuY2hpbGRyZW5baV0pIHtcbiAgICAgICAgICBpc011dGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzTXV0YXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50Ll9zaGFkb3dDaGlsZHJlbikgfHwgaXNNdXRhdGVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdDb21wb25lbnRcXCdzIGNoaWxkcmVuIHNob3VsZCBub3QgYmUgbXV0YXRlZC4lcycsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayA9IHtcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKSk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbk11dGF0aW9uV2FybmluZ0hvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBDb21wb3NpdGVUeXBlcyA9IHtcbiAgSW1wdXJlQ2xhc3M6IDAsXG4gIFB1cmVDbGFzczogMSxcbiAgU3RhdGVsZXNzRnVuY3Rpb25hbDogMlxufTtcblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHZhciBlbGVtZW50ID0gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcbiAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5mdW5jdGlvbiB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlICcgKyAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VDb21wb25lbnREaWRNb3VudFdpdGhUaW1lcigpIHtcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgfVxuICBwdWJsaWNJbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnREaWRNb3VudCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lcihwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpIHtcbiAgdmFyIHB1YmxpY0luc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gIH1cbiAgcHVibGljSW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCk7XG4gIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHRyYW5zYWN0aW9uLmdldFVwZGF0ZVF1ZXVlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgZG9Db25zdHJ1Y3QgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICBpZiAoIWRvQ29uc3RydWN0ICYmIChpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAhKGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5JbXB1cmVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIG1hcmt1cDtcbiAgICBpZiAoaW5zdC51bnN0YWJsZV9oYW5kbGVFcnJvcikge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmcocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGludm9rZUNvbXBvbmVudERpZE1vdW50V2l0aFRpbWVyLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50OiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcjogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdGFuY2VPckVsZW1lbnQ7XG4gICAgaWYgKGRvQ29uc3RydWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdGFuY2VPckVsZW1lbnQgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBjYW4gc3RpbGwgYmUgYW4gaW5zdGFuY2UgaW4gY2FzZSBvZiBmYWN0b3J5IGNvbXBvbmVudHNcbiAgICAgIC8vIGJ1dCB3ZSdsbCBjb3VudCB0aGlzIGFzIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGFzIHRoZSBtb3JlIGNvbW1vbiBjYXNlLlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdGFuY2VPckVsZW1lbnQgPSBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZU9yRWxlbWVudDtcbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmc6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXA7XG4gICAgdmFyIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSb2xsIGJhY2sgdG8gY2hlY2twb2ludCwgaGFuZGxlIGVycm9yICh3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHRoZSB0cmFuc2FjdGlvbiksIGFuZCB0YWtlIGEgbmV3IGNoZWNrcG9pbnRcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICAgICAgdGhpcy5faW5zdGFuY2UudW5zdGFibGVfaGFuZGxlRXJyb3IoZSk7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKHRoaXMuX2luc3RhbmNlLnByb3BzLCB0aGlzLl9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LnVubW91bnRDb21wb25lbnQodHJ1ZSk7XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcblxuICAgICAgLy8gVHJ5IGFnYWluIC0gd2UndmUgaW5mb3JtZWQgdGhlIGNvbXBvbmVudCBhYm91dCB0aGUgZXJyb3IsIHNvIHRoZXkgY2FuIHJlbmRlciBhbiBlcnJvciBtZXNzYWdlIHRoaXMgdGltZS5cbiAgICAgIC8vIElmIHRoaXMgdGhyb3dzIGFnYWluLCB0aGUgZXJyb3Igd2lsbCBidWJibGUgdXAgKGFuZCBjYW4gYmUgY2F1Z2h0IGJ5IGEgaGlnaGVyIGVycm9yIGJvdW5kYXJ5KS5cbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudDogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICApO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZWxmRGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgc2VsZkRlYnVnSUQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZSh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCAmJiAhaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIGluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gdHJ1ZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNhZmVseSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpICsgJy5jb21wb25lbnRXaWxsVW5tb3VudCgpJztcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQoaW5zdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0ICYmIGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgISh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA3JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTA4JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tDb250ZXh0VHlwZXM6IGZ1bmN0aW9uICh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCB0aGlzLmdldE5hbWUoKSwgbnVsbCwgdGhpcy5fZGVidWdJRCk7XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQXR0ZW1wdGVkIHRvIHVwZGF0ZSBjb21wb25lbnQgYCVzYCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkIChvciBmYWlsZWQgdG8gbW91bnQpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEzNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdmFyIHdpbGxSZWNlaXZlID0gZmFsc2U7XG4gICAgdmFyIG5leHRDb250ZXh0O1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlByb3BzID0gcHJldlBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gTm90IGEgc2ltcGxlIHN0YXRlIHVwZGF0ZSBidXQgYSBwcm9wcyB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIGlmIChpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGludm9rZUNvbXBvbmVudERpZFVwZGF0ZVdpdGhUaW1lci5iaW5kKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRIb3N0Tm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBmYWxzZSk7XG5cbiAgICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZWxmRGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMuX2hvc3RQYXJlbnQsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBzZWxmRGVidWdJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRkZW4gaW4gc2hhbGxvdyByZW5kZXJpbmcuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luTGlmZUN5Y2xlVGltZXIodGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRMaWZlQ3ljbGVUaW1lcih0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHJlbmRlcmVkQ29tcG9uZW50ID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IHRoaXMuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwOScsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzICcgKyAnKFNlZSByZWYgXCIlc1wiIGluICVzIGNyZWF0ZWQgYnkgJXMpLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJywgcmVmLCBjb21wb25lbnROYW1lLCB0aGlzLmdldE5hbWUoKSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgIHJlZnNbcmVmXSA9IHB1YmxpY0NvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0YWNoUmVmOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHJlZnMgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucmVmcztcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSBpdFxuICAgKiBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvciBudWxsLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50IC0gaS5lLiB3aGF0XG4gICAqIGlzIGV4cG9zZWQgYnkgcmVmcyBhbmQgcmV0dXJuZWQgYnkgcmVuZGVyLiBDYW4gYmUgbnVsbCBmb3Igc3RhdGVsZXNzXG4gICAqIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSB0aGUgcHVibGljIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfSxcblxuICAvLyBTdHViXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBudWxsXG5cbn07XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiBSZWFjdE1vdW50LnJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnRUcmVlOiB7XG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgLy8gaW5zdCBpcyBhbiBpbnRlcm5hbCBpbnN0YW5jZSAoYnV0IGNvdWxkIGJlIGEgY29tcG9zaXRlKVxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlclxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgaGF2ZSB0aGUgaXNzdWUgd2l0aCBkZXZ0b29scyBsb2FkZWQgb3ZlciBmaWxlOi8vXG4gICAgICAgIHZhciBzaG93RmlsZVVybE1lc3NhZ2UgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgKHNob3dGaWxlVXJsTWVzc2FnZSA/ICdhbmQgdXNlIGFuIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGEgZmlsZTogVVJMKSAnIDogJycpICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdGVzdEZ1bmMgPSBmdW5jdGlvbiB0ZXN0Rm4oKSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZygodGVzdEZ1bmMubmFtZSB8fCB0ZXN0RnVuYy50b1N0cmluZygpKS5pbmRleE9mKCd0ZXN0Rm4nKSAhPT0gLTEsICdJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgJyArICdvZiBSZWFjdC4gV2hlbiBkZXBsb3lpbmcgUmVhY3QgYXBwcyB0byBwcm9kdWN0aW9uLCBtYWtlIHN1cmUgdG8gdXNlICcgKyAndGhlIHByb2R1Y3Rpb24gYnVpbGQgd2hpY2ggc2tpcHMgZGV2ZWxvcG1lbnQgd2FybmluZ3MgYW5kIGlzIGZhc3Rlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1taW5pZmljYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdm9pZCAwO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgU3RyaW5nLnByb3RvdHlwZS50cmltXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25lIG9yIG1vcmUgRVM1IHNoaW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbiAgdmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rJyk7XG4gIHZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaycpO1xuXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzXG4gKiogbW9kdWxlIGlkID0gMjEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8YnV0dG9uPiBob3N0IGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSB7XG4gIGdldEhvc3RQcm9wczogRGlzYWJsZWRJbnB1dFV0aWxzLmdldEhvc3RQcm9wc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUJ1dHRvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01CdXR0b24nKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xudmFyIGRlbGV0ZUxpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXI7XG52YXIgZ2V0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7ICdzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcbn07XG5cbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZSB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBfcHJvZEludmFyaWFudCgnNjInLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5faG9zdENvbnRhaW5lckluZm87XG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpbnN0OiBpbnN0LFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NSW5wdXQucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxudmFyIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHZhciBoYXNFeGlzdGluZ0NvbnRlbnQgPSB0aGlzLl9jb250ZW50RGVidWdJRCAhPSBudWxsO1xuICAgIHZhciBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICAvLyBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGlubGluZWQgY2hpbGQgdGhhdCBoYXMgbm8gYmFja2luZyBpbnN0YW5jZTpcbiAgICB2YXIgY29udGVudERlYnVnSUQgPSAtZGVidWdJRDtcblxuICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgIGlmIChoYXNFeGlzdGluZ0NvbnRlbnQpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudCh0aGlzLl9jb250ZW50RGVidWdJRCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50RGVidWdJRCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBjb250ZW50RGVidWdJRDtcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogX3Byb2RJbnZhcmlhbnQoJzYzJykgOiB2b2lkIDA7XG4gIHZhciBub2RlID0gZ2V0Tm9kZShpbnN0KTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzY0JykgOiB2b2lkIDA7XG5cbiAgc3dpdGNoIChpbnN0Ll90YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFJlc2V0LCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQsICdzdWJtaXQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wSW52YWxpZCwgJ2ludmFsaWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlU2VsZWN0V3JhcHBlcigpIHtcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBfcHJvZEludmFyaWFudCgnNjUnLCB0YWcpIDogdm9pZCAwO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbnZhciBnbG9iYWxJZENvdW50ZXIgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IG51bGw7XG4gICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbnVsbCk7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9SZWFjdERPTUNvbXBvbmVudH0gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBpbmZvIGFib3V0IHRoZSBob3N0IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBnbG9iYWxJZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcblxuICAgIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcbiAgICB2YXIgcGFyZW50VGFnO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RQYXJlbnQuX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RQYXJlbnQuX3RhZztcbiAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RDb250YWluZXJJbmZvLl9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0Q29udGFpbmVySW5mby5fdGFnO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09IG51bGwgfHwgbmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiBwYXJlbnRUYWcgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5odG1sO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzdmcnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuc3ZnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90YWcgPT09ICdtYXRoJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLm1hdGhtbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKHRoaXMuX3RhZywgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRJbmZvLCB0aGlzLl90YWcsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIGVsO1xuICAgICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPCcgKyB0eXBlICsgJz48LycgKyB0eXBlICsgJz4nO1xuICAgICAgICAgIGVsID0gZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5pcykge1xuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUsIHByb3BzLmlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY3Vhc2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICB9XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIGVsKTtcbiAgICAgIHRoaXMuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG4gICAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvclJvb3QoZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhudWxsLCBwcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUoZWwpO1xuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpO1xuICAgICAgbW91bnRJbWFnZSA9IGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcbiAgICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGlucHV0UG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRleHRhcmVhUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShvcHRpb25Qb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRJbWFnZTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gICAgfVxuICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fZG9tSUQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVIVE1MKGxhenlUcmVlLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlVGV4dChsYXp5VHJlZSwgY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91bnRJbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBtb3VudEltYWdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgbmV4dCBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01CdXR0b24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldENvbnRlbnRDaGlsZEZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDb250ZW50Q2hpbGRGb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Tm9kZSh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuIERvZXMgbm90IHJlbW92ZSBmcm9tXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnM7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxuICAgICAgICAgKiBlYXNpbHkgaW4gYSBjcm9zcy1icm93c2VyIHdheSwgaG93ZXZlciBpdCdzIHZhbHVhYmxlIHRvIGJlIGFibGUgdG9cbiAgICAgICAgICogdGFrZSBhZHZhbnRhZ2Ugb2YgUmVhY3QncyByZWNvbmNpbGlhdGlvbiBmb3Igc3R5bGluZyBhbmQgPHRpdGxlPlxuICAgICAgICAgKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXG4gICAgICAgICAqL1xuICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPCVzPiB0cmllZCB0byB1bm1vdW50LiBCZWNhdXNlIG9mIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGl0IGlzIGltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhIHNpbmdsZSB0b3AtbGV2ZWwgY29tcG9uZW50IHRoYXQgbmV2ZXIgdW5tb3VudHMgcmVuZGVyIHRoZXNlIGVsZW1lbnRzLicsIHRoaXMuX3RhZykgOiBfcHJvZEludmFyaWFudCgnNjYnLCB0aGlzLl90YWcpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbihzYWZlbHkpO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgICBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnModGhpcyk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fZG9tSUQgPSAwO1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2V0Q29udGVudENoaWxkRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH1cblxufTtcblxuX2Fzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQ29udGFpbmVySW5mb1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuZnVuY3Rpb24gUmVhY3RET01Db250YWluZXJJbmZvKHRvcExldmVsV3JhcHBlciwgbm9kZSkge1xuICB2YXIgaW5mbyA9IHtcbiAgICBfdG9wTGV2ZWxXcmFwcGVyOiB0b3BMZXZlbFdyYXBwZXIsXG4gICAgX2lkQ291bnRlcjogMSxcbiAgICBfb3duZXJEb2N1bWVudDogbm9kZSA/IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgPyBub2RlIDogbm9kZS5vd25lckRvY3VtZW50IDogbnVsbCxcbiAgICBfbm9kZTogbm9kZSxcbiAgICBfdGFnOiBub2RlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbCxcbiAgICBfbmFtZXNwYWNlVVJJOiBub2RlID8gbm9kZS5uYW1lc3BhY2VVUkkgOiBudWxsXG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5mby5fYW5jZXN0b3JJbmZvID0gbm9kZSA/IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIGluZm8uX3RhZywgbnVsbCkgOiBudWxsO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29udGFpbmVySW5mbztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzXG4gKiogbW9kdWxlIGlkID0gMjE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01FbXB0eUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAvLyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCB1c2VzIHRoaXM6XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fZG9tSUQgPSAwO1xufTtcbl9hc3NpZ24oUmVhY3RET01FbXB0eUNvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIG5vZGVWYWx1ZSA9ICcgcmVhY3QtZW1wdHk6ICcgKyB0aGlzLl9kb21JRCArICcgJztcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG5vZGVWYWx1ZSk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIG5vZGUpO1xuICAgICAgcmV0dXJuIERPTUxhenlUcmVlKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCBpbnNlcnQgYSBjb21tZW50IG5vZGUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uXG4gICAgICAgIC8vIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm5cbiAgICAgICAgLy8gbm90aGluZy5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICc8IS0tJyArIG5vZGVWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUVtcHR5Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUVtcHR5Q29tcG9uZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GYWN0b3JpZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKiBUaGlzIGlzIGFsc28gYWNjZXNzaWJsZSB2aWEgYFJlYWN0LkRPTWAuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSB7XG4gIGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2EnKSxcbiAgYWJicjogY3JlYXRlRE9NRmFjdG9yeSgnYWJicicpLFxuICBhZGRyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdhZGRyZXNzJyksXG4gIGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ2FyZWEnKSxcbiAgYXJ0aWNsZTogY3JlYXRlRE9NRmFjdG9yeSgnYXJ0aWNsZScpLFxuICBhc2lkZTogY3JlYXRlRE9NRmFjdG9yeSgnYXNpZGUnKSxcbiAgYXVkaW86IGNyZWF0ZURPTUZhY3RvcnkoJ2F1ZGlvJyksXG4gIGI6IGNyZWF0ZURPTUZhY3RvcnkoJ2InKSxcbiAgYmFzZTogY3JlYXRlRE9NRmFjdG9yeSgnYmFzZScpLFxuICBiZGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JkaScpLFxuICBiZG86IGNyZWF0ZURPTUZhY3RvcnkoJ2JkbycpLFxuICBiaWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2JpZycpLFxuICBibG9ja3F1b3RlOiBjcmVhdGVET01GYWN0b3J5KCdibG9ja3F1b3RlJyksXG4gIGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JvZHknKSxcbiAgYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2JyJyksXG4gIGJ1dHRvbjogY3JlYXRlRE9NRmFjdG9yeSgnYnV0dG9uJyksXG4gIGNhbnZhczogY3JlYXRlRE9NRmFjdG9yeSgnY2FudmFzJyksXG4gIGNhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2NhcHRpb24nKSxcbiAgY2l0ZTogY3JlYXRlRE9NRmFjdG9yeSgnY2l0ZScpLFxuICBjb2RlOiBjcmVhdGVET01GYWN0b3J5KCdjb2RlJyksXG4gIGNvbDogY3JlYXRlRE9NRmFjdG9yeSgnY29sJyksXG4gIGNvbGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdjb2xncm91cCcpLFxuICBkYXRhOiBjcmVhdGVET01GYWN0b3J5KCdkYXRhJyksXG4gIGRhdGFsaXN0OiBjcmVhdGVET01GYWN0b3J5KCdkYXRhbGlzdCcpLFxuICBkZDogY3JlYXRlRE9NRmFjdG9yeSgnZGQnKSxcbiAgZGVsOiBjcmVhdGVET01GYWN0b3J5KCdkZWwnKSxcbiAgZGV0YWlsczogY3JlYXRlRE9NRmFjdG9yeSgnZGV0YWlscycpLFxuICBkZm46IGNyZWF0ZURPTUZhY3RvcnkoJ2RmbicpLFxuICBkaWFsb2c6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpYWxvZycpLFxuICBkaXY6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpdicpLFxuICBkbDogY3JlYXRlRE9NRmFjdG9yeSgnZGwnKSxcbiAgZHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2R0JyksXG4gIGVtOiBjcmVhdGVET01GYWN0b3J5KCdlbScpLFxuICBlbWJlZDogY3JlYXRlRE9NRmFjdG9yeSgnZW1iZWQnKSxcbiAgZmllbGRzZXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZWxkc2V0JyksXG4gIGZpZ2NhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ2NhcHRpb24nKSxcbiAgZmlndXJlOiBjcmVhdGVET01GYWN0b3J5KCdmaWd1cmUnKSxcbiAgZm9vdGVyOiBjcmVhdGVET01GYWN0b3J5KCdmb290ZXInKSxcbiAgZm9ybTogY3JlYXRlRE9NRmFjdG9yeSgnZm9ybScpLFxuICBoMTogY3JlYXRlRE9NRmFjdG9yeSgnaDEnKSxcbiAgaDI6IGNyZWF0ZURPTUZhY3RvcnkoJ2gyJyksXG4gIGgzOiBjcmVhdGVET01GYWN0b3J5KCdoMycpLFxuICBoNDogY3JlYXRlRE9NRmFjdG9yeSgnaDQnKSxcbiAgaDU6IGNyZWF0ZURPTUZhY3RvcnkoJ2g1JyksXG4gIGg2OiBjcmVhdGVET01GYWN0b3J5KCdoNicpLFxuICBoZWFkOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkJyksXG4gIGhlYWRlcjogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZGVyJyksXG4gIGhncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnaGdyb3VwJyksXG4gIGhyOiBjcmVhdGVET01GYWN0b3J5KCdocicpLFxuICBodG1sOiBjcmVhdGVET01GYWN0b3J5KCdodG1sJyksXG4gIGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2knKSxcbiAgaWZyYW1lOiBjcmVhdGVET01GYWN0b3J5KCdpZnJhbWUnKSxcbiAgaW1nOiBjcmVhdGVET01GYWN0b3J5KCdpbWcnKSxcbiAgaW5wdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucHV0JyksXG4gIGluczogY3JlYXRlRE9NRmFjdG9yeSgnaW5zJyksXG4gIGtiZDogY3JlYXRlRE9NRmFjdG9yeSgna2JkJyksXG4gIGtleWdlbjogY3JlYXRlRE9NRmFjdG9yeSgna2V5Z2VuJyksXG4gIGxhYmVsOiBjcmVhdGVET01GYWN0b3J5KCdsYWJlbCcpLFxuICBsZWdlbmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xlZ2VuZCcpLFxuICBsaTogY3JlYXRlRE9NRmFjdG9yeSgnbGknKSxcbiAgbGluazogY3JlYXRlRE9NRmFjdG9yeSgnbGluaycpLFxuICBtYWluOiBjcmVhdGVET01GYWN0b3J5KCdtYWluJyksXG4gIG1hcDogY3JlYXRlRE9NRmFjdG9yeSgnbWFwJyksXG4gIG1hcms6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcmsnKSxcbiAgbWVudTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudScpLFxuICBtZW51aXRlbTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudWl0ZW0nKSxcbiAgbWV0YTogY3JlYXRlRE9NRmFjdG9yeSgnbWV0YScpLFxuICBtZXRlcjogY3JlYXRlRE9NRmFjdG9yeSgnbWV0ZXInKSxcbiAgbmF2OiBjcmVhdGVET01GYWN0b3J5KCduYXYnKSxcbiAgbm9zY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ25vc2NyaXB0JyksXG4gIG9iamVjdDogY3JlYXRlRE9NRmFjdG9yeSgnb2JqZWN0JyksXG4gIG9sOiBjcmVhdGVET01GYWN0b3J5KCdvbCcpLFxuICBvcHRncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnb3B0Z3JvdXAnKSxcbiAgb3B0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdvcHRpb24nKSxcbiAgb3V0cHV0OiBjcmVhdGVET01GYWN0b3J5KCdvdXRwdXQnKSxcbiAgcDogY3JlYXRlRE9NRmFjdG9yeSgncCcpLFxuICBwYXJhbTogY3JlYXRlRE9NRmFjdG9yeSgncGFyYW0nKSxcbiAgcGljdHVyZTogY3JlYXRlRE9NRmFjdG9yeSgncGljdHVyZScpLFxuICBwcmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3ByZScpLFxuICBwcm9ncmVzczogY3JlYXRlRE9NRmFjdG9yeSgncHJvZ3Jlc3MnKSxcbiAgcTogY3JlYXRlRE9NRmFjdG9yeSgncScpLFxuICBycDogY3JlYXRlRE9NRmFjdG9yeSgncnAnKSxcbiAgcnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3J0JyksXG4gIHJ1Ynk6IGNyZWF0ZURPTUZhY3RvcnkoJ3J1YnknKSxcbiAgczogY3JlYXRlRE9NRmFjdG9yeSgncycpLFxuICBzYW1wOiBjcmVhdGVET01GYWN0b3J5KCdzYW1wJyksXG4gIHNjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnc2NyaXB0JyksXG4gIHNlY3Rpb246IGNyZWF0ZURPTUZhY3RvcnkoJ3NlY3Rpb24nKSxcbiAgc2VsZWN0OiBjcmVhdGVET01GYWN0b3J5KCdzZWxlY3QnKSxcbiAgc21hbGw6IGNyZWF0ZURPTUZhY3RvcnkoJ3NtYWxsJyksXG4gIHNvdXJjZTogY3JlYXRlRE9NRmFjdG9yeSgnc291cmNlJyksXG4gIHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3NwYW4nKSxcbiAgc3Ryb25nOiBjcmVhdGVET01GYWN0b3J5KCdzdHJvbmcnKSxcbiAgc3R5bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0eWxlJyksXG4gIHN1YjogY3JlYXRlRE9NRmFjdG9yeSgnc3ViJyksXG4gIHN1bW1hcnk6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1bW1hcnknKSxcbiAgc3VwOiBjcmVhdGVET01GYWN0b3J5KCdzdXAnKSxcbiAgdGFibGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RhYmxlJyksXG4gIHRib2R5OiBjcmVhdGVET01GYWN0b3J5KCd0Ym9keScpLFxuICB0ZDogY3JlYXRlRE9NRmFjdG9yeSgndGQnKSxcbiAgdGV4dGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHRhcmVhJyksXG4gIHRmb290OiBjcmVhdGVET01GYWN0b3J5KCd0Zm9vdCcpLFxuICB0aDogY3JlYXRlRE9NRmFjdG9yeSgndGgnKSxcbiAgdGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoZWFkJyksXG4gIHRpbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpbWUnKSxcbiAgdGl0bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpdGxlJyksXG4gIHRyOiBjcmVhdGVET01GYWN0b3J5KCd0cicpLFxuICB0cmFjazogY3JlYXRlRE9NRmFjdG9yeSgndHJhY2snKSxcbiAgdTogY3JlYXRlRE9NRmFjdG9yeSgndScpLFxuICB1bDogY3JlYXRlRE9NRmFjdG9yeSgndWwnKSxcbiAgJ3Zhcic6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxuICB2aWRlbzogY3JlYXRlRE9NRmFjdG9yeSgndmlkZW8nKSxcbiAgd2JyOiBjcmVhdGVET01GYWN0b3J5KCd3YnInKSxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiBjcmVhdGVET01GYWN0b3J5KCdjaXJjbGUnKSxcbiAgY2xpcFBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ2NsaXBQYXRoJyksXG4gIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcbiAgZWxsaXBzZTogY3JlYXRlRE9NRmFjdG9yeSgnZWxsaXBzZScpLFxuICBnOiBjcmVhdGVET01GYWN0b3J5KCdnJyksXG4gIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxuICBsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdsaW5lJyksXG4gIGxpbmVhckdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdsaW5lYXJHcmFkaWVudCcpLFxuICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXG4gIHBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdGgnKSxcbiAgcGF0dGVybjogY3JlYXRlRE9NRmFjdG9yeSgncGF0dGVybicpLFxuICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXG4gIHBvbHlsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5bGluZScpLFxuICByYWRpYWxHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgncmFkaWFsR3JhZGllbnQnKSxcbiAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxuICBzdG9wOiBjcmVhdGVET01GYWN0b3J5KCdzdG9wJyksXG4gIHN2ZzogY3JlYXRlRE9NRmFjdG9yeSgnc3ZnJyksXG4gIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcbiAgdHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3RzcGFuJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GZWF0dXJlRmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogdHJ1ZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFncztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlET3BlcmF0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy5cbiAqL1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50SW5zdCwgdXBkYXRlcykge1xuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UocGFyZW50SW5zdCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKG5vZGUsIHVwZGF0ZXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERpc2FibGVkSW5wdXRVdGlscyA9IHJlcXVpcmUoJy4vRGlzYWJsZWRJbnB1dFV0aWxzJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZExpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkIDogcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQocHJvcHMpO1xuXG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgICBzdGVwOiB1bmRlZmluZWQsXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICAgIG1pbjogdW5kZWZpbmVkLFxuICAgICAgbWF4OiB1bmRlZmluZWRcbiAgICB9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuXG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYGlucHV0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZExpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgY2hlY2tlZExpbmtgIHByb3Agb24gYGlucHV0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZExpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAoIWluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCksICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuXG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gICAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcblxuICAgIC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZS4gV2Ugd29uJ3QgZG8gYW55dGhpbmcgaWYgd2UncmUgd29ya2luZyBvblxuICAgIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gICAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gICAgLy8gcmVtb3ZlcyBicm93c2VyLWRlZmF1bHQgdmFsdWVzIChlZyBcIlN1Ym1pdCBRdWVyeVwiKSB3aGVuIG5vIHZhbHVlIGlzXG4gICAgLy8gcHJvdmlkZWQuXG5cbiAgICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgICBjYXNlICdyZXNldCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdkYXRldGltZSc6XG4gICAgICBjYXNlICdkYXRldGltZS1sb2NhbCc6XG4gICAgICBjYXNlICdtb250aCc6XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnO1xuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gICAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gICAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gJyc7XG4gICAgfVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvdGhlck5vZGUpO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTAnKSA6IHZvaWQgMDtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rLmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01PcHRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIFJlYWN0Q2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuKSB7XG4gICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0ge1xuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgaG9zdFBhcmVudCkge1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB3aGV0aGVyIHRoaXMgb3B0aW9uIGlzICdzZWxlY3RlZCdcbiAgICB2YXIgc2VsZWN0VmFsdWUgPSBudWxsO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHZhciBzZWxlY3RQYXJlbnQgPSBob3N0UGFyZW50O1xuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50Ll90YWcgPT09ICdvcHRncm91cCcpIHtcbiAgICAgICAgc2VsZWN0UGFyZW50ID0gc2VsZWN0UGFyZW50Ll9ob3N0UGFyZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0UGFyZW50ICE9IG51bGwgJiYgc2VsZWN0UGFyZW50Ll90YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNlbGVjdFZhbHVlID0gUmVhY3RET01TZWxlY3QuZ2V0U2VsZWN0VmFsdWVDb250ZXh0KHNlbGVjdFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHsgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIGhvc3RQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NT3B0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAob2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbi8qKlxuICogVGV4dCBub2RlcyB2aW9sYXRlIGEgY291cGxlIGFzc3VtcHRpb25zIHRoYXQgUmVhY3QgbWFrZXMgYWJvdXQgY29tcG9uZW50czpcbiAqXG4gKiAgLSBXaGVuIG1vdW50aW5nIHRleHQgaW50byB0aGUgRE9NLCBhZGphY2VudCB0ZXh0IG5vZGVzIGFyZSBtZXJnZWQuXG4gKiAgLSBUZXh0IG5vZGVzIGNhbm5vdCBiZSBhc3NpZ25lZCBhIFJlYWN0IHJvb3QgSUQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byB3cmFwIHN0cmluZ3MgYmV0d2VlbiBjb21tZW50IG5vZGVzIHNvIHRoYXQgdGhleVxuICogY2FuIHVuZGVyZ28gdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIC8vIFRPRE86IFRoaXMgaXMgcmVhbGx5IGEgUmVhY3RUZXh0IChSZWFjdE5vZGUpLCBub3QgYSBSZWFjdEVsZW1lbnRcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xuICB0aGlzLl9zdHJpbmdUZXh0ID0gJycgKyB0ZXh0O1xuICAvLyBSZWFjdERPTUNvbXBvbmVudFRyZWUgdXNlcyB0aGVzZTpcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcblxuICAvLyBQcm9wZXJ0aWVzXG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgdGhpcy5fY29tbWVudE5vZGVzID0gbnVsbDtcbn07XG5cbl9hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLiBUaGlzIG5vZGUgaXMgbm90IGludGVuZGVkIHRvIGhhdmVcbiAgICogYW55IGZlYXR1cmVzIGJlc2lkZXMgY29udGFpbmluZyB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcoJyN0ZXh0JywgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHZhciBvcGVuaW5nVmFsdWUgPSAnIHJlYWN0LXRleHQ6ICcgKyBkb21JRCArICcgJztcbiAgICB2YXIgY2xvc2luZ1ZhbHVlID0gJyAvcmVhY3QtdGV4dCAnO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQob3BlbmluZ1ZhbHVlKTtcbiAgICAgIHZhciBjbG9zaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChjbG9zaW5nVmFsdWUpO1xuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkpO1xuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3BlbmluZ0NvbW1lbnQpKTtcbiAgICAgIGlmICh0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5fc3RyaW5nVGV4dCkpKTtcbiAgICAgIH1cbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKGNsb3NpbmdDb21tZW50KSk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIG9wZW5pbmdDb21tZW50KTtcbiAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gY2xvc2luZ0NvbW1lbnQ7XG4gICAgICByZXR1cm4gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlc2NhcGVkVGV4dCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0aGlzLl9zdHJpbmdUZXh0KTtcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgd3JhcCB0aGlzIGJldHdlZW4gY29tbWVudCBub2RlcyBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkXG4gICAgICAgIC8vIGFib3ZlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXJcbiAgICAgICAgLy8gKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPCEtLScgKyBvcGVuaW5nVmFsdWUgKyAnLS0+JyArIGVzY2FwZWRUZXh0ICsgJzwhLS0nICsgY2xvc2luZ1ZhbHVlICsgJy0tPic7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSBuZXh0VGV4dCBUaGUgbmV4dCB0ZXh0IGNvbnRlbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0VGV4dCwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dFRleHQgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRUZXh0O1xuICAgICAgdmFyIG5leHRTdHJpbmdUZXh0ID0gJycgKyBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0U3RyaW5nVGV4dCAhPT0gdGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBTYXZlIHRoaXMgYXMgcGVuZGluZyBwcm9wcyBhbmQgdXNlIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeVxuICAgICAgICAvLyBhbmQvb3IgdXBkYXRlQ29tcG9uZW50IHRvIGRvIHRoZSBhY3R1YWwgdXBkYXRlIGZvciBjb25zaXN0ZW5jeSB3aXRoXG4gICAgICAgIC8vIG90aGVyIGNvbXBvbmVudCB0eXBlcz9cbiAgICAgICAgdGhpcy5fc3RyaW5nVGV4dCA9IG5leHRTdHJpbmdUZXh0O1xuICAgICAgICB2YXIgY29tbWVudE5vZGVzID0gdGhpcy5nZXRIb3N0Tm9kZSgpO1xuICAgICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucmVwbGFjZURlbGltaXRlZFRleHQoY29tbWVudE5vZGVzWzBdLCBjb21tZW50Tm9kZXNbMV0sIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9zdE5vZGUgPSB0aGlzLl9jb21tZW50Tm9kZXM7XG4gICAgaWYgKGhvc3ROb2RlKSB7XG4gICAgICByZXR1cm4gaG9zdE5vZGU7XG4gICAgfVxuICAgIGlmICghdGhpcy5fY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgICAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICEobm9kZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIGNsb3NpbmcgY29tbWVudCBmb3IgdGV4dCBjb21wb25lbnQgJXMnLCB0aGlzLl9kb21JRCkgOiBfcHJvZEludmFyaWFudCgnNjcnLCB0aGlzLl9kb21JRCkgOiB2b2lkIDA7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIC9yZWFjdC10ZXh0ICcpIHtcbiAgICAgICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGhvc3ROb2RlID0gW3RoaXMuX2hvc3ROb2RlLCB0aGlzLl9jbG9zaW5nQ29tbWVudF07XG4gICAgdGhpcy5fY29tbWVudE5vZGVzID0gaG9zdE5vZGU7XG4gICAgcmV0dXJuIGhvc3ROb2RlO1xuICB9LFxuXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gICAgdGhpcy5fY29tbWVudE5vZGVzID0gbnVsbDtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0Q29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRhcmVhXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBEaXNhYmxlZElucHV0VXRpbHMgPSByZXF1aXJlKCcuL0Rpc2FibGVkSW5wdXRVdGlscycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogX3Byb2RJbnZhcmlhbnQoJzkxJykgOiB2b2lkIDA7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAgIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gICAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK0JlbiBzZWVtZWQgdG8gbGlrZSB0aGlzIHNvbHV0aW9uLlxuICAgIC8vIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBEaXNhYmxlZElucHV0VXRpbHMuZ2V0SG9zdFByb3BzKGluc3QsIHByb3BzKSwge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46ICcnICsgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHRleHRhcmVhYCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzkyJykgOiB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MycpIDogdm9pZCAwO1xuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG5cbiAgICAvLyBXYXJuaW5nOiBub2RlLnZhbHVlIG1heSBiZSB0aGUgZW1wdHkgc3RyaW5nIGF0IHRoaXMgcG9pbnQgKElFMTEpIGlmIHBsYWNlaG9sZGVyIGlzIHNldC5cbiAgICBub2RlLnZhbHVlID0gbm9kZS50ZXh0Q29udGVudDsgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dGFyZWE7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRyZWVUcmF2ZXJzYWxcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG5cbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IHRlbXBBLl9ob3N0UGFyZW50KSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IHRlbXBCLl9ob3N0UGFyZW50KSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBpbnN0QS5faG9zdFBhcmVudDtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGluc3RCLl9ob3N0UGFyZW50O1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCKSB7XG4gICAgICByZXR1cm4gaW5zdEE7XG4gICAgfVxuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RBKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2lzQW5jZXN0b3I6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzUnKSA6IHZvaWQgMDtcblxuICB3aGlsZSAoaW5zdEIpIHtcbiAgICBpZiAoaW5zdEIgPT09IGluc3RBKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3QpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldFBhcmVudEluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM2JykgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGluc3QuX2hvc3RQYXJlbnQ7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sIGZhbHNlLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgdHJ1ZSwgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAoZnJvbSAmJiBmcm9tICE9PSBjb21tb24pIHtcbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBmcm9tLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRvICYmIHRvICE9PSBjb21tb24pIHtcbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSB0by5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sIHRydWUsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAoaSA9IHBhdGhUby5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW2ldLCBmYWxzZSwgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9va1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlLFxuXG4gICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB2YWx1ZUxpbms6IHRydWUsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gICAgY2hlY2tlZExpbms6IHRydWUsXG4gICAgaW5uZXJIVE1MOiB0cnVlLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICBvbkZvY3VzSW46IHRydWUsXG4gICAgb25Gb2N1c091dDogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIGlmIChzdGFuZGFyZE5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBndWVzcyB3aGljaCBwcm9wIHRoZSB1c2VyIGludGVuZGVkLlxuICAgICAgLy8gSXQgaXMgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2FzIGp1c3QgYmxpbmRseSBzcHJlYWRpbmcvZm9yd2FyZGluZyBwcm9wc1xuICAgICAgLy8gQ29tcG9uZW50cyBzaG91bGQgYmUgY2FyZWZ1bCB0byBvbmx5IHJlbmRlciB2YWxpZCBwcm9wcy9hdHRyaWJ1dGVzLlxuICAgICAgLy8gV2FybmluZyB3aWxsIGJlIGludm9rZWQgaW4gd2FyblVua25vd25Qcm9wZXJ0aWVzIHRvIGFsbG93IGdyb3VwaW5nLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcCAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoaXMgcHJvcCBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3BzICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhlc2UgcHJvcHMgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzXG4gKiogbW9kdWxlIGlkID0gMjI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWJ1Z1Rvb2xcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rJyk7XG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0Q2hpbGRyZW5NdXRhdGlvbldhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vaycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaG9va3MgPSBbXTtcbnZhciBkaWRIb29rVGhyb3dGb3JFdmVudCA9IHt9O1xuXG5mdW5jdGlvbiBjYWxsSG9vayhldmVudCwgZm4sIGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgdHJ5IHtcbiAgICBmbi5jYWxsKGNvbnRleHQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdLCAnRXhjZXB0aW9uIHRocm93biBieSBob29rIHdoaWxlIGhhbmRsaW5nICVzOiAlcycsIGV2ZW50LCBlICsgJ1xcbicgKyBlLnN0YWNrKSA6IHZvaWQgMDtcbiAgICBkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFdmVudChldmVudCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhvb2sgPSBob29rc1tpXTtcbiAgICB2YXIgZm4gPSBob29rW2V2ZW50XTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIGNhbGxIb29rKGV2ZW50LCBmbiwgaG9vaywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBpc1Byb2ZpbGluZyA9IGZhbHNlO1xudmFyIGZsdXNoSGlzdG9yeSA9IFtdO1xudmFyIGxpZmVDeWNsZVRpbWVyU3RhY2sgPSBbXTtcbnZhciBjdXJyZW50Rmx1c2hOZXN0aW5nID0gMDtcbnZhciBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBudWxsO1xudmFyIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcblxudmFyIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNsZWFySGlzdG9yeSgpIHtcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcbiAgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suY2xlYXJIaXN0b3J5KCk7XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKSB7XG4gIHJldHVybiByZWdpc3RlcmVkSURzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwgaWQpIHtcbiAgICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gICAgdmFyIHBhcmVudElEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgdHJlZVtpZF0gPSB7XG4gICAgICBkaXNwbGF5TmFtZTogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCksXG4gICAgICB0ZXh0OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFRleHQoaWQpLFxuICAgICAgdXBkYXRlQ291bnQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VXBkYXRlQ291bnQoaWQpLFxuICAgICAgY2hpbGRJRHM6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q2hpbGRJRHMoaWQpLFxuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIG93bmVycyBidXQgdGhpcyBpcyBjbG9zZSBlbm91Z2guXG4gICAgICBvd25lcklEOiBvd25lcklEIHx8IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChwYXJlbnRJRCksXG4gICAgICBwYXJlbnRJRDogcGFyZW50SURcbiAgICB9O1xuICAgIHJldHVybiB0cmVlO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0TWVhc3VyZW1lbnRzKCkge1xuICB2YXIgcHJldmlvdXNTdGFydFRpbWUgPSBjdXJyZW50Rmx1c2hTdGFydFRpbWU7XG4gIHZhciBwcmV2aW91c01lYXN1cmVtZW50cyA9IGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyB8fCBbXTtcbiAgdmFyIHByZXZpb3VzT3BlcmF0aW9ucyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmdldEhpc3RvcnkoKTtcblxuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IG51bGw7XG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gbnVsbDtcbiAgICBjbGVhckhpc3RvcnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJldmlvdXNNZWFzdXJlbWVudHMubGVuZ3RoIHx8IHByZXZpb3VzT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZElEcyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UmVnaXN0ZXJlZElEcygpO1xuICAgIGZsdXNoSGlzdG9yeS5wdXNoKHtcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gcHJldmlvdXNTdGFydFRpbWUsXG4gICAgICBtZWFzdXJlbWVudHM6IHByZXZpb3VzTWVhc3VyZW1lbnRzIHx8IFtdLFxuICAgICAgb3BlcmF0aW9uczogcHJldmlvdXNPcGVyYXRpb25zIHx8IFtdLFxuICAgICAgdHJlZVNuYXBzaG90OiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcylcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFySGlzdG9yeSgpO1xuICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpIHtcbiAgdmFyIGFsbG93Um9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzFdO1xuXG4gIGlmIChhbGxvd1Jvb3QgJiYgZGVidWdJRCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWRlYnVnSUQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RGVidWdUb29sOiBkZWJ1Z0lEIG1heSBub3QgYmUgZW1wdHkuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgJiYgIWxpZmVDeWNsZVRpbWVySGFzV2FybmVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdEaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdGFydCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbmZ1bmN0aW9uIGVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAhPT0gdGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnV2UgZGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RvcCB3aGlsZSAlcyB0aW1lciBpcyBzdGlsbCBpbiAnICsgJ3Byb2dyZXNzIGZvciAlcyBpbnN0YW5jZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnIGluIFJlYWN0LicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XG4gICAgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSB0cnVlO1xuICB9XG4gIGlmIChpc1Byb2ZpbGluZykge1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgIHRpbWVyVHlwZTogdGltZXJUeXBlLFxuICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gY3VycmVudFRpbWVyU3RhcnRUaW1lIC0gY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvblxuICAgIH0pO1xuICB9XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IG51bGw7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSBudWxsO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgY3VycmVudFRpbWVyID0ge1xuICAgIHN0YXJ0VGltZTogY3VycmVudFRpbWVyU3RhcnRUaW1lLFxuICAgIG5lc3RlZEZsdXNoU3RhcnRUaW1lOiBwZXJmb3JtYW5jZU5vdygpLFxuICAgIGRlYnVnSUQ6IGN1cnJlbnRUaW1lckRlYnVnSUQsXG4gICAgdGltZXJUeXBlOiBjdXJyZW50VGltZXJUeXBlXG4gIH07XG4gIGxpZmVDeWNsZVRpbWVyU3RhY2sucHVzaChjdXJyZW50VGltZXIpO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBudWxsO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gbnVsbDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XG4gIHZhciBfbGlmZUN5Y2xlVGltZXJTdGFjayQgPSBsaWZlQ3ljbGVUaW1lclN0YWNrLnBvcCgpO1xuXG4gIHZhciBzdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuc3RhcnRUaW1lO1xuICB2YXIgbmVzdGVkRmx1c2hTdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQubmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIHZhciBkZWJ1Z0lEID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLmRlYnVnSUQ7XG4gIHZhciB0aW1lclR5cGUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQudGltZXJUeXBlO1xuXG4gIHZhciBuZXN0ZWRGbHVzaER1cmF0aW9uID0gcGVyZm9ybWFuY2VOb3coKSAtIG5lc3RlZEZsdXNoU3RhcnRUaW1lO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gKz0gbmVzdGVkRmx1c2hEdXJhdGlvbjtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbnZhciBSZWFjdERlYnVnVG9vbCA9IHtcbiAgYWRkSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rcy5wdXNoKGhvb2spO1xuICB9LFxuICByZW1vdmVIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChob29rc1tpXSA9PT0gaG9vaykge1xuICAgICAgICBob29rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUHJvZmlsaW5nO1xuICB9LFxuICBiZWdpblByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBlbmRQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBnZXRGbHVzaEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmx1c2hIaXN0b3J5O1xuICB9LFxuICBvbkJlZ2luRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkZsdXNoJyk7XG4gIH0sXG4gIG9uRW5kRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcbiAgICByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kRmx1c2gnKTtcbiAgfSxcbiAgb25CZWdpbkxpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uRW5kTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVycm9yOiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGlmIChjdXJyZW50VGltZXJEZWJ1Z0lEICE9IG51bGwpIHtcbiAgICAgIGVuZExpZmVDeWNsZVRpbWVyKGN1cnJlbnRUaW1lckRlYnVnSUQsIGN1cnJlbnRUaW1lclR5cGUpO1xuICAgIH1cbiAgICBlbWl0RXZlbnQoJ29uRXJyb3InLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKGRlYnVnSUQsIHR5cGUsIHBheWxvYWQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBkZWJ1Z0lELCB0eXBlLCBwYXlsb2FkKTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25TZXRTdGF0ZScpO1xuICB9LFxuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoZGVidWdJRCwgY2hpbGREZWJ1Z0lEcykge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGlsZERlYnVnSURzLmZvckVhY2goY2hlY2tEZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uU2V0Q2hpbGRyZW4nLCBkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hlY2tEZWJ1Z0lEKHBhcmVudERlYnVnSUQsIHRydWUpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVNb3VudENvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25VcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25Vbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uVGVzdEV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblRlc3RFdmVudCcpO1xuICB9XG59O1xuXG4vLyBUT0RPIHJlbW92ZSB0aGVzZSB3aGVuIFJOL3d3dyBnZXRzIHVwZGF0ZWRcblJlYWN0RGVidWdUb29sLmFkZERldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5hZGRIb29rO1xuUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2s7XG5cblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayk7XG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0Q29tcG9uZW50VHJlZUhvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENoaWxkcmVuTXV0YXRpb25XYXJuaW5nSG9vayk7XG52YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gIFJlYWN0RGVidWdUb29sLmJlZ2luUHJvZmlsaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVidWdUb29sLmpzXG4gKiogbW9kdWxlIGlkID0gMjI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBSZWFjdFVwZGF0ZXMuZmx1c2hCYXRjaGVkVXBkYXRlcy5iaW5kKFJlYWN0VXBkYXRlcylcbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtGTFVTSF9CQVRDSEVEX1VQREFURVMsIFJFU0VUX0JBVENIRURfVVBEQVRFU107XG5cbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xufVxuXG5fYXNzaWduKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luJyk7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0NoYW5nZUV2ZW50UGx1Z2luJyk7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKCcuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyJyk7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9FbnRlckxlYXZlRXZlbnRQbHVnaW4nKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01FbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RE9NVHJlZVRyYXZlcnNhbCA9IHJlcXVpcmUoJy4vUmVhY3RET01UcmVlVHJhdmVyc2FsJyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi9SZWFjdEV2ZW50TGlzdGVuZXInKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbmplY3Rpb24nKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uJyk7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL1NWR0RPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NlbGVjdEV2ZW50UGx1Z2luJyk7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL1NpbXBsZUV2ZW50UGx1Z2luJyk7XG5cbnZhciBhbHJlYWR5SW5qZWN0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZiAoYWxyZWFkeUluamVjdGVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgdHJ1ZSBiZWNhdXNlIHRoZXNlIGluamVjdGlvbnMgYXJlIHNoYXJlZCBiZXR3ZWVuXG4gICAgLy8gdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlciBwYWNrYWdlLiBUaGV5IHNob3VsZCBiZSBidWlsdCBpbmRlcGVuZGVudGx5XG4gICAgLy8gYW5kIG5vdCBzaGFyZSBhbnkgaW5qZWN0aW9uIHN0YXRlLiBUaGVuIHRoaXMgcHJvYmxlbSB3aWxsIGJlIHNvbHZlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgYWxyZWFkeUluamVjdGVkID0gdHJ1ZTtcblxuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFJlYWN0RXZlbnRMaXN0ZW5lcik7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWUpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdFRyZWVUcmF2ZXJzYWwoUmVhY3RET01UcmVlVHJhdmVyc2FsKTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFJlYWN0RE9NQ29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdFRleHRDb21wb25lbnRDbGFzcyhSZWFjdERPTVRleHRDb21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudEZhY3RvcnkoZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFjdERPTUVtcHR5Q29tcG9uZW50KGluc3RhbnRpYXRlKTtcbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmplY3Q6IGluamVjdFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudEVtaXR0ZXJNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRFbWl0dGVyTWl4aW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdC5faG9zdFBhcmVudCkge1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICB2YXIgY29udGFpbmVyID0gcm9vdE5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5fYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gYW5jZXN0b3IgJiYgZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSB7XG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKGRlYnVnSUQsIHR5cGUsIHBheWxvYWQpIHtcbiAgICBoaXN0b3J5LnB1c2goe1xuICAgICAgaW5zdGFuY2VJRDogZGVidWdJRCxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgfSk7XG4gIH0sXG4gIGNsZWFySGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5fcHJldmVudENsZWFyaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0cy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoaXN0b3J5ID0gW107XG4gIH0sXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBDbGFzczogUmVhY3RDbGFzcy5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5VdGlsczogRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgSG9zdENvbXBvbmVudDogUmVhY3RIb3N0Q29tcG9uZW50LmluamVjdGlvbixcbiAgVXBkYXRlczogUmVhY3RVcGRhdGVzLmluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluamVjdGlvbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSBmYWxzZTtcblxuICB2YXIgd2FybkludmFsaWRTZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0ge1xuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3NpbmdDaGlsZENvbnRleHQgPSB0cnVlO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB3YXJuSW52YWxpZFNldFN0YXRlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vaztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vay5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5cbnZhciBUQUdfRU5EID0gL1xcLz8+LztcbnZhciBDT01NRU5UX1NUQVJUID0gL148XFwhXFwtXFwtLztcblxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XG4gIENIRUNLU1VNX0FUVFJfTkFNRTogJ2RhdGEtcmVhY3QtY2hlY2tzdW0nLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXG4gICAqL1xuICBhZGRDaGVja3N1bVRvTWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuXG4gICAgLy8gQWRkIGNoZWNrc3VtIChoYW5kbGUgYm90aCBwYXJlbnQgdGFncywgY29tbWVudHMgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIGlmIChDT01NRU5UX1NUQVJULnRlc3QobWFya3VwKSkge1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKFRBR19FTkQsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIiQmJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanNcbiAqKiBtb2R1bGUgaWQgPSAyMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZFJlY29uY2lsZXInKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZSgnLi9mbGF0dGVuQ2hpbGRyZW4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VJbnNlcnRNYXJrdXAobWFya3VwLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUoY2hpbGQpLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBjaGlsZC5fbW91bnRJbmRleCxcbiAgICBmcm9tTm9kZTogbm9kZSxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSBtYXJrdXAgb2YgYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlU2V0TWFya3VwKG1hcmt1cCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuU0VUX01BUktVUCxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIFB1c2ggYW4gdXBkYXRlLCBpZiBhbnksIG9udG8gdGhlIHF1ZXVlLiBDcmVhdGVzIGEgbmV3IHF1ZXVlIGlmIG5vbmUgaXNcbiAqIHBhc3NlZCBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHF1ZXVlLiBNdXRhdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIGlmICh1cGRhdGUpIHtcbiAgICBxdWV1ZSA9IHF1ZXVlIHx8IFtdO1xuICAgIHF1ZXVlLnB1c2godXBkYXRlKTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZShpbnN0LCB1cGRhdGVRdWV1ZSkge1xuICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoaW5zdCwgdXBkYXRlUXVldWUpO1xufVxuXG52YXIgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGdldERlYnVnSUQgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghaW5zdC5fZGVidWdJRCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIEFSVC1saWtlIGluc3RhbmNlcy4gVE9ETzogVGhpcyBpcyBzaWxseS9ncm9zcy5cbiAgICAgIHZhciBpbnRlcm5hbDtcbiAgICAgIGlmIChpbnRlcm5hbCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpKSB7XG4gICAgICAgIGluc3QgPSBpbnRlcm5hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3QuX2RlYnVnSUQ7XG4gIH07XG4gIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIGRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgIC8vIFRPRE86IFJlYWN0IE5hdGl2ZSBlbXB0eSBjb21wb25lbnRzIGFyZSBhbHNvIG11bHRpY2hpbGQuXG4gICAgLy8gVGhpcyBtZWFucyB0aGV5IHN0aWxsIGdldCBpbnRvIHRoaXMgbWV0aG9kIGJ1dCBkb24ndCBoYXZlIF9kZWJ1Z0lELlxuICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZHJlbiA/IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5ba2V5XS5fZGVidWdJRDtcbiAgICAgIH0pIDogW10pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VUZXh0Q29udGVudChuZXh0Q29udGVudCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VTZXRNYXJrdXAobmV4dE1hcmt1cCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIEhvb2sgdXNlZCBieSBSZWFjdCBBUlRcbiAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgcmVtb3ZlZE5vZGVzID0ge307XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IG51bGw7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAvLyBgbmV4dE1vdW50SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIG5ld2x5IG1vdW50ZWQgY2hpbGQuXG4gICAgICB2YXIgbmV4dE1vdW50SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RQbGFjZWROb2RlID0gbnVsbDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCBsYXN0SW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAvLyBUaGUgYHJlbW92ZWROb2Rlc2AgbG9vcCBiZWxvdyB3aWxsIGFjdHVhbGx5IHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX21vdW50Q2hpbGRBdEluZGV4KG5leHRDaGlsZCwgbW91bnRJbWFnZXNbbmV4dE1vdW50SW5kZXhdLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgIG5leHRNb3VudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKG5leHRDaGlsZCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdLCByZW1vdmVkTm9kZXNbbmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC4gSXQgZG9lcyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhbnlcbiAgICAgKiBiYWNrZW5kIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpIHtcbiAgICAgIHJldHVybiBtYWtlSW5zZXJ0TWFya3VwKG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzXG4gKiogbW9kdWxlIGlkID0gMjM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTE5JykgOiB2b2lkIDA7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjAnKSA6IHZvaWQgMDtcbiAgICB2YXIgb3duZXJQdWJsaWNJbnN0YW5jZSA9IG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCdzIG93bmVyIGlzIHN0aWxsIGFsaXZlIGFuZCB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZlxuICAgIC8vIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyUHVibGljSW5zdGFuY2UgJiYgb3duZXJQdWJsaWNJbnN0YW5jZS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQdXJlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIFJlYWN0Q29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gUmVhY3RDb21wb25lbnQucHJvdG90eXBlO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlYWN0UHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihSZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5wcm90b3R5cGUpO1xuUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbih1c2VDcmVhdGVFbGVtZW50KSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdERPTVRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSB1c2VDcmVhdGVFbGVtZW50O1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RVcGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2F2ZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlIC0tIGlmIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGlzIG1ldGhvZCBpc1xuICAgKiBwYXNzZWQgdG8gYHJvbGxiYWNrYCwgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhhdCBzdGF0ZS5cbiAgICovXG4gIGNoZWNrcG9pbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZWFjdE1vdW50UmVhZHkgaXMgdGhlIG91ciBvbmx5IHN0YXRlZnVsIHdyYXBwZXJcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHkuY2hlY2twb2ludCgpO1xuICB9LFxuXG4gIHJvbGxiYWNrOiBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbl9hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWZcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdE93bmVyJyk7XG5cbnZhciBSZWFjdFJlZiA9IHt9O1xuXG5mdW5jdGlvbiBhdHRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihudWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5SZWFjdFJlZi5hdHRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcblxuICByZXR1cm4gKFxuICAgIC8vIFRoaXMgaGFzIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyB3L3IvdCBlbXB0eSBjb21wb25lbnRzLlxuICAgIHByZXZFbXB0eSB8fCBuZXh0RW1wdHkgfHwgbmV4dEVsZW1lbnQucmVmICE9PSBwcmV2RWxlbWVudC5yZWYgfHxcbiAgICAvLyBJZiBvd25lciBjaGFuZ2VzIGJ1dCB3ZSBoYXZlIGFuIHVuY2hhbmdlZCBmdW5jdGlvbiByZWYsIGRvbid0IHVwZGF0ZSByZWZzXG4gICAgdHlwZW9mIG5leHRFbGVtZW50LnJlZiA9PT0gJ3N0cmluZycgJiYgbmV4dEVsZW1lbnQuX293bmVyICE9PSBwcmV2RWxlbWVudC5fb3duZXJcbiAgKTtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcbiAgZW5xdWV1ZTogZnVuY3Rpb24gKCkge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBuZXcgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0aGlzKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub29wQ2FsbGJhY2tRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKCkge31cbn07XG5cbl9hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB1cGRhdGUgcXVldWUgdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqIEl0IGRlbGVnYXRlcyB0byBSZWFjdFVwZGF0ZVF1ZXVlIHdoaWxlIHNlcnZlciByZW5kZXJpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kXG4gKiBzd2l0Y2hlcyB0byBSZWFjdE5vb3BVcGRhdGVRdWV1ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAqIEBjbGFzcyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICovXG5cbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAvKiA6OiB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb247ICovXG5cbiAgZnVuY3Rpb24gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0cmFuc2FjdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKTtcblxuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuaXNNb3VudGVkID0gZnVuY3Rpb24gaXNNb3VudGVkKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUNhbGxiYWNrID0gZnVuY3Rpb24gZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlUmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlU2V0U3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzXG4gKiogbW9kdWxlIGlkID0gMjQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU1ZHRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLy8gV2UgdXNlIGF0dHJpYnV0ZXMgZm9yIGV2ZXJ5dGhpbmcgU1ZHIHNvIGxldCdzIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gYW5kIHJ1blxuLy8gY29kZSBpbnN0ZWFkLlxuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBjb25maWcgYWxyZWFkeSBzbyB3ZSBleGNsdWRlIGhlcmUuXG4vLyAtIGNsYXNzIChhcyBjbGFzc05hbWUpXG4vLyAtIGNvbG9yXG4vLyAtIGhlaWdodFxuLy8gLSBpZFxuLy8gLSBsYW5nXG4vLyAtIG1heFxuLy8gLSBtZWRpYVxuLy8gLSBtZXRob2Rcbi8vIC0gbWluXG4vLyAtIG5hbWVcbi8vIC0gc3R5bGVcbi8vIC0gdGFyZ2V0XG4vLyAtIHR5cGVcbi8vIC0gd2lkdGhcbnZhciBBVFRSUyA9IHtcbiAgYWNjZW50SGVpZ2h0OiAnYWNjZW50LWhlaWdodCcsXG4gIGFjY3VtdWxhdGU6IDAsXG4gIGFkZGl0aXZlOiAwLFxuICBhbGlnbm1lbnRCYXNlbGluZTogJ2FsaWdubWVudC1iYXNlbGluZScsXG4gIGFsbG93UmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6IDAsXG4gIGFtcGxpdHVkZTogMCxcbiAgYXJhYmljRm9ybTogJ2FyYWJpYy1mb3JtJyxcbiAgYXNjZW50OiAwLFxuICBhdHRyaWJ1dGVOYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZVR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6IDAsXG4gIGJhc2VGcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZVByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJhc2VsaW5lU2hpZnQ6ICdiYXNlbGluZS1zaGlmdCcsXG4gIGJib3g6IDAsXG4gIGJlZ2luOiAwLFxuICBiaWFzOiAwLFxuICBieTogMCxcbiAgY2FsY01vZGU6ICdjYWxjTW9kZScsXG4gIGNhcEhlaWdodDogJ2NhcC1oZWlnaHQnLFxuICBjbGlwOiAwLFxuICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gIGNsaXBSdWxlOiAnY2xpcC1ydWxlJyxcbiAgY2xpcFBhdGhVbml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjb2xvckludGVycG9sYXRpb246ICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsXG4gIGNvbG9yUHJvZmlsZTogJ2NvbG9yLXByb2ZpbGUnLFxuICBjb2xvclJlbmRlcmluZzogJ2NvbG9yLXJlbmRlcmluZycsXG4gIGNvbnRlbnRTY3JpcHRUeXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50U3R5bGVUeXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogMCxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuICBkOiAwLFxuICBkZWNlbGVyYXRlOiAwLFxuICBkZXNjZW50OiAwLFxuICBkaWZmdXNlQ29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246IDAsXG4gIGRpc3BsYXk6IDAsXG4gIGRpdmlzb3I6IDAsXG4gIGRvbWluYW50QmFzZWxpbmU6ICdkb21pbmFudC1iYXNlbGluZScsXG4gIGR1cjogMCxcbiAgZHg6IDAsXG4gIGR5OiAwLFxuICBlZGdlTW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAwLFxuICBlbmFibGVCYWNrZ3JvdW5kOiAnZW5hYmxlLWJhY2tncm91bmQnLFxuICBlbmQ6IDAsXG4gIGV4cG9uZW50OiAwLFxuICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6IDAsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgZmlsbFJ1bGU6ICdmaWxsLXJ1bGUnLFxuICBmaWx0ZXI6IDAsXG4gIGZpbHRlclJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlclVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZENvbG9yOiAnZmxvb2QtY29sb3InLFxuICBmbG9vZE9wYWNpdHk6ICdmbG9vZC1vcGFjaXR5JyxcbiAgZm9jdXNhYmxlOiAwLFxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gIGZvbnRTaXplQWRqdXN0OiAnZm9udC1zaXplLWFkanVzdCcsXG4gIGZvbnRTdHJldGNoOiAnZm9udC1zdHJldGNoJyxcbiAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXG4gIGZvbnRWYXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgZm9udFdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcbiAgZm9ybWF0OiAwLFxuICBmcm9tOiAwLFxuICBmeDogMCxcbiAgZnk6IDAsXG4gIGcxOiAwLFxuICBnMjogMCxcbiAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXG4gIGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsOiAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsXG4gIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgZ2x5cGhSZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6IDAsXG4gIGhvcml6QWR2WDogJ2hvcml6LWFkdi14JyxcbiAgaG9yaXpPcmlnaW5YOiAnaG9yaXotb3JpZ2luLXgnLFxuICBpZGVvZ3JhcGhpYzogMCxcbiAgaW1hZ2VSZW5kZXJpbmc6ICdpbWFnZS1yZW5kZXJpbmcnLFxuICAnaW4nOiAwLFxuICBpbjI6IDAsXG4gIGludGVyY2VwdDogMCxcbiAgazogMCxcbiAgazE6IDAsXG4gIGsyOiAwLFxuICBrMzogMCxcbiAgazQ6IDAsXG4gIGtlcm5lbE1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbFVuaXRMZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogMCxcbiAga2V5UG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5U3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXlUaW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoQWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyU3BhY2luZzogJ2xldHRlci1zcGFjaW5nJyxcbiAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgbGltaXRpbmdDb25lQW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAwLFxuICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgbWFya2VySGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VyVW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcldpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAwLFxuICBtYXNrQ29udGVudFVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2tVbml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogMCxcbiAgbW9kZTogMCxcbiAgbnVtT2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6IDAsXG4gIG9wYWNpdHk6IDAsXG4gIG9wZXJhdG9yOiAwLFxuICBvcmRlcjogMCxcbiAgb3JpZW50OiAwLFxuICBvcmllbnRhdGlvbjogMCxcbiAgb3JpZ2luOiAwLFxuICBvdmVyZmxvdzogMCxcbiAgb3ZlcmxpbmVQb3NpdGlvbjogJ292ZXJsaW5lLXBvc2l0aW9uJyxcbiAgb3ZlcmxpbmVUaGlja25lc3M6ICdvdmVybGluZS10aGlja25lc3MnLFxuICBwYWludE9yZGVyOiAncGFpbnQtb3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlLTEnLFxuICBwYXRoTGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVyblRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyRXZlbnRzOiAncG9pbnRlci1ldmVudHMnLFxuICBwb2ludHM6IDAsXG4gIHBvaW50c0F0WDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c0F0WTogJ3BvaW50c0F0WScsXG4gIHBvaW50c0F0WjogJ3BvaW50c0F0WicsXG4gIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmVVbml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcjogMCxcbiAgcmFkaXVzOiAwLFxuICByZWZYOiAncmVmWCcsXG4gIHJlZlk6ICdyZWZZJyxcbiAgcmVuZGVyaW5nSW50ZW50OiAncmVuZGVyaW5nLWludGVudCcsXG4gIHJlcGVhdENvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXREdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZEV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZEZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc3RhcnQ6IDAsXG4gIHJlc3VsdDogMCxcbiAgcm90YXRlOiAwLFxuICByeDogMCxcbiAgcnk6IDAsXG4gIHNjYWxlOiAwLFxuICBzZWVkOiAwLFxuICBzaGFwZVJlbmRlcmluZzogJ3NoYXBlLXJlbmRlcmluZycsXG4gIHNsb3BlOiAwLFxuICBzcGFjaW5nOiAwLFxuICBzcGVjdWxhckNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyRXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6IDAsXG4gIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0T2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGREZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogMCxcbiAgc3RlbXY6IDAsXG4gIHN0aXRjaFRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdoUG9zaXRpb246ICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAwLFxuICBzdHJva2U6IDAsXG4gIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICBzdHJva2VEYXNob2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICBzdHJva2VMaW5lam9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZU1pdGVybGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgc3VyZmFjZVNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtTGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxlVmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXRYOiAndGFyZ2V0WCcsXG4gIHRhcmdldFk6ICd0YXJnZXRZJyxcbiAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxuICB0ZXh0UmVuZGVyaW5nOiAndGV4dC1yZW5kZXJpbmcnLFxuICB0ZXh0TGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRvOiAwLFxuICB0cmFuc2Zvcm06IDAsXG4gIHUxOiAwLFxuICB1MjogMCxcbiAgdW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcmxpbmUtcG9zaXRpb24nLFxuICB1bmRlcmxpbmVUaGlja25lc3M6ICd1bmRlcmxpbmUtdGhpY2tuZXNzJyxcbiAgdW5pY29kZTogMCxcbiAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxuICB1bmljb2RlUmFuZ2U6ICd1bmljb2RlLXJhbmdlJyxcbiAgdW5pdHNQZXJFbTogJ3VuaXRzLXBlci1lbScsXG4gIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcbiAgdkhhbmdpbmc6ICd2LWhhbmdpbmcnLFxuICB2SWRlb2dyYXBoaWM6ICd2LWlkZW9ncmFwaGljJyxcbiAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcbiAgdmFsdWVzOiAwLFxuICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcbiAgdmVyc2lvbjogMCxcbiAgdmVydEFkdlk6ICd2ZXJ0LWFkdi15JyxcbiAgdmVydE9yaWdpblg6ICd2ZXJ0LW9yaWdpbi14JyxcbiAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcbiAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICB2aWV3VGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6IDAsXG4gIHdpZHRoczogMCxcbiAgd29yZFNwYWNpbmc6ICd3b3JkLXNwYWNpbmcnLFxuICB3cml0aW5nTW9kZTogJ3dyaXRpbmctbW9kZScsXG4gIHg6IDAsXG4gIHhIZWlnaHQ6ICd4LWhlaWdodCcsXG4gIHgxOiAwLFxuICB4MjogMCxcbiAgeENoYW5uZWxTZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICB4bWxuczogMCxcbiAgeG1sbnNYbGluazogJ3htbG5zOnhsaW5rJyxcbiAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnLFxuICB5OiAwLFxuICB5MTogMCxcbiAgeTI6IDAsXG4gIHlDaGFubmVsU2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogMCxcbiAgem9vbUFuZFBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHt9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7fVxufTtcblxuT2JqZWN0LmtleXMoQVRUUlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW2tleV0gPSAwO1xuICBpZiAoQVRUUlNba2V5XSkge1xuICAgIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW2tleV0gPSBBVFRSU1trZXldO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3RFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWxlY3Q6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlbGVjdENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSwgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xudmFyIE9OX1NFTEVDVF9LRVkgPSBrZXlPZih7IG9uU2VsZWN0OiBudWxsIH0pO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50RWxlbWVudDogcmFuZ2UucGFyZW50RWxlbWVudCgpLFxuICAgICAgdGV4dDogcmFuZ2UudGV4dCxcbiAgICAgIHRvcDogcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICBsZWZ0OiByYW5nZS5ib3VuZGluZ0xlZnRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50ID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX1NFTEVDVF9LRVkpIHtcbiAgICAgIGhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2ltcGxlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNBbmltYXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVHJhbnNpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1doZWVsRXZlbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYWJvcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFib3J0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BYm9ydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGFuaW1hdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQW5pbWF0aW9uRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBhbmltYXRpb25JdGVyYXRpb246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvbkl0ZXJhdGlvbjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQW5pbWF0aW9uSXRlcmF0aW9uQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYW5pbWF0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFuaW1hdGlvblN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BbmltYXRpb25TdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGJsdXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJsdXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJsdXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheVRocm91Z2g6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29weToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29weTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29weUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbnRlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0V4aXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFeGl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRXhpdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnTGVhdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ092ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ1N0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyb3A6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyb3BDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkdXJhdGlvbkNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW1wdGllZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW1wdGllZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW1wdGllZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuY3J5cHRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5jcnlwdGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5kZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuZGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVycm9yOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FcnJvckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGZvY3VzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Gb2N1czogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRm9jdXNDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW5wdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbklucHV0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW52YWxpZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW52YWxpZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW52YWxpZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5UHJlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVByZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWREYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkTWV0YWRhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlRG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU91dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXN0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGFzdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXVzZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGF1c2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhdXNlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXlpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwcm9ncmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUHJvZ3Jlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblByb2dyZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmF0ZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SZXNldDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmVzZXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNjcm9sbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Nyb2xsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2VkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVrZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdGFsbGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdGFsbGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdGFsbGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VibWl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdWJtaXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1Ym1pdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1c3BlbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1c3BlbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1c3BlbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0aW1lVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hDYW5jZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaEVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRyYW5zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRyYW5zaXRpb25FbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQW5pbWF0aW9uRW5kOiBldmVudFR5cGVzLmFuaW1hdGlvbkVuZCxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBldmVudFR5cGVzLmFuaW1hdGlvbkl0ZXJhdGlvbixcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGV2ZW50VHlwZXMuYW5pbWF0aW9uU3RhcnQsXG4gIHRvcEJsdXI6IGV2ZW50VHlwZXMuYmx1cixcbiAgdG9wQ2FuUGxheTogZXZlbnRUeXBlcy5jYW5QbGF5LFxuICB0b3BDYW5QbGF5VGhyb3VnaDogZXZlbnRUeXBlcy5jYW5QbGF5VGhyb3VnaCxcbiAgdG9wQ2xpY2s6IGV2ZW50VHlwZXMuY2xpY2ssXG4gIHRvcENvbnRleHRNZW51OiBldmVudFR5cGVzLmNvbnRleHRNZW51LFxuICB0b3BDb3B5OiBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogZXZlbnRUeXBlcy5jdXQsXG4gIHRvcERvdWJsZUNsaWNrOiBldmVudFR5cGVzLmRvdWJsZUNsaWNrLFxuICB0b3BEcmFnOiBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6IGV2ZW50VHlwZXMuZHJhZ0VuZCxcbiAgdG9wRHJhZ0VudGVyOiBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6IGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogZXZlbnRUeXBlcy5kcmFnTGVhdmUsXG4gIHRvcERyYWdPdmVyOiBldmVudFR5cGVzLmRyYWdPdmVyLFxuICB0b3BEcmFnU3RhcnQ6IGV2ZW50VHlwZXMuZHJhZ1N0YXJ0LFxuICB0b3BEcm9wOiBldmVudFR5cGVzLmRyb3AsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBldmVudFR5cGVzLmR1cmF0aW9uQ2hhbmdlLFxuICB0b3BFbXB0aWVkOiBldmVudFR5cGVzLmVtcHRpZWQsXG4gIHRvcEVuY3J5cHRlZDogZXZlbnRUeXBlcy5lbmNyeXB0ZWQsXG4gIHRvcEVuZGVkOiBldmVudFR5cGVzLmVuZGVkLFxuICB0b3BFcnJvcjogZXZlbnRUeXBlcy5lcnJvcixcbiAgdG9wRm9jdXM6IGV2ZW50VHlwZXMuZm9jdXMsXG4gIHRvcElucHV0OiBldmVudFR5cGVzLmlucHV0LFxuICB0b3BJbnZhbGlkOiBldmVudFR5cGVzLmludmFsaWQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BUcmFuc2l0aW9uRW5kOiBldmVudFR5cGVzLnRyYW5zaXRpb25FbmQsXG4gIHRvcFZvbHVtZUNoYW5nZTogZXZlbnRUeXBlcy52b2x1bWVDaGFuZ2UsXG4gIHRvcFdhaXRpbmc6IGV2ZW50VHlwZXMud2FpdGluZyxcbiAgdG9wV2hlZWw6IGV2ZW50VHlwZXMud2hlZWxcbn07XG5cbmZvciAodmFyIHR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0eXBlXS5kZXBlbmRlbmNpZXMgPSBbdHlwZV07XG59XG5cbnZhciBPTl9DTElDS19LRVkgPSBrZXlPZih7IG9uQ2xpY2s6IG51bGwgfSk7XG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG5mdW5jdGlvbiBnZXREaWN0aW9uYXJ5S2V5KGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW52YWxpZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZERhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkTWV0YWRhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZFN0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhdXNlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheWluZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQcm9ncmVzczpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSYXRlQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJlc2V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVraW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN0YWxsZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1c3BlbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGltZVVwZGF0ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BWb2x1bWVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2FpdGluZzpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDbGljazpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFuaW1hdGlvbkVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBbmltYXRpb25JdGVyYXRpb246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQW5pbWF0aW9uU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVHJhbnNpdGlvbkVuZDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2hlZWw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb3B5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEN1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBfcHJvZEludmFyaWFudCgnODYnLCB0b3BMZXZlbFR5cGUpIDogdm9pZCAwO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2tleV0ucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1trZXldO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ29tcG9zaXRpb25FdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljSW5wdXRFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljSW5wdXRFdmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0tleWJvYXJkRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMjUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvYWRsZXIzMi5qc1xuICoqIG1vZHVsZSBpZCA9IDI1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRhbmdlcm91c1N0eWxlVmFsdWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXI7XG52YXIgc3R5bGVXYXJuaW5ncyA9IHt9O1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fCBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIEFsbG93ICcwJyB0byBwYXNzIHRocm91Z2ggd2l0aG91dCB3YXJuaW5nLiAwIGlzIGFscmVhZHkgc3BlY2lhbCBhbmRcbiAgICAgIC8vIGRvZXNuJ3QgcmVxdWlyZSB1bml0cywgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXJuIGFib3V0IGl0LlxuICAgICAgaWYgKGNvbXBvbmVudCAmJiB2YWx1ZSAhPT0gJzAnKSB7XG4gICAgICAgIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBvd25lci5nZXROYW1lKCkgOiBudWxsO1xuICAgICAgICBpZiAob3duZXJOYW1lICYmICFzdHlsZVdhcm5pbmdzW293bmVyTmFtZV0pIHtcbiAgICAgICAgICBzdHlsZVdhcm5pbmdzW293bmVyTmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICB2YXIgd2FybmluZ3MgPSBzdHlsZVdhcm5pbmdzW293bmVyTmFtZV07XG4gICAgICAgICAgd2FybmVkID0gd2FybmluZ3NbbmFtZV07XG4gICAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2EgYCVzYCB0YWcgKG93bmVyOiBgJXNgKSB3YXMgcGFzc2VkIGEgbnVtZXJpYyBzdHJpbmcgdmFsdWUgJyArICdmb3IgQ1NTIHByb3BlcnR5IGAlc2AgKHZhbHVlOiBgJXNgKSB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgJyArICdhcyBhIHVuaXRsZXNzIG51bWJlciBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0LicsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZSwgb3duZXJOYW1lIHx8ICd1bmtub3duJywgbmFtZSwgdmFsdWUpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZSArICdweCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRET01Ob2RlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG5cbnZhciBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSA9IHJlcXVpcmUoJy4vZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20uZmluZGRvbW5vZGVcbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHZhciBpbnN0ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgcmV0dXJuIGluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSA6IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZERPTU5vZGUgd2FzIGNhbGxlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzQ0JykgOiB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IF9wcm9kSW52YXJpYW50KCc0NScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogdm9pZCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICogQHBhcmFtIHtudW1iZXI9fSBzZWxmRGVidWdJRCBPcHRpb25hbCBkZWJ1Z0lEIG9mIHRoZSBjdXJyZW50IGludGVybmFsIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgaWYgKHRyYXZlcnNlQ29udGV4dCAmJiB0eXBlb2YgdHJhdmVyc2VDb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gICAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuLCBzZWxmRGVidWdJRCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAgICAgcmV0dXJuIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICB9LCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydPJyArIHN0eWxlUHJvcF0gPSAnbycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcblxuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xudmFyIHN0eWxlID0ge307XG5cbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfVxuXG4gIC8vIFNhbWUgYXMgYWJvdmVcbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG9ubHlDaGlsZFxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnMTQzJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3QvbGliL29ubHlDaGlsZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplLmpzXG4gKiogbW9kdWxlIGlkID0gMjY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvY29udGFpbnNOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2VycyBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdFxuICAvLyBpbiBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBvYmouY2FsbGVlICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgY2FuXFwndCBiZSBgYXJndW1lbnRzYC4gVXNlIHJlc3QgcGFyYW1zICcgKyAnKGZ1bmN0aW9uKC4uLmFyZ3MpIHt9KSBvciBBcnJheS5mcm9tKCkgaW5zdGVhZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybSBhIGhldXJpc3RpYyB0ZXN0IHRvIGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgXCJhcnJheS1saWtlXCIuXG4gKlxuICogICBBIG1vbmsgYXNrZWQgSm9zaHUsIGEgWmVuIG1hc3RlciwgXCJIYXMgYSBkb2cgQnVkZGhhIG5hdHVyZT9cIlxuICogICBKb3NodSByZXBsaWVkOiBcIk11LlwiXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGl0cyBhcmd1bWVudCBoYXMgXCJhcnJheSBuYXR1cmVcIjogaXQgcmV0dXJuc1xuICogdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYWN0dWFsIGFycmF5LCBhbiBgYXJndW1lbnRzJyBvYmplY3QsIG9yIGFuXG4gKiBIVE1MQ29sbGVjdGlvbiAoZS5nLiBub2RlLmNoaWxkTm9kZXMgb3Igbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgpKS5cbiAqXG4gKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3Igb3RoZXIgYXJyYXktbGlrZSBvYmplY3RzIGxpa2UgRmlsZWxpc3QuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0FycmF5TmF0dXJlKG9iaikge1xuICByZXR1cm4gKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzXG4gKiogbW9kdWxlIGlkID0gMjcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlYWN0L34vZmJqcy9saWIvaXNOb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzXG4gKiogbW9kdWxlIGlkID0gMjc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWFjdC9+L2ZianMvbGliL3BlcmZvcm1hbmNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVhY3Qvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfVxuXG52YXIgcmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHN0ciwgdGltZXMpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSh0aW1lcyArIDEpLmpvaW4oc3RyKTtcbn07XG52YXIgcGFkID0gZnVuY3Rpb24gcGFkKG51bSwgbWF4TGVuZ3RoKSB7XG4gIHJldHVybiByZXBlYXQoXCIwXCIsIG1heExlbmd0aCAtIG51bS50b1N0cmluZygpLmxlbmd0aCkgKyBudW07XG59O1xudmFyIGZvcm1hdFRpbWUgPSBmdW5jdGlvbiBmb3JtYXRUaW1lKHRpbWUpIHtcbiAgcmV0dXJuIFwiQCBcIiArIHBhZCh0aW1lLmdldEhvdXJzKCksIDIpICsgXCI6XCIgKyBwYWQodGltZS5nZXRNaW51dGVzKCksIDIpICsgXCI6XCIgKyBwYWQodGltZS5nZXRTZWNvbmRzKCksIDIpICsgXCIuXCIgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMyk7XG59O1xuXG4vLyBVc2UgdGhlIG5ldyBwZXJmb3JtYW5jZSBhcGkgdG8gZ2V0IGJldHRlciBwcmVjaXNpb24gaWYgYXZhaWxhYmxlXG52YXIgdGltZXIgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gXCJmdW5jdGlvblwiID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xuXG4vKipcbiAqIHBhcnNlIHRoZSBsZXZlbCBvcHRpb24gb2YgY3JlYXRlTG9nZ2VyXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBmdW5jdGlvbiB8IG9iamVjdH0gbGV2ZWwgLSBjb25zb2xlW2xldmVsXVxuICogQHByb3BlcnR5IHtvYmplY3R9IGFjdGlvblxuICogQHByb3BlcnR5IHthcnJheX0gcGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRMb2dMZXZlbChsZXZlbCwgYWN0aW9uLCBwYXlsb2FkLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZW9mIGxldmVsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobGV2ZWwpKSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiBsZXZlbFt0eXBlXSA9PT0gXCJmdW5jdGlvblwiID8gbGV2ZWxbdHlwZV0uYXBwbHkobGV2ZWwsIF90b0NvbnN1bWFibGVBcnJheShwYXlsb2FkKSkgOiBsZXZlbFt0eXBlXTtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBsZXZlbChhY3Rpb24pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbGV2ZWw7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGxvZ2dlciB3aXRoIGZvbGxvd2VkIG9wdGlvbnNcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge29iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIGxvZ2dlclxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBmdW5jdGlvbiB8IG9iamVjdH0gb3B0aW9ucy5sZXZlbCAtIGNvbnNvbGVbbGV2ZWxdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMuZHVyYXRpb24gLSBwcmludCBkdXJhdGlvbiBvZiBlYWNoIGFjdGlvbj9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy50aW1lc3RhbXAgLSBwcmludCB0aW1lc3RhbXAgd2l0aCBlYWNoIGFjdGlvbj9cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvcHRpb25zLmNvbG9ycyAtIGN1c3RvbSBjb2xvcnNcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBvcHRpb25zLmxvZ2dlciAtIGltcGxlbWVudGF0aW9uIG9mIHRoZSBgY29uc29sZWAgQVBJXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9wdGlvbnMubG9nRXJyb3JzIC0gc2hvdWxkIGVycm9ycyBpbiBhY3Rpb24gZXhlY3V0aW9uIGJlIGNhdWdodCwgbG9nZ2VkLCBhbmQgcmUtdGhyb3duP1xuICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLmNvbGxhcHNlZCAtIGlzIGdyb3VwIGNvbGxhcHNlZD9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy5wcmVkaWNhdGUgLSBjb25kaXRpb24gd2hpY2ggcmVzb2x2ZXMgbG9nZ2VyIGJlaGF2aW9yXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvcHRpb25zLnN0YXRlVHJhbnNmb3JtZXIgLSB0cmFuc2Zvcm0gc3RhdGUgYmVmb3JlIHByaW50XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvcHRpb25zLmFjdGlvblRyYW5zZm9ybWVyIC0gdHJhbnNmb3JtIGFjdGlvbiBiZWZvcmUgcHJpbnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9wdGlvbnMuZXJyb3JUcmFuc2Zvcm1lciAtIHRyYW5zZm9ybSBlcnJvciBiZWZvcmUgcHJpbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVMb2dnZXIoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gIHZhciBfb3B0aW9ucyRsZXZlbCA9IG9wdGlvbnMubGV2ZWw7XG4gIHZhciBsZXZlbCA9IF9vcHRpb25zJGxldmVsID09PSB1bmRlZmluZWQgPyBcImxvZ1wiIDogX29wdGlvbnMkbGV2ZWw7XG4gIHZhciBfb3B0aW9ucyRsb2dnZXIgPSBvcHRpb25zLmxvZ2dlcjtcbiAgdmFyIGxvZ2dlciA9IF9vcHRpb25zJGxvZ2dlciA9PT0gdW5kZWZpbmVkID8gY29uc29sZSA6IF9vcHRpb25zJGxvZ2dlcjtcbiAgdmFyIF9vcHRpb25zJGxvZ0Vycm9ycyA9IG9wdGlvbnMubG9nRXJyb3JzO1xuICB2YXIgbG9nRXJyb3JzID0gX29wdGlvbnMkbG9nRXJyb3JzID09PSB1bmRlZmluZWQgPyB0cnVlIDogX29wdGlvbnMkbG9nRXJyb3JzO1xuICB2YXIgY29sbGFwc2VkID0gb3B0aW9ucy5jb2xsYXBzZWQ7XG4gIHZhciBwcmVkaWNhdGUgPSBvcHRpb25zLnByZWRpY2F0ZTtcbiAgdmFyIF9vcHRpb25zJGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgdmFyIGR1cmF0aW9uID0gX29wdGlvbnMkZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZHVyYXRpb247XG4gIHZhciBfb3B0aW9ucyR0aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcDtcbiAgdmFyIHRpbWVzdGFtcCA9IF9vcHRpb25zJHRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9vcHRpb25zJHRpbWVzdGFtcDtcbiAgdmFyIHRyYW5zZm9ybWVyID0gb3B0aW9ucy50cmFuc2Zvcm1lcjtcbiAgdmFyIF9vcHRpb25zJHN0YXRlVHJhbnNmbyA9IG9wdGlvbnMuc3RhdGVUcmFuc2Zvcm1lcjtcbiAgdmFyIC8vIGRlcHJlY2F0ZWRcbiAgc3RhdGVUcmFuc2Zvcm1lciA9IF9vcHRpb25zJHN0YXRlVHJhbnNmbyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9IDogX29wdGlvbnMkc3RhdGVUcmFuc2ZvO1xuICB2YXIgX29wdGlvbnMkYWN0aW9uVHJhbnNmID0gb3B0aW9ucy5hY3Rpb25UcmFuc2Zvcm1lcjtcbiAgdmFyIGFjdGlvblRyYW5zZm9ybWVyID0gX29wdGlvbnMkYWN0aW9uVHJhbnNmID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoYWN0bikge1xuICAgIHJldHVybiBhY3RuO1xuICB9IDogX29wdGlvbnMkYWN0aW9uVHJhbnNmO1xuICB2YXIgX29wdGlvbnMkZXJyb3JUcmFuc2ZvID0gb3B0aW9ucy5lcnJvclRyYW5zZm9ybWVyO1xuICB2YXIgZXJyb3JUcmFuc2Zvcm1lciA9IF9vcHRpb25zJGVycm9yVHJhbnNmbyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IDogX29wdGlvbnMkZXJyb3JUcmFuc2ZvO1xuICB2YXIgX29wdGlvbnMkY29sb3JzID0gb3B0aW9ucy5jb2xvcnM7XG4gIHZhciBjb2xvcnMgPSBfb3B0aW9ucyRjb2xvcnMgPT09IHVuZGVmaW5lZCA/IHtcbiAgICB0aXRsZTogZnVuY3Rpb24gdGl0bGUoKSB7XG4gICAgICByZXR1cm4gXCIjMDAwMDAwXCI7XG4gICAgfSxcbiAgICBwcmV2U3RhdGU6IGZ1bmN0aW9uIHByZXZTdGF0ZSgpIHtcbiAgICAgIHJldHVybiBcIiM5RTlFOUVcIjtcbiAgICB9LFxuICAgIGFjdGlvbjogZnVuY3Rpb24gYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiIzAzQTlGNFwiO1xuICAgIH0sXG4gICAgbmV4dFN0YXRlOiBmdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG4gICAgICByZXR1cm4gXCIjNENBRjUwXCI7XG4gICAgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICByZXR1cm4gXCIjRjIwNDA0XCI7XG4gICAgfVxuICB9IDogX29wdGlvbnMkY29sb3JzO1xuXG4gIC8vIGV4aXQgaWYgY29uc29sZSB1bmRlZmluZWRcblxuICBpZiAodHlwZW9mIGxvZ2dlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybWVyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIk9wdGlvbiAndHJhbnNmb3JtZXInIGlzIGRlcHJlY2F0ZWQsIHVzZSBzdGF0ZVRyYW5zZm9ybWVyIGluc3RlYWRcIik7XG4gIH1cblxuICB2YXIgbG9nQnVmZmVyID0gW107XG4gIGZ1bmN0aW9uIHByaW50QnVmZmVyKCkge1xuICAgIGxvZ0J1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChsb2dFbnRyeSwga2V5KSB7XG4gICAgICB2YXIgc3RhcnRlZCA9IGxvZ0VudHJ5LnN0YXJ0ZWQ7XG4gICAgICB2YXIgc3RhcnRlZFRpbWUgPSBsb2dFbnRyeS5zdGFydGVkVGltZTtcbiAgICAgIHZhciBhY3Rpb24gPSBsb2dFbnRyeS5hY3Rpb247XG4gICAgICB2YXIgcHJldlN0YXRlID0gbG9nRW50cnkucHJldlN0YXRlO1xuICAgICAgdmFyIGVycm9yID0gbG9nRW50cnkuZXJyb3I7XG4gICAgICB2YXIgdG9vayA9IGxvZ0VudHJ5LnRvb2s7XG4gICAgICB2YXIgbmV4dFN0YXRlID0gbG9nRW50cnkubmV4dFN0YXRlO1xuXG4gICAgICB2YXIgbmV4dEVudHJ5ID0gbG9nQnVmZmVyW2tleSArIDFdO1xuICAgICAgaWYgKG5leHRFbnRyeSkge1xuICAgICAgICBuZXh0U3RhdGUgPSBuZXh0RW50cnkucHJldlN0YXRlO1xuICAgICAgICB0b29rID0gbmV4dEVudHJ5LnN0YXJ0ZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgICAgLy8gbWVzc2FnZVxuICAgICAgdmFyIGZvcm1hdHRlZEFjdGlvbiA9IGFjdGlvblRyYW5zZm9ybWVyKGFjdGlvbik7XG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSB0eXBlb2YgY29sbGFwc2VkID09PSBcImZ1bmN0aW9uXCIgPyBjb2xsYXBzZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgICAgfSwgYWN0aW9uKSA6IGNvbGxhcHNlZDtcblxuICAgICAgdmFyIGZvcm1hdHRlZFRpbWUgPSBmb3JtYXRUaW1lKHN0YXJ0ZWRUaW1lKTtcbiAgICAgIHZhciB0aXRsZUNTUyA9IGNvbG9ycy50aXRsZSA/IFwiY29sb3I6IFwiICsgY29sb3JzLnRpdGxlKGZvcm1hdHRlZEFjdGlvbikgKyBcIjtcIiA6IG51bGw7XG4gICAgICB2YXIgdGl0bGUgPSBcImFjdGlvbiBcIiArICh0aW1lc3RhbXAgPyBmb3JtYXR0ZWRUaW1lIDogXCJcIikgKyBcIiBcIiArIGZvcm1hdHRlZEFjdGlvbi50eXBlICsgXCIgXCIgKyAoZHVyYXRpb24gPyBcIihpbiBcIiArIHRvb2sudG9GaXhlZCgyKSArIFwiIG1zKVwiIDogXCJcIik7XG5cbiAgICAgIC8vIHJlbmRlclxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgaWYgKGNvbG9ycy50aXRsZSkgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiJWMgXCIgKyB0aXRsZSwgdGl0bGVDU1MpO2Vsc2UgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKHRpdGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29sb3JzLnRpdGxlKSBsb2dnZXIuZ3JvdXAoXCIlYyBcIiArIHRpdGxlLCB0aXRsZUNTUyk7ZWxzZSBsb2dnZXIuZ3JvdXAodGl0bGUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5sb2codGl0bGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldlN0YXRlTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbcHJldlN0YXRlXSwgXCJwcmV2U3RhdGVcIik7XG4gICAgICB2YXIgYWN0aW9uTGV2ZWwgPSBnZXRMb2dMZXZlbChsZXZlbCwgZm9ybWF0dGVkQWN0aW9uLCBbZm9ybWF0dGVkQWN0aW9uXSwgXCJhY3Rpb25cIik7XG4gICAgICB2YXIgZXJyb3JMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtlcnJvciwgcHJldlN0YXRlXSwgXCJlcnJvclwiKTtcbiAgICAgIHZhciBuZXh0U3RhdGVMZXZlbCA9IGdldExvZ0xldmVsKGxldmVsLCBmb3JtYXR0ZWRBY3Rpb24sIFtuZXh0U3RhdGVdLCBcIm5leHRTdGF0ZVwiKTtcblxuICAgICAgaWYgKHByZXZTdGF0ZUxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMucHJldlN0YXRlKSBsb2dnZXJbcHJldlN0YXRlTGV2ZWxdKFwiJWMgcHJldiBzdGF0ZVwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5wcmV2U3RhdGUocHJldlN0YXRlKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBwcmV2U3RhdGUpO2Vsc2UgbG9nZ2VyW3ByZXZTdGF0ZUxldmVsXShcInByZXYgc3RhdGVcIiwgcHJldlN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGlvbkxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMuYWN0aW9uKSBsb2dnZXJbYWN0aW9uTGV2ZWxdKFwiJWMgYWN0aW9uXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLmFjdGlvbihmb3JtYXR0ZWRBY3Rpb24pICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIGZvcm1hdHRlZEFjdGlvbik7ZWxzZSBsb2dnZXJbYWN0aW9uTGV2ZWxdKFwiYWN0aW9uXCIsIGZvcm1hdHRlZEFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvciAmJiBlcnJvckxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMuZXJyb3IpIGxvZ2dlcltlcnJvckxldmVsXShcIiVjIGVycm9yXCIsIFwiY29sb3I6IFwiICsgY29sb3JzLmVycm9yKGVycm9yLCBwcmV2U3RhdGUpICsgXCI7IGZvbnQtd2VpZ2h0OiBib2xkXCIsIGVycm9yKTtlbHNlIGxvZ2dlcltlcnJvckxldmVsXShcImVycm9yXCIsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRTdGF0ZUxldmVsKSB7XG4gICAgICAgIGlmIChjb2xvcnMubmV4dFN0YXRlKSBsb2dnZXJbbmV4dFN0YXRlTGV2ZWxdKFwiJWMgbmV4dCBzdGF0ZVwiLCBcImNvbG9yOiBcIiArIGNvbG9ycy5uZXh0U3RhdGUobmV4dFN0YXRlKSArIFwiOyBmb250LXdlaWdodDogYm9sZFwiLCBuZXh0U3RhdGUpO2Vsc2UgbG9nZ2VyW25leHRTdGF0ZUxldmVsXShcIm5leHQgc3RhdGVcIiwgbmV4dFN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCLigJTigJQgbG9nIGVuZCDigJTigJRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbG9nQnVmZmVyLmxlbmd0aCA9IDA7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgLy8gZXhpdCBlYXJseSBpZiBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSA9PT0gXCJmdW5jdGlvblwiICYmICFwcmVkaWNhdGUoZ2V0U3RhdGUsIGFjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ0VudHJ5ID0ge307XG4gICAgICAgIGxvZ0J1ZmZlci5wdXNoKGxvZ0VudHJ5KTtcblxuICAgICAgICBsb2dFbnRyeS5zdGFydGVkID0gdGltZXIubm93KCk7XG4gICAgICAgIGxvZ0VudHJ5LnN0YXJ0ZWRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgbG9nRW50cnkucHJldlN0YXRlID0gc3RhdGVUcmFuc2Zvcm1lcihnZXRTdGF0ZSgpKTtcbiAgICAgICAgbG9nRW50cnkuYWN0aW9uID0gYWN0aW9uO1xuXG4gICAgICAgIHZhciByZXR1cm5lZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobG9nRXJyb3JzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybmVkVmFsdWUgPSBuZXh0KGFjdGlvbik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRW50cnkuZXJyb3IgPSBlcnJvclRyYW5zZm9ybWVyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5lZFZhbHVlID0gbmV4dChhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nRW50cnkudG9vayA9IHRpbWVyLm5vdygpIC0gbG9nRW50cnkuc3RhcnRlZDtcbiAgICAgICAgbG9nRW50cnkubmV4dFN0YXRlID0gc3RhdGVUcmFuc2Zvcm1lcihnZXRTdGF0ZSgpKTtcblxuICAgICAgICBwcmludEJ1ZmZlcigpO1xuXG4gICAgICAgIGlmIChsb2dFbnRyeS5lcnJvcikgdGhyb3cgbG9nRW50cnkuZXJyb3I7XG4gICAgICAgIHJldHVybiByZXR1cm5lZFZhbHVlO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUxvZ2dlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC1sb2dnZXIvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHByb21pc2VNaWRkbGV3YXJlO1xuXG52YXIgX2lzUHJvbWlzZSA9IHJlcXVpcmUoJy4vaXNQcm9taXNlJyk7XG5cbnZhciBfaXNQcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUHJvbWlzZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0VHlwZXMgPSBbJ1BFTkRJTkcnLCAnRlVMRklMTEVEJywgJ1JFSkVDVEVEJ107XG5cbi8qKlxuICogQGZ1bmN0aW9uIHByb21pc2VNaWRkbGV3YXJlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gdGh1bmtcbiAqL1xuZnVuY3Rpb24gcHJvbWlzZU1pZGRsZXdhcmUoKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICB2YXIgcHJvbWlzZVR5cGVTdWZmaXhlcyA9IGNvbmZpZy5wcm9taXNlVHlwZVN1ZmZpeGVzIHx8IGRlZmF1bHRUeXBlcztcblxuICByZXR1cm4gZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcblxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQpIHtcbiAgICAgICAgICBpZiAoISgwLCBfaXNQcm9taXNlMi5kZWZhdWx0KShhY3Rpb24ucGF5bG9hZCkgJiYgISgwLCBfaXNQcm9taXNlMi5kZWZhdWx0KShhY3Rpb24ucGF5bG9hZC5wcm9taXNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY29uc3RydWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvcmlnaW5hbCBhY3Rpb24gb2JqZWN0IHRvIGNvbnN0YW50c1xuICAgICAgICB2YXIgdHlwZSA9IGFjdGlvbi50eXBlO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICB2YXIgbWV0YSA9IGFjdGlvbi5tZXRhO1xuXG4gICAgICAgIC8vIEFzc2lnbiB2YWx1ZXMgZm9yIHByb21pc2UgdHlwZSBzdWZmaXhlc1xuXG4gICAgICAgIHZhciBfcHJvbWlzZVR5cGVTdWZmaXhlcyA9IF9zbGljZWRUb0FycmF5KHByb21pc2VUeXBlU3VmZml4ZXMsIDMpO1xuXG4gICAgICAgIHZhciBQRU5ESU5HID0gX3Byb21pc2VUeXBlU3VmZml4ZXNbMF07XG4gICAgICAgIHZhciBGVUxGSUxMRUQgPSBfcHJvbWlzZVR5cGVTdWZmaXhlc1sxXTtcbiAgICAgICAgdmFyIFJFSkVDVEVEID0gX3Byb21pc2VUeXBlU3VmZml4ZXNbMl07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRBY3Rpb25cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgcmVqZWN0ZWQgb3IgZnVsZmlsbGVkXG4gICAgICAgICAqIGZsdXggc3RhbmRhcmQgYWN0aW9uIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBJcyB0aGUgYWN0aW9uIHJlamVjdGVkP1xuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhY3Rpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGdldEFjdGlvbiA9IGZ1bmN0aW9uIGdldEFjdGlvbihuZXdQYXlsb2FkLCBpc1JlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgKyAnXycgKyAoaXNSZWplY3RlZCA/IFJFSkVDVEVEIDogRlVMRklMTEVEKVxuICAgICAgICAgIH0sIG5ld1BheWxvYWQgPyB7XG4gICAgICAgICAgICBwYXlsb2FkOiBuZXdQYXlsb2FkXG4gICAgICAgICAgfSA6IHt9LCAhIW1ldGEgPyB7IG1ldGE6IG1ldGEgfSA6IHt9LCBpc1JlamVjdGVkID8ge1xuICAgICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgICB9IDoge30pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBc3NpZ24gdmFsdWVzIGZvciBwcm9taXNlIGFuZCBkYXRhIHZhcmlhYmxlcy4gSW4gdGhlIGNhc2UgdGhlIHBheWxvYWRcbiAgICAgICAgICogaXMgYW4gb2JqZWN0IHdpdGggYSBgcHJvbWlzZWAgYW5kIGBkYXRhYCBwcm9wZXJ0eSwgdGhlIHZhbHVlcyBvZiB0aG9zZVxuICAgICAgICAgKiBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZC4gSW4gdGhlIGNhc2UgdGhlIHBheWxvYWQgaXMgYSBwcm9taXNlLCB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgdGhlIHBheWxvYWQgd2lsbCBiZSB1c2VkIGFuZCBkYXRhIHdpbGwgYmUgbnVsbC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgZGF0YSA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoISgwLCBfaXNQcm9taXNlMi5kZWZhdWx0KShhY3Rpb24ucGF5bG9hZCkgJiYgX3R5cGVvZihhY3Rpb24ucGF5bG9hZCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHBheWxvYWQucHJvbWlzZTtcbiAgICAgICAgICBkYXRhID0gcGF5bG9hZC5kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb21pc2UgPSBwYXlsb2FkO1xuICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcnN0LCBkaXNwYXRjaCB0aGUgcGVuZGluZyBhY3Rpb24uIFRoaXMgZmx1eCBzdGFuZGFyZCBhY3Rpb24gb2JqZWN0XG4gICAgICAgICAqIGRlc2NyaWJlcyB0aGUgcGVuZGluZyBzdGF0ZSBvZiBhIHByb21pc2UgYW5kIHdpbGwgaW5jbHVkZSBhbnkgZGF0YVxuICAgICAgICAgKiAoZm9yIG9wdGltaXN0aWMgdXBkYXRlcykgYW5kL29yIG1ldGEgZnJvbSB0aGUgb3JpZ2luYWwgYWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dChfZXh0ZW5kcyh7XG4gICAgICAgICAgdHlwZTogdHlwZSArICdfJyArIFBFTkRJTkdcbiAgICAgICAgfSwgISFkYXRhID8geyBwYXlsb2FkOiBkYXRhIH0gOiB7fSwgISFtZXRhID8geyBtZXRhOiBtZXRhIH0gOiB7fSkpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEBmdW5jdGlvbiBoYW5kbGVSZWplY3RcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIERpc3BhdGNoIHRoZSByZWplY3RlZCBhY3Rpb24gYW5kIHJldHVyblxuICAgICAgICAgKiBhbiBlcnJvciBvYmplY3QuIFRoZSBlcnJvciBvYmplY3QgaXMgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgICAqIHRoYXQgd2FzIHRocm93bi4gVGhlIHVzZXIgb2YgdGhlIGxpYnJhcnkgaXMgcmVzcG9uc2libGUgZm9yXG4gICAgICAgICAqIGJlc3QgcHJhY3RpY2VzIGluIGVuc3VyZSB0aGF0IHRoZXkgYXJlIHRocm93aW5nIGFuIEVycm9yIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtcyByZWFzb24gVGhlIHJlYXNvbiB0aGUgcHJvbWlzZSB3YXMgcmVqZWN0ZWRcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBoYW5kbGVSZWplY3QgPSBmdW5jdGlvbiBoYW5kbGVSZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgdmFyIHJlamVjdGVkQWN0aW9uID0gZ2V0QWN0aW9uKHJlYXNvbiwgdHJ1ZSk7XG4gICAgICAgICAgZGlzcGF0Y2gocmVqZWN0ZWRBY3Rpb24pO1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBAZnVuY3Rpb24gaGFuZGxlRnVsZmlsbFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gRGlzcGF0Y2ggdGhlIGZ1bGZpbGxlZCBhY3Rpb24gYW5kXG4gICAgICAgICAqIHJldHVybiB0aGUgc3VjY2VzcyBvYmplY3QuIFRoZSBzdWNjZXNzIG9iamVjdCBzaG91bGRcbiAgICAgICAgICogY29udGFpbiB0aGUgdmFsdWUgYW5kIHRoZSBkaXNwYXRjaGVkIGFjdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0aGUgcHJvbWlzZSB3YXMgcmVzbG92ZWQgd2l0aFxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGhhbmRsZUZ1bGZpbGwgPSBmdW5jdGlvbiBoYW5kbGVGdWxmaWxsKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgICB2YXIgcmVzb2x2ZWRBY3Rpb24gPSBnZXRBY3Rpb24odmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICBkaXNwYXRjaChyZXNvbHZlZEFjdGlvbik7XG5cbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGFjdGlvbjogcmVzb2x2ZWRBY3Rpb24gfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2Vjb25kLCBkaXNwYXRjaCBhIHJlamVjdGVkIG9yIGZ1bGZpbGxlZCBhY3Rpb24uIFRoaXMgZmx1eCBzdGFuZGFyZFxuICAgICAgICAgKiBhY3Rpb24gb2JqZWN0IHdpbGwgZGVzY3JpYmUgdGhlIHJlc29sdmVkIHN0YXRlIG9mIHRoZSBwcm9taXNlLiBJblxuICAgICAgICAgKiB0aGUgY2FzZSBvZiBhIHJlamVjdGVkIHByb21pc2UsIGl0IHdpbGwgaW5jbHVkZSBhbiBgZXJyb3JgIHByb3BlcnR5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBvcmRlciB0byBhbGxvdyBwcm9wZXIgY2hhaW5pbmcgb2YgYWN0aW9ucyB1c2luZyBgdGhlbmAsIGEgbmV3XG4gICAgICAgICAqIHByb21pc2UgaXMgY29uc3RydWN0ZWQgYW5kIHJldHVybmVkLiBUaGlzIHByb21pc2Ugd2lsbCByZXNvbHZlXG4gICAgICAgICAqIHdpdGggdHdvIHByb3BlcnRpZXM6ICgxKSB0aGUgdmFsdWUgKGlmIGZ1bGZpbGxlZCkgb3IgcmVhc29uXG4gICAgICAgICAqIChpZiByZWplY3RlZCkgYW5kICgyKSB0aGUgZmx1eCBzdGFuZGFyZCBhY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFJlamVjdGVkIG9iamVjdDpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgIHJlYXNvbjogLi4uXG4gICAgICAgICAqICAgYWN0aW9uOiB7XG4gICAgICAgICAqICAgICBlcnJvcjogdHJ1ZSxcbiAgICAgICAgICogICAgIHR5cGU6ICdBQ1RJT05fUkVKRUNURUQnLFxuICAgICAgICAgKiAgICAgcGF5bG9hZDogLi4uXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEZ1bGZpbGxlZCBvYmplY3Q6XG4gICAgICAgICAqIHtcbiAgICAgICAgICogICB2YWx1ZTogLi4uXG4gICAgICAgICAqICAgYWN0aW9uOiB7XG4gICAgICAgICAqICAgICB0eXBlOiAnQUNUSU9OX0ZVTEZJTExFRCcsXG4gICAgICAgICAqICAgICBwYXlsb2FkOiAuLi5cbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oaGFuZGxlRnVsZmlsbCwgaGFuZGxlUmVqZWN0KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUvZGlzdC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC1wcm9taXNlLW1pZGRsZXdhcmUvZGlzdC9pc1Byb21pc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGNyZWF0ZVRodW5rTWlkZGxld2FyZShleHRyYUFyZ3VtZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBkaXNwYXRjaCA9IF9yZWYuZGlzcGF0Y2g7XG4gICAgdmFyIGdldFN0YXRlID0gX3JlZi5nZXRTdGF0ZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGlvbihkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhQXJndW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIHRodW5rID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKCk7XG50aHVuay53aXRoRXh0cmFBcmd1bWVudCA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gdGh1bms7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgtdGh1bmsvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gYXBwbHlNaWRkbGV3YXJlO1xuXG52YXIgX2NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKTtcblxudmFyIF9jb21wb3NlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbXBvc2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZShyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IF9jb21wb3NlMltcImRlZmF1bHRcIl0uYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmVkdXgvbGliL2FwcGx5TWlkZGxld2FyZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBiaW5kQWN0aW9uQ3JlYXRvcnM7XG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uIGNyZWF0b3JzLCBpbnRvIGFuIG9iamVjdCB3aXRoIHRoZVxuICogc2FtZSBrZXlzLCBidXQgd2l0aCBldmVyeSBmdW5jdGlvbiB3cmFwcGVkIGludG8gYSBgZGlzcGF0Y2hgIGNhbGwgc28gdGhleVxuICogbWF5IGJlIGludm9rZWQgZGlyZWN0bHkuIFRoaXMgaXMganVzdCBhIGNvbnZlbmllbmNlIG1ldGhvZCwgYXMgeW91IGNhbiBjYWxsXG4gKiBgc3RvcmUuZGlzcGF0Y2goTXlBY3Rpb25DcmVhdG9ycy5kb1NvbWV0aGluZygpKWAgeW91cnNlbGYganVzdCBmaW5lLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBzaW5nbGUgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYW5kIGdldCBhIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvcnMgIT09ICdvYmplY3QnIHx8IGFjdGlvbkNyZWF0b3JzID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgJyArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyAnLiAnICsgJ0RpZCB5b3Ugd3JpdGUgXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiIGluc3RlYWQgb2YgXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXCI/Jyk7XG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFjdGlvbkNyZWF0b3JzKTtcbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgdmFyIGFjdGlvbkNyZWF0b3IgPSBhY3Rpb25DcmVhdG9yc1trZXldO1xuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvYmluZEFjdGlvbkNyZWF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMjg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbWJpbmVSZWR1Y2VycztcblxudmFyIF9jcmVhdGVTdG9yZSA9IHJlcXVpcmUoJy4vY3JlYXRlU3RvcmUnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzUGxhaW5PYmplY3QnKTtcblxudmFyIF9pc1BsYWluT2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUGxhaW5PYmplY3QpO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCcuL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uKSB7XG4gIHZhciByZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgdmFyIGFyZ3VtZW50TmFtZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gX2NyZWF0ZVN0b3JlLkFjdGlvblR5cGVzLklOSVQgPyAnaW5pdGlhbFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCEoMCwgX2lzUGxhaW5PYmplY3QyW1wiZGVmYXVsdFwiXSkoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gJ1RoZSAnICsgYXJndW1lbnROYW1lICsgJyBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFwiJyArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgJ1wiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nICcgKyAoJ2tleXM6IFwiJyArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgfSk7XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gJ1VuZXhwZWN0ZWQgJyArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgJyAnICsgKCdcIicgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArICdcIiBmb3VuZCBpbiAnICsgYXJndW1lbnROYW1lICsgJy4gJykgKyAnRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiAnICsgKCdcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2FuaXR5KHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7IHR5cGU6IF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIF9jcmVhdGVTdG9yZS5BY3Rpb25UeXBlcy5JTklUICsgJyBvciBvdGhlciBhY3Rpb25zIGluIFwicmVkdXgvKlwiICcpICsgJ25hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlICcgKyAnY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgJyArICdpbiB3aGljaCBjYXNlIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZSwgcmVnYXJkbGVzcyBvZiB0aGUgJyArICdhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBkaWZmZXJlbnQgcmVkdWNlciBmdW5jdGlvbnMsIGludG8gYSBzaW5nbGVcbiAqIHJlZHVjZXIgZnVuY3Rpb24uIEl0IHdpbGwgY2FsbCBldmVyeSBjaGlsZCByZWR1Y2VyLCBhbmQgZ2F0aGVyIHRoZWlyIHJlc3VsdHNcbiAqIGludG8gYSBzaW5nbGUgc3RhdGUgb2JqZWN0LCB3aG9zZSBrZXlzIGNvcnJlc3BvbmQgdG8gdGhlIGtleXMgb2YgdGhlIHBhc3NlZFxuICogcmVkdWNlciBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlZHVjZXJzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgY29ycmVzcG9uZCB0byBkaWZmZXJlbnRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBjb21iaW5lZCBpbnRvIG9uZS4gT25lIGhhbmR5IHdheSB0byBvYnRhaW5cbiAqIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzIHJlZHVjZXJzYCBzeW50YXguIFRoZSByZWR1Y2VycyBtYXkgbmV2ZXIgcmV0dXJuXG4gKiB1bmRlZmluZWQgZm9yIGFueSBhY3Rpb24uIEluc3RlYWQsIHRoZXkgc2hvdWxkIHJldHVybiB0aGVpciBpbml0aWFsIHN0YXRlXG4gKiBpZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZW0gd2FzIHVuZGVmaW5lZCwgYW5kIHRoZSBjdXJyZW50IHN0YXRlIGZvciBhbnlcbiAqIHVucmVjb2duaXplZCBhY3Rpb24uXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHJlZHVjZXIgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGV2ZXJ5IHJlZHVjZXIgaW5zaWRlIHRoZVxuICogcGFzc2VkIG9iamVjdCwgYW5kIGJ1aWxkcyBhIHN0YXRlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlLlxuICovXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZHVjZXJLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHJlZHVjZXJLZXlzW2ldO1xuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTtcblxuICB2YXIgc2FuaXR5RXJyb3I7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UmVkdWNlclNhbml0eShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNhbml0eUVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKHNhbml0eUVycm9yKSB7XG4gICAgICB0aHJvdyBzYW5pdHlFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGZpbmFsUmVkdWNlcktleXNbaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNba2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVba2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGVba2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBuZXh0U3RhdGUgOiBzdGF0ZTtcbiAgfTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9saWIvY29tYmluZVJlZHVjZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMjg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgd2luZG93ICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wb255ZmlsbCcpKGdsb2JhbCB8fCB3aW5kb3cgfHwgdGhpcyk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWR1eC9+L3N5bWJvbC1vYnNlcnZhYmxlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMjkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L34vc3ltYm9sLW9ic2VydmFibGUvcG9ueWZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVCTEFFc0FBRC8vZ0JrUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEE2THk5amIyMXRiMjV6TG5kcGEybHRaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPa1ZwYm5OMFpXbHVYekU1TWpGZllubGZSbDlUWTJodGRYUjZaWEpmTFY5eVpYTjBiM0poZEdsdmJpNXFjR2YvMndCREFBWUVCUVlGQkFZR0JRWUhCd1lJQ2hBS0Nna0pDaFFPRHd3UUZ4UVlHQmNVRmhZYUhTVWZHaHNqSEJZV0lDd2dJeVluS1NvcEdSOHRNQzBvTUNVb0tTai8yd0JEQVFjSEJ3b0lDaE1LQ2hNb0doWWFLQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0NqL3dBQVJDQUVoQU53REFTSUFBaEVCQXhFQi84UUFIQUFBQVFVQkFRRUFBQUFBQUFBQUFBQUFCUUlEQkFZSEFBRUkvOFFBUmhBQUFnRURBd0VIQVFRR0NBUUZCUUVBQVFJREFBUVJCUkloTVFZVElrRlJZWEdCQnpLUm9SUWpNN0hCMFJVV0pFSlNjckxoTkdKemdrTlRrcUx3Q0dOa2c3UEMvOFFBR0FFQUF3RUJBQUFBQUFBQUFBQUFBQUFBQUFFQ0F3VC94QUFqRVFFQkFBSUNBd0VBQWdNQkFBQUFBQUFBQVFJUkF5RVNNVUVUSW1FRU1sR1IvOW9BREFNQkFBSVJBeEVBUHdERkpJZDJvWGg5WjMvZlQ4cU1rSjJIRk9LTTNsMGYvdlAvQUtqWFhjYnNpN09RRHpXR1Y3UEgwRVNGbkpaaVN3OWFUQ2YxcUU5TWlwTjRnaWJQVGNNWXFLT01jOURSQXMwWXlvK0tYdDlxVGJETWFtcEtyeHpXU3pJU2ttSUVjajYxSkVkTFdPZ2FNMmNUaVhBNUdEVTBRa3dqNXpTWUF5c1N2SEZQdUc3c1lQVTUrYVZwcUpxNUoxQ2JPT3RRdWFtYXQveDgzelVNRG10b3pyaWE4T2M4R3ZXSEpwSnBrNCsxZVYxZVVCNmE0SGtWNVhVak9SakpJcndHdVFIeS9LdldYYmpkbW1UelBQRmVnbjFxVkFJd1JnY244cWJuR1pUZ1lCNlViTWhkemNDcDBrZmQydzkvV284STd1UVp3YzBYampXYUU1UGxTdEVnZGFUOXkvUFEwVmdjVEp1R2FFTEgrdVpPaEJ4UlMwaDdvRWhzNThxS2NQaDh5Z1orbE9ZSHFmeHFQSU15cmpnMUpLZE90SWtWUCtLdXYrcy8rbzFOUmNnK2xRNGovYUxqL3JQL0FLalJ2UlkwbTFLeWlrQUtTVG9yRDFCWVpwWjA4VlgxVmcwbkdjRHp4US9IR2VLMUg3VkV4MjJ1NDdPMEMyY1NJZ1dJQURPUFNxSGMyMXlPdHN5aCtSbGVhV09XNGVVMVJld0diZFBpcGdTcTNGY2FqQ28yQnNkQUN2Tk94MzJwS2VjRURrN2twZUkyc1FUNlVwVXgxb0Ftc1h5Y3RDcFh6R3cwaHRldTBjQVFKN2dxYVhqVDNGbFZRRFMzeVVVZVdUVllYdEpPUHZReGZuU3Y2enNRQWJaRGpwaHFQQ2p5Z0xxbk4vUDdOaW9vRlNycVdLZVY1U0pGWmprZ0VFVjZJSUNDUVp4akhCVWVkYXhDR2Mwa2lwejIwSVFzMHNvVUhCOEhJL09tMnQ0dCtGbmJIcnMvM28yRVExNTYxT2pzMWtiQXVGSHFTcDRyMytqWk51VmtSczg5Q0tOalNBQlhvRlRWMDZRNXpKR0JUZ3NtTVpIZlJBRGc1eUtOalNLQUJnb2FmZUhjZ09lUlM0clF4TU16UXliczRDc1RTRWlMU2hqTkh0SE9DLzVVR1hhNFVFT3RLYVpkeFZnUFkxSWpDeUFCREdXUEFHOENvOTdBd1psd0JJbkRBSE5JRzdSRDN1V0dRZWhvdkJibllXQndLR2FkSXVDSkQ1OFpvcDNwSTJweUtWT0lVb1ZiancvZk5UWWhrRGRVQzRpSW5EZE1taWFJb1hMSG4wcGthbUs5NG0wODVxWUNNREpvUko0Ym8vTlN2RTNLazRwNko1QzJibTVIbDMwbitvMGYwSnpGcWRuSW9CS1RJd0I2Y0dxN0JuOUp1ZjhBclNmNmpWZzBNYjlRdGg1RngxcWVUNmVDNTlvdXpQOEFTR3AzR29UM2VaTGh0d0NnZ0RpcTlKMlVsVTVNN1NEb0FjMXBjY0phM0lZRGFENGFhbGlWc0JjQWl1U2NsblRvdUVyUG91eXNvS1p5dTdrSEo1cFYxMmR1SVZJL1NBMmZKWmVsVzI2VEYyaExOaFJqclFTNVFOSkozZWNaSkJxcG5hVnhrVlc1MFM1TW1YbE9NOGdQbWtOcGwyeFpXNUFIVVBqK0ZXWlUzQStJZ255cHlLMmFXVGFEMUI2MVhuVStLbFQ5bjdsMUpBejZaSy95cGgrelUzVXFEZ1l3cDVxK3RheWQyZUNWREhuMHA2MjB1OHZiOHgyTURTc3YzdG80VWVwUFFDbitsTHdaci9WMlZReGtSOEJzWjNEcFNwOUN1VmcvVU8wcnR5ZWh4anBXb3ZvZHRheXN1cmF0YnhZUE1Wc0RNMmZUMHJwSU96Y0IzQzAxQzdPM0Iza1JnL2hSK28vTm1FdWd5M0JqN3VPY0ZseEp2WUhMZW85cTkvb1M4aGkydzJrbTRIeE1TQ1QvQUxWcDlyZTZWR0NrR2dSRkFNWWtuWTBXdGJDMHVYa1Z0SWh0Y0RKWVROd1BYMnBYbXMrSE9PVmlkdG9Hb3RKdE1MZ055U1JnRDhhT1FkbTB0ZzRsWXN6RGxnZU1IR09LMHlmVGtnM0JWQzdtMmpjM21DQ1A0MVh0VXU0YlNCQVZVeXZuQ0lmVmo1Ky90Uit0eTlEd2tVcVRUWWJkMlZSdGNqcjFvWGMyY0tPVE9oSVBSbzN3RFIyOXVqSnU3M0N5Y0ZzZUVBRStYSE5RZFVzNUVHOHMyN1pnZ3Ixd09sYVMzNml3TGlTM3M1ZThpTXlNUWNkNWc4WTU0cUhiUlc1QmtFa3A1d1BDS0pkbnRWN2k1RnRJc1R3U1l4dUdkcCt0WGlLMnRwQkdUQmJzR0grQWV2V25sbDRpVGJOWk5QZG1EUnJKdFBuSUFLYlFOQTA0emdxY0gzclcyMDZ4VkNaTE9JcU9BUlZHN2VXa1ZuZXhyQkVzYU9tY0w1KzlHUEo1WFF1R3UxZXNaQWtwM0RJTkdySmtIaWJwNUNnMWd1U1RqcFJZT3NhQUVEUFNxcFEzZWd5U29GSEc3cUtsT28ycms5S1lMNUliQUFweG03d0hibjVvQ0pLQzl6Z2ZGVFVUQ2dVT1VFVFl6eURVNGx6NWtld3FrbXJjL3dCb3VQOEFyUDhBNmpWbDdOak9xMm94bnhpcTNhRE04K1AvQURuL0FOUnExZGswM2F6YTQ1d1Nmd0JxT1Q2ZURVNTI3dFVDa0FlZUtZaEttNnpoZ01kS2xZN3kyVGN1N0k0Tk54SWdsWTQ4dlN1RjFodCtzYksrME1DT2xETzQyUnN3SnlCNVZaSHRVNU8zSkk4alVPZTBYdVhZWlhhdlF0MTVweWxZQlF3cm5KVnNuclQwc1BnNFE3dWVRS25SeHhyanhPUFhJbzVwVmhiM1RTVDNULzJDMlR2SnlPQ3d6d2c5MlBGVmNpMEMyTm5ERllSM3VyTTBkbzVKaWhqR0hud2VjZWkrOWRlYXJMZnM4UzdiV3pCQ3Jid0RDZ1o4ejFKK2FrNmpKTHFGeEJMUGhXemhFSFJFQjRVZXdxTUlRSGxZcXVDdy9lYVcvd0RwaHBzNGhLNmdrQlc5T3RSWllNQWt1d3h4UnFhTVA0dTdYTGM1RlFiNklGUERHQU9laHFwVTJHTkpzV3VTeUpJU1diWmsrV1FlYTFUczUyZk9xeVdObzhzaGhqYnY3bDl2REJSdFJTZWg1eWZPcXY4QVo1cERYTHl6U3dyK2pJNnM3TWNaQTZEUHorNnR1N04yd2hzMmxJSGVUc1dJSDNRUElEMitLY25sbG9XK09JZWV4K2xOSVpicTJXNWZiamRJT25xYXFldi9BR2U2TEx2bUVUUnNBY2dOZ0gzOXZwV255RGc5TTRxdWRvOTYyVW1PT01ualAwcXM4WmpPaXh5dHZiQnRjN1BhUllSU2lHSWhoeURucWFwOHNTdERkUlRicEZYeHJ6bmFEajY4R3JUMnpuMk03SzJSNSt4cWx3M2tZblJKWmU3MzVRdUJuZzlSKytsaHV6WXoxdFV0YjArU3luNzZOZ0FHenZHT2M5RGlydjJYbC9TdEp0NWRnSlh3bjJPZWxRTlh0OVB2VU1aZG1PQnRiWU1xZU9UejgrdFNleDROcFp2QVN1QS9IaHlmalBTdE1ydkZFbXFQc1JKbFZBR0g2RStWVVQ3UlpBMnFRTHR3Vml3UHhxNnh6Z1RCOGNGdjhQdlZPKzBhQ1NiVzBlTUl5ckN2M1Q1bm1seC83SG42QnRHZ0RRdElXOEpiQkFvdERZd3k1TFNlRURPZmVobW16UFphY1QzWTNPL0I5S21Nelc4WnhJV0V2UE5hMW5FSzVVbGxXTnVNMUxnVXBFUWZUclVLUEJ1RHVib2NnVVZuUVBCaGZUbW1BV01rVDU2blA0MU55d1BBcUVGMnlsUWVoNjFPWGVSeFZwSXN2MjAyUC9OZi9VYXQvWTVDMnRRNE9QQzV5ZmlxaFlmdFpmOEFxUDhBNmpWNTdFSURyQ0VqL3dBTmgwK0t5NWZWVngvR2hRSURkd1JnRUFBZnVxSUpYQWxJWTdzOFpQdlJtMEN2cTBBQ1l4bno5Rk5EWXdnT0NBQWE0blVlZ01za2E4aytYSnFCY05JTFNWMmNFOTRGVmNkY2NtakZzcTVSZU1aUE5RTGtnYWV5TXErS1hJSUhJNHBRSVlrWW9ITzBESHBSeThsTmxvZW4yaWhkOTBQMDJZZW9QRVlQd0FUOWFETWpDM0dWR1NwK3RGdTJOd1lkZm1oVmVJVWloQUlCd0ZRRCtkVVNBekR2YllsY0FBOVBta05jSUlXS29NN3VnK3RLYTUyL295dEV1VEdDZmVveXlxNEdJUU10MHlmU2thWmJScmNCQVY1QzgxQnY0UWlTREhQU2lOdmN3eFRzV1FrYlR4dXhpbzJwdEdrakRKd1FyWVBVWjhqUlBZcXc2TnFqalFEWUNJdENTWGxlTmR6b05vVWNmSjYxZXRPMXk2MDdzZmFUTGFDNW1qVHUyQ3RnY2M1QXprOGM0ckxkSGxkVkllTldXUkNEMUczNmo0NlZwOGVqV3ZhTFJyQmdaSmJhM2FRdEZGSVU3MXlBQUNUNURyOGdWZUc5OUp5MXJzUzA3dE5GZmFGTnFheDdVaFF0S3BJTzBnZEt5WFcvdE4xRFY3dHJUUklvR2lrd0E3ajhmenE1NmhvQTdIL1p6clNXVUVjVWswV3dJc2pTc0J6eXpuRzV1dVRnVm1YMlVSUUxOUGJySEFaSlkyS1N5eDd5Tnk3V0hYb1IvR3J5dDEybWEzMHBuYVhWcDd1Q1FtV3p1SHpoakFmdS9TcVpxYnUxb3ZWV1d0cTF6N1BQME84V1FUV01Wb3NUS2tWdWhHNGRRT1JnYysxWTkyeGtoanUzaGl6bm8yVGs3dk90T095OVJHY3Z1bzgyb3JKRVprTzBrSGNoSG5RODZqY3dYTFNXc3pvR3lOb1BCb2VIWnRxa2xsejkwOUtlc3U3aXY0djBtTnBZMWZsRUdTMk9uRmJhMHoyMHJTWmJxUzJ0Skx0QXR4MVpRTURPZVB4RlErMWR1c2w3RzhtVkJPWEk4eFJYUjVvcjBXa3R1eGtSeGxjakgwOXFGZHQrNFc3WlF6aTVVS2RvNkFHc0ovczB2cFY1SDNTOXpFakNJTmxXWWRhZHVZSkhoM3UrVlBUSGxYT2p5V2dsSXhHcDJqMU5lejNkcmJ4cXNZY2tqb3c2R3RVQnNFTW1STDVaeHoxTkdsY2lJcFFyOUtaMFJSSGxRYzA3RmZzY3E2WnoweFZXYkl3b3hLYyt0RW95ZHZHRFE0OHluSXhrMFFSZ3E0R2Fvam1sV1Uwc2NzeUxsTzhibjZtdFA3TldFVnJwcHVGeVpjWUJQbDBxcGRqdjdSWmlHUGtoMjNmaWF2ZHJCTmJ3bU51SXl1UUQ4MXpjMlhlbXZIUHF5NlRsOVZqUG9ySG4vSWFFeE1RcTU5S0w2SjR0U0pKeUJGTC9BUHpOQlZCQ3I4ZXRjemNUdGxaaXBVRWtrNHh6NVZEdnhzMHRIZjd6U01RUFBIU243Wmp1QklrRzBldFI5ZDQwNndabUpMb3hBejA4UnBUMmRSbVltS0RJd09Pdithbk8xVzZYdFhxbTRuSXVKQi83cVp1QWYwVGN2a3BJK2FLYXRCM3ZhQzRsbVhDemlPWUVlanFHcXQ2U0UzYk1MaEEzOTBCT0tiaUlhWXFBdzVKSkhuVW02akRhakpqTzBQZ2ZTbWJUS3pGanlOcFBGQWVKbERJd1VOakdNanpxTVpqSmZYSWRza3VNazlhbGtLOGE0NnM0Sm9aS1ZGM093eG52T1BmbW5CVmdzcG5ObzNpSVhPMERQV3RPK3lTOEVtbGFoQTV3WWJqZmsvNFdYK2Ftc2xzcm5kWndLRkJiTE1UVjQreXE5eHFtbzJ3WUtseENOdWZOMUpQN2lhckMrT1d5eTd4RXZ0aTdUTFpkZ1paVnM3bDJ1d1ZqSGRrNEdjYmpqb01ldnJYeno5bld1dnArdjJwaGdrZUNRRVQ1encyZU1lbGFUck9oZHR0WWx2WmhESkpERHZpQmtuMmQ0VjhsSHB6MDZjVmtHcWFWckdsYWxKQzFzNk0yQXl4eUIrZnBXa3ZsdmFML0FCMXByWGJmdEU4VVk3bGhzSXlQWVY4L2RwWFo5VmtkemxtOFI5czFaN2U3MUZOR2tHcHh5QlZuQ1FiK1RnamtINDRxcjlvbys3MUhrNVlxQzFWeFllS2M4dkpBaDJoWkdac01BTnZybXAybGFSY2Frd2FIS3dnamZMNUtmUWVwcUZib3BMTktKTzVVZUlwamQ5TThaclV0TnM5T3N0SGhHajNNdDFhT1RMMzhvQ3V4SUhCQTRCSFRIdFdtZVhpakhIYVZwRWFXMDhFY1MrQ05RRno3VldQdEdFaDdRL3FpQW5keDd5dFdXMVA5cEc0OGpqSDFyM1d1d21xZG9OWmxleGFNUW9pT1djNEpHM09LeHh5a3kzV2xtNXFLTmNHUHVFU01zRVh4RTFEdUVnbklmZmcrUXpSTFdOTHV0T2tsdDVWSkpPQVZOVnhVekx0YzdjSEZiNDk5czZreHlneTdOd1dNK25GZWQweXpiQm5PZURUYlc4aU5nb1RucGlwTVVURndzNVpTQndLb2lTZHo1UE5FWW1Rb0NBUHhvYUJnc0tKMmlLc0l5U0NUbW1Tdy9aMjRFTnljYzk4U2ZqTmFkZDNuNlhGQUZVS0ZRTGtlWXJHK3hsMFliaDQySkN5c2NmT2ExWFNWbU52TVpFYnV4dEVaSTRQWE5jdk5QNWJhOFY2V3JzMUdHMWNaSUlXQ1ZqbnArek5DWndXQ0R6QUpJeHhSM1FXRWJhamRFWmFHellEeXlXSVQrTkFydktPb1BQQkZjN2M1R0FxQmlUdXhqQU5EdFprQlcxaklQaGpYR0Q4NW9oc0JqWGFwNUJISnpRM1YyYVdkRllEd2VCZVBMLzRhSjdGT002dmJBTG5wNjBhZGxtMC9TNzBrbnUyL28rZjJLNWFNL1ZTUi93QnRBSkJoRDdEeW9ub1YwdHEvYzNTczlsZEtZN2hWNUlIVlhYL21VOGo2anpwa2p6QUM3S2hzbnhGcy9GZWFmQ2paTXNvU1BhZHgyNUhuVFdxYWROcDJvbTJua0RNRTNDUkRsWkZKQlZoN0VZTklqa2RkUGtqMkVsK053OU92OGFORFpjU3JsUURnTG5wNVVGd1RPeEpVNzM4elJ1SUFTc1hHUWluenhRTXliRkRJcUE3dXVNbnpwd3FMd1F4ZDFGRW1kN0VzQ2dESGtjREh6VHVuVHo2Wklra1RHRzdobHlHYis0UUJnKy9uVUtPZDNzNFpYWDlZZ08wampJeUtYRmRPYlZTd0FLa25KNms5YzBHMnpzN3JPbmRwZEVsRW5kN2xIOW9oQis2VDVqejJuMXJQZTJ6OW5kRXRVdmRQamplTnQyWEI1WSs1K2FEOW5yMXB0ZDB1MnRyZ0M3dkxpT0FpRS9kUW5MNS83UXh4Ukw3Uyt4OWxaNi9iMkxQTEJwMm9ndFpNN2w0Ky9ITFF0bjdwSXd5bnp3dzhxdlZ5bTc4VHVTNmpBOWQxazNkOXRqWEZ1c25lNTh1bmxRTmJPZS91WG5tQlZXT2ZmSDhLMnJWL3NvbHRld09zOW83c0dDVzFpYWVDM3p5VVFqTHQ4akpBOU9heW5VTmVpTUloMHFMTEJjdk15K0ZmZ2VmeWE2TWIxMUdOL3NHMUlyRnR0b2hoVjVJOTZsZG45YmwwcmZDMjU3S1U3blFkVmIvRXY4UjUwSkxGbUpZbG1KNUo2azBwa1pNYnVNMWVwWnFwMjB5emxXZWFPV053eWtBcTRQQkdhdkZwZnkydGhjeW1NbktBQmcyTThWZytsMzEzcDBnbXRHeW1mRkczS044aitJclhkRTdiNkZxR2kyMW5ORWJXL0JQZXJQd0cvd0FyZENQd05jL0poWTF3eVZUdFFKbzdZWHpFaEdPQ090VmhiUVR1a2lCdVd5eFBtS3NmYW02ZmZjUnhxQlpPT04za2ZhZ21tek0xcUY2QWNBMXJqMUVaZTB1MGdEWE9UMEZPMzZvR0xZR2NVaUZ4RVNjNWFrM2JGNGlTY0RGUDZRWkZHSkpqeVBXaTBhS1VIaHpRZUJjeWpCbzFCRXhqSFUxZFNCNlJlSkE2c2MrRnlmenJidXpQYWFEV3RCaXRyZUZvelpzRmtabCs4U0NSODFnbG1NZzRiSEovZldwL1pVQXVtMzdPM1c2UVk5ZkIvdldmUGpOYlh4WHZUWCt6VDJXL1VMZlVybHJXSzRpUkZjSnVKd3diSDVVNWVXdlpkc2w5VTFBam9kc0E1NW9WWXdtODFXMXQ0eGxwSlVRRDU2L2xtcDNhT3dlNjdTTnBlbndySmV1N1N5U2trQThGZ3FqcHRDNDU4elhISFNjZURzdU5rWjFEVll3UmtFd0E1TkluMHpzM1BjQXJydHpFaEp3WHRlbisxQmJvbExpTHZnVk1ad3dJNUdPQ0taYVVHNGZEL3F6bkF4MDVwYi9vYUdaOUQwVjJLUWRwNEcvelc3RGo1cUVMTzJnMVMzaXRieU85aktsaklpbFFEMDZINHFFV1dLSUZUeVd4K0FwNnpJalF6RWtFeG5wODBXaUppeVEzZGxGcGQxS2lYTnZnMmt6SHdFTTNpaVkrWFBJUFFVTjFpM3VkUGRMUzVoTU1xZ3NRM21QYnlJNlV6TVZNN2pQR0I1VVNoMW1TSzNTMHZVVytzR0dCRE45NUIveU4xWHAwNmNVQUU3ek1SYms1SGw5YUNLUTBhcXc2blBIeFYxbTBteHZZczZMcUVRbWJsYk83YnUzYmcvZGI3cmZHYXFPdmFkZTZDSXhxZHJOYnUyQU84WEFKOVFlaCtsWGltdk5VdllJTGVDRzM4Y216OVlDZUYrdEJKNzJlOGx3WHd2R1FuQ2dmRlIxWXlRK1lKWTUvRS95cEY1ZFI2ZlpQTTNBUUVnQThrK1FyU1k2WjI3V3I3TjdpK1h0N1lIUjdhSzRudFVsMnBKbmFaSFFnRTRQa092eldtL2FsZWFoTnAwdW5kcHJiUzU5TWlFZHpKK2lHU09ZT3ZpRFJ1U1FweUNPUjBKOWFydjhBOU4rbHNOWXZibVFabXQ3ZEJJVDVTU2t1MzRCVUh4UTM3ZU5mZlVOUy9vN1RKWTFXOG5TSXlPMk1vQUZ6N0FuUDBxcnZXcFJOZlRYYUQ3YTlSN1MyK29hTm9tZ1doMDY1czVJSjViZ3VCQ2pJVllsaHhnQStnejByRkJwcTJWb2x0bmU3Y3U1R00rZy9EbjYxYzMxRnJiUVlOQnRtMjJNTEdlNksvd0RqeStXVDVxT2dIcVNmU3E3dGE0a1lucVR1NitkWEttd0doc2tSOTVIUHZUR3FJcXhKakJ5ZktpdDJ1MXZDTVo2Zk5DNXdyWFZzcHdjdjRobXJsVFU3VDdNL29pQWpuR1RTM3RFQnhzQnoxSGtLS1FLRWczRVk0cm9FVnZFUmtBWlB2VTdQUUZleHlkeDNiU2tSTHlGT2NDbjlQa2pNQ3FwM0JSZytvcUpyVHNiZ0xuQzg4VkJpa2FOdzZIRENxMXVKV0JGVnBTUnlLVGRZRURCaVJtaGtOL1BHY2dxZmtVcWU3a3VDTiswRDBBcHlEWnl6T0pQYWpsc1QzUW9CYi90RndldEYxM2dEYlRwUkIwdlRrYzNHUjl5RVNENU5hajJBdEV0dERWMVhtV1RjeCtGRlp6cGF2L2JTdlFXeTFxSFkzZEYyYnRBNHp1Y244aFdQTmVtbkY3V2ZUcjFyQzhGMUdvYVZVY0tXT01FcVZ6OGpOU2RPMTZTenZ0SXVWaDNTV3R1YlZ6dTVsWG5Id1JrRDZVSG5PSTI2ZTFKZzhNaXZnWUMxeXR6MXk1WGFTMjd3c1NmVTU1cUlrbTVaQ3cyakdEajFxY1FxUVJxY0hLRWtuMTVxSW9Sa0tmZTZEcDhVb2RJdUcyeHhLQ1FjNSthZVdRL29qa0huYUFmOXFadWltL0lQRzdBL0NuNGlvZ1FSbGR3WHhmSlkvd0FCVEpDbkxLMHA0NEFHS2c2dkcwa1lqRWp4SEFkV1U4a1VUdkNYbnVCazRMZnlGUnI4YjVJMEgrRUtlZlBOT0ZVU1NYY0Y1eU82WUhKenowNlVDN1Ezczg5aWxrODgwa0tBaUtKbkxLak54d1BMeXF3UENkN0tBUHVIZ2tlWnFxWWVUVTVXWWhva0picnlHendNZm5XbUtjamthZHhDa1pQaUFBSlBVNEZBN2tuVnUwZHBZam0zZ2J2NXZnZVgxT0tKYXRkaTF0WkpuUFFjVVA3TXdiTkJ1YjEvMjk2NXkzb3U3YUIrODFwT3B0bmYrUG9mN0tTZEsreS9XOVcrN2MzUWt1ZDJjRUt3S3hmKzBCdis2c0oxS1JydlVadFFuOFg5eTJVOUZVY2J2NVZ1M2FlYTAwbjdMZFZ0REtFTnhxa3Rza2E0QmRZNU5vVWV3U05RZmFzRTFHYmZjSkV2aWxjZ2JWNENqMVBvTWVWTC9pcWlUSEVDZ0hCa2JjY2VubC9Hdlk4SUQ1WnBESHZibkkrNk9CN1VxUTVVa2Nwa2dFZWVLcElOcnpUQ0FORTJFQjhZSFg2VVAwYUFTVGQ2M08wNEZHYmw0MWdsTXZDWU9RZk9nbWh5YmJobEFPQ000OUt1ZWszMnNlb1RDR3dibm9PZWE2MG5JMFZaaG5kSU1qNlVLMTI0ekNJODhtaVduRGRwVnFOd1dHT0liMjlTZWNVdGRIOVZ1NzM5OFRJd0xrOUFjNHBvVTdjc2h1SE1TamFUMVBPYWF6V2lDbDRxVEI5MS9pbXJVSzA2Sy9Dc2NFK21hZmtpYUNXU1BPY0hGQUx0L3dCb3RHNG53ZzZtZ3RxQ1pBUE9pcU1Rb0hXaWg1cDhrMGNONFRHVkRXNkRKSFd0VDdLc2Y2cVdQZW5vVy9lS3FIYW1hS1RzSnBGM0RDSXBaWkdqYkhtQUt0SFlrbTU3SldVa2h3RzNZSHdjVmh5OXpiVGo5ak1oWEE4K2E5UW5mRXVSOTNKRk5PY3I3QmlEVW1GRllBODdzQUVlMWN6ZElNUCtNbmFNWllkZmlrQjBJY2hUNFFBT25yU1pja3hzRG4wK0tTcS8yWEIrODc4L0FGSTBYVVJDWkFrY3lrb3U0K0VnRDYxRXM1eEdzMkNIVUtwSjh2UCtkZTMyVk1wYkJMS0FQZ0d1dFkvN0VmRHl3SE5WUFJmVDEyNmJwVy92NUhubkdjVTNkdUhJWS9lM0x6VGN3TGQ2Q2NIZi9La1RxQkh5U0NDQ2Z3b0p3YmJKSzVJNmVmbHpWWGpHMUdQK0ppeHFYcThybFJGR1NTNTNIMzlNME4xU2RiZTFZbmphSzB4aU1xcTNhcTZlNnVZcktISloyQXdQVW5BbzNxWDZqU0hzN1VaWkVFVWVPdVIwL01WVmRJa00rdlJ6UHljbGgvQ3JaZDIwcHQrK1puZ3R5MjJXUmVvSG9ENWU1OGhXMlUxcU01MzJzSGEvdE5MMmwxeVpyUGZIYXhzWElZZ3BicytHa0MrUlpteWZZWXo2VlY0WFJwTHFXTlNJb3gzYUFuSkxIcVNmTS96cVRxUGQyT2w5ekFpeG9CdFZWNHdLSHlLWWJDQ0RwSTQ3eHZrLzdZcVpEdFBXcHlweU9ENVV4SkwzTXJZNWpiN3kvd0FSU3JkKzdpMitmbFF5L3VlNGhhYnF4OElIdlZTRUg2M2RkNUtJVlBnVGx2YzB2UzRlNmlhUnVDMzdxaldrUTJtV2JMTWVlYVZQZGxRVVRqcldtdmlmN042aE4zczV4MFVZK3RXQldSTklnRGtyR0VHeEIxUEhKTlZVOUQ3MWIrN0FoaVhidUlVZUp2aWxrSXIzY3lTRmlJdHE1NDhzVXk2N1dJeUQ4VVd2QzdNVjNkUEljVUxsajJFRG1uS0s4SElxVVdabys4WWtsanlUVVZlbFNFTEdMYnhnSE5NaTRXS3NDT3RGVVVzb05DNFYzT0JuSG5VOFNPQmdVd09kbzlVMHk4N0xhUHArbVRCMmhkblllbVJWNjdFUWJPeUdsRGN4SlYrQi9uTllwcGtZTWFlSTlLM2JzZU5uWkxTVVhBekVjbno1WTFoelRXT21uRjNSQm94R2hKOFRrbmp5RlB4RHhSNWJHU01uMXIxNDhSZ0tNRHpyeVU1a0NwZzR3YTVIUVJLQ0FNNEdBYVFaTWxNOUFHUDhLZnVHSGR4b0FjK2VmbW9rZzRtNSs2b0dUUkFIM2I3M0toUTNHS24yYW9ZQUpkK0ZVWTI0UFBGQ0lnWG5MZjhBTWZ5cXlkbU5NbDFmVW9iS0lpTjU1Q043YzdWQXlUajJBNlZWbnhJZTBZT1dZWVV5ZFFQZWl2YTdzcEwyZDdLLzAxcWw1SEVNcXpXK3dsa0I5VDZnZFJpckJxVTZkaWRWdCs2N0phcnFNU1NodjAyT0w5SWNuMVVEaGZvT0tHZmFkOXBWaC9VeUdhNzA1NDlRbW1iOUZzN3hRTWtIaDNUcnRIWEJBeWNldFZqai93Q2xhelRVN1ZyWVc4ODg4Q1R5Z3NMVEo3NUkvd0M2N2pvb2JKd0R6eG1xTDJ3djhsYmFOdUR5MURaOWV2WlpiaVdTVGZMUEswMDB6SHh5c2ZNbWhseEs4OGp5U0hMR3VuRERYZFk1WmJXYnNucHBWUmVTREJjZUFIMHF3U0V0SGgyWXhFNUVaUGhQdVI5S2c2SzQvbzZKSnBFaC9WK0hkeG5IcDcxSWlsV1NGV0lLNUpIUG9EMStDT2FqTHVuUFNQY1p1cnFPSnVlZWZpaCtwemQ5cVJLOUI1Q2kwS2dTelNuSUNqQVB1YXJ6RWk5YklPT29xb1ZFZHhlSTlBY1orS3E5MU1ieTg5WWsrN1JMWEx2dW9oYnhzZDdqeEgwRkRiY0NPUEo2bXF4bjByVHJ2aGNjZ1krS0h1ZHpFMDdPNUp3S1lIU3JpU2h5UVBjVmNaMjI3UWNkT0JtcWpiQUc1aEIveHIrK3JhMFcrUXZrdDdBOUtuSlVSTzdCY256b1ZmamJKakdQZjYwZktqYWNkUlFyVmsyZ0hQbjB4U3h2WW9hbFB4bkFJcGhhZFRyV2lUOGZCR0ttSkpoZWNBMURpNFpjOU0xS2NLV29BWnBLa3hMNDhERmZRSFpVcW5aN1JZbk8waTJVZ1k1SXI1MTBtNWI5Rjh2WE5mUVdneUQraU5LSllobHRJeGcvRlkvNUU2WHdqVjB3MmphNHg3VkVOeXNUQmprL1NsZDlic2N2TVZKR1N1M3BYaldzTTZkNTNvS2pxZWdOY2pvTTNGOUgzc0prRERjTWtlbk5JbnZJdHJLQTJYOFhOUTlZamlXOFZGWThKZ2djNTVwazkyR2JlU3hBNDVwNkxacHBSRVlnQ2ZFQ2VQZXJOMksxV0swN1E2WksweGdINlNzVHV3NEFZRlNmam1xcGNpUGV1QzIwY0Rta2pZWUhSamhHWWVmdFZhTGJkTzI5L3dCbzlOaGtXMDFIUjQ4SWYyanlKSVFlTTR3UUQxODYrV1B0TDF1LzFlN3RCcWJhYzdXMlkxTnF1Q2VPU3g2bitkYlZIZGRuZTNmWnE5anVyZlVicnRSb2R1a1VzTmxNNGtuVUR3TUZCOFE4aWNaQjQ4eFdHOW83REFsZVBTMjBlMmpKRHRjZzk0eDlNSG5OYTR6K1c2enk5S3JMM1NxVmlZdjRqaHl1TWp5NHJyVTdaME8wTVIwRk01NHFkcE1Ja20zc0R0WDAvT3QyU3hXamwzUm4rOG80OWpVdHM0TFpPZXRSZTVoa3VaREFycGJrWlRka0VuLzVpbVpvQ293a2tpc2YrYk5ackVMaHBCcGdJKzh4TEgzSFNnZDFLc0Z0MzdueEhoVjh5YXNXcHFzRnFOekhiQ2d5ZmdWUWIyNE4xTzhuS3Jud3I2Q25oTmpKNGhhYWN2SVNXUEpOU1ptQWovTG1vOEgzUng3MHFUenorTmFJTXNjMTVYZWRkUUM0ZUo0Lzg0L2ZWemloQ3FHWW5tcVVDUVF3OGptcm5BQkxFc2diY3UzT0I1Q3B6VmlUT0N4NEI2VUYxTXNjQTlNNW8rWFF4a0FucFZkdlczczNYZzBzUlVNVkx0SkJFWHlvTzRZNXFJdlduVnJSS1dER3paeHNwM0FQUjF4VVJlYVYrRkVBVHBvVHVENll4WDBQYW94MHUwbWlVSkgranhyejVZVUN2bkhTam0zSG5tdnBHeXVvcGV5OXFqRmxrVlF2NEFWbC9rZkY4S0dKekRQaHNFQWNpbGk4Y25FTEhZb0pHVnlLSE8vNjg3Z3hHM2ozcjJHUllMYWJKWWs4WTlUbml1YXhySzllN2trSTd3Z3RnRElBQnBMdUZkNHBHMkVkYVN1WnBWa2hqeUJ3QjhjVTFQQkk4a2pHUHhIa2ltRGMvT1R2UGhweVJ0c0RzOHFxNFllRStkTVBDNmcrRHFCVUthVjVieWFMYit6NXgvaHA2SlVadFZ2dEI3WnphcnBkekxhM2lUTVVsaU9HQUlHUjZZUG9lQ0tSMmh2YmpVN2I5SjFPWjU5UmFRelRTbHNodHpFREhrQWVUOUtPWG5aNk84bXVMbTRrbE83YXdWU0FCZ1krZVFLRWRwYlNHeDA1RmlCM1R5cm5KNktpbkFBOGh6VzBzdW1kbFZyR1NCNjhWWnJXSkxTMVJTQmw4S005VDYwSDBheWUrdjBST2krSnF1TnpHUmFTV2lxZ0J3VEtSeUR4MDgrS3JLL0N4aUUxd280d090TjI3ZC9md1I0SURPTS9TcGJSb1NkcWdmeHBoWmxzMmx2SkFDTGVObkE5VGpBSDRtcFVoZHROUUc4V1VUY254eWtlWG9LcXRLbGxlZVI1Wm0zU3lNV1pqNWsxN0V1ZVQwL2ZXa21wcG5ic3RPQjZHdWMrZ3hUaURnNHBweGpOTUVldGVVb0RKK0s4UEZNUFJSM1E1bkVRa1p0a01Cd1hQOTRmNFI3MEJINTFaZERoZGJObzdtTUJRKzljakpHZXVhbkwwY0tlNlNiSlVqbWgxNHJjbFJ4MUpvdGNSTEczaVJkcDZNdlNvN1JyMDhqVXluUVZldE9DbDNrSWhuS2pvUm1rTG5OYVJKMUIwcGRJWHBTeDlhY0lCMG45a25IcCsrdGUxZlhXMHEvL0FFZUh2SHR0aXVJK01LU09ockk5R1h3UlpCQXlNbjJ6V2w5cFZ0N3JWWlo3Rzd0M2o3dEJ1RGRTQjVWSEpKYjJlRjZOdDJtdkhrSWl0OG4xMmRLaXpkcFpXQlJ5eXFTUHVKem1ub3RMdEJwYXp5eTNEWFVwWW9rYkFJb0J4elNScE9sU1c1RWE2aWJuY0Rsbkd6SG4rZFoveFgybDJuYk8xc3c2SmJTeTdlVWFUQy9QRkZFN2M2TTBXOXJlOFU5R0cxT0QrUFNxL0hvdGpjbmR0dVkyTEVFN3hqOE1WeDdOMmFveGxOeS9ubEdVZnZGVGNjRlRMS0Q5NzJyMHlheU11bGJsbFhoMXVDcWsrbU9hcjUxcTREeWFnenhxc3pZWWtjRXJ6aW43THM1cFZ5UUo3dStpY3R1S3Bib3kvVGtWNXFIWnpUSUlzRFV0UjVKa0EvUlYyZ255NE5FbU02RjhyMkgzR3ZTWFNrdmNSZ00zQ3FNSE5NZHQ1R056WlJTSExKRVdiNUp4L0NudE43UFl2YmVWcEpER2poeUhRRE9Ea1VHN1JYcTMycnp6eG5kR01JaDlRUFA2bk5YSk45SXU5ZGpQWTE0eGJ6aFFlOTM1WnZieXFiY1hwUU9IUjFiZDRsSzRJcDdUVWcwWFNBN05zWlU3MlNUSE9ldFJtakt1OHp0M2hsMnNyYmNEYWVSKytwOTNhdmlISnFhQVk3dHg5S0g2bGRDV3d1ZHBPNDdBYyttNy9haTRnVStqZlRwVUhWclpScGx5VVU3aHRicDVBaitkVk5GVlpSU3pZRlNQMmFZSDUwdTJUQzVQSlBXdkx3Wng2ZWZOV2g3YXJ1UWtpbXJrK1BBR0JVbXdYS0hQclNMNVZVREdOM21hRE5Rb1dYb1Q5S1JJbTA0T01pcDFwdGExQTR5T3ZOUjB0Ymk4THRCR1dVSEc0NEF6ODA5a2QwaTJ1SnJ1S1NHRXZHamdzeDRHUFBtclZzYUp6M2JBSTNrMU5QdXRWZ0hDeE1vWGFENFZPSzVwQVBDMlFENzVGWjI3WEpvNFpJd29Fd0E5ZWV0QUxpNVdLUjFpTzVTZU9lbE82aVNqRlNlQ09EUWtkYXJHRmFkeXprc3h5Zk0wdGFRZ3pUaWozcTBsaWxqNXBJOHFjQVB4VGhJdWpRNGdYYnljREFxN2FEcE13VXlYSlFaNXhueXFzNlpvTnpIcFZyZlBISXRyTVNrY203cVJSV0hUM0JCRTB2OEE2eldlZDM5UEVkMTFlNWt0MHRHamxqVk01WG9UbnBRT080dkVaekdvSlBsbmlwMXZHMXVpd2xtYmdzTTBoblhkNGZ2SHFmZXM1MTB0Rmd2WjBEN29TWHlPajhWTVhWWjBqWWZvckhQVWgrb3BDbFNDTTVPY25pcFVpdGFhVC9TRDkyMFRrcHRCeXlnZVpIa0tMb3pRMWtpSjkxazRiR09IQXhTTGpXRk1BamEwbkxrYzdtQXg4Vkg3KzNtajNic2dqakZJTGh4akc1czBhZzJScXVydW1pTXNhdkRKTTNkS0dQTzNIaUkvZDlhcVE0QUlBd1BLaVd2TkovU1VrTXZIY0FSaGM5UE0vbWFIVnBqTlJGdTFzN1F6RzgwdTFqZys3Y3lSb0NQUTBYMUdIOUZpaGlZNUt4cU0vQXhVVFRiSnJucy9wTXR1dVpZWlk1Q0NjWlZYNS9MTkV0WENYWGY0NGZncWZpc3JmaS83QlJJQUFCK0dhUks2eUk4WjREamIxOWVLWUoyb1haZ3FEN3pOMEZJaVNlN1lpMlRiR1IrMWxHQjlCMU5Wb2diYUVjb2MrRTR4WE91OEhxTTFOMUMzTVZ4amVIQkdTd0dNbnovT21kbkdSODFlMGt3NGlpSlBIRkQ1WGFlWGdkZWdwNjZrYlp0SDFvam9lbk5NZHhIeWZRVS9YWUp0clNRUUNLSkdaM0lCSUhDNTh6NlVjaWtTMkxXb1JValRpUGpnaXBXMFd5Qlk4QWUvbjgxQ3ZaRkJBWWVFOVFmSTFHOXExb3VmOVpFMGJnRlNPZ29MTkxMYW51Mk9VL3VzZXZ3YW45OElseUNTbnZ6UXJVTG9TNEdPbFBHRlROek0wbVNUa1ZIRmNHT1RYcTFhVGlkT2FkQTU4cWJVY1U2b3BndGVjVTV0YnlyeEFjQ25ndnJ4UkNRckR0SGZUNkJaNlpJUitqV3psMDU1eWFreDMwd0F4bjhhdlhaM1ROSWEyaTNhSnBibkErL0dUbjU1cTEyK2o2TXZNdlpuUW5RRWRJV0J4LzZxeXk1WlBpOGNMV2NXYlBQYVcwanQ0aXB5TStWS1pmUEJCclY3ZXcwUXdFUjludEZYWmtZN2h1UE1ZOFZleVdPa3BHQ2V6K2lFKzhMYy93RHZyTDlZMG5IV1VZMi9kSkI5cWF1TFlTb1ZZdnRJNUFPQWEwdmJwa2s1aWk3TjZPeEJ3ekMzZkM4ZFB2MUpGaHBTZnRkQzBZazgrR0dRZi83by9TUS9CanFXZ3Qyd21jZW5wVG9RN2g2SHJXc3pXR2pEWjNmWnJSNVdZQnNZbDgvL0FObE1QcHVtT015ZG5ORVQyTFRBL2dIby9XRitkWXByUXhmc2NrN2xVNVA0ZndxQnlUZ2RUMHJRUHRLc2JLMTA2MGx0ZEowNnprZWZhSmJaNVNTb1VuYWQ3RWZsVkZ0SW5udW9ZNDFMTVdCd1BZNXJmRExjMnp5bXEwclFZamE2WEJibnFtNVI3bnJVWFVQMVZ4TWNZVTVZWS9HamN0dm1KeWd3UTI0VVAxZXludUVqZUJlVzhKejBIcldFdmJUWFNyUjI4VnpjZDQ2bG1EZENjZ1o5cUs5ekkrMkdDTjVKVzRWSTFMTWVuUURrMUowdlJyMldjUXd4OTdQTGhFampRbG1iT0FCNzF2dllic3FuWmZUcml5dGhETjJtdW9jM3QyVGxMS005RXovQWNzUm5vQlZYSXBHRXgvWjUyaXU3YUdaN1NLelJ6a05lVHJGa0h6eHlmeW9nZnNsMWRWWHZ0UzB5TU1oWU12ZVNLZlFad092cjByUmRYRnJhYWhhNlgyWXNaTlp2MVFpZHBWRGhlZnZzVDRVSDREM29iTnFHb2FlOXcydTZyYWdLM0Z2RXBjN1FQdXF4d0FQajByTDlNL2pTWVlxSGJmWkRkVHpxWmUwZWpyRG5CWkk1WDZkZklmdnJ6dEJvdjlXYmsyUmFPV0krS0c0ais3TU1aejgrMWFMb21xRzVpYWJUaUk5T0liZWpRNUxmRFVFMWJVclBXb1cwdU54UENQQzVZQUVOMUJCOGlLSnlaVzlpNFl5ZE16dUxqZ2pPZlEwT3VIM2pCODZlMXUybDB2VUpMVjVGa0Nud3VweUdGREpIWnVuV3VuR2ZXTmV2S0ZRcVR3T2hxQktRV3lPbFBPanYxNEZNT3UwZ2VkWEVrQWMwcFJYQVU3RXU3am5OTWlrSEZQSUs1WXVQQ2FXcU5ucFNCeEJ4VHVQbjhhYVJUa0Nud3A5cUFzdlo3V3JtT0JNZHowSFdNR3JWSDJsdlNvSDltSUgvQU9Pbjhxem5RWkIzU1pPT0tzMExaR2V0WlpZeGVOV2dkcHI4cVQvWmg1Y1FLUDRWdzdUM3k0UDZqcDV3cC9LcTRINHJpNUl3TW5IcFdYakYrVldNZHJMOE1mOEFoajdHQk1mdXB1WHRQZk5nbU94UHNiWlA1VlcyZm5PQlhHUTRvOFlQS2paN1JYcWx2MVZrdTRja1FBZnhxTyt1M2JaTFJXWjUvd0RKL3dCNkVzNUl6Z1UyVGo5OVB4ZzhxUjJtMUNlOGh0UktzU0xHekVDT1BaMUdLcnE3TS9zOGZCeFJpOVVPTUVnNDVvY0VWWkFjZ2duenJUSHFJcVZHd1VJT0ZCNjV6U0oyR1c2L0lKcGFzbmc4UTloMXJwT1F3em5QMG9DNy9ZZGYyT25kcDcrOTFGbGo3aXljeFRzL01MRWdFcXA2c1I0UWZMUHZWM1BhdE5YczcrOWkxTmJIU0JjR0dTM2dZRzRkOWdZbG5QQ3JqamVjNVBBNlZpK2t6UzJseXp4c1J1VXFRRG5JUFdyR0lyUzQwb0kwY1F4SVg1VVo2QVkvS3M4NXVyeHVvdEdsOXJiL0FGSzJIWi9zZnBrTVl1WmR2ZmI5cG5iQjhUc1RsemdIbnB4UVM0dTlEMEhVRFByTS93RFdLK0tzRTRJdFkzSG9uV1FaR01uajJvSFlCTENlS1NKdnVNVHN5UU9oOU9sQ1pyR0tlZDVHWnQ1SExNU1NhSmpOaTVVMXJmYW5VOVN1N2llYVo0b3BTRDNhSENyajBBNEZRN0xXNWJKUDdPSGFRbk9TS1dkUFl1UVc0SFFtcFVWcEZBbTZYYTNvSzExakpwSGFzNmhkeXpUYm5EYjg1TzZsd1B2QUk4cWs2amJpWExJcERMOTBmd29kRVNyWkhROFZjOUpTWlpRbzJqclVROG4zcFpCejYrOWVxdk5NaVFPS1dBZUtVRndhWHNQSEhGQVNMZkxxTTRiNXFYR25vY2ZQSXFGR1dYRzAxTnQ1aWg1Rktta0lnT055YnZjVWg0MURlRWtDaVRTeG5SNVhBaU1ydXFBNThTTHlUK1BGRGNDaVVValFRbmNJUjZWWklTTWNZcXI2Q283aVBqbjFxMFJaSUhURlRrTVR5RURrNFBzYThZQnM5QjhVcFZQcDlLOUFJUHBuMnJOWnJhYzlSWGhRbnJ6OWFrTXJBWXh6N1UyVUo2clFERFIvTklNZkhUODZlN3Jrbm40cmpHY0dtRUtTTmlNcmc4LzRxZ3NHM0VFdjhZb3EwU25KWU5uMnFNMENsZ0FYSjhzbkZNaktnNVhBZjhLVTZsZ2VTUHJUM2RoU0F3WWUxY1l4amhEK2RBUjBWMTVEakdNNUZFSXBtU0VoanlSNlZHU05pY2JjZkJwMHF5eG5JSm9vSWtrNXpnZmhURzk5eC9kMHBRY2Y0VytLVG5QUlNmbWdHU3pqSUdlZmVrdHZZWVlxZm1udzNoQUErYTlZREdSZ21nQjd4RWNrQ2hsOWI3Sk84UVlWdW85RFZpOFRjQkNmWUNtWHMrOUxveWpCSFFuSDRWVXBXSzZCbnBYb1hKOXFrVDJ6UVRORzQ4UTgvWDNya2p4NWZsVnBOcW5oelhGZWV0U0FudFhyUjBBMmk0QXFUR3ZUaWtxaHA5RXhTTXVOVkJKSVBJd01IenIwQWYzZ2MvT0tXb1B4VGtxbDIzeVNCbmJra25uNjBBeHBIL0RRZjVSVmlUNzYvSDg2NnVxY2hpa245bjlLY2orNjMwL2ZYVjFaMVpRNkg0cE12M3E2dXBHVDUvU201UEwvQU9lVmRYVXlKbSs0UGlvTGZjK3BycTZuQ3BjZlJhZFA3UDhBR3VycVptYmY3NStLY0hYL0FMYTZ1b3BmRWQvMnIwbCtvK2E2dXBrWWwvWS9oU3ZLdXJxQThYN2crUlR6ZnNGK2E2dW9wd0oxajlwSC9rL2pVU0hvYTZ1cTU2UlRpL3hydjhYeFhWMU1IVSs3VDBmM3Z3cnE2a2NPL3dCMmxSOUQ4MTFkUkNmLzJRPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL0VpbnN0ZWluLmpwZ1xuICoqIG1vZHVsZSBpZCA9IDI5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsLzlqLzRBQVFTa1pKUmdBQkFRRUFTQUJJQUFELy9nQkpSbWxzWlNCemIzVnlZMlU2SUdoMGRIQnpPaTh2WTI5dGJXOXVjeTUzYVd0cGJXVmthV0V1YjNKbkwzZHBhMmt2Um1sc1pUcE1aVzl1YUdGeVpGOUZkV3hsY2k1cWNHZi80Z0ljU1VORFgxQlNUMFpKVEVVQUFRRUFBQUlNYkdOdGN3SVFBQUJ0Ym5SeVVrZENJRmhaV2lBSDNBQUJBQmtBQXdBcEFEbGhZM053UVZCUVRBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTl0WUFBUUFBQUFEVExXeGpiWE1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFwa1pYTmpBQUFBL0FBQUFGNWpjSEowQUFBQlhBQUFBQXQzZEhCMEFBQUJhQUFBQUJSaWEzQjBBQUFCZkFBQUFCUnlXRmxhQUFBQmtBQUFBQlJuV0ZsYUFBQUJwQUFBQUJSaVdGbGFBQUFCdUFBQUFCUnlWRkpEQUFBQnpBQUFBRUJuVkZKREFBQUJ6QUFBQUVCaVZGSkRBQUFCekFBQUFFQmtaWE5qQUFBQUFBQUFBQU5qTWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCMFpYaDBBQUFBQUVaQ0FBQllXVm9nQUFBQUFBQUE5dFlBQVFBQUFBRFRMVmhaV2lBQUFBQUFBQUFERmdBQUF6TUFBQUtrV0ZsYUlBQUFBQUFBQUcraUFBQTQ5UUFBQTVCWVdWb2dBQUFBQUFBQVlwa0FBTGVGQUFBWTJsaFpXaUFBQUFBQUFBQWtvQUFBRDRRQUFMYlBZM1Z5ZGdBQUFBQUFBQUFhQUFBQXl3SEpBMk1Ga2dockMvWVFQeFZSR3pRaDhTbVFNaGc3a2tZRlVYZGQ3V3R3ZWdXSnNacDhyR20vZmRQRDZURC8vLy9iQUVNQUJnUUZCZ1VFQmdZRkJnY0hCZ2dLRUFvS0NRa0tGQTRQREJBWEZCZ1lGeFFXRmhvZEpSOGFHeU1jRmhZZ0xDQWpKaWNwS2lrWkh5MHdMU2d3SlNncEtQL2JBRU1CQndjSENnZ0tFd29LRXlnYUZob29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS1AvQUFCRUlBUjhBM0FNQklnQUNFUUVERVFIL3hBQWNBQUFCQlFFQkFRQUFBQUFBQUFBQUFBQUdBUU1FQlFjQ0FBai94QUJNRUFBQkF3SUVBd1VGQmdNR0FnWUxBQUFCQWdNUkFBUUZFaUV4QmtGUkV5SmhjWUVIRkRLUm9TTkNVckhCMFNUaDhCVVdNelJpOFhLQ1ExUnprOFRUSlVSVFk1U2lvNlN5czhQL3hBQWFBUUFDQXdFQkFBQUFBQUFBQUFBQUFBQUNBd0FCQkFVRy84UUFKUkVBQWdJQ0F3QUNBZ01CQVFBQUFBQUFBQUVDRVFNaEJCSXhJa0VUVVNNeVlRVlMvOW9BREFNQkFBSVJBeEVBUHdENTR4TXQrOEt5TmhLU1NmVCt0NmdxaWRCOHFrNGhQYnFDdVdsUkkxazBsQm5oRTZqZWxiV1VLU3R0U2tMR29LU1FmblhKK0lVbmxWbFdLb2c2eDQxNEFURVVnRW45YTkwcVVXZHlJNUUwZ2puU2VBNVY0ZERVb2gwRlNJcndVWkpyam5GZEhwVUpZcEovbzE1SzQxL1N1RDQ3eFM5ZVlxVVMyZEZSSTVWMEZ5UDNGTkNOTmhYUWd4Q2hPNEFxVVN4VktNVHRYaW84K2RjS01DU2ZEV2x5a0dJZzFLSnNYT2ZDYTc3WlU3SkgvS0tiTVRxVDUwa2dRUjlhbEZXUGg1WFBLUno3Z3B6dGlCR2hUMHFPUkkwRmVqclVwRjJ4NHVBZ1FsSUk1Z1FhVE1UdjlhYjlLOXZ2VlVTMmRsWkIwMXIzYkVwZ0pRQi93aXVCRWVQV2tCQUVFYTFLSlk4cTRkVUNCQVNCSGRTQlhIYXFqVlJqa0lyalFHWlNUMHJ4a2t5UlBPcFJMWjRMSUlxM3d1NGFSYkVPMktMaFdiUlp6YmRONnBsQ0R5OUtzY1B1aXl3VWdyQXpUM1RwVUpZdUlvaTRjMEFHWWlCVUdOZldyTEVKVmNPR1pCVWRhZ3FFVEkwbXFSR01FYWpxZVZJUnBIV25DTnBFVndSQko1MFJSeVFLWFdhOEppdmE1djUxQ0h1bkt2R0JwcFN4WFBPb1E2SDBwZXNhZU5Ja0dZQWtuYWk3Z25oK3d4dkVuTEc5VStsOHQ1MEtRNWxBMDZScnNlbTRxMHJLYlNWZ2dkNmZ0TFp5NmVEVElsUjE4QU9wb292dUNMeTF4KzVzbE9vOTJhVUllT2hVa2lSQ2V2THBJcVhpTmszaHRvR0xOQVMxQXpLbVZPSHFUVk10YkhmWnJoMWc3eFdpM3VMWnE5TFRDM1dtM2w1VXZQQ0FoSjVBYjd6NDFxMTJjR3h0OVdGNHpoU0VKUWhDdXhXeUczR2xEY3AwMVRQekhLc2U0WVN0akdMWjhFNWlvaElCMU02VDVDdDlZWVk0Z3MyeGRFQzZhMVM0UGpiVjFCNWcxRnZSSkt0bVpjVGV6M0ViRzBLc0hidDhRdzR5VXVXOXMybTViQk13U0JKSGtmQ0lvR2Rid3E1VmRzWW93TFcrUjNtM0xJSlpCVitGYlI3bzU2cEFQaFcvbCs4d0paYnVra0puUnhHcVZIcjRWVzhVWVRoZkZsaTZ0UFpzNHEwUHM3b0NRZjhBU3ZxRFYxK2dVLzJZSi9aTm9ZaCs1QlBWQ0ZSNnlKK1FwVllOYUpRa291N2h5ZC80ZEtTUC9xR3BsNWh3UmMzRnUrMFdMdTNVUTRsR3dQV09oR3RWUlU2MHNONTh4TzBhazBOak9wTnh6aGUvd25EclRFVEQrRzNTUXBENkI4TXlJV05jcGtFYmtlUEtxRTd4c2FPY0J4dTZ0Y0t1OEp2UUg3RjVDajJaM1JtMEpISTlZUE9nKzl0RjJ4UXNkOWhVaERnMk1IWTlENEdyOUJxaUxQU2s5ZVZLQkJNN1Vta0NvV2U4cTlKNWhKOUs4TmE5QUFxRVBBK0EycjBpRDNZL1N2YVY0ODZvaHp6bllWTnMybkhHWlpMb0FKQnl0WmhQbjVSVUk3MU50QS8yWDJDOHFaMTA1ODZzaE12a3FiZlVsU1lJSm1ETlF5Tk5kNXFmaXlpNWlGeXRSNzNhSzV6enFGRzM3VUNlaTJ0alMwaU5wOUthVW1CcnZVc3AxNWIwMnBFbnlvaWlLVW5VaWtqWGFuMUk3eCt0TnFUc1BwRldpaHNmclN4clBuWGhwSU5LZE5RS2hDMXMyTGUzdEdibHg0RzZVNUNHY3VrZFZIa2FsWU5qRHVCNDh6Zk5KbnM4eVZEL0FFcUJCK1ZWdDR3NHdrV3JuZFVoS1ZLSFNkZjFwdGpOY0dVa3FYOE9VRFVua2FOdWdmVGIzN2UzeGF5YXYyRkJOeVd3UTRDVkIxSkVwa0hmYzY2YzZITGdNT0gzZS9BUXBXcUZBOTFYa2V2Z2FYZ3hHTVlkaDZiUm9zbHM2NVhHVk9LUlBJUXBPV1BHYXRyN0Qzc1JEZHRkTHpBS0tnaktrcUU5TW9IMUpxNU9MOEJncEwxNkpQQi9CN3ZhS3VseTIwc3dra1NvcG5UVGxPbEhkbFpQNEpjcExzRnB5STBranpxbzRSdHNjd3A1dHkwV2wvRFdoQnRMMXdsVUQ4RGtkMCtCa1Vmb1V6akNVZGsyNjFjcWsrNVhLQ2gxVWJsSVBkV254U1NLRlJRVGJIQmF0WDdLMm5VcFdoU2ZpalFlQnJNdUx1RCtJc1BiZS9zQktMaTNNcTdJS0NWQTlCT2grbEdiejE1WU9ydG1VcmJRQ1R0M3ZueXFOY1l2ZUlUTFdkMXprcFNpZnB6cTIwL1NsYThQbXU0R0lXV1BQbkYyTGhxK2RCS2t2cHlxVWR2S1BLdXJlMURDWlVTcDFVRlNoK1FyWXZhYmFweFQyY1gxNjZBN2UyWlMrQ1JxazVnREhRUVRXUTJUajJJcFFMZElWbCtMWFUrbEprdXV4MFpObmJUSksxd3NqVHBYVDFrZ3NLUTRncWFXUm1STUVrQXdwSkd5aEoxMk94a1U4aHRVNVZTbUkzRVU2NGxTa0U1U1kwMUZTeU5PZ1R4YkRsV0RxY2l3N2J1QWx0MkltTjBrY2xEbVBYYW9ITDlLTWJxM0wxdGNzclVRZ3RMY2ovV2hKS1QrbmxOQi9JRVJGR25ZTFZDVjZrSTFwZkxhb1E5WG84YTlIU1BPazI2VkNoSkdZVHI1MUxRVzB0TmxUeWtsUW5LVUV4ckhMeXFHUnJUcmlWS1MzcWRFeHI1bW9XWE9LWmZmYmdvK0h0Rng0aVRVUUNwbUtrbS91bFFSbWNVcUR5MXFJQkNlbTFBdkFuNklOZHV0TEdtc3pYUmdhYlRTSGZ4bU5EVm9GamJpQVFJaW1DZ3lacWNFeUNhNVVnRTdhVlpSWHJUQmcrbGNSMTU2Vk9kYUdXVWtWRlVnZ3hyMHF5RHJEN3o3d0MxRjF4V2dLdC9uUlR3N2JwYmN6c3BCV2tkKzRWb2xJNkQ5NkhzT2FUbnpMSnlEZktkVitGSEhEdGdyRTFwN1JJUmJOZjhBUnArRWVIaWRmU2hsT2dvd0NIRDhRTExRUmIyeTNtTk11NHplZzFpcm15dk1iU0Q3cGdqYUU5UTJxVDZreWF2OER3OWxsdE1JQTZuZWl1MVpUa0EweTcwbDVHTmpqUUFuRytLV0draFZpVVpWYVJiS1VQb2FsVzNIRndvZGppdGhiUDhBZUNnMnA1YkJrY3hJMFBqTmFUYTJTVmdrRFRtUlhkNWdWbGVXNmtYTnUwNmc3aFltcVdTZjB5M2lqOWxEdy9pK0hZeDlqYUt1Y0x1VXBVcjNaNXdQb2VFYjVwSjBKNUdmQ2xlc1RjVzd6d1o3SjF0d3RQTlpncklyY1FSdWtqVko1aWVZTkQyTDhKUFlBOE1Vd0FyV2hrNTEyaE1uU2U4Z25jeE9oM0duU2lEaDdpSzF4SzBSY1d5MkE2NG1Gb2MrRlkvQ29hU0pueFNhZGp5ZHRTOUU1TWZYYThLZG0zUzdkTzJGd2hKdEwxb3RFTDFFeUNKOHlBUFdnMzJqK3lwVm80ckZ1RUd5MFc0VXExYU9xZE4wZVBoV200alpkcG5ldEJtYlI5b3BCMGNaMSs4TjRuWld4ODZ2RVhDZ0FyS2t1ZGVkT1VVOU1VNU5PejVyd0M1dDhaVWJXL2FTeGlhQi93QUljSDRnUHpGUjdHMVVHNzBQZy93NjhwSFdkYTBYMm04RzIrSk1PWXBoYUUybUtXNTdSWmEwemY2Z09SbmZyV2U0TmpUTisrNWFZa2syK0lySTdRQTVVT3FBaWR0NEZacHdjSG8wUmwyUTFhdUN5eEN4dlhFeWkzZlE4c1JNcEI3dzEzRVZaY1ZjRTJlSnFmZHdkcEZwaUNKVUcwaksxY3AzR24zRkVSSEttOFh0RkphSVFnRkdzamMrSXJSN3V4elhUU2hyT1ZNandTQUQ4aFJRM3NHZWo1bnVHSGJkNXhtNGJXMDhnNVZ0ckVLU2FiMUIwcmFlSitITGJGeUc3eGsrOGdGTGQwMW9vZWY0aDRHc3E0aHdWL0JuMEJiaUhyZDRFdFBJMENvMElJNUVkS1lBbVZSMTg2VHBYcVRuVUpZbFNGU1VOa3B6ZDBSb2RLam5lblZLVUVOZ2QyRS9xYWhFWG1NSktjUmV6SE1Tb24xcUZxb2d6NTAvaVJQdjF4bTNEcXdPZk9vNkRsMjNwYThHUDBjT3Bub2FWR25lVUpGSkJLdGRFalduVXBrUU9XdXAycXloQWxTdHpBRmVBSUVjcWVTTXVtNXBRbktkZktyVEtHQ2tCT3hBalh3cU8ra0RZUk9ncWU0azVUcm9haXFqdFVFZ1FBVlJ5Ty84cXV5cUZZbHR4Q0c1N1E4L3dEcjUxcXZCTENXc05aME1LT29uUVZsT0hkNTU5eFJKaE8vald2Y0tJV213WVFVd3FBYXpaWHMwUVh4TkJzRkFJVEd3K3RXOXE0QVRyUTYycFZ2YkZ3eENSSjlLdE1KVXE0T2N6SUhJVXB1eGtZMEZkaTdsVEE1K05XS0ZKalNJTy84QXRWTmg2b0crdStsVHdveG1NNmN3S09EcEVhc1M3U0RKamY4QU9zUzQvdEhlSDhXL3RPMWJ6WWRjci9pR1JwQ3o5NEg3cWoxNml0bnVuSVR6Z2IwRzhaMlNjUXdlNXQxQW5PbjY5YUtTdFdWR1NUMzREdkRIR0RhbDJscmlMNVhhT3FIdWw4UUFwdGZKSy9IbDQwZDNHTzJkcmVvWnZvdEhGckpCV1lhVkhOQzl0ZWgxRmZOOWsrcXhjdWJLNUJWYnVISzRrN0pJMldQRWFlbGFUWjQvYVlsd20vaE9LTFNNUmFhN0ZJVi8wbWtKV1BUZitkT3haYld4R2ZEMGxyd0xNUXhOaGJ6TDF1NjI2MjYwdEp5S0JoV2NrcE1jNEkrZFlqN1NNSFFtL0Z6YklBQkVrRHAvS3RCeHhGcHcxam9iZFNHY1BMVFNISEVwaExUaVV4bVVCeU9xU2ZLcVhpNWp0N0J0NWhZY2JLd3BLeEJDa0s1eU9XbTlITGIyS2pyd0FjSzRpdUxRQm0velhOc05Bb243UkhoUFAxb3d3dmp4RmtodHRiNjc2elNwT1ZKaExyWUIxMVB4Q09WQ2Q3aGFrUDhBd2ZGb29ScDUxVVBXb3p0QUpFcUpTUjRpbCtQUXoxRzNQNHhZWWt5WGNKdTdkNUx3aElXNEVFRW43eVRxUEtzNzlxYmR2YllkaGRxMHNLVzB0WGUyS2hHcCtldEJDcmZNNEVwYlNwZVlBUU5ablNwL0dXSUt2OGJlbHdPSlpKYkNrL0NTTnlQQW5XbXAyTGFvb052U3ZIYm5YanFERmNuZUtzbzkrdGR1QlJTM0FFQk9ranhOY0FTYTdJVkNlOEJwMThhb3RGdGlhaDc5Y0VjM0ZHUFdtRUNTU2R6VW5HQWtZaGNJYkgyYVhWaFBpTXgxcUsyRE93M3BhOEdQMGVKbE9VYUNkdXRPdEo1a2VNVndrWmlDbW4yMHAzR3cxbW9TaDFLRktwZnZRUG52VHJjZG1lcE90S2tBVEFCTWJURlN5VVIzZFFkQ0RGUUxvbHJQQjE3b0hQbFA1MWJ1Q1cxRXgzWWlxbDhCVDZpcUpCekFEYXJSVkV2QXJaeGJTMTZKVG0zTmFOaE9PMjF1cHBydEc1QUEwSTE1L3dCQ3Myd3BMOTBoTGR2M2xaaURPZ0E2azZhQ3JZTllLNGdzb3hLNGR1Z0pWa3R6aytmNjFteUszWnJ4MTFTYk5nWGk3ZDdaM2JkdkNuQXlvZ0o2MU1zc2FPSG9DMU5xVWs2d0JKMjZVRCt4MXQyNHhkL09GT1c2Q243UWpSSjEwTkdYSDdwd2hoTGpUSUtYMTVRUnBCTko4dHNjNCtSWDJXRnQ3UWJWdHhMYXV4bm1GS016KzlGT0Q4VVdXSkhzMnloRGcrN05ZZGhuRVRHR1hTTzBRSFhGclZsQXRBVzFFQkpPWmN5QkNrL01WcUZ2ZTJkNjRxMHViSldHNHEybk1XRmJMSDRtMWN4NEhVVmE3MWJRTFVMcUxzTHJsWlVreUI0K05WZDRKWVZHc2crbFA0WThYV0NoM2RPaFVlWS9lbXJ4Q2dsUlVFZ0hsVFl5WW1jVEF1TTdMM2JHbmlCM0ZxekQ5YVpzWGtYMXI3azZQNHUzNzFzN3pJR3VYMGphaXYyZ1dwZGZRNEJySkVnVUJOanNWQndrb1UzM3BuVUdnVDZqZXY1RlFaOFVZdU1YNFpXK3NEMzFZOTNXam1YQ1J0NEhlaEl2WW5ncjkzYjJTd3F3YlFGS1plVG1RU0l6S0EzU1NlbFQyN3BiYWplTnRJZGJjeWwxQjNiV05sQWROVHI0MUN4N0VVTzROZU9KMWRLY2t6cnZ2K1ZhNHk3R09VWERSS3N1SmNLeEZwSzhSL2dsQld1WXlrZ0Q3cEFtZkNQS2FwTVF1OEdUZEZkbmRxV2hKS2tEM2RZMWp4QTYwUEphVXF5S3hPeVZEOWFoaU52R21PS0ZLVExwdkUyYlc3WnVXQ3B4MXAwT29HU0VnamFTZGQvQ3FRU0VBRWt3SW1sMzJyM2pWbEhPMGJVbjFycWtOUWdnM0hPbFdCbFIzbzA2eHpOSU5DS1V3UW5UbCt0VVdpNnhNSjk3ZUkxbFoxbWRlZjUxSEc1OERGUFlrb205dUJtbFBhS2p5bW1BWjAxamZ6cFM4R1AwbE5JT1V6ck1iYlUrVWxSQWlkZGRkcWpvY09kQ1FERS9wVmczb2taWk0vU3FZU0ZiUVNJa21laGtWM2tsUkNTWjJNR3UwaUFJQWdiazArMGdaVEJtUEdLbGxVS0dBR1NOU0FJMU5VZUp0ZG00RmlJSWlpTHMrNEFtWWlPVk0zOWg3ell1SlpTU3RCempsUFdvcFVWUlY0RmhydC9aT3NNQXFXNGZobUFST3MwY1hkcmFjUDRFVXMyZG8xY0tBU0FrQXJjVjRuejhhRStIN3gzRGxEczRDaUNsVTdqV2kzaFcxWGoyT0IyNGh4TEVaVWRWY3ZsV1hMT1NrMGRMQmlVa24ralN2WnJncmVFWUdsSkFVNnZ2TFZ6VW82ay9rS3Z1TExOdSs0ZWRaS0cxT0VoVGFsQ2NxaHNhazI5b3F5dG0yeVNwUlNDUURWYmk5OFFVdExTVWlZMTUwTzE2WFhhV2dMd2xoeTFjeTMrR1owQllWS1dPMVFzaUlKMGs3RGZvT2xHVDl0YjQycExsMGg0dnpuUTZRV2xKUCttUUs3d2R0eHQzT1RtYm1RRFJLbHhPVWMwbWlqZFZZRTRwU3RJcTdERHZkbEdYbkhEckFVWWo2VjdFbEpEWkFNQ05kZDZtWFRxVzBoV20rMUQrSlhvSXlnbWF2WXVrQ1hFclNIMEhTZk9zMHh5MU51NHB0WUlTcFVpT2VrMXFWNG1VTGNPM0lVTDhRcHQ3NXhKdDBGZnVDQ0hDTk84cU9menBjNVVPd1IzWUlvdTBOdDlxd3VTQVpCR25pRDRWVjRxVzNzS1c1YkpXaEQ0ektRVE9UWFlIbnFQclVqRmxCaHAwNVFsVGlvZ0dkOUFLZzRobFp3OXRDcDBSQThTWXJWeFUyN1puNXpVZEk0dzFzWEdCSkJJK3lleVpmQlEzK2FSVkFwQlE0dEIzU29waWVsRWVBb1VNQ3ZuUjhQYUlBRWM1bVo5RFZWajZFdDQzZXBUOFBhWmhIaWtHdGpXck9jbnVpQ1pwTnRKcFJxRE5kZm5RaERlMjFKOUs3T3gxcmc4NmhEMWVVWWlCUHJYZ09acnNtQU54UFExVENqNldsK2hJZWRqa28vblRLQjNaMkZTY1NNWFRxUnNGSDg2aW8xVU9sTFhnYjlIbXdjdzExSmpTcmEwSUlBbmxJTlZZT29NZDRIbUtsMnJwQ3hyRWJlTkN5MFhEYUlQZDJIS05UcitkUG9RZ0o3L2RQV0tqSUpjNlFSVTVoQlFmaDAzMEg1VURDSDBNcElUazE1Q1JCSHJVOWkzaUZEV1FlNmYzcG0zYVdWcXltQWRaMzVWWU1OeVlJZ2lkcUNUSWdWNG5zeFozU0hXUkNIUWR2eERlbXNGeFIvRFN0NjNlN054U2hHdSsxWHZFOXVGWVN0eU8rMHZOTWNqdUtFN05uTmROcUtPNEZBbmxvS0N1eTJiY1UzR09qYXNQNGt4ekU3ZnQ4SXQxdUJNU2wxSlNUNGFuWDBxeXRVNHpqeTMwWDltTFZDR2prY1BkbGZJZk1WQTRmeE1XZHc1bU9WdHpLWkhMU2laZkVGc3Z1ZHBIbVRyNTBLaGEyeTVaVkZ1b25QQ3VKQzd0dXlmQVJkcy9adW9PNElOWGEzVW8wT25oUVZlTzJ6bHd1K3NuQTNmTkRNb0pnZHFrY2lQeU5Xcjk5MnpUYXdTY3drSG1ha0xXaVNsR1h5Uk52M3prN3VvMzlhb0ZCVGlwMXkxWnJVVk5HZG8yamVvUkl6a2lCNFV6cUtjdjBWbDhVaHNoUnlwa0pCT21wSUg2MVE4YVhGcmhlR09neENnRXBRQm9WUnVlcHFYeFNsMTlwcTF0eWUwY1ZJOU5mMHJKdUo3Mi91OFNMTjQ2VkZneGxKMEI2MEhUdk92b05UVU1kL1pHZGZMcmlYcmtETVREYllQMXFIaUR5M015bDZaUnQ1MDAwRkc5UkprekdncVd1M0Q2NGVXT3pCZ050Q1lIajByb1k0cEtrY3pKSnlkc011RjhKVC9kZEFkbjdSMHFLZW9BQUg1cVArMUFPT0JTY1p2RXJWbktITXNqbUJvUHBGYXhoRi9aS3dvdDI5eXcwcUNsS2JoUVJrMGc4elBtUGxXVTR4bFZpbHdwQ2dwQldTa2ptS2ZQU3BDSVhic2hKMDNyM0k3MTBJQTZUWFBYOXFTeHh6OWE1TVR2WFhMeHBPUjZkS29naDEyTmRrd0FJNWRhYkExcDRuUVpZR2xSaDQ5c3NyNXhLN3E0V2tDRk9LSWpwT2xNNkFURk8zSklmZEJHeWxiZWRNZ2tIV1NRZGFXRS9SOXM1UjRuZUtmUU5nUnowcU0yb0VwSmsrSHJVbEcrbXZYeG9TMFhkcEVJSmlScEE1MWFzR0ZKMUdnMEhoTlUySHdqS05mSWIxYnNwSkFKSGxJMjlLWElNdFd3a0FFcFRKK1ZUbXlCRWZFQnJIT3E5cVFtTWtrUkEvT3BXVXBJME8zTDYwcGtSM2NvUmNNS2FjQUNIVWxFSHg1MER0UE9XUzRXVkpXeWNxaEEvV2pncXlvVE1HT1g3MFA4UTJnRDZMb3A3cGhEZ0EzNkg5S2lZM0hLZzM0Y3hIQjNiTzBEeTNoMnFRQzRzSFJSNUVnMFRwd3ZERk41Y3lDMmRpSm41eldZNEZoMXdsaHkzWkNYV0ZLMENpUVVuemcwZFdOcGNzc2dQclFTUDljelFKV3pUS2V0SW4zV0FZYWkzY2VzbSt6dUVvN3FnbzYrQjFxTWhaU0xaSDRSbUlwN3RpRUZQWGVUdFVWYmpiYmhKVkJJK1ZQakdqSk9iWllDNEpXclRTbUgza3BsUUlBMTFxQ2JtZEVhODRtdTJyTnk3K05SUzNNR1B2VVRWQWQ5amRtbFQ3N3Q0UkNVakkyU04rcHJHZUswazQ3ZHJTUUZCVUdERmJ0aUFETmlHMmhsQUVKSFNzWTRpc1VYVFdJWGpDZ0hXVkxVdFA0a0E3am9SUXcxSUtUdUxCYXhTRlhpYzNOSi9LaVBER0VxSlF5em5DZThvRG1OdlRwNjBMcGRMTGdVblZRbUovcldwS01Wdlc3WjlwcDR0b2ZUa1hsRUhMekE2VC9LdDBXa1lwSnZ3UGJiRDdkOWJaZHRqYXNMYzdOTG5iSkFKOHp5MzJyUHNhVWhlSzNoWlFFTmgwcFFnYTVRTkJURGp6cmphR25YbHJiUnFoSzFGUVQ1QTdVM3lOWEtTWlVZdGVpUVpQV3VSRWJiMTQ2Y3Q2OEprVUFhRWl1YTdWc0s0UG5WRUZTQVNQR3BuWUxRbFBhSXlraWU5ejFJcUdEQnFhSmNiUm55SEtJQktRVEVrNyt0REx3YmhTY3RraS9KOTh1U1pudFZILzVqVENOeHBYYjVsMWNmalBPYTRURUVuMG9TUDBWSmhVRXlLa051WllDZmlPNXFOT1dQMHJvTDFFUlVaRVhsbXRPWVNxSW5sVjVablAzazhqdnpvYXNIUkFnRTBTV0svaEpJMC9xS1hJTk11R3RXOUJ2eU5TRUs3b25ValNhYlpuS0JJbUprMCtsWUh4SFNTT3UxSmFMUjBrQWlUcE5RY1NRMExWOVQ0UFpCQkN0UVBXYWtyY1NmaEFram5wUWh4dGlBYXRoYXRyQ2xGV1pVSytId29zZVB2S2lwejZxeC9oemlSV0dKVWhhVk9Na3lDbU82ZVlOSFZweFBaUFc2Vjl1U1NOVTh4V0lZZmRsdTVSbVhsQk1abzA5UjBva1E3Mkt3bHl6Ylc0b1prcWJYQWNIaFRaWSt2aEZQdnMwdiszMm5pUXd1VG9DWmlucmNtNUlVZGZIbFFYZ1dMMmh1T3p1TE1NY3BWcnIrVmFOWU1JZllRdTJVZ29qUVQvV2xCMm9Kd2JPclZpU0N2YnBQNTFaV2d6T1FQaFR5Tk1Nc2thS2tENVZPUVVNTktXNGNxVWlUT3dxcnRXRDFyUlhjUk9oakQzbHFWQkNUcjBGQVdFWVFwL0I4WGRkUVQyalNyZHNIY3FXWmp6MCtkRXVNbTR4ZTd0MHBRVVc2bEZTRVJxdVB2S1BJRGxWeTdhcFJnK0QyMXVnSlFwMHVLS2RjMEVpUjFHMnZQV2l4UnQyeThzdXFwSHpiY3RMdDdsMWh3ZmFOTExhdk5KSVAxRk5FK1pvcDlwakxEUEhPS290aWtKS2tLVkg0eWdGWDEvT2hWV3BJbXRWR1VXZjMwcjIwN1VnM01nMHBnVDRWWkJ0V25LdmN4WFIyMnBDUENxTEVNY3pyWEozRWZXdWlEL3RTS0ErdFFoejk2clMzU095VE1iRGZ5RlZjQ2ZXclcxQVUwTW8wQVNQWEtLQ2ZnN0IvWWJjRU9xQm5Rbld1ZE5QUGFuTGtaWFhBZERtTk1xT29qblFndlRGSm5mNVJTSk5MRWpTa0hqNjYxWkN4dzV3aHdUOEpFUkZFK0dySlNOWU92TG5RamFuS29IVFR4cStzN3RGdTBwYmtJVDFWejhvb0pKc0pPbHNLMmxoTGFFaFV6eUc1cXB4UEhiV3pLZzg4blA4QWdUcXIxNmV0REdNWS9kT29MZG9TeXlvNnIxeksvYWgwSWt5WkpKMUo1MGNjRlA1QzNsdGZFSXNUNHJ1SHdVV3FPeVQrSTdtcUM1dUhMaFdkMVJLanoxL1dwdHBaczNRbEJLU04wenFLZGR3Z2hKTFpKamxXNkhHbTQzRmFNY3VSQlNxVDJWRUtBMUVwTlgrRFlxR0cwMnQrZ1BXcXhJekE5MDlRUnFDT284aklxbWNaVTNJQWtjd2E4MCtVSUtkWUE3cDZUU25CTDR5R3FiZTRtbzRUYTRMY0JDSDcrNHNVcUhjZGVRbTVZVi96b3lsSTlEUlRobUdQNFpjdXNXN3JieGJJTTI3bVpDZ1JJVUFkZFFSV000QzlmTU9YQnNTaDl0cHBUejdDanVnZkVvRHFOekZhL3dBSzR0YVlyZ3pZdzExYW4ybTBvdUdsQ0ZOSFVEekJBR29yTGx3MnJScXg1cTFJS08zVjJZVzVLWS9FSXFMWnVLeHpFMHNwemU2QmVSS1lndXFISVRVaXp0VUJzdUl6QmZOSjFCOEQxR3RVMXZnSDlyUExiUXAxVnUwdklodU5VQTh5T3BJMzlCU3Z4dTB2b05aRjFiK3cvc3VFWGIxeDI2eCsxY3RNS1lqS3lvWlZQSkJudkg4Sk95UjZrN1U3aWVGdllnNmxTbkJic3BTUXBMYVIzRWJrQThnQkdzY3BvRGJ3amlYZ3pDci9BQnJENzgzTmcwQTY5aHJoenNPSUJnN2FwVUpCMDFxS3YycVlqeEp3amkrSHQ0QlpXQWVhVGJPNGcxZUs3Z2NNRVpWRGZMbTJPbTlhb3BHYVgrR1NZamRveHZHYnQ1UVBaM2o2M1VEWWdmZEkvd0NVQ3F5NncxMXRjTi9hb0czV3B5TElxVm50WlFwdFNuRUlXQ0ZCS1FDREhpSm9oU3czZDJUTi9hZ2RtdE9ZaVBoVU54ODYyNE1jTWtYR1hwaTVHV1dLU2xIeGdBUVIxTmVPbFcySld6VGQyNjJSbElVWUk4NnJIVzFJVnlVT1JHMVpwUmNYUnFqTlNHOVJ5M3J3NjE2SUlyMGFkS1d4Z2hFZEtUV3VsQ0JYSkhJYzZvZ2huZU5hdGNPR1pnbU9jZlFWVnhySnE0d2xKVmJFNi9GK2dvTWpwRHNDdVl6ZEt6UHVxTzZscU92blVjK0VWS3ZobHVua2JaVmxQeU1iMUgyNTFFQy9Ua3p5cHhLU2RCcWE0bkpHYWRkaHpOU0dHVnZLbFl5b0owUVAxcDJIQkxLNmlKeTVvNDFzYlhjSnR5RXBBVzdIL0tQM3BHWDFGeEs3a2x3VHFlbFcvdUF1a2hvSU9jZkNwSTFxdXZiSjYxdU96ZDBWR2g1RWVGYTN4bmdmYjB5TGtSemZFdEc3WkR3VElDMEVTT2tWVllsaGp0b3BLa2dxWlY4SlBLcGVDM2Z1OXdsRHF5R0Y2SzV3ZVJvd1Rob3ZjN1QwaGxTY3NqNkVWcWZUa1EvVFJqYzU4YkorMHpPV3M3SzB1Sk1GT3hxL3cxNFhTQXBJR2RKZ29BNTB1SjRJL1pYSFpPZ2xDdmdjR3loVGRneTVoOTEycVFUQjd5U1kwclB4NXl4UzZ2dzA1NHh5dzdMMGw0cmhZdUVGeEtDbFcyYnI1ME1YTm10dFpuZjZWcVY0dzJ3eFp2RWhUVndGTnVFSFROOTAvblZCakdGU3NxUk9RekVqNlZweTQ0NUZabHc1NVkzVEEvRGJoZHRmdFB0S1VsYUZTY3U4RVFmcE5hYjdIV1ZONGJpOStFTnFhUTYweTZWSXpCS1lKQjhCUE9zMnY3QnhwU1ZKQThJNjFaOEpjWVl0d3c2OHJEM0VLWWYwdUxkMUFVbDNscnptSkZjMmNYRk9MT25DU25Va2ZScWJac1c0dWJkYWtJMmNRb3pCNUtCM2lyUGh5ellheEpiaFN2M1pLRXBjZVFDUUZBZ3pNUkEvU2hyMlRZMnhqOXM2bFFJTGFBcHhPaEJiSnlranB2RUhZNjlLT0xxemZzSHM3RHF1MGJHZHBZMER6WjJCNVR5STJrZU5KUzFZMnlyOXBUaldIOE40KzdhT2xQYjJpbW5HMG1ZV1NFaFEvd0JLcE92bk5ZRFlQMm45Mk1Vd3h6dUxTUThsVGhoQldrZ0JJOFNKK1ZiZHh3d01kNGZ2RzdBaHQ0TW9jU2hSQVNwWGFBbEk5RW1QSFN2bS9HRzV2bjF3VWhheXFQTTBWL2FJa1hOKzA1ZU1vdWJkOVVyYlNsL3N5VE84bFFNVDVBbjZWWjhHcGI5emR0NFVHczYrNytEN3c4K3ZuVlZ3ZGVEdFYyQ3pvNm1VQUpHNG1CUHFhOWU1c012MUtUQ1FwS2tFK1kwUHpqNTF1d0tQVHV2VG5jbVVuUDhBR3lrWG11cnBUeXQxcUpJbVkxMnF5dzdEQmMyRG1aS2M1V29hN3dPZGMydHVJYldFa2hhWlQ0aWpDd3RBMWh0dVVKUzRsU1FRb2RacXNGTnRzUGt0eGlrak5NU3c5eTBjZ2lSeXF1OHFNK0xraE4xYmpROXlZODZvUGNoY0l6SklTY3N6TzVtS1JreFhOeGdQeFp2Z3BUS3M2ZzB2OVJUajdEakJJY1RIaUthcERpNHVtYUUwMWFGalViVlo0V1NMZFhlKzkxOEJWV2F0TUxVRTJ4a1QzalNzbmcvQTZtTGlRQ2J5NEdzQjFZK1JxQ3B4UVVFSkdaWElWSXhKWDhVK3BRajdSUklqYlUwbUZXcW5sNXpwTzU1QVU3RGllUjBqUG15S0NiWTVhVzV6Skt4bVdvNmswUVlmWkpkTVFaalFSdWZPb2JqR1JLY2lTTXVwNVZMd2wvdG53MkFRdEl6YXlKanArMWRySEJZMTFSeHNzM1A1QkxZV0NXbXdsS1FTUnpwTVV3eHU5c1ZzcUNRczZvV1Rzb0RUOUJTV044RWxLYnBNU1lDZ05QWHBWeG1TcHZNQUlWcVBFVXVkL1ltTHJhTXJldFhMZDFUVHlNcmlEQ2s3d2FMdURNUVU2d3F5ZE1yYUdaa25tam1QUXg2SHdwM2liRGM0RjJrSmtES3FFYStCTlVtRk9JdExsbFp5OTB6cnBGWTEvSFBSMHBWbngvNkc3MXFMMXhGdXJiS1ZnY3BvV3hwbnNseUVrS084L2xSaGF3c0I1dlZMaVlCSEljLzJxczRsczB1Tjl1WVNoY0FxalJLdVJKNUErUE90R1JKN1JrNDhuRjlXUmJGNFgvQ2R4YmsvYldEZ1VERzZER3Z5bXBqVGFMbXhTN3Jubkl2emdSOUtIc0RkTE4yODNwbGNTVU9KL0VnN2owcTJ3VzQ5M3ZITEo0a0lXcklmQThqOVJyVE1NdThLKzBCeU1mU2RyeGtXOHcxR3BVdEtFa3dDb1VJWTdoeUdGQnkzV0NTZGNvZ2VsYWU3YjVZUzRBSk9tazFCdk1PYXVtRk51SkVIdzIxb2NrVk9OTXJEbWVPVmd6N0srTC83b2NVTVhiNFY3bXM5bmNKR2d5cTBWUFVSQjgwcE5mVjF1OG0rdE94WlN6ZGE5c3hLaWxLa2thaEt1VWlDSytNc2N3dFZsZHJRcE1KK2xhejdIT0w4U2F3VlZpcTRhVzVoeENXZTJSbWxvZzVRSUlNSjczMHJtdE9McG5aaTFOV2pRdUoybVA3SXU4UndwcTVKdFB0TDJ6QkJjQ0I5NUkyTUhmcHFlVmZPdDhDN2NQTENRbExpMUxDUWN3VE92NjE5STJ1TnVYV0ttN2NhUmIzYnV1Wm9RMjRxSUl5a25VanhnNjFrdnRTNGJ0Y0h2a1grRXBMVmhmT0hQYkJQZHRuWW1BZndLMUlHNGdqb2FGVS9BOW96K3lVcGkrWmVTcFdacFlYcG9TT2V2bFJoeGhaaHpDM0xsb1IzQTRueEhUNVU1d0dwa3F1V0g3TkZ3anN5NHBTZ05BUEh4NWVOWFdPQU9XZDBGd0FwS3pBMlFJTUpIbHBXcmovYStqRnk2dUwrd0k0VFVtOXN1ekpoVFNpVXhyRS8wSzBBMnFVTnBiQ1V3bElBSUZaandNNHByR0MxQXlLQVdSTWJmMXRXc1lrVTJ5VnJST1Vvem85Uis5Rmg4c0RsTzVLS002NDFaS3I1SzBrcVNFQkpNVEJIKzlNWUxaNXJJa2lWWjRtRHJBMUg1VjFqMXlROCtsSkMwa3hQaEcvblYvZ1RUVEdDMnhKekxXa3VRTmRUL1Fvc0QvazdGY2g5Y1NpRDExWmpzMUZlcWRpQ05UUTNpRmdwZ2RvMkZka1RCbmxXbHUyTExwVTJWUFNOeUdaSHpOVjY4S3c0cFcyTDZRcnVsQzBSQk8zS3RlYkZETEduNlpPUHlKWTJacU9rU0t0Y09WbHQrc21hallwWk9XTjA0MnBKU0VLS1R6ZzFNd3pzUGRFNXM0WEp6ZEpuU1BTSzRPZE9DcG5vK00xTjJpRmVpYjUxcFJFSVdyTVowTUhyVjNnNlcxcFYyYWtyV2tTVWpVK0dsVStJSkNiKzh5eGw3ZHlDRE9tWTdWT3dOU20yWlFRRktWcitsYThHUjQzb3hac2Y1RnNzM0NyY3AxbmJuVUc1N1cxdVV1dEhJc1FzUnlxNkJQdkRRTTVwNzJrLzF0VFdNV3dMU0NBbjhKVU52WHBYUVdkVFgrbUI0WEIvdEZuWktieEcxUzYwQ0ZINGtqa2Fmd2krY3NycFZsYy9hTVRPY0FuSjQrVkMzRFYwNWI0c3l5bFVOdnJ5RUhhZVZYZVA0dTliMnlWMlJMU0FwQ2tMMlU0U3I0ajRST256bzdVbzdFU3h0VHBCc3BsRGlEc3BDdWczQm9GeDNDbFdsNmxBbnMxVEN6cEkvd0J0Nk5jRnVFUDI5czdHVnE0UklnNklVTkNQNjYxSXhTMEx0czQzbFNwUUVvbjhRMi9iMXJMa2hlbU93NUhCMlUvRGJxV1FoaFJIWnFNVE9rMWZYTm0wOWJ1TXZvQmFjN3FoNGRLRExTNFJxVlowa3ozUUpQOEF2cFJsZzkrbS90b2NURHFVZytZNngrZFNFdm9QTERmWkdiM0ZtOWhPS1hGb3NxS21TU2xVZkdqa2ZVZnJVZTd2UXhpNEtkTTZRdEpubldoOFQ0VUw2Mk4yd2tHNnRVU2svaVRyS2YycktNV1NvTFM0blpHZzVSMC9PZ1UzZ2xhOEdwTFBDbjZhdmJPRytzcllzOTl4NEFEV3BIdTdER2pxdTFKNUpFQ3FEMmRYcWIxcTNhbUZBcVNRRHNTQ0IrdEY5cUdqWkUzSU1NNm1EdjRHdFVuYjBjOVJyMEMrTkxCdTRzWEhGTmRtcEtNN1o2aWhUZ080OXk0aWgxd28reVhNSFJVQ1FQV3RBeGNpL3RIM25Va3JuYndqYjByTitIck4rNTRxdExacEJXUTdLc3hnSlNKS2lUeUFHczFqNU1mR2RIaHp0Tkd2RzZObGlWdGJOdkhJNjRpZGRSS2hxRHlrZlEwQWNTOFgzZU4yS2JGeHBsbTNiZDdSV1U1MXVLRWdTb2dRQUNkQjFxVHhyaXlVRmhPR1hVb1dsV2RhVS9Fa2QwQks5d21CMEU3N1VJMnJiU24wRzY3Vk51b0ZJVTJQdlFjb0I4U0t5eFJ0Yk5RNFl0T3h3dGd1SUFDa0JjcVNFclNvaWNoamNEZWQ2YTRqbHZCN3hham03c21UL3FTS3M4SmFXelpXemJxZ1hBMmhDaW5xQnI5YXJPTjBxYndaeHBNSE80bEpuem44d0szVjBWSExjdnlUdG1aNGFvc1l3eTZrN0tNeFdvM1Y4ZzRGYnFuTmxPUStLZDZ6SzBSLzZRVCsvT2lHMHhJckNjUHVGSEpsZ1NyZm1EOUtHT29PaHMxZVZGYmVzbHk4VTJrRlNTb0pBRkg0c0RaaGxnaUVvUUVnY3RxcE9HV0E1aTlvdEtRRm9kektISVpkVCtYeU5HK0l0ZHJiajhTVEFJcThQeDJCeXZra2lodXRBaGNBRWtJVjR6c2ZuUWJpcTEzTnhkb1FvRUpWbEd1aGcveW9ueGQwTTRjK3VaS0ZKNStJb1Z3SWU5NXlzOTF4MVdrNmdWdlRyWmhTOVk3eEZhSmVTaFNrQ0Z0SkprYzh0RE51MTJLVkpXRDhXbW5LdEp4RzFiY2JaS2xCQ0FnU3BXZ0FHbFo5ZkxsMUpLd05Eb0JvTlRYTDVzVktLYTlPdi96Y2pqS240VitJd3E1ZlVnUWhUaWlrQXpwbXF4dzA5bmFnaUFjMjlRYjV2N1pSZ0R2cUVUc1FkdnJVMjBURExjZ2c1K1c4ZjcwdExZMXZSYjJ5aXBhWEZsSVJKSGpHL3dDdFcyTXNnWU9VRWxTZ0FWYS9lSWtpb0xqRU5ObzU3cW5sVTI2ZFc5Z3BXc2Q1MTVhd0J5QVNFMHp3WDlnRXB3dFhFNWlGQlFVbFhsVnp4cmNPS2ZZS05MZTRWN3hsNUJmM284enI1MVNZZ2doM01RUnlqcFQ5eTRwL0JHV2lWS1N4OElPdVhXZEt0WlgxY1dVOFM3S1NERGdmRkc4aXJDNlY5ZzZxVW4vMmErby9XdEZ0VktlYkxUdWo3T2l2RWNpT29yQnNNdVZNUElXT1ptdGd3UytPSTRVeS9ici9BSSswUU13NXJSMThlbnJXbU1sT1BZeFpZZmpsL2hFeC9DQWk3OThiMGFXZnRobG52SFpWTjIvYVdxMEtibnVtUWR4Ukg3dzNjMitaQWlVd3B0UW56SGlLcEhXK3dkTFpuc2pxZzlQTWVHb3BiVmJReUUrMmdtdHJ0QzJVUElNcFVKSTZIbURRQnh4ZzZXZ3Q1aElES3BJQSs1NEdpTEQ3Z1c5d1Vsd0ZoVzhjajFxd3hTMlJkV2JqUVBkV2tpU05OcUpydEVGUy9IS3pKK0NjUk9INHZCVkEzajFIOWZPdFh4YVRickxhME50M0pDazVqQUI1cFByV0pQSmV3L0VFcnlaWFdYTlVucURxRDlhMSt5ZmJ4UGhkOVRKVXR0YlNWbzhDRHI2aldwZ25jYS9ST1RDcGRsNHh2RGliVzhTMWN0RktYQkJISWp3UE9zK3VMZDFuaWsyeUNvdk9PT1d5ZGRWSE1VNjFhVzJNdjJHZXl1eXA2M0N1NlNlKzM0cEpxWncyeU1UNDJ0Yjd0UmNDMFN1NWNWbHlxblNNdzZ5UjlhdmxZL2paT0c2bFJTY1Z1dHJ4WnhpM0pMTnNrTUFubmwwSitjMU80RnNEZTNDbm5zeHRyZFllS0NCbFV2VUlCbmZhZFBLcS9IN1hMaTk4M2JxQlNIQ082TkFTZG84OVBPdEZ3ZkRQN0p3UzN0bFFYaC9pRW5aVzVTUEFiQ3NtS055czJjbWZXTkw3TEt5QmNlaVRxYW8rUFhFeGJvVkpLM0ZSQjJpUDNvaHd3ZnhFY3VzVUhlMFFrdTJ4QkloS2pIci9BQ3JSa2RHUENya2lpd3V6U3ErU1ZSQ2MwQTlTRFVIaU5seXh2TFI5UHdIdWowcS80YkxsMlcwcUVxUVNvcTZ3RHAvWFdvL0d0dWxWaGFFSkFIYUtUTXp5L3JTaHY0TVkzV1pGbndVKzJyRVgxejMxTkJTUjhnWjhkcU1uM080Y3NFSFdack5QWjgvbHUxQnd3cEtZTTdGTTZuNjFvVHlpRzlkQ1ByUjQ5cXhlYlVxQS9qSjBJd3g3WDQxSitXdFV2Q0VkbTJTUGh6R3AzdEEwdzQ2NkFpcS9oZjdDMFpYdXB3SEtrN0hVNm45dWRPN3BhWXFNRzRhL1lVNHE2ZzRVbE1rTENrbzMwSkpCanhvQXhBUStBa1FBUHc3Nm5XamQxcGIxbzgzcXRTRkIxVVJNd2RmUXhRanhJRXRYVnRrVGx6TUpVZGR6SmsxaDVGeVZuUjRxVUpVUEt0MCsrQUZDRDNqR2tnRTgvcFZxeGhyTDk3Yk1xU0VnT0pLZ25uRlFiWUZWODNtTzZwQjJtaUREVWs0b25VZDBiRHhycE9FZXRVY3Q1SktWcGplSjJpbUdIaWdGek1uTklIVGxwU0tiN1BCR2tyR1ZYWmpmcWRUVnJmS0xhaXJST200SDllRmQ0Z3puWVEyVWtwU2hNRUQ0VEgxRlpaWWRYRTBRNU82a1pYaUdZb1dWREtkSkpCM3Jtd1QydGhjcEdwQXpEVFVVUmNSMm85eWNPWHZBVG9JTy9PcW5oWm9QM2J0c1ZETS9idUpUL3dBV1dSV1ZwcVd6ZW1uRzBVTEpoQkhRelJqd25qRG1IUHR1SVVPNm9EWGJ5UDhBWE9nOGdvdUZwT25oVm5oUzR1bXhvUVZDYWR4NTA2WWprUTdSTmt1R2JXOWNTNWF2QzBBbVIyWmtHZXMxRXY4QUFmZWJaVFJ2V2xhZ2d6T282aXErM2NoQVVDcnlxZTIvbDVnSHIvS3RjbzZvNWtacE8xNkNyVnNteXVKTjh5bHdheDJaL2VqbkExb3U3RlFNWm14TWNsRGxRcmlpa3M0b2tPaEttWHBYTzBUK2Y4NkljRWRSYXVOU0VsaHp1S0lQeUlyUEY5WlVicC95UVVnSzlvR0VGdTRWZXRJN3E5VmdjbERjK29nK2RkK3pmR0JhM3Z1RnlSN3MrU084ZEVrNkg1L25SL2pkbGJQc0VGQktGaUNrNmlzZ1EwdkM4VVcyc1RrV1VrYm1PUi9XaG1uQjlrVEUxa2owbDZpMTR2dEZZZmlEN0t5VjVUS1ZFYnBPb290OWtWbXR2QjhSdlZJaEZ3NmxJVVRFWlFldi9FUGxRenhhNmNRd3V6ZkJ6dUtHUVFETy93QVA2K3NVYXJXeGgrR1lSdzB3c2YyamtTSGdQK2lLZ0ZMV1kzSTFnY2pxZHFIUE56U1EzQkRvbTJVZUE0UWNRNHF1c1JlYkh1VEw2bHRTbU02OXZVRGZ6aWpKL1Zwc25tczc4OUJyVWkxYmJRQWx0T1ZwSUFRSUE5ZlBuVE4yZ0JMS1pFU3BVZW8vYWpoRHFqUGx5ZDNaM2hZKzNFN3g4cURlUDA5KzBXUDlRSHpQNlVaNGVBSHpCMXlrZVJpaFBqWEk0Nnd5ZFNsQjU4NU5TZmhlRCt5R09EeEZ1aVFOQXBKUHlpbmVPV0ZMd3hwU0pLQTZGQWVrVjdnd0RLUVZFakxxQ2RUcUt0T0lHUXF3Q0FxYzZ1N0kyTWZLb3Y2aFMxa3NCT0J3bzQydGxRRXJaY1NOTmlCSStvclFpc3VXcVY2NWpCang1MERjTG9ESEdOdWxXNndzQ2VYZE5HekNwWmNSdEI1K05GZzhBNUsrUUdjZktBdzhBNnpBMDhEVlB3Njdtc0FGU3JMM1FJazc3RHJ2dFUvMmhxaTFhbUpLb0VjOS93QnFyZUZsT05zcmNSdWxha2pyQm9Nai9rRzhlUDhBRUdXQnFWY05YSlVrSlVXVkpJQjE4alBQU2hiaXNMOTl0bzI5M1Q5NmRKVkZFbkQyUmhaVTRvQUxIZTVKMzBqK2RRT003VkNjVFpBUVNPd0VIL21WNDBqTS9nYU1LdVpCc0pWZUNZbEtqbEFNZ2N2MG9rdzFzSmVRK05BWW54b2N3NU9TOURaM0VnblNqTERFWm1ZSXJxMzhVY2VhK1oxZXRwV2xabUlVblh4aXU3OVNvU1VpWTFOZWRJVTJzS0VxS2tqWG5wVHF3bFNDSUdtbXU4VXNqS0s3YmF1Z3NCQVV1TlVtQ29lTWM2b01JdEVOY1FJZFEzbEtWS1drYkNZTkVWNWFoYXM3VUpkVHFsVXg5YVp3eTBjdU1WTnhjWkd3RXdxRkR2SzhCNDBYV0xWbHhuSmFSbm5GZHVMWEczdXovd0FOZmZUck9oNVV6aGJtVzRaVm1PaWhNYjFjZTBGckpldHJLWUlKU2FvckFBM0RZNmtWaGxIcGxwSFRoTHZpVFpxRm9vZGdsSlR2c25jMCtsekk1TUUrWXF0dDNXdzJFa3lxTk9kZHJ2TE5Fak80dFhXTkszMDM0Y210aitKQk40d2tMVEpTRGxJT3l2NkZRckY5VnVTd2hKdU96VnEyaHhKS2V0S3JFTFZRSVE2NENaRXh0Vk5pQ005eWg5cFNRVmtoUlNTa3lCdWVXdFo4Mk4rcEd6anlYOVpNMFN5eE5GMWEvYUIxdFlHWDdST1g4NkZ1SnNPWWRVSHMwbFJBQ2h5UGoxcXJ0Y2V2TEoxSVRlZDVCZ3BkVUZBOVFlY1ZlWWh4UlorNk5xRnRiWER6bnhmKzZubkEwT3ZoVlFsMlZNazhiakpTaUQ2RnVzb3RtcmNLOTlRU0drcEJVUXNrZDRBYjlSNG53b2g0TnRHN2ZHN3R0OVNoZk0yK1lvY01MVVZIdnE4ZWg1NjFTNGFwVnZpV0g0bXRSU1czSEVvQjBDVlpEbDE4ZGFhd1ZicnZGbG82aHdsYlRpbExXREFDZVpuWFF6dEZaby8ycEcyYStETlpZWmN5RXVKeWhXbXRSNzF3ZHFBZ2dKR2swMjNmdHFRQ3R4dEt0Z0F2dEZmUWFWMjAwMjRvckNYbkZIYk5vSzFIUGUvQnkxN3JpTklCazlUTkJYSDF5QmpuY0lVVXBoVWVHbEdwU1VPaGE0Q1U2bVBwUU54VmFtNHYzbkdVRlJ6RXdWUklPdWxLbVB3NmV5dzRSUW4zZHhSTUVDWWptZjhBYXJUSHovQVpVcUdZS081MjBxRnd5MkUyaTgya1pVbncwK2RTc2ZQOE1nS2pMckpQTUNpWDlRWmYzQXpBbk0zRjlrY3hVUVY2K0lRVCtsR2x3c00zQ3N4MFdOQVB5K2RBZkNzSjQwczVsUVV0YWROdFVFQ2ozRm9RcHR3d29pUHpxOFRwRmNoYk0vOEFhRzRGSnQweUlLODBlaHF2NFpLdXpjQVZyR2JMbXA3MmdPaHk4WjJDZ0ZIVHpJcm5neGFBOWNGeEtJRGNDZmlKUDRZMjIzcGNsMnkwT3h2cGdzSzhKYUFIYnZ3V2tFRUNmaVYwaXF6aTI2TG1JTXFLRFBZai93REpWV2xoY2w1YTIzY29WbWtSSHlGVlhGREtGWGx1b21KWkdnLzRsVWZKeHJIajJMNDJaNU0xakZwYzIvdjVoYUNVTFZsS1U1UnkvblJqaGF1K01wU1VSeTFpcGIzc2Q0eVRmTGZ0ZUZMNUtZMFF1NnNvOHY4QUg4OWZwWG1mWmI3U1dYaXRyaG02UnJJaTl0UC9BRHFrYzZyWko4V1RkbzVXaENuQUk1a2tjNXBwUWtRVmFRRHZWK3h3RjdRbE5aYnZoSzd6eEdkdStzOWZtOVQ2T0F1T1FTZjdvWHdFL3dEWExJNmY5L1IvbGcxNktmR3lKK0Frb0NTa2hYUG5VREwyRndGSFZCMG5lamwzMmRjYXVLekhoUEVBWm4vTldSLy9BTDFHZTltdkhUaGc4SjNxZ05pYnF6Qi8vZWFLT2FIN0JmR3kvb3k3MmtvejI5dStBTXFpTnVzVUdXNXlsQi9rSzNUaVgyVWNlNHRoak51M3dwZEljUXZQSzd1emdhZjl2UXN4N0NmYVVnak53d3ZRL3dEWHJYL3phelpacHpUVE4zSHh5ampxU0tHMnVBK2xwQU1KRVp4cG1VZkFkS0lXTFZBQUxWbm4wMVU2NEI5QlZyYSt4VGp6TW50K0c3b1J1UmMyWituYjBRMm5zdTR5dGtaZjdzWWtvOWZlTFA4QUwzbXRhejQ2OU1rK05rdTBnUERkemtDUXhiSVNPU0QvQUNwdDlLVnNsdHhnRWFpVW45cTBCSHM3NDBpRjhMWWdEMUQxa2Y4QXhOSXIyWjhYbEtvNGN4SUs1SHRMTDAvOVpxbm5oK3dWeHN2L0FKTWV2RFpOQUp1VXRPS1FPOEhBUVFQRHdxT3RlRkZLUmFOZmFpVm5TRW1CdHJyenJUOFU5alhHVit0bHc4TlBvZEh4cjdhMHpSSC9BRzVHaDhPZFZsbjdFdVBMZDErZUhidFNDaEtVRVhGcEpNeVQvbU5Qck5aY21SWG8zWThjcStTQm5CcHU3bGxoQ3N6VWpNQ2tFS0Fna1FkOWg4cU5iSEI4TjdidG1MZHREdTRLUm9lZXhxYnc3N0orTXNOdlZPdjhMMzdpQTJVSWk0c3Bra1NmOGZ3cStSd0x4aTBzbHZoVEVTa21RUGVMSVIvOXhRd2xGYllPYUU1UFNLM01HMDl4RFV4ckxZSDVVeTVldUFFRXdrYmhDWW1pSmZCUEZpMEhOd3BpZVlpUDh6Wi9NL3hGUjE4QmNWcU1mM1N4THpOM1pmUC9BQjZkM2greER4WlAwVTZWcFdncFNGRW5tVEpvS3gxOE9ZbTZwQXpCS3NvSFNPbGFjMXdKeGMyQVJ3cmlXYmYvQURObVAvRVZSTyt5dmpONDVsOE5ZbUZIVTViaXkzNTYrOFVEbkg2WXpIam1uYlJUY05MN0swY0w2WlNGakxHaEFNeDYxenhIY3R0MjZFRXgycWlBbFhRRHJSaGgzczQ0dHRyQXRLNGJ4TmJoMWxUOW5xZi9BSWcxQXh2MmFjYTRnbHRDT0ZzUVNsQU9wdUxLSjh2ZVAxcWxrVlVYK0tUbGJSbEdFb0xIRitIZDVPWVhDWUU2UVQvT2ozRjNnRUpLU1JHMm1uenJpeTlqL0h6T0wyOTA1dzFkbHBwZWVQZUxNa1JzUDhjZEtKTHYyZDhhdk41UndyaVU2Nis5V1EzNWY1aXBISkZFeTRweStqQytNRjlyaWJhaEoreUVHSTZ6WGVBa1c1QkExTzVvOXhqMkplMEc1dW0zTFhobTVLUW1DSEx5MFRySjZQSGxUbGg3R2ZhR3lnSmY0VmZNYTl5K3ROZkQvR3BtTEpDTTNKa3lZcHZFb3BGUFpnRnpObjBBMGcxRDRvZGNGMWE2YSs3aWN3Zy9FcXRGdGZaWnhvU1JjY0xZZ0FvYUtGM1puS2YrL3FCeEI3SWVPcnk2Wk5wd3ZlRnR0ckpLN3UwVEp6S09uMjU2aXE1ZVdHU0ZMWXZpWU1tT2ZacWovOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9FdWxlci5qcGdcbiAqKiBtb2R1bGUgaWQgPSAyOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUVCOUFIMEFBRC8vZ0JDUm1sc1pTQnpiM1Z5WTJVNklHaDBkSEE2THk5amIyMXRiMjV6TG5kcGEybHRaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPa3hsYldGcGRISmxMbXB3Wi8vYkFFTUFCZ1FGQmdVRUJnWUZCZ2NIQmdnS0VBb0tDUWtLRkE0UERCQVhGQmdZRnhRV0Zob2RKUjhhR3lNY0ZoWWdMQ0FqSmljcEtpa1pIeTB3TFNnd0pTZ3BLUC9iQUVNQkJ3Y0hDZ2dLRXdvS0V5Z2FGaG9vS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tQL0FBQkVJQVVJQTNBTUJFUUFDRVFFREVRSC94QUFkQUFBQkJBTUJBUUFBQUFBQUFBQUFBQUFEQVFJRUJRQUdCd2dKLzhRQVF4QUFBUU1EQXdFRkJRVUhBUWNFQXdBQUFRSURFUUFFSVFVU01VRUdFeUpSWVFjeWNZR1JGQ09oc2NFSUZUTkNZdEh3SkJaU1UzS0M0ZkUwVmFLeVk4TFMvOFFBRndFQkFRRUJBQUFBQUFBQUFBQUFBQUFBQUFFQ0EvL0VBQ1FSQVFFQkFBSUNBd0VCQUFJREFBQUFBQUFCRVNFeFFWRUNFbUdCY1ZLUm9kSHcvOW9BREFNQkFBSVJBeEVBUHdEVHRWdVU5NjhnUEtNTDRDRE1WbHJ5bzdpNmh3YmJuSUVFN0ZWUkRWZHJLVERxQ0VqcnlSUFRGR2RSL3RLeTRvQXRMQ3NBekhXYUxhY2J1NEtPUXBSTTdRdk5WQ2ZiWElXRklYUDlWVEFaalVHOWtPTkhiSmtBWm1nWTVlTXVFQWtwM0dDWlY0YUFhWGJkS2lydkZUa1lPS29Ja3RsUkJkV0RFYzBCbW1rakllSVNvYzdaL0QvT2FpcTI3WkJTQUNWRWN5a3lLcUVRMkVCSmJVRXhsUmc4RTBDOXp1VVNYRWdnU0lKSitOQklMSzBxQTNpQW1SQmlQblFHVXd2dUpLc0ttQUl6MXFDTWxLa2xNdWdlbU0xUmd1U0MyRXZKVnV4dDNDUm1JcUJYdFRLazdBb0pVTXlBSng2aWdBMDljU0ZxZVVCSEFVT0tvTWx5NWRVUHZWR09TQ1RueW9DRnk3eUpWQVBXb3ZneEtybzRVVkFtQmxWRUUrMDNhRXRoU2xRUmdaRkZuc0p5NXVWZ3dwWUgrOUpvbUdKdkx2YkFKQUdlb0gxcWg3Vjljb1dvaHhRa2M3aVlvYUtuVTdsSUkrMHVEUDhBeFZDb3ZMWXRXMHU5Rnk0cFRCMmxVYmhJcUtwWGRQdWtKKzhaZFNQbm4xcXBrVnI5cyt5bzRkVEE0TTFURUp3TFRDUnVBbklVS0lHSFZoZU5paUFad0tCd3VIQWtRa2d4MG1hQnpsMDZrQWdIcGtSazBHSnVpRUJSU0RQbWtHZ1EzU1lLbEJFbFdSR0tCVlhiUVdDQTM0UU9ETkE4WGFGcG5JSStmMG9IOTRPcGNnK1p4OHFCVXV3U0E0b0dPQ1B6b0R0TEFVb2I5b1YvTUFhQTYzeTJZMzRqUEppS0w0UUx2VmxOdEFKVU1Zd1RRMVR1WGx3OGtxU1RFeEpNVVFOQ0hYREEzRS9nUjZVRXhqUnIxOVBodG5WN2lBQWtIUHBRWTVZdU1yS1hiZDVDZ1lJVWtpSW9KbHRZdU5EdnJOVHBFOEFBeDhSTkJaYWRxQ1hIUTFkcVMwWWdxS1lDajVFZERVV0o2RUo3dmI0SjVPVFJjTWVDVWJKMkZVSGdtZWVhSFRDQzRuWnRTVC9LWkVUTkRURjJySzFFRUdaQktRc0RqcEh4b2x4aTBOdE5LQUFPNmV2K1RSUk5pRTQrK0h5aWdtNmhxcTAzUy9lU2lTSkJQMG9LMTNXM3hoYmo0amdoWHhwaWFqWE9zUE9OSlNwMXpPWlVaNjhSNVZUVVJlb2xhZkY3eE9RcEFJaWhhWTNkb1ZQZ2FnOHdtaUNwdUxjaUYyeUZxNEVFaWMwR09xc1ZJTzYyZVNSSk8xUXdmclFSMXMyU2dtRnZUL051SDVVQ3B0TFJTVlM4ZjZRT2ZLZ2pHMWhTUzJ2Y1kvd1VCRVdheWtsUkJJeEpvTURLeUk4RUpNWkJIWFB4elFGVGJLVVZFcVNUdDZLQTRvQ04yam9XRm9naWVKRkJGMU5icVNRc2trK3VQb0RRVVNRWFhBa2s1TVlvTzRlenYyUVBhdTB4ZGF1bGJOcVVsUVIxakVUNVZSMnJTZlpkMmZRbE96VG1WdWxPM3ZCTzFQOEFlcGh2cHVXbmRrZEpza0h1TFZPK0luYlB3aXJEVURWT3pHajNEYTBQMkxDNEUrN3pVV1Y1dTl0ZlpWbnM3YzJyK21OOTJ4Y0V3dEpNZzhrWXFMcm5kaHRlS210UUpVRGdLa1NhSjQ1R1pXdEx2Y0lVcGFnZkFWR0NSUUhXTHZ2RHRiZGdESUJtaHBpemVkMlIzVnpId25yMHhtaG9LWG4wbUljaVlWdmJqOGF1R3NOMFZRREFWQndVaW1HaUYwbkhsamlZOUtaVFUvVTFJRHpvS1pSdXpzWHlLaUt4d0kya3FRNUl3QnVtcUF1SVNVNEQweEIzRGsvU2dqS2JTRkhjNXRJNENrOCtsQTFiU2RxaktOMHdQQ1IwOUtBUmJLVUs5M0hrck5BUkREb2xXMVJFR2M5YUJpdDRiSkFWSmdTUlFNUXRhRXBVazdraFdRZk9neEx5NWtISjljMEJrWEtra2hRQkJ5TWZuUUtibFE4UUdlUVRRRkQ2VU5FS0JVcFk5MzlhQ1ltN1VHMCs5SUV5RkhOQlFhdGNxZFdySjV4UmVHeGV5YlJrYTEyM3NXSGtndE5UY0tCNEpIdWo2MGhNZTF0TFFpMlliYjhKWEF4MStNY2ZXb1l2MkQ0dGdsYXdtQ1RrVHp4V3RQNG1sb0ZNSVR3TWtERkdjVjE4eTZoQlVuS1J6MU1lZjQwNVZ5ajJ5YUtuVU96N2pOeXh1VWxhWEc5cytCUThqMGtZUHhxTEhtZlgySHJGQ1lhQXR5WWFkTFlHMytrK3ZwODZGVXIxMHBDMm5rU2tweVBROVJSVnMzcWptMUN0cWlrZ1pTWkJxWW1wYmV1dkRDUXVZQUIvdFJkU0crMHJxSVM0VFB3QnhWNU9FaFhhVzNBRW9SS2p0eWdDZjhpbTA0Ri9lbW1xSkxqS0NxYzdXSnB0RlpxcXJJUHUvZUtTa21QZDRFOFZFNFZ6aUxaU1NwTndRT0pOVkRPNlFvRGJkSkdZR2Z6b0dLYWNrSHYwckhCZzhVVTBvZFVuUGRtQlB4b2lPcEMvNVdrS0FQeU5BMWVDa0ZwYVl3b2hYNlVDaFJCVGx3RHBRSWw0bEp5c1JqS0pvRURnTWtxUVl4bE1VQm15MXNFaHJqclBOQVFKUXNGTzFvSGtRdmlnTWxMWVZCUW54Q0JCSFEwQkgxTjdGcUxmQ1NDQWVEUWF0ZUsrOVZ5UG5RZGgvWnZzbTA2anFXcVByUzIwMkVzNzF3QW4rWW1mcFV0a1dSNm1zR0VJV201amZLTndKNE9LZHE1bDJ4N1k2dGU5b3JYVE5LdlhyQ3pTZ3F1Rld0c3Q5MUNqd3Bld0dCSDYxUHI5ald4OWx1eXV0WGxoWjZwcGZ0SXV0V2RTUXBLVnRKK3pMSTk1Q2tqSTh2TWVWSlBoNFRhNmJhdVB2V3FSZU5sdDREWTRtWmc5WTh4aXRkSHRVNnphdFhGbzQyNGxLa3FTZHFWamxRR0JUU1BNWGEzUzd1MFZjV2JOb3NoMVc4TkpDU2hZUEcwSzRJOURUS3JrRjVweE4wK3dnN0xodWR6S3NidlVlbzhxSmRIMGRMYnRxRU9CWmNTWUtSUEZDTFg3cElUdGJVa3BnN1ZBbmNueU5SUU83VHVRQUZidW0yaWNISnRFN0M0OHB3b0J4dFNKbU1mQ2k4RjdsQy9FUW96NTBGbnFXbHQvYVZoTndrQUs0Vm5GRXhWdTZZZ0VqdjBSbnhBeno1VlV3QmVsUXFVdk1DY3lTSStkRndKZW5MU1FCM2F2NXQxQ3NGZytoRUozUXJ5WE5FQ2NzN2hIUlF3UlArZWxBTXNQSmVVbnhEY1RKSW9GZERvQ2dBb281NmpOQUVwZkFTTnBnZElvRlNIc0ZTSnhreFFFYkRwSThCSkdUMG9KVERTeVZFc2dpQVRKR1I1L0dnSUdUNHZ1cEtVekJQa2VhYXVJR3BGTExXenUxSlVaTTVpS0kxMXhYalVaeFJldTNRL1p6MmZ2NzNmY0xiVzVaMmFrcWN0MHZCQ3lWQ1pTRlFsU29Ud1NLbGsvcXpoNko3TzlyOU4wYTMwaExGM3FXdTZhOHdxNGIreFdqano3YUVtRkpXaFB1d2NHZURqTk0vNGdtczNydWlhRllONk5kb2J2ZFRjVmRYVDRHMVJjV25lQko0T1FuUEFGTHlZaCt6TnpXZTljZFU4L3ArdTY1Ykt1bE4vWjByWmJMU2twTHFrbnhGeUZoUElDb2s5S3YxMUxYUkc5QTdZM0EzSDJnT040bUdkR1lTZi9BSkZWWFBqMWQvN24vbzM4Ujcvc2wybit5azNQYi9WSHdoU1Z3aXd0V3pBT1loSE5UNi9IOS83SmExZDcyY01hNFYyNjlhMTY0MUFORlllZnZJMks2SGFFaEl6MGlrbng5TGVtbTl0ZllIMmd1dXo2TlJaMUcydWRhdG1TVjJ5QVQzeEVtRUtJQm1PaDY0bXRTZkhwblhuZEZ5VzFvSVF0SmlGN1JCSi92NlZscUxWTHdkYVFVaHdiZW03ck5RSVhqUHZMRS83cXB6UkRrdnIzcERianlVYmlWSm1aQkVBWjlZb3ZLV0hlWWt3ZVRFMEZqcU9wa1BuY2hra25IaEZFMVdYVjhwWlBnYkE0allLR283ajVLUUZJYmdaOEl6UTA4dTdrNTJBak1SSlA0MExUMm53azdrb1J1eVRneEh3bWhNUGR1QUViVjJ6WlJ6Qkp5VDE1b2FHWDF1S0tuV0dncUFNVDllYUc4czc4d0FsbHJha3labWZ6b2FLSFFCdjdwdmQ4dm4xOWVLSEdzUTZGalozYlFVZXVCRkNjcERiKzFDU0MwZ2RBU0R6ejBvb1pmQkozdXR3QU1KQmswRFZ2YmxyVWp2RkRQQ014MDVvTmM3UkxVcFpLZDhUamNlQlZFUHNpTlBWMnUwUk90clNqU2pmc0M4V3JoTFBlSjNreC9UTk91U3QwZXUyazlyKzBXbjJMajdXbTNSV2xseFEyN0VoUkFjSFRnbUQ1R3ArbjQ5QWV4S3lSb1dnSFVYbVMwNXFQM3JUWm5hMjBBSUtVa2tqY1pXUlBLcXBXNjNtbHVzMjc2TEhUV05jMDFheTYyMGgxRGIxcXBXU254NFVpWklNZ2lZeUtienduK2o5bU5QMUcyMUovVmRYdG1MZThkWUZuYjI3VG05TnF4TzRoU3VGTFVxQ1l3SVNLdVhvMk54c1VCa2crOG84azgwUFk3am5lSTJxMmlTRWtlVkZreEF0RWhpOVc0MGxBTzBKT1BlQUZQeEwwdUcxa3BTRmdwV1JNSDhhZytmdXAybHZlOXNOZmR0dGlMTVg5d3BDRXFnRkpkVnRBcWF1RVV3bHRSN3UzZFdQOXhMd25ucDBtZ0VxMmFVMGh4TFZ5VW5jQVJCelBCOVJRTyt3dG5BKzFoVUVrbHRKbWdLYkMzRUJhM3dmTHU2Q0pxamI0ZFZ1TWtrajNQV3F5Z2JsSlZsSVVabjNlUE9hQUNueUNkemFBZnBGQUV2cksweWdaSG5FMEJFdjdSbHRBRThFODBDS3VsaVpiU3JqUE5BMDNTaW95Z2NtVFFLaTVKQUlRa0VHZ2VYMWxaSlFneC9MUFByUVBUY09xVWtKUWpieWNjVDFvREt2bkM1dEhDZkNJVG5paTZZcGQyc1lVN2s5RXhVdzBxV3IzYkJiZk15VEdKbXFhS05HdkxvQUMyZHp4dnpSR3ZhcHByMW02b1BObEdmS2d0ZXpLWDlhdTA2WXU0Q0ZLdDNXbW5GSjNLNEVJK0JJSHdweEd0ajI3cGV0WExtaDJPa3R0MjJsNncweW43UTFkdEZRYkFUdDNwQUkzSkpHRFBGVGxOaTUweHdsTEtMcGR2OXREVVBQV3lDMGhTdVpDQ1NZK2RWZGJBenR1VzVKQmM0SkdhYXlhbGtOa0dUUGthaTZWUUN2Y3hKZ0NPdFhmWnFPNjBGUG9hTzRsU3VKMjQrTlF2TVUvdEU3UXNkbU95bXI2b1VPUFAyMW92YWdHU2xSRURQVEpCcTJtdkRtbHZ1cHRGRnBLbkFUbFJTVlNldjQxRjBiOTRPdFhJV29EZjAzSndmU090RFlNOXFqYlJTcGxMWVV2eExTWmxLb2o1ajFvYWlmdkFxVHVDVWM0Z3hRMkpTYndaQVMyQURHZXREVnBmNjFjZmFTc3NzcmdrZ2x0TXhqMHBocXJWcXUxNWU2MHRrWjJ5aEVVeE5SWGRSWldwVzYzVDhka2ZQbWh3QWJ5elB2TkpNSGtBLzNxZ3h1TEJhVkxMT1NTUGRQOS9qUTRONy9UbEdWcE1kUENvZnJSQ3B1YkVMUGhISWozdXZOUllDcTh0VXdsQTY0d3IrOVUzZ3FidTMzWWIzSkp3TmgvV2lkSmJlb0pRMFZKdDJ5Q2NBdGo4Zm5RSzFycTIzRmR4Yk5BRVRCUU1la3g1MEEzdTBtb1pHNUNRUElZK1dLRlJWNjFxRGdudjFaSU9FbWdSbS92MW1DOHJBeE1BVXdVbXN1dXVPSHZYRkxrbmt6UXhzUHNhU2x6Mm9kblV1NVI5cEtpRHdZU1QrbFM5RDFEZGFxYjN0dnJPb3V0WFRsbmJNc2FlaERDZHlpbksxS1BwdUlBK0ZNcTVXMTIzYW5SeHFCc2J4dEF1RkozQXNIdlMyZVFGbElJU2NqQk5PYVpXMzZIY3BlYUtrcFdsQTJrQmFZSW56OHFxTEo5YllRb2t6MHBoT1VOaTRCdWlCSklFaW1HS3Z0TVhGV0Z5UEVQRGhXY2VmNVZMRHcxRHRUWnQ2dlkzbW5YSTIyOTlibEJtU2tFanI1K2RMREhscTFTblFQdFdrYWhhQjlkdmNyQWNQZ0t2aG1sMVpHTHZ0TGVKUmM2ZVZvUHZEdmprRHl6aW5KaGpOMXBiaU5yemJ5aUoyT0JlWS9xRVJJOCt0RERRdlJWVDRiaEpIUFg5S0dEcVowZVREN29rOGJCK3RERmZxak12TEliQkFVZmQrTlZGVmNGU1ZybEsyeXJ6OWFDSTR0c3FCM3FUTWc0b0VDdHF0cVhrcTVCOHFBWldUS3BTUngwTkFRcVVFcFVFSjR4SXBveVFGNVFrU1ptQ01qcFFJaHdrb1VOb0k2R2FCZDZ5bFVKOFBKR1lGQXJsemtrb1R0d09EeC81b0dKdUFXanVDZ0ZjeDlhQmdDVnBVRkVnQVRCU2MwQ0JaQUlDTnM1TXpORjBWSnlWaHNwVDFvbitLNi9DbEVxejY4MFhVbnNocW43azdUNlhxS3AyV3o2VnFnL3k4SDhEVXByMXpyVFRkMXJ1Z1dyQTIybDlicmN1RnRUTHc1UWt4MEdUVTNWdGRMN09JMDJ3czB0MjFvMHdsSUEzQ0RuOGdhMXJQQ2NsNE5YaTNXazkzdUVreE82cm94TjJwMXJmeDFnWm4xcWJWMFBTeVZ1S1dRb2dpRHU2Q2t1R2lhd2dxdGdqeEZTOENmV202VzdGTy9hSmNDVk9vS2tKQjlNeEhTaTY4d2UyNjJiMDN0aXRhVWxLcmxsTHFrcUVlTEk2L0FVVFhOSExpU0lPWTh1YUdtOTh2YUJ1SVQxd0lvYkNJZFVWZUpVL3dEU0RORFUzdlFra0tTaVo2cFA5NkxxZnFiYXZ0THNERWtHQ0ROR1ZTK2x3U1NGQXhKb0lhbEtNejVUaytsQU5MamlDTm9TbjFpaTdVKzAxOTIzVnVYcDJrWE04cHVMQkNnUjhvb2l4UGFlMFYvRzdJZG1GcE1ZREx6Wk1lcVhSVGF2Q0ZxdXVhWmRxU2Jic3ZwVmlBTTl6Y1hKM0h6OFRoajRVU1lyYmw5bDUwT1cxc0xSb2dEdWtPcVdQaktpVG1nd1BzcHQxb1cwc3VrZUYwUEZJVC8wOEg2MEFBRXJVcFJXcVVwa1R6TkFpdUJ1Y1VBT25XZ1V1YlVrZDRxUE9nUkt5a0tJY1VDQno1MEJTOG9RbEszQ25vRFFDY1FoMUpWM2l0MDVCRkJWckcxUkJFZWxCM1AyTWR0cnE4dWRKMHU1dUQzOXFPNGJXZVMzMHlmTGo1Q3MyRDAvcGh0MmQ0ZENWRUFGRTRDaDEvNzFyUUxWZFJTU2kzc2RyampoZ3hJQUdPdFRmU0piRWpEcmhIa2xKNFArVFZWYldiU1VpUURBaWVoTlFHWlljdkx4UzRVR0JBM0VDRmZDZzUxN1N2YkYyWjdCRjJ4c1FOYTE5R0RiTk9lRmsvOEE1VjVDZitVU3IwSE5MUjVVN2M5dk5hN2JhNE5VMTU1dFRpVUZwbGxsc0piWVFUTzFQVTU2a2sxUnJya2xTUUNrL1NnYnZWUHVwSjZVRDBUTUFJSjh1cG9KWldzcVZ0WlFSUG5RVDlXdEFYbGJFa0tCSmlhaTlxbDFwMXBSZ3FINjFVUlZJV0pCS3dlb1BGQWlrcmdxSkpqem9HYmZFWkNRZlByUVlwT1R1Z0tHS0FSU0RCS2NueU5BMERrSHo0b0VLSjZHT0tCaUJCQmd4UHBRRVUzZ1lNQ1Nab0dsSUlNZ2dEeUhGQTd3Z1pHWjhxQlNRbFU1QkdaanJRRmJnb1Zubm1Jb0lsMDBKSmpucGlnaldkM2NhZmV0WE5tNnRtNGFVRkljU1lJTk1Ib0gyZmUwOXpXZ2hqVjcxNFBJQUNrSkFTa1lncXh5S3ptTG11eTJuYUxTV2tmY3ZObEFTQVN0UUJQV1AxaW9mVnNPaFhLNzlRRmlnT0dmNUlJU09PZWxiaUxEdFQybTdQZGlkT1RjZHJOVFlaVW9TMWJBbFRqaDhrb0hpVjhZanppcGJJc2p6TDdVUGJ4ci9hcEx0am9aYzBMUnpLWWFYL3FYaC9Xc2U0UDZVK2NFbW1leXh4WlMwcFNBbkE2aW1HR2Q1NGRzS2ptcVljbFpFZVhUMCtkRXhJYUFmWDRWUXJ5Sm91RHF0MUNVNXdKa1JSQjBXdTRFcXhKTVRReGJhdUUvYUhGRlFDaVloUk5EcFUzSTNZU2QyMmV2K1lvSXFrK0RrU1BTYUFKU29ZVEt0d2dTSnp6UU9OczZwTGlnbGVFaFJsUCtUUU1ERDJTRXFPTW5iTWZoUUNVeTV1VEtWRG9mQ2FCcTBxQ0FTRlRNNUZBSE14dUlqeW9FUEVKSjQ1eDVVRGtrK0lFcUtZekVVQ2JzRXEzVG1nY2xhdGdrcXhpSW9KU1cwcmlKQVBTZUtBemJVQ1ZLSjI5QVlvYWM3dENDVXBVSkFrVUZUZnRRa0tpS0NQcDE1Y2FmZXQzTm81c2VhTzVKL1FqclFlMnZZTmE2RjJ1N0sydXF2eGNYWkd5NFpXMmtCSzR5UFVkUjZHa3VGcUo3ZnZhZGVlejVWbDJYN0lXTFZuZFhOdDlvVmQ5Mk5yRFpVVWdOcGlDdVVtU2NBUmdrNGwyckhsVFViMjYxRzlldkwrNmZ2TDE0eTVjWERoY2NXZmljMGt6bzNVTzUyN1k3eE1nU1NEVk5RM0R1TUlPT1pQV2hwTWN5RDU1b2twNkNtZHhPS0xweUZncWdEaWhxV3k2OENra2hROGptaHF5YmViS2NxUUQ1VkQ3TjExRFN0UUZ5NFUyVDRoUms3VThrOU1VeGUvQ3R1ZEx2VkhObytNeEVBZjhBNjFVeEMvZCtvRmF2dTNFWUovaUFabnJpaGxNYjB6VUZGSlZzZ0tqeFhFZlRQTlRURHpwMTRyTHJ0dkFPRkc0R1BTZDFOTXFLdlQzQ0ZiN3UzK1Q0L3dENnFtVkVjMHQ1T3dpNnQxaFdSRCtmL3RReWtPbFBGTWwrM2s4bnZ4ai9BT1ZFeGNkayt4djc2djdwV3AzeHNOSXNiVmQ3ZlhqWTcxVGJZd2tKVE9WcVVVZ0Q0K1ZQR21CZHFleGw5MmUxUVdxSDI3KzBlWmJ1N1M3YjhBdUdIRXloZTA1U1l3UjBJUE5EdFJ0NlRkNUMyVkFLQmlUeWZwUmNwaTlNdUVTcHh0VWVxZlA1VU1wUHNOeVFRVzE4aVBBUDdVUklSYTNLa2dGaFlQTTdZQmlnUVc3dTRBdDVQcC8zcG1neHRsaHVWTkdZa3FLY1I5ZmpWeWl0MUpoUXR5VklnQXh4K2RRYThzK05SNWswSG9mOWtIV05XWjdTMzlsYnRPTzZTdHBCZlVueGR5NU1KTWN3Y2drY1FLbURvZjdZbWtXN25aalJOY0JiUmVXdDBiWXBVb0JUalRpY2dlY0tTay9NMWQ4RHlZdDhpQWt6aUpQRkFKYWxPNUpKUHdvR09ZTzJLRE4wRElQem9ISVdBUitCb0hKV1pBQUpIU2dPMFRzeUR6d0NLQXkxZ3FKa2lUNTBIUzlZTjBiaHhDcmgvY2xlVTdpYXl1dGZ1VXZBbFNpUm1mRW81K1UxY2lJRHJUZ1dyeE43akpJSjRucG5yVndLaG5mRWhCM0htQlBHYUxTclpTa05sUlNFbmttRFJFZDFrRkJJVzBzSmpqRS9LZ3R1eTNZN1Z1MXJ5N2ZRR2JPNGRiVWhDa09YTGJKOFV4Q1ZrRlFFZnlneFRqMkQ5dWV4VjEyU3ZyS3p2cnV5dW5ybTBSZWY2VkNraEFLbEoybmNBVGxCekZMK0M5N0ZuUnJUMlY5cWxkb0didHl5MUhWTE93VzdZclQzck8xcHgxRGdTU0FzQlVTa2tUSjZnVTZHcjl2TmJ0TzBPdDJ5dElZZlowelQ5UHR0TnNrM0VkOFdta2tibGhPQW9razRvS0JMQzBLaVZsWUV6UFRwRk1EVmhaOEpMeUFPTnJpaGtmT2l3b1c3a0JkeW53eEFjVlVrS2xmYWIxRzBKdXJ5UW5udkNhcG9yVjlxS1hSRDl5Vmc0a3o5S0duUDYxcVZzMFVyZmRTQW5BVnQ4K2FHdGQxVFg3dTlSM2FuSlI1RkNmN1VOVThFcTg2SW1XTDF6YWhiMXJkTHQxQ1A0YnBRbytVUnpVc2w3V1hCTG05dXI1OE9YbDAvY3VBUUZQdUtXUjh5VFNTVG8wZ1ZDUkhQWHlxcG9wVWxTZjVnZktjZkdnRVRKNTY0b3VzSW5xWWpORFdBU1JKT09oTkVGVElJamswQjIwbmFkMlBROWFHbnVKSmNWdE9KUGxRZFYxdHhYMmh3ZjZZbmNaS1hBRlRVWEd1dkpjQldVb1Frai9kVWs1L1ROREFWaHdLSCtuSlQvd0FxU1o5RFJORlpscVQzVHFTZ2srNTF3T25TaTFDZWZJS1pDeEN1TmhIU3FnTGx5Z2Q0cDFZMnFCNmtGTWRlT0tEcDFpV3ZaZjJSYTFKWWFiN2I2NHdmc0FkRXEweXpNZ3U1NFd2cDlPaEJYL2lzNTVhZDI1N1VOOXBkVXQ3cGtQSmF0dFB0ckpDWFhBcGN0b2dtZXNxS2puT2FrMUZqMklZT3U5anUxM1ptMis5MU5hV2RXMDlsS2s3bjNHSkRpQU9xaTJxUUJuRlhOcStOSjJnN0w5bXgyRnRlMG5aTFY5U3ZiZE40alRyMFh0dWxBTDZtdThKYndJQTRJTTg4MC9pS0IvU0ZNZG1yTFhROGhiTnhlUDJKYjdzUzB0dENWaVRNRUZLcCtWQlVYS2tCTW9Ta2daa0FBbWFCcUVtY0lBSG5QUStrMEIxb1VzcFZzU01BKy84QTVGQ0N1dk5XZHVwNVFTQ0VuYjRqUDUwWEdsMzE0NWQzQldwU2lQVTFKRVJUSFRtcUhvRW1jUlFQeW9SVXd3OVBoSVBuVkQwa2ZLT2xETkZLdkJrY0NJb1laeEhIem9Ua1pTVkFSR0FaaWdTZkZnU0JGQVpJQUpVWStIblFFa3JpRTdVVUJ5eVZxVWRvNU5CMGJVYk1pOGNBZHRWS0JQSVRqeXFDcGYwVUtVVnRpM3p5Z2dZUGx6VFZ3RDl6OHBTbG9yeEFDMVorbEREMTZWY0FlNjRrR0lDWEZENlVXbU8yRndsS28rMUZBT0ZCY3hqMW9sYlI3T2RCYWF1Nzd0UDJrRDZ1eitoQkxxMkhJUDJ5NVA4QUN0eHpNbUNjUkVUZzFkemxNYWgybTFyVmRmMTYrMWZWMzNITHU4VjNpb1NDbEEvbFFtZUFrWUE5S2tpMnFodFQ0QjhVSUdKVTBEOEtxRnQ3bTl0YnkzdWJXNCt6WEZ1c09zdk5JS0ZJVU9GQWpNMHMwWHZhTHRqMm83UldOdGE2MWZ0M05vMHRUNlcwMmlHa2x3OHVLQ0VqY3N5ZkVaNVBtYWZ0cTZzYmUrdHJqMlBYTmlweTAvZURIYUpGeTB3VENsSVhhbENsQlBNU2taNEZUeVkwcDk5WVd1R0xXU09pQ0txSE11cVRuWmJ4OCtmMG9Kamx5cmJ2RFZzUVJqSkZGNGE3cnQ2WG5kZ0RZQ2NlQ2MxRFZaQkNKUEpOVkNRU1k2MEJpZzd3bEp3bm1ock9oSDVVWFdjZ2RLSWUySWduOGFBMGN3UFFlbEY0d3FVRStWRHZzNHFnamFabWliaDJOeVNvWVR6UmRIUWdCSUxzU2Y4QXpRMmlJbFFNQWhQRTlhSWtMS2QzdWcvRTBIcEJ6UWRDMUM5VXRqV0dyVmU0TDdtNldsVGF2VGVVQWo1L1dwc3ZhNWFoYWwyT0duN1RkUDJ5RU95VXFjRFJRdjRMQ2dEOWFYTzRSVDNuWkZ0YVphZTBwTThIdzQ5TU9HcDlwZkpsVkY3b3Zkb0pWZTZRVkFqK1p4T1BsTWVkTm50ZVVLMTBxNnZyaTN0TEYyd2V1WDNRMnl5M2VxRzVhakNSQkZXWmJtbmhlKzBUVXJmVG1iUHNycEY0MDdwbWtENzUxRngvNm05VlBldUh6Q1RLUlBFR25GNlJ6cHg4dXJBZFdwU1JrdzZrOWZVVlNFUDJaUk81dzQ0QTJRZktvWUc2R2drQXVDRGpoTWo2Y1ZUQVVJWkJJNzVxZHVESFdoZ20xdG1GaDFqZWxPTUdhR0M5eWw1U2Z2V2RwUkt0c3dUaVJ6aW9ZS20wdDBxSGV1TnFaaVJCTzREeTUvR2hnZDBwcGl6V3N1c2JnMllCa3hReHoyNFgzdHdwUmlTZWxVd2hQaTNSZ2NVVEVsbHJZeVhWRHhkQjFvdUJ4NFQwUDUwUWhWZzhSd2FLYU9SUXdka2xLY1FDUkZERGhKOCtLR0NwVWQzaFB5QW9ZeE1ieGdFZWhvWU00Q2hISFVEL0FMVU1ZbEt6ekI2elJCVUtPSlVBZmhrMFhCRkx5WVFGRHptaU9uWEJSM3lnN3VJM2RIYy9qMHFMbzloclY1cFoyV0w0REJ3dGh4WWNaWC96SVVDRDlLbWVqZllyOTcyWjFDVHFXanVhWS84QThmUzFkNDBUNWxoZkgvU29WcmI1UDhDc095VmxxdW8yYkZsck9scnRIM2tvZGZCVTI2eWttQ29zcmdrQVp3YW1yZGJDZXo1OW1GbnFXcjZxUTMyajc1N1Q5RlpDTWJZQVZlRGd3RXFWdDhpcjZhdkhFVHR5MTFDQVQ5MmdOOG8zQXg2a21meHJJeldyQi9STlp1dE4xRzNRaTl0SEMwNmxCM29KZ0VGSm5JSUlJUHJWUkhUY0lPM0tVays2TnNtUGhPYWNyd1VMU2hRVHRDVHhsdkhxZWZLaWNFNzFvRCtjeGozWW9NUzRneUlCanpCb3ZBUGV0dHFCR3dtZWdQVDUwSmNTeGNOclZ2VzJncU9RVEl4UG5OVERWWjJvdkFMWkNFb1FrckV4RW1xY05RU0NvbmJrMFE5Q0NWZ0hqazBOSHVWSHdOekFBay8yb0JqZytWQXhYU1lvdWlCR2VRS0lKaUFaR09QaFJkT2FCVHUzWUg1MHB2c1VBSGpFMU5UUm0waElLaDczVURQK0NtcnBIbGhTRUJPZkZ4TkpUYWZLbFlLdHRVMmtLUUkvVVVRWWJSSVVDVEo0b09vNnFXQXR3QjFlOEtJVnVHT2FsRmE1Y05JU3BDM0ZxQU9NZ1RpaXhHTHpBQ3R6aTQ0ancvWDBvZ0xydG9Tb09sd3dtQkpUakZHbTNkcXUyRmgybTBmUjdOelJMcFYxcHRvMWFXOStxNVBlcUFURGlWaUNGcEpBS1RnajUwbTB4UXBRMDlhQmxXaU9yV0FVbFlVdmM1dVBLc0dRT2dFVmNxZWVtLzhBYnpRa1gvWlRRZTE5bnBxMzdwNjBaWjFObGFuTnpTa3A3cHR3QUFZVVdpayt1M3pwNFJjMjJpbzB2UlA5a0U2QmFydnIvUWJtL3dCUWVMU2xMUmQ3ZThZWjNISTJwUVFRT3BCcHZPSGh5VmVoYXE2cEsyZXpicE1CV1cxUi93RGFwLzhBZHJnYSt6V3ZwbEo3UFhJQmpLV2laUHgzVmNRbit6R3Yvd0RzRjJZSTkyMmNtaW9iblpqWDBFcVgyZTFDRG1EYU8vaGlnVDl4YTRFZUxRdFIybmtpemRBZ2Y5T2FaVEdrOW8wdm92U2grM2RZSS9sY1FVbjZFVXhGVnR5UnlCNVVFcG53b0tpZlVqOHFBSlVTU1ZaVWZLZ1dja1JpZ3daelFQbVZlbmxRS0pKOVBTZ0lqM1ZmUHBVQldISk8xVlQrQndKQkFTZmhWQWlTWGs4Z1ZSSUNpTnBNWW9DbEhlWlZtYzBEOWtsVzNpVFFkbTFDOFFibGV3MnFWQ2MvWkVBRFBsRlRhdUttOHZ1N2QzTnFiUjBKRnMyQ2ZVR1B4cHRFQjI4Y1BpUmNxQ1U5UWhBejlLQUQxMjhRRDl0dUJ1NElJNG5IRkJHWGN2S1VTTCs1SW5QM2l1bndwZ2F0YnluQ2s2bGNLUkl6dVhING1tVDBWMDNRdFhiMGpzcDJQdjhBVUdqcU9paFdvYUZxckVTWFcxT0I5dUpQdkptUnh3UmlhYytFUnV6V3VwMXIyOTJldE83MFcycGFpNHliZDR5UTI2eXBsS1QwNGlrV3VZcTA5NjNVVzF2dGtzcUxlRGlVa2puNENoYlNwc2xMY2szS0VnSXdOM0o4cWNJYW14ZlNvcFJkbVNaL2lWTW5wZVJVMjJvSVVOdDg3M2ZRb2ZNejVjMWNucEFiNjgxZXlzbGxPcjNhRWtFYlJjTGo4Nm1UMGEwTzdmZGZlVXQ1NXgxZVpVdFJVVDlhMEJSd21jem1nSzRyRzBIRkFQcElQRkE3TUUrWm9NRUFZb0hJSXhBb0hwT09JaWdlMnFFWkVkYzBEZ0pQWHBRRTNtQ0QrVkJpeDQyeU9lRFFHRWdjVUJXWko4aDBvSlpDZHlwU2s1NW9PaTZvODc5dU8xMUFDU1loUFh5SHBVV0taeFQ3aXRvZFJCRVJ0T2FJaHVwZUNWSzc1QUE0T3ptaldvcTF2clVRMnJ4QWtsS0VIa0RQRkVvRGkzMEdQQ25md296SDBxakVQdm1CdmJNZWZwUkRoYzNDbGhvcThHL3ZPN0xoMjdpSUtvNG1NVFFQUmRYRFRqVHJKS1hteUZJV2h5RkpJeUNENWlnWXQ1MUNFcURLNUtlWm5yMG9ISnVGeUpRNms4NUFnbWdSZHl0TGhqQ1ZkRklvQk9YdVNvS1FBSUcwR0JRVmV1YWd0YktXd29GSXhoYzBHdnA4VG5uMU5BOUhLbC95K3RBa21jcCtNMERTQ0UvclFQNFZpTWV0VHNZVDRhb2NrNS9XZ1Vxa2NZTkFvQ3VZekZBOXNxSE13TTBCZ1pQdTBHSzhKVDVBanB6UUdCaGNTZWV0QVpqQU05ZUlvTEJJYlZKVTRsSms0SW9PbDNuY3VYQjJsNUlLdmVXeUNBZnJUQld1V3dDVk9KRnlxSkVKWUVEMTVwbjRJeTdjbWY4QVQzcWlFZ0NHQnlmblRLSFc5dXdYRXFjYTFBSkpJQkRDVEg0L0dtWDB0cVZkMittb1oybHk5QU9EdXRRZW1NeUlxWmZRZ3RzYVdwU0M1ZVhEUmtBSlZacVA0N3F2OE5FWHB1a2Q0alpyTnVnS3g5NWJ1Sm5HUmlZcWIvcVFGV2k2Y2xQM2VzNmFwS3VmRTRpZnFtbXhjczdSMDZJbGF0d3ViTlNTSjJwdUFuZG5ISUZQNmhybWhQZ0JUWGRxWHlDaDFLZ1NPQU0xUXh6UnI0K05DSEZIZG53N3MvSTBFTzUwbTdDU3BiVGdRRGs5MmY3VUdtYXVzbTRVQ0lnK1VZb0liWVBrYzBCQ0lTQkFtWk5BemNwU3BKaytjelFZRDErZEJrRUtVT2MwQkVwSkVjVUQ5b0VDZUtERkt3Q0RFOWFCeW5JekF6NVVERXJVUWZLZ2VrbnhTc0FtZ2NTcm5lREdmeG9EbVFzQ0JJUG41MEJnNEV5RkNBRFFHS3h1VjhmS2FEMG00N2RXN3JnRnFBUXFTU0VUSHhLdWFvVmwrL0R1VkpUSXdGQmdIOFY1cC9RSzgxZTZHOURoY21QNUZzSitaaFZadFZXcjE2OVM0ZGphaU9aNzlvQ290bXBkbjJ0djJ2ZnRtM0FPcFUwcUIxRVNKcHQ5cGtUeDJ4ZTM3anBOdXBzR0NrMjZGRkk4ekN6VisxOXJnRG5hMng3MG04N042YXBNazdITFBhUjVTUk5YN2ZMMm1JaDdUZG5IbGZlZG5OSVRIVXRGT1k2ZUNuMytYc3dKV3E5Z2wyNFZlYUJZa0grVnA0cFA2WXA5cVdNZnZQWlE0eUM1cEY2ejBPeDVVVDhRcXA5L3lJcUwwK3pSQ2tkMHgyZ2FSbUZOWENGWi93Q29mclQ3ZmcxTHRaZmRrR3JGU3RPdiswLzJvcUpTRkZyYkJua2lEekg0MU5uci93QWpranpoY2VVb3FVcVR5b3lhb2MxSGVBcTRIeXFncnhFaFFNcUluQjRIUUdnR1U3UnhIeDZVQ1JnUitWQVFlSGtjbWdXU2VJK3RBUUpWdUFUQkpPQ1RRSVdGN1VFclFRUmlLQWV6d3lTT0tCeU1nWkFnNHBvVklJSGhLWjU0b0hEY0ZSS1BwUUdiV0lLREpQQmdVRWx0VWdTQWxSelBuUVNHa3VLM0VRQnVQVG4xb092WGliaGJpaUVlNlNNTEJGTEJXUDNJWVdVT0thUWR2SGVwM0g1R29HT3ZGOVNGdDkrVXdEQ0J1a2VrRE9SVnkxWlZVODQ2b0tXMkgxSUdKVUkvU29VTDdRK0NGTnFNbUNRVmdSOFpvU25KNzVTOGdaRVIzb0h3R0tHSExiZWR3cGFGcUFnS0xoTWZPaERIclpTRXFFTkNjekNpY2N3YUdCSXRRVndsNW1USjl6bkhFazAxTVloYkFKbFpYRUdNUVQvYWdocmV0aWdKQzMxR1RHUUJIMHFqVTllZFNwOVFRVlFEMU5RVTgxUVZKeW1RRDF6UUtrNTU5S0J5bEh6eDhLQkNzek9aSm5HS0JOM2lNa0RyazBEa3FBR0NKajQwQlczQWt6MTZoSXFhQ2ZhTjZFeWxlUGVPSXFnS25OdzY4Y1JGQTNlcmtDUG5RT1R1bVNUUUVTQ0ZZbWZqUU9ZUXNLa2c4eWFDY21DTXlBY3lLQXhhVko1Z0dCbUtEMW5wbnNJVWRPY3V1MW1zM2wvZEJKY09uNllmczdKTUh3Qlh2cUo4OGZDdFNmRHJOVGxNdGZaanBGcFoycmY3dXM5TnNYSVc4MGhnOTZxVXp0VzZ1VmtEcmtUVnRTV3Q1WWQ3S3RJTFNHclFOTkpDWUNmZDh1a0RpczZvN2VsZG5yeDRLUmIyaTE1bFFTRlNUNjArM29BMURzTm85MGtyWHA5bTRDTnNxWlNSQitVelZsSEEvd0JvYjJjTjlrT3o3SGFIczh1NHRrbTZRMWRNcElMYVFvR0ZBSGp4QUR5elV2STgrSHRCcXlBUWJzbWVwUUpyUDFpc1BhSFV5QUZPb1hCd1ZOakZNQy83UTNweVc3ZWZQYkg2MDVEMmUwVGdjKy90bTFKaUQzWktTQlRrQXVkZGRVNzkwbEhkam9vYzA1RmRlWEs3dFpXN3RDam5BcWlLTW5OQVdDRDBvRmlKbkZCdmZZWDJVZHJlMmltWE5MMDRzMlRnM0p2THM5MDF0ODA5VmZJR3RUNCsrQjN6c2QreS9wTm8zMy9hZlVYdFZjNk1Xd051MFBpY3FQNFU0blE2SHBYc283SDZMdCt4YUJZSjJueExkYjcxVS9GWk5MODc0SE4vMnBPeDJrdGRobWRhMHpUcksyZnRMMXBEanJMQWJVdEMwbEpTWTVBTzAxTDhyWnlQS2hiSU9Sa2VsUUlVQUdNWTlLREFpUVpvRlEySk1tQjhLQWdSeG5OQTVDTVo0SGtLQ1F5Q1I1eG5OQVZDVHRKZ2VFengwNjBFOUN0b3oxTTlhRHMvYUQyaGUwSHNndHkvMC9VN2pVRXY3V2xwdkdnOGhPMmRwU0FCdG1USjY5ZUtsK1BvZHk3SysxRFE5ZDdETjZscVY5YU0zWXQwRjYzQ3gzaTNOb2tKYW5kbGNnRE5QdG5Ia1hXaDYyeHFPcHZocXl1TGExZFFnaFRyUUNkMEh3cUhTUlYyK1JWM1dodjltUzQ1bzZtM2RQMmxhYlJ3a0tiemtJVnhHWkFQMXEvNEpXaTlxVlAzQXQxMnQyeS9pVXVvSXg4ZUk5UlV3VXY3U0xDYnoySjlvMXZ5bnVneThrREdVdklpYXRSNFVmYkFJakkvU29xT3RPZHBCQkdEUUljOVI4WW9HbEFtZXRBaWtnSm5yOEtCaTQyZ2c1b0dwSEE4NkF3Z0t3UHhvUFNuN09Ic2I3TjlxK3pyWGFqdERkL2IxZDh0dE9uSVZ0YlpVa3dPOTZxSndvREFnaVptclBsSi9vOUkzMnQ2Zm96QzBXTEs3NTlsQUJadEFrN1lHQVZFaEtSOFNLejl2UW91eUhhM3REMnAxQjVDdEliMGhpMmQydWh4MFhCV2tpVWxLaytFZzlZbURpYVNYeU4yZFNFd1gzRTdqNkFab09mZnRDMmlMMzJOZHFHdG9VcGxoRDZUNm9jU3Y4dnpxd2VFYnB2YXM0SG1QV2dqcEdaSmo0MEdiVEhJZzBCVUlKR0lqa3lPS0FvZ3E4UDA1b0hzb0NpQndUbWFBektDcFFJMmtIT1JRU3cwSjNwL0E0TkFSU1lVUnQ0OUppZzlFWDlvekt5YlpCVE9VbFFpZlBqTlVjcjdXNk03Mlg3UVd2YTZ6dEV1TnRQQlR0cTRJU29FUVlJeUpCNTZVM2VoM2YyZWF1NTJ0N0Z1YXpjaHUxMDY4WHROcTI0dHdrcFZDVUtWeVZISEFGWm43UjBsNW9uU2RQYWRTbGxib1VRMEZZUVlCQ2ZpUHpxaUZjWEgyTXRsdHhLMU5LeUFZL09uUTBMOW92dGhwVDNzcDFUVEU2dFpmdkc2WGJvVGJoNUpjSTcxS2xlRVp3QkpxZmFYaUR4dzZRcHdIY0RHUEtxQXlKNmZNMEdBY1R4UE5CaWtuY1lpZUtBWndyYVRpT29vQU9ZOFB6NG9ISlRBOCt0QWRDT0Q1MEhvejlsZG0yMWpSZGEwTkxwdHJoTngzNzdpUU55bWlrQVFUeGtINjFObmtlak5ON0RhQlpzTk5odGI3YlJLdHI3eWxwVW84cVVEZ2srWnE3T3hzemJsdmJzaHRvb1NsQ1lDUlUzUlY2aGNwU25lNlJ1R1pIUWVRb05DOXBPdUt1ZXhQYUsxYmNiUzB2VExoS2xLQUluWWNmcFFlSGk5dmJRcFdGRWVmNFZRRGhVY2Y1MG9GNFNUQStFVUJXMVNtQUppZ3lDWUlJVVBUa1VCRUFwTUF3VDFpWW9KYlFHd2trZ0RnaWdLa3FPNUtpWkdLQWdWeks4Z2tjVFFlaGxPMlNuRkJUYlpXWmtoWkJNZWVhcTVFZTRWcGJ5SFVPdG9XMlJ0S0ZiaUNtTXlLbXlkR0tQVC93QjNkbkxwMWZaOTI2MHp2UEV0dTNmVUVLSTRWc01pZlVWbTVlNHVHT2RwNzVMU21YZFoxcFRaTzRKVS9KUkhRWXhnbmluMW5vVXZhSFd6YzZWZk5QWGQrOHBiUi9qUEtWQkhCK05NaU9JTmZ4UURNeWZ5clNKWklDaEpqclFOUGlJaWZQSFNnd1NWY0VqOHFCWEFGS3h3S0FhOEdUT0Fab0FIN3haTkFjSndveWZEaWdWQkpNRXhRYkgySzdVYXYyUDFnNnBvRnlscDlTQzA0aHhBVzI2akIycUh5R2VhbG1qMUw3Sk8zdW9kczlHTDdxZEt1THdLVWgyeFZxSGN1TndmZTJFWlNRY0dUNVVHNjNOMjVwVGgrMzZlNDJrK0x1Ylo1Q3lmU1NxbkJxdTFqdE16ZXRoVEZ0ZEpXQ0VNMlMxSjN2TE9jaEp3a2RUU2p6MTdZZTN5M3UrMGV3dUduN2twS0x0MWxPMWxub1dteC9NZk5ScCtqa0RQallSQWpIVStsVU5TUnRFRHpNVURsS0VIcmlQalFZRHlTb0dnTWtnQVNaSDBvTTd6QUVpQkhGQVZ0NlFRUlBTZ01ISWd6ZzhHZ0tiaEtTUUNCbnpvTy9QTnNaVWxGd0FldTBUL0FKL25TcW4ydFExS2JTNnBEYkRoUVNWNzFtTTlZanpySDYxcXIxSmhKTWkzZklrWjNqSHppcmFhZ09XNmkwQXF5Y2dxOHdlUlFxRGRzcENYaDlqMitBanhLa2pIbEhOQnhzQ0xoekJHMG41VlVFM1lUQTlLREpPQVBMNjBHU1FveGdlbUtCUXFUSFQxTkF4NHczQTg2QnJXR3pJTkFRQUJuTTVQUHlwb2MyUEdSRUNPdEFkQUtXd09uRlRZR3dBcEtoSVdPRE1FZk1WUkt0dFoxSzBjMzIybzNUYStKNzBtZnJRUzBkcXRmUmJYRnUzcXR5aHE0RzF5RENsRHkzQVRCNjV6VXdWVnVtU0V4ejBGVUt4RGFGSVBSY2NVR0xCUW85T3VNNG9CcVdNNXdhQm9YZ254ZklVQmZISUlTZlFuRkJuZHVFektmaE9hQjZRdklrRDFvQ1FSQndUeG5pZ3NMYTNMelpVU3lEdUk4VGdRZnBRZWxyeTFYdmsyNnlxREJDejhxclVtS2x6VG5Gb1ZOczZBQURKVVpQU2FrM0RFWjJ3Y2NRcHhkdUNoc0RDbEVtS21XR0sxMjFjRERoTnVrcEFDdHhKems1NWtITlF4VzNMQ0hFRkJZS1FjWlFUOUQ4NkdOUmQ3RDZZU3BhbmIxRzdPRUQ2VmRUQTBka3RGRWVLOVdBa3lTb0ROTkpESE96ZWt0clNFTVhDd2VxcDQrdERDcDBiVGU4aHF4UTRrWUJVbFFuOGFJYnJXajJOcnBnV05NYVE4RktCVnVQVDgrYURuejQrOFY1RGdBelZEOXNOZ255b0NML2dvVDV5Wm9FYkpnbFJudzlhQ1RrTmc0azlLQVNpT2dvR1NaSHB3YUJ5Wk04MERtMXFLU2tHRXpKeFFQN3VYTndVUlBsUU5XMm1SR1Q1bFZBcFNKRUorbEE3WWR2V2M5YUFnU2Rva1JGQVp0QkJHQkp6bWdSVGNPUU00bWdjcEJWdXpRUElNbkhXZzlYM1NRc0FSSXhPNXlEOHFvaDdGQXFHd3lKSlVIQkFGRFVLNEN5c29ReW9RVEEzQThlVlNyS2hxWmRVbmIzVHllUk80RXdjNHJCVUIxcDRBQUM2a0RvSjNWckRVVjFwMVNDU2k1QXlGYlVnZ1V3MUVZdGlFYmx0WE1oSkFnREl4VUloSnRYbmxxVDNEcDhXNGxZanBnRHI2MVQ5Tk9tdnlkMXF0UkpBRzVZVGdVTDJxTzE3YTJOTDJLYVlRSUp5NXVJNEdQS2lPUnZZV2VPVFYwUFBBa2NDS0F6M3VEbU1SK3RBTk1iczVpcHlEcVY0UUtvWkpFa2lnYkFKQlBQd29FUFdnZTN3SlBUbWdPZ2tLQTg2QkZueDUrR2FCU0J4T2FCUUNBY0NQaFFHYUhod01RUG5RRkNRQ0l3UHdvRWNRUXNUSjZab0RJU0FpQ01uaWdPaUU3aEUrSStsQjY0MVQ3SXhxVGxrM2FzUFBnRlhoVkc0QWllYXRvcDFxYUNpcGVuYmt5VElXQmp5OWVsVGtRYnRMTFpLRTZVVXBLYy9mVE5PUlhyUXpnSXNsU0lHWEIrR0t6M1ZxRSs0eVd6L29IQkFrK0tDUld1ZUNJQ3Jsa2dBMlYwM3RNNGN6SUhIcUt5aVA5b3RFRUtMR29EdkZTQnZ3ZjdWUkZkZHMxRkpGcmZ1VGxJTG5Yb1BwVVdveGR0MHFPM1RuRGtnQmJtQ0QweG1xVnJYYlIxWXN3RldZYWdFa3FVU2MrZElqbUNzcTZjMVFmYURqcjVpZ0krRDNjR01wR1k5YUJpRWdRQVJFZldnT3BJMm1QZW9CaFBrVEZCaDVOQXhVeitWQTlITUVUSFdnTWtsSjhNZ21nYTdLL0VveVQxb0hORHdrbWVJRkE1TWhKRkFSb0VwSFF4OUtDWTJEZ2dTRG1TT0tBYWs4bk0rWG5RU1dtOTZZUHdvRHBRUEZFSEo1T2FEMVA3U3JadXo3WUpmVGNJSWV0VkVCdHdwQUlXSkUrZm1hdDVHc1hMZ1RBU3RVWlRIZThZNEhtS3pab2d1dnZnTEtsdUJLUjczZmpFLytLZlVRbkx0d0RkdGNuTUh2aHp6L0FIcUxRSFhIRk5LbEQ2Z015SEJBSkZDSzE5eFFWdGk2QldBSkNnWjY5ZVBqVktocVpjTHlDeW04VTZESUNWZ2srY0Rta21rb2x3eVJ0YkNMd0JJZ0pXNEFab3VvUzJ2RHZLSEVrOVZQa2dFZWdvbDdhdDJ2YlNobEtJWkN0c21GS0ovR2lORVFKV24xTlVURzBlTHI4YURMa1FTVEE0RTBBMEFod2crN0E2VUVsYWZDUDkwWndhQnFVN2NmUG5wUU54bkVnNGswRENNazlCbko1OUtERXdCeVlpZ0lBSkE2SDFvSHJTQWtjOFVHSlNJaFVHUjlLQWlVcGpnQW40MEJtVURZbVJucFFTME5uYk9ZK25TZ1lzU1JCL0dnT2lRbUV3c3htS0E3YVJ0eWdLeWVSbWc5VjZscExsMDZUZFd6N2kyMGJONjBqM1ptQWV1YXVDdGYwQkplVE5nNjJ0Q0JLUUFjbnI4OFlvSzEvcysyb3FEakR3Q3pCS1d3U1BqbnpvSUMrejdZZU1zWFFtUUU5eWNmR0RtcGtXb2J2WitGdUFvdXNrcUgzU2g4em1tUk5RaDJlVzQ0VklhdkVwalAzUzRBK05YQTlQWk45eGFpeGJYNVBSYmFGQWlmWEdhV1R6RmxISFk2Rk5xTnBkT3VFRWVNWjlUSlZpcG5vMm5mN0hObFN3aTFHN21YRk5pUFByVGp3bGFiN1VkRGEwKzBDa3B0MHBnRVE2Q280UGtQaFVIR2tKQktJODZvc0cyb0lKQUlQTVp6UU51L2RXUUJ4ejA1NlVBbTA3SEVnKzhPVkF6UVNsN2kyZ0VJQ1JqSE9UMW9BYkNKSVB4enhRTlVuT0JKb0dFVHlJR2ZqUUx0QUdlUHBRSEtZQkltWUI0eFFOSUtnRE9Qam1nVnRJSkE4OFpvREpTUWlCQjlhQWpZQVFPWXhtWm9KU2VQRVRQUXh6L2VnYzZDcVZFeHdBZkwwb0hNd0UrRVRCa0VVRXBwYVFnQWlhRDJ5OHRydkhDR3k0U25Fb2dmRE5hMW5mQ3N1YmdKRXBzMm9JS2dWR0t5MGdYTncrcEpjVjlqYWJHUW1SajhxQ3RmMUFKZVVPL3R0d1daS1lKNCtOQ29GMXFoSk0zYkFPSWxSS2dma0tuOUVCZXFIZWUrdjkrNGtvaHRaUDBBcTlDSis4UVZIL1h2cVFTSUNHRCtFOUtuOEljM2V0R1VkL2ZnbE85UVFsS1JIeEpxY2Vsd291MnRvS25OU0tjNER5RXdhdjhBRXJuM3Ridm1WMk8xS0wwN1JFdXZvVk9QU2c0b3lDWEVEMWptcUxKQ2R6U3BnUjVabWdqM1JsSzVuNUNLQmlkdmZrcUpDY1lIV2dQdUNreURnbmhJZ1VEUWtxVVNKaWNSUU5YdVBDVEhVbklvQkw0eVQ5S0J5U1FmUC9PbEJMWldsTWxhaUJ3UkUwQVZESkFHSmtFOWFCVzhxRWpqclFGVnRBT2VlWUZBclJCU0FyR0tDWTN1M0pVTUVSSi83VUJ5NmhTRkFJaFN1SXlQV2dHSEVxeWttWkVEZ2dVQjJFU2pDVW5QSlVmN1VIc0hWeUVFOTAwb0VLSmdJSm5QVE5XVnJocnp6enExZ0cxZkhKamJVTVY3djJrb0pSWVBMVVV4RzNhUm55cW5DQVdkWFJJYjAxU1VLaE9TRXlQbldlUzRqS1kxUlNzczJpRnh0LzhBVVNmb0RVblp3alhGbHFnQklmczBna1FxSmc5Uk5YYVhFWWFicUJYNHJ1eUtTSmp1emdlWEZTMUlNblIzOXdLdFNhWlVZOTIzSkpIbE1DaTFKdDlNV2xMYmYyOHFNNVVMVTVINGRSUkwyMEQycWFldTNiVVRldlBCU1lPNXNKQWdEMXF4SEpHQjk2Z0U5ZVBXcUxGa0FtVkFnZVFNVUFydG9ndVFrN2drbVBLZ2pOcFZ1ek82QURQblFGS0JzVWVNY3hRUFNNeVJuaWFCaWhJZ3pKeWFBSlRPQ1B3b0ZUNm5CTkJNYlFGcGtyZ2ZyOGFCWEVuaWZEME5BeE1EM2djOHpRS3MvakdQS2dHbFh1U1lCb0piRHBHMkZtT1lvQzk2U3VVQ0VyRXdrSEZBamFmRWxTYzR6NlVGZ3krdERZQ0FJK0FvYTljWHIxektrb3VVNVBFS3hOQnJ0N2RYdTljUE5GQWtBS2NJTS9DbUN1ZXU3ODRVR2k0bit2Y1RuclBXbUFOeGZYcWRvTENGek1FeDg0enpVeXJVVzQxYStjUWhwOWh4VGFQQzJudkkyejVFVTUxRUp5NmZkU1hGMnE1Vndkd0VINjAwUWU5Y0t5TzR1a2s3b0ljRXlQT25mS3cwSlVwc0xXemRqcVpjQmtlVTBRVmtObDFLQmF2QXJWdFNWUFJKTVJPZk9talJmYU9XQ2h3SVplYmRTRGxheG1JK3ZXcm81d2xKRnlrNUlWSmtmaWFDZTJJa2pKaVNmT2dIZEpKU3VaamFmS2dqTXdIRlRNY1RRU0NESlVtVDhmMW9CRkJpRlJua2lnYTV3QlB3b0I1S3VvZ3h6UUtsT1J6SEJvSmFOeWhDU1lIbFFLNENFeU13ZWtpZ0VFcWtpU1I4YUJ5Z290a0RtZXBvQWhNSkJtQUJFelFUclh5UHhTZjg2VUdHU280Nm1jMERtTXJLU1kyK3VLQ1VncUNZVE1EeU5CNjl2RXZyUnU3Z2hFS3hKbUo4L2puOEswektDdTIza3JTMkZiMGhaVnhzSkJ4a1ZGVjF3aGFFQXBhSWc0MnJCM1ZGVnkwRUpsVERwakFWUE1uSXB5dFFMcGpkdWxwd0dkb0pTREE4dUtJQTViVzVXWVpXa0RrS2pyMG40elFWeFlZL2hwN3dLVGtnSVNxSTU0NlU3RG1XMnlrUjN3QTZsb1NNWUhHYW1VTVdsbExxQ1ZQays5dERRRUU0L1NsNEhPZmFhVU5yaENIUEdaKzhRQVp3UDBwQno5aFAzdU9VazRqTVZSYVc2VXFSNzJPREhOQXg5cEs3ZDhJRzVXMGovUFdncjJOeE80aUZFREIvT2dtSWJJVE1uMVB4b0doczdVd1lIVUdnRTgzdVBQaUV6NVVBMW9HTUtBbmlnWWtldkhTZ2xKQkN1aGpQRkFSU0FHd1VreFFEUWd3QklrZzBDcVJ6eEhrYUFHMHdEQStmbFFUTE5DVllJSW5neE5BVjRqd2dnbWVCSDFuMW9HSWNsU29KK1BOQk5aSjdzU21mZ1lvUGFkdzVzQ0IzaTlqZ3lFT0R6eDFyVmwwUkZYUnVFUWdPcFVFUnRMZzU4L3hySUNwZ0tiN3dKdUVxbFNSM1lUMEhNMEVaelNkcDJPTlhJUXZ4Q0d3WnhrbWkwcnVtRnhRVzIxZXFHREJaQlB6eFJsRmMwZEliQVZiWFNUL3hEYWJpWkk2MDFVWnJTV1VwVWxEVjZGTnFJSk5rT3ZUMWswR0d6c0xaOFcrcUxjc0VPRXQyMXlwZ2xwemR3aFpqd0xIa2NIb2FBcU94dHM4dFNYYjUxSlFTWURKZ0dlU1lvT0ZlMjdUV3RMMUZ0bG01VzZkOGJlN2lPWi96MXFEbURDUVgyazdlUW9UaXFMVzNRQWtqQmxKRVJ4UVp0bGFrZ1NWSTRIWG5OQkF0Mnh1S1NvUU9CejBFMEUwTVlKVUR0Z1NSbWdBdHBYQkVuekZBSmFDQ0lCZ2VlYUJpbXBXWXlRZVU1b0doc0QzaEN2S09JNG9KTFVKVnRBeHhuNFVEMUpUNlNBQnRJNjBBWVNJQ3VJNDlLQjZnUW1JeHlCUUJPV3hqd2dtS0E5dWRxeHRqSFU5UlFaY0pWMzVjVktrcDQzRE9ldjBvSTI3Wm1NQTUrRkJQYWNQZHA2aU1kS0QzUmJzdE9hcW9PTm9VQTBDQXBJTVpWL1lWMCtYVEU3aGpscGI3U2ZzN1U3bFoyQ29zQzFlMlkrejNYM0xlQ1FQQ01Zb3FFd2xQZW9FQ053RVIvVFV5YUpxUENmRGpQVDRVdmNVWmhhdnVSdVZHMWVKK0ZWQTdsMXd1cUJjV1FFbU1uK21zK0ZiTllJUmNXSmJ1RXBkYldraFNGamNGQ09DRHpSRlRldG9Ta2JVSkgzZ0dCMHhXaDVaL2FVU0U2NVlGSUFLZ3FTQnpXYXJqOXY4QXhMZjRmclVGNGdmY0U5ZHMvaFFGNHVER0ozVEhYRkJYV3Y4QUFkUFdVNStSb0xJQUJSZ0RqOUtDTy94OEZmb0tBSXlYcHpDZjdVQ1hZQWFWQUF5YUNFNzc1LzVnS0NRUEVTRlpHNDgwQ3lmQm5tWit0Qml3SlNZRXduOGpRWWY0S3ZoUVIydjRhLzhBbU5BYTN3MHNqa0NnVjhraFpKTWtEODZDR3NueFo2VUVrT0xTbElTdFFFY0EwSC8vMlE9PVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvTGVtYWl0cmUuanBnXG4gKiogbW9kdWxlIGlkID0gMjk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvL2dCS1JtbHNaU0J6YjNWeVkyVTZJR2gwZEhBNkx5OWpiMjF0YjI1ekxuZHBhMmx0WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2sxdmRHaGxjbFJsY21WellWOHdPVFF1YW5Cbi85c0FRd0FHQkFVR0JRUUdCZ1VHQndjR0NBb1FDZ29KQ1FvVURnOE1FQmNVR0JnWEZCWVdHaDBsSHhvYkl4d1dGaUFzSUNNbUp5a3FLUmtmTFRBdEtEQWxLQ2tvLzlzQVF3RUhCd2NLQ0FvVENnb1RLQm9XR2lnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ28vOEFBRVFnQTVRRGNBd0VpQUFJUkFRTVJBZi9FQUIwQUFBQUhBUUVCQUFBQUFBQUFBQUFBQUFBQkFnTUZCZ2NFQ0FuL3hBQkRFQUFCQWdRRUF3VUZCUVlGQXdVQUFBQUJBZ01BQkFVUkJoSWhNVUZSWVFjVEluR0JGREtSb2JFSUZTTkN3VE5EVW1MUjRSWWtjb0x3b3NMaU5IT1NzdkgveEFBYkFRQUNBd0VCQVFBQUFBQUFBQUFBQUFBQ0F3RUVCUUFHQi8vRUFESVJBQUlDQVFRQkFnUUZBZ2NCQUFBQUFBQUJBaEVEQkJJaE1VRVRVUVVpTXZBamNaSEI0V0dCQmhRa1FsS3gwZkgvMmdBTUF3RUFBaEVERVFBL0FMMTJhMTVpWWxsVXcrQmN2b2tFWmREdHBGOUhuR1ZZbnB6a2tpUXhEU0VudkdrRHZVSi9PamlQMWk5NGNyVFZZcGpNeXl2TUZKQk9zWURScDNiZGs2bllRWUJIQ0dFdjJoWWVHc1JSdzVxTmpwRWJpU2hTZUpLUzdUYWdtNkhOVXFHaW0xY0ZBODQ3bFBJU2tyY1VsQ0J1b213QTZtTWM3VU8yV24wbVhtS2ZoZHdUZFNJS1ZUUTFhWjUyL2lNTXg0NVRkUklsTlE1WmoxY1dpbXo4N0s5K0podVdlV3lIMERSZVUydmFHS1ZYSlZWMHU2RkovTnhpaUNwVERUanRuTTRXc3FXRjZoUkoxSmg2V25KVnhYNDJaazIzR29qVGVsNDVEeGEyNkx4TllnbHMyVUp2cHBsZ1NkZm1Wb2VUTDVoZnczSjJKaW55eTVhNXpxV3UvdW0yOFNNbE9ld3N1WjBnTnExQjNNQThFVXFTSCt2S1hiNExIV3B0bVh3MzdIY0V1cVNiY1NvRzVNUFlTN1NNU1lmQlpwdFVlN2hwWGhZZS9FYnR5c2R2U00vbko5YzNNWjFtd0dpRTMyRUlsbkNsMG4rS0hSMDZVYWx5WjJmUDZrcmo0UFE4ajIvMW51Lzh6U3BCODhTaGFrSDRheFg2OTJyVml0dWs1bFNqUi9LMnEvempMSmR3aFhROEkyYnNQN09Hc1JQL0FIN1gyU3Vpc0xzeXdyUVRiZzN2L0luanpPbkF3bWVMRmpXNW9HRXBTNFFXQ3NKWXB4cGxtNU5UMHRJRS93RHJacFJTaFgrZ2JyOU5Pc2JkaGJzNkZCY2JkL3hEVkgzUjc0QVFsdFgrMGdrZkdMaTAra05vUTJoQ0cwZ0pRbEFzQUJzQU9VUEJaUEw2eFRiM0RXNUlNTUpHeTEzNmdRc0pValk1aEJCVUhtc05ZNVJBZG5KV3A2WWxKRng2WERhZTdTVnJLd1RZQWE2RGVQS0hhcDJ0MWZGS0hhZEpQcWxxUUZFS0RmaFUvYitMaUIwK01ldWlRYmtIV01iN2FPeWFYeE93OVZzUE50eTFkU015MmtnSlJPZER5WHlQSGpEOFRTbDh3TGphNFBJTTJyTVRmNnhIdVd2cHRFclVXWFplWWRZbUcxdFBOcUtGb1dteWtxR2hCSEF4Rk9hS1BLTlNIUldZeXJlQzNnMTZ3UjR3WkozVVNvTHBOV2xaNURZY0xLcjVDYlpoYTFyeGM1cnRQbkMyVXlWTmwyRm44N2poY3Q2YVJueGdjZG9DV0tFM2NrR3B5WENaMDFHZG1hbE9PemM4OHA1OXozbG42QWNJNXIyM2dlY0hZSGpERWt1RUEzN252S2tOQmRCbFduUmRLbVJlL1dLVExLZHdYaWJ1VlgrNnB4ZmdQQnRaNGVSaTd5TTdKcXBERXkxTk1HVVMwazk3bkFUWURlOFpYMm85cGVIbktZOVRxYW43em16b0hVNk5Obm5tNGtkSTg3SEhLZkNSb1Rrazdac3Z0RFFsVE1MZFEyd0JtSzFxQUFIVXhuZUxPMlBEMUV6czA4cXFzMm5Tek9qWVBWZkgwdkhuU3ZZdXJGWVlReFB6NzdzczJMSlp2WkE5QnY2eFhYWFNUdnB5RVhjZWk4eks4ODcvQU5wZHNiZG8xZHhTNm9UczBXWk81eXlqQktVQWRlS3ZXS004OWZjdzJ0ZGhyOElaY09vMWkvREdvcWtWbkp2c0RhbXk0UStDRUsvTU4wSG4xOG9lcWxObUtjNDJIMHBVMjZuTzA4ZzNRNG5tRCtrY2gzaVRwbFhWTFNia2pOTmlhcHJ4dXBsVzdhdjRrSGdmckJ5dGN4Q1ZlUzBkbVRrbXRxb01UaVpaUzdwV2p2clh0YTJsNGxNVTFHbU1VcVpsMHpFc0hIRWxJYllzU2ZoR2VUMU9VdzAzTk5manlUcHMyOWJqL0NvY0ZRd2hGaGNKSHdoSG94bExmWWJ5TlIyaHNqVk9ieWp0UU5pTjd4ekkxVUxiWHZIZTBtNDZRNlF0RnM3UE1Mek9MOFR5bEtsc3lXMW5QTU9qOTB5UGVVZm9PcEVlenBGbVVwMGhMU2tvMEdaR1dRbGxsdEkwQ1JwL3puR1Y5Z3VHL3VMQkFxVHFDSitza082alZEQTl3ZXVxdlVScVRTVXFRWHBwV1Jsc2FBNlg2eGxacDc1ZjBMdU9PMUVrek1oU0ZLU2xLVURkU3pvQnpqbVRYRzFPRkxLSFhramRZOEtmUWJ4VWEvaVNVU2dxbkpscVRwNmRnNHJMbjlOekVkSllwbjZpbnU4TFVHWm0wSFFURXgrQXo1NjZtSmpoYlZuTnF6VG1wdnZMRW9LUE13NkhDVG9DZlNNcm5aMnNTM2l4QmpXa1VSUEZtVVFsU3gwdXJYNVJIL2UrSEhENDhhNHNtMWNWeTZGNWZraTBXSTZXL3dENHhUbWtiSVZxRy96aExpZ3BKemVVWkd4VnFPbFFFbjJpVnFUYy9LbW9Na3AvNmtpTEZJMURFemJYZnlreFI4VXlRRjFLazFobCszbGNwSmducFd2dHIvdmdoWkV6S1B0UDRPWlEwemltU1FFdWxhWmVkQUZzOS9jY1BYVEtlZWtlYTVpNVVlWWoyeGpsK1N4cGdDdnlNcWwxRTZKZFdhVmZSa2VhY1Q0a2hTVDFHaEdoanhOTUc2czF1R29oMkZOZksvQXZKeTdReXJuQ1lVZFJDZUVXQUVHWUtERUVkbzQ2eFZyd1Yra0JKMDlZVjYyamlDYVZQekhzaVpmdm5lNUdvYXpuSjhObzVsUEZYR0VrRlMwb1NDVnFOa3BBdVNlUUVPek1qTlNxRXJtcFdZWlF2VkNuR3lBZldFTGFoNnhUbEZ5U3RJWUtvYmRWdmZicEJxc2RpQ09ZaGtrazYzaGlFeVZCbFlQRFdHenFZTzQ2UWs3NndRSVIyRUgxZ0hZd0U2NkdKSkpPaVZaZE1XNDI0MG1aa0h4bG1KVmZ1ckhNSGdvY0RIYlVLS2dTeXFuUW5WVGxML09rL3RaYitWeFAvY05JZ0k3YVRVWnFtVGFabVFlTFR5ZExqWlE1RWJFZElWS0RUM1I3Q1V2REVvQUswa2NmbkYzN004TUt4YmpDbjBvZ2lXV3J2WmxZL0t5alZmeDBIckVlaVdrTVNLQzZlbHFuVm5kVW9UWm1ZUE5zbjNWZnltTnUrenRTUHV1aVZxcXp6S21abVlmRWtuT2toU0cyd0ZMc09xaVBoQ011WDVhNlkzSERtL0J0a3V5akpueUlabEdVaEtBU0VvU2dhQzU0QUFSUWNhMTZlcWhNdlI1bG1tMGhzM21Lck5DM2VXNE5JUDVSek8vQ0k3RXVMYTlYcXpPVW1sVTFpVWtaREtGT1RibGtDNHVGRUQzemF4NUNLcE4xQ2kwOThUTlVtbDRrcWlEWkNEWk1zMHIrVkk4UDFNTHc0SGR0REpUTEhoMlJrM0hSTVVHbFRGZm5kelZxcXZLeUR6VG00ZjZSNnc1V3FyVG0zRnQ0dHhqTVRXVTIrN0tDMlVOK1JXTlQ4WXBGYnhIWEsybnU1aDR0TUgzWlp2d05KSFVEVlhyREZQb1Rpd2xiWXNiRDNsaEkrSklBaThzRmZOa2RmZnYvQU9DZDk4UlJhV01XME9uYTRld1l3aTJ6OVFXTXg2MjFQemg5WGFkaUc0RENhZExwNEpibDFLSHpNUjBsZ3VjZlJtWFB5REtPazAzOWJtSkJuQVNyMkZTazFxUEh2d3I2R0dLV21qM3orckJheXNmYjdUcTB0SlRQeVZNbld1S1hHQ245VERrdFdzSXp6NlhabW1UZUhwNG53emxQY3lwQjVuTHc4eEMwOW5kUmNSYVhtWlZ5KzNpSStjUk5kd1RYNk5LcW1KeVN2TERVdXRMQ3ducWJiUTZQK1huOUxwL29MZnF4NzVMZzdOVERjL0tPMVNaWm5TbEJjbEt1eUFQYVdCcXRwMERUTUI0aDVSNDBxRHFYcHA5eHZSQzNGcVNPaFVTUGxHM1ZuRVM2TmdpdlN4VWJQSUNaWkovSTZzNUZXNWVFaytrWVN2UVc0V2l2TEhzbTBGdXRJSk91bGpDUnRyZldEQjhYV0FSWTI0eHh3U2Q5ZG9WYS9XRXdvYXB2SEVNSk8vbkM3bnA2d2c2V01MQjYyamptYWJnaGRNWWsrOFJNeXJyNmxBdU1UTExmZU5PV3RkQ2pxUjAraHZGdlM2c2xTa3VxRnhycmNmT0dwSmltRngyWG1xYkl5U2dRR2tobE8zbmJlRVROTG1HbHFXeTRGSkFOa3IxU2ZJN2lQUDVKS2NtejZ6OFB4dlQ0SXdqVHIydjkvdjJJTEdsRWJtcEp0eVRwcUhaMVpzSEVLRFFBSTk0blFLNUFIbkdYVGpEc3JNT01URFpiZGJWWmFGRFVHTklybGVxbERRMDRsaHR5VW1CYStjcVFWY1VxQkhMNDZ4bXMyOTM4eTg3M2JiV2RSVmthR1ZDYjhBT0FqUzBhbnRwOUhqZjhTUFR5eTdvSnFmbFZTL1BybS9leHNubkJYdkF2QkgxaThlWUJCcDBJTittMEE4YmJ3WEFnUnh3NWJTRGJ0bk4rTUVueEpCdnJDMER4RHJvYlJ4eDJNV0YxRWFKOFhXUFlHRHBCK21ZTW9rcE9yV3VZUkxKZGVLbFhKV29aaUNlbHdQU1BLdUZaUkUvaUdseWFnVklmbTJXMURtQ3NBL0tQWmRUdG5YbDBGejhJbzZqNW5SWnc4S3pBZTErWmZSak54TFNuUFp2WjJrdXRoUnlGVmliMjJKc1JFREsrRW9XdEtybllBZU1qa2xQQWRZc25hUE1CV002dXlsUnpKYmx6WWNEa3NmMGc4THk2TzdjenBTWERsSlhiVWkwRmsxdnBRcExrZGgwaXlTdHZnT2dVeGMrc21aVXRoby91a0h4ZjdsZm9Jc016UldKZVhTbVRrcFJSRy9mTjMwODk0YlFuMlowRkY4bXh5bUpSbWJTdE5zMWxiYVJpNXRSa3l5M1NaczRjTU1hMnBVWjNpU2pUS2xxY1d4SXJVRGJ1aTBlN1NPbHVQVXhFTjBLeWtxWVlaN3pRSHV6NGJubHhqVkg1R1ptSENHWmdOTTI5MVRZVmJ5dnJETEZJbFdsRU4zTGlWV1c1WUVrOHVrTmpxR28wVFBDcnNyMHhTUkkwbGMyWGxJRGFMZ2haVC93eEEwVEgySzVDb29OS3JLaTFleXBOMWZmTkxUeFNwS2lmbGFOTnFrZ21hcFMyYldCdGJ6NFJVNUxERXJQdXFSTU9XZUNnVFpzSlVDRHA1MmdzT1pSVGJGWk1MeWNGQjdZS216TnprbWlUYU1zaDNOTU95dDc5eXZRWmI4cjN0ME1aMGVzVHVPcHRNN2lxcExRZncyM2xObzF2b2sydjZrRXhBR056RzI0cHYyUFBaRWxOMTBGeGhhdFJlRytJTU9DREFZZ3dhRHJ2QTgvbkJjWTRrVVJvZUVHa0FpQUxHL1dFcFVRTGF4d0pzMkthdTZxWnFFNm1YYis2VzMzR2ZhbEwzV2tDNFNPWlVkUFdLTTVqYXJGZDIzVU5wdGJMYk5mMU1heFZNSXlrNWdtZVpTMkpaSmJVL0tsUjl3ZzVzNmllS3JhOUxSNThKdUJHWG8vU3o3cVhUTnJKOFIxdU9NVnZhVmNWeDErUlpwN0ZiczVRSDZmTk5wVzQ2cEpEZ3NBbXh2Y2ZTMFZna1gzaE40QmpRaGpqRGlKUjFPcXk2cHFXVjIwcS9zR0RwQjM2d2owZ2Vlc01LdEM3anlnQTY3d2dSMFMwbzlNL3NrZUhpdFJza2VzY2RRbHNnS0lOb2VZWlc2cXpLQ3NqZTNEMWp2WnA4dXdFcWR2TU9jaG9pLzFNUEdaQWJVbHRBU2dmbFRvUGxFZmtGdDl5d2RuYktaZkcxQWNtRnBTRXp6UnlnM0oxNDhvOVl1cVM0TGtqeEhYb09NZUs1ZWJkWWRiZFpPVnhsUVdnMjJVazNFZW9xMVhzdUNIYW8zb3FZbGtxYUE0cmRTQUFQVW40UlZ5UWJtbDdqWVNXMzhqSVhIM2F6aVBFbFVzVk5PTzUraVFWRktma2tSUDBoWVlkYkJOZ3BGcmRSRS9nL0RhSlBENzByTk41SHBzWm5qeEFJc2tlaCtaaUJuSlYyVlV0aDFKUyt5cXg4eHhpcnJvcmR4MFg5REsxVDdKeDRsVE9kSTIxQXZ1WUtRQkFTNkYyRnJGTjl5TnpEZExjRHpiYTFId3BOMUo0WEVPVFNrdXRPSmxWaEIwS2xsUUJGOTdSbDF6UnF4ZkZzNnB1YWVkWVczSnFVMmtEeE9KM0J0c09zTzBpYWsvWWtOeTc2QThBQ3E1MUt1TnhFZEx6YUdtUWhLWmtFYUZIY0VnaUl1b0lrWnRhVktkUkx6S0ZaZ3B4QlFiamxjUWFqZkFMazI3THZQdkpia0huZ29YU2tFQUhqY0NLbGp2RmJXRzZlcGJTa0dkbUVFTUl0cmYrSTlCSEhWWjlNaFRselUwNnQyWFpBZFdwQ2haUnY0VWpxVEdNWWtxOHhYS3E5T3pXaWwrRkNBYmh0QTJTUCtieFowdW05U1Z2cEZYVmF2MDRWSHRrUytvcVVwU2xaaVRjazhUeE1NR0ZLaEJHb2pkWEJnQTA0N3dzSGErblNHanZDZ1k0NnJGbUVtREkwRUpNU2NoU0RyQ3lrSzEwRU5DSEVuVGUwY1EwYloyZ1NkVnFVb21ucW5uR0pDV0pTdHBzYjY3cUIxSTJ0cmJwR1MxR2x1eTg4NDA0MlphWGJBVVhWS3pqTHRlL0VrOEJ4alhhbS9PUDFPWW1ucHdMVStsTm04b0xZdHA0U09GckMydTBaZmllZG1Lak5NU0hzVHpjeExxVU83QnpGZDdXSVNPblV4azZOeWo4c2VnOG1TVTV1M1pBdnFRcFo3cEJRMk5FZ201UFVubkRWeGFKaG1sSmFmN3FiS25wb0FxTXBMcUYwQWNYSFBkUUJ4M1BPMFJjeUVCOVliS1NqbWdFSjlMNjI2bU5HTWsrRUNObUJmYUM0R3dpUnByQ1FrekxvQkE5d0hpZWNNc2xjajBuSU50bzcyZDFKMmEyK1A4QVNPaDZjOTFJSGhBc0FOaDBBamtlbUE0cnhXM3VxNU9zTVp4cmJRWDJKaVZHK3duSkxvNkhKaFdwSGg2bldFdHU2V3ZZRWVVYzVVbFJPMTc2UWJaT2F3QmlhQWJIMkQ0ckhuRytZRFE3aVRDZENsM3ZGSzA1dHdyT3ZpZENpbHNmN1U2K29qQW1SWjYwZW9Pd2FYRG5ad2xkdFV6cnFmVE1EK3NMblNhWVVQS0xRekxxdWdtMXkyRkMreHZ1SWljWDBBenphWnlTVGVaUU1xa2JGeEk0ZjZoODR1RHN0L2xXRkFmc3lVSHlKdC9TRU9JSzJsRTVjd0ZpZWZuRlRMRlpGeVdjYzNqZG94dWxQS1ljZUNrS1A1U2s2RUhscnRFZzJ0cGFFSVNpeXhmVUtJdHB0MWk0VmFuTXpBY1creVVyQXQzellBV1A2K3NWYVNvYzVjcE02WGJuMzNVaTRIWEtCR2JMVHl2ZzA0YXVOY2dhYW1pblFCWUd3Qi80RERUaVp2dlQzNlhGQlIwQlNJanFYWEUxQ2VWSlNLaTdNSWM3ckpsSXViMkZqdFl4RDQ3cjFRYWtwNlNwa3M2cDFnV25acG9aa3k2Q2JHeEdtK2wrRWREU1pYS3R0RXkxV0tNYlVpblkrcnlLbk5mZDhqbFJJU3poTjBmdlhOaW8rV29IcVlvN3gxTjk0NkhFNUZDMEljQVdrYmNoRzNpeHJISGFqRnl6ZVNXNW5DYmNZYlZEaWhsVVJiYmVHeWRJWUtRUjMwaFFPa0pHMjhBR0lSdzRDT0kwZ2phQWs2Nndkb0k0UjYydENncXcxK2tGYmVFa2tIUzBjY2JTNndoaFBjdE91T2tpNWNJRmlvNjI2SGpZeFZhMEpwcGJ5dzRpVGtsSkhmVGFSZDFmOG5NY290Z25HWnh0d1RiYnpFcWx3bEswTEtWTEtScG1Kdm0xNERiNFJBMVNzMDlwbGJWVEJXMDc0QzBQR29wdnZ3MjNqRXhib3ZoV016eGp1M1I4L2YyeWxyZGVubVZ5ZEpsbE5TS1BFc1hBelcvTTZzNmVoTmhFUzRuSXNvQzBydCtaSnVQanhpenlMekZRS25xb3BLYUpMT3BSN0hMT2hrcUtyaEt6NFQ0UWJYVVJmV3cxaUxybExWSXI3eGhxWk1wM2kyZThjUjRDNGs2cFFvSHhqS1VtK20vcWRPRWtudEFTZFdSaUVsYXdsT3BKc0k3NXQyNlV0b3loS2ZEWVJ4eTF3ck1OeWJDRk9pemlsQ3dQVXhZU091a0RTKytnNHdQTDR3a0t1ZVd1dG9Wc2Q3d2FBRWk0dWJqaHhoeEJzb1dQV0dsOHhEako4WEhXT09PMXBObkVIZS9HUFZuMmJVZC8yY3piZGg0S2c1bDYzU2t4NVVaM1QwTWVxL3NzQlp3ZlZDUmRDYWhZZEQzYVlUa0RnelNBMEZ0T29WeGNJdDVpOGNiVFpiY1huc0xKc3E0djZ4TmxrQ1ltTXUxMHErc0tRd2t6Q1NRUUZlRTI4b1RHSXh5SzNPeVNKcGxRUXRTVkpHWWNSRkt4bzQ1UzZBNnBKSHRUL3dDRzFiZlVha2VRalVaNmdKV2xTbTFPRFFqTGZRbU1tN1NwdGdOc1N5VUlMN1F5b081R1llTDAwaG1QQjZqMm9DV1ZSVnN4Mm1KY2tIc2lIMU1MbUp4bGxMb1BpUWtYSzFENHhlOFUxbVdWWEpPa3NOcFRoRUlNbTZKUTVYWDBGUXpFSzB2Y2pZYm1LaXNwUlhXRkJvdW9sVXFXVUQ4eEkyK2dqZmNVWVlicVBaMlpLV1pRMDQzS29jWUFUN2ppVWhTYmVvaTdxOFhwL0xIN29SaHlidVdlUzhVVWxGTW5uR21IQzR3VkxMT2NXY1NnS0lBV25ncTF1a1FSNC9JeHQvYmRLbXAwRENXS2U2TFQwM0ttU20wa1dJZGIxRi9uR0pPcHlMSTVSVXh1MG1PWnlxSGVKMDk0UXdiYmlPaFJ5dTNISFdHNWhBU2N3MEI1UTFvR3hrSHFid0wvQUFnaEI3N1FzSUFPb3NZV0RwRFlPZ2hTVHJCSWdYeDBndmo2UXE5K3NHQVR0SEVKbTFTc2hJek00SFoxYjZrRUFKYUNoa1BRN0cyMmdJaU94VGc2a1ZDY0UwaW91eWdLQjRFU3VjcUF2WUVBZ2hYTFEzR3NTOUxwejdUQ1hKcWJzOHNuT2dBS0NkdGI3MzMrVVNFelU1TkVzRXkwdzJtN3FXM080YUM4b1ZwcUwrN2JNYmJYQTRtTUNHU1VaZksralJqZ2tzYjlUaS8xWmwwL2hkNlJrblhwV1Z0TnlqcGFtbTVncGNVbFdhMW13THBYcHFkT09seHJIQlJhcE5FVkZpZnE4M0xGY3Rab3FtRnBWM2lVNVcwMkFKSXlLVWkzaEFDdDlMSFVLblUyS1czbmVjUm5BN2xwR1Vya3pja0Z6TGtPWFlsUVZxT1JqTmNWVElxdE5rcDN2a3ZxWldxV3plMm9KeTNLaGxZUDRpUmMrOFNvY0w3QWFHS2J5Y1NYOXlwS0tqMFIxWmw2ZExUNlUweWFEN0tVRE5sekZJVUFBYktVQm1CTnpzTGJkWWpGV0pKdGZwQkk5eFI1bTBDK21zYUVWU29VMkpOMG5VYndhZU8vbENUOGVVRURZMmdpQnhYdW5qYUNhOTYzemhRdVlRM2NMMGlTQ1ZsNzVVZjZyYWphUFZ2MlhmQmdpb0d5dGFrclhoYnUweDVVbGgrRzMxSmoxdDltMWtOZG1xM3RQeEo5Ni9Pd0NSK2tLeWRrcm8xRmtkNDdOcUk0SkgxZzFJOTVOdGR3ZVJoeW1lT1htWFA0bkxlZ0ZvWW5YQTI0Q1RwNXdtS0piT1BFRlM3dVRVc3VCQktiM09nVHBxVEhuakVOUSs4YW0vTmhSVTBrNVd5ZExnY2ZVbUx6Mm1WbGJrNC9TV0ZlRXFDblNEc0NMNWYxTVFVMVJtNWZzNVRVVmdGNnBUeVdFNmU0MDNjbTNVcUh5alowZUpZMHB2ejBVYzg5MXhYZ2hPenFtZTE0cmtWT0l1WG5pcXl2NFFrbjlJOUxTa3FudVFoYWIyUW42Umh2WmF4bnhuVHlQeUpjV2Y4QTRIK3NlaEcwQkxxZ1JZWkVneFgrSVNySWt2WVpwbDhoblhiamh4dXJkbUZUYWwya0pka1VpY1pDVTIxUWJxdGJta21QRTg2Z0JZT2hDaHBIMGNxRXNpYWtYR0hCZEQ2Rk5LSE1LQkg2eDg4cTdKcWtweWFsRmdwWEx2TFpJUERLb2lLRVdXa1FMbXFRZDdHMEVEZEJCTnhhSEZnNVZEY2Evd0Q3REtDUmM2NkNMS0JZd3RPVldYcnZDZUVQT0M2UVJ2dERSSHBDNUttRXVVRlkrY0M5emVBT2tIMDFpRGdJTm9jQnZEWStFR0xIaGVKT05hWk5ScXp5UTluYmtzMTNDUEFrL3FxSitWcEVwSWxTMjI4N3RpTzlXYm5VNmdjaERNdE5aWE83ZDhEcVJxaEdaU2hibUxYaERsZnByRjJsdXVCU1RZb0RSSkI4dDQ4OVBmTGlLNE52QkhEQjc4a2s1ZjFaVGUwNzJuN3dacUNYWEVxV2hVc3ZLcys2YitIeUlLaDFpZ2cySjZScGVOWm1WcVZIZVRMOTkzaWJMVG5ZV2k5dXBGdWNab2tYTnZwR3JvMjNCSitDanJZeFdTNDlNWGZ3aE9tbXNGYzg0Q2pkVjRUeWk4VWhlWThONEpWOWVjQVFlL0NKN0lFb1VkaERtenNNblJVT3A5OFJ5OWlHVEVvRGxidnpKTWV5ZXgyWCs2T3kya0pjdUM5TEdZVmNmbVdvcUgxRWVPYWUwWDNHV2tlODRRMk9ZS2piOVk5eFV0Z0pSSnlUZWtwSnRObzg4b0NZQ1owZWkxMGhvdFUxcEt2ZUtibnpNVkRIOVhGSGxWT0hLVmcyUW0vdks0RCtzWEp4MU12SjNWYmJUU01DeHhWMTF1dk9xYktsc01xN3BwS2RjeDJ1UE02UXpSWVBWbnowTHo1Tml2eUl3YlNWNGp4S2ZibGxUS0Vyblp0Wk9wU05UOFNRSWxjVGp1T3pEQmN0WWhicGRtTGREY2o1TEVTMkdhUXJEakdOMVB1QXpNdFNFcGNJMlF0YUZLS1I1YUR6amg3VExNMDdCMGlCWlRGTFNvZ2ptRUQvQUxUR242bnFab3BkTHI5UDVLampzeHR2ditmNEVkamN1WE1WdnVFYU5TcXJYNmtDTjFDZngxZ2JsR2wvT01qN0ZHclRWV21EK1ZEVFlKNWxSTWE2MmJ6cXdUc0xSbWZFSGVkbHJUcjhOQnpBL0FCNUVINXg0bSswRFNtcWRqeXBsbEdSYnN3c3JIQTNBVWsrZGlSNlI3Y21CL2wxL0dQSnYycVpMTGl0TXlCbzR3MDVmbjd5VDlCQ2NIS2toa3VHanoycTk5ZFRmYU9hOXI2eDFMQkNqWStMZU9RN3E4NGFpUlNkUnJzZU1JVU40VUNldG9KWE1iUk1sd2N1eHV4QXVZQTZEZUhPTnQrY0lVbFFKTUxmQVNFbStrR1BPQmZTREJOdHhBOEU4bzlCVmZEemxIZGRtblpWcVlaY1VGaC9LVkpTU0RhOTl1UG1iUnpzTFNrbnVHa3RaamV5UDZ4cXJoWjluWExyUUZOcUJTVUhXNE85NHpLdFU5ZEdxUGRhK3l1a2xsWjRqK0U5UkdIbHh0S3piMGJqRjdVcVpHVmx0Y3hLUElXVmVKSkdwM3VJeFFJVTB0eEN0Q2dsSjh4cEc1UDNVa25oYlNNa3hYTENVcTh6YloxUVhiZ0w3eGErSHlxVGlCOFNoY1ZMMklXQUFZSUdGQS9EckdzakdDc1JDZ2VjS2dyZ2NvTklFUTREYlNGdER4SjFJRUlVVTJzRERqQnNvSGUyc0Q1T2ZSZU96aW5xcW1NNlBLcHNjMDBsUnZwb254SC9BT3NleUdaYXFJUm5sMHlpY3d6V0pWeGp6WDltcWxHZnh5SmhTYmlUbEhIZjl5aUVqNm1QVk5kcWN0UTZPL096aXJNc0kyRzZqc0VqcVRZUUV1WFJIUlRjYjR3bnBPaUxwOHpKc056enlNamJyVGx3RTdGUkIxSDlZaWV5RERwbjZpcXF6TFlNdEtMeU1KSS9hUDhBOFhra2ZNamxGUGt4UFl6eEt0YnB5dU9YY2RVblZMRFNlQThob09aTWVncVF6TDRkd3puUWhMY3ZKeXluTFgyc0NvMzY5WXU1ZjlOaDlHUDFTN0swZnhaNzMwalA1eDFVMWhmRzh3a2t1VlNyb3B6Ui9pQVVoSDBLb2crMTE5SzhidlM2UGNsWmRwaEk0QVdLdis2Sitoc0tWUmV6K25LSDQxUnFLNnM4Q1B5b3pPWFB4VEZCeG5QKzNZdXJMN1JLKzhtMW9iQ2RTcktjZ3Q4SXNhWmZpdCtGZjdMOWhlWi9JbDkrL3dDNXAzWWxLM29kU21sRDlwTnBRazg4b0g2bU5IWTBtbHExMUkrY1UraktsY0RZR3BiTlNLaSt0V1pUYllCVTQ2cTZpQnJiVG4wamptc2Z1cHpHV3BpRUtWYXhlZUp0Ym9CK3NZT3MxZU5acE9UTlhUYVBMa3hyWWpRMzlXWExjb3duN1FOREZVZUFXMkNWMGFheUtJOTExcXpxZmtGRDFoMnRZaG5hbTYyOVVaNEFKQktFb09SQ2ZJQTc5VGVPUjJvZmVUS1V6VDAzTnRKYlcyTTRXNE1xMDVWVzVBZ2tlc1U4ZnhLRUpPNHVpOC9oR1NVVTl5czhqdW96V1VBZFJlT0ZWZ1RmZVBVY3ZnM0E3NENIYVBLdDY1YkZiamFoL3dCVjR5SHRvd3RROE0xeVRUaDJaVXRtWmFMampDbk01WklOaHFkYkhnRHlNVzlQclk1bnRTb1ZxTkJQRERlMm1qT000Qk84SG1CNFdoZVVGTU5FWlRydzR4ZGRvb2NCZzN1QnREbHVWNFpHbTBMU3ZhOEFuWkxUQXBQS0ViYVh0NlErbnhDNCtNV2loNEN4RFc2ZWlla1pFR1djSnlLY1dFWmdPSUI0ZFlHYzR3NWs2SmhHVTNVVlo2TDlwZGwzME12cUtrdUhLMjZCWXFWL0Fya2VSR2g2R0lySHJpRTBVdEZGMXAvRUtpQ1NramtlR2tUUmxmYVdIdmFVNVM0TXFDRldGN2l4SElnZ0gwaXVWMWFwMmtJVE1XRXk2bGFIVWhadUYySUl2dHY5UkZYSkJVMGl6REkxSk1xMGk2bDlxMXdRWXpUdENJVFh1N0JKeXRwdnB6aTY0VmNMa3ZkVnlVNkdLTGo1eEs4VVRTVWFoQ1VJSnZmVUFYK3NWdEhHc3pYOURRMTByd29yd0Z5UDFneXEwSjIyM2dzdk84YTVpaGttQUU2M0pNRjBGdldGWmRRRkUzTzBjaUdCWUFUcEMydFZBQ0FXVlc4QkJIVTJnaytBMkkxNndWY2tlRDA1OWxWaHRxUnJ0UWRLVUp6TnM1MVdBQ1VncVZyNmlPL3RIeGE1aWlxc3lsT0MxVTVoekt3aEkxbUhEcG50OGtqckdXWU94S3FUd0sxUlpGU2tHWW1ISDUxZHJaaGNCRGQrVmszSjhoempXK3ptbXBwVWd4aU9lWkQ5UW1sZHhSNVJXaGNjVVAyaEhLMXpmZ2tFN2tSY3dZbzQxNnN1WDRSVXl6Y3BiRjE1TkR3YmhodkQxRFZMUGhKcUwrVmMycEp2WS9sYkI1SnZyekp2SFgyblRqaU1CVE1teVFINTliY2tnQTZxTGl3UHBlSWtZeXcvSVBKazZoWDZlSDBIOFJTMzA1bHIvTW8yMnVkaHlFWmgyaWRxOU9ucHFSKzVIblhWeUw2bnc5a0FRWEFMSnRmY0oxTjdibUs4YWxsM3pZeHhhaHRpaTlZcXhWTDRaeDhYRXNsOFVpbHBrSk5zSEtrT3JzVktKNUJJQTBpcTRHWWJaVW5FTlVKVEp0dWxUUU9wZFZxU2V1dWdqTUtKV2Z2L0FCUXcxVW5IRm9mVXBUaTh4VTQ0UUNjb1BOVzErRWFoVVhYWjFoaStSdHB0SlMweTJQQTJCcFllbHRkNFRyTmZqMDBObVBsc3Q2UFFUenkzVDZSMFlreEhPNGhxTGMzTTNTMDFwTHl5RGNOSjQrYWpwYzlPVU9ybWdxWHpsU3VRdGJVeFh1N1huVUdnU3Uxc3dPZ0hJUjMwaDFMSUxiK1VwVnRjOWRiUjViSTNrZTZSNmZFbGpXMktFR29zc3ZabTJXMHFKdVZLQUNvY0dLS2JJZ0xuSjBJYzN5cDhSNitYckhaTWV4cmJVM015aUZvVnNoZGlUOHJ4eXR5ZEdTck1pa3lnSk4xWm13cy9POFF0dmxETGt1aDMvR0ZFbW1yR1liY0Z2M2lRcTBWbnRFb3VGcWhncXIxQVM4dEx6N0tBdVhtMlVoQld2UUJCdDcxOXJIOUlzc3pTcUpQclMvTVU2V1M2MlIrTTIyR3ovd0JJRng1eFRlMWVqeWpHQkhabVVjN3NzVGpSVWc2OTRDQ0FBZVl2ZnlFV05NbDZzZHJvcjZqbkZMY3I0TUVjWktWMktoQ1BFTi9FT1VkYjJWV2gxQjJ0SE9kRFk2OGpIcGRwNWhzWk9scmJRSVVzYVhoRUltdHJHTGxFN2d1UmxxaGlHV2FuNyt4by9FZEEvTUJ3OVRhUFJjdFhaZnVFQnN0QkFGa2hKc0FCc0xjSTh2U1U0OUpUQWVsMTVWajRFY2pGdmxzWlM1YUh0TXM4bDNpR2xETDZSbjZ2QkxMSk5jbzA5RG54NG90UGhucEowSmNVdElTRkl5MlVNdlRnZUJIT0tyWFpoYUpsaHA5MHFXU1ZwWG1BTGdCRndlbytZMWl6UFREV2RURXVDK3RJL0VLZkVsSTZuYThWZkVLQzYyMkZadkJaWXkyQkJHeCtIMWkzT0M3S0ZsUm9zbTNJZTFzamRMeTFhNldCTndQbkdUWWtkTDFkbjNGQ3hMeXRMVzJOdjBqVW0zRi9lRlFTb2hLZzVmUVdCRnVYQ01ucnR4V0p6TWJrdXFKUG1ZcmFSVmtreTdySCtGRTRMbUR0YzZ3UXNiUXEra2FLUm1CZzVmT0ZJOTdYZUd4cHFkL09GZzJTVHhNRWlCU1QzcnVVSEttSHBWSUN4blRkVzJvam5iTmlEdnJIV0ZnbTRBdWVQV0RYSUw0SkZwNVRSVGtVVWpiUXhaWi9HZGZxUlpYTzFXYmNXd3lXR3lGWk1yWjNBeWdialF4VUFvbXdQQThvNm03RUFDOERKczVNNlMrUU5OUFNFSldWRlZ3VFkvbE1JQ2IydmU1NHdwSUFLaHJ3OTB3c003S1pNcmtwNWlaUlpDbW5FdVgzT2h2SG9FSzcxVmdMcEtRVWttd1hjWEFJOHIvOEVlZG0wZ25SRndlS28zTEROVkUxaG1sT2dxNzFES1czVlpicEJUcGM4eHByME1aZnhHRnFNa2F2dzZkWEU2M0VMTm1sTERSTnlrRVh2YlUyOVBsSExMTFJMTGIvQU0wb2VJcXpBREtMbnJIVk1NckxwS2NpeUNSbnpKdWpwYmVFdXRvV0xUYTFrYUFacko0Y2hyOHpHY28rRFJjNjVaS1B2eTAyd29UVGFIVzdBS3Vra0V4RHpGR3c4ODJFSllTMDJBVGxTOHRBSG9ERGlsRmxTUlQ1Tnh0VmorS0RZbjA0K3NWcXNWNWNoNEtnL1UzRjVpRmhtWENNbm1TYkgwaHNjRS9BdVdweCtXVEF3cFFWS1E4bCtkUXNXT2NUcXdFcHZxYms2QzNPTVl4bldGVkNzVGpFdFBURXhTSmQ0b2xVcWNKU1VwMDd5M002NnhNWTFyNmFyTHBrYWVxYk1vRG5jY21GMlc2ZUF5M05rajVtS1E1b253NldNYW1qMDhvdmZQc3pOWnFsSmJJZERTNzczdjFocFE2YndxK3B0c2RvU2RocEdrWmdnNmkxdFliaGF6ZmJlRUNFNU9Sc1FRSUFnUUZCSHNsaW5xWVpTdzhvS3pBcUNrN0U4VTI2Y09uckhCVXBOQ1dsb3NBU2s2NVIrc1NzL1BKVzBwcGhKVThMRVppYnRuZ2JBSDRSV3FxN09UTENsRnhMSzdsS2t0dDJzb2NMcU45ZjZSMG1xcEEwL0pRWitWTGM1UGQwbGFsS3N2d0pKSnNMZnBHUTF6S2FyTUZCdWxTcmd4b21JcTgvaHFyb1FHdStROHhiTWREbUJQSFk3OEl6bXB6SzUrY2VtMUlDTTZ0UU5oRmJCQnhtMittWHMrU004TVlydEhGQmp6MWdRT084WExLRkF2emhlcEF2OFliNDdRc2JXSnRCUlpBcEhLOE9KTnRmaERhVHI1d3JmYURUQloxSU55TDZrNngyc3IwRnJnYmtFUndOa1dUdnpqclJmUzJ0dEk2UjBUcExsaUFRSURhaVh0N1podmFFSkYvNm1ITWxsSkpUZnB3TUtZWThnNjZxSk1hMzJQVTJhclVvK3hMT05vYmxYUEdGSnViTEducGNHTW9hYVVTTEl0ZmJtWTNEN09sTXE4dGlhWmRlcDc2S1c5TFpYWFhVRkFDZ1FVWmI2cU43alRuZUZ5aEdmRWxhQ1U1WStZdW1hRkpZSFVwZDVwM05iUUpTa0RTSkVZTWFTK0FqTHB1YmNZMEJFdWxMaU5OYjJQd2g1VXVETUt0dngrQWprc2NlSXhGeXk1SmN5WlNGNFNTbEl0WXFBS3ZoSExVc0Z5ODZsUlcwbFdkS2dBUnhBQkVhTXRvQnovYXJoMGh0cG9KbEVLQXVVTEN2VFFRZTlld3Q3bXV6emZqM3NkVE5NKzFVT3pNNFcxTDdxM2hkS1JlM1FrUjV2bkdpUm1OejU3anBIMFBucFZOZ2hKQ1ZKZEtXMWNpUWN2enRIbEg3UldDMktMVkpXdjBwc05TTldVcnZtZGd4TUFYVUIwVnFmTUdEdVBhUkVXN3BtSEszTzBJVWROcngwVGpMckFTWFFtNnRyR09UZmpyRVBJcTRIcURUcGdKZ3ZTQUw4SUVMNzVDQkIrY0Z4TUNPSlI3TGxGb1RMTEFDQXBBVXBDcmE2ZWU4Ujh5VktjRGlYRXFRNk1xa2xBSGlBOE8zdytFS0sxeXpEcS9DQXRCUUNTYmtuK2dIemlQbUhjcU1xdGIrSFdCY2ZGQXBtWmRzbEtRbVdwODAzTDJMYmhTNDdtTmxaZ05BTnRDUFBXS0JUNUJoNm5WRnhheUVoR25HeWhyZjlJMnF1ekVuTnlMclZWU0hKY05udldVcXNWQ3gxdndzUURjYXhpODNOcGs4UE15N05zNzl5U0J1T2NJdVgwb3VhZFJxVXBlRi9CWEJyckF2dndnUUx4YXNxVUFia2NJQU9zQVdnZW5wRXBrVUxHOExUcUlhU1FOVGMyaTgwM0FFL01NTU92T2hIZkpDa3BTMlNTQ05JUGZHUGJCYWI2S2sya213NDJqdlpiVVJxUGpHaFNIWmk2cHdCYnIyVytwS1FJMFREblpOSnQ1WEhtUzUvd0M2Ymo0UkcvZDlLQitudG1KVXFqVGxTY1NpU2xYSDFmeURRZVoyalVzSWRqODVVTzdYVWxoQ1QrN2IySG1yK2tiVFJjTHlNZ3loQ1drNmFBSkZoRmxwN2FtU3BPVkFhQkdRSkJDaHp2NjhvN2JYMUVQSi93QVNvNFM3TUtOUmxoYUdrbDVPN2hHWlo5VCtrWCtsVTVtVlJkcEd0K090b2RTZ0pVRkMydnpqclpVQjRZWEtYRkloVyt6b1VtejdZNTNNUEpBOXJXT0ZoOUk1blYzbVdDRHJlMTRlYlVUUE84Z0FQbENXd3hheGRZdndTWVMybi9LcVQwL1NEV2ROTlNRUkNXVkR1ckhpRDlJaXpxT0dvcFNwSldSb1VvVWZSUXZHUy9hTXBZbWV6bXJrcDhjbTgxTko2QXJzVDgxeHEwOFQ3RWJuVU5LSHdGLzBpQ3h4VEdhNUp6Vk9mL1kxR1NkbGxjZ1Q0a24wSWl4QjhVTGZaNEJxQ3MwcmxPN1pGanh0RVdlY1RGYmxIcEdibVpTWlJrZllXcGx4UEpTVFkvTVJEeHpWY2xoU2NseUNEZ29CMmdiSkJBdkE0OG9PSk9QVmsxTktWTnN0a0hJMmtyU0w3SFdPT2VYWktsY2gvZUJBaVUzeUMxMFV1dE9xYmw1OVNRbXlKVnl5YkMzN05YOVl4ZDlTbExDU29sS0JaSUoyRUNCQzJIRDZSb2pyQXQ4NEVDT2ZaQUFJTUNCQWdvOUhCb0hpQVBsSHF6czFLSnpBK0huNWhHWnd5Z1FUZmZJU2tmSklnUUlzUjZzVGtMZUN5Z3JDV2R0dGY3UkxVcW9qdXNwYUp5bXc4WDlvRUNJbEowUW9wa2ttcG9HWlBjSFk2OTUvYUhCVjBsb3I5bk9ZZnovMmdRSXJTbTdHS0NvZSsvN0lCOW5ObGJqdlA3UTZjUWdoS2hLa0c0L2Uvd0JvRUNBYkMyb0RlSlI3WUZHVVBnMEE3My94aFp4UUc1aHhYc1pKTmgrMTZmNllFQ0FiQ1VVSy93QVVncTFrenNmM3YvakNWNG9EYVVqMk1tNFA3M3AvcGdRSTZ6dGlJNmN4VUN5VWV4Ym9WKys2Vy9oam1xZUowdk9TdDVLd1NiZnRkeHNlRUNCQnhrd1hDSjVPN2Z3dzMyalRiMHV6M1FuSmRtWldrSFFMS2JLUHJsdjZ4bWxyd0lFT2svbFJFVlFWb0FnUUlBTU13QkFnUjFzNC85az1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL01UZXJlc2EuanBnXG4gKiogbW9kdWxlIGlkID0gMjk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvL2dCWlJtbHNaU0J6YjNWeVkyVTZJR2gwZEhBNkx5OWpiMjF0YjI1ekxuZHBhMmx0WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2tkdlpHWnlaWGxMYm1Wc2JHVnlMVWx6WVdGalRtVjNkRzl1TFRFMk9Ea3VhbkJuLytJTVdFbERRMTlRVWs5R1NVeEZBQUVCQUFBTVNFeHBibThDRUFBQWJXNTBjbEpIUWlCWVdWb2dCODRBQWdBSkFBWUFNUUFBWVdOemNFMVRSbFFBQUFBQVNVVkRJSE5TUjBJQUFBQUFBQUFBQUFBQUFBQUFBUGJXQUFFQUFBQUEweTFJVUNBZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVJZM0J5ZEFBQUFWQUFBQUF6WkdWell3QUFBWVFBQUFCc2QzUndkQUFBQWZBQUFBQVVZbXR3ZEFBQUFnUUFBQUFVY2xoWldnQUFBaGdBQUFBVVoxaFpXZ0FBQWl3QUFBQVVZbGhaV2dBQUFrQUFBQUFVWkcxdVpBQUFBbFFBQUFCd1pHMWtaQUFBQXNRQUFBQ0lkblZsWkFBQUEwd0FBQUNHZG1sbGR3QUFBOVFBQUFBa2JIVnRhUUFBQS9nQUFBQVViV1ZoY3dBQUJBd0FBQUFrZEdWamFBQUFCREFBQUFBTWNsUlNRd0FBQkR3QUFBZ01aMVJTUXdBQUJEd0FBQWdNWWxSU1F3QUFCRHdBQUFnTWRHVjRkQUFBQUFCRGIzQjVjbWxuYUhRZ0tHTXBJREU1T1RnZ1NHVjNiR1YwZEMxUVlXTnJZWEprSUVOdmJYQmhibmtBQUdSbGMyTUFBQUFBQUFBQUVuTlNSMElnU1VWRE5qRTVOall0TWk0eEFBQUFBQUFBQUFBQUFBQVNjMUpIUWlCSlJVTTJNVGsyTmkweUxqRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZoWldpQUFBQUFBQUFEelVRQUJBQUFBQVJiTVdGbGFJQUFBQUFBQUFBQUFBQUFBQUFBQUFBQllXVm9nQUFBQUFBQUFiNklBQURqMUFBQURrRmhaV2lBQUFBQUFBQUJpbVFBQXQ0VUFBQmphV0ZsYUlBQUFBQUFBQUNTZ0FBQVBoQUFBdHM5a1pYTmpBQUFBQUFBQUFCWkpSVU1nYUhSMGNEb3ZMM2QzZHk1cFpXTXVZMmdBQUFBQUFBQUFBQUFBQUJaSlJVTWdhSFIwY0RvdkwzZDNkeTVwWldNdVkyZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFaR1Z6WXdBQUFBQUFBQUF1U1VWRElEWXhPVFkyTFRJdU1TQkVaV1poZFd4MElGSkhRaUJqYjJ4dmRYSWdjM0JoWTJVZ0xTQnpVa2RDQUFBQUFBQUFBQUFBQUFBdVNVVkRJRFl4T1RZMkxUSXVNU0JFWldaaGRXeDBJRkpIUWlCamIyeHZkWElnYzNCaFkyVWdMU0J6VWtkQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBR1JsYzJNQUFBQUFBQUFBTEZKbFptVnlaVzVqWlNCV2FXVjNhVzVuSUVOdmJtUnBkR2x2YmlCcGJpQkpSVU0yTVRrMk5pMHlMakVBQUFBQUFBQUFBQUFBQUN4U1pXWmxjbVZ1WTJVZ1ZtbGxkMmx1WnlCRGIyNWthWFJwYjI0Z2FXNGdTVVZETmpFNU5qWXRNaTR4QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUIyYVdWM0FBQUFBQUFUcFA0QUZGOHVBQkRQRkFBRDdjd0FCQk1MQUFOY25nQUFBQUZZV1ZvZ0FBQUFBQUJNQ1ZZQVVBQUFBRmNmNTIxbFlYTUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBS1BBQUFBQW5OcFp5QUFBQUFBUTFKVUlHTjFjbllBQUFBQUFBQUVBQUFBQUFVQUNnQVBBQlFBR1FBZUFDTUFLQUF0QURJQU53QTdBRUFBUlFCS0FFOEFWQUJaQUY0QVl3Qm9BRzBBY2dCM0FId0FnUUNHQUlzQWtBQ1ZBSm9BbndDa0FLa0FyZ0N5QUxjQXZBREJBTVlBeXdEUUFOVUEyd0RnQU9VQTZ3RHdBUFlBK3dFQkFRY0JEUUVUQVJrQkh3RWxBU3NCTWdFNEFUNEJSUUZNQVZJQldRRmdBV2NCYmdGMUFYd0Jnd0dMQVpJQm1nR2hBYWtCc1FHNUFjRUJ5UUhSQWRrQjRRSHBBZklCK2dJREFnd0NGQUlkQWlZQ0x3STRBa0VDU3dKVUFsMENad0p4QW5vQ2hBS09BcGdDb2dLc0FyWUN3UUxMQXRVQzRBTHJBdlVEQUFNTEF4WURJUU10QXpnRFF3TlBBMW9EWmdOeUEzNERpZ09XQTZJRHJnTzZBOGNEMHdQZ0Erd0QrUVFHQkJNRUlBUXRCRHNFU0FSVkJHTUVjUVIrQkl3RW1nU29CTFlFeEFUVEJPRUU4QVQrQlEwRkhBVXJCVG9GU1FWWUJXY0Zkd1dHQlpZRnBnVzFCY1VGMVFYbEJmWUdCZ1lXQmljR053WklCbGtHYWdaN0Jvd0duUWF2QnNBRzBRYmpCdlVIQndjWkJ5c0hQUWRQQjJFSGRBZUdCNWtIckFlL0I5SUg1UWY0Q0FzSUh3Z3lDRVlJV2dodUNJSUlsZ2lxQ0w0STBnam5DUHNKRUFrbENUb0pUd2xrQ1hrSmp3bWtDYm9KendubENmc0tFUW9uQ2owS1ZBcHFDb0VLbUFxdUNzVUszQXJ6Q3dzTElnczVDMUVMYVF1QUM1Z0xzQXZJQytFTCtRd1NEQ29NUXd4Y0RIVU1qZ3luRE1BTTJRenpEUTBOSmcxQURWb05kQTJPRGFrTnd3M2VEZmdPRXc0dURra09aQTUvRHBzT3RnN1NEdTRQQ1E4bEQwRVBYZzk2RDVZUHN3L1BEK3dRQ1JBbUVFTVFZUkIrRUpzUXVSRFhFUFVSRXhFeEVVOFJiUkdNRWFvUnlSSG9FZ2NTSmhKRkVtUVNoQktqRXNNUzR4TURFeU1UUXhOakU0TVRwQlBGRStVVUJoUW5GRWtVYWhTTEZLMFV6aFR3RlJJVk5CVldGWGdWbXhXOUZlQVdBeFltRmtrV2JCYVBGcklXMWhiNkZ4MFhRUmRsRjRrWHJoZlNGL2NZR3hoQUdHVVlpaGl2R05VWStoa2dHVVVaYXhtUkdiY1ozUm9FR2lvYVVScDNHcDRheFJyc0d4UWJPeHRqRzRvYnNodmFIQUljS2h4U0hIc2NveHpNSFBVZEhoMUhIWEFkbVIzREhld2VGaDVBSG1vZWxCNitIdWtmRXg4K0gya2ZsQisvSCtvZ0ZTQkJJR3dnbUNERUlQQWhIQ0ZJSVhVaG9TSE9JZnNpSnlKVklvSWlyeUxkSXdvak9DTm1JNVFqd2lQd0pCOGtUU1I4SktzazJpVUpKVGdsYUNXWEpjY2w5eVluSmxjbWh5YTNKdWduR0NkSkozb25xeWZjS0Ewb1B5aHhLS0lvMUNrR0tUZ3BheW1kS2RBcUFpbzFLbWdxbXlyUEt3SXJOaXRwSzUwcjBTd0ZMRGtzYml5aUxOY3REQzFCTFhZdHF5M2hMaFl1VEM2Q0xyY3U3aThrTDFvdmtTL0hMLzR3TlRCc01LUXcyekVTTVVveGdqRzZNZkl5S2pKak1wc3kxRE1OTTBZemZ6TzRNL0UwS3pSbE5KNDAyRFVUTlUwMWh6WENOZjAyTnpaeU5xNDI2VGNrTjJBM25EZlhPQlE0VURpTU9NZzVCVGxDT1g4NXZEbjVPalk2ZERxeU91ODdMVHRyTzZvNzZEd25QR1U4cER6alBTSTlZVDJoUGVBK0lENWdQcUErNEQ4aFAyRS9vai9pUUNOQVpFQ21RT2RCS1VGcVFheEI3a0l3UW5KQ3RVTDNRenBEZlVQQVJBTkVSMFNLUk01RkVrVlZSWnBGM2tZaVJtZEdxMGJ3UnpWSGUwZkFTQVZJUzBpUlNOZEpIVWxqU2FsSjhFbzNTbjFLeEVzTVMxTkxta3ZpVENwTWNreTZUUUpOU2syVFRkeE9KVTV1VHJkUEFFOUpUNU5QM1ZBblVIRlF1MUVHVVZCUm0xSG1VakZTZkZMSFV4TlRYMU9xVS9aVVFsU1BWTnRWS0ZWMVZjSldEMVpjVnFsVzkxZEVWNUpYNEZndldIMVl5MWthV1dsWnVGb0hXbFphcGxyMVcwVmJsVnZsWERWY2hseldYU2RkZUYzSlhocGViRjY5WHc5ZllWK3pZQVZnVjJDcVlQeGhUMkdpWWZWaVNXS2NZdkJqUTJPWFkrdGtRR1NVWk9sbFBXV1NaZWRtUFdhU1p1aG5QV2VUWitsb1AyaVdhT3hwUTJtYWFmRnFTR3FmYXZkclQydW5hLzlzVjJ5dmJRaHRZRzI1YmhKdWEyN0VieDV2ZUcvUmNDdHdobkRnY1RweGxYSHdja3R5cG5NQmMxMXp1SFFVZEhCMHpIVW9kWVYxNFhZK2RwdDIrSGRXZDdONEVYaHVlTXg1S25tSmVlZDZSbnFsZXdSN1kzdkNmQ0Y4Z1h6aGZVRjlvWDRCZm1KK3duOGpmNFIvNVlCSGdLaUJDb0ZyZ2MyQ01JS1NndlNEVjRPNmhCMkVnSVRqaFVlRnE0WU9obktHMTRjN2g1K0lCSWhwaU02Sk00bVppZjZLWklyS2l6Q0xsb3Y4akdPTXlvMHhqWmlOLzQ1bWpzNlBObytla0FhUWJwRFdrVCtScUpJUmtucVM0NU5OazdhVUlKU0tsUFNWWDVYSmxqU1duNWNLbDNXWDRKaE1tTGlaSkptUW1meWFhSnJWbTBLYnI1d2NuSW1jOTUxa25kS2VRSjZ1bngyZmk1LzZvR21nMktGSG9iYWlKcUtXb3dhamRxUG1wRmFreDZVNHBhbW1HcWFMcHYybmJxZmdxRktveEtrM3FhbXFIS3FQcXdLcmRhdnByRnlzMEsxRXJiaXVMYTZocnhhdmk3QUFzSFd3NnJGZ3NkYXlTN0xDc3ppenJyUWx0SnkxRTdXS3RnRzJlYmJ3dDJpMzRMaFp1Tkc1U3JuQ3VqdTZ0YnN1dTZlOElieWJ2Ulc5ajc0S3ZvUysvNzk2di9YQWNNRHN3V2ZCNDhKZnd0dkRXTVBVeEZIRXpzVkx4Y2pHUnNiRHgwSEh2OGc5eUx6Sk9zbTV5ampLdDhzMnk3Yk1OY3kxelRYTnRjNDJ6cmJQTjgrNDBEblF1dEU4MGI3U1A5TEIwMFRUeHRSSjFNdlZUdFhSMWxYVzJOZGMxK0RZWk5qbzJXelo4ZHAyMnZ2YmdOd0YzSXJkRU4yVzNoemVvdDhwMzYvZ051Qzk0VVRoek9KVDR0dmpZK1ByNUhQay9PV0U1ZzNtbHVjZjU2bm9NdWk4NlVicDBPcGI2dVhyY092NzdJYnRFZTJjN2lqdXRPOUE3OHp3V1BEbDhYTHgvL0tNOHhuenAvUTA5TUwxVVBYZTltMzIrL2VLK0JuNHFQazQrY2Y2Vi9ybiszZjhCL3lZL1NuOXV2NUwvdHovYmYvLy85c0FRd0FHQkFVR0JRUUdCZ1VHQndjR0NBb1FDZ29KQ1FvVURnOE1FQmNVR0JnWEZCWVdHaDBsSHhvYkl4d1dGaUFzSUNNbUp5a3FLUmtmTFRBdEtEQWxLQ2tvLzlzQVF3RUhCd2NLQ0FvVENnb1RLQm9XR2lnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ28vOEFBRVFnQkxnRGNBd0VSQUFJUkFRTVJBZi9FQUJ3QUFBSURBUUVCQVFBQUFBQUFBQUFBQUFRRkFnTUdCd0VBQ1AvRUFFRVFBQUlCQWdRREJ3SUZCQUVEQXdJSEFBRUNFUU1oQUFRU01RVkJVUVlUSW1GeGdaR2g4QlFqTXJIQlF0SGg4VklIRldJa2NvSXpvaFlsUTBTUzB1TC94QUFhQVFBREFRRUJBUUFBQUFBQUFBQUFBQUFCQWdNQUJBVUcvOFFBTFJFQUFnSUNBZ0lDQWdJQkF3VUJBQUFBQUFFQ0VRTWhFakVFUVNKUkV6SkNZWEVqa2JFRkZJR2gwZkQvMmdBTUF3RUFBaEVERVFBL0FPRjVpalVHWWhRek1hcmVMZVFTVDV4NitlRkc0SHRLN2lBQUtaSkdtQUJ6NThvZ1lBRDZxd0JFTVRVS256QXZFa2pjZExkY1l4UTZFVkdBWTZOVW5WejZiZW1NWUl5NmxrQU05NFRDd1ltOHovazRKajJwU1JGcEN1NkhVcElONE45TVc4NytaR01ZcVR1eUNFWjBMV003ZW84dDhZeGU2cFdlRWNHREFXb1lBdmY3K2tZdzBPeXVxbEtvV0pxSFNvTVNvSW4xOWVmTEdMeTZJMUtacHVEY2drK0hja2pkZXZNNHhNdTNhbnExQWhJTUMvcDYvd0FqR01WVmFOT29OV2xRQ1NGSjlSODdqQWVrRFQweXhNcFVjeWxJTXNYazdqenZmMXhMbVBHRFg2RjFISlpnSlZLb3pBcW9KQ1N1L1A0R0tYRXFzYytBUlE0ZG1haXMxTUZiRWkwVzVpZjVHSjNBbkRFU3pmQ3N4U2dzV0pCMURTZHhzUDNJdzBad2JvZVVaTG9XZHlwZ1ZHbVFUQ0F5THdJUHppbkxqcEFqcFV5ekxVZ2xSVHBTb29JSU84U2VVOGpleDVnWTEzc1pNcmFXSWxVMU55YllIOWp2Z28xRXF5QUswQldGb0pxRVFPbzl5YitmbmdrcGtHUkJYZ3ZZTUFEOWJSdUw0S0ZMMTEyRlFhRk1xSENqWURsN0g5OFpqUjdKclZZVlgxalVDQXBNL3AyOTdiWUZYb2FYUlVsWHZBUlVPb2FUb0traUR5K3B4dUZiSmx0Tnl0Q1JKYlZQcUpKdVRhTnZwaWI3TVdtUVhkSDd6VnZhSThyM3RoakZRWWhwT3BiYXZFSXRhOEgzK01Za2ZaZWpxVHhVVll5UmVvaXg4bS9yakZRWE0xME5lc05JUDVwMUtKL1ZQUHpzRGpFdVpaM2xPbTRmeFZEVUhoSFVubFBwRStVNHczSkZCYzFhaStJcXk2VllpdzNCTS8zNVJqRzVJc0g2aVdWZ1NicXRPQWJreVo5b3hnTjJ5T3BkVUJtUlZBTFNadEhtZkw3NTRLbFJCYWFWRlZkZXN5WldDWmc3RG5OeHRqQWJzc3kxTXZSTlF5UUpZN0hWRi9pMk1Ba0tyWFlMcVhiWWcyNS9NRTRCanlpemF0SUtoakYra3lKK1o5Y1lOc2hVSi9SWURWc3c5QjlOdm5CTkhza3dPbGtieElZaFEwU2RvTWY3d0gwUGRiUEZwMW5WRnAweGVTUE1rQ0RmOXZLK0ovRmV4NHhsUDBiSGdOR2p3OGlsbmFDR3E2TWdNekRIL2p5TzhUYzd4eXh5NWFsMHpvaEdVUFJxTXJ4UkJsM0ZmaDYxTzhVa29YOEN4c0NQSUF5ZlhIUE9ITHAvK3pxZzVSN0ErT3BUejJZcVZlSHJTRHNBcjB4cHBVeEJnUnVaaTl4YzRiRGFXeU9UY3RDS3JUek9YQU5jZDRvOGZpWUVmSG5qcGhKQ1NGbFpRMUdmMEZWMU5ZRXhzWWovQU9VOHNXVXRpUG9URlNhdDJwd29CVXliV0oyR0twMkt1aXhOQlk2VzBEb3Q0NWs5ZDR3Ym96VFo2c0IzcG5XcnJ5SUZwaUczOWNhN01sWFpHc2loRDNaTHNRSHNEc1oySHZob2dsR3dkU1pxbFNZM0FPd3RhZnI4a1lkQWhHbVMxa21RQU83WWtTU0lIWDl2bkFZekw2Q3BvQkxyTnd3QTNrenYxODhLTExvblVScC9MWVFDTEUyTWJmdisyTVRMcVZlb1FOUjBFc2JxQVNJNWZmVENHSzFxaEhZTnFZdXZLYlduKzJDWStwbW1nSUVnRXpCVVd4aGxHdENYTlA4QW01bFdVR0tyQW55a3gwNUdQOVlham1wRSs4YW9uampXSlZqQnVKMkh6NXpPQUdqeXJWSWhsSUFWdFZqRzUybjJNRDF3REJCOGRJRUc0bG1tcHFFOHdiQTlENUhHTVZNU2FMU0piK2dFbVlQSWlQTGIxNll3UzltVW9VRlJYTVJkdDduYVBUR01mVWFpRUJucGxnZkV4RnB0ZmIwK250akdDS1ZkVFRVVWxKYlNZS043OUxZREdpUmJ3ZUVDNUg5WDdBYmY0dDZyMzdHcEgyWG9WY3k2MHFTNjNaZ2ZDbDc4djMreGhYSlI3WThjYmJ0SFJ1eW4vVGRzOWxxTmJNMVdaM0N1QURwV0lOeWVmK2VXT0x5UE9TMUU3c2ZpeGt0bW5mc1p3WElFaXZTSmNSYzBTUU9VemVQODQ0MzVFcGRNc3NheDlJK2ZLNVRJSXowYUwwZzRVTlZaQ0tqaWYwSlA2UmU1OHg3R001U0RQb1UxcTFYTlVxaTBjdFNwMFE3TzRZclNwaEwyTEVqa0RKdk05WXhXTVdMS1FtcjhSeWxVRjZ5MWtRdE5OaWhBSjVpUkVkZDhVVUwwbWM4cHBiU0V1Zk5HbitmbHExV25UQmtNVEpqclByYkY0UnBVSkozdXdDaldOWE9hYXFkOVNBQkJVTUdNY2gvNUczVVd3NzFzV0liVDRJWHBxOURKNWp1cDFNVkFZamNUeW13eGxsSDRyMFFvOFBSSEQwbEpXbExNYWlhU0lIbjc0cHp0bTRnVmVtOUlNakxScGtuVnBNVzllbUdiMnFGa3FCN280WTZQQnZLelBMZmtQakZFMkl1d2NOM1FIZUNXVmlUL0FCL0h6Z3BzTFBKcHZWcU1Bd1VrL3FFZ2NnUUNPVTNIcmc5azVQUktpVlZmeXd4YUNRUUpBazhzRVZOdDB5UnJJMWVXcUtyQWxpUXU0aXh0OTdZREhTWDBFVVJycElyeUNGdnA1YjI5TGpDalVxNktpTlg2bExCUkFnQVJhZjhBV01SUGFTcnB2WVQ0ZlRHRzVQMkljMUlyVlNKSjcxcGsvd0JPb3p0YzdlM3ZnMmM1RlJWRTZnRk1FOGdUQXRKNWI0QmdsR1JrVXNBd21WWXJadWMrd0pNZWZuZ21QVnI5NG9wZ016ZFpFQzhmejB4akZsSjFZQU8vNVlKdFBJZnE4NXZmbGdNSzdKVXdIMkFBQktzSUZyOCtsenZnQmFvOE5IVUNGL3BKL3BIei9HTXpCT1JINm5XQklraU4rUVBUQ1N2Vk1hS3V4bHczZ2ViNHBYVk12U3JWRmFBU0xLSnZjOHB3bWJOQ0NPakhnYzRuWk93SC9UcHNqVW9admk5Y1JLTXFNZEltNTUrWHpqeHMzbWVranZ4NDFCV2RIeTlISTVITHJsOG85UXRvQ29xQXdJQnVZdGZuamovYmFLV0pPS0ptYzByMXE3MU12VHBoZEswMEpVV01HQnVkK3A5TVdnNlJyWFJsZTArWEZQTHZVaW9HTndqRXlUekxFYnNlZzI4OGRHT2JYUXJ2b3crYm8xS2xTa3RTa3dxS1pacWpTZlFEa0JqcWkvalpHU0dQRWkvRlZwOTVuc3pWclpkVm9yVHpUbHRDZ0NTb0hoQStwakNSblhSb3FNbFZiTXR4Ykp0bG1yMHFGUmx5eGE3WDhNaThIcjlMSEhWR2FPZk5oNHF3THN6bDJkbTFWS01KSGdrM0pubnVJTVFiNE04a2FxZ2VQQnkwenBmRHVIMFc0Y1JtYzNUU3V2aVZlOUVtNUkwRURhQmNkWnh5OHFaZmp4MEJjU291MUdyV1Y2VDF0bVZ4QVlFd1Q1allpOFd4WlR2YUZ2Um11SlVYRk1hWUtPcWp3VEZ6MU8zUEhRbnk2WnBSNUpHY3pBUUVudVNTU2Y2dGh5Ry9uaXkxN0ljV2dEUEJpQXdRaFhPbUFkckhEUmFzUjhnVUYyRlhUcVh4a0Vjb084ajQrVGg3WG8xUDJHSkpSbWlHTWtneGJ5NjI1WURDb3F5MTZhR0xzQWJNTFNRTnR2dTJGc1pJOUxVd3poMUdnZ3RJQUo4dHVjMnhna3FkSU1GVlhCWW9Kc1BFZWYwK01ZWGd2b2xUb21ycmNMb0phNmxvZzRTMkRoL1FqcW51Y3pYcXVxSDh4NTFIeGZQSW0yM21PWnhRNVNiMFZLK0JlNzhPa2liYy9EMXdBbndhblZEWGRXWGFaSks3N0h6QStTZHpqR0kwTXJUcWFoVFVTb0hPSU1lR3grL2pHTUVVc3U5TU1Ub0xDOGVjM0g4ei9uQ3RoU0x4Uzd4VWNzQTRZNmlSRndDRDczSS92aldQT095eW9XZ2F3SUVGU0Z0NW1QZytzNFZ0dG9XbU5PejNEam5hNnFhYnRJOFRDVEEvOXZVMnQ1NGptbldpMk9CMlRzemt2d09TZW5ScGhLcXdIWUFFVXhlVkhYelBYSGo1SlNjajFNU1NWRitiNGhXcDUzTDkxVU5UTUVBS0hHb2xRRGM4bDY0S3hwN1ptV054NnRScXJxekR3bjZ4U1g5VUEzbitNQndTRkhIRHVKVWEyV3A1bk5WcTFncmxYSVVqbGU4OHRnTUs0TjlCVkdUNDcyblRNWmx6a0tOV3UvNktkUmhDSXZSQjdiNHZqd3lxMks1bWN6TjZZcTExN3pNdVY4S0JtYUkzTVl0R2xwaDR0OUZOYmgzRUF3cVY4dG1zdlFjNmdXUWdRQkV6TmhneGtyb0VvM3NEcTVwUlNDVlhlcHBCMHp6WSt2dGgwbnV5TTNUMEU1M0p2U3ltVHpPVG1oays2aFRWalhtSHZKVkJzb1BQb043NDBKdTZacFNyb3JDc29LbVdWVldTcHNwTWlSZmI2M3dXK1NzWkpKVWdzQ3ZtdUgxa3FNV2JMS05URnlTcWtuY2Y4YmdUdk16aFU5QVViV3p6TTBtcm93cjBnRVFxejAyQWtRRzhYbU9mdmdwaFRhUm5zOWxhQldvL2NqOVVLZE80MjI2M052NzR2R1ZDOTlpL081SWpMcWZBRXB3U1prUjBuRm90RVpKSVZrb2dZRkthbmRENXo5MnhWVUtWUXFzL2RhZEJhQVFaS21CdDk4b3diRFNQcWJhNnZkbnBZTjV5YjJ2TWZ2akdlbFpOWVVveERpUkI1a2lJUDg0eExuSW03TVFsZ1VJa2MvOEFmOThZUE5sZ2ZTQW9SYWdGaENBd0JzTUNrVUZXYVJlOXI2QVVobUFrVFlFbi93RHJnbkRZUmxLZXVuNFEwY2lvdXczZ24za1d4aldlb2xQUUQzakJRUVRZaTloQjVjL2ZHb05udEhRR2NsbW1aL1NJQUp2RWN4NWVjWXdTT1hxa21YVnRJRUFrd0RlZVZ1djF3ckNpMVNTakVCLytVcU92K2hnRDgyVXJTVWxoSlJBUUptUUx5WW43OWNDNlp1YjdTTi8vQU5QcURWVWMwaHFyTkNKQWcwN2p4VzNpVDhqcGp6L0psdloyK091V3pwK2NyWmJoWEMxbzVOUWFqZ0pURHQ0VU1FNm05Ti9VNDRWOHVqcmFhTTYxVXJVb1pmTGxYck1uNWo2aXhZUVRKTWJiNzR1cmloYjlsV2Q0b01nQVdiS1pnRkZiUlVrRVNDTld3bmF3OHVXTnh0YTdGYzZBTXkyVzRyU3BzNGNWR1VIOWVrQWd5VHBQN0hCVWVLMk12bUJQMmJyWnZPTXVUTHZVWndGQ1Q0ZmNueS8wTVVXWlZUTkxESTBYQ09IWjNoZFpSU3pOWFZUZFZabTBPTlgvQUI4MXNUMU1lbUlUbXNpdUkwTVRYczE5ZFY0OXd6TTBLOUdwWHpMTnFRNkNqQ0JGMnZwQUl0SFRIUFRqTk5zZlVWUnlmdEZ3UE9jT3AwZS9LbXRVbFVGRUZ6TVdsajA2K1dQVHg1SXZTT1ROaWVuRXlCenVhRkROVWxmUWE4MGlnQTFFS0MwQTdqYmx2aXFoeDJpRGQ2WS9wNWxjclZWNnVxb3BRQ1VBaHdRTFNUYnorZVdFY1c5SWZsVEdsWGlZeXBXcFF6R1djRWdsYVoyQm1ReEc5aVJ6dkdKdkcxMlYvSXVrSFpUTjArSVZIcHBxZW5wbEdlV0lJQkJVbnpIeGhKZkRabDhuUXE0K2k1Ykw5N2xsUTVlcVkwTWJvNHN5eDZZcmpha3JCS1BCaVdwVExOVk5KYWl6TE1GSWlCeWcydGZGa3liVm9Bek5GSktCZHlDQkJBSjZqeXhkU3BXaVhUQUVmU0cvUUpsU0dzSWc3WW9uWVNkT25xWlhwMlZnVEhsR3dQVEJONm8rWFpXSVlDN0ViSHA5TVlUOGFJTUlDdHJGeGNnUnFJNWV1TWJnajZuVHBsWWR4VEttSUxqNXhySFF2clBOYXZjQUdzUUNDUnp1ZkxhZmZHT0FsUnJGYVMrQWlvVElBdmVPV01aS3d0TklCQ3MyaW9KTUhjM3VmS2Y0Nll3OVVSTXNnVWdCN3J0RzNMNXdHdzBlb2trQXdMQzhDWkhLKzMrc0syWXNVSzFBd0FReE1zQUJQT0QvQUd0ZWVnT01NNDE3SzZiUzlOaVFBYkVYanA5K3VBMTdHaXV6ZGRpTS9UeUlwa0tVMDBxb0RJUnpHd0h4anovSWkzMGpyeHlwVWg3VTR2OEFpQzlXcGxpMUtrZ0tyYTRtQUFkK254aUNnMHRJc3NqYjJEWnpqSzBNc2N0bE5SZXE4TzVpSUFuOThQSEhKTzJibkZ1akxaek9EdnFWTm1OUm1nRXNlVjcvQUI4WTZJcGNXNjZKdVM1VWRPN0Y4RFU1V205U29XSnRid2diZE1lZG15dTJlamhna3JOcFV5Z3BaWHU2Q3ZUSjVySXVEMWp6dmpqZVMvWlZwdnNvcWNCN3hXZk5VV0loVElNQlNPWHBnckpVZEJUU2RDYk41VE1aS3JXcDVIdndDNGlxU2ROeHNRYjlNV2hKUHNQNDAxWmtlT1ZzOVQ0ZlVXdFJsWUFhcTdUTjdSYzNKSCtzZGVCeHR0SE5rZzZvekhEdUFveHkzZVVpZGNyNERKMnVmSTljWG5tb2hqOGR0YkdlWTRJMVBMMUFWWUwzbGxpU2JjdkxuNjRuSHlIWjBTOGE0MFluUFVzeHd3bVdWcUxBYUhITGY1MzJ4NkVhbWVaa2k4UmR3ampWWEo2U2hhbUlnd2JNUnluMitjREppVFZDS2J1eGxWNDR2RWU4eTVVVTZsWWhnQ1kxTU9oNmtRUG5FbERoMFA4QWtjbnNMbzVnSm1hTkhNWllxS3M5MjlJMmN6Qmc4aU9tTTJHTGJlMERjWXlTQUZxVGtJNEJCaS8zKzE4Tkdld3pqUmxhaU5UVndHRXEwaSsrMThkYTFSQzYwRTBTQlZBWVNOTTZJM21iL2ZYeXdiR0NtYlZSOFhpS3FiaTA5ZmpHQjJDMUN3VmYwV0FGeCtyYy9mcmdqRjZkeVZIZUZWTUFEOG9HUkdCWUxNOW1tcC9pYWlrVE5VaVlnbVpuZjFKM3hqZ1BxY21tQzE0aUlPOTk0bWVRM2cyeGd4VkI2VkQzS05mWElnRXhNamYrY0k1VTZvWmtxajZabG9zZjZ0ejBQdmdyZXdsWmZTODFWZ3VTU1M0Z0dKdDZZMUdzcG9sbUJMU0dZR1BqMTY0dzdtbXdsR0RGTklNS0xFajdQKzhCOURSb2U4QlI2b3BVa1lLenNRcGt4ZGlmN2ZjNDVwZkhzcW5WVU8rSlArSFJCVDFvakFVcGtOdGJvZWs5SUk4OFJWdVIwUytNZGlIT2VQTU9XZDExSHd3QUJ0NnhpNjB0aytON1FSbDh1Mll6T1cwYWxXbXFsOVN4OW4rMkp5a29KcjdLWThmSjJkNjdKcDNPVnBvRllzUkpnaVdNQ1Q2Mng0ZmtPNU9qMThhcUp0OG02bFNIVUhZanBqblJISmZvT3RvSTBpTU5icWlHN3NEem1VeTlha1E5QlhPOGFKSTZZSEpsb1RrbjJZSHROd1VWS2VoWWVCQVhScGlSYTNYL0FCaXVISzFkbldxa0wrRTluM0pwYVFvRXowNWJEejgvWER5eldQWEdKTGpIQzJ5OU4xWWtpYmFTUko1ZXd3SVNacnRXY3U3Y1pCNkpVcUIzVXlmRHNlUittUFg4YkpiUEo4dU90bk9xdWNPUXpwQ3pVUVF3UXRJQk84OWY0eDZPcEhreWRBK2V6T3VveHk3RW9wa2FSRWM0OVFRYjRaSkxzUnpsNk5mMlM0dm51STE4cmtYSXFWcWxWYU5NaFJJSklubGJZWTVzcW82c00zUHMxSEUyUTFzMWxxYi9BSW5McnJDUGRTOEVqVUxXODl0c1NpdVd6b24yWlRNVWlLYW1VYVdZYnpPMThkTVhkTWpMc0RkdEw2OVFLZ1JjYmUzcml0aU43SWFwUS84QU5WdE5qTS9Zd1E5RTJDbGpvalNCdTBBMjZ5ZW43WUhJbitUK2o1MHFXMEwzZ2pmV28vMzY0MWxLRUdjcWQvbUtra0VNU0RhNU0vV2VYdmduRFJiU3FBYWFqQUtpd1dpNHROejViaTJDRTlDbEF2aDBGQnJLdEEyTno1enY2WVdnaEhkZ05VZGRSRFFOaHpGLzNIek9NWXJDd2xCcVpXSG5VdHdUdk44YXpGdENrakZBMHZVZTFwTWt4NzRsa2U3SGhCU2V6VThONEJsNEI0aWFsSXNFYnVxVlBXMEZ4dmVCZmw5TWM4c2ovaWR1UERGTFp2OEFzL3dISlU2NjVqaCtSZWdWUTBrcVpnUVFTQ0NZSHJ5SHhqbHlaVyt5L0NLMlZkbytCcFF5RkpWcGo4TlNHaEhFNnFqa2tYNkRjKy9RWU9PYWx0QmNlVE1MeFpWU29HaG1TWUphWWdEcC9PT2xkRVhjWG9KNERuRFc0bHFxRXc2cVcvOEF1RW4wR0plUzZpeS9qdDNzN3Z3TTA2U1VHS3hVV21KQzNPcUI5YjQ4V1R0czlUdGFOVGs2akZmRzBqYnFSaVhSTEl2cEJqVnRNNldueUl4cFNTZE5rZU45a0RtQ1ZETWhVUk55SU9GMEhndWtBWjE2TlRXc0RrTGkvdFBQREowdEY0UmtrZ1loU3BaTFFUQnZKRnJTT2ZYQ0w3Wlcvc3ozR0tsS3U5UjNjc2dJSUlKQysxOXNXajNwYUdYVkhPKzFlV0dieTlmdTExS0FHTEdUNFFaeDZIano0dTJjL2tRNXhwSTRwMmtwSmwrTHRUUWx3RkdybGZtZW5USHV4NnY3UG5NeXFWQU9VcUtnTi9IcUlqZTFwSDMxd1gwVGo3UnJleDJheStTNHRTYW5TYk1PN2FLZWxyZ2tFKzNOZVdPZktyV2pweFZGR3M0aFdvMEdxVVNQRVYxT1lBa2tHZHR0OXNUaEd0RjV5U2RpTkNLMlZCVVNEVm5WRnZYeXhhT3RFM3ZZdXpOSmhKUlhGNzZWdDc0b21JMWV5VkNqTk5BdzBvUkFFekhLUisyR3RCc0k3cW5KN3VJZXgvbitmTENXQ2lMS2hQalJXTzl0aE4vM0p3UmRtYXFvRnpiVkRFak1FZ0cwWFltZnFaMnVCaHprc3JWSGJMb3ZpWWxJaGx1Ynp5MjJtTUVKWUZBb3U0VXRmVDRSMDNrZVFGNHdBaEhkYWRERU1CcFlxVE1SQWtSZ1dZblZWNFVFRUtGMm5mOEFmNytjQmpKTmpyczFsS21Zei9lMGtKTk1HQ0k4SmczUHpqbnpTNGxzU3AwemFaTlV5ZE9sY2Q0NnlSdVprR1k5dW9BeHh0dDdYUjNXbjBOY3Z4aXRrYStxalZTb1drRWprQ05sMkhyaFhDTSt3dVgwRnIyczc3SlBrbVNrbXVtYWRTdlVZYTNGcldzc3liN3dNSXNLakxYUWVmMlovaWxIZ3RTa2hXdlJmTU9CcVdtajkxVEVHQUp1eHZ1VHoyeFpPZlM2TjhXTCtGVTZkVGpOT2hsdTdWRG9RUWJBemN5ZlA3dmdlUktvdXhzTWJsL1IwamlQSHFuQ2NvVGxxWXFab3dsTUVjNC9lK1BOamhqa2xiUFJjdU1hUmhPSWNZN1E1aWptS2pjV3FGVWI4L3VWSXAwdWNCeVluckU0NzRZc1VlNG5PM1B2a0k2dmJUaXRDbWFGTGlqVXlSQU5PdW9BOUFEaDRlRmhsOHVPam1ma1NUcGhuRE8zUGFISktOZkZhMWVtWi9MeklGUmZyL2ZBbjRtS2ZVVFkvSWNlemRjRjdSNXZqdFNqV3lpdlR5OUFsOHc3THFsb3NQS2V2bGp6OG5qd3hTcG5xWWN2NVkySzg5MnpTaGsvdzdsNnBVa3VxaURBYXdubDUrdUxSOFJ5MDBUelo0d2JTWXFQYjJsbVhLMWNyU3BrblptSXY1WDIvdGpvZmdPQzdvNVY1dXRFVzdjWmFsUnFLK1JxUFVKc1EzaE0ybnozeGw0THUyN00vTmwrck9VZHFxdEtweFdwVm9TS1JFcjZSc1o2V3g2Mk5KUlNQRnp5Y3BPUUxRb2Q1b3B3TzhXYmtTQ0NldnlaOU1NeWNmczJmWTdKaW5tOVRhZFRmcE9tQUlJajN4elpYclIxNDZ2WmJ4SnhVNHBWNzFqcllNUVJQb0NSOVBTMkdqRzQ4Z1piNUpFNktvY25wWnpyRlh4Q0pXQ1B2NXdhZGh2UUtvWkdkNExMK3FDQk8zWHJoZ0hxdXlTQnAwcmVXOHdOaU1NS2VxRHBRcVFKdDExRHBnVU5aOUFlNUpPL0x6d1JkR1hybW1jeFVGWFFWZXF5aStyK296SFFiZXdPSE9Jamw1YWt0TmFqa0tBUUlrZ0ViL3pHQ01FVWFlcW16QXlTcTdqeENSZU92VDBqQUNHMGhOVlNWQkVhREFISVQ5ZXVGWVNMUTFMVjNzeWJoemM3Ry94dE9GOTBQRnBkbXQ3QThIeldmcTFobDlJOEJmdkdiU0ZGcit1T1R5Y2lXanN3eDNiTjdTN081aGlncDAxcjFDeFFCUk1FZ0dTZXZsT09iODN4cEhTOGFZczRwdytyUUxMVGlvRXA2OVM3UllFam1CSkFrN25iREthcWpmam9WVmVINWdWS3RPdHFScWRQVTRJMm5ZWWVMVmdrcVZpVE5jTTRobUs5Q3BUZjhzRUtGQjBoVkIzUFdaSTlNVjV4U0kvaWZLeHAyY28xS1BGOHRyVlQzZFdXazNBRVFENTdlK0llVEs0dWtkSGp4Y1pXZG56blpUSzhZeXNWRUNWR3NXUUhVZC9hVE8rUEtXWndscEhwdVM0N09lY1o3RjVUSVpsS2VlcU8ya251cVZVZ1VYV1A2ZVFZRzk5LzM2NGVWZm9uazhWWkkvRm1EN1hka3M3eEhqQnpncjVjcTlORkplb3FoQUJwbFl0cDVoZVdQUXcrWEZZNlBPeWVEYzdUR25aenNrL0djMVd5aWttblRwNmxlbTJ4QTZrWEIvbkhQbThqZ2RjUEdqN083ZGoreitYNEoyYnovREVVQU03QUVYWWdnQzU1M25IazVjN25PMlZjZUVvOGVqODZkdU1nY3YycXplVThTMHhwcUFBeHExYno2WTkzd3BwNGxKbkg1K09YNVdvKy93RDRoVG5jbytUNFZVemxGYUJxclZBN2w2WlpnSjNnMjZHK09pR1htNlp6emc0TFFveTJlcTFsRmFyUlFqVmMwQUZXTjlvaUx4aTdWOW5OR1RrN0ZuRkgxWnBTL2lJQUEydlA3bTJNbFJ6emQyRThKVXVsTmFJMWtOc040RXo2ZStNMGFQVkcxNFBUcEtoRlNveVprazFOTHJHcGdiRlQ2Y3JZNTVMUjBiVERPSURMVnFLMUNIVndwUStFU2J3ZjdZWEhKcFV5azZlMEs2ZXFtZExOT3Z5SFFnbmUzTEZsc24xMlJabVdYSkFCTTc4b1ArY0VPaUNlSjNZYVlQVUhmeStQcU1FVXNwYXU3RE5CRFRZajR4akVhcWgzMVBVUW56TVl4aktaaFdyWmwxTEZRYXJBQmlSc1NRWjJISWUrSE9JOEFwQVZIQ1NkRWdnYVNEL3k2bjBQcmdqQkZNZ2dDbnExRXFGNVdnYnpnQkRxTEZuZTdFU1JHbzdnUkcvVDk4S3doZVRvTTFTa3BWbFhYRWxyUVB1UFBFNU5KM1pTTWJSMlBzTms2V1ZvMVd6RE9Nc0dRaE5JSmR1VWVkdjV4NVBrT1VuWjZPTnFLTnYrTXlZeWROUUdGSFVlNnBKYzFHSWlGanJCbHo3UnZqbXFXam81cEM3aUNaV2pVcDFIVFdxa01LZEgvd0RWWmJxcS93RGlDZjV4U0xjZG01cG5qY0JGVEsxRXpGZW1jMVdLWm1vYWJBZ1BjeDFnR0ZIWDV3SGxmSWJsRjZveDNhcDZPWC9BSXRRSUtnWlNCNEFGQnVTUnkzUHZQcDBZN2JSSExOTFNNSHdMaVNLK1ZVMUFIdXBZbmF3bS9XZWZwam96UnVMUW1ITFVyWitrZXlPZXAxOHBUZW9kV3BRc3plUnk5ZXB4NFdaVkk5T2FjNEpvWjhmNFZrdU5aVHVzd29BMVROcnhqUm5TSjRwenhtRHJmOU5NaFhyTm96SkpCblFLUWdmWGEyT2hlWk9NZEhUTExIMmpZOW51QWNQNE5rNjZaUFNheEFGU3JGemJsNVk1Y21XVTJRbmtseVdpeGFiSytZQVdYYWtDQ0xtelJIMXhOclpSdFduNlB6Ny9BTlJlN3pIYnJQdFNmUVZLcWpXc3dCdDh6ajN2RGIvQTBpSGtyL1ZqWlZtem1YeTdLOUlaaWkya3hFbjFqRHhmdHVoSlFiVlUvd0RZem1jeWRUTjFCVHllU0ZDak1zNXA2UWVuOFd4MXd5ZmJPS2VMaStqRjhXWHU4KzZhUVNFMG1adHkvajduSFFuYVBOeUtwTWM5amFScTVvb2lqdmZDdExjQm5NZ2llZ0VtZVVZbmw2MHhzU3VSdU16UXkxV2hRUlVWZ1B5elVXNVl6TW4zRmpqbWhhV3pveWFkb0NvMWhVR2wySnJvSW1ZMWxSdWZPQmh4WXQzc1hWcXFzNkdsNGc0SkY1dmU4OUo2NHBBMHV5a0xET0hCMHhxSkF2TnpJOG8vYkZBRU1rTytyYWFaWUJsQWczMWVZUDF0akFzSVdub3BxRFVSUUdJZ2pZYlg4N1l3YUpaYWc1cG1FRldER29xUWZRNFVhek41dkxzOVd2cFV5S3pIVHpNTWZwZjZZb2NCUlRxVldnenJWZkNTUlkzL0FMZW1DWXR5K29PbzFORGJrL0pQbHlKOVBQR0dEOHFuZHUwSTBqbHBCOGlKOHp0aWVRWkRUaG1aSGZpWTBzNEVSL1NONDlmbTNuaVRqY1MyT1ZJM1BEdUlMM0NvMU1zaXN6dGVKNVI1QUFUNzQ1WlFzNkl5RzJWNG03Vis4Y0FLdEl4cDVDTmhmL2NERVpRTHhZWlM0c2F6MGN6bTJaSWN3cUVRQ2Zmb0FQS1IwT0pxTldNbVU4UzdTVnUrekNyVWRYZEZKWmxCWVd0cDZBWEErY05IRW10aDVWczVwMms0ZzlhaFhWM1pXUmpvTEV5RTliMjJ4MjRZeFJ6Wkg3TTN3aGpVenFvZkNWTXlUUE8rT25Lb3RhSjRaSGZPeEhGbVRJNWVkV29lRnAvYi9PUG5mSmg4ajZMeFgrU0ZIUjhublRtcWJMWXdTQ05wZzQ0NUxpTlBHb3NKUmtFbEFxaytJZ1duek9BNkp0TUZxOFNvMGFsWExaWU16VUIrYVZnd1R5SFV4aHFIaGpjL2xJT3lKVVZYTFdBcHhmenZHQjdKNWVsWDJmbTcvcUZURkh0bG4xbUlxQnJ6YTVBSHB0ODQ5N3d0WTEvKzlrdk1qZVRsL2ovaEQ3aEFuSjB3dFdhVEhVRnRIbi9ySExuVHUwZWhocHJaWDJqTlA4SWRKSWp4QVRwdUpJSTYzNVlwNC9LVFRPZnkrRUZSeEhpbWs4UnpVdEVFUUNEYzgrZVBidE5LajVYTCt6R0haNnZVbzV0WHAwbnFrS1VKVWthWjlQNllrZWZwaEp3NUlPR1ZObS95aTFINGU3MXN1OU1Nd0toejRpU0o1YzVQbGprZW1kampxencwRkJwVkgxTUpKWUtmMURuQmpjREJUZGc0Mlo3TlZOVGlnYVlDQUhTRHRHc2pmcEVXeGFQUkp1blJDdVNjdFdQZGtOcEpWajVkT2w1d3huMHluSzF0T2JWVUVBMFZPc2I4NU4rZlBERUE2blVINGlwNFFWWVJxdkE1Zk1FZkdGT2hsUGVGN21uckhJcXhGdm5mRENtZHppbXBtYWdtUXpzUU45bjJQVXp6dGh6aUthZE95enUxNUoyTzBEejJqMXhoaHBsNlVVbmFWT2tXa21GdGYrUGpHQ1d1MnhRcUNOUHdmTDczd29UN0w1bHFEc1VWZFNUR3RyeVpIK3ZiQ1Mzb0tsVE5SMlZydm02Wm9ueFAzZFFONHA4ek5zY3M0Y1hSMFFkb1pyV3FMUmRWZVMybFZDdHVKTnZYRTJrNUt6cWlXWk5xcHA1ZEdLaEZxWEJmeE5lOXVYK01DVVZib0xkTkE3Wm5WbjYzZk9raFNBSmthdmYrZW1ER1B4RE9XekVkb014cnFWYUlzTkxHSms5TjhkY0ZVYk9USklYY0ZjTHhIS2hualVZMWVkNzRwbDZGd1N0bmEreWxQLzBoOENxb2FCeWdua1Q4M3g0bms5bjBmaFBSMExoK1lYTG8wQUdWMCtLMC93Q3NlYktQS1IyU1hJSi9GNXppTmI4SGtpVmRoNHFvV2RBamYxOHVlR1VXbVRxT0w1eUVmYXpqNTdDNmFOYmhPYXpHWHJFVktXWVNvcXlZOFFKLzUySlBXY1d3NGZ6S295SXl6S1VYSytodjJSN2I4TTQ5bHF6WlRWU3FwVDhWS3I0U2t4L25FOHVDZUIwU2pKWmtwSTV4L3dCVDgvd2M4ZHI5eFVENXFybFdwWmxWUE9KRUhtYkRib01kL2g0OGxKcm9HYkxCTGkreEwyV3pUdGsycHZHdFlJRFg1YjdlbUxaNFh0aitITlA0b1c5cnM2eHFJa0VnS1dZN1R2UHZJR0wrSGo5bkovMURNM3BITjhubEsvRWVJTFRwdmQ5V3JXUkNLZHpQcmowT1ZXZUU0eWY3R240ZHc3TEptS0ZQZ2hlcTYrRjZ6alRMSHk2Ymk1L2pFbkpOT3krT0x2US9YTDUwVjhxMmZxRUlxbHFGTmpaMkpna25tTjcrV09lNDhkRHppMUpOaEdacktLU0xUTWhwSUpCNTlTT2VCRjA3TFRNMjFHYWkxckZTU21ycnY5Yi9BRXhkUzBjOGxib0xhbXJ2VUZVNmk2bUZVMk1qbGdjaGVBcXpPV3FVczJ0V2cyblF5MnRwZFRhQVBuNll2Q1lzb2JHcUtwa213UVFQVWpDRmZaVzFaVU9sd3MvK1ZNTWZjemdVSndNdFVxTU0wN0VsR0x1TGJSSkIvZjR4YzVTd0ZHcE9WRHNxekFpSW0wam9aSDdZQVExQ1B3N1N4RVNBUTBpWm1QUHp4akh3cUVWYWFqOUtnQVRjL1Q0akNzSWZ3VGhlYTQxbU82eXlNS1ZPMnVkSUFFbjlWaHZFa2pwenhMSktFZSt5dUtMZitEcFBaZnMvVnAxY3hYRk5RY3hSMDB3ejd5cGtrY3ZzNDRNbVN6dGhCUmFvTjRYMlphcStYUnFRT29MQkIyRjRFRWRZT0p2TFVVaXlqY2hOeFhMZmhPSVo2bVdiWFNySFU0WGNEWS92OWNQamxhRmxHbTJaK3RtU2xhdFVkQ3BwNjJZSFRMN1JjZFRQemk4WTh0SE85TXduRzJpclRlU1hKWmkzNy9Gc2RtTlVxT1hKUFpUd05tYmkyVlVCbEFxZ2FoeXVNTlBjV1BqZHRJNzkyY0pUTEtwUWtpcHBpMEN3Qkg5L1RIejJkZkpuMHZqU3FLTmZsS1lxVmtvbURxQjlJQi9ienh5czZKU05GbGN4bE9FNWFBLzVsZHBneEp0RWJiOU1UYWxQbzVNejV5UE9KUFQ0cGxDajBqVnBheEt2QU16SE93YkJVWGpmeERHTkhGZTJuWlBQWkRqQS93Q3hVV0ZITVV5dFlvM2VVekJCMG1EWWYzeDYzajVZNU1UL0FDOXA2SjVzRG11VVRuR1pvVmtyVkJuR0tWWklLeDltTm9PMlBUeDVMVkhsWmVhbmJOTHdHcVVIZUt1a2FWVnBQa1puNm5ITmxqWjZHR2VyWXE3VDVvOTFtNjZTR1Nub0E2RXRBTWRiSGx6eGJCajR1amo4dkp5Um5lelZKODdubHl0QjlOSXF1dUpNa21CQS93Q1VrL1BURnBmRm5uUm0ra2QwN0Q4QjRmbDhpT0k1bWpseUZaZ2h1QWVyK2hNZ1k4ZnlNemNxaWVsaXhKUlFKMm00ZFd6SEY4MW5HTkx2R3BvbE9sVHVLRk0yV2ZXWkhUbml1R2ZHS1Q3SjVJSlMwWnVwUktsUlRaRldtMmhEc0NlUTk3UWY3NDZaNzJKVkdienRSM1ZsQjhlb3JJTVFWdFBrWW5Gc2ZST1lXZTk3NXl3RGdvQ1FCWmlEYTNLeElnWUV1d3g2QWtyOTZhYjZsL01FTkpzU09SNTlNTndaR2M5bG1VcmhVQXFUSVVpUW9nOUpHTndLYVBhSVpWT2drU1pJWlJ2SHJoakdOekZRNjZ5c1JyVjN1Q1IvVVR2NWpsNVl1Y1lUUVlzaExDQ3F5R1pyTllINzlUaFI0U1hzSm9hVFJDQzUyRUdiVHQvT01DWGJHL0JzZ2N4blN1bXlFTkxHSjJqMzJ4REpLbVBqamJPb2NJeVNqS010R2xUWkIvOEFVZVBCSElBVzY0OC9KSzVXenRncVZCMlhHWnAxQlRwVURRcENFWWxmRXhpZEpKOXZMQ1dtNktOYjBhYnN4eE42R1ZwdDNuZkVFeXpBQUFhaklCK2s0NXNrWFpSV2pNZHJ4VmRUWHlWTFd5dHFOUGJ2QkY1dHlHM1hGY0QrMk5OY29tSnpuQ1RuNkxQa3E2Q2tISGVxQnBaVm1mOEE0OHpmcGpzamtxVkhMS1BLTmV6bkhhT3BTcDUwaWk4cXBKRTduNC9mSG9RMnJPTEpCUkYzREhGSE8wWEZnRElITVJlY0dTdE5CeE9tbWQ1N0g1K2xtc3NoWnBCRWdBejV6NlhHUEU4cUZObnYrRmxUVk0zQzExU3JTcUxxa0JrRnJIbkgvdHh3VWVoTktoVm5lRVp2dFR4aVV6dGJKNVhMTEt1cWtrdHlFUkUyeGFNbzRWMVp6ckhVdVZpYmpmWkxpOU51OHpuRTg1bWxCbnZLY01GLytCaTkrV0dqbWhMK0svMk96SGlqTDNRakZLdmxtZWpsK0tVU0dXUHpMYWZZRVRhTjhYU3hQdER5aHhUU1puODdscXY0a0Q4WGxHYVAxMDZlclNQbi9XT3VHU2xvOFR5b3hUdTlnK1VkcUl6Q0d1V3FIU1VMaU5RamZ6MkdLU2Rxem1qTXovYVd0VVRJNllBYXJWWVJ6Z0dmOFk2c2Y3TC9BQWNlYWVtZ1hzbG1teStaYW5UMW10bUlRRmJSWTh4ei93QVkyUlhJamphWC9rN253L2lqRGhGQVZNMkM5RngzTk1zUEdRQUZCZ2NoSkk4OGVWa3hyazZQVGhUUlZ4WGlkR2x3K2tsT3M1eldZTldvSFlYOFMrS3AxZzJWUnp1ZVdOR0cwVGxYYUV0SlZlZzhPTk9zS1ZrRzBiZkZ4aStTVmFReVNhMkxPTDhIWE4wZTl5a1ZjMEc4ZVhJQUZUVCtrckg5WG41NHBpeTdVV1F5WXIybUphS1ZSM0RWdEpjRFF6UjlMSDM4OFdxTGRwaUpWcGdpNVdUM3hwNlhSbTBrS1FUSWlUKy9uaHVaT1VDOVpMQ3cwZ0FXdFBzZm5HS0VnNXBxRlR1QUkyTVcrdU1BeHRiU014VWd1ejk2ekV4YWRUVzg1SHZmRnpoc3RRc3RZSlQ3endrZ1dpZkxDaGlIRm5SbGVGbDJZbU54WWY1K2NZZDlteDdKMDlXVXJQVENDclVlQTVNYUNiU1JIcmpqOGh1MmRHRmFSMHpLVWtvVGxLYXFxVVdTVzNMTmVSZnpqSEN6cHVuMFhLaXdHT2s5MkFuNlptUllmVVNmUENlN0tyWlJTRlJLS2EyVUdqVk9zQWFaTzhiOU9lQTY5anBXVWNUcVZobGU5OElkQUNHcUdOd1NTZk8yL3RoVXFZMi9Sekx0TFhOT21IUmxjMjFPVTBoemNRZlNRZk8yUFJ4UVV2MlJ5NVhTMGMvempHcm1tZW9RSFlqVWVaa3o4L1RIYkhTcEhCTkxzcnBVelN6SXBxeExmMG14Ti9zWUwvb0VlMGplZGplTU53bk5VNmVaRGFBeEkwOUkvYTMxeHllWGdVbGNUdnc1L3dBZWpyS2NRcFpuTDBNMVRZdlNZd1hPMFJZbnl4NDdoVDZQWVdWU2hZNzRmeEpLZEk5eUNyTkJGaWZrODhSeVExUldNa3k3UGNPek9leXNVNnA4YVFkQ3dUUElIbGhJdU9QdEZhWHN5K1o3QXF0ZG1yMEM3dGNHbXdhNDNuYy82eDF4OHhxa3VoUHdRbW02L3dDVEo4YTdQWm5LYW5ZYUtLK0tCQnRjU2VtTzNGNUVadlo1L2tlSHhWcm96RlFqSkdvTldvd1JxLzQrZnlmcHp4MVJYSTRacmd6RjUvTi9qTThocUU5MmdPbTl6OXo2N1k2WXF0bkJrYWxJdTdQVWdjMmMzV0pWa2J3d3Y2aVlqQW14b3JvNkprODBUdzVGcUJtUGVLWS9xTjIxTjVHM3ZmSEZPRHV6c2pPTFZFbnFWYTJhNzV3MXdpZUVTRkVXOXJDM0lZS1FQN0RzdTRHa0Z4VEdxMG1OK1h6em5tTUQrVmxWMXN2elFmTGQxVGNnclVwcURJa2dFYlQxODhLdDNadFZvU1p5Z296TktvRVZaYlE0VmZESUoyRWRjV2dpTWdEdnFlb293T2tPUXdrRGw2ZW56aW5Ga3BOMkRPZ0dncGRvaTRrSDcvdmh4aU9aQ05VR3N2SVVDUTBUYnpQN1lGaWNqTTFEVFd2bUdjTnFGVWp5UGl2YU5zZEJ4azZUK0pOUThNeHZCWWV2TGUvWENqTFF6eUM5L1RxeUZKUUJpQ0NBUnNWamU4LzJ3cmRGRWt6UmRqc3BuYUdacTVldFFZS0ZoS3JSRWJ6ZTU1WTVjN2kwV3gydEhXT0g1U3JVSmVyVENMVmlvN245SWJjcXZYSG5UbHhSMXhmMkVaM0xuSTVidkUwNmdOUURibUxYNlNZdmdSbFk4bnJRTncyaS93Q0dZVlhWbmRtcXQ0WnZibjBBbkN2YnBqUWRxd1R2MHlqVU0xbm5RY1BxVVJUckJrMWFTcEkxZXQvcmh1NkhiZGFPZmRxT0cxTXZ4S3BRUnFkZWcxUmpUZWxkWHB3U3BKNU1JajR4NkdHVlJwbkZsdDlHRjQ1UVU4UnJHbXRRZUhTeWtURENKKy9QSFdtMnRITExyWlcrV3BQbXNwbUdWKzRxYW1jVTExRWRZdnNNYmt1bUNFRzJxTjlTN09KbitEZC9TTFBVcEdGcVNWQkZwdHRFMzg1T09CWjVRblRlajFjZmo4b092b1hjSTQ5bU9CMS93dWF2U01DQ1ROdWNiUmJGSllsUDVSSXJOTEg4SDBiYnM5MmtvVjh1aU95bFk4TG00QnZ2YmVjY0diQktCMjRNNmwwem91VjQ4aTVjV0U2Q0NnYVJ5dDc3NDRaeGxkSGJITkZxMkJVdTBGSitJQ2pUVU5NdDRQMUVIWSszUEN2Rlc2SGhtdlNabU8zSEZFeTlKcUZOZFRQTGhRUHI2ZVdPenhjTGN1WDJjL21aNmp4czQxMmw0aUNCbHFSWHZXRitnOVBVNDluRkZyL0I0ZWJMNk14U0FNYVdPbHpjU0pBODhkTHIwY1NIbEtvUHhLVVVsWUlDaWQyaS93QkwreHhPU2JhS1JrK2pUNWRNMVh5ajV2Sm9LaFRRM2RLWkxnTVJiMkIvL2xpYzVkcjZMd2cyT2tXczlmTHY0aGw4elNCQmdEUzIyNDlMK3VPZE5kbGFsSFREc21OZVdQNG1zYWZka0JtMGFpSWprUFlZV2Nrbm9yRk45bnVpcG1jMDFPb3dwcUpVUFVRZ2d4WVFEYThYNkRBVFNUYUVWc1QxVFVySVdxb2lQM2gxS3BNQyt4bm5JT0xKcFUwTEs3RlZlazlOdkFpa3Ewc1BMb1IvT0x4bFpLU1pUcVl1MHJ1eGlERWNvKyt1RFJySUtxc0oxb1J5bEp3YUU0b3lkWjlPYnFsTHAzcEdtWmp4RzNQMXhVNVMzTDFnYTlOdzU4SXZGaUw4emdVTU9lRTEwVE5IdkNGUjRVRy9sSHJ2UHNZeExMSFE4ZmkwMGRMNEpuTTVrc3F0T28xQTBsWTFKS1JJYXhJSnVOd2ZiSEZPTmFPcE90bW80ZnhITUFBTFdvd2lRb1NYS0hwMCtjYzBrbStMS3hsZlk4YWozOUhVNzAzVW5VQVdZbC9LUnltTjhSY2ttVlM1SUZWS2xKNjlRcW9wZ2xWM2gzdFlFKzhZeiswVVM0cWpNOFg0aFFwMWErVGRXYkxzeFYxbmRpWUJIbmlzSTJyRWxNekdjYW53OU5OTExxMUdveTA1aVNYM2t4NUVSTTdZdWs1S3lMbGJNZnhHZ2xiT1Z1NFlsZThaWUE4Uk1EYWJiQWs0N1lOeFd6bHlLenpzcFhwSm1XWE1VMXFLcGQ0SUJFbFlQdnQ3WVhMSDJpbUIzcG5YT3cxRDhJOWZJNWltOU9uVWl0UVlnQU11a0FnZWh2R1BJejI0Yy9aNi9pZkVVZHVleXdZVml0T0ZhR3BWRkVhR0c0UGtiWXY0bmxKS21MNWZqYy9ramx0V25uT0U1a3RTMVV5V1pRNnpEWDU0OVZVK3p5cHhuRG9kWlB0Ym0wcGlqWHk5UmdCK3FsVTNIb2ZzWTU4dmpKN1JTUGt1S290b2RxblNvekpTekNzU0NDcnFXdE8wYi96dGdyeHJTdERmOXpTRXZHdTBWZXEzZTFVZHExL3pIZlV3a200OUkrdUtZc1g0M1NJWmN2SlhabFhmdnFtc3F6Rm1NMjFFZGZYN09PbGFWSExLVGs3WmJRMDBxZ3FsYlNKTWtnRGVQUXdMNFZnUXh5eW44Y0xPNnM0SkVSS2tTUVQxQS9qQXVpbEpOTTdsMkw0RW1YeTlETVphb3labkxQb2FtVk12U0xTcEEzZ0NiK1J4NVBrWkhibzlURkcwbU1PS2NEb0pRN3BDRVpaWXFWTWZxL1dzYittSVlzbEZaWTNrZklFVEwwY25MWjRvMVBSREVpZFlBTm81bmEzbGk4M3lldXlTZGFZQm1zNGM1bUt6bGhScGtnRmxVV0VXOThPNFNTMlRTU1lpekRCVldtN0xxYXJjMUR2TmlEODRvazNvRW1yRjNFVFRZMUZoWVdTQ043d1krdjF4YUtaR1VoVzZNMVE5MkVnTE84bmI2WHhhd1VSY0dvdE5nek1OTUNYTnZyZ2kwWTJvU2F0WUlJMVZYai94T29pLzc0dFJ4MFc1VXIzaUZSSU1CaHZ6OHhFWUFiR3RPbzFhdFVwVm5KbHdTWWdqblllVWNzTE50cXFIaTdhczFuRHM3bUVvd1FLaWhRdXVESUFtQ09zakhKS0owcWFacWNuV3JabGF0UjZ6RFVvQldvMTFKdnRIemlMU1R1aDRtaHlQRkNtVlYyWFMwYVNDdzBqenR5eHpUaXVWbFU2MEFjUzQxbWF3MHFVNzlMQkEwYUp0OVJ6d3lnbm9kTzA3TXBVektEUE1NMnpKVHBVMnJNNGFEcWlLYXoxdVcyNllyeHFOUjJSbFA3Rk9mcTVLblJvbkwxV0ZkUzZnVldEck1CUURFR2ZJamFMNHJqaTZwazIvb3N5K1dJbzVnMUZBSUoxSCtxZEpKUG1TQ0IvYVRnTnU5TWZqOGJaazhzMm5OVlhSaWxJTXN3Yk1DWWtiUjF4MVNYS0ZleUdOMUswZm9XcHhMaG5hSGlUVitBNXZLdm5GY1pnVXZFamtpQUdBSUZqY0hyT1BDVVp0Ty9zOWJIbFhGQjlWcVdmeVNPb1lVNmlocmtRRHRlM0l3TVJqQnhuYU85UGxFdzNhdmgxQ21rT2thcXBqVUJLRW45aisrTy9ES1o1L2tLUG81VFhSOHRXcXAzYjkwR0pYd2tBaVkzNTgrblBIcXIvSjU5TDZLYzVtZTZva3I0U2ZDRFBNY2g4SCsrR1d4SlY5Q0d1WHFNMVIwSlRjRXJJQitQU2NPdE01WDJWcW9BMk1yQ2lUOWZmNlh3YnN3UXNsRkJDRUJ6T2x2MzYzSStjQmd2WXl5dVlVQ2srbVhSbFZrSi80M2lldksvVENTaTVkRkc5V2R1N004UnluR09DWlNubDh3dERpZVdwaGFURjlJekZJTUNMOG1GNVUrdThqSG1aSWNaUGw3UFJ4WkU0cE4wTXN6eGJQbkxsR1ducUVvYWlBaDBBL3FpZmtERVlZNHA5bEpjMDlDM0tWSzlXa2xCNmRUTUdtbXBuYlpPckVuNjR0Sko3RVVHdXhQbXFpcTVPb29oc2Flb0V6dEVqbHQ5Y1ZpM0pxeVV0TVRadk1kNWxuV2lBcU0xZ3hrOWIrVng4NHFsUXZZc3FHbTFiVXdFYkVsWjJBM2pGWUVIdVZGY290VXFFWUJkdkRKOURnbFN1b1lJaW9pZVRnbWI3anl3Yk5Sa3FxRTFtVmFiRXRWWXBKbitvL1hZNDZEaUowYWpBQnpMYngxRWZUa2JZRkFvSmRTd2RsTEtJbGZGZUk1ZlRHZFZRWDFvYmNFenhUdnN0bXF4MHVvQ3NyVERXMi92NllqTlVoc2RyUnIrSGNhZmhiNmM1cXFJU0ZEL3FEMjJiMmlmWEhITldyT3RQam9lMWMzazN5VEd1NHk3a0hTYWFnazlCUFQvT09lbTMwVXR2YVF2NGptS2JWU3RldGxhZVdVUXAxU1dGZ1pqbGVJK3VHZHFsUUx2cGdkYk9wbmFReXVSRGQxUzAxejNvVUNvWkVGZ0J2dkIyaTIySGpHVWRzUnU5VVdaYmc2bnVucjFLTjFKYUtpaHlTMG53OHR4ZHJXNTRNczFLcUt4eExzQTdaWnluUzFKbGFKcDBuWWlGcUJoSUVFTDFpQVBNNE9CUGkyelozYlNSazZPVllqdTFLNnBVMUZtWTh2M25IYkw0cFMram53L3RUTjV3Y3J3L2krVHpuZG83MFVEQ0pVT29KTWpiN0dQT3liaTRwSFhqZ3I3T2hyVXl0RGlKL0N0Vi9DWnhPOEFhRkMxQitzUjB1RDVnNDRuR1RpMnZSNk9PVGNhRjNhTEswS29wTFZZQkFaMUh4R0R6STg3ZnpiQnhTbEVYSnhaZyswZVdTblFxc0F3b2dGVHFYeE9aSjB4TnZXTFI1WDlQRmtiZlJ4Wm9LS09YVm5xNW5NWmlxdFBSUkZqSFR5NWN6ZTIrT3hmWjVrM2JLcW41am95a3FzYVZHbUFBT1pITW42emh1OWlFVXFhYmF2NnQyM2dnanpOeFB6eXdURUZKQkdyVUNZRXFZSW5sN3diNEZBRCtIVlZMU3hXb0UvcGduYmIrUDJHMk5UVzB5cTJxTlQyZHEvaDZtdVFLWVh2cEJnc1ZKdUFDSjVHUmVUam15d1VuYjJXeHg0OTdPZzhPN1EwT0p3alZvcUVhcUZhdEpWbmdXUG5QTDN4eHl4VTdSMHZLMk5pSytYb0xtS2JaZHFkVlBHR0VkMjNNanpqbDB4T0NjaG0zVjJaRGk5S3ZVemROZ2l3VktsVkVEbElIUVk2OFRUVFJHY2FhRkF6S0duWE5TSVNtUDFYOFZ2Q2JYM1B6aWdrWkpzcERkNCtxVTBzTGtKQmczdU1QSFF2RDVjajVuM1l0SWlBWmk4WC8zendSaWgzQ21DYWFrVFl6MTVYd2FCWmxNODFUdjZ5cnJEbHlWRWdtTlVSUDN2am9PTXJiVUtqRUFscmN5Q2VVZ2IrZnZqR0w2TlpRQUFqU0hHelhNRVNJK01DakVzd29UZlRLcVlJQnVQSSt2TENPT3dtaTRKeDdVZ284UmR0U2doSDJJSkVFTkVlbUk1SVU3WFJTRS9UTkhTNHZsY3RST1hxSEoxNkJTekd1VlBQejJnM3RqbjR0L3FqcjU4VlF0eitjcFZhckRoaTBLQmo5WC9FQVJ6SFQzeFJKcGJJenBQNHNERC9ocU5ONmRVWmhXSVoxSlBqSkZwSjN1RDlNSDl0U0hVcUxLWEg2N1VobDJyaWhTVlRiTHBwYW9EYmZyR0YvRkd3U3lTZnNRY1g0blZyaW1LZFpsN3VRdWxqcFNTSkE1a3pNazc0cGloeDBMa2x5Nlp2OEEvcFgyZi9IYXVMNSttRFJweXl4Y2xnUU9lOTUzeHkrVm0zU09yeFlyaTJ6WThZNEJTeWZFTXJWcVV6WFRNUDhBaDJwVlNHTlNxUkxBZFFENVk1WTVHenBjWW8rN2Q1K2pWejNCUlNOTTE4dGx5WE5KNWhUb0NnMy9BUEZyRzhIQnhPVW90ZllZejNTSzh2cjRrVVFzcERVZzcxS3A4Tk1RTlJjbllYT054VGRJYmxxMmN6N1pjWUdjek5mSzVKaXVXUjZpc1VVS1hVOGlKL3FBbjBJRVdJeDM0b2NlenpzK1RtcVJnOHd3ZXBwcHNBaVRlL2k4L2JIV2tjSkU2a0xrbHBDa3daOFZoRzNJZnZnOUdJcTVRbFNDRkIxWE80NUM5NzlQUEJNUWVtRVpZRTZKM2k5OXRyV3hqRFhnenBTeldxcFNxVmRTbFFDQURwNmsrNXVMMndzazYwUEEzWFo3TFpXdlNxOFJ6MVB1YUliOGhXTEk1YVpFZmQ0eHlTbEs2UjF3ZW14bW1hWE44Tld2Q2lwMzQwYUFCQmtDUkhNOU1TdVhKeGtPcWFzdnpuRllwVUtiT3FueGVFbXdPODMzblNwMzVZV0VIVFlGTGRFZUk1MUMxQUVoRFM4UU14QUEybVIwajN4WEFuZTBMbG1xdjZNVndQdnYrMTZxMGhpZFZ5VGJrRDFqcnp4MDBqbXh0cDJNV2VxSEJiVXBDNkJjeVR2QjY0MUZPYVBSS295dzZ3ZzNINm9VaWQvdWNBUE5FSHBrYVJCTnR3b1BNOWNNWXhOYlFLbGVEQldveElZZE9Yd1RpNXlFSGJ1U3hhRVphamNoR3EvTGtCYmJCTVQ3OUZEQU9OTEd4VllOcDZmUCtzWXdXbFNuVzBMVnErTW0xcmJ5TDlZZzRWb0pZeW9jeWk5NHVwajRXbTQzSDl1WExDdHlXakZ0SlpTbENLOFRNZ25tT2NXd05vYTc3TEh6MVg4dHFaQ2drRWhtbWVSM20yM25HQlY5ZzY2UHF2RjY5UlVwQ3FIMGlBcktGMEEvV0ptM25oVkNtTThsSVdWYzFYY0tRVFNwZjhRVEVkRDAzdzFDdVNsbytvSzlaeFJRL211VnBLQ0xhcGo3OWNCMUhiREZLMGZxUHNsd3FqbE10a01qbFF2Y1BHaUZNRktJQkJQUDlXa25IZzVKdHlia2UxalNVTkgzYkRNRThQNGptMDFrNVJxV1h5andSNDJyQXM4OVlVMzhoaDhTYW5USGxUVkl5UFp6c3UzRVZmTzUzTTBzaGtCTG12VlM5UURkMVgvajVtMkt5eWNIUktNVkYzSUI3WmNUeS9EdUNQbHVIVVN1VnN1dk1rZDdtamFDWVBnUWZxMGpGTUVlVHYwVHo1RkJWN09PWjFobDhtRkVyV3FTWUFrcXZVbmNmNG5IcFJpa2ViTnNEU21HOFRyVDhZSmcyRzl2M2pEMmdKcWlvQTFDNFNZREVFaXdzRC9CeGhYdDZMR0pWd0thc1NZRVJjRzIzWGxiK01ZQjhLVFU2eWhnVlNRSkp0dUpJZy82R05ZV211eG4yY3lkUE52VU5TcWFUSXc4SVFzU09RM0VieDdZV1VtdWg0UlQ3Tkxrc2pTemVacEFack9QUUR5eHFLQ1BEdXRqQWorY1NjOWYyZE1lTWVocm5DbVhxZmxVM1hLVVFXMU51OVRWT3BqdFk4dk0yaStKSzJ0alNkdjQ5Q1ROY1ZwUG02YVVIcGdCajhibjJGNTlUaWtJdU1XYy93Q1NwVXlXZXk5RE5Wb3FadDNCWWwwZ1hQa2Q0djZjc0dFcXVMTTdrVzFIU2tEVFJrQVZRc3gvanBIeGh3cEpJOHFJck14QnFFRVJxVUdKOHV0djJ4ckVLbHFDbVgxa2xpU3h2dElzUiszdGhhQ1dvYWdXS0ZFVkZIUHZQdmxHR0tHT3pSVTFxaTNWZ1NBVU1TUXhGdW00K01kQnlBOVVMM2lhVlNDeDU3QW1JZ2UwK3VNWThwb1hGTldnVEVONmlkdmZmckdNWXVwMDZqZ3J1QVNQRTBTeGo2eko5c0FJVTFQU3dacVlCMWt6MFlXdVR6dGZBWmo0MG1xekNoeUhnaVJ5TXdjS1k4cjFOUDVTRlhCVWlCL1R2QSs3NEFMb3J5dE44d2FqVkF1a1gxTUFSSkhQNCttTU1sOW50VEs5MmxONWtmMUFSWXp6UDBuR05RWDJkcHJVNC9sYWJnbEVxaGl0cHNRM3p5eFBJL2l4b0s1SS9WWEFLcVU2V1pxTUFGeVhEcXlGVklsaTFXRjlDZE1lK1BDbW0yejJvZnFrWTN0Vm5FcGNMNGJ3bk5QVkZPdFdxWnpNVkZDczZVNmFzUENOcDFFd01kRUlwelQ5RThyYWVnT2x4SFBjWldoVFlOUXlRcUpUeTJUcHhyclZGSGgxRS8wZ2I3QWRMemlxaFV0Z2IrSnkvdGx4Sk9LZG9xM2NQVi9DVUFLYXVZdVZIaVlBY2l3SUhrQmp0eFkxR05IQmt5S2Nyc3lKWjgxbUZaUHpRU1FFVUFjOXZmOEFiRit1eU1uZlFRcWtWRkQvQUtwa0U3SDE4dnZmQUJ4YVd3ZG4wVlM2QnVnTUFpUmV3NVIwMlB0aGt6RlZGTmJnT3FNMjBtZjFSWWREL2pjWURCN0RxdFB1TzVZTFRlSEpJZExNUUx5T2NubGpCWjVsS3RUS1ZxZFNreXM2S1ZMTUpEMDRnZzh6SUorTWFrd1hReVR0UFhXbnFxOTJnL1NkRktMenkrOXdNVC9IYktmbGNlaWpOZHBxOVZXcEpUNzFEYjg4YXR1Z0hQY0QyT0NzWUhtY2hBOVNwVllWR2dRMHdpd0J6dGl0S2liZnNaWkxqVmZMcVVySnE4WllWRE9vMk0veGliaHUwRlpOZG1tNFp4RVptbWU3RFZFSkhqWnJneHRIUGFad3JHVTdEWHBrb05YaEFqYTRrV1BtZWQvVEN0cGRqclpDcnAwNlFCY2VJQnJ6YjVGdC9QRG1LcUlYTUJtVVNBeEEwRWlCdVBVd2NZZmtqSnZTTDV1cXFHcXpMVk1Xc0JxTi9QRjdSeWxPWUNtb0pWMlVqbEpPeHZ2di9iQk1TN3dhaVdaaVo4WjIxWG1KR3dqM0dBWXRWYWFVZEx6NHhNeFl4c1o4NzlNWUpKalJWM1ZTYnNkT20wQ1pJQlBtTUJndEh0Yk5OV1Y1Wk5OOVJKSTVXdjA2NEFUN0taRU84T1QzbDFnam9UZjk4Qm1TdGhsSWFGSnBxNEJzTG1TREhuOSsrRktTU3JSSHVGZk0wVlJDVE5yWG4rWUg3NEQ2RlI1d1JpbkVLemFOTENoVmM2Q0RIbk93Rm9rRHBoWjZXd3g3dEg2SjRSbURuS1hFTkNHcDM5REtVU0FaREFscXNHTFgxQWUyUEh5cW16MmNUdEl6SGF4RXpIR3Nxck5xN3RDamJuVWRiRW5jYytXSzRsUzJKbWE2TXIyaTQzVnl6bWxsYXVoNjlGc3RTR3hwVVlJZXBISXQra2VSbm5qdHh3NUsyY3VYSlVhVE1KbkdhaFJLSVdWbVVKYlpSQkgzNll0RzZPRWp3K2pEaHRBVUNRUnpKSUczcE8rS1MyVWlvL1pkbVdCUlgwYUNRQnRjUUxqck1nK2VBTkpyN0JLZEJxb1BpQ2ttWEhRM0k4djk0MWtVckdyWlZNdGwycnZUUVZDUUFvM2lkcDVkUE8rTXRsSXlVVlRGZWNxVWhYQVlhQ2c4TURZamtKM3Zibno2NElzNWNuYUsyUStKVEVQWXpVbThEbjZFL0dNS1ZwU1ovQzZycUEyRzgzMlAzZkJScXNwYWlxazY2aW05Z2szMytQcmdtcWp4cUJTUWRTQlJJTEVnekV6Ymw1NDFnYUs2bEFhQlVndVNaTnp0MCttTXFzSEVsU2F2bGFnZW5LTUZJSWkwYndlZlA2REdsRkEydWgvdzdqRE9nb1Y1YldOSmFaMG5wUG50N0RFcFFLUW5ROUpXcVZiVUNOMU8yOXhIWEdiS2Q5RkJka01zNEdyeER4UmcwUDhBRXp0WUQ4VlVJSWFwM2pxYi93RGtZK2JmR0tISUNnS3pNZTdsUitwWW1TVHpqZjEvdGhnbnRiU01zaUdEREt4QnVaaUQvRXhPK01ZSFVsMUlDd0JOU1F4bllUN1lKZ3hja3lsSHFHRnFqU3VnbVpJdVBtODR4bEcyZVprTGw4d2FmNnU3dkEyc1AxRDI1ZWVGWThsUWJsQzFLcjR6SkpFdE1neWJtZWRodjU0VmdSTlhIZUlOR2xUSk4rY2Y2dHlPQVlZWkhRMmVPWllQb3k5Rm5obWdCaUNJOTV3aytneDlpN2d0S2FXYjFFd0tBcHlBVGRoYTNTMDN4cHBOMHhzS3QwZm96c0h3eWx3YnN2VHptYUlOVmFKck16Q3dNQktlL1FRY2VQbHlxYzZQWHdxa2MzNHh4TEo1YktQbU14S2lxN0RRRExiR3c4N2kvd0RmSFZDRnBJNXNzNmt6bnFOWHoxYk01NnFTQURPcmJmYjBIM2ZIZnhVWW5GQ1hLWUJtR09Zek1oeVNXdHZid3dML0FFUHJoaVl3U2FXVUNJYWY1aS9wM0VHMFg1VDcrbUFZcWRScWw0WUxFU2RNUjEzK3ljWXdadytqM3VhZVdDQkFUcU1FQmVSTWVlRmtQRWh4SmorSXBJdW9BeUZBSWptQlBXK05EbzArd2JNVXFRVU1LYWsyQVpUTUM5dVptSkVYMk1IRGlBZFduWHRxaDEwM0treElrbmZsdGpHS0JxTklXY3NRQk84Q2YyNVQ2WUtBVHBvdXRpM2VBYXR5TEFBRTR6TVgwdzFSaVhKWUFlTHc3UlkzTzFyNFVmOEFpU3p0TUl0T21OUmI5UmIrbUlOajdBNElvUG5LZWpVWHA2cFd6QUVDWU1SUFdEOXhoZ0FwcEt0OVVnRGUvVDdQTTR3bzI0UnhONlJGRE42bnAyS21MZ2pZZnZoWndEQ1krYXRVcGtIdXFqaHhxbmY3dk9NV001VzFMbXFySVFUcmVWRUNibjZ5RGhySUFMaVhDd1AxZUtMVGVQdjBPR0NmVms3eW1RZkROeUFPbCtXM3JqR0NzalROT1dsZGJEYU51djhBRnNFQzdaZXcvd0QzTlZsQ253S1EweEN4KzRQMHdDc3VnVTFDS2xCd1ZKVmhBZzNJdmNmR0F5YTloRkJ1N29rQm1CY3lMbWR6MHR0cXQ1WVZqQldTWXRYck1vSlVMdHpraWJmVS9Zd3JNSFZLeVVleithcHFvRlhNVkZVek1hRU4vd0J5ZksrSlA5Z2x2WlBoaDRqbjhqazZhNm16bVpXbjNjd2RHeHQwQUpQdGpaNWNWeUtZTkg2QjdiOFF5L0R1ejlhbnJDcFZxR25xVjVpbWlpYjhnRmdEek9QS3hRNXpzOWJKL3B4UitjTS9tcTNHODczbFVuOFBUWFRUVFZ0TXdJNm1CZnl4N0VGd2lqeUpQbE5zdDRybWZ3MlFwWkZLYW83alZYT2tmcEYxU09rUmJ6d0lybk5zSXNwVDNmZUVFNmR5b3Z0SXYxMyt4aHlSN1VyTXBxSHdzeEdrSFVJamEzbFAzdGdtTE9BWkVjVjRsU29oalRwSDh5cFVCL1JTRjJueTVEemlOc0xLVkllRVRZTFNvNXovQUxobTh1bFBMVTNxSmxzdlRWU3FxcUpyYVI2QUQxakVKejBqb2pEc3llZnFsYzNSTFVneXNzZzZURW5mMzUvR09oTzFaeVZXaStua3U5cXF1WWN1MXd3TUM1dnk4cDlNTEtWT2g0eHRGMzRUTHNpNndOSU1rRXlvQXQ4V3dZdXlrVkdQWk9zUXRKMlVkMnFyQThNUmMyamtOb3RhK0NMa2NkVUwzTE5SMUJkTEZkQzZya1QvQUl0T01TUGFWSmc4a2dVNXV6RXlMSGw2d2ZmQk1mUFRTa29YTUJTdC9BQjRwbHZyWVc4OFl4N3hDcFd6ZEVtdlRZMFhVTUgwemFJL1VaakdNeE02bWtZUmpVdktrQzF1ZnAxOWNNSURkNVlhUXVoWlV3SWtUUHZ1TVl3KzRmeEdtdEFuTUxYMXN4YUVwekU5YjlaK21FNERLWlZuS0lOZk1haUNPOFl6c056L0FEYjNPSC9JS0ExZ0dlTktxWEFtOEdmUDY0Zit3a3FkSHd4UzB1ZFNnRWYxVCsyTWFQWXhwNVZhZElHb2RkUm1KVnJIdzh5UFBBS1BzSDRwVUlDMkFMZzJXd0FnMkI1QzN2QXhnUG9YZ05VcWpRZkcwU0JhVDE2WDZlV0F5Y2ZZWUdMcXVreEg2QW8vVUlnTjZ5SndQUTZEY2lHcUFHaElxVmFoQ3JJQjJBQXZ6L25FbjB5bVAyUzQyeHFaNU1yR3FsUVFVL0EwaWY2aUNQYkFoK29QWnZ2K2srWFhNOXQ4cFZNTlF5R1RiTUVBV0ZSNUZoOTc0NXZNeU5SMFg4UEhjN1B2K3NQSDE0aHh4K0VaYXFXeStVQzBuSUlBTEM3ajBKTTh0aGhmRHdwSnpmWlR6TXlsVVRHMHROREpHcVgwcUNSVFFnQmpGd1RQUCtiN1k3RWNRdXFLK1lyOS9WY1BWWWd1dzN2dWZqREFCYzM0RkswNHN4STA3RWVVSGZyNzRJMCt5L2hmRG00dFhxcjMrWG9VS05QWFdxMWlWQ3IwQUYyTnRoME8yK0FwY0FZb2ZGamJzdFNkT0daMnM2NkJtWFdrQmFZUUFuMk1pUDhBMmplNXhQTTdhWlhEMHg1bXFvb2NBb0pUVWp2TXpWRHp5RWdiN2JDUVIwd2lqYnNyeXFJaXpacDFxOVdtVkJrblRxTmpNYmpyL1lXbStMcFVxSk4yZVZKVmxxdTVKUThvc0NmMzV6Z2dJVmFnVlFFa1dCR2tqMDJ0eXhqRU05US9DNVBMMFVwaG1xbnZTcE13dTNYbUkrUGZHTnhzcHllVnJFbHRUV0o4UXNZaTErY2dZQnVOQmh5N3NGcFVOS2FtaDUzWVJzT3ZNQTROMXNLVnVnakk4UG9KUnJabk1yT21ZRlEyOTc3Q05yekdKT1Z1aHVCS3BUcXZsQXRLdVJScVVhbFlxaUErQUtUYWR0NGdkZkl5eVcwQnhTUmpxRlNLTFRUSWZTUzB3dHp0RnNWT1NQN01GTlVzQXBCT2xTYm4wdmh4aTVLNXBnaFRFbVNiWCs5dmJDR1hRNHpqQVpqTVNRNTF1QUFoSVdXTy93QTQxQUJNcUZGZWlwcEIxMVFCQUFzT1U3akRCR2FNdE51K05JTjQxZVNJbU9SK01CaEpMWW9TQ1hKTWsvcUFNbi9IdmdESVhjVnJLYzAwcW9SUXFBUVlBdnQ5OU1NaFdEWmRwMWFocEphd0l2Y0dBUkcrK01CQkx1Z3BFTVFJQlVnTWJzTDJQV1A0d2ZRUnB3NnRUeXpMVnFJckxSUXRZV1ppcGorLzB4SDJYaTZUQXNqVGVxMVN1NHVIR3U1RXN4SjlJM3hub2xCYWJadCt3SGFTaHdESTlwODRGSDRzVUZORVZFOExPV0FBSE94RTM4dVdPVHlNVG5KRi9IeWZqaTRzeWxJMVRGTTE1cVZDYWxWank1blZ6TW43QXgxS3FWZWlMZkp0bm5FS3BhbUthTUFpandCMVZTb0lzYmVZQjkvUEJGSlU2ZmMweVdIaENpWWlWbjdCeGpDYk1PdFJyS0ZUVGUwa3IwRWRGa3piWTRJMHpROFR5bzRYMlo0ZlJ6QTBaek9rNWlvbmRnRWJhUWJTTkkyL3pkRkpTZWlqZzRJYWNGMUp3YkpLbE5nS2xiV2RUSG1abjBKSys1d2o3SzQxOFdCVmN5R05DZ2FRYnVxanN4MUdEcWx2cUNKOU1aUmY3QWowVjUwSlJjNjFobE56cTUrdnB6OU1WUVZRRld6QzFhaXF0RmxsV2tPM003RzNxTitjWUVpYyt3dmgyVldyVGd4VVZQRTMvSDczd3JlMEdQVFBxNVQ4ZlZKMFV6VGhhWkRTREFNbjB3NkVmWmRTRkVwVEMxQ2xKeDRaSml3TUQ0bS9XRGdtUEtyZitvZlRVUDVSS0NEK29UWWJ3WUxSODdSZ1ZZWXVtQTVqTU5YcnB3K21meVhQaWxaa3dmMzVEKytNbzdBNTdHT2F6QzVYaHJaanZoVW9LaG9VVklLOTdBRWtlOGI3d09SeFBIMnpPZXFNYzZhQ2l3RzEyZytQbnY4QWZYeXhjNXBGVmRERXhNeVFOTWJiL3dBWXdUeW1vWmZFckVxU1BDUDg0d1JsbW1CemxSQVdGUnFyQ1o1Rmo4V2orK01BalQwdFVMR05LeTk1NUQvSTI4c0d6QnRCbHFVS1prZ2dxU0EvTzQ5TGcvR0FNZ2xkRGswNEJNNmVzQzh4OTlNRkdGR2I4VlpnRWtLVHBrRTJFeDk4OEVWM1o2aTkyMGhkTGd5cG1UcXVkL1Q1OHNZS3YyVk0wVkFxanh5WVlub2Q5ajB3ZlFRajhRM2NWYWxRc2Iza0FHNGszR0pMdGp5Nkx1QjFUVnpOS2dDU0tvTUJSTnhKQkhUMFBuZ3RBajlGVkhNUFQ3K2xQZ0RCbmpscDJQbHYvdmZBcXdQc095TlJhV1hyVnFrcTUvVVNta2dIZjY0SFhReTFGMGVNRFZLSTBoZzJwZ1JNRzhUWXlESDF3clpsMldjVXJwbDBTbnFJVlFKdVpVUVJCbmVldjdZMFczMkdhUzZBZUJjUGJqSEdzbGtGVXMyWnJBSHlTNWIwR2tNZmJEU2tvUXRnakZ6R25icmlRNGwyaHJLcmZrVW1ZVWhwaTF2SUcvSy9MeXZMREJ4alpYTk8ya2h6bDY1cHBrVmxnVXBpWTY2SUg4Umh2N0hXbFNFQ21NM1JDeVdWZFg2ZjZpTmhISStIMG5ueVp0OGFGVGQwWDhWck10Y3RFSVFMWEg5L3YweG85R2sybm9od2ltS3owaFUwTlNJTk45UnZCL2lUTWprZkxBbUwyOWpvR25rTW8rc2dGUXpFSG90dDVucjE1KzBiZGxVa0xLYTB4bEYxQ0ZKTXNlVzIzcmY5N2JZdkVTYVJHcFdHb29raGsxRlJlOXBnZTlzTVRsMEE1ck1KUm91NVZiazNGcE43ZVVYeGtKYkFlR0ZxdVpzbmpxT0ZSWmkwWE1td2kyQkp1blFGdGpMdGJtNlp6bERMNWVGbzBLWTBxRmdTZ2drZXA4dHNMalZiTkxRZ1V0VUtxcWg5SWFKaWJmekErWnhVUmtLeFV3TkoxYzlYemJHRmsyWEQ4UWYwMHd3NnNwWTllUmlMNHd4ZFhnNS9Nd2cvVzRKRWY4aUpuMHhqRTBKQ001TUFLSUpFYXZVRDIrbU1Zdnl0WjBvMUMxd1dQaGlSWmZwY2ZYR0dRWFJxQmMyckxZckJJaWJiMzZXeHJDa1VtaTFNVlVhQzZ3UE9SdjhBdmhrYXZvalRCV3RXcU9IQkNUdEIySm40NWVXTUJpOFNkQWRXdFRLd2dGd1JGdXZyZyttWXZ6ZEdNazdvcFJVcUJYQXZZZ0d3Kzd6aVM3WldyVExPQjFLQ2NUeXpPQXdXb0lHbUNJMmh1bjlzRjlhSjQ3OWttZWxVelZiUUg3b3V4UldHa2tHWSt4MGpDcS9abjJXSVVWZEFCVnRRQmdtVkcwZWQrdHIrV01HL1Fka21wVTJZeVFRQUZneVo5Qnk5YjR6U295N0Z2RWFvcjFrTXN4Z0FrTFpnTFcvazQwRWd6YkhYWXgwNGZsK0s4YXFBVTZsQ2cyWG9qclZxQWhpTjlsbjNPSlo2bStQb3Jna29Sc1c4S3kvL0FIRGkxQ2tDUHptMUhYTitadjB2RnB1UnRpamJTcEU0cE4yeGhuYzRCeFJrRUlDM2hNVFlDeDkvNzRWZElmazA5OUFnZFc0ckFOdElKRzBXRnV2TDYrV0MrZ3AyMnl2aVdsYTZKSkIybGJEOUlzTGZmcmd3NkV5TjhnM2d6TFJBUmhLUFRhbVZLa0NRUTEvWVcrY0NSb3YyRWNXcnFyS0lOUURRdGdmTWszQTZtMkpSU2ZZM0pvZ09KWlV0b3JVL0hxMUFxd2hTTFFSUE9Sc1FOOE8rWDhRdWNhUE9KSmw4dFZmdTNESUYzTmd3M0VlUitodzFzRFNhTXp4Q3MxYXZvcUVGVGNNWmlZdWJmZHNVaXJWa1pkam5zMVRGS25tK0tFMnlxNktJWlRHdGdSZTI4bWZNQTRWOTBORkxzUVprclVxc0NDV1FoZFIraDk0bjN3YnJvbk5zT3lkSFNuZUJWMVFZTURVdmhNOC9QR3RoaXI3QWMwZi9BS0xNQ1EwNmdiVGVZNjJ2OU1NSkpJK1FWUWc3cXJZM09seUJQc2NZSmZXV2N4VmdqUzlWbUFBMzhSR01ZK0FZVW9rK0lSQjJqVlBMckgweGpCZVRJaXF3SGkxYmczSkEzNmRQbkdERjNZYmtpSy9mczNpaVlLRzgyVTI2NHcwZGhUcEdYcW53SFhxZ1FMYmlCeWovQURnVzdvcDBoWXpFUHJwaEVOUzRBQTVzUU51bGo2WW85RW0yeGZyT2tFaFZJQmc3ZytHMC9IcE9ONkFQTWtxMWN2bUtXdEZvdENNcld2TmpQdGlON1owUTlpemlXU3FjTnIweXpPOUpTV1dwcDJNM24zMndiSjIxcEZGTndHRFN6RFR2SU85eVk4emZyYkd1d09xdjJHNWFxSFdzeHFHZTdKTExhQjZjK3NZQVlxMFhaeW9hYU1zQUhRU2RJbVp1ZmtSakI0K3hPemE2Z3FGOVRFaGJwejUrdHNGYTZFYnZzZjVwMXlmQU1oa0FTanNUWGJTSm5Vdk8yd1VBaWVubmlVVmJzcE5KS2dqczRweWVTYmlDUTFZdXlVeEZvSUpueU5wNW5iQWxKOHFHeFJUallIVDdyT0xVcEdhZGRBcEJQckV4enNUYisrS1VqU2Q2Qjh0VXFMeEVxU3JFU25oSE1Hd0h6MTU0MHRJV09uUmJ4Wlp6VlJIMHRUQ3NCYVFzOHo4V242NEVPZzVGN0d2QU1pTXhYeVZHUVZjTzd4S2hnR0lpKzFsd01qcEJqSGRlaVBGODBxY1N6VFpkWFNpRHBSbWlRUnozOGpqUWpTdG1sWFNFR1dxVTh4bmU4Y3NyVExEa2ZubjlNUGZGT2lDaHlra05lS3VLVkRTRHBBQTBJWjhNSFlUYU5oOFlXQzVLMmRVb3FLcG1iaHN6V05OUWhxMVNSQW0zbjZYbkZlamp0dDdIR2Zxakw4RXkyVldzOEZqVnJLeDBnbUlXUi80aHA5V09GU3RsWjNGZkVENGRRL0VaMm1hcHFScVl1NUlNcUxRSStEZ04wNkpwTjlqR3IzZFJEVDhmbVNoQUppNWlQS01FWmFNOVhrcFNrS3F5UU5OT1AyMy9BTTROaVNQdENFelVjZzhvWUczeGdoRFgxRE5WdzRXQTdoZExYdVQvQUx4Z0UyQTBnaEQvQU9WNEFrZ1Q2YmdZeGozaHdVWmR4Qk5waHVrYy9uNWpHTXRCT1NZMDh0VlRVekJtQy9YYnl4aG82RDNmL3dES3FsU1FTRHVJdWVYMzVZRmJzZHkwTE0yeHBzcUZ3K2tYR20zV1QxbmtNUGRra0FWV1ZhQVlMcE56RTNpMXY4K2VHU3NQUTU0RFVGVVBUcWFlNllGVHVJOFArTVJhcG5SaTJyWXl5dFNpck53M2lMaUIrbW9RU1hVaytMYmxmNHdzbTB0QXFub1E4WjRjK1NxanVXUjZURTZIQk5ySG55SUU0S1lrb05iSjVlVXBmbUhUVlFUR3FZRjQ5Y0VhRlVWWjRwVnFBMHl3MVdSVHVPWkZ1ZDcrdU1MS1ZGT1VwbXBtS0ZKcENYSk0vd0JQOXZNY3NZRVkyR2NZekRaak9RdEx3ckZQZTBiQWI3WHdzWTBVeU5PVkljVkhwcGxPRzVKYWpCRm1xOEVmcWcybjBKK3ppUzI3S1Jpb3FnYk1yU3FCVlY0cmlGZGdiNmZzbTIyTENQc1g1SDgzaUtobDNZaFROZ2JqK01DWFFxN0RPTkg4NmtoRWcyRW13TnBXL1QrY2FIUWNuNmozc2pWR1c0THhMUHRvUGRVbHBVOVg5YkdUOFNiZnhpZVJYSXRHa3JNdm1IZGFUZUFzckhXU3AzUElEbkZ0amVKNTRxbnBMNkl0VllGd25VS2xPcFNMYXBHMFd0dnQ1Yll6WG9uR1BKOTFSZnhUTW1yV2NLeWdEVWdubnpuNU8rTkJLT2pTYmI3UHVFWllNU1RUQlp4cU9xMmxRYi9JajJ3em9LanFpeDhzY3htWGRoRk9DQ0NQMVg2Vzl1bStCZEFtN1kzeStXU2hsd3VXQ014SWFRYmxvSTI2anA1WW01ZXlrVXFZdnpBWlhKaW9yaWJYQWliaVpqbFArc01uWk42RWVhWXMyaGxZQlpKQmFEdnkrOXNQUk9SQm0wUURjM20rMXpnbURtQ0xuYXpWRnNLenhJRW01eGhWS3l1dEt5bTZCcEVHK243SDBHTU1FWlNwcFI1VnRVMmE5dHZweUp3YUY1Ym92cEJ2d0ZSVlF6T29DRDhHZm5BSHVqd1ZDZUhkM0pKMXpJL3E1SEJvTjZvRnpiZDVYYW9GTU1BUWRVaVk1K1IvakJXaGFLMDBzQ3FyWnhBSjUrWHdNRk9nMWFvdTRNekxVcW9UQ2tHRDFhTGZjWVJyMld4eTRxaC9uRWZQWmFqcEEvRVVCcFZxZTVCdWQvUUg1R0o4dnNlU2ZhRkMxM3JxYU9aQlpRSXFBRVd1U2RKNjg0eGxIK1ZrK2J2WjQrWFNpRFVVK0d6QXdMaVJNZE9YMXRoZ0xjaW1xekYxWXMycFYvVHk1ZlczSzN4akFtWFpSVkE3NE1QRXQ5RjRuZjI2NHcwRHpKMHpYemVYR2xpdFJ4T3JsZVQ2MkcyRmNxRWd2bWh6eEp0UVdxOU50VHMzamFBWlBJOU9SeEdIWS9JR29kNVd6WTd4Z0lNRWtrellrWDM2L1RGMERrQlVTcVorQ0N0eUNDSU9rbTlqNWZQWEFrR08zWVp4MWlLdEl0cVpHVTJucEVnZFFaM1BuMHRzVzlEWlAxQ2xjLzhBNGJ5Nmg0RlNzejFBSklQSVg5Smo3T0ZiK1ZEZWhGeEJqcGdpU1dpQ0NTRDc4OS9XeHhYdEV1VldWVXFpNlZBc3NHR2R0TmdJSHY4QTJPTlF0a0VWbWNiaGlET3Era0MzdnY4QVU0RGpZdGJIbVFwRmNuVXJWUEFqZ0taMkFKTUFjcE52aWNMMHlxMHJKNUxoOVoySTd4QlVndHZBTnlienRhUHBncVZiQWx5bFE1ZGNwd25JT0lYTVpwcmwwYUFreDlSZjR4S1NjbVUvVlVaM09aMnRVVWFxbE1NUEZwbjlSdnNPWE1tZXA2NG9sUkdURU9iR3B4cU0zSUVOUFFDZnZwaDdKeVpIOE05Y3MxTldjVEJsd3NIcEdDRVlNTldjWU1zVFZZS1ZicXhpY1luQWxtUVNZSzZTN0ZwUXhlWTl1ZStNVUtNc1ZOVlNVQkpOdkR0YTNvWi9mQlRKL3dBbU1XTHBscWlnQVEwc3kyTFhrR2Q1dnZnWHVpakJGcm1OU2plNEF0WWJjenRiNThzTlZCQTlaRlptTEVJcGsrRzRJNSt1Q1ltckZCVFlobEFJREFpKzNwNmZHTVpGandsZW02SUZCaVJFOHZyZ1ZZeWRNMVhEOHkwRU00QWhVYm9DTm05dDU2ZW1PZWNYMGRTMnJJOGI0ZVhZVmFla1ZsTEh4RGUrM24xODhDTXQwSk9HckZDdlVxS1ZaQW1tVk5vaTF1ZitMN25GTEpxTk1xcVVLakpLS1NnRUJ0UFV4NitXTUNVYkp2VUNVQ3FsZThXeENqbmVSMFBRNElJdWlmQjZUdm1qVk5NbWtpa2tydkJzUHJBOThUbUdIN1dNYzR3R1dCQVVoV0pMQWpVUnR2TzBFL0huZ1JnMXNCUTFFcFV5N0h2SFVnZ25TUkpJQWp6K0xSaWdCY29qaUJjL28xWEkzQUpreDdEQWt0V05BTjQ2eTk1bGFzV0tPTGducEFpZHY4NE9KVTJQbDZSN2w2N1BsYVliVU83SklFbGdJQVB3QVRHRTQyMndwOG8yS2Mwd0xLcFVnNmlTV005SjkvdStLUkl5N0I2TlRUbGtZazI4Vjk5b01kY01BUDRhbE5xdzd5bHBRTUxMNGpCSTJGcG1TTnhoSlBROFkrelVVUDBLSytYcE1CNFVXcUE0cDNBSkhVK2NZZ20zSW8ybXFLNjFLbWFUc2RBcTZpTExKbVQvQUNCR0tLL1lpVmJGT1hPV0xsc3d6aFdJbXh1UGJibjdZWlVEdVNJWnlwUUZNVUtGSmlUSmRvNWVjamZlM21jTUdiaUpIY3FLbTM2eUdXZHhITWZJOThHaURWbnFVaTBzVVY1Z3krcWRoMEdDRU1jTXVhcU9WQTBWSG56Z3o4WXdrWXRkbCtmYVFia0tGQjZXUDJQczR3NENsUWlvVDNwRFNOTFRwRzRIMk1ZbXYyWXd6RHNjdFZZSWRKYVZFemNtQUR6TnJZRmJzb0FJMEZqRnBONCtoK21IYk1DaENWVVFzWGthZHpFejlNYTBFdG9xVnEwMGN0dU5WcitucVJqQkx5N000b2szSUYxSGhCQXdSbzE3R1hETTJPOVVrL3JBRmp0djlNU2xGOWxJeTNRK3l4WE41SHVOUUZhbjRpd0pHb0M4N3pJL2JFS2ZJdDJVMDB5NjFtVFBVbE5GaUZxdXFqVWg1T2gzaTl4aHRnYXRBTDVkc3RUclVIQVoxZ0UySWc3RVJzRFk0eXNrMVFwcnlNd1VCMkJBWW5Uc04vajZIMGlwSnFocHdzQ2x3NTZ5TG9OU29GREpJa0RZL3dEMjRqT1E4RXlGUk5OSnU5Qkx0L1NZT3FiY3ZXM3ZpbGc0c2hseUdWQ0ZhR3RNTkpQN2VYeGhoUmRUQlRPa0dUQklZQzVrZzdlMERHZTFRMFhzTjR5N3ZSeUR5RWxaZ25uekk1UmJiNXhvZkY3R3l2NG9weWxjR2t5RWhVaWZDZGhhSkcvbDZucGdKQWpOS05BUEVLdy9FZ01HUUlSSUtpUWQrWFA5OE1oRzluaUZxaVVsU3phNUlCQm1QMnRPTXhXelE4TnlrMGhtcXhTbXF6M1VLVHEwa0N3R3dBdFBVeHlPSnlhUjBLT3JHbE9sVmNoUlRaaVNFVUFreE05T1huaVNkT3pjUzE4am1hbFFlQnFZL29KRnlJMzZqRGMwWnhkQURjSEtzeFJhd01pNEpISXhiMHRIcmc4MEtvUDJESGhyZHpKcHNRS2szM2pwQTUrbUhVcjZGbmpSbTh6SWNxaGM2V2hwc0Q1anpuRHBwOUVpaFZycklvcVhFK0tPUjZmc2ZmQkNORmxNem1WcDJMTTRQbjRyZmZyT01BaG0yN3lrZ3FxU3RTbk1UY2JYQTVHMS9YR01DcktrdDBJTXF3UHg5N2pHRVhiR1ZSU010Vkowc1FzYWlJRy8vd0RvNHc0R29xTGxpRlkzQUZ6SU5qejM1NHhpSVVGRWtxSEJCOE13UVRCKzdjOFlLS3k0TlpkSjA2ZkQ0VHNOdmVjRkJMZE1Ha3hFS0FMSGtRSUk5UDdZSVVmTjNkUE9GNlEvTFlobUViaVlNZE1iWHNaZGovSjFsTDAzcE1kWm1SY3d3TnpHM1Q1T0pTWHRIUXVob25kMTZRMGhTeEdwZEl0STVldlQyR0oycm8xTW9xSXRXaFBkZ1ZLSVZRZ1lhaFR2QWtieGNlaEdHRW1KYzBvcTBBRHBjSkJnUkIya0NPVi91TU9SbHZvSzRUV1FaZEtETkJQaUtIZVJ2NkRuNjRqT0xmUThaSmRocm8xUUl3VjVxQzF3UmZyMS9zY01NNHRkZ0xEOHhtRGFTQkRhT1I1SDAyR0hSSmkzTUdtT0pXRE10OUpuWXR5UDN5d1FMc3M0d2RkUEpLektyNlg4U2NnWU52akdEazNGVUxrcXVYQ3ZCY2hwaTVMU1FQbkdvVlBSWG1kTFY5UUJpYnhmWVFmNWdjc0ZhN013ckpMVFpGTlhXc1JMR2ZYYm5OcHdiTWw3WWUvRSs4cUR1YUljb05JMVRLeDVjOXh5R0oxOWpwdm9Lb2Y5enF5YVRpalNqVU5IZzg5OXhjSHl3clNZeTVQU1F5NGZ3L2kyY2Z1MXIxSDdzYXBOY2lBUVlKQWtteHQ2ZVl3amNZN0cvSEo2WjVVeWVWeWIxS3VacnRVMVJMVktoQUFtOStmUHIwR0NuS1MwaEhHTUh0aXpPY1hEMXY4QTBxTWhEUnJlZFJONFB5ZC9TWnhTS29uS1ZtZHpjR296S1ZsZ3luMXZOc05GVjJBRnFrT1FXMGd4ekJNKzR3OU13ODd4VnpkV0ZrR3EwQTlaTy95Y0FCVlVxYTh2U3FIOVFZR1JiZkdNQ2hrWUJWU3lzQmN4RW5rT25QR0ovd0FtTlhKN3BwdmNLRkprRUc5L0x5eGlnQlVxSTJYcEs0OExNQ3dqMUE1K1gxeGpIMllwaWtUSS9NUVJHNHVBZDdIbmpCUkYxaHFnQ3JFd2ZQeFJIcEFHQ2drNFlJclZBSUpWWURIbU52NG4xc2NFS1BkSkNxMm95S2dtQkVneVRqTTExc0w0WFhkS2E2aVNYVVZBWjJONyt0c0xWbFl5ZERqSVZ6U3pWU2l3dnA3MEVHYndQNzRrNDdHVXJkQnJvV3BoMUtxNm9ET21aWHhMZnp2OFl3SjlDdDFUUXA4VEkwK0UyZ0F6cHR5djhZY2lCRkhTb2cxZU1OcVZ4YXc2ajNQK01ZdzV5N3JuY3RScTBoM1pjSDJJa3p2Yi9PSmpSbTVkZ3RTV290bUZKMUR4T0Nkb0VrcjUzdzZBKzJKYzB3WE5Ga2dsVi9xVVh2djYySHlmTEdBZmNZcmErSDBkS2doR2J4bjlYSzJHUWZRdkZ5V1NkV3BoSjZtK0NJZ25obEZzL1hjaU83QlZtRG01RWVtKytBelBzdlZ6V1ZtSkNVYVFqU28yWHlFNyt1QVA2Q2FlZmFpQ012UnBMNHBEa1N3bUFEKzJNbFlMb3FUaU5kaFNDdUFqTW9BQS9TWW14NllLZ0ZUYUQ2SEdhbVJSMXlWSUpVcUFCM0x0TGVGamlUZ216ZmxZdXpPY3JWOHorY2Raa0VqVllremY2aitNTWx4RmJ2WU4zZ3FVOWFycDBnc2VwOFJBTnVlR0ZLS2hEMWFhbG0xTWJRQUJZNFl3R0txSVdEbGdTU2ZDQWYzdzRULy8yUT09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9OZXd0b24uanBnXG4gKiogbW9kdWxlIGlkID0gMjk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVpBQmtBQUQvL2dCWVJtbHNaU0J6YjNWeVkyVTZJR2gwZEhCek9pOHZZMjl0Ylc5dWN5NTNhV3RwYldWa2FXRXViM0puTDNkcGEya3ZSbWxzWlRwRmNuZHBibDlUWTJoeUpVTXpKVUkyWkdsdVoyVnlYeWd4T1RNektTNXFjR2YvMndCREFBWUVCUVlGQkFZR0JRWUhCd1lJQ2hBS0Nna0pDaFFPRHd3UUZ4UVlHQmNVRmhZYUhTVWZHaHNqSEJZV0lDd2dJeVluS1NvcEdSOHRNQzBvTUNVb0tTai8yd0JEQVFjSEJ3b0lDaE1LQ2hNb0doWWFLQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0NqL3dBQVJDQUUzQU53REFSRUFBaEVCQXhFQi84UUFIQUFBQWdNQkFRRUJBQUFBQUFBQUFBQUFCUVlEQkFjQ0FRQUkvOFFBUGhBQUFRTURBd0lGQVFZRkJBSUJCQU1BQVFJREVRQUVJUVVTTVFaQkV5SlJZWEdCQnhReWthR3hJMExCMGZBVlV1SHhKRE9DQ0JaaWNpV1Mwdi9FQUJRQkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFEL3hBQVVFUUVBQUFBQUFBQUFBQUFBQUFBQUFBQUEvOW9BREFNQkFBSVJBeEVBUHdCUVVrbVNNZWhGQlhXbkpBM0djZk5COGtncVBteDZVRjIyeXVCekgwb0NMSVVvaUVKTFdaUEovTDBvSkhXeW1aQkNoeDNvQjl3bkVHZWZ5b0F0MGlNOXBKeGlhQVU4a2dra0dKeDhVRmZtRWlBUjc4MEZoa0tDUXJPUGI5ZitLQWxia2owSjRqaWd2dERqdEdNbWdzSkVvQWd5Y21UKzFCNlJPQVlQeFFlRTh3bythUklQSjlLRHhNR0RHRkRCQjUvNm9LN2lRVUszQVFVOStmOEFPYUN1dHRVOXlKN0QrbEJBODNJbmllNHlLQ3F0c0FUUGZ0M29JRklnU0p3Ty9OQnlCQXdSSHRRZEpPWlBsOWU4MEVxZkttQno2aWc3VEVFQUNPUFVpZ2tSQVZPY0RrZnZRU2hKSUhQRkFhU2dnbWVUMjlSUVJMUU1rSEhFSDFvSXduak1wbnVCUVdiWUhjQ0lIcFFGYmNKQ1Q4aWdzdU1nZzdZamdRTzlCUnVHK2Q0NG9CRjZ3Y2pFVHp4UUJydG9JQlVvN1ltVkhpZ0RLMUN6OFFEeDBHUFNndE5YdG8yMGY0NllpWVNjL1Qyb0lXdGVaU3ZhMmdyUUIvTnhQelFUdGRWTm9lUUhiZHdBL3dBd3ppZ2xlNnR0bXNOTnFWajRpZzRQVnJEcVREYmdVUmpnajg2Q3phOVIycFI1Z3NFWnlNL1NnbVo2anMzWGcyamNEM1VLQXEwNjI4QnMyd1I2NTk2RGwwRWdRQWR4eHRvS3JxSlRLSVB4ZzBGZGFOb0k0Qno2ajYwRUMwNS9zYUNGWVBlTTlxRHhNZ0E1Qm5qMm9KMHpuSDlxQ1FBa2YxNW9Pazk1R2UwVUVnQkl5aVQ2OFVERnRnOFo0eFFWM1FNRXlUMy9BTFVIQVR1VVRoUmlTTVpvTExJSUdUT01mMm9DZG9FL3pBY2pFeElvQ0NVN2tCS295SUpCNVB2UVVycElRTjY4Smd5b3dQOEFPMUFrOVNkUzJ1bnJVMDMvQUJYT0NsT1FERkJuMnA2Mi9xaXlsMWJnUVA1QmhOQlNXd2xJVHNCVVk1SjR4UVhXR2ZFYlZ1Q3Q2WUlVazU5NkNCOXBld0VxS2dleG9JV1hWQlpTb3BLU0pCSmo4cUQzVUNVb2FXMkFGbzVqdlFjc3Z0ditKS2RzSmsvOFVFN2R5R1R0YzNCQndZUEZCMG9uY0MzSlR5U1Azb0ptZFJ2bUNoeGwxYUl4Qk5BYzB2cXA4T0FYNVNwb25Ld25JUHJRTmpiemI2RXVNa09CUTNZRWlPZUtEeHhzQUtqNW9LNm00amNPM1BGQkNwQmdFSGp2UVJLUUNvWnozN1VFcUV4Z3BuT0JOQklDQUNUejJpZzZDVEhzT0tEMmR1TjBmcFFNeEU1SDA5NkNxOG1WQUNDRDNuOXFEa0ptSU1IakZCWmJCZ0VRcE1jeFFFcllnSlNGam5CN1FlMmFBWDFQMWJhNlN6NGJTZkdmUDhvTUFZNE5CbHVxZFQ2dnFiNno5NFdsQi9sUVlBOWhRUldlbVhGNjB0eGhFa0RQclFUTTZYOTNDZzYzSzRHVDJvQ0owVmxGcXBlVkpBM0t4bEFQZUtEMnoweFNyUU5GS1FwVUZKN2tFLzVpZ3AyK2tPM0tsa3dHR1NwTSs0ekEvS2dwUDZZV3JkYjZXNVFsend5VDYrbEJFL3BxMzlRRnUwQ3JhTjVLUng2LzFvQXpqSGdYUklPNVV5SndKUDhBeFFYRzJDb0lKUXJQNG9IYWdyT2hhTnBUSlNGYllTTS9GQkl0WThBa2ViZ2lUK2xCd0hOdTFKaFJ5U2s5eDZmU2d2YVByajJtWEFFcVV4TUZBeUk5UlFQMmxhcGJYeWR6Ym9uMFBOQmRjU3FWVG52QW9JRkpQcGprVUVVQ1pnNDdqTkI5UGtCSWo1b1BSa0RNamlnbFFuSEdhRHNOak1pYzRrVFFNb0dCR0Q4VUVDMFNmOTFCeHM0QkhINlVGaHJhQ0pJb0JQVSt1RFRMRlcwamVjQUF5VDhDZ3gyK3Y3alVidFR6bTVLQ1lnS0pJb0dIUW1Va0JEcGF1RXhJV1FRb0Q4b1Axb0x6bXVmZGt1TW9RbEpTWlNRT2ZuM29CN0dzT1hTRW9jV1ZMa2tGQkdlOUJjdU5TTnE5NGJMeVZ0M0xZYVVrNEpFZ2o2MEE5elZYVXZpNGE4bmdnREJuYW9FeFFIYlhWVlc2K243VTdqLzdIbmlGY3FXT0pvS21tM1pkc3J4TjBUdEpLb0l5RkpWSFBZekZCZnYwL2NMNURqQ2tlSTgyMnlFeElsWmcvb2MwQVovVGxLdUE2Mmc3WFgxQktvd1FEeVBiRVVFVHpPMWhleVZ1clZBVUFZU1BRZXBvS0M3UHcwbnhFcTNubU1BZk5CUmNCTEtpc1FrUW9Sa24yb0kxcFVMZHRSVDUxYnBnU1kveWFDdW9GUi9DRkVIOGNVRTlrODQwMmZDVnQ5RnBQQm9IUHB2cU0zRVcxNENIWkFTcnNhQm5Xa1RPRFBxYUNKU0NEeG44aFFjZ0tCUG9LRDFPVEpFMEVnUEdlL2FnbEFCNVVmeUZBMGJaQkVIQWt4eFFWbGt6SUlQWUNLQ0xpTmg1N1VIbHc2aTN0WEgzUEtoQ1R6UVpMMWhyNTFTNjhPeUNvU1BPdU9UNkNnSGFUYVhvZFM0Yk1yYWtCU3VhQjcxSFViZlQ3SkRTYkZyWXRJa2ptYUJFMW00UmRyVXRsSUNnWnh6UUM3ZnhFM2FDaE8xVzdnY1VCZTFTdTVkUW5hVkRLaHRHWm9DbHBvZHkrWFF5aHhRZDJuYWN4UVg3blNMMHFaM3RLU3R1VWoyeVAxb1BYdEh2RXZxUmtELzJrQStwbWZmdFFYZFlhZHVOU0RvYmNMVnZzQ0FVNWtJNTk4elFjdmh5MjBkRFN5cHRTMmlzcndEQ3VQMEdLQ3piMktubjdScFRZQ2tvU2xMUkVKUUNNSlByUEpvT2RmMGtOS1dscG9sbE1sUzBpQXFJQmoya3dLQU96cERZczJuSFZ3dFpXNGxJejVSaVk5T2Z5b0JMbGlxNmUyc2tFaFBtUG9CMkh4UVZMaGxMQ1FrZWFjQ0RranVZb0lIUExrNFBZUkpOQjYwcndWdHFRbFpNOWp4UWFSb2w1OSswNXRaSUt4NWZpZ3ZFYnNrRWp1YURoU2ZYTWQ2RG1FZ2hVOCsxQklpWWlJTkJLRlk4eEFQZVJRTXpvT3djR0J4eEZCWFdSZ3lQNzBFRGtpQVNQVEZBaS9hTHJTbTl0aWhRQTVYUVp0dkszZ0Vna1RNQWRxQnowMTVEVmhMcXJ0ckhQYWZnODBBblVOWmZVNEVKdUdybHBCSVQ0cmNGSTlKL3ZRQ0ZYTDdpbEdSSE1KQUEvU2dhZWp1bGJyWExnQUljUTNpVnFFN1JRYlJvM1FGbmIyTGFXd2xEeVFWRmFreVYwRHRvblNWbzJVRHdFRUZCbkdVbnRQNm1SaWdLWDNTVnRlSmNYY0lQakpSSVVFNUJBak5BQ1gwT1VId3d1VkxBVHRSbmNtWk1rOThjVUhGejBKYnQ2V2xaYThTNFVuY3BHVW5lU1lUSDFINVVBVy82TDhCZHFxMFlTOCtsYVFwTGljYmdPODRJeFFMK3M2TGUyZHcrTHR0OWFsQTcxcVA0eXJ6S01qaVovdFFBZGVhdVhXMnd3blloS2RvU0JHNGdSSkhhT0FCN252UUkxN2JYb2NXcGFscHhCVUo0aUFQaUtDdUV1dHRsbEtWVEVUNmpzUGlncFhIaVNWcUFDakdkMDQ5UGFncUlYSVZDU0Q2OS9yUWNsYWdza0FwMjRraWdPOU02a3F6dUNoU3dHM01FR2dmVUtDa0JTU2xRVmtDZzlXWlZ1U1p4UE5CNEV3TXhuTSt0QklsTzRRY2U2dTN4UVN0Sk93UVNuMklKb0dOYVFFeXJCaUJuSm9LNndaeEJ6R1RRVkhqRG1RTWQrMUJpM1dyNWUxMThGVWdVRmpwYTJhRnlIblhraUlKRVpvREd2M1NMdE93dUoyeDVRbVpvRjhhV0N5cDF4S2xKNEIzVUJub3JwYi9YTmFidG1Bdnd3cnpyaUFmanZRZm9mcHpTTGJUYlZERm9ncVR2MkNEK0tPU2ZidFFPdW4yNEtQNHU5S2Nmd3lpQnh3UGVnTXN0RW9Pd1FtTndKejJ5UFNnbFF3KzYyWFZKY0tFd1pFOS9UMC9hZ0lXcUVJYktGVDVSTytKS2lmMy9BT0tDSzZpVWxXMG5nZzV4M0kvenZRVkx0TGJqWTNsUzRBTW5DZ1BURkFJdnJBWEZ1K2hiYmFZbFcwQ2MrLzE3L05BcHY5S1d6enJ3V2c3andSQWc5eVAyOTZBZGQ5Q053NnByTGF3a28zNWp0UHhRSjJ1OURCaEhtMkpVQ1RIQVNhQkoxYnBzc1FFdDVpWmo5NkJPMWpUM2JPVnBDZ2dIMDQ5alFCVzNuQzV0Vms5Z2U5Qll0M3lDSkpTZmYxb0hMUnRYZGFhUzJ0SlVtUFhQeFFOTnMrM2N0aFNSQjQyK2g5YUNlUHd5RDdab1BXMGJjUW5JNW5tZ3NGc1RIY2V4TkF4T0lVV0RJT1NjZW52UVZIUnRqZy9IRkFQdUJ0amFESm1QZWd4enFxM1FOYWRDeXNMSi9Da1pvTFdqV3lHRzl5ME9JSE80L3ZRZHBiWmV1a2hhaVVUZ0h5cEh6UUc3MjJjdkcyYmF6UXBUSU1JYlNPVC9BTGxIOWhRYXo5bkdqTmFSb0MzL0FEQjFYbFV0STJsUmppYURSTkN0ZzRFdWxHeFJJQUJNeDZmRkF5Vzl2OTRoS1JDamxTaVNlRHp4UU1PbmFLRk15NlFwUkdaRS93Q2ZTZ0pDdzJvQUFRREVHUFNlS0N2ZVdKVnRLVkpiQ0IrSGpIdlFCcjFzSlVwQ0R2QUpTUkVuaWUzMW9BdDFkU2gxS2dRNXVFQUhLZ1l3Ui9uRkJKcHpvOEVsUVVTbzd0NGlUbmswSHlpaEc1YTBmelNsSUVBajBuMDcwRlV2cUZ1b2VHRlNBZHhFZ0RKeDdpUlFBTldaUzQwa0tXQzRvenRDaEpIOW9vTSsxZTNiTGlqdWJqZHg2ZWdpZ1I5YnNXWEZxRzNIZWVhRE9OUzAxVm5kS1NNdDdvbjJtZ3JyQ0FvSVdJUHBITkFSc0xnb2JTaVFZT0p6aWdjZE5mQnRrcnhnVGptZ1lHVkJ4Q1ZDZnd5VFFTYlJFRVJQSTlxQ2NRUVAvd0RVVURJRW53aEVtTVR5ZnlvS2R5Qm5IbHhuMTk2Q21vVHVFUXJJQW9NYzY1dDNHZFZVNUJBS3QyNDhuNjBDK0xoOXpIaU9iSkEyaFdLQnI2WXRtbkhFTHV2NGl1QWsvcFFhTDA3cHJkenFqclQxMHExWlFtRktRM3VPT0FuL0FQSW5FMEd0dldqU2JCbHRsSThOS1FpQ2lOeDVKSHI2Zm5RSDlGYjIyMEpBSUJVRlNaN2MvbFFOT2xJU3kyZ0FuOE9TSnpQb1A2MERSWkxVcEVxMmhJd0FPQUJRV0ZyU2xNbkltREhiNW9LTjh0dGR1clpzV0U1Z0NUOFVDYnFTeEtpUXFBUDVsQWtwUGYyakZBQlM4cElDdG9DWEIvOEExN1RqOS9lZ21zSGdBc0JsZTRBSUN5UnQ1SUpOQlp1ZGlpNHRFU05zcUt1NEVmdFFWMzBLRmdWSklLWWhLUWQwQTR6OFVDMXFGeXRLblV2SjJnSENFaVFCRUg0TWNRYUJPMVJZYzNwQUFLb24xVU8yS0JRMU5La3JnQ0NmUXpBb0Y3VTdWRG9JZzdnbWMwQ2Zmc2dLL0RudEZCVWJPeGNtT2NBbVBwUU0zVDdpRkhhcVNqa2JUeFFPK21xSloyREtaeDZVRnhTYzRpRFB0UVM3U3NUUDUwRE1Hd1dvZ2tBOEFZb0tOd2tnRklITWdrSDNvS1pTWk1TRFBOQUE2aTB5eXViUngyOGdKUW1aSTRvTWZ1M0dFM0t2QVNkdVFtTVJRRitubnl5KzBWTGd0amVvbnVSeFFiUDBGYzdrRzVjVHZXa0ZiaXprN2oyL3pOQnBkaThwL1RFZU9sS1VMTXBSdUc2WTVIeDZVREZwRHBXaEtqNVVuY2xTSjVnY2U5QWN0SGxXNURiemhRU2o4ZU9JeEhiMm4yb0xyTDduaWtsMFNvQ1JPUHlIdFFXMVhpbUc0UWhRVkJDU1FBRDdpVFFVZFF1RnFueEZRbHNESVhrL01kK09QV2dCM2xza2hKOE5TU2Z4R1NwU0IyRUgyL2VnQ0xaTzBoYXp0M0VKYlVBY0QzN1NlMUI3YUtBdEVsTGhJQ1BFQVdtZHlTUUpUQnpIcFFkM1FXaFpIaU12b1VoTzBBS1JFRElnakh2UURIN3NDVzNVR0ZKSWxPVW1PLzhBM1FDWDcyM1VGcFNFeXFRbmNOMFFjZlgrdEFsM2wyVlBuR0ZjN3M1OTZBTHFXK2R2bVNRSjRqSHpRQTNnUzV3UjJvRS9XVXBEaW9WQTcrMUFIV3ZlUUN1ZjkzZWdPZFBKUXU0UWplWUtzeDZVR3BXektXMm9RSVJIL2RCNnRBTSs1akJvT2dESDRqK2MwRFV3aVdBb2lTWVVNNG5zWi9PZ3FYS01tY3BFaU8zMG9LS3dFa2lQbitsQXVkZVd6OXhvRHFiVXhQNHozSUZCa0RMS0V0SzhRRHk0K3RCTHBLbEt1UVRFTFVCSGFKNW9OazZUdUVwYWNiWldwZStlTUNCZ21nMWZwMWJhclVLY1EwemxMZmhwVEpUMmordEEwV2ExdFBwOGlscHduYXJFSHRudDhVQlNTcEt3bytLU2tKSUNZQUErZjJtZ24weDFlOUtraExZVjZHQW9jWXhRVExjY1VrK0lGcmNPRnJBS2g3QUdNVUVZdG5YbUVxYmF1RjdUQkNVUUZrL1BiSW9LOTVhWExZUTB1M2RsUk9WRGRpVEJWbjl2U2dwT1c2dzF1VXhjSmRLY3d5U25ua21jemlnSG0zUXo0b0szV3Y1VktLU2xRalB3Y1R4SElvS3QyNGk0YldsTDZOOEJJUkpsSjk1OVk0b0JkOFFpMzhRUEZzS2tiUXJqMmo1OWFCVzFJaHRzcVVFRjRva1R6TTk2QmFjUnRNcFVvNEg0ak0wQXE4ZFc0bzhuSndUZzQ1TkFHdXlVT2lDUGllOUFxYXhDbmxBcG1PMUFEY0NVSGR0QUJWeU1SUVBuUStuTnZJOGQzQ2s4R2dldG9BS1lHUFFSUWNLT1ZSenpOQjZrWThvRkF6V2hVWUJRRDdSeU9lUFdnNXVaRWxKa2preFFDMzF5c2tZSTd6SW9LOTBnTHNuMGtUS1RBaWd4VlNJdnJobDhLMmxSSVNudm1ncjI1VXpja2dKU2xzd2tEaWdmdWt0UmNiU2dKamVwUGhnQXgzbVQ2MEdwOU9YU2dVSVNoenduVmJWcWpKeG40bWcwaXhWdmJiV2lRdlltVDRnVVNRZS9ma2lLQmlzeTQ0RmJmRElTVEJCbWM1L0k4ZldnOGF0VkllQkJEcEJNQldBYy9wSHBtZ1lyRUtuQTJxZ3FuZGo2ZTFCYlN5UERCQ3QrZHgyNW1ncjNOa0R1ZWMyS1VEZ1JQbC9xYUJmdTIwckttMGdwQ01iU3VUOEs3VUZacG9PdU5oWEN1UXBVN1RIWVQrdEJTMU96VTd1UzU0YTlwMmdIZ0RpQlB0OWZlZ1ZyeXdBRFJTb21CQ3o0aEpjQndlUWZhZ1hkVjA3d0NsdmFTcFFsUVVNNFB0amlNMEN6cVZ1NGdBS1FBQ0R3Y2dmWG1LQUh0S25TcFlpSm5PRDcwQy9mcUJXb2lBZlU1elFLV3JFNzFFUjhVRmJUTFg3MWV0c0NCdUVqM29OVDBTelJhV2FFQWtLRXo4MEJJRThHUFF4NjBIQk1UQUdEeU9QbWc1WHlOeWhNZnpjbWdiN1ZLUTRyY1MybVFKT2ZrLzU2VUVkNmlBWk1ZbVFTUjNvQmp5VXJVQnRBSHIvbjdVRVNsK0d5dFNodWhQclFZbnFDWEx6WFgxTmtJVXBaaVRBVC9hZ2llczNtMUhZNDI0a2NxUW9IRkFlNlljS0ZsVFpCMnJFZjAvV2czN3BXei84QTQxaDlRQmNVcmV0ZkhtUGM5dmI2MERyWWJMZ0R3bTB3VzQzRCtWVThIdkdhQm0wdTBBYlNQQ0NrSlQ1a2orWDFISjlxQWd4YmxBR0NoSkJVZDhoUUVSblB2UUY3WnNvVUJpQ0FSSTQvejBvTFlLU0RFR09Zb0tlb1hMVFZzNjQ2cEpRa0hDUkpPS0JPVzRsOVRpVnEyZ3BrOTl4NTdkdjdVQSswdWk1ZHQrT29KWWlVN2hrQVFJajlmeW9MT3J1bGFGUTZrSlY1aVlBZy9UdWFBRGZKUDNkQ2tCZTZJS0VBejhleGlnVjlaZVNoNHBqeVFCQWt4alA1OGZXZ1ZMdVhWRUtTb0VjU1FZSGI2VUZWKzNMYlNpRzRqQlBjMENWcUkyclVCR1NSeFFKMnMvdzNzeWNmblFYdWlyZnhyN3hETUlNSE1tZzA1SkcwWndlQkdLRDRGVytRZURFY1VIaTRrZW56RkI3Q2Y1b24zRkE3TUtVWFNWa2JpQXBKNy9sMm9JN3RrSmhMWVZ0SE9CaVRRQzF0QUt3bE1TVEhHQjYwRkhWVitEWXZMUUpLVWsrdmFneGhsTEZ4cURpcjE4c01sUkoycEsxSDRBNzBITjYwbHU4YkxhVkozQ0lXbU1lcG9HWHBXMUtuN2NtTnF3WUlUR0o1b1AwYjB0WUgvU0xmeDBBYmtFZy9pSE9PZmc1RkEwMnRzNTQyMUNRVjRVSUFJU2VTQjI5YUIwMHkyRFRJV3NaVmtFQVQ3Z1VFemx6Ykl3b29LdVZBaUlId2FENVdvTmJUL0t1QVFOcEp6NjRpZ291ZFJXdjRRNjJNa0Fic2tlMFVBcSsxcTJ1R1hBMHRHMXBPZHNFcFBidmo2MEMyemNCZDZrb1FmQ1VDZHFWUUVTWUVUeWMwQXk2ZlF1OFNHd29SdUJNNWoxK21LQzVlM1NENEpkQUpNSGN2T1JnNCtuenhRVkxoOUxyVDZrcjNvUkpDbXpHMzNNYzBDdnFhMjF2UEFBTGdnT0tqY2UzUHBRTDE1NG05WkRhMEFxSkhINy9YTkJTZFF0TFNreVNPOG44UW9FcldCRHhLakpreE5BbTlSQUpkYkpHQ0pNMEUzU2R5V3JoUVNmeFFPT2FEVUxCS2xNb1VWRXo5QkZCT2NrVDNQekZCOHBNZnJtZys4TW4vQUw1b0hkS0VpRkpXbllyeXpKZyt0QjFkQUVEYUR4Z1RFZTFBTFdnTmtsSUozWmdEOVAyb0I5NkE4aGJhb0lLWUlKL3BRWXhybHViYlUzMEtCQ2ljQkl3QlBOQVBYZEtncGU4NjRnTDRJOXFCKyt6SjFOejFKWTI1VnYzSkNOb21TQVppZy9UbWxzT0taS0Y3VXV0RWxRMjRqME9hQWd5K2l4bFpUdGpuY1lTRXhKK2FDdzkxT3cxYnA4TzViMjVVQVpTY0FrbjhoTkFrZFJkVFg2TDI4dHJBWGwzcWlHUTdjTkI3d0dOUFNRTmh1bmdDVXFWTWhwSG1JR1NrR2d4ZnFXeXZOUWRVL3FuVld0YWxka2VjRzVMYmFTTUVJU0NRRTlxQmFaMC9VclVLTmpxK3AycEk0THhjUitSL3BtZ3Y2VjFmcm1qM3pkdHJDQXZ4Y05PQVMyK0I2VDNIcFFhNzBGcjMrdFhqUzFrSzhCSldVQkpnUisyY3hRRkwyNlc1Y0lRSFljVUZFcktETGVRZXd5S0JJNm82bGN0R2trS1MyVWJzbzl5S0JmYTZxMVhVYks5djdkeGkwMDIyVWx0eThmQmhUaWhLV0drakxqeWdEQ1J3SkpJR2FCWHY3UFhOVWRVOXF0M2R0cWN5aHRLZ2t3ZUFTTWZsajNvUGJQUmI1aHRCWTFUVVdHd0pUc3VUNVJQKzA0TkJZZTFqVzlGQ0ZhazZuVXRPVWtBdm9UdFdqLzhBWWR4eFFjYWpmdFhvU1dDQ0NRWlBKOUlvRTdxUWYrUXluRWNFMEZ2cFcySzdueFlCS1Y4R2cxVnBJRENOZ0FCRUNNWW9Pa2pha3lSbnY2bWc4TXdQNmQ2RG1QY0Q0RkE5MlFscFk4SWJFamFPUDNvUHJ3QUdBTVFQY21hQVJkcklWSkFsT0pQYjBnMEZiVExKelZMNUZzMG56S09WVEh6UG9LQVIxdjBheTIyNHB1NVNIMG1OeVpQMG52UVo1Y2RGM2phUTQ0ODI0dHc0U0RrMEVQVDl5T2x1cVdMOTBPaTJ0MWZ4a284eElPUEw2MEg2aTZNNnI2ZjZtYWFWby9VV25YRjBwSURsbzR2d1hpSUV3bGNFeDdUUU0zVUovd0JPYWNXNjBwYmFZUUdOdVZHUDVmbjA3MEdXOVIzTjVZMnJGMjIrelpPWFQzM094VGNMa2h6Slc2b1ovaHRKQldvUVpJUW52RkFDdHRUTnVsWFNQVCtuTDFOZHVwVHQ1Y1h5eVBFZGt1RjVRUXFYU1JtVlI2UlFJZDcxSTg0K3cxYk8yRFJ1MnlTM1oySWFVaFU4S1VxU1o1eDYwRmZmZXQyN0wvM3AwcGRCSmFkQUlVUVlJQkhBOTZDMDlwNDFlMmNzbGJtdzhrTGFLcC9odUQ4S3g5Y0dPMUExL1lSMWJwYS92bW1YbW5YYit2cmFVbGx0SmJTd3NqQmtrZ2hXZndnR2MwRlg3UXV0dFM2YjErNzBaVmpwbmpNcFNGRzJ1Rk9CTWpBSkdOdzRqdFFaL3FuVXFOZVd3M2NyVnByU25FcGZlZVJ1UzJKeXJ5K1pVRE1BU1lpZ2FXdFowMUxxWHRQdDF1YVRwalJ0TkhZdWxRb3FYLzdMbHdjZUk0cVZIMEd4UEFvQnVyYWhkdXJ2cmk0MUlXMTR5WmRhVWxLVWxKMjdBamtsUmt5RGpBelFmYVk1cWQ1YXV2SVUxY0czS1N2RzFSU3Jnei94UUdHSGJlNFozTnRuOEI4UnRjRkpBL2Yzb0ZlOHRtOUoxWnl5YlhOdTQybCsyS2hrSVZ5ajZFRVVDenJqNGV2RWh0TWhBNTdVQlhvOThDOFMzdWhDc2trVC93QjBHbzI2dDdZSUhsQXdZb0pPY1ovdFFSeFBNUnh6N1VIeE9UZ0gvd0NVVUQ1WVQ0Q2ZLbE1ESVNNVDgvbFFjWFBoa0R1b1lKM1JQK2Ywb0FsOHNxVUVxSUo1SUZCUTFTL2QwenBlL3ViWld5NVgvRFFwSXlDVEdLQUJwVGV0aTJTYmx4eHhsWmtsWm5QZWdyOVFYUjAreldwQ0p4Z25GQVgreVBSbU5hUzgvZk1vZldaQ1cxQ1U1R1RIdFFTOWYvWWRhZUliclNuRldRY1BCVHZRays2ZVFQY2NUeFFKdHphZmFMcG5UN3VuV05ycXR3MExqeEJxRm5kdnZqd3RzQm9BS2hLUVJ1eWtLNDdVQmo3STFLNm0rMTYwdE5YMUcrdWJLeTA5eHUxUmZLU2xTTmlVa3R4d2tFejdrYzVOQitrSDJMVFNyOWQrL3BLSDdoUjNKdk5QWVNIek1CUVVJZ2dnQVFjWW9NNzZyNlUwbDNWWHJxdy8xU3hRNmxhZ3dOUGJVbHNLeERhNTh1Y2Q0N1VDaHJXamFaOTNTMHkzZCtHaEtFcFN2YTBJN251U2NUTkF6ZEVhUFlQSlI0YUE0dHB3bFJXNXVLQVl4SHVaanR6UVpoOW1uUnVxOVRmYkgxRFlkTzNTZFB0YmU0dWszTjRwaExoWnR5NHBPMUtWQWplcmdIa1FUT0tEZTlUK3dYN090TTBkTGY4QXBGeTdjQkptN1hmT0IxUi8zR0R0QitFZ1VINWQrMHpwWkhTK3BGdXllY3VkTWZWL0RVOFFYRUgvQUdxSTV4TUhIQm9DdW5hVzFkV2pRY3VGTWhwU1ZRQUNGRHZOQWZ2ZW5tTGt1dmw0S2RVZkRVcnd0NkNNUVNKNWowTkFYMGJUZE1zTE82dFhMbGNPd0Z1SVJ0TDBBN1VnSEtCQmp2UUQ5WHNtMFBCMjBiOE5rTnFTRXBFQUppQlFMZjJnMlRDZEo2ZDFDK1c2aHBOd3EyZCs3Z0Yzd2lVckpUT0NxQ3FBWUZBazNTU0xxNERTTG43b3BTMHNMdUd3aHhTSjhwV0JnS2lPTzlBUjZTWThYVkdrS1Awb05kUTBsdEVKR0FLRDVYZkJqOWFDTldRVCtSb09BRDIyL1ZOQTgyU0I0WjIvaUp5REk0UGFnNXVTb2VVRDhZbmllYUFEZnBJSlVaekoyOXVjMEhEZGwvcXRzaXl3ZHJtNlBRWS81b05UMHpSTFp4YmRsY05JRm9ob1FWSm1ESFBzT00wR04vYVRwU3I3WGhvZWxGTGppOE50cGtuNjBCWDdHbTM5SWZjc05RYlUwK2x3aFNUN0R0UWJ5TGRpK1lSNGlRdmFpVlQybjFQYy9GQXBhdjA4OWJYcXJxeTNiU3JjU2tZVE9Da3g3ZDVvRXo3VDJ2OEE3YTZoNlkrMFczWlNwN1RYdnVldE50anpydG5KUWx4VWN3RkZFOHlVVUduMy9VS0dMRXZzM0NGV2pqS0hHSFVFRkMwa0FoU1Znd2VhQlkxbnEyenQ3ZGJsbzRYM1ZTQ24rUW5pYyszcFFaazZ6ZjYvcXF3cEFDMXFIa1RQNFJnVDZ3UFdnME5GamFkSGRKMytwWHpxV3JUVFdmSHVYQ1lVODZQL0FGdGlPQ1Y3UUI5S0M1LzlOSFM2OUUrejVlczZraU5WMTk4Mzc1VmhRYkpQaGo5MWYvS2cxVHFDMlRjNmVWS0U3ZVFSTzRIRWZyUWZqLzdVTk9ROXFPcGFlQkNsU3BzazVDaHdmYlA3MEM5MEU0THkyUXRDVW00YkcxWUtaS0ZESDBvSEMzZVhabitMYkIyUWZNRHo3bWdnY3ZXRjNDVStFVXFNRkJnSmd6eVRRZU4zRjFxT29JdDJXeXZ4RkJLaWtoUVNtYzVGQlI2M1pDK3AwMnNKVXpvN0l0NEtZQXVGK1pmL0FNa2dwRStwOXFCTzZnUVZ2c1RKSUJuMU5CMTBXd282N2xKUGJGQnFLZ2tSa0V6R1A2VUVhczhBZW5QTkJ3cElnZ25zVG1nZ1VNenhRTzJtSGFWVC91TWtHU284a25PS0R0K0JBTVpWeWVRVFFBcjlVNzhnQ1k5U2ZUTkI3MHU2VTY3Ym9rQU9FcFBQcFFhdys4V0xIVUhqNWkwMzIvY1VDajluR2hLdnV2RzlZdVVuYXcwcFNOdzVVYUFuMTFZb3M5YnM5VFpTV2xlSXBMcG5LaU1nelFObWozWVcwMitSRzZOOEtrR2Y3bnZRRnZFUzRpVkxUNFp5ZHB6Z2NIOWYxb0F1dG0zZXRYdjRUTDF2Y3RscDIzZFNZY2JPRm9VTzRJOVBZMEdNczZmcjNSRGR5MW9sZzkxQjBvRnJVMVlMMk8zbGdua2xBazcwYzRpZmd5U0ZGM3JMcHJVbHVlTjFBMXB6d2tsbTl0WG1sdHFKNGdBakFrODgwRFowcjF2ME5vN0pWb2J1c2RTM1lBUzUvcG1tT3EyNVBLblFsSUdjMEZDK3V0USsxYnJIUzlEdjJFMkhUbGs3OTdkMDloMFBZU01GNXdZV3RSa1FQS2tFNVVjZ1AwbTB3R215RUlTZy93QzFKd0I2VUhWNG5kcHo2WTN5MnFBZStPS0Q4ZjhBWDdMbi93QnlYRHEwa0FLS1ZFbWNHZ3p0cEYvcE9xL2Y5RUlSY2pEclJQbGQrZm1nYVcrdWJXNEtScXlEcHQwcmJ1UStnN1RBNUNnUDNvSkxucUxwMGdoelZMVWlKL2hJVXBSSjdBQUdhQTlvL1VqK20yRGl1bWRHWHB5M0FFcTFqVWtqeGprNVl0K0I3S1VZNzVJRkF0dkpSYjI2VW9KVkVqektsU2lUa2tua2t5U2U1TkF0YXlRaDl0UjRuRkFkNkdzOTEwNitSOWFCMVdKSkE5YURoUTJudC9hZ2pVQkJrWjQrdEJFVUpKOHlUUHRGQTdhY2hhQVZFRXBVamRoTzNFQS9XZzl1b0NEaUFZMjV3UU80L09LQUZxS2xLQUtzRThqbjFvQjlvNzRHb1d6c2diSEVuZHhIdlFiUTJ5YjdUbm1rNFU2RXJUT0QrUTU3VUIzUnJWdTBaYlFocVZKRUJZVHg3VUMxMWd2NzFiWFNOMHJHZHFVNVNmUW52UUFPbXRTTFZ1aENseW9MZ25nVHhrbmptZ2FYTHNvSzBncHpJQWtSOFQ2VUVMVnlsMS93bkZGYTlvU05tVFBiYjNBOTZDci9BS0dYRmVJMkVraFJPM3pqSTdtSXh6K2xCeSt4Zk1JY1VrTjNUczdadVdrdkNZRS9pRTBBWFdocXVxTk9zL2ZuMHRPaFhrUkxUZTBqL2J3Q0NQVHQ3MERsOW0vVGxucFJlTnMybjd3NDJGS2R5ZTQ0b05GV1MyMm4zNTk2RHkyVUhiWWNrR1JNODBINTArMnV3RnMvY090b1NBbFFrZ1JQOTZESG1XVXZYSTNBZ0tIQTlLQXdtMVd5bHdMQ1ZzcWdBTEFVUHlQRkJiWVVoczcyMldXbDhlSTAwbEczOGhRVnRWdTFLSUtnUHc0ZzdzZkpvQVRyeFVUdTlUTWZwUUJOU2JjdWJoSkFWdFQzbWdmT2lXZHVuU1FRVkR2L0FFb0R4T0o5ZTlCSHdQNWgySWlnNUlrZ2R5WWoxb0lWcGs0Si9PZ2NOSFVxWU1TbWVlZndqOUtDeGNvTUVKVGtxNzl6SGYzb0YrOVVFa0lWRUs0ajh2OEFQaWdFdkNaUDYwR25mWjlydHRmc3MyVis4R2Jsa1FDbzRjSGFEMk5Cb2kxWGxrdFNtWEFwZ2pHNU80VEV4UUlkM2IzTGJWNWZYYmdoOXdoQ1FjUlBOQXY2RzJFT3VxYmpkdW4wUGVjZStNMERYZHNMVmJvVUZiUUViZ1o1Sk9maWdwMkYyNWIzS2xMU1V4K0NIUWVPSlA1WW4yb0hiVFhHME5uZWdtRVNCUG1tZU00b0xkNHhidjI0Q2tsT041MjVVRDZVQ3BxMXd4cHlnR056cjRVUUVRQ3BhandEbjF6RStsQTJkUHJUcDlvdzA2b2VKdERqc2lQTXJuNEE0QTlxQmlkZGJXMFNoYVNPZitLRHZjMnkxdUtnbEp6SjcwR0RmYmxjVzdqYVNWbFRhd1lCN25tUjdVR003MmhhV1RpUVBGU1NPeGxQZWdQMmFDOHhtRE9lTUhIRUgvdWcrdWJkdGhLbEpVVkpJQVVvOC80S0JjdmlqZVFBUVBVaUtBWXBVTnJKSUE3UjZpZzQwOVF1bWR1Q3VZNG9OQjBlMis1NmFsSTVNQ0o3VUVxK1lISEltZzhJRzBDSXhKZzBFWkJIb08wUlFSa2RnUG5uK2xBMzZVMTRRTzRsSzNGSldFUVZUaUNhQ3hkYkFsUlVJekdFNEk5L1U5cUFQZW9sUjQyajhvL3BRQm5XeEpnOS93QXhRUXRTMjRsYlpLRkpNZ2pzYUIxMGZydThac1JaNmdwVHFSK0J3Q1Q5ZjB6UUR0WDZqdXRVZVlEY00yck1yU0NQeEtqbWd0Nlc0bFYwVnBKRTl6QUE0eCtzMER2YVBKY2JhU29CUkp5Q1lDbGRvK09hQ3NsS0hCQVNyeUtLOXFVNElQYVBTWm1nTGFjQzRBb1N0b0s4eHlBVE9TZmNudG52UVhkVHZmdTFtRkJDUW9qY0pUbUJ6UHA5Wm9PZWc5RE4rNG5XOVRCeXJmYk5uai85b09maWdJZmFEb21vM09rWEYzMDR0WCtxSVRJYUtwRGdIWVNZM2VrNE5CaE9qZGMvYUpvdDg0TlQwMjJ1Tk1EZ0NtbHloOUFua0ttQ2VjSG5pZ2FPby90TVUrd3o5MUtpd3RPQ1JCSDY0OXhRWTcxMTFiZDZpcEJlUXBmK3hrUk1ldnhRQnJlOEQ2Ry9EVGhJbFZBMGFaY2xETFU3d0R4bVJIMTcwSGw4KzRsRWpDWXhuSm9BRHJtOFRNeDJKb0tiZ1U2a3RObmM0dnlwRVVEUjBuMCtiZGtQM1F6NlJ4UU5pK0lFRDBFVUZjZ2tZSGw3VUhJeWNuRVRNREZCR29aSTRJNWlnaElKUEt2cFFOMW5FRlFTU1FuYUVuaVNRZjM5S0MwNlNsU1NtRlFJeUk0UFB4UUI3MHlvN1VMVEhjbkordmVnRVBncVVOcEpCL21IZWdxbkJFWjlKb09rWklnejJGQmRiVnRRVktKVW44VUh1QlFGK24xN200U29sZTdidDlaOSsxQTIyejYvQ1dVSmpPSE5zUWY3MEZoU29jSlFVK2NiQ3VTa2ZNejZIODZBN1pKYlFndUZ3RklTQ1NZT09JK2FEN1Q5T1BVRjhFcFQ0V2xzRUI1WkovaXFHU2dldmFUK1ZBK0Y5QVFoTFcwTmpDUW5FUi9TZytkZlVDZG8zUU4xQW05Y3NXVCtsdnB1MGdvY1FvSlR0aFFqT0l6UWZtU3p0RGZhdGRNamZzVFBsN1R6bWdYTlYwOVZuZUwzRlJNd0RFelFRV2pjRWlZRkF4NlU1NGx1RzFlWkhNS09hQ054MVcwTnFFa0psS2xlbVlvQTZuSUJBTWR5RFFYK2xVRnpxRzNLUVlRbFNqRkJvaVFFNDNZam1nNGc3RDVnQWNaZ1VFU2lDVCtpWi90UWNLSklrSGpzZTlCR3NRSlBQYjFvSVNBRDVoOFJRTU9uM0cxcEtsQmU4cWhNazVqdEhwUUUzRjRJZEpTWmpJTWV2SCtjMEErN0NsNEtUekprL3JRQjMwRXdyZDVmVDBvS2pxSUdaNDU5cUQ1SWt5WUhjZDZDMHlKUitBUnpIT0tDOW82dkN2UWdwU1VxRW5IY3lQMG9IMjBaaitMdEVLQVNVazRIcitmNzBCRzBzMU1yQ3hDUWh3T2JnT3dJR2Y4QW1nTE9XeTNFcVEya3VLTUpFQ2NubVNlT1lGQVlTcHV3dFdiZGdOSVF3UE9aNDlTUk01TkFPdmRjVGFCUThSQ1ZCV0NwWFBwOU1tZ2tScURhbVM5ZXJRMHdoSU85MXpiSW5rekJJOXFCZXVlcmVrL3ZTYlM4MUJxNWZkOHFRa2pZY2Z6RVlUSmlnSGRLZEM2VFphemRYMTQ4eWJSenhGTnlvYlVnQVlQdmtuNlVHTGRkUDZVLzFQZGpTTGdQVzVNOFkvUHZRTEpiOEZhUkNRREpPTVQ2MEZpM2RLQUZZSkgwb0k3aGFWdUpXbFVLR0NSNkVmM29LWlNDNm9nZ3hqY2FCZzZFWjM2aGQzQ2dmSWp3eDhtZ2QxRXF5SmppZTlCdzZNZ0dKL01rKzlCRXBQbVVVampzT2FENVE4MERBR0JRUXVKOVpBQW1LQ0JZTTRVQjgwQnV3Z2dBRlNWVEhPRDMvT2dKZUtmTEhQSXpnbm1LQ3JjaElKRUJzSGdabWY2Q2dFWFg0UUFFZzVNVUE5eFdZN1FCL3dBMEhpVlltZmZOQVMwNWd2S21GN1IrUSt0QVkxNnpPbG90TGdmK3QxUVJ1QS9EaWNmbFFNMmo2b0hMRTdZVWxZM1JQQi96TVVCaTF1Q0VxS2twSkFTUWdaTVRNelFNbWxPanhpU1VyU0NSa1pKbmdENDcwQzkxcjFBclNXbkhrcFV2YmtIamNBUHdFbk04ZW5GQmhibXQ5VDZwcUlkMHRvQmFDU0MrVENBYzhEdlFYMGRLZmFKMUs0aHpWYmNYVE1HUjRwS1VnY1NrZXZ4Mm9EckgyYmRlc0lkWFlXT25Ob1cwUVd5OFF0VUVEYkJ3SkI3K2xBcmRTYVIxMW80YjArNTA1NjNaVUZoTzI1SzBFSGtDQkZBb0xaMWhDQzB1eWJTbEpoVzVSSEh6UVViZ1g3QTNMWlJFUUI0aDgzeGlnNXRyeDhxSmVaU0FjZVJVL3ZRRVdXVktiVXBReGdnQXhtYUNvNG90aFpKK2FCODZRdEZXV2h0N3dVcmYvaXE5WVBBb0QrMVFXa0V4OEQ5S0RtU2dHT1Qzak5CR2hQNFJPWmozQW45cUQ1U0J5Y3puMG9LN2lSUGxUMm5qOXFDRlFNalBhS0FuYkwyby9DZGhJSktpT000UGJOQVV3RUpUS2VJeHpIL0UwRUYyQnVVbEtnUk9UNi9sUUJyb1NzaFdPK0JraWdvTEkzWWdHZ2lRQ3RZU2tFazRvTk0wblFsTWRNcmUycEMxb0lreU9lMzYwRHFqcGY4QTFUN04yV0hFSlZmSVFIRTl5Vm83RStwRWo2MEdTbDF6Um5ITFJSQXQxUTQwdjFIY2ZTZ2QrbWJzdldxWEVyU0NFbENncnNJL3o4NkE3YjN5QXlwQi9tQWdSZ2R6SjljOXFBVjFLd05WZUtBRnFZVXFGa0p5b0ErdmFmMm9EZlQrald6TERTbE50TElSQ3dHMGpHWUh4M3ptZ212V0F5eDRqU3dsSTh5VEJUQU1jUm5QNVlvRi9xYnF1N3NrTGNZTjBYRUVncGRTWWppZmY0b005dmZ0QzZ2TENrdHUyYlZzaHdGSURRbEI5dldnU3RSMXJVYjlKVmV1SjNxVVZRbElHU2N6NmZGQXYzRGJqNWxaTzBHQm44NkRwdTBFb1NCanVEUVNQTzdXbE5FZnBuNjBIV2kyQjFUVkcyUi82R2dGdTQvU2cwUktTTjIwRklFREhidFFTaVRFbko5SS93QW1nOUtKU1NCT1lPS0Rrb3orSlJCeUl4OWFDUGtCS2s5cy93QnFDRXBuYVNJanNRYURndGdreVVuM0k1b0xOa05xZ0IvTjV2U2dMcEtsdG5ueWpQZm4xb0tkeW9Sa0RiTW52anRRQzdzK1lra1RFeDZVQTUxUko5b09LQTcwTG82OVcxaEJXRkJsQkhPUlB0UWJhdTFTemFHMlFrbEFUNVovV2djZEpNNmJibUlsQW9NeisxSHBSbzdydENJczNWYmxiUi82WFBYMkIvS2FETjlFMUZ6U2IwdFB1UjRjN1ZKN3pIMG1nZDEzeFg0ZHcybHh4dFNZV0loTTkvajFvT1duM0hybFBpS2EzcVRFSlRFREdKN0U5eG1nYWJXN1EweXRMWG1jSUVnWWc4R2ZYMytLQ3d1MWVlV3BTakNRWVNWQ1pWOGQ4VUE1L3BkT3BPaEx5aHRtVk83WmNJNHgySHh3S0FkcS93Qm5PbGkzbHRieFdsTzFKeDIrTy9IelFaZjFCMGtpMWRTZkZKa0ZSQnhKakorbmVnVnJuU1ZKQ1NFcVNsUTNibDhVQWg0ZUdsWVZreGcrMUFOWHVjSVNrRlN5WVNQV2dmdW5iQnZUckZEYVNsVHlnRnVxUEpWN1VCZENUNGNSZzQrYUR0QVNwSWxXM0JtTSsxQk9sTWhTRkFoQXdNOENnODJEZk1FbnVNQ01mOVVIaVd3RU5nd1NRY1I3NG9JMXRxRG5tSGxudnhQY1VFVGpDNUcxUkFJazVQTkJESm1BUk8zNnpRWDdlUTM1cEJIWSt0QjQrckJPZUR6ek1ab0JWeVNKM2VtY2QvNzBGTkZ1dTZmRExZSlVzNENSUCtZb053NkMwQWFSWUpXcmFIaUpKSmc1NW9HM3dRdEE4WEE0ejJGQVcwY2dXeFp4TFppUGJtZ3RYVnV6ZDJ6dHZjdHBkWWRTVUxRb1NGQThpZy9QZjJrOUdYZlRkeXE2WUMzOUtVcitIY1RLbXY4QThWLzBWMythQmYwblhGRUZsOGt1QVlDanVrZkhmSHJRT1ZscWJSTFliY0tnVWlTbUNRUDZlL05BMzZTNGxUTzZQQy9tQ1NvZWFZN0dnYTdXNGJVUjR4U0pIbFNTRDdVRmx5NmJCS2dxUURPQVA4LzZvRmZYdFVRNjk0YVZsQ1RHVU9RVkNlUUJ5Ukg3MENKMU02d2xRSUtSdUlTUitJYlJHSitZeDgwQ0JyVjYweUhXaDRaQUpoWVBQYjZpZ1F0U2RDMUtWSk9lVDZVRlhweC83MXFxa3NwMm9iTzJlNW9HUldwS3RuZ2hjZ0pWRW1nTFdXcmdqektINTBCeG03WWNqekFrZStJb0xiYWt4S1ZRSWdlczBFZ1FGcEoybkpBRS93Q1lvSlc5cGVDWjhzU1NhRHBMY0tLaWVESUJNQ0Fld2lnNThBbklTUk9UMm9BREhBbUFSM21hQzZ5VHNRVkFKTTR4T0tEMTRoUXdBbjBQclFETGhPOVFiYmJLbGs4RCt0Qm9mMmM5TGJmL0FETG9KSmdjcXlCOU85QnExbzM1ZTBKR0Vqak5CM3NTR1FTb0EvNWlncWk0TnJxQ0hVQStHY0tBT052YWdaRWtLQUl5RGtVSEZ3eTFjTUxadUcwT3RPQXBXaFlrS0I3RVVHQi9hWjlrMTFZZUpxUFNqUnVMRk1yWFlnL3hHdTh0bnVQYmtVR1c2YnJqbHM4a3VCU2twVkc5SmhTVDNDaFFhSDB2MWFBaEJZZThZb1BtVkFLcGs1VUNDUU14Z2U5QXpvMTlMWWNLYmdGS2trRGFjYzk1enlLRHkrNm9TV2kyaDliZ0kzSy9pUmdDSUVjNW9GeldPcEdVUEo4Tk11cUlrcUVsUEl3SmdZejYwQ3AxSDFNMnRvSXQwanlMbHZ2aWUvdnhRSkYvZHJlQlVWd2tEbnVQWTBBRFVMaFJiVW9IeXh6UE5CZCt6OXZlNWNMd1pFOFVCTHFSTVM2bjhKZ3pQRkJWdDNuRklDMmpCQW9MMXRxempKVEpJTkFZdDljQjVVY2NaeFFGN1hYU0FtVlRISHRRRldkWlNkcFV2bnk1SEFvQ0xHb05PcjNLQVBtTW1jKy96UVdOelJ5VGs4NE5Bck1IQTlwUHlhQW15QXRwSUE4eDl2YWc2YlpYY3E4SmhKVXIyei8xUU5YVEhUSis5b2Z1d2trbmdqSCtUUWFYYXNKWlMybTNDUWdqOE1RVEhyL2FnSU5TaFpNaVNaNC9TZzhrcVdwU29VazlpZUtDcGNza3RSaEtWYytzZXMwRjNwNi84VHhMVjFlNVNENUZIRzRVQnVnK29NdisxSDdLclBxZER1bzZONGRqcllFN2dJUS9IWlE5Y2MwSDV3ZnNiaXcxSnl5djJYTExVR1Q1aE8xWHlrK2xCYlZxRi9iaEtYRmZlVzBIQ2xZVitZNStvb0s3dXR1b0psTGc5aFFVSHRYM3lDVkNmU2dvUDNtNFRzSnpNemlncHJkVTVsdzQ5c3pRQzlYZTJ0S0VrVURGMENoVGRuY1BFUWtKT1pvTEd2UE1xMG1WclNGeVJFMEF6Um5nV29KeCt0QmNlUUZLbnYzOXFDQkpLRDVwTWUyS0M2MWNraEtVcUk1eFFXbW4zRXlVcTd3S0M2eHFhMjFKbkFIZisxQVdHc3FBaEprRHZITkJiYUlVcElQckZBVzB4aHk1S1dtNEppSkg4djFvTkQwRFEyN2RrRjFCMzRuRTVvRzl0QWJRQUcxQkp4QkVtZ3Z0a0tibE1UeGovT2FDeW1JODVtZlVUUWVjamRqYkJJbkVVRkJheWsrSnVVcVFVeUJJeG1UUVVOUVMvYk9JdWJSc2tJTzhxQ3ZYdjhVRFJwT29wdldnRmpZOGtlWlA5cUFoUWZVQ1o5b2YyZjZYMW5Zbnh4OTIxRkEvZ1hiWWhTRDZIMUZCK2ErcGVuTmQ2UnVEYjY3YUtMSENicG9ibTNQZkhITkF2dnBRdE81c2dnOFFjVUE5YlFNOGc4VUVDd2tEYVRJNUE5YUNqZHZiRWtpQUI3VUM1Y3VLdWJoRExlNGxaakZCb1Z5NGpwenBaTFRrZU82TWcwR2V1UE9YTGlsT0xPd21kdEFYMHE0Q0NBcVJRTXpaU3RBS1FDRDNvT0hVU1BNQk9lS0NvdFhocU8zMk5CZHMzL0VTTUNaUEh4UVRxN2taOUJRZDdzQ2dkTEczVzhvQkJJU1RCSXhqL085QnAzUitsSXNrZUlVQlJLWjh4L2IyOTZCb2FRbGJ5RkNGTmp6YlJnQS9OQmZXdnczZjRZVEhZZzk4VUJCc3FjU0NOM3FaNUI5L2FnbDg2R1NoVzFhVlRtYURoMUtWSWxhd25jSjJVRUNJU0pPMGlNS21CTS8yb0txMm5BbDFFaFBpWUJTTWMwRlJrdTJ0d0hBWEV1SU1BZXA3L1ErbEEwYUxxYWRSYVVGSkxkdzJZY2JQOHBvQ1ZCOGFDbnFGbmIzZHNwcTVZYmVhVmdvY0VnMEdLZGIvQUdNNmRlRnk0NmVlT25YQm4rSHloWk9lTzFCakd1ZEk5U2FFNGZ2dG1wMXJzNno1Z2NVQ3RkM2NFaFlXaGY4QXRVbURRQTlWdXg0Y0E4MERYOW0vVEc5QjFuVWtFTUovQkk1TkFCNjMxUldxYTA0bE9XR3p0U0RuRkFKYmFDWUErYUNSc0R4RWppRE5BMzZkaGhPQko3azBGeFkzZmhtRFFWMU1Bak1pWm5QRkJ6NFNrRHltQjYwRXlISjUvUTBFdURrRlAxRkJ0L1RHakMzWUR6aUZKVWNUUFBlS0IyMGdoS2RpZTRrcEFKSTkvd0JhRG5VNzFiYWdXRXdDZHBLdUppZ3ZXZDBsZHVsYnFRREVrcEpqNmZXZ0xXVncwdEtZVkc3emZCNGlndEtHeUVDZGg3emdZb0lIQUhTVk53Q0RrZHg3MEVkeTBwVHJha3hCd3FjUnhnZWhvT24vQUF5MDJrbmVVcHdVanVPOUJXZGJXSldBb0p4NVRpSTRvS1Q2YmkwVXEvWmNVWEVHUTJFeHY5aWFCcTBuVkdiKzJDd1FoMU1KY2JKeWxVWkZCYmNPMVlXbUNEam1nOWNVTmtpSVBya0dnQTZ1MzVOeWxwUU13bzk2QkYxZTcwNXAwdFA2dmJCWkk4aW5BWlBlYUJWdk9sOVA2Z2VjQ0JhUE56RzhFRXhRWTM5by9TV2g2RDFPMWFzM0sxbEtncDFDZTFCSjFIMTJselNVNlRwdHI0RnNoSVR1L3dCMERrMEdlQUZVa3FTQ29aUGVna1FtSUdmeW9Jd1ljVDdVRFpwamhVMGtLLzZvQ1NDTVFKSFlpZzZDZStCUHZtZ2pVQWNZeFFSTEJudEU0b08wcU1kZ08wbWcvU2JCMjdnNG1FcDk4ZXgvZWdNNmVFYlZiU1pFRWY1K2RBSzE1THZncmJoU2tyVHVCVDYvOVVGenBOUWUwMUlraDBmaWttSTcwQnEwS2l0QndpREJBemoxb0NidTVDMHBBQzk1Ny92UWZKYmNRcFNaQUJQbEE3MEhkeXRTRklTSENyZGhNai9PYUNBc3FXMCtrTEJrRE1VRURqWVFrK2ZZRUkzRXFHU1o0b0tpcmJ4SFdHR256NGJ5dDViS1pCQTlQUSs5Qk5xVmtxelQvcUZpdi95MEVUT1F0UG9SOFVBdnFQN1N0QTZlWlNtOWNkY3ZYRUJhYlJsRzVYMVBBK2FESitvUHQ2MVZJZFoweG0ydDFUQ0RseHdEdFBhZ3lycUhxZnFuWGo0bXA2amVvWldUdFFWRk0vUVVDN2MyeFRzUjRyamo1RW5jb21LRHkydUw2MldWV2QvZE5sT1ZMU3N4UVVieDI5ZTFGTDdyaTNWcjVVNHFTb1VFM2tmUVd6Z0VZQTdHZ29OYm1sa0dBa25raWd0cUg4eEpJb0toVnRlU0o0b0cvUWdDekpFbUp4M29DY0FsV0FQaWc2UktBUVRqOVRRZktRREJCSDBGQjk0Y3dUMkgxb0JycnFVckkzUkhhZy9UZHNoVzV4MU80eU9BUkJIOUtBbUVoS2lrQUZLaUNJNWowOTZBVnJUNjJtVmxrS1R0VjVnY3pQZWc2Nk12QVBFWmRKUmtDWTQ5NkJqUzFENjBCeEtGVHZRZnhRQ2M1K1JRV25QR1NTNjQ4ZHFaZ2pqNW9PcmQxNXRhVm9Xa2pCVW9nL3BRWDNubTNRMlpBamcraDkvMW9PVzNqNHlZV0Jna2tTUjhmRkJFK2xQakErS1NVbVFyYi9YMG9LTzkzNzZ0eGNvVTJnb1F1SkJLam1mU2d1QjdkdWE4cWxKUUNEeEtpZWFCSCsxUG9HMDZ1MDU0c2JyZlZHRWx4dDVDZ0M0ci9hUjZHZy9OOWl3blNYTGhxOVk4SzlaYzhOVEtoa3E5QlBZK3RCOXE5MjljdmgxNUtUZEZNQnNZUzBQVSs5QUpTMEhRdnpFTnpManZkWjlCUVRPV2dTMGxhMnlsQi84QVUxT1ZlNTlxQ2xkdGxwWjNSNHNTUU9FRDBvRngxeGRzOHJaNWtxazBGMjJVMC9iQUpUQzBuelpuTkJhWEFZU0pJVjZFVUFwMVcyNUdRUDZVRHQwMmpjMk1FZTRGQVdXMkF2QXg3VUhLV3d1Y0QzSW9PMjJ2TnR5UlFkUElBYldmYmlnV24wcUxwZ1Q3MEg2bjB0K2JkZVNsMUtpTnE4aFFKeCsvTkJhWmRPNUNGSjh5UmdBOXY2UlFDZXJHM2d4NHJicFQ1U2twQWdpTzU5cUFMMHhmUEYzYTJrcEtFd1FvejY0K0tEUkdHa2xkcmRMM0xSY003ZGdNcGtIMTlhQzIyc0xRQ1JDUVNsTzR6QkhJb0xmaUxLeXIrRVU0QWpNNG9KYmRDM0J1VWhLa29KQ2h6NzBITjZwTnZha0lEYVdrK1lFS0dTTzBVRVYxcUNFV3lYYmhFRW9La0ZKQlBISjlxQ3BaS1M5WXRQUFBGRDd5U29Ua1J6a2ZGQkpidzI2aHNod0ZBM0JaeVovcUtDKzJGM0pIQ2dESktZZy84SDBGQmozMnpkQUt2bkY2L3BUeUhOVFFsUldraUFwUCswK2hIWTBHQUxjQ2trRGQ0WVBuVWZ4clg2VUJXMXRBVXRxY2JDbkQvd0NxM1R3bjNOQmFjYUtYVm9Da0x1RC9BT3h3L2hhR01DZ1g5U2FRR3lHZ3J3Snl0WEsxVUMxcWFmRGlaVW9qZ1VGV3lRNnlzcVFTRDZVQkg3ejRvQUtvVU8xQlN2UEs0aFJNVUdrOUZOSVhhQXhKaUJITkFXdjdZQkJLY2prQTBGQk1wQmp5azh4Mm9MRFRXNEVUazhudWFENjRRb3NxNUI0aWdDcnRDWEZTa0VneHpRZm9jclUzZE5wVXBLSFZnK0hJTUxJeVV4a1RIQS9LZ0l0ckVia2x3OEJTVkRCUGI0UHZRU2E0MlhtTmpyUWRWc0g4UUhnYy9UdlFaL3A5NHEzMTVMVzhCTzR6UElQdlFhQnB3OFJoRHFOeFEyNUNFQldJOXYyb0RWMFhFdUZNQkRSU1ZvSkg4dzdZK3RCOXBpZDF5ODYyK3RTU25hcE13bmRFN2dQVGtVRnkyRjRsVHFGdWhUU1kzU0lVQ1R5STlxQ1oxVEt0d1Y1a3hBQ1VnNVBlZ0g2Njc0bW5Jc2x0N25YMXBhU0FZaEpPZU9NVUgxeWx0aTJOcTJoTzFLWVFGS2hSRXg1VDYwRXp5bE5JSVh0S3hDUXBmWW1POUJiczJ2dVREN1ljV1pNbENvOHFqMlRGQjQrMmJwUVNBNGxLVXl0YWs3U28wR0UvYTcwR3RpNGU2aTB1d1VzTnFoNXBvQUlVWW5lRTh6RkJtdHJkcFNncFljQ25GSkNuN2pza2Vnb0oxRnAyM0VId3JFWUJqelBHZjJOQlQxRmx3dU5GeHNlTXJEVnVuT3dlcG9GWFdXZ2wxTGNoYWgrSW4xb0lHbWc0aU80N1VFTDl1cHRJV2taSHZRVW55cGFVOWlLRFUvczNRcDIwQ1RBSFB6UU9PdFdDUlpCU0NuY0RtT2MwQ3cweVVsVzRBRUFqelVFcklJWEh4azBFNVNWU0R3YUQ1VERZaVFuSW9OamhKS2krK3BUaVR1QUU0RWp2NnpCb0xWdXR6NzZ5aDRBSmRFS1Vnbm5PUU8xQk5lZmRtbVV0clJHOUNtTjhreklrWm1RZmVnUk9yTGR4THpkNjRHMkhnUWcrR0pCSTcvcFFIT2dieE9wdHYyN3dXcmN3cFpDVEFCSC9BSDJvSEMyZEp0R1hTU1E0Z2ZpT2QzdjdjVUhqTjB5MFcyclpEaWJoSkpWSVRCTXhBb0NkazA5Y09LbFNnMkR0Sk1TSjRtT2ZtZzZOdXdWT0pVNnRxQ1VxU2tTZmdHZ3AyakNVUE9hZ3k0NCtxUERDWGNKOFR1cjJ3WWtVRVRxWVVwOWFpbTVaUjVnRkVwbjFIcHpRV0xZdU5XeEsybWxXdXorSUJ5VmNrai9tZ3RtNEtYR2tvQ0hHTUtrZ2p0SU1VRjlTaXUzVzJ5b05yVEJJeVNBcVlqOGpRUjNkc2xWdWhManBXMDRBbE1wa2ljZC9XZy9OWDJ1ZENMNlh1djhBVkxJSkdpUHVGVHpRZ0Z0d25zTzROQXEyamhiUTI0dEtWM2EvS3lnL2dhQjROQjg4Q0ZQSlFxWEFQL0lmUEtmWlB0UUtGMjYzY1BMS0ViUW44SjdrZXRCSmJzOEtBODNjVUZweTIzSkNvM0U5c1VGZTYwVlRWc1hWSkFCNHpRTm4yUnVCVHpqYTB5VXlZb05Tdk5LS3JWU2trQTdjeWVab0VDOFNwbDZENVQzaWdrUUlBb0paQ2xjZVlkdTFCSzN0MithSitKb1AvOWs9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9TY2hyb2VkaW5nZXIuanBnXG4gKiogbW9kdWxlIGlkID0gMjk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFFQVNBQklBQUQvL2dCdlJtbHNaU0J6YjNWeVkyVTZJR2gwZEhBNkx5OWpiMjF0YjI1ekxuZHBhMmx0WldScFlTNXZjbWN2ZDJscmFTOUdhV3hsT2sxdmJtRmZUR2x6WVN4ZllubGZUR1Z2Ym1GeVpHOWZaR0ZmVm1sdVkya3NYMlp5YjIxZlF6SlNUVVpmY21WMGIzVmphR1ZrTG1wd1ovL2JBRU1BQmdRRkJnVUVCZ1lGQmdjSEJnZ0tFQW9LQ1FrS0ZBNFBEQkFYRkJnWUZ4UVdGaG9kSlI4YUd5TWNGaFlnTENBakppY3BLaWtaSHkwd0xTZ3dKU2dwS1AvYkFFTUJCd2NIQ2dnS0V3b0tFeWdhRmhvb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LQ2dvS0Nnb0tDZ29LUC9BQUJFSUFiOEJMQU1CRVFBQ0VRRURFUUgveEFBY0FBQUNBd0VCQVFFQUFBQUFBQUFBQUFBREJBSUZCZ0VBQndqL3hBQS9FQUFDQVFNREFnUURCd1FCQlFBQkF3VUJBaEVBQXlFRUVqRUZRUk1pVVdGeGdaRUdNcUd4d2RId0ZDTkM0ZkVIRlROU1lpUWxjc0pEVTRLU292L0VBQm9CQUFNQkFRRUJBQUFBQUFBQUFBQUFBQUVDQXdBRUJRYi94QUF4RVFBQ0FnSUNBUU1DQlFNRUF3RUFBQUFBQVFJUkF5RVNNVUVFSWxFVFlRVXljWkh3Z2FHeEk5SGg4UlF6UXNILzJnQU1Bd0VBQWhFREVRQS9BTTgybExNVllUSmt4d2E0ZVRXem1rdVFJYUZoUGxnbHNBRSs5RDZsazFqZlJ5M29tU0dZUU9LVjVmZ2RZL2s3L1FiN2NzckxNOFpnMFk1Ry9Jc29KSGJ2VDRTV2FWOUc0UHlvdWNsMnpRaW4waUIwTnBWTHdvaUQ4ZUtWejhoVUczUlAra2tzcHRrQ1k0aWFQMUtTQndPZjl0VnJnREtVZ0dZbm4rQ2tlUk1LZzBEYnBmbTNGSnpnTVp4VytwUnZwL0JDNzA0UUQ0U1NRRjR6VEtiOE1YaFhaNWRFUWtiTXdUODRveHlCY0VGdGFGSHR3VUVNSWdudFN1YVY3RHd1anFXV3RwTmxZTStWbGFCN3o4cVdOeVVYWWR4YnJRTnRDaEE4cUU4c0RWSEtTc1ZRUWZTMm92TElIQkdQZFNJb2N0KzRaUmE2SjI3VnBGRUJTQ1JtUHdxVVY4RE5ORXJhMnd6bUlKQkFFZHU5TXRMWU4yRFRUMm5Na0hqQmlUOGF5aTE5d1hZWCtuUk4za3RpRmlRc0g1MHkxMFoyd0YzU3B0QytHcytzeFI0K1dDMzRCZjB0c2cyMlNST0FDZjByTEhhc3ptN3BzSzNUVVlBaFFUM2lZcE5SMCtqYmUxMkJPZ1FPSDhOVEhCSE5ibkZxNHNGTmFaSWFWYmF5cWdNRFBCTkxiZDNRM1hRTCtsUlhoTFpBQUlCQXh4V1dsb052NUlmMGErR25rSU01OG9vTk4rUW5HMEl3ZkRVbWU2ODAvS1NWV0x4VjJDT2lrTEtJUFdCRkZOb3pTWk5kTEMrVUFaR1IyUHpvODE4aThIOEVWMHBKRWpjSjlwL0ttNUo3RmNHZ28wWnd3UlFUMk16OWFaWk5pZlRkSFA2QWxBektKQTdIRkQ2aWFhVDJGd2tuYldpYjZDMkJJVVp5WUZPb3I0RXQvSkcxb0VWNTJncWV4RVVPbTBobGJSSzUweXdTUUxWc3prL0QxcDdkMGpKUDVCRHBscHA4cEhja0VnbjlLQ2kyKzZHY3FYUVd6MHRkZzJ0cU4wOTJNVWpjdkRHVHA3UUs3cE5QYWVMbDY1YjNTVlZXNEU5NVBOVnh1MTJkTUphTkxlQ3lDZ01SbkZjYmtxdG1yd2lONjJBeWovRUhFOFJTeW1xREdJSmdQRmtLb1Bxb2treC94U3RtUFdzYldNSG5nOCsvNlZveVlHbDRPTWJiQVFwSkg0SCtDanlhMzVCUU1LN0l3QzVNY24xNC9NL1NsOTFEYXNOYlU0SVhkQmdUQW4rVFJiMVFGRlhaS2ZEQkxHZVNDUjJuOGVmeG8yRGlSZnpPcFY1QkptTS9HbXBVQktpQ3J0Q21BVE80eVovbnJTS2tNMVlKQnVVSHlMdTgwZHgvUDNvS0tNL2dtc3JFU3dnbURSUUdqeWdNME9waU94bzhrelUwVENvZnZJQUpqSW9wMkNxT2hCNDZZd1Q4S1JTdVJXS3BVUXRuYXBNZVhnVnVWV0NVYm9rL25qRUw3Q0tLbllPTkhOZ0xSRFJFVE5VNXZ3SnhRZEZWY0VtWTVQZWtiWmlKWlJ6TUhzYWRTQTBES0xJZ0VidmVpbTEyd1V2QjNZVGdBeDhhbktOakloNFdZS0dQalNmb00wZWRWQjNLVzVJeFRKM29ISHl6eFVRMklqdlFqSnQ3Wm5GZUFaQk1ST0orSHhwdGRocWlBREV5SmcwTFM2Tlh5RTJjYmxNbk5OekY0RTJRYlF6Qmg4cUhJM0VpQjVUaVQvOEF0NW8yKzBiaXVqbDJUL2o1UjdVYjh0Z3I0SldrdHVWQ2lmaU9LTGZMU0RWYllRSUF6WUI3ZndWdVRpYmltZFZCSmhGUGZ5aWdzc3VyTThjUWtJRkNsQjhRT2ZoVGZVOFdEZ2pxSWp3Tm9CWGtSK1ZhTTNLcmZRSlFTQ01FQmpPNFFjNStGSEkyMnJOQ0tSbmVvMmJOelVsamRWU2V4ejNOTkI2MldpdEdrdHdkNEcwc01tSzU1UFpraUlUemJpZTRJSnpqMUZMRldHUkJyUWE1a0VOQmtHUkg4L1NpL2hDbzRMYWhQVUU4WU04NS9MNlVpVkladXlLaUZWVk1BNEp6RVQvcWl2ZzFXRGk0UUNjWTJ6dW5JOVA1MnB0SUZXRVlsQ1pLbVNTSk1maCt0Q3pjVGx4V1p2TGtEakZhM1lUaHNGQmtEMUo5VCtsRkpnMEI4MytSMmdtQTU0NDRpaXRHYU9CUEltWWIwaU1nZWxCc3lSTXA1U1NJbkhNVFN2c0pJV3p1VmdmaFJvQk1xVDk0bjRDc0E3TzJDb0FhUmcxdkk4U05xMkRhVWQrVG1wdEJDRzFPZndtbWgxUXNpSlFudWVlMVVGb210bnk1Qit0QmIwWjZPRzNJM1lqNDBkOUlGSFBMT0Q5S05tbzRVTW1HajNvTU5FMFhhQjVwN21zcVRBMDJTS2p1QURSUUdqektQRHpJSkVERktNQ05uYUpZNU1uRkJhMGcxWjVyZTFsSTdVM2dCNEJqeEU5dmFrR282RVBaZDJLS1RCbzlzWVlWUjlacksvQWFYa2o0YWh5WXozTlBRcitBMW16NVRIT0RtbXRDVTJTZTBaSklBajRVc2ttTWp3Vll3dmFscWd2WVRhSkFDa3dLTkFPQ3lNNHorZEN3MEN1V25UaGNSRmE5aktxS1hxUW0rTnlBRUNEQjV5YTdNZHVPaGRJdnRNQUNKNE9Sbm11SHZSUmhMcFdUd1RqNVp4K3RQMEoyY1JSdkRQNTJudG4rYzBHdkxCZmhIV1l3QUZ6T2ZRVDIvS2cyKzJaSkVFUkh6Zy9HdFpxSlc3U3FNWjdjZDZaVUxzbUxLa1NRZDNyQW1nL3NNZ0xwdFkvZkk5WkVVdDBOVmtTcHpJWWlNZDZibFNOVnNqYnQ0RUFHZTNwVzBCMlFGb0xHRGdmV2xHT3NnQklCay96MnBoU1FUQmlSK2xaNkFsWVcwZ3pJeitsSXV4bVEyZjNsSXg1aEUvR2plMEZMUU8wdmxrRHR6V2lHU0dVVVFEa0gwckxUQTFaUHd5MG50NmlqYll0STc0U1hQaFRWNUFjdTZZSWtyazFrMjlocWhmd0RKWXJXYjNUQ0ROc2s0bUszWm1UQUFrWkZhaFFpcExnR1RuaUtLVmdETlp5RG44NG9TVkdpQnVJU0JQZk9QalFTR3ZZTmtWb0lFNHJYb05FeGJJazVHTTFqSFN1RG1Sd1BqV2VqTFp3V3lSSjllOWFKbWR0b0pNZ1I3MDY2b1ZqSEU0LzFXNkZvaTRrU1o1clVyMk5zZ1V6eUFCOHNVWlZRRWRVaFQzTXppTzlKWXpRUzJaSlBtayt0RG9CeTlia0dlU0pvV01aenJYazF6S3NDQU1WMlk1VkZDOGJOSHBiSThLVEJFZk91S0MyUE42STNRZHpCRmpnWS9MOGFaaW9HNExNT1lER0o5elFZYURMYkpEYnZVWkZKWWFPcGFJdVl4T2MvT3RDM3RnbFM2SmY0b0lKTUQ5NnRwQ0VZOHhnbVNjeFNYZWg2SnI1c1JNVHdJRWVsWjcwWmZKMFcxTFNDT09ZbzhWMGEzMkNLZVk3VFB5L1dwdlEzWndXY2lWZ2pIdjdWazBaa1hUYklQcFI1VUNnaUlNRmhqdFFjck5SM1prS3ZCNUZhNkRWZ250K2RaSGxrQTB2TGV4NnBIcmRvako0STdWUlBzRFhSUHc1TWtnQ25XeEtva2JaMllQeUhldEtYd1pJNGlnVEpKZ3pRV3V4bnZvSmtyM21qeVl2RUhjN3FmdTk2RGZnMUFTdWNEbnRRWDJNeVNLQ0RrQXpUQ2gxWGI5MEU5cG8ycm9XanJnbmlQblFjdDloUzBDdTRpR0VpbHV4bG9Fd0FNQWdBQUFTYzBISVpJbWNqYjNJNzkvbFJUQlJBZmR4QkVUeld1MEdxQ29KOHFqTVI3VFRJRE9CWWtEMXhCK0grNnlZR0daVEIzUkhZRTRwMjBoVVFSUUVJODBaUDgvR2x2UXpXd2h0RUVBY2Q1NzBya2FnWVdHNXlSbUQ3OGUxSnoyR3RCa1VFQUNEMi93QjA4WFlHanpXMkFadlVkcUxWbVRveTMyaXRPZW9TdHNNTmd5Yyt0WGkxU0dpalU2V1BBTXo2UlBGY3NZV3FRSk9uWkIxRDNHUlZJamt4MkZHU2ZrVlA0Q2l5clJBbURqdlMxYkRkSGJ5eElrd0tMVkdUQm9ZMnlZUEg0VUZLZzhUaEJLRXJKbjVlbEJPdzFSRkZZQ016Tk1rWTZ1NGp1UkhwVzVKczNHanlXNVlBUHozOWEzMk1GVzBmUUR6Y3hTNlp1amwyMldBaVFTZTN3cmNXbFprd0kzZUdCR0FLVm9LSmhXS3d4Mmlza2pIbVhieDZSVFZib0hSMjRoSzRKbkdmMm9VcXZ5TjI5SGJ4dFdiQmErNm9uSkxIRkkyaWlnMjlHWDEzMnUwZzNMMHl4YzFUcmpjMG92eTdtcXhVbjNvdkgwM3lVT3UrMW5WSGNxdmc2ZUJQbHQ3aUI4U2FwSEhGcjVLZlFqSHNybiswZlUyWlNkZmRFNE1LZy9TcXJCSDRBNHdvOHYybzZ4YjJGTld0eGZTN2JWdnlnMGZveCtBUEhCOUZocFB0enFyWi93RHk5R2hYdWJURWZnYVYrbnI4ckVlRk0wUFNmdE4wM3FUcWkzeFp2dGtXN3ZrSlBzZURVdnB2R3RvalBGSmJvdkZBbmpJUEVVdHJ3UmFhQ2hZVDM5NkxhOEFvTHNBVW5NZDROSnhwbXV3TjVjeWNLT0R4M3AzVldaSUh0OHVKbjFta2FIUkt5SWJJTXhCeC9Kb3JRR2UycVdKTVIrZjgvU2lxWnVpYVd4SzRuSHAvSS9hcU5DV2QybGk1aUQ3Zm5TMzJhZ3dTRUpqZzlxRDJncGJKV3JVN2h6ejIrRkJkQlpLNWJPL1ByUFBOWjBCQzdKREErYUFQOGFuV3h3dHRWWmNqSXBoUXJBN0dqLzF6QXFsNkU4bVMrMEZxNmVvRW9qc05vNE1WU01sUlNKcGRDRld3SkI1NTlhV0w0b25KV3liamI1VkhtUGVacFpPK3pKVWVXNy82a0R1U3gvbnRRVERSeTViTHZoZ1JQOC9udlFrRkU3VnB0NXlKNy92U2ZZY2xjdGtLQm52K2RCTnJzM1lNSUNzQ0JtbVQwYnlTRm95QUJNQ2NIOWFOQXNKWlRhNE1aQXpXbzFrZ3dBaWw2Um1pS2tZMmlBRG1hMzJZU1NJQ3pNVmhaaWxrMG5vMUhIdDdnTUE5d09LVmQwSHdkYTJHaUlsYXExUXEyVi9WdW8yZW42VnJsNCthQ0VIcWZhcHR2cGRsOGVOeVo4KzZ0cXRYMWZVQTZoaW1uVStTMHB3QjZuMU5QcURkZG5aamhTMGQ2Wm9FRzl0c3FveVRVY21WdlIwUlZDZXEweGRuWmxtVFhUQ2RKRW1yWlhYZEhBM1JBR2ZjMTBReVdUY2FLblU2Y1JpUVIzcm9qTWxKQ3phbTlaSURlZGZRMVJ3akw3Q3FiaWNlNVoxQ1JiRFdqa3grMUx4bER2WlRsR1MwWC8yWisydXA2VGNUVDlVTnpVNkVZM2pOeTM2ZkVlMVJ5K2tXVDNZOU1qSkxwbjF6UmFteHJOTmExT2x1aTlhdURjcnJ3UlhGeWEwMXM1NVFjWFRIQ29Za0JtSnhHWnJScGlQU0JHeUprajJNNXJPSVV3Ykp0YUZuN3VLMUpHN08ybEJhQitIYW1Bd3BYNzJaOWZlbThiRjg2RHJiWGFkd21CMnJTNk11d1hnLzNBUnh4RlFrdmdvZ20yQXhHZHNjR3RZeVJKUnRVaURFL3dBK1ZDMjlCTzNKWmczQjlZcGhDUGg3Z1NCUDUwT3duTnNJQWUrTVU2Mkt3N3dFTUNZSHBRbEt0QVNzb2VxYWEyMm9ET1JKWHY4QUVpclFWcXcyeHpSWEkwNmp6VHVKSlBKcFYwRjlqZG0wSDhwSFBvSno2MXFzVG9NK21ETnRCSVhHTzBVUHNrSDduVGFVRXdvT1AxNzBqbHNaTFIwcDRZd0pPUWNack5VWk96amlWeVBqbW5VZmtGL0J4aDVWMnJMTHo3Q2tiWGdLWHllVVQ3ODBiUWFDS3BMeEdPK0t6a0Nqd1NDU09NVUxEUUFyQkh2V2FNR0txY0hBQnBGRmRzMzZIUWhhQ1d3QmltVVVac0ZxSHRhWFNYTDE4N2JhTHVadldtWVlSYmRJK1dhL1czK3I5U2U2NmtneXRwQm5hUFlWbWxGV2VqQ0NTb3Vlbi9aL3FHcGdwcHlxdGp6NHJteVpvS1JhSzBYOW43SjN4WWEyV0MzR0V5T08rSzVYbTNkREZYclBzcHJRekZYdE5Na25JRldqNnFQVkFvejNWT2c2N1RxYmh0Qnh3ZHBtdXJINm1EOGlPRE14cTdiSVNIUXFmY2NWM3dhZlRJeVZkbFRxbGFTZWU4MTB3SXlRanFGQXVZTTk1QTRxeVJOa0NWZENyd0cvT2p4cm9hN1d6VWY5UC90VS9RdGIvUzZ0Mi83YmZKbWYvd0NrMHh1SHQ2L1d1ZjFYcHVhK3BEdGYzRS9NdUxQdVZ0MEZwR0dTL0FHUWM4MTVNUGMyUmtxUFFXbnlqZHRxbmJFQXJZYkpQbDllOWFtZzJjWkFJNEE5dTFDdEJzSWdJa0VBeWFmd0tIVUU4bkVjVXI3Q0V0V3l5aVRTT3FwQlhkbmJxcUNVWGowanRVMnE2S0loZFFLaDdBQ1NZK2xIb3hFb1FZSU04SDFtdGU2QlhramJBRzcxN0d0QXpQS3VWUHFjR25YWUdoaDFBVW4wQndPOUdTVHNWRlJyVC9jVWJaaGVaanVhNk1hOW9IK3BMU0tSWkJEYnYvcm4zcUMwdGxIc2JzNzAyc2N4akdKTkJ2ZElWME9LNGFGVWJkb3lPYWJTRld6aXpCWUFGZTRpaEZYc0wwVHVBT0lVVEhjMHJmajRDa0RObGlNdGc5NkNrdzBSMllBeVNUMjcwajMwTWdpMmh1QU1UMzcwZEl3V0lKaVRqMW91WGhnb0N5Q1lHVGp2VzB3bmhhQlVGcEh2UWNxTlFXMmdPQ2VDWS9DZ3Zjd2RIYnZsUVFRTVNhNllhRWV6NS84QTlRT3JNNHQ5T3NPSkpEWEk5ZjhBRVIrUDBvTDNTYmZTT3owK09seUxyN0dkRGF6cHJicGJVWFhFdGN1REorUS9ldks5VG01em83NHhTUjlGMG5UV1ZGRFhKTENSc1VBY1Z6eVl5RzIwS3NXWHpaRWc3b000L3dCMUpNSWpyZW5XenVQbStJUHdvY21Hak9kVDZaRnN4Y2FSTUExU01nSHpici9TUUdZOFQySW12VDlQbm9TVWJNTjFQVEZISzRQZkhGZXZoeUo3T1djS0tMVkFJU1RNZHpYYkIyUWtnQklZTnU0aU1BRDZVNG9Kd0lLbkk5YWUxMksvZyt2L0FQU1A3UTNOYjArNTBuVnZ2dmFVZjIyT1NiZnA4dnlQdFhqK3F3ckhrNUxwL3dDVFpGeVhJK2tBQlFDdkkrOVVJMnRzNTJld3BMTU1kcUwwQkhSYjNIZHdSbWthSFRKS3NuTTdnYzRvY3ZCcUpoQXVTYzVwbTdXZ1VkTEh6QURIQXBLSFBOYkpVU00rOWFrWTQxdG9Ca3lENlVlSnJBTXUyNlFBZSswZDZ6VkJSMjJDZHhPRE9KcFllUXRFclNlWkZBaURIUHpvWHZSbUdqeW5keHRtbWUwMkw1S2JxQUMzRWc0S1R5UFUxMWVuVDRJV1ZXT2RNOE83SGgvNUxJenhYTTdwak43Ry9BRFB1VXd5Z0FEc1BldEcraFpWMmUxTmxrMUd3S1pNR1FNREVVSUs0Mnd2VG9sWnRzc3BkZVNCQU5hT203TjNRMWFzamFkeDNENGQvd0NDakZjdjBNOUhWc2pjUnNIdFdhb3lJRzAyVHo2QVlpazJ1eGtlTm9xNjd3TjJhejBGSHR2bkFnbWZsV1h1Wm5wSHJLeTVCZ2R2V25TK1JXd2R3QW9wR0R3UHBTdElLQ1dsRWhveFZJUlRkc1dUYVZJcnV0YW9hSFJQY0FMdWZLaVRsMjlQYjQwOHFYMkdoQnlaOFo2RzkzcWYycE4zV1hDMTdlekgwR1lnRDBGVnoxancrMDlHQzkxSDMzN05qWWk4QXhqdDJyNXlYWjBtbUJBSG1KQkFBNDl4U1dHaVlmZGlaSXg4YW1sU0NDdmtFUWNrbk5iN0dLUHFIaEFPU09lTTBVQXduMmd0NzJKUWZ2WFRoZE16UG5mV05Kd1lQTmV6Z21RbWpKYXUxTnlESUV3Y2NWNlVIbzUydDdLeTliQ2toQ0NCbWE2b3R0Ykl5VmRBWEgrQk1UM0ZVKzVQeFJZL1pycTc5RzY3b3RjazdMYmp4Vi85bDRZZlNhaG54ZlV4dUlWdlh5ZnBNM1VObHk3cnRnUjZIUFAwcnhYY2xhSWRNaWx6ZmNVQUdESEhiTVVVOUdhMk1oa3RocEpCVWNFMGpsVEdvTllZTVNGYmM4eGlzMzVacThJNnpvVUVaNUJqdEZHdTBnSmtGa24wN3o2VVBHeHErQm0zREtRY25zWTlxRjJ3MVJKcloyRWlKa3hUTjBEc1hlMXVjYlNEUDRpcHRqSUUxdm1WQi9EMXBSanRsZHo1Sm1PeGo2MFZ0Z1kyMXViTEFRWUhGV1QwVGFNOTFWaXQyeklVazI1TXRIK1JxK0dUVU5HY2JZdDludGJhRm9DZG94a2lKd1A5Vkp4MHdTMUpJdk5OZUYyOTRkdG9QSnhtZy9hbTBCYlozVjZnRlE3bG1JMm1GUDVVc1UyaG5waW1rMVlmWDI5dm5EbVJITktvMHFZWDNhTGxXSlprd1NESXpWRlZXRFllMmgySGNTQmtlbmYrZldsazBaSWlMdGxyZ3RsaVdISTRuMWlweWt1eGw4Qkx5a3VCSnozckJvU3VLUTg3VDMrZjFOR01WV2pOdDloYkFVcUdIM2NURk4zcEN2N2cxUm1Oc0JlRDgvOEFtcHNaQjdkb0pheWRvQWtrMGJhV2pWcytZL2JYcjdyZFUyVC9BSEwwcmJCNHQyeDMrSlA4eFZJUitxOTlJN01PT3V6Sy9ZSFRmMUhWTHJxZHhRZ21ZeVNacTM0ZytNRWkyTGJaOTU2TENMYmRsN1NhOEJyeVhMYTN1ZEdVTVdrd0NESFAvRlRwcll4TUZyYlNzd1JFOC96aWxXd3NqYzNRMFNJSE0wM0ZKYUZzb3RlanMzbUJJT1BtUi91dEZhMFlvOWZwR3VBWXhBSlBwVkUwakdYNnAwbmZrcVlIRmRlTEx4WWtrZk92dFBwRjA1T3dIMU5lMTZXZkxzNThpb3k3MnlGM3pJSTRudFhvcCtEbXJ5QXVMZ2tUSHFPQlZDYjBCVlNXSzVPNmpRdmsrMS9aZnJGN1gvWmpRM0RkYmNsb1d5Mk1iTWJqOUJYa1pJTEhOeEk1TGIwYVczckZhMWFDNzl6S0dsaVJpTzUrbGNrWFYyTzQzVkV4cXhkMUFlZHpjbjBIdFJqRjF2b0U1VjBXcVhmQTA3WFdhWVdZSHJXYXQwTGRLeVhqZUJwYkc0QXZnSDJKNW9PUEtXalJmR0kySlBFRUhnUjNpazVVaTFEUGhzeUVFOXArZEJmSmlkcnlpRElQRmE3QTBRYnkzQVR4QkpOSTJNdWdOeEdpU0RFOStLeUNEdFBOMVJ4T01kODFSS3RzVnZ3T09CNEt3UkJiYTNZajRVVzIraFY5ek9kVnVsTDZLRjN3bjNnQjZuMXJyd1c0YVJuVm1jNlRyaHFkT1cwemkxc0cwTGNndG4ycEp4NGUxbTdkajJzMW5oWHZ2N3dFaG1uSk04WTlmU3RCV2lVbHNqb05XTDFoaGZZdGNFbGZOd0QyOXFYSW10SXJGTHRuaGNPbWRMdHZ4Q0JCZzhnZXRLbHliVDdDOUxSb05QMVNVdHVOaElPMGtuYnU5ZjNwR2tyU01rL0lXOTFCcjl1TGJCWUc4VHl4emlvMDA5bE8xb1ZPdjhOZ1RnNVlFSDNpUHBUUmhZazNSWjZmcTFqK210dmZkUmVMYlFnYVNSNi9uVkl3YmxwYUY1cExmWllXZGw4SzRLc0NKa2UvRk9xWGpadXc5cTBxNDUybk9lS1RZU1ZoUnRUYUFBVFA1MU5xbU4ySS9hQnhwZW02aGhKbEFOM3UyUDFwSXQyT2xiUGhIMnZ2RnV1WlllR2JRMkVmUDhjVjZYcG9MaC9VN0lPa1dIL1NsVC9YNnBWT1R0SUhxSXpVL3dBVlZxTERnMVo5cTByYWUxWlVzQURFaVJGZUZKdXFPaGJIOUpxYlRmOEFqYVlqRXo3MU51dERVTjIzM0x5SmpuK2ZQNjBxZndZcWVwZFowbW1KRHZ1YWVBYUtqS1hScUVCMWF4ZVVrQkFNY21uVUdnTVgxZXJzbUdEMndlSW1qR0xNVVBWTmZhSVlTSXJvaERZalo4disxcmg3cnNCaXZZOUtxSTVPakdYMGlJamI2VjdFZWpqYVlCQVM3TEdHSEE5cWRyVmlXUlpJWlFCT1NLQ0EwYjc3QzZnRDdOdmJmN3FhaGtJSG9RQ0I5WnJnOVZIL0FGTEpUOEdrMEdvL3FMSldXa0VoZlNNZjdya2xEaUM3TGZTVzNzTXJNU1FabWVaaitmU2xWUzFZSk1zTE9zZTdxVVI0VlVJbVB3L1N0eFNWL0pOeXQwUzFXclkrQW5lNEdZWmp2QS9XdEdIbjRCeTFSb3RIcUxMaFUzRHhBTWowRmNzNlhaMVJkajRieW1ZazByWTFIbFVFWndwUGNZcWZOWFFlSWJ3ZkRieExpaUFKTW1QclJuMWFNdXlzMUY4aEhrem51ZWEwVnJRWkZmcHI4MzA3ajFIWUNhNm9MVkVaTW5xZXI3TkhoSU8rQUQ3RDhhb3NSTjVESzlWMTE2N2ZSMlVBbFA4QUkrNXJyd3hTaFFidG1INks3bStXbUF2bUhxUkdhcmtqcGxOV2FKYnR5N1pFSGJiQjRQZVRVRkZMdnNpOWpmVGZOZElPTnNzY3dDZTAwazFXMFBGNjJPVzd3TndiVkxNWklJd0IvUDJxVGkvMFE5ak4yNkxRbENwdVJ5Zmp4U0tOOWhiRmJXcWVkNm5jb0pJb1NXcUdTQi8xNVc4VHM0TWM0NC81cDR3cEluTGJDYWJVWEwycVZtVlplNWdBY0NLWjJvMGpLQ2Jzc3JQVUwzVHJndW8zL2pLamFUT1BmNVVtUEh6ZEFuTGpFM1JEbTQ2cUJnam40K3RTakhsc1p1dEhCY0F0RWduZEpFQWRxM0RUSFV0R1YrMmVzWWROSjNNVlc0aDlZRXhQNDArT0NyUUl1NUh4L3JodFg3czNHTXF4Qzl6SC9QNTEyNHJqMGQwSThrN0hmc3ZxbjZick5WZXNnRmxnRVJQZWs5VkQ2a1VtUEQydG15dDljYlZhZHIydTExMnlGOHpXOU5wemVaVjlXSklDL0N2TGxnNHVvcS8xZEYwNzdKZEQ2N2JYVmVMMDdXM3RRRi84bHU5YTJOSGNnVEIrVkxtd05LcHFneGQ5SDBEWGFwcmVnYlZJeDhObDNBK281cnpJUnVYRWRueW5VYWpWOVE2aVdEN1Viejcyd0FDYTloUmhqZ1N0dGxucnJuVHVsYVZHMVo2eGRGeWR0eTJnUkNSSEc3a1ZER3NtV1ZSNGpPa3RtZDFuVW4yNzlCcTd3WC8rM3FWQWI1RVlOZGtNUGlhL1ltMzhBdW10cjlmcU5vVm1XTXNCaW15TEhqUUZiRXZ0TG83aVcyRnc1NzRxbnBwcHZRSnJSaW5TUXdFckVDZHRlekZuRzFZcThxd004Y21PS3JWb2k5SHBJWUVuZ3prVUtzTm1uK3lSZDlOcmRQdUFBdUpkQ25qSUlQNlZ5K29wTk1sa1QwYWEzZjhBQ1ZKT3pZSThoa2oxcmxjTEk5ZEZwMCsrNXRYTGR4bU9KREhKUTkvamlsY1VuYUZiMXNmdFhDL2liR1Y1QWc5L2pScWhIdm9DM1V4ZDF0amNGdFc3UjIrcElBL1d0OUtvdWdwcTBhZnBGN2RyTFcweUd3Y2NuYWYzcmd5eDR4YloxUWUwa2FpMG9WQ3pMTTk2NTR1eXJDb1NsOGdna1lnRWZqU1JqYmVobTlCTDJwVlZoZ0drOGs5cXB4ZjlCYktiVlhiYlc3aEczYzBaSHA3VVlkMGpUV3JLL1VYQWhOdTJwVmlnelBxYTZjS3ZiSVpYU3BBMzBuaGRQVy9jSWJkL2pIcUt1cFg3VUpYa29lcFdFZTVhWjltNDJ4OTVnTzU5VFhYZzFCQmFkcytmOUxCMytISWduSk9JNHFtUm9xelZhYUV1V3RzN1NUN2o0bXVhVzFSTDdqZGxKMDd0ZE9HTEdGTXovRFM3dWtadEJkSVN4R1NubEJFSDFpcHlTVDJGU3ZvQzVDWEdEWElnN2Nqak9CUzNwSklvdmtsWVZXdG1HbFlMTU9PLzVVSk45aFJXV05ROThzcFZWdGJ0d0hFZk9ycUtpcnZaTnZZL290U3FYVXVGZ0FoTWpqK0NvVFgyS1JkRG1tMUZpNTF1Nm12aDlLbHBycnFwaVlVUUorTkJjbEJjTk94R2srL2cxdXM2OG1ucytPR0Ria0RMQmtSSE5RVnQ4WWxWSFZzemRuN1I2clRvNlhyaGF5eWJ3L2RXQU9CN1pIMHJwaGpUSnpiNkd2dEpyTFk2WTYyeXB2WHJZRnNkc2dTeDloUDFpcHc4RklLMmZHOVk4RytTUE9XZ21lTTgvbFhvUjIwZWxTVWRHMS82U2FkZGRxT29GbHQzQnRSQ3JaNW12UDhBeFRKdzRyOVE0WTlzK2syK2pwbytsM2RLZW1lUFp1TERpMUEzVFhrU3pjNUtWbGtxSy9vL1FVUzRicWRNdGFSVUhsTE1XSTk4bm10UE01YWNyQ2FIcmlxUHN3TFNnZVJOdVJGUnhPc2xtYU1sOW1kRVV2Z0paUmpFZ01KeU9LNnZVVFVrS3RHazZ4cC8rNTIxdDZ6cGphallkNmxRZkwyeG5pdVNFdUR1TXFIc3FFK3pseDdoanBhYWUxTWszQmx2MXJvK3ZTM0t4YXRscmYwOXZTYVVqYmJSd09GVUNLa3BYS3d0SHlmN2NYVVY3Z0VacjJQUkt5R1RvK2JzOE0vQm5IUEZlOUZhT0p1aGUrZk9XNU1IRVk0LzVxNkl5ZXRraDV3VkJFeGcxTzZZYXRGMzlsTHlKcXRVbDBaYTBJZ3hCRENaK3RSOVIwbWllUldhTzFkdHVzS3BKVTV4aUs1cFBSeitTejBkcVRLczZnRDdxbXM1cndoSEhRWU8xdTR4Vm1WZ0lraUpvWGV6VlJLMmJmOEFVc0dBeEdlSkZadDFzQzdMM290OFdiOXdPVmlRNm1abVlCcm15cFMwV2k2UG9WcTZqMmd4SUtqT09ENlZ3S05kblRkOUVXdXA5NzE5T2FiU0JzQmZ1STByYklZK3MxblRWSVpmY1MxRXNwVmdGSlBQYXB4VGk2QzNhS2wzWTZwbUpNS01DZWZTdTNFcTB6bnliMk9YbjhYcDRWU0lpYzlvSGVuYXBpeFpudXA3aTluWmUyZjI4Z3huek5uTmQvcDQzQXpuVHJzeC9SdW52Y3QrTWlFbzJRV0lBeGcvalU4bVZKOFdWa2l4TGJuMnZkdERCMmhib1luL0FIU05ydWpSU3FtRU54cmFpMDE2MnBIYVpBUHZBcGs5V1FjUmpkQ2wwdktUZ2VVelNTVmFhQkd4UzVxZHR4a2dPeW5CTTRQNjgxTnh2YTZMUnRJRnJUY3NnTXBZM1dEYm80Mi84Vm9kaGZSSFRsU0dGdktDQVlPTSt0TSs5aXQ2RnJyeGR3OEtCa2RxZElGa3JsNXpxUWJiYldaTmh6engvcWh4MXNaREs2Ni9jMHNGWnN3RVFuTUFkdnpxWDBWeXU5bGxMMjBTNnBxR05temJHQnNBR0tPRmJiRm1scEhOUnJoY2RMVDNRb1MzYVFad01TZVBjbjZVSEdub3BpL0xaaWVxRGZxOVJjc3VOck5nSEJQK3E2c2JwSk03T0w0bTEvNk1hczZmcU91c2lON0JTUGxYbWZqRWVTakw5UzJEVm8rNTZKMmUydmljQVNSNmpGZUlpelJ6VUFNcW9vRDRFeHhXakZNRFlwMTIycWFDMkFSQk80Z2Z6K1RSeHg5d0d5bzZLb1crdTJKbUNBS3BsalpvbXhzM2dXQkFoVEE0ajYvV3VWS2xzZG9WMXQ5UUxoTzBFVHhOYW1Fdy9YZGNGRERkSHNEWFhoaFlzblI4aSsxK3BhNWNZU1RuajByM2ZSeG81Y3JNZHRNU0NKT0NmU0s5ZE00bWpwdC8zRUJKa0VSUEZPcGFFY2JBMlZnZ1Rra2NpT2ZYNVZtQk11ZnN4YXVhajdRMjF0S1dhOWFmZ2prQ1R6OEtqbWFVTitCWnF6Y2pwbW9YY0xkZ2lJNXVMUFB4cmhlU0xYWkhpMDdZenB0SHIwQS8vR0lKSCtJQno5YVhuRitUU2d6emFYcVRmZnMzU283Yll4VmVVZkRJOFdBT2sxd3VFZUVSYlBHNVNZelJiaFhaa042QWFpMWQzTXJiVEJJTnMvdFUyMThoVG8yL1NPclcyMDZwY1J2S0FKaXVMTGlmZ3ZqbjhsaC9XSTFzaG5HMmVEK05SVVd0Rm0wd1RhbXlHM2VJaTUveVBFMHJ0NkdTMVlMVTZ1MlNSdldCRVprMVZWSmlVMGhOTGlLZDBCeTNjOXF1ckVvWDFWMVRhVUVtRE9CZ2NZSHpxbE9oRjJJZFNhMDE2MlljZjJ4aFQ4YTdzRXZZSktPeko2QmphNlpkRnNDUUF1N0dTUkpFODk0cUUxNzdaMHZib3FkUXUzVUtvQkI4cXRIcUJuUDFxeTJyRkxOV0J0S3pFRVJrOHdmWC9ta1JMcG5iQVVYeWdJRDdkeFdlYzl2Mm9OMkZKVUZESUx6U1NBMFJuOUttMHhrT1hEYXVoMkREWTJHQjVIeXBHM1ZHaXRpdHl4dXN1bTBybjdvUHRUWFRzVmJFN2x0ZzhXakJVaWZwVHAvSnVrZXQybUFXNDBoTndYQXpNVm5KUFRHUzhnMlFxMGduSGwyOFluMW9LV3FIOEFydHg5MjBlWWdBQWdjQ1BhbWl0RzhsYmYxRFE2c05vWmljRUgwQTk2Zmo1TFkvQWpldU1BOXpES01BeDNnSDhJb0pKdWp2cHhqYUxiL3A1cmpZKzA2dVR0TnhZK05RL0VjZDRmMEJobDcyajlFOVAxWXYyRVlPVkVjVHpYelRqUjFNNWUxSWJWMnJTbU44NFBjeFFqOHNEUVA3VFg3ZW5zTE4xVmdSTEdPM3BWSWU1NkZNL3dCSDFkdi9BTHJZc2pVS1JkSkFDK3NUVkp4Zkc2TXV6V1d5YlpHNG5BNU1mejFybXBXT1ZYVXRic1J4dUV4Tk5DSUd6NTkxL1c3bWJJNzRyME1PTW0yZk5QdEE3UGZmL3dCaFhzZW5WSE5rZGxJUVBNd1h5aVlrMTNyNE9aNjdPc1FGQkRFd1FTVFRLK2hhVldLbFQ0WllBbVJJTTlvcWhLeDdRdWJXcnMzMVlTamhpZThFR1RVY2l2UVh1SnJVNmhxYmxyWmRlNHlvUU9TNEF4SGY0MXl1RVZzaFRma3RkTDEzVXdGdStHZSs0ckgrcVI0aytqTk9oMjMxaS91SUZxMlJJQmtrNW5pc3NTSk8wR3RkZnVoa216YjJrL2RHS0x4SmlLeC9UOWZ0dW9sR3RNUnhNam5zYW04RER6WmFyMU5WVU5jVnNEQXg2R29mU3NxcHRka202dFliaFF6UkJVeC9PS1Y0Zkk2eTNvUWJxclhXY0MybHRWa3pINUgxcDNoVUtzMGNybFpYV3VzWEJmQ3VpM0VBa21jeDYvalZKWUYrZ1l6YkxPNTFmUldMYWtPR1o1TWJSUHpxYTlQSnZZSGxZaHFPdGI5SXV5MHJOZ2IyVVFQbDNxdjBQdWFPUitTdnU2cThqK1Z5NEluY0NJUGI5SzdjS1Npa2pYYjJaMjNxVXRkT2J4SGtGNVZBWUpIYVBuRlRsRzUxUlYvSUZtZTVmdTNHQUtxSmdkeG4wL09pa2tra0tuWTkwcHlReVBERXpjYjR6eDlJTkpMUXNsZXhnWlo3cURzUGNmalNkYUZUMkZ1RUlxWmhnc2tmbGo5cVRzcFFLOTVkeFNJS3p6M3JMWVpLaHpUM1d2SVd1a0Fsb09SNlZtdVBSTVdEZzNMdTFjYm9FRGpuOTZLUVdnYXdiZ1V0T1pBRVp6NzBXTkZFR0cxbUVzRFBHM2Q5U0tIZ1lXdjduWnBFaWNBeVI3MDhXa0x1eW0xTEphdk9Ob2FCNVFCRXdDSi9HcVUyV3h2V3hDL0l1N1JEV296dFBmMitVVXlvNjFKdEJlazNEcCtxYVM5SkFWbFgzaUFLWDFFZVdOb01IVWt6N24wWFgzRTB0c05PUlh6T1NDTzAxUTB1ajZsbzBXOENyS2Q2T2hocmJkaUQrbGNjWEtNckN6NW45dGRMMWQrb1hOUGZ1LzFDSUJ0dVd3Vng3anNlYTlYMHNzVldpY3JPL1pEcE43U2RSc2F6VTNURmt5RkptS1BxY3FuRnhTRmlxTjlxZXNXN2g4TkdFKzNldk8rbTF0bExLVHE5NTJSaWVJNHEwSXBDdG1MNnN1L2NaUHk5SzdzUWpNSDFmNzdnOG52K3RlbmhPZklVekRkTW5nWi9PdTFNNTJpVjBNUUFzZ0VuZ3hqK1JWRXhHZ0YwZVU0VUFTUFFaaW1pN0pOVU1hV0lpU1I0VUQ0Z0VVbVFlUHdhUFQyTGh0c3daUnZWU1o3NEZjcmttUWR4ME9GTGdUY1kvd0FUS3NJNDdERmJURmJhQzJoY1hJZEdnL2RNNWsrbjRVYkVaMFBjM0FBaEJ5UnU3UlFOUXlMcUJ4bHRvTUdEQk9hRDZNbHNPZXBPYmpNcFlLVGhlTWRxUlEwa0Y5MkhzYXgydU1HVWpKTzQvd0ErUDByUEg1RlVxZERTdGNYU09qSUFZM0dWR1JNeFBiaWxhWEpNWmRVaExVcXdWUUNGSjI0R1o1SXA0dE4yTlRvSGV0dGFLdVNOL3dCNEFmbWExMkdnMXAwWFRCV01nd0IzRTRuNTBFMkZ4K0J2VWFVM1VzTmJzSTgyeEpadHBCazlwcThHNkdTUml0SnB2TlpWakxlaCt2NjBNayt4MGhsaWlHNHNnbTROZ0VuMU5CWG9CWjZDMkxZRE5PNHFjOXNnUlUyN0JMb0lRa2dLMDdaSjI1SnBOaXFKeUd1TnV1TXlpUUROQzB1aXFUWVZrUzd1YVJ0bUQ2eDhhV09sUUpXMkJOMnhhdHh1WDF3UDU2MVRiRW9oNGl1eTVVOGVVNS80cmJHMFNhNjlvaUZZcUdrbVRCNStWRHNaZklHNDRJM2I0Sjd6dFA2VU5tMEJaRGMrL09PVEh2OEFoVHAwSmRDWFVMUnUzR0xEemJCZ0NPWno2VTBYUmJGOGxjUXFvMXpBQXprVEppZjFvemQ2TzdHdUtzVXVPckk3cVFQL0FGQTdmeUtxbDRGbTkyZll2c1AxR3oxSHBkdmN3TEtvVmgzcjV6MWVKNDhqUjF3bHlqWnJOSjB2cUcrL3FOSjFadFBiZ2VYd2c0UDdWd3VjWHB4c1pkaTNXTkoxTzlhQS9yOUErSlo4cVQ4UVIrdEhIT0VYMHgyclJtSDB2VW11K0YvVzJrM2QxV2E3VlBIVjBTYVpmOUg2ZW1qdEFYTHozN21TMTE0QlB3QTRybm5OemQ5RzBnZlY3MXRVZ0hBb3dURlpodXE2akZ3N2lUZ1Y2R0tJa21ZanFUYjNZbVluMDdWNldMUnp6S3NMREZjRXR4TmRmZ2d6dHhJamFZVWQrOC96OUtaUDVGYStCVjJHNWlHbWNqeXgvTzFVaVRleDNUS0VjQU1RdXpnanZ1cEp1MEdKcE9tQVBvaHVrT0JCSHFZSDgvU3VXYjJSa3Rzc1ZGdTR4RnZZQUlFS3UzSUh4eng2MGlkTVdTMXNrTFpWWmRXbUJnWStPYWV4RzluVXRBWEZZcVZKYVNCalB6ck5HVWdscTBCczNUZ0VlVVV0TXpZell0Mi9FRzN5cVFKeE5ZUjlEMXMyMEhCWnBuSTcxT1VXMk9wSkVOUnFGY0ZTNmduSVJTU1RXakg1R3R2b1ExRjI1ZFlLakJSdDJ3Ty9wSjd6N1ZTS29QYm9HaUt2aHhkTjF1U1o5Nnp0b2RhME9hYTRSYUhob1FoeElYekNUblB1YUtRTDJFMWxxNExpUUZjYkJrblBGV2owQkdRMDk5bEtGOGtHRmIwZ2Z0U1pJMnRGWTZleGdwdnVMZU1BMjRZaWVCL0RVK2JXak9KWmk0V0ZvdEpEQXJMQW1NZ1Q4ZWZwUWFNaWZoM0NGOE9BeE82V1hiamdjWit0SmZ5RUlUZlZnZHdJakJFL3RTcWdnRGN1TnVtWDc3ZVZCOThVZWpVUVRlWGpNQVRDQ1AwbzY4aXRmQjd3bHVKSTVrUlBINVUyaFhZWmRKY0JUeUZkMHNNaUQ2RWNWbTY3RjVXRVhUM1F4VUlXNzU3L0FFcExSa3dsdXhlMnB0UzRESXp0L2swRzFzYnNyK3A2ZThtc1lFZVZnckZvaU1IL0FIV1VsUjBZbGFNM3J2RXQzQ0lEQTRqdFhUR3BLenBVdFVoTzJzaEF4aFR3U1BsbW51bVo3MFdmUU9yWCtqYXNPai8ybUkzcUQrTlE5UmdXZU8rd3duOU4wZmNmc2gxcTExYlJnMnJnTXhLazVCbml2bXMrSjQ1VkpIWW5hdEZ4ci9zbloxbDN4ZkZZRTloTVZHT2VVTklOV1VtbzZQYTBXOVE4c0k0NzFkWlhJV2hOcm9zQWt0R09LWkt3R2E2eDFRc1NBd3p6TmRXTEVJMlpqVTN5NHVGak9NR3UzSEdpY2pOYTE5N3d2bWl1M0VuMlFteFRjVjNRTzBaTUdmWDhxNlNUQnVXQklVa1FaejZVeUVlOUFHVXlNZ1lIZWFhTEVhb3NOT0g4WWNOQ24yeUo1K2xKTG9aTFpyT2lxTGxsaXRzbTRTdTJmbm11R2JwMVl1VlU3R3JhWEJkWlhBeXZCSk1EdHpXYlZFbHNidGFja1FHQUlreUppUDRQU3M4bkhZbkc5SExxc2did3lJM2hGOVd4azVHSzBjamJxak9JRkxqeUF3RThZaU9PeHFuZXhYclFUZTZ5RHVCN2pFOGVrVWRnMEN2WEx6RUtkMlJpWnorc1VHRkpJN1pSZ3BreWVKNG4yb1dtTTlEZW5zczEzYmN6Z0FDUmdUVElVaGVBSDNpU3hNUjYwdTdLYURXcmdXeDkzc0RqQTU5cUxzV3RndFk5NXIyTCttdGJWQUszTG0wOGVucFhSaTNHeG1qSEw1N2RzSGtFbjhxelZGYkxDejU3S3F4bG5kVmppZXhOYzB0T3cyU3QyN3pBZ041SWI1bnZCOXVhUE5hRkM5TmU3Y3VpM2RoaWtuZU05aElKNzhpaEpLckF5MWNrOFREazdaR0NKN2ZPazZNbXhNV2RyTEpCTXhKUHYzSDdWbTlES1d5Q01RNnI1bUVUbmlSN1VhTlpKSjN3QkhjbUlJajhoQi9HZ0N3N1BkRFc5cjk4YndKQjd4bmltWFF1aG0xWjFIK0xvRkp3ZDRJaWZhbGFpQnNidDZQV21HUzd0eVpnSDE3MGphUVV4SDdRMkx0aDdGNjZ5a01qSWNSa2NEOFQ5S0VObDhVKzBaSytRVkZ4OXZsOHhIOCtOZEsrRWRjVnF4WVhWM0lIRUNOdnVlNU5iaS9CVG1udGk1dXExOWpHVEoyL0txcUxTb2hPU2JzdXZzejF6VWRINmdsL1RzZHN3eTlpSzVmVWVtV2VOUHNmSGw0UDdIMmpRZmI3U2FqUkIvRkN2R1ZQcFh6MlQwT1NFcWFPeFRqSldpbzZsOXFMRndzVUpaamdFZXRWaDZhWGtWeVJsTmYxYTllY3FaQ2pBZzEyUndLSW5PeW8xTjRBN3JqRDJFek5Yakg0RWNxN0t5L3FtdllWZktBZU9hNllZK08yU2xPOUlydFJaWkN4Y2RvaitmS3JSbGVrVGZ5eFFoemNQYVJFOFZWTkNIa0VxcXZJd1R1R0p4M3B1aFFKZ092bDNCY2tSNlU4UkpNWXRraDAyNWtIbmlsa3RHVDJhWG9GMmJsK0F4OE5nUUp4d1pKcm1uRW5ta1hSdjIxU2Q2bWVGR1IzL0hpcE5OdlFrUjFkWUh0QklZWkM0TUFtUFdsK2lCNWV3R3BOdTU0WWtrWXdSajQwMFkxMkk1MjlFTHBRV2k1Sm00M3JCeC9CaW1UYTBOVmtoZFcyUVBFRnZkMkdlM3c1cHViYTBUZU4yQ3YzTDF1U3BVQWlaVWtjbnVhMTMyTW90QmRNenNSNWo0Z3lETXdJOVRRdEdwaHJHbXUzR3ViZnZEa2tqNlUxL0pyQTNiRjFDcXR0SHdCWWZsUlRUUXlHTElLV1VnRU1SSjNBTFNQb3BxeXYxT21EYWk1NDkrSEIvd0FVa0VSWFJqbDdVWjltYXNBQ0Jrd1NSUEJ6VFNITEN4Y1ZHRW1kcDNFQTRBbi9BSnJtbEZzRmtkVHFIYlUyYlZ1NEZSQnRFQ09abXRqeHFtNUNONzBNSFRsUERaTG9STGczTm5udkFIeW9YWlJhUmFXd0xxaUNGS3BBYmZFNS93QlVpVnVnTjByT25UbmF6UGVRYy9lWVIrRlB4Sjh3YWRQRDVWd1JJT0o5UGF0VE01aGwwVmhFQWE2d2pBOHA3L2xRcVFPUTE0R25hOG5oM3JpdWlxckJURTh3WUFNVXNZdUtvTG55Mk8yK21XaExpN2ZMazRIRS9oU3ljazZmUUZUV3V4cEVXeGFDaDM1amFXTW1rYXZiQ3I4RmI5cGJTYWpwOXp6UzZFT01jUWN4UHROR0ZwM1pURzZhTUJyOXlYeUxiRFlWT0Q4YTZvSzFiTzFTclFnVlVFczZ5eWlKNFBOTTc2UTZhN0JQWkpJZFREQ25VaWJRU3p1R3dxY1NDZldsRkxMcGZpM3RUYXRLMGVJUXBBNS9rMUxLMG90dndORDgyaTh2ZFAxdGdsWEpNZTJlVFhISExDUmRxU0VyeVgxQ28yRE9hcXVJbHNXT21kbWlKTXprMC8xRWtMeHNQYTBwTFd3b0pKbkErQnBIa0R4T3QwMW5BYTRTT2NjVXYxYTZOeEtYcU5vV204bzQvR3VuSE8reEpSK0JGanNWb0lLOWoySkZkSzdKUG9FQkp0eXk0T1J6bitSVEprbWcyVkZ0cHh4bnR4KzlEdXdseDBFMy9FY0xMS2ZNUUl5ZlhOSmthb2hrVk8yYUR3N2wwQnJuaGdLWWdpSWo0Vnk4a0xkYUdiZmxJMjNXbWNuWUJuMnpUTVI3Slg3SUtxMXk2NzNDQkFnNGc4MGl5Ykc0MTJLc25tUU1uSlBJbjB4azhVNmQ5REw3blZ1b0dEZ3N0NVpDam5IcVQ2bWMxcThCc0JnZ0FsUjdHVHVQT2YycGcySHRKNFZ0TnpEWUR1bWZldGRnYUg3V3BHRGFaaXgvK2d0TExRa1lQNUMydFkxNjQ2YWh3QUJqd3dEOHA3MFV0ZTBMVFFhNEowelBhQWR5SUNGWU0wWk9sY21hQ2JkVVVtdk9vL3FtOE84cXJBZ0JmWVZiRnVOMFVsR25SUld3bmlKOTVwSkVBeE5PMzJPNlMwT214Y1dEZFZrM0dEakp5WnFEYThDOWtOUllZTWx4Q3pLWmtBWnh6V2kvREZZZTJseldHMERiQVVEQSs2QU9PVFM2aU1XbW4wM2hvaUpiVWdmNVhHVnVjNGdlMVRidDJGUFE5cDlJbXdOY1pGUHFwL1dLTHlVU3F3bG5UYWFWQVZEbkpaekp4U3ZJMkhpTXJhdEprVzdlN25rbjgrYTNKaTBIdk82Mm1heWNnU0J0akh4b3VxQkZib01seHZFbFgzWW1RWkhGQnhjaldva0hZSGFyTnVZTndjeG5uaXB2UThkN0ZkVmNDcVo4cGdqREg5UlFpMjJOU01EMXhBdXYxUzJqNUYyL0FTc3g4TWZpSzY4YjlxT3pIdFd4SzRWZFFFVWlDQVdQY25qNlpySmZjNkhKZkF2Zkc0bUQ0WS85UjJBRk5GMFR5ZGhBQUdBRVFmZjQwTEpqM1RiaHM2cTFjRTdsY01QZ0NQMk5TeUs0dUkwWFRQc09vNmFtcDA0dnFaM0RkSXJ3WXpjZEhWMlozcVBTQ1hZUVF2OEFyL2RYajZnSEVyQjBvcXdDaGlSd1kvT3EvWEJ4R2RMb2lHQVlUMnllS25MS054RGF2cDROb1lNNGlKelNyTHNGR002M3BTbDE1RUFNRkF5Sk5laGd5Q3lqb3o5NEY0Umo1cDVPSzdvUHljOGxxZ0VsazUrNklPZmVyTFJGN0QzUVYybmJoUnVJOUJTUmRoa3FHK2g2eGJkMjVhWWZlVWhXaklJN1Zzc0xwa1o3V2pZYWEwbDVMWlpyWUxBVG5QcE5jamtvdDBTY1d5MXRhRFNpMFd1YWtwT0JzWVovT29TelNrNmlob3c0N1lLM29WTHJGKzZFVWtrVG1QUTFUdEM4Nlo2NTA0UGMvdEYzVVFBSm5IdWFaV2xVdklybmZRYS9vYmlNRnZJQjNBSm5IeXJSYWx0TU4xMmppOUlYZnVET3dBeHQ3NW9QTFdySGpiOERscm9EUGF3Z1ZleHUrWCtHdWQrcTQ5c3FzVGw0RnRiMHhySklSRVFHQUR2Vml4NTlmYXFRemNxYjJaNDZ0QXRGcEQ0bzh5cEJCTEZ2d3JwK29xSk9ObHBwQXhueFhCRnJNamowL2V1WE5QVkl0aWpUc3p1dVYzdkJ5NUJjYmpKR2ZldTZEcFVDUzJVbWx0VGQzTW9Kd1NEMitud3FrNUNGelpzbTgyOVhVTndJQkVZOXFpeFc2RExaREFCcm9nTkpnR1BwUjRFM09tTVdMS01OdStmbDc4NXBlSnViRFdOSnBtWGRldUVCVDVpb0pIN1VzMDEwTkdkNk82bTFPbFk2ZG10Z3hzUGY0bjhvcmllZHQwanFoaFMvTUtYOVU5alZXa3ZQQ1hOeGp3dHhFQUFmalA0VlNFK2FzRXNTUzBMV2IrcGRIdjI3amhaYmNIems1VXg2OFlvdWZGMThqZlRUU0dOTDF1eGYweHM2bFFOWkxMOTJBMmVRVHh5S3RUZWtTV0ZxVnA2R2IrdlMxYThVcmIySXZtTE9BUVFPQmlUVWZxU3ZpbHNiNkM4c0hxT3JhZjhBb3pmUU81VXl5SHk3U0FHSUpuNVlwN2xkQ3JGc1IxUFZMZDdVV2RScHc1dEtDcHRreEhyT2NVcjVLV3dxR3FNcnI5VDQzVU5ZNEJDM0xrWk9jRGtWMndoN1kzMmRFSHhYRVNhN2MzYldrN25WdWU2aU9hTGpYUlRsWjVDR0l3Y2pBaWFGVUNUc2JzV1h1YlJ3Rkl6OGpVM0toYU5CMGJvdDdWdXZsY1d6UG1qbXVQTm5VU3NZSDFib3l1bWl0V0xnTEZCRTk0QXhYalpIYmJSZElZMWVpRnhRUE1RUmtmQ2tVZzBWYmRMTXFOdlBJOUtmNmhxR0xQVGZERzVoR1k5NlZ6WnFCNnpRL3dENHBhSWpuSjVuODZYbnNLUmhQdGRvb0JkVkl1S04zRUE5Z1B6cjBQU1pOMHpTV2pFYWl5YnNoUkx4NmZHdll4eW81cExrZ2JhYUxMa0lRY2MvSW1uamt0azVRcEJlcld2RHMyR0JNc2drZnArTkxnYmNtZ1pFbEZNcC93QzVidWJobGdDOHllMmE3R2xKVXptMmk0c2F5ODEyRWVRNmo3cm1PUHo1K2xjempTQTRvdDdENnQwWCs2QjZRMHhtdWVYRmJFYThEdlNkVnFYdjNkTkpDcUN6WmdjL25TVGFpbE1mZzVQaVdXcCswTnV6cDQwRmd1TXJGekRicGlTUjJvS0VwU3VRaVZhRGRGNm5aNmhlTjNYSXdkUkVBa2lKNXBNOFp3anh4dWlrRXVWeVZtdHVXcll0a3BkdWJ6dElXVG45cThuSEtYS25zN212YnJSVmFvQmRPTDEwWGJvSkNxcHVDWitIcFhiQksrS2FYOUNFbTZ0cGdOSnBGc2g3MXlKQ3p0bkFCNC9XbnlaSEpxS0ZpcTJKYWdzdThrRkVKMmhSMzdUWFpqVm9Sa2RQZXVKcDNzMnJhdE1xWi94R1JqOGFNNEp0Tm1pNjBpT3JNYXE3NFpKU2ZLVllqRWUxVnhwOFFTcXlySXQyMVY1eVZBSW52U0tjbkttV25pWEcxMk9hVzhIVmRwU0J6T09menF1emlrcVllNS9hWGM2VzhOQXo3VXlra215YmkyNlJIU2FxMG5pK0paWFlJaGgvdjQwa3NrYm9iNk1xc2JWUmM4cE95MlNTRWlTUU9KOXU5ZWZuelNiYVhSMlljQ2lrMzJBMStyaVFEaFZoUURCK05SZ2pvVWE3Rk5JUEZ2c3hnWGJtTndJbmovZFVrNlZlRUNpV251enBybGw0Rzh0bmp0ejlhTW83c1V6bDFyZi9BSFc4WEFhVTJnRThmQ3UxWDlOVUw1WUsxcXd0bTJOUWJsM2JKSUxrRlNQNXhUU2kyN2lJdXRqZHNlTHByNkt6YlEzenpJL1kxTisyU2JNMVlqNHo2YTg1WWJsQTgwLy9BTGY1K05WY09hbzE3SzNlMXlTNWtzb2ZIcWVmMXJva3FROEZiSldrM3NycmdCWWs0Sk04ZlFVa25XaXFwN0xEcDJqZTR3VkZMRnNBQVNjbmlvWmNxajJ4bEcramU5Qit5YklGdTYyeTVMQ1Z0Q0k1SE5lUm05ZHk5c0dWV091ejZOMFRwVm5USXJYRVZZNXJ6cFpISmxLTGg5QUxUbll2bEk3anZQRlNsTUtRRzdwSDMrVUJoR0R4M29SbXpOSTZ1aExrRXJqdG1qekFHL29rQkJLZ25tU0RuK2V0WnN3bGYwcWkyd2NvdVpsdnhKL0dsYnRqR0orMkdpVCttVWdoQUZLcUo1bU01T2NWMWVubjdyQ2ZMdFZhVmRZZ3R1TmdsdysyTWl2ZWhMMld5RFh1cEV2Qi93RDBacnJuemxvSWtEdkg2VVZML1ZwZkFrdnlPeEhyTnNTbHNISUluTTl2OTFmQkx0a2NuU1JXc2tYVjNmOEFxM001eC91dXJsb2pRYnB1MFhDcnNCYmI3ckV3QVIycE1uMkJ4MFh0bnB0Mjl0OEM5YWNHSi91QVpCNGlaL0N1WnlTL01oV24waTMwWFFMOTlIUjNLdDZnalByenhVbmxTNkZjZmtzcmYyVC9BTFFYKzhXQWdHUUJTUE8reGRXUDlQOEFzcGNzQmQyMHFveVRjaVI3MXo1ZlZYNUw0OGJmZzBPc0ZyVGFlMnVxdnNVaUZXMDI3SEZjZU9MY3JpWGsrS3A2TTN2ZDlWZXZGQ0xRVnRrbVRBL2V1eWtvcElpK3crbHZCYkJlNGQ5eTVMRUVTdnArRkZ3dVd1alhvcTljL2lYSnR5eWJnQUo1QUFydHdyaXRrcE85aGVsb2x0QTEwZ2JuSU1qdDIvV2x6eWJlaDRMNUszWDN5YndDRlNBdmNBKy82MTFZb0p4MlRuSnA2QklvdUlqRlZJMnJQdVJBcmttNmsvNm5wNDY0cE1tOWxOenVtR0pBQkhGQlpaS2pUd3dsWUs3ckxqb2ZHUkcybFIzQjlmV3FLWGNmazVKZW5TYWtuMFM2WUdmVDdibHNOdU1RQjI1L01pa3pOUmRwZ2hDeTBjZ0JGQUpNR2Y1NjRyaFc5czYrS2lEZlIrSmQ4TXRMT1JFa0FEMzloM284NlYwTFh5RjBuVDAwNjNXc2xlUjUrRkU4UU9UeFN6eU9UU2tDdmdSMTdXazBqZUN1M2FDVDN3SS9jRTFiSGJsc1Zxa1p3V3AxUTVLUUdNZXhydWNxaVNvRjF4VGIxTzdhTWlIOXp5VC9BRDBvK25keG9XZnlNNllrZE91Sk1Cbmt3ZTIyTS9XbG4rZXhrclJVZFJWcllBYklZczNNVG11bkMxSnRvVnhhV3hlM0kyZ2Nxb21UanZWSmpRK3c5bzdUdjVCa0tUTWRxNThyVU5uUkJONlBwMy9UM29sdStodm1GWW1GQkhhYStmOEFYWjI1Y1VkVVlxS1BxdWc2YXFoZHdCN21SSnJ6d1BaYnBwUnRCQTh3TWcrbjFwRS9KcUNmMDRlMHJBRUJSZ0tZSHlGSmRqZEFidW4yM0pZQUN0MFluYnRiU3BWV2ovMmpCemltVEJSRy9iaGdBdVJuK0dnM3N5UlQ2NEJWWUtPWjRHZjV6UVlhUG5uMjhWcmVrOFFtTjFzSURIM1NUa2ZTTTEzZWthZVJJTFh0Wjg0MWVuRnU0dmpobUNramFCOE1mOFY3TUoycWlUY2EydzJzdXAvMnpUYlZnazhEdDVqRS9XaGppK2JFeVBSbnVwM2kycklrR1dNWTlJSDZWNkdHTlJPWEkvZFFKb1BtUEFVS01keUtkTUZhQnZiT3hTVjJxNWtDT0tkU1ZtYTBXdlRkY0FOcG0yd0FuTVNmWCtldGMrVEcreWJqUnBPbGRXMU5oMlJMbHp6S3luY3h6TmNPVEdwS3dYVHBIMGpUNnkxYzB0cHJLUzVVQm5WU1F4ajFyem5Gc3JhaXdYVUxPc2FMaVc5c0NRQ0lWdmpSaW82NUR1VjlGZGRTNGJJOE5BMnpKSkV3ZmpUcVVlVnRpT0xxcUZiMDdTaFJWVUFmZVdOeG5zYW9uVzBMWHlBVFMzcjYzRXRnTUNHVUFDSXoycm8rcEdGTmljVytqaWRPS050TnRuYmNJRWMvRDhhcjlkUGFZRkJpUVZYdldGWUlxV3d6bkU4a1lwL0RhOGhTdlRGTlJiTjBwZElBOFFGdkw2RmpFMTF3MUZKRXBiZHNoWmJaMDNURTVJU1pHQ0FTZjJGY00wM2xsK3A2RWVrendaelpEUUFtN1BmanRTU1NVcThsVTliTzJkT2o2ZTd1KzRxcnRVUnlRS1NVM0dXdnYva1dLdTdPOUpkUmNTMllDTXdVSDB4M281azJnSlU3UmNMb28xTEJ3UUZXWTQzNTRybCtwclJtRHRhTkJxYmNNeExBU000RTUrdGFXUjhXbUtsYlBYVWZUbS9iRnpjQTI2Q0lnUkVmS2xUVXFZOUdmdTJRVXVMZWJoaXVUOTRHRCtsZGNaOU5JV1Vma1ZGbEh2SWlCazJuYXpnVGptUGpWZVRVVzNzbkt2QkhxRmszYmUyNS93Q1JwYVNlUGVqam54ZGdjTFZBeGJ0NmZUM0ZEZVVBTnZZUjNINFUxeW5LMEdNRkZHZDExOWI5NG0yWlJUdEJubWUvNTE2R0dEaEhmWkdjbEo2Nko2ZTA3dW9FU1FCanRtaE9haXJLWTQzbzFIUjlDelhQRFRDa1E3eFBQclhsZXB6YXRuZmpoV2tmY1BzYjA1TEdpVUw5MHFOb0g3K3RmUFpKOHBXeDU5MGJDelloZ3dZVEVUM0dhbllnNnFvQkVqMHJQUmdMczdFcW94bmtjVXR2d0VFNmYzZ1dHQ0lCTksrd29PdHZiT0pIeHFpRkZOUnpFOGRvRUUwSDJFcCtxS05vamFJTW4vaXNqSHp2N1phbGJkdDB1Z05iSzdlQkpKRTkvWVYxK21nM0swT3Z1Zk5yOTk3bWt0NUxYQVRBeks0OWE5dU1FcFA0Sk42STZvaTMwcXlDMjQyb0JpQjNCL2FuZ3JtMlJuMFplNDM5NGtTU3BnNTU1TmVrbyswNDc5dzdwZE85NXRnTUlKTWs0SmlwVG1vbFlLMFdlcjZWZThnVmZMdEFFc2Z3eDdWQ0hxRVVsRHdWdXEwMXpTWGhkWUxFOEF6ajBycGhOVFZJbE9MVHRsdDBiV0pjdmkzRzhHQkJhUHo0cm05UmphVmlSajQ3TmgwL1czMks2V3lFbEpNM0xoS0xIZWVENlY1OG8wcnNQdGI5MnkzMEdxMWQ0WFh0RFNsUVFGVVd4NXZYT2FtMjZXek9NTDZIanF0U21sdWFzM3RNcEMrUzBiWG1PZUpqNTFCcFNhVEtKS1BRcHB0WnF0ZFpMdDRTbnVSYUhQYVQ2VlJ3aGpkSUNjcExZVjlYYXNGbHRseXFEejN5ZHFnKzFWampsT244K0JlU3VoTysycGZVM1dScnBsU0VFbkErSHdtdWlDZ283RWxmZ3I5V2xzRHdTVlMycDJrem01TWZ0K0ZXaTNkZ1MwVit1L3BBMXJmY0VsQVlDa2daT0JWTWYxR3RJRXVLZllEUm9VMHRvM0JBYTNodlgrQ3BaSGMzWHlkMFZVRURlL2NXMDZXd1ZFQlJnWk9jUlJhVGRzRWs2cEhVdkphMHpxVEo1QWpzQlVwUmJrWk1UMDE0TlpjRXpsVzQvQVZlVWFGVWpYMnV0THFOWnBMTjlFRm00cTIzTEVncTBaYWZjL25YbHo5TTRxVW85b3BwS2k0YXhidUZydGtBRXdKTENPYzUvd0NlSzVJdHJUQmFFTDJtVlhmZGNUYXhBSjNjOW9xaWJhQTVVVWZVOU9CZDhRTTExRllNQkhjbkVEMnJveFMxUUpPeEN5eXU4c0d6UGxiZ2VzZTlkRXZhaFlwdGluV2I2V3RyRWhWVWd6NjFUQkNVM1NIbFVOc3lXdjFWM1c2aDRaaGFhUEw2a2ppdlh4WW80b280NXpjM1NCV2tDRmh0bHVCNkF6aWkzZXpKVWFqN01kT09wdUFsZHpQZ0NmbC92NVY1bnJjM0hSMzRJNnMrZzZEb2x6VVBhWFRLYmwxMkJkemdNUEwzNEg2VjRXVE51bWRrYVN0bjF6cFdqTnExSUFPU3hJSmpPZjU4Njg2L0JON0xheUJNR1Juc2VlOU1tS0dJRzdibHZlZnJUVUFFNnM4UUJqbjFvVWF3WnRsWEFnZkhrNHJTV2tGQlhJMmtNSVBFMXJNSWFsV1VFZzhkeldmWmtVdlVGWWFkOXdKQjRIT0t4ajVuOXNRRHJWSlZXWVc4WmtLYyt1T0s3UFM5RkRFYXNxQ0xWdEcyTTRiempQcWE5VEZiMjJKazBoWFZMZDFXbS9wN0s4M0NTeE1BY1NTZTNGZEVHb1M1U1p5U3VTcEV1bmZaYTZWWnZDdTNTL21BVHlpSi93RGMvcFJ5K3VqMG5YOCtCWTRHaSswM1NkWnBnV3MyZEJvVVV4bTRDd2ozcmpubmhON2JrV1VHdXRDM1VPbklxZUxxdXBCM01EeVdpMFQ3azhmS3F3elA4c1lnY2ZMWm50ZnBkR2R6TDFKOFo4MW9mcFhmaXlaRS93QW45eUUwbXV5a0ZxNWJ1SHdXRndxSWxEQng3VjJXbXZkb2lydlJkOUs2KzloZ3Q2YmIvZDhVWXg2TURYSm05RmZ1aCszK3c4Y3FlcG11MG4yZ3ZJUW90NkZnQ0JHMWJaSUl3TUNQd3J6M2pyV3lrc2NYdG1pNlQxN1Q2bHlyNkN4WUluYUZkV244cy9XcHl4cGJmK0JIaWZnc0RydEdxbFhzbGhKWUtFMnlQWG1rVUxkeEFrMnRzZDB1dDZiZTA0ZXdWWkd3eXNrZ2ZMMm9TeHlYNXRNMjQ5YlFkLzZOTGJ1alc5cE80RVlrZTN3cVhDWFZsT2E3YUtQcWZUZjZrK0lpcGN3R1VvWm5ITS9QRmRHUEk4V25venFhMFp2VzlJMS9qWlJGd01OR0s5UEJueDhEbW5pbGZSU2FHYmlXa1lLVHM1UElFMXN5cVRaMjQzY1VXRjIzYkNxcWt1QU1rMXljbjJ5bkVnK2pGNnlUa0ZGSThvZ2ZQOHFYNmppeFZGUG9DdG16WVprdCtINGhqM2tZeEFwK2NwYjhBVUFHdFZuT3hBb0lJRWp1Uk5VaEt0c3pqZlEzMHU1ZjBPMXJWMDJtQXozWG5NanZ4UzVZeHlPbWpWbzBuOVpidlcwMUYwQ2JpQWhkcEpXZTVqNTE1anh5akp4WGo5QnExWXRhMDQxS2thYTViMmtIYXluak9SN2MwSE53ZnVHY1V5dDZuWS9vOU85eThOaXFobVRuako5dmpYUmlsOVNTVVFVbzdaOCs2aHE3dXMxUGlGdkp3bWUzcjhUWDBPRERISEdrY0dYSzVNamJVQW5hVkcwY2pqNEQ2VVpNV0tPQkRjdkxiUXpKNDk2VnVseVk2VnVrZldmc0QwMUh0aHd3QUkyU0lrKzN0WHpYcjhyYm85UEdxUjlZNlQwNVZ1TjRWbndiWVVTZXpONjU3OFRYanlsc2R2V3pSVzdRVmlvQmpjZHN3Ty9yU0w0RVpOb0RBZ25uNzFNQWx1a1JqMXB6QmtDa2drU3dCSUhyVEFPUGFnbm41bWc0bVRJbFZMREdENm4zL3dDS05Jd3JxTGZsd1FEbm4ycWJRVVp2cWwxaXA4UW5hQVlraWFDYm9aSStZZmFIeE5UcWhkTFNqeTYybGZid1lFL0tLOUQwOVJWRHZSbXJ2VEV0a1hOUmNaR01CeUJJQUhZSHR6OGE5R09WOVJPZWRQc3R1bWFkMmMydW5kTlozVVNITnVRbzdTVGdUOEtoa2w1bkkybDBYN2FKa3RlSjFqcUNXUzRNb0dEdU84Q09LNXVTdW9JT3l2MS9WdWhhUzk0ZG0yTGpMeXhnczJjK3BxOE1PV2FzVzBpZzZoOXJkeWthUHArblFIQWQ0WmhqNW11Mkhvci9BRFNKdWFYUm5PbzllMWwyMll2V2h1UFpUR1I4SzdjWHBZSjdSR2VSK0RPM3Jsd3NRNVI4VEl3U2MvRDFyMEl4Unp0c2dnR29TQVNHbnYzTVZSKzNhRi9OcGp2VHRUc2RiT3BLcXNnQmlUNVI2SDhLaG14MnVjU3VPZGUxbWpSME5rRFRxQTB5V2ptY2ZTdUt0KzQ2bEhXaGtkVnZJaFc0VWM3dVhCUHAvSW93eHBQUktjV3k2NmEycTE2RzMwNHA0WVA5eGJSQWFQaFVjbkdMdkoyVGtwVjlqUS8wR3JZaTNkZTNiSVhZekV6QWpqOHE1clMya0NUVDBoeitrU3hpNWRaMFhhQnhBVWZPcCs5OUlmbEI5aW12V3l1b0t4ZU1Ec1ovV3VyMC9KdzkxRThuMDc4bUE2WXFobEp5U3B3VEE1aXUzMURkMGRXQ3VObHBkQXRTUXhCNUovQ0I5YTRHK1JjSC9Wc0ZJWHpQenh4aWg5TmVRT1RSMjFabHdidUhIbTNPSWc4UUtEbDRSbEYxYkdidGt0WkxXY3dCSlplTzArM0hhazVXNllYb2haMFJKWHlFamJJQjhxL3ptbWxsUzhpL2NiVFNhblVFalpkYVFKVzJwQWowOUJYTzhrSXROTmYxRGZ5aHpTZE1mUjNoY3V4cHJZRzFVL3lZOXlmMnFNc3ltdUs5ekRUWmt2dDcxbE5VdzBPbVlzdHVONUhId252WHJmaHZwSlkxOVNhT2ZQa1g1VVlwaVg4NVlTeDQ0aXZZT0w3akxBaTB6TGhSZ0dNVkc3ZEZFdFdHNlpaSnZXMlk3Ukc3NENhbG1scHBGY1NwMno2UjlqdXBucDJzc2pVUzFnZzdoLzZmL1VWNFByTVAxRnlqMmQwSFh0UHVYUytvYWJWYVZYUjBJZjhBeVU0L0t2QmxGeGREMlhFN3JSWnRvekRmd1VYOG9VUmE0Vk93U1dMVEh0NlZTTzBnTmpta1JuSUV3VDVvOXZiOEtEN01QcjkxR1dEaWVmMy9BSHFuZXhTYklNakE1R0p4VE5BVEFNaXFRRHRERWNlMUxRYkZ0VHMyUXZmamlsYTJNaktkZGUzYWtFejVjZWJqMG1rVUhKME5kSHp2ck9vUVhkdWxGdTVlSXpkSkFBSHhuQW50OWE5SERqcGJFbE95alM5b05JVGUxRnczbjdLRmhaN2tmbGdWMU9PU1M0eEV2ZHNSNnI5dWI4UGIwMEJZQVVBa0tCOEt0aC9Eazl5RWxsU014cmVvYS9XM0RjdjNIOEVnd3pFSW8rdk5kOGNHUEhwTGY3ay9xU2tWalhIQjJycWtVN3A4aVNQcWYycnBqRmQ4U1RrL2tycmwyVE42ODd6aFJ2eitGZENqOElpNWZMQU02bVNIdURpT1RPQ2FwVEU1TDVKSThzcDhWekpBRW5CRkd2c0x5KzVPME9Dd01EQjlPTVVROHI3REVzeUFONXNRRE1rZXgrdjRVcVZGTDhsejBqVnRlc2kzY0FabEhsYVlKQTdmS3VUTGg0dm11anN4NXVmdGZaWkR4Tm9ETHVTZS9OUnRGT01sMlN0cFpEWWRyVGh2S1ZHZmxUTnlyNVFuR0xmd2E3by8yaDFXaHVodW8rTHE3RVJ2UzRkd3hHUjNyejgzcFlaRjdQYXgvZkh4Wm9MMzJpMCtwRWFkRWEyUnl3UVQ4UWZqWFBIMFN4djNOLzNJdVdXVzFFRnB0U3Zoa2xYeVQ5MHBGZGVPVVl4cS93REp6NVBUNW03VVQ1Wlp1dGExZ2RDWUlLK203UE1kcTlYTEJPTk1waWswN05DTGx0OXp1M2lscG1EN2l2SGttdXRIcHhpbU82R3dscENYKzY1QktqSit0UW5OeWZGZUNuMDBsYkg3TnUzcG44UzdhUmkzbUFJbU04ay96aW90dVRwTXlnbWptcTF0eHZEdDIyWGF4eUZRSDRWb1lZN2JCd2d0QjExZC9UT1E5MXU4d0JQdVBXaThNWnEwaVVxaStnV282MXFTSFVYV0NzTnUwa2ZNNXBGNldLZGc1Zll4UDJsNjlmYTQybXQzcmhjQW02NUpKSC96L1AwcjJ2UmVqakZjMnYwLzNPYjFHWGZGTXpUU2x0bWRqdXljaVkvaHpYb3ZibzVPZ0dsc203ZXRLY0lCeWUxTk4wbXhJN1k1ZVh4V0Z1MHBnbkVmaWE1MTdWeVpYdlJiNkhURVgwQmphQkFuMUhKK3VQbFhKT1dpc1RRaHhhUzNDRGZFTkl4R0lrL0dSOGpYRTQyWFV2RExYUzlWdmFWMWZRWDIwOXlmTU4wajF5UGdQeHJtbmdqTDh5c3JHVDhtdDBQMisxZWt0eDFLd0xnSCtWcG96UGNHdU9YbzFKK3hqMXF5NjZOOXJ0QnF0UXozdFFMYnUwZ1hCRUR0bXB6OVBPS3FoVGM2SHFtZ3ZXQWJXb3NtTVllYzF6U2kxMlljWFUycEhoWFVQK09HeVJIdi9PZldtaXdORTF2Q1ZaMlFaM0NEZ0EwYjhBb1gxR3BoSUJHT3dITVo0NTlhRGJ1Z3BJem5YT3YyTkVqS0xpZUtBUkNnVHh3SU5hRUpTWWVqNWwxYnI5N1dhbndpak9mTkZ0VDkzM1k4VjM0OENpckp1UmkvdEIxZGtBUnIvbUF3RWlUN2UvNEN2UzlQZ3ZkRXBUcEdadVhManNYdk9WQkkvd0FpV1B4cjBJd1M2SXltS3ZkRml5V1JaYVJET01BbmlCVnVITHNrNVVKYWczdFJxdHpsM080NVl5QjIvV3JSakdLMW9uSnQ5blQwL3dBSWxiZ0V3R0FpZlNQaEl6UityZlFPSHlDMU9rUkh1YlZpSEFHUGVqR2RwV0J4MkxHUklERU1DVmtZam45Nm9oYUpXVmxSdFhqelJIYnRGRnNGRFZuN3JLdys4Wkk5Y1VHTkg0QzJTQmtBN0dtUWUrUi9xbGFzZVB0WTNvQjRWNlF6SnVFN2dKZy9DZy9jcUhpK0xzMVNLSEZwN0s3YmJjN1FUQjR4ODY4bWZ0dUwyMGV4QkthVW82c05jMGloV2hRMERzTTgwSTVOL0FKWXRkSGJIT3dNeXNwNE9SL3FxdFdySXJUcm9tZDJsdWk4QUZZanpTSlZ2YW1Tams5ckZkdzJ2K1A2bHJwOVphdTZlM2N1WHJsb3NNSjRjeG4xK00waXc4TmRnbm41dTFvdzEyL3QxTnU0UVNGQjc4SDQvQ3ZSbEMxUnh3blR2c3VPaTM5UGZRMmtEQ2ViY1FWOURYa2VwaEtMdG5yNE1rSlI5dWkrTE1BcStlZjhXaml1TGlyWlcxU1EyNUdwc3FtclFvNmlONm1RZmthbC93Q3QzRGY2ZzR0QzY2UWsyN2lYRUpDOHQ1U2M5NmVXYTlOQzFURzMwbDI0eXN3QmM1OGhtZmxVMW1TMGhaSyt4SHF1aDEybHNQcVgwT3FHMGZlMitXWitId3ErTEpqbkpSVWtTYWFUYVBtOXBOMnJ2M1dVNEpQbUgxcjZQWEZSUjV2L0FOV3laVWVIY0pPV09HbWVRYUs3RWRnN0txaUJsbmN4Z1NaNStYdFdsc0NkRG1rdEZ0WXBXSm5CUEUrdGMyV1M0bG9MWmY2ZTZ0c05zV0FoMnFJaVlHQ2ZYbi8vQUtOY0VrMjlsRVIxT3JGdGJWNjR3a0hjWU14MkErTVQ4ejdWbzQrVGFRM0pKV1QwZHk4TEszcnFoVGNPNTNPU084QTg4UWZuOGFYSW8zeFhnYUxmWTlwYnJhaTdjZFdHeEgyTFBtQk1UOHM0NzFHY1ZGSkZPZHNza0tsUUxsc1FGREdZbGZpZTBFZ1I3MU5yNENtZ3lYYlVxMXE0OW9rZ0FxeEFKa2Y3cEpRdnRES1Q4RGRucTJyc05OclczMUhCaGczTlJlR0w4RDJPSjlxdXAyeVIvV1NwVUFiMG5nZHFMOU5COUlXL2tKcVB0YjFNMlMxMjZrTjdCY2U1bmo4NkgvaXhiRWVSTFNSUWRTNmliVmtYdFhxN2lzNGxVS3c3ai84QWlQeHE4TU51b29tOGhtN3VzdWFoV3VhbTkvU2FLU1FxZ2t0OEIva2ZjMTF4eEtPb3EySTV2OURNOVI2cFlTOHcwV25aQVQ5OWp2dU44NjlERjZlVFh2Zit4enp5SmRGZTExN3pzNHdUbUQzeGttdXRRVVNMazJGMHRyZGVKY0hhdVNSbjRmclU4azZWQml0bDlwTkhiM0MvZEFJM2IyYi9BT1JnQWU1cmt5WlAvbEZWSHlKM204UVhiclpMdmlCL1BXcXBjYWlCN0VkYSs2NXFCUDhBa0NESHVhckJhVEVhS3dqenpMUVJCZzgxMEppTkhyREVMNjhrZno1VVdLRXRRYmdFREkrTXhXZlFZOWpGb2tkb01aanY3MEtHdXRNWlNVYUZVdDI1b0pic0xlcUxyUjZ1NE5QRFQyQkU0eDNybHo0MDVLUjIrbnl0UmNmZ3NIMXh1NlVoN2UzY0NkeVprL0Q1VnpSd3BTMHpxbGxianRIZEhkOFc0WmRDZXdQcjhPMVVuSGlyb1NFbExWbHQxR3cxL1NXblZZQkFIT1FmU0toZ3lKWktiS1pvWERTRkxLdUxTazNyYXpNRHhBTzhjSGppdlJTK0R5cHlTZE16OTFaWUZsQUJFN2ZVZWxPYnNRMFdwZE5mYmNQNGNrZ2tlaEhGVHk0MDROVWRPSEp4bW1hclM2MjR6Z2k2UVNKa0U1K0ZlVmt4SmFhUFZqSk5XVzJuNmhlSWNFSGdlYi9tWnJreVlvanBKOW9ML1hxVkIyOCtsdUQrRlIrazEvMk54aVEvN3I5MEttK0RFRStuKzZkWVBMWktVVjRFK3VkWVk2RnJYZ0lwSnpFNStOZFBwZlR4K3BkblBtVGpHekZtNEFNRlpJams4eFh1cEhreWJJbGxDZjVGUU1ZNUVVVUt5SWp3bExib2tVSk15R3VsQnQ3a1FBVnhQdVNQbFhQbnJvckRxeDYvcWcrdVVLR0NLSUpJNEZjcWpVYkhGOVhxQnFOWmJSVm16Ynljd0Q2L1U0K2RVaEhqQnQ5c0RkdWlkelZNRk5oWGJjVERFaVJ0bmNZK05CUVY4Z3VYZ3V1bjNGUkhKTE5kbmZNUUN4d1B4bXViSXJZNlpadGNVcUxhanl5UUc1d0lWU2ZRNWR2aWFoRlB0L3orYVE3ZmdpTGloUXBrYjFXZmFXd0RQc0orUXJPN3NLMkFmVUliczdsKzZ4VmlZRURFL3dBelJVZEJ2WUQrcVpycVcxWmk0MjdnZ0lMR0RqNG5HZjBxaWdsc1NVbjFZYitxdUI5d1ZMbDdCZGlmSmFYamsvbno2RHZTMHY2ZjVFS0xxV3VzRzhIZTYxKzRjVDkwVDdkeWZldXJIamsxVlVJNUpHZTErc2E2ZHgzRVJ0eWUzNlYyNDhhaVFsSnNyc3M4S3BCSjdkNjZOSmJKYkxEUVdRekFQamtudWVQOVZMSk9sb3BHSTlhWCswc2hsTG1ZbmdSKzM1MXp0N3NwUTlyOVJOdGRMWUpCTEJua2NFVGdmQWZpYW5qanZtd3lmZ1d2SUV0V2JhcnVjeVNBUGtLZE8yMndQb01QczllTnU5ZTE5MWRJZ0srUWtOY2JuQUE0N2MxTitzanFNRmYrQi9wUHVXaFM3MHZScmZOdXlMelcxKy9kZC9OMnpBeEUwOGZVVHEyOS9BUG9xeGU5b3JRczI3TnZZSDhLZC9Fdk1tVDNHWUh3cTBjenZrL24rd3J4ZUVLNmV3VXVHNWRkZ2dKV0F1ZjVINlZkenRhRVVhbHNpeG01bFlNYmZONmRqUGVuc1dyR1VKY2xXNDcrMWF6SkZsMG9odFphUjhKZUJVQStwNC9LdWZQL0FPdHRlRHF3TkxKdnlpNWZURmJUT0F5cWhBSGZtdUtHUk4wZHNra3JzSWJBRnh0d0J3WkVRVEZHR1IxbzAxSHRuSHVCckNCV3VGbFhjZk1TQm5nQ3VpQ3BuTE9WK1NlbWFMUU4zUjNiak5tVmNBRDhEVHZqOGt2ZDhGUDRvSmRTak1RU3NURVo5YXMweEZLS1JYRzJUcUdiYjU4Z0E4Q2U5WnZWR1RkMmFXelp1cnBySkRlWHd4RUdTY0N2S3lTVGs2UFloeTRyK2cvWjAxMXlsMUVaMVVTUVRFL09wU2E2WWVUUUVyZExSZFVxdlpWUEdlLzQwcXBkRHR0cllScHRJSUJVbkFJT2VacE55RHBGUjFiVTJYc3NpcTdrSExFNCtIdlhiZ3hUVXVUNk9YTm1qVGo1S0lxTjZxU0FveWNWNlM2UEtrN1lCN3JMZFl3Y0huMC9hblMxUW5rNWF1c1FVWW1TWW1LU1h5TWl4NmRkMkc0MjQvZVVlYmc0Si9hdWZLcktSZWpyTUNkUmNJTXdGV1R5ZWY4QStKcWJqcElLWkRwejd0UVhZQUFFc2ZnQis4VWNpOXRHWFlRWEZWNUkzTVRQZjEvYWh4ZEdzdDlOcURZMCsvYW9hZDB4UEFnZmlTYTU1UjVTb1pNYVRWa1dFUVpiY3Fremc5ejlTYWs0YnNkUDVJM2RVN0J5Ry84QUxkT1IyQWtZK2xaUTMrZ2VXaEszY2U1Y1BHNENFUTlnRHlhcTF4UXQyTXZjRm5UQ3piWUJtRVBjTXlCL09mcFNKY25iQTJWdXVhN2N0QlYzcFlVbnpIRW1ZaytwL3dDS3RDS1QzMkkzb29yOXpJVWNqL0tQbCtsZGtZL0pGc1N1WFhZbFJJeDJHUGhWa3FFZXlla1VaWXdPeSszcWFXYjhESkQxaTRGVGNjUXhaaEhJSGI4aFVaVzNvZU5IVjFKODl3bnlydVByNWovQlE0VnBHdTloOUVEZThXNDhzeDhxRHVXSk9QcFM1SmNhU0dpclpjOUtabnVwNGRyZmZ5QWVkb2orRW4zcmt6ZE8zb3JCZkhZM3FMdm5VRld2WG1JSjQyajRudjhBbFVZclQ4SXJWZmNyMXNheDlWZUc1Z054QjJuRWU1L1dxdWNGRkFxVGRpRDNENWg1SEttUTRlZWV4TmRVSXRpU2RkbFZmMVphNHlxUVFRUVNCR0RqRmRzSTBqa25LMmVzTFBsTWdEUHJnZnRSa0xIYkMydC9pSUhBbmdEdFdWRHR0TVl0M1RiVlQzVWhoM3pRY0U5REtkR3IwbldiRDJEdnNxR0s3bkVFWkgrNXJ5NStqeUtXbitoNmNNMktVVlpQWDY2emU4QnJMS0FHWW5HYWIwK0NjYjVDNXBZNjB4WFMzUUh0U1J0SzRhWTc4ZmpYWkdObkxMUThsN3c3VnZ6SkJFaVdnK242Vno1SXliOXBlSEN2Y1ZTV3lvUUU4Y1NNVlZ1em5TTzlPNmVkVDFSckxCd3F5ek5Ba0NQejdmR2t5NWVHUGtHS3VWRzRYU21iUnRtZGcycXB3QjJpdkdrNDFUUjJyTFB3eG82ZGxESkNFeWZ2QWZoRlRUaVo1TWo4a0JwRloxUjdOb3dlSWlLTGt1MHpMSmtYa0ZyZEpwUWpwZDA5c2NCRG1RUFN0Q1R1MHd2SmtmYk1IMVlhVzBxMnJhSktrRm9NempqNUdhOXpDNXYzU09ESS9DS1ptL3hJRE0zcGlCL1B5cnFXeUxGd2hOMDhHUU1HSTlLZHNWQTdQbWNob21ZNWlhRWtGTWF0c1FYMmtrYnBuM2lweWlGTTh4M1dYeUJ2YnY4QUEwbGJDRXRFSlp2a0RJZ1ovbnRTUzIwaGdSYytNb1RBS2lQanhUMXJZQis1YzhTNXRiQ0taTTlnS2dsU3NheWFYRGI1akozL0FFR0FLRFZoUEM2WFpWVWlRQzJCM3lmMW9jYTJHeHRBTk5hS25OdzV1RUhIT0ZxYnVUQ2RhTGRqZmZIOTF2TjRQQmozOUtLOXo5dlFyS1BYNnU5ZXVqZXgyckVFY1o5SzY0UVVlaWJZaGNZVzBDbmJ2SW5pcVIySTlBRldPQmsrVVZRVUtTQ1FBQkFHMzUrdnpwTjlqQkxyYmRPRUJKWmp2Z0R0Mkg2L09sU3QyRzlDOWxDOXlCaFJEY2M4VVphVmdpWDF1MGJHa3QyemtzTnpIams1SHh3TTF4TjhwTm5SRlZvdXVuZ0lzcUI1Z3dNRE1rQThWelpkdlplT2ozanBoOWhjaHNCZXc3RSt1YUhGOUcxMlVtdTZtTE54L0d1dmRZLzR0d3Z0aXV6RjZmbWxTcEU1NVZEN3N6MXkvYzFEM1ExemJKRGJSQS9uTmVqR0NpcVJ4eW01T3p5SWdZQlBVaWZ4cGhBMXR5dDFYOHVHSDQ4aWcxYW9LZE10VFlNRXdKdFJqR0J5RFVWTkovcVdjYlg2SEJiQmRnR0JBRWcvalRxVEZhVDBXdlM5R21wczNpVmh3UklKN0gvYzF6NThyaEpiMGRPRkp4cWl6dWFCZkJ0K0hhVXRheTBpWjlSTlJobmZLMit5azl4cWhYVFNXQWdySUpKSWdUSjVycVc5bk5KdnBFYmx1NTVkcURhSmpiYnh5YURyNUR5a09YdW02dDdva3d3KzhzQWorWXJubG14eFNaUlk1dGw3MGpSRFE2ZTR6dURkZjd6RElJSEFyemMrYjZqcndYakRpV3FQdnRENzBTR01HdWRvZW1GTjdZVUlBTEhnYzBuRUlWN2lyYWJ4V3VkMWdOQUdQNXhVOXQwaGluKzBIVTEwdlNiMXdGV3V1UWxzQXlSUGYyZ1YwK213ZlV5SlBvWEpMaEZ0SHpWOTdzV0pKWWM0NUpNMTlEcGFQTnQ5Z3pibTV2QkcwRGtEdlRyNEVmeWVJSUxnSk9JeXZORnRCU09CYmE3eVpHN2dDdDlnTmVTU2tNcmhJNUJ3S1dXZ3hCQmd0aGdjQUg0WnBHdGhDcVNkT1JpV1BZZkFWTi9tRzhBYlFCMXFpSWc4UjJGUEw4Z1BJN2FjbTYySm55a2ZpYWxKYUdCMzNMdVdJQlk1SWppakZVWWMwQUl1TmNhSWtnZXBxV1N1Z29aOFR3YlF1SE4xc2lSOTMzOXoycVZjblEzUlh2Y042WllpZWU4bXJ4WEhvUmlsOGhNakVmY0I3KzlWaXIwS3lyZVd1YnZwNzEwSlVxSnZaTVBCMzRnZmR4M05LMTRNUnRnRm9Kd28zTlRNQkl2dWU2U09lM3Azb0pVQnN0TkdteEZ1dkFSRUpnREpNWS9ITmMrU1YrMUZZS3RsZ0I0U0FzR0Q3Qkh0aXVhK1RvNkV1S0d0THFQNmZTamNRR2JsbzRKOWFsT0hPV2gwNld5bDZwMUUyTjlyVGNrOHpuSStsZGVMRHlWeUpUeVU2UlJOSkRsb0o5T2U5ZHFkYU9kcTluaEN1WmtZZ3hpTWNmV2ltWm9NRkU4d0ovV21FWVVHWm1QY0VlOVlVdWRPVmUxYmJ6TnVBUXpYTk5VMmRNWGFSRXBzZVZJZ0NZR01WUk1SNkxQb2o3ZGN0b2xqNGk3UVlrYmhrVnorcVhzYitDMkg4MWZKcGRJb3RsTXRrTUc3NTlZcnpaT3pzb2hjNmF4WkgweWhiZTFpQVJFRSt2dFZjWHFrdFNKend0OUFrMFRiQXUyK1F2RzBDQURudjhhYVdkUGRvS2hRdDFQWFhCcUxmbmJ0L2lCMjlKL0N1cDRZMTBjc2NzaEZOZnFKTTNtUGN3T1BwVTVZWWZCVDZraHJTYXZVQ0U4YTlQdXYrNm5MSER1a2JuSVovcXJ0dEFwYTYwQUNOaGtmS3A4SXZ3TnlrRHY5WmRkUGRQaTNDRk1TVjR4anZXajZkT1hSdnFOTHN6M1V0YmQxUlUzV2tURzA1UEZkK0xFb2ZsSVRtNWRpVE95M1ZDSHYyL0dySmVTYkdVS3hiVXJDa2R5VEpxY25KV01raWVvdCthUTRhUlBITkxHWTdRamZRa094SUluZ0ROV2pKV1RsRWpiYllISVBKa2o1L3dDNk1sWXNRZDFnVlppQkU1ejNwVXRoRDJpQ2JTdm5nL2hOU2w1b1pBTGJNTHhaZWU4NHFqV3RnOGpTUDVuNWhRZWNkbzVxVFhRVDFuKzZ3Z25jcmNBZHF6MEVlUWt1cVc1aEJsdWNmejg2ZytyWXlJdXdJRzhrRE1EMi9rMFZyb3pBOGpnQlFjbnVmWWZyVG9WbGJyN25pWFlCeU93OUs2TWNhVms1TVVhUXFrSGtIa1ZUeUFHeDhnV2NjSDQwQU1tV0NBakVnRXRQZk5HcjJDNlBXenVBR0RMWmdSbWl3RnJhaHd0Mk53WGFxajFPY2tlMWNrdGUwdEg1SmFuVjNMMTE3cnNDSWdZN1VrY2FTcEZYTnQyeEc5cTVDZzQya0FLYTZJNC9nbTUvSWpmdUc0MlRra2lQVC9tcXBKQ1cyRVZTTk9DRmc4UVBnZjFwYnVWRktxSkFMdVVzMkNmYjJwbTZGU3NOTTRCUEkrOTZVNkp5Q0s1M3pBSTIvd0RyaWlJUDI3eFFFYmhJQzhkdWFsSldVaktqMzlRZHhVRWovd0NvNEZGUkE1V0Z0WG5XK0xnSlZ3UXdrYzVvdUthcGhVbW5hTE50ZmRPMUZaVHVpWTl2NEtoOUdOMlcrdEtndW0xZDltRTNTUkVDZmpTL1NpdWtINmttVFc5cVdud3JqN1FZd1NLSDA0L0Jua2w4alhVZ292cktUbm1ZN1VHMjBDTVVMcmJVRlF3R2VCNlZOdHNkSUpaSUxJdTVlWTNDUDJxY3JEb2pxN3lXVldiOGdEN3dnayttTzlhRVhKNlFHNktmVjN2R3VMdFh3MDNjTVpZay9EQXJxaEhpcUVic1dTMHh0eXppSjllS3BkdlNGZWpxV0lPNHlRMlo0K2xNMnhVTjJVSnRoZDd4L3dEQUhOYzBudm9za0hheU1CbnViU0ltWkg1VW5KL1lORmZxRUNzeExqNW1hdkdWaU5DeFlDOG9ZOGpnVTkyaGVPeE0zdjdseE5nem1aOUtkTHlLKzZKVzdoTjRiQndDUUo5YURqbzFoTk9DU1dIM3R1ZTlDUnZJUkNmRGxqbjlNMGpWc1laMFZ6KzBiaGpqaXB6VzZDaGl6SXRzV0FnbWRwL3lQN1ZOOWpIbGxwdVhDUkp5UjMrSDh4UTYwZ3NyOVRmM0Vxa0JGemcxMFFqVzJTYkU1OHhQZkFHZTNGV0VJN2R6SUR3djgvU3N6QWJoZ0taNUlKL256TkZDc2crNHNwR0FCQUg0L1dtV2hRbHJ5cXJ0MzRIenpTdjRDaXkwMk5PSEwrVEJDeHpBL2V1V2Y1cUxSSzY1cWp1MjJwei9BSlRHSzZJNDllNFZ6OElHaWczWUxDVEprOStjVS82Qy9xZXRvWGVTUVc5NkRkRkl4SitaREJNZ0tESHZrMGkyTzFSQXp5U1lQYUtjVmhQS0ZYMERRSStWTW1KSkJWTzRTRGpnKzh4VEVoMVZMa2dFUkEvRDlPYWszVEtKV2p0c0dlVjloNjB3dEUwWGJjWHhJSUVlMlBhc0VldGhtdGdDT014VTV0THNyQ0xZOXBiTjFSbnlrekpJbUFEVXVVU3ZGamVuREJXM1h4bGovai91azVwZURPRGZrNzFLNDF5K2taQTU3d2FEcEFqWW9YWk1LSUUvU2xvTEk2elVQcDdDbEUzWENjSzJBUGMvenZSeHc1dmZRc25TS200MzNXdXZ2dWtaOWgrbWUxZEsrRjBJL2tLcVhFMHkzbnRrcTdsVjh2TVJ4V2YyQWlWNVdlNG9DMnd1MEFoUnRFOFNSK3RLNVZ0aFVHK2dscGZJcFBsRnY3b0Vta2VSdlE2eHBCcmEyQXpnU3ZJQk1qK2MxS1VwYUtLSVZ2QWNzTFdwY2tDR1lHQVBoU1hKVmFOUlYzVGZ2SzVOb1hRUkFjeDIvUEZXWEdMN29XckU3bTVibTRnN1NJWUFaWCtSVkU3UXJWQ2R3RVhwSU1IT2Zhckxvayt6b0RBbzY0Qmd6M3JQNE5Ya0xZZUxiS0FGNUFCL0NnMTVNU2t0ZFlSQ2pBQS9LbDZRUnl3b2RsUXpzRUZ2MnFVcld4a1AzVjIyaTdpRjdIMStGUlR0NkdLM1UzMmNSd3VRQjdkLzFxMFlVSzJWOTNpQklYajUxZUtKczRBU1lBd2Z6b2dQWFNRb09JbkFGWkdBM0ZiMGtqK0NtUXJJRWdiU0pBNW1QYXNBa0ZZTWlBZVpTSUhjZDZGNnN4TFUzaDRSQ1R0UGxFZWxKR0c5amN0Q0xNMHRCRzMyOUs2S0oyRnRqY1ZCRUg0VWpaV0tHbVdMaEE1Sm5BOWYrZnhxZHRsdUtYUUJ5UVZJeUNxZ21QYW1paEpXam02Y3d3SmdaUE5OVEZzbXVVZzVXVFMzUWFHTEJod0RHU09lMVVmUkt0MFdHMDdpUFgxejNxUzJPM1ZrVjh0eUI2eDY4VTRyQ3IyWVFEMzdqNlVBbGhwN2U0Z2J6akVBbVdxYzM1S1k3K1IvVEk2N1FHTzd6WlpqNVJVWlVXVjBFVzVjRW5hU1NaTUExUGdIa01hbENydVI5NmtsTFpvUmRGWnFDV0huOHFJU3pHWXgzTk5IdWwyek5Qc3IvRWE4TG1vdm1BVDkwbkFBd0FQaDYxMDF4cU1TUGUyUnRLR081MFlFOERFUURpaTN4VkFweVlQeGdoY3BnNG00V09JLzJPS0hDK3g0MGdtbnZtMnZuUk5veUh2U0NSazRBNW1rbGo1ZFA5djVvb3BWdi9JdmQxeUtHRHNQTm5iYmFNVlNPRjZFbGtSeTNkMDl5VS91VGpra1RRYW10NkY1UlBQZnNveTdXbko4dTZUUStuTnJZeW5GZEhqcUM5NGtaWGtLQkdab1BHa2pLVGJCM0hsU3puSk9JN0dzbzdwQnRkc1FCYUFvem5QMS93QjEwSkVXTWJoNElUZ2dZK2RJbHV4bTlVQ2JiQnlQclBlbW9VTnBVWmdZSU9DU1RnSEZKSnBCUmJXdGxnTTJMbHpkSmJzUGxYTks1TWZTQWFxNGJwY3U1d09EVFJqeDZBMkpFYmpKNHpBOUt1QVdJSkJKYkVtSjlmNEtiN0NIa08xUWVTbzRvZ09YRDV4NnorbEJJRE9UQk05eGduaW1vREFubUo0NWo4S1lVUGF1U2Ixd2pKTzFaUE1qTlRhNlFmdUtYektoZllINDA4VUJzSEVINFV3VU1XZ0FDejhkcW5JdEhReWhZdEEyd1lKQnFUUlpIcktrM0VremppTUw2WW9TMGpKZmNpNkFXeXJJcEU0Z2Z0VHA3RWxGQzZuYUNDRGtuZDdTS28xWkpQaUh0a3hDd3VJUHQvcW1Ra2xROGJ6R0Z1ZlA2YzB2RVBMd3lNN2lUbmRKeEh6clVDeGxDTjY4RUF6Z1ZxQ1dHamNlTmJCVXNKSS9HcFpGcGxjZW1XdmhqeGtJQ2Y1ZjVINjFCUFRMTmRGcG9iSGkyU3pGUXdZZ2lDWXBOQWRpUFdTMzlUY2Z1Zk5DanVUU3I0WTY2c3pPdnVuWkRrd3pDZmVNa3g5SzY4Y1Zka1p0MVI2MDNpTWlQQTJrbmFENzRuMHA2cm9WdSt5ZXAxRFpJaFJJanZ0eitOSkdDc2FUZFVLMjdXMjAxMDdaNFFFRWpmT1RIY2dISHZXbEs1S0svaUhqR28yV09tNlNITExxbHYzOVljcnB3TnprZXJBR0ZIeE5ReWVyYS9KU2o4K1A2ZlA5QjQ0SXZjN2IrUDUvK2hqME85cHQ3WG0wbWhRK2JZQ0xyL2hnVnp2MWtaMVNjdjdJc3NEVzlMKzV4YkdpVkNxNnU5Y3VZUG1oVS9JMW5reXQzeFNYN3NEeHc2YkY5UjAyL2V0K0l1bUZ4QkozcGRCUGYyRlZqNmhSZGNxZjZDdkR5OFgvQUZLcDUwMTRqekZUeXR3UVI2NTc5NjdFMWtWLzRPV1VYaloyKzI2YmlRQnRrbHVUajBwVXE5ckRkN1FsRWxvRVJtckxvbSt5VWtBRXdaeVA1ODZOR0lxQ01rUUk3OXFWczFEbGk0TGFBSDdrWUF4bWFtMWJDRzhRdTJZSTV6U1ZRYkJsa2pMWW8wekFidHlRT1BpVFZFZ0FHTEU4REprMHdwQzZ4QUVEMGo0MFVnTWdrbFZCZ3p6UGIrUlJGSlhHS2lDTVJnVUZzREZ5MHdPVDNweFNiM0NyS2dpQnpIcWFWSzloNkJNWk1lOFRPWXBrS3pvWW5BVWV0WnJ5TWd0dFdZd1Zsc2pISnhVNU90bDRLM1FTNG13amRBOWdaNzhmblNwMk80azdOd1dqd2hZYytJSm41RHRTeWkyTXV1ejE3VWJ5dm1PTWtjQVo3Q2pHRkN5bGVoYTRXM3VEbVRrUm1xcGFJdGg5T3dKRXd5ZzVyUFFFNzBNeUh2RkpUQk1TM2FheXZzRCtBZ0RLN1NNekV4RTFqQlJjS3BQUHhPVGlpWWIwV29BdlduektzREJ4VTVRdE5GSVNwcG1odFhrWmx5Rk1zRGpFeHhYSlQzWjFhOEZqMDN4ZjZjbTNjZFFXTTdSSUpHUDBvNlJHVnRsVjFtOS9kWTl5MGcvTFA1MHVPTmxKT2taM1Y3bDFtMXpoUURqdC9NVjJZOXh0RUphbFRPRWdMQUlBQVBtTkdqV0MxTGtNTmdsbkdCNjU1L0tzbFlXNkxuVEJVZGJoVmphc2YycmNFQW01eXpUN0U4KzllZk85cnpMYi9Ud3Y2blpDdjIveVdYVGRSc2U0ckxzMGdIaVhMWVAzeU9NOTU5L2ZGYzJhRnBPL2QwaTBYUUd6b2RkMXpWK0lxdmJzTWNZKzhUNmVzZXB3QldsbHhlbGhYYi9uOCs0SHl5UDRRemQwU2RQdUxiMGRtenFXMnkxKzVmUzJnUDhBKzQ1UHlBcWNjcnpKdWJhK3lUYi9BRy83QzRjT2xZRFdMcTdYVHliK3RzNmZUU0ZWYk5zbFdQb0MwRS9TcVFlT1UvYkJ0L2QvN2Y3Z2FsVzNSVzMraTlTdUZZRGd1dTVFdnJ0Y2lPUW9rZ2ZHSzZJK3N3Ui80Ni9jbThNNWVmM0tPN2JiVHV5RjBPN3l0SEFyMEl0WkVuUnh5andiVmcwdGJjM1NWUGFmclA1MGIrQkV2azRoVkFHbEp4QUo3MXBYMEZCYktDMWMzT2UvSTdVa25la1loZXRqZENuZytYYWVCUmk5YkExc2sxei9BQk1qMS8xV1VUQWk3K1htZVpIdFRVYXlPNFJuMDlLTkdzaUpCRWVsR2hiT1JNNHh6bXNBNERBaWVSRVRuMS9XaDJBQmR1ZWduTW1uU0ZaeTAwRXRFQVVXZ0htbGkweldBUXVBYlNTWTI1K09QOVZqQjBzaVY4VHlDTzNKeWFSeStDa1kvSkp5OXVmREd3RVJ6UDFwYXZzcW0xMFNBM3FGTGdEL0FPVjVyZGJvYmIxWjQyRVVtWHUvSGIvdWh5YjhJUEZMeURRQnNGc2NZRk5iWGdWMHlXeUE0aGpEVElvcVFqaWN0TnRJbVlFRGlucXlRZEJOeFFPQ0FCSTROQUlZcVVMVzEzQWdFRU5qL2loWWFDMjJOeGRyTUJza3I2WnlZb29ERElRck1GQzQ0eHg3L2xRTWkxMGw0dXl5UUNUTUFjNDQvd0JWRnhMY3FvMHZSYjBhUXFGUmlya0VrZkN1ZkpDVFk2bWtpbDYyeTJiNVAzbzh4RENPZUJXd3B6S1NhanNvSGx0UkorOWlUWGFsU09aN1pKb21KamFaSUk1OXFETWhVQXRycGNsa2tuSjlCTkdXb2FESGN0bDdwVnR2Y3MydkVWRlZRVE9kek13TUQ1bjZDdlBtMms1Vi9FZGtmQ05MNEduUGhwZnRpNTVXdk5QM1FzSEpBd0FCSmozTmVWem03Y1g5anBkSWoxTHJwdWRPczZYcFNYcmJhcEY4VjJnM0xnSXdnQSs0bzdLUFhKcHNYcEVwdWVaM3g2K1AxKzcrNXVXdENlbDZmYjZUcFJydFp0RjF2L0R2TStJZUNWLytSLzdEbmdIdlZaNW5ubDlPSFhuN2Y4L2J4Mi9nQ1hGV0h0WGJqTnB0WmFXNXFOYnFqczBwdkFLOTFwaVVBeGJ0THllSk15U0FhV2NZcE9EMUdPNVYwdjErWlA4QXQ4R1RmZjhBUCtndHkxdXVMMGZwbW9hL3J0VFA5ZHJnWkxIbG9QcCtlS1NHay9VNWxVWS9sai9nMG0veVJlMzVORjlsdnNUbzlRUHVGZE1nMlhMNFQrNWVZY3FqZjRxREVrYzF6ZXAvRU1sMisvand2MVh5YUdLSzZQb0doK3pYU05GYkIwblR0SWhDZmU4TU1UOFdNazE1ay9VWlovbWsvd0J5cWhGZUJQcWZROUxxRllYdExwMkJtUWJLbjlLT1BOS08wMys0elNmZ3cvV1Arbi9UdFNXT210ZjBWMC81V1JpZmRlSzlURCtLWllmbWZKZmYvY2hQMDBKZGFNUjFyN0Q5VTBKWTZZVzlUYkhkUEszMFA3MTZ2cC94UERrcFQwemx5ZWtuSDh1eko2aXpjdE1VdTIydDNCTUt5a0dhOU9Nb3kzRTVXbXRNQ3dZSEVneEpuMHB0R2FBa3NKT1FUVFVoV1NMZVdZSmpCK3RhaFFrZ0FFNVByRkxSbXdMSGg1K28vbnBUSkN0aXprckFFK21EOGFaSVZrcll5bzVCUEhOWmhSS1luZVFPTzJhQmpzQjVpUUJrYnZYdlc2TWNCRHR1OTgrMWF0REo3Q0toWUFFZ0htbGJLcFdHdFd4QUpWeWNINFZOc3JGSkhicWxXTzFTUWUvclFUVEM5Qy8zZnVnOFFaRVZWVXlVcjdSSGV5dElMS1IzRk5TSldFdDIzamVGWUlDSllyMzdDYXlBeGhWbTROdTQrLzhBcWd3cFdIZVd1T1habS95NTlxQVZvODd6Mmt4eHhSb3djQVpBa0dKNC9ud29pam1tdE1WdW1TcklGZ0VaTW1ESHdwQXk4Ri8weUdzRW9JQlArUmd6QXFVdE1aSlVWLzJnM0hWcUdYYVFkckQ0VlAwL1RvNk1uZ3AzUG1MY0NKcnFyUkM5bmdGaytpNU05eVA1K0ZIN0FyeUxiZzEwWEFURXdJbkdJb3Rhb3llN0xmUnNBNzNRQk51U0NSNkQvZGNHV09xK1RyaEl1ZXI2cituMFdvMDlnS2IrcW5lOC9kdENJWC8vQUNnSDRmR3VIMDJMbk5UbDFIL1AvQjBaSk5LbDJGVVc5Q3QvWDNrdDN0cFRTMmxZeHZNQ1o5aG44dTlJN3kxaVd1Mi8zSGE0Mi82Q09xMVE2ejFKNzNWYnJlQWpaQ0RhZGd4c1FkcGlQWVNhdkRIL0FPUGpVY0syL3dEUHkvMC91VGN1VXQ5SW5xZFpjMVEvcXJ5TGJ1WDNYVDJVUUFMWnNvUjVGOUFTVlg0QnZXbGppVVBZdWttMzkyL0wvd0Evc00zZS93Q2hhL1pxMGRQWjZscVNRTHhVV2xiZ3k3bmo2UlVQVlBrNFE4ZC9zalIwMno3QjBmWnBkRnA3Q1lWTFlBRS9qOWE4TEpjcE9UOGxrcVZGb3VvVmJTeVJ3TVZIaU1CYTd2M0UrK1BwV293cTlwYzVKa3lKN1UwUXNydFJwZ3pjWXFpa0VVMVBTZEZyclJUV2FTeGZUdUxpQnFwRE5QRzdnMmdPS2xxU1BudjJ0K3dXbDJ2ZTZSTmk0TStFVEtON0NjaXZZOUgrS3pUNDV0cjU4bk5sOUpHU3VHajVscU5QYzBsODJkUmJlMDQveGNRU1BiMXI2R0VvNUZ5aTdSNXNvdUxxUkFrUWVaajBwaWRuakxUT1NEbkZhZ01qY0NxcTV6a0VVRlptS1hBQ0RQTTFSQ004SkE3cUFZa2MxcU1kWEloVEJPSkltaFh5WTZDTjBzY0FRWkdEbjlxRkJPRGFDaGlTSUpCckJRYTFkTUNJbjRaTkJ4UlJTYjBGUm5qN3pSTVpQRkkwaWliTzNkeFFFbVQ4ZmVncXNMc0F5NFAzaEJxaW9tN0RhZXkxd0dHQUlFeXhqL2srMUZpZnFkMk5adVFSNTBFa0FURWZIK1JXQU5hUzN2M0VQYlRhUzNBZ2pPUlAwb1NNanFiV0Z3QldDbkFZY1RISDUwclJSTkhtVTdGYmRuaVRuR1A5MDNRRXJHVVZtdGdMOTBEYkdCenhTOWJDbmVobEFTeWVZaVJFOEVZTVVGMkNTTkQwd3pwdDNpcW9Ka0J2Z0toTjB5aVZvclB0SXhHdHhHV0xmVUE4L1dwK2w2SzVQQlRYQkxBNE8rSzdMcEhOMnp6d2kzU0RnRWdDZVFCU0p0ME8wbGJFTlJLMjJVZHlEOHZUOGFzbmJKUzBoL1NhbHZCSzVETUNNaUo0cm55UlYyWHhzTC9VRlgzYmR5S056QTk2bHgxUlc5MlduV05lbW91V1JhSmF4WllPWkVCbVpnVCtFRDVWeTRNTGduZmJPakxrdWtnTnBrdHF6M0FJdWFobGcrZ0g1UzM1MW5jdEx3bC9QN0FUU2R2NUdOWGNVV2RQYlZsWmRPTm9LbVFXQkxNZmNTY2ZDdGlpN2NuNS93Q2wvWUU1ZEpGcHBkVWJMRlZZYkd1MmJoSHRKTWl1YVVPVlA0VEtmSjlNMFhVa1pFaGh0Qy84MTRzOGJSMGFHazZtaFZWa0RpayttekRPbjFVa3daK2RKS0lSd1hnUmppcDBGbkdHNFNEbmc0b1d6QzdJWW50K2ROeU1LYWpTQzRDQ3JIUGFtamtvYWlxNm45bTlOZTBoUy9wcldwdG5KdFhWL0ZUeXArRlh4ZXJuQ1Z4bFQvbjdpeXh4bXFrclBublh2c0FnVzVjNkhmdUJ4Sk9tdmlTQjhlZm5tdmI5TitNUzZ6clh5amd5ZWhYZU4vdVlYV2RONmhwYnJMcWRIZlFnd1lRa0g0RVY3TVBVWXByMnlSd3p3NUl2YUs1Mk8wYmpIYVBTckVXQ0xUQmc0a0NNMGJBZVllVWtZUE1Wck1UUS9lK0VDUk0wR3dvZzdnUWR3RVlpYUlEaWtuN2tIMkdhRjEyRkp2b211NUN3ZEdVeDNVL0doYWZUR3FTN1JPM2NiQjV6UEZCb2RTR0hjT2g4Z2lNUWFWV21VdE5BY2lTRm5OTitvanZ3RnQzcmlxTnAyRE13UDBvOFVoSEpzYnQyYjVYeGJqTXd2RHkzRGtNUkhKbVpHQjhLRCtBV2RTQUp0N0EwYkdBSUVuRXdPMC92UXRqMHFQRjViRGdHQVdFeXVNalByMm9yb0QydytxVjdGK3d0eENoZFEwYzRQSEZic0NmRUtxa1czMmdCbGFJOUJ4UVRHZmRoTFYwTGZna3FCRVo3VG1hVkkwbm91TkpmMmFkQkVDQkdKcU1sYnNvblNTWXIxMGx6dkJUQjRFQ2UzRkRDMG5SU2NXMVpSWExtMXBCT0RPUG5YVzFvNW85a1Z2TERCbTdrOHg4YUZET3dHb1laZ3lPZWFlSWtrZDAxemE4ZHBFQW1seVJ0RFk1VU9MY1pyYnlRUElZOXhVSEdtVjVXU2ErWENrNEFBa1QvQUQwcEZDblJSeXRXRnQzdDlvQnluQk1EMUptZzRLTHRBYzNJSmV2TU5QdHh1bWZYNi9TaEdPek4yaHpUYXorbzBQaHNQTXBrd2M0R1AwcUU4WENmSkZZNUxqUm9lbjlhYTFaQ2Fnc3J4QUhiNHpYSGs5TW03aVhobHN0ZEIxWmJsd0w0aXlZalBQd3JtbmdhVmxGTk0wMmh2TVVubkZjRTRsVVd0bS9EYzVQYXVkalVPTGVpV0puNTBPek5FQnFBVzlSUDBvT0prU3Y2aFZ0bGw0RkxHTzZHWWxwT3JXTHQ3dzJZRWc4R3FUd1Npck1tbVdPdTBHbDZqcFlhQTRHR1V3dytCcVVNa3NidEdyNVBsbjJvNkxyckd0OElhd0pZdUQrM2RjR04zWU4raHIyL1MrcXh1TnVOdGVDV1dNcTlwajcvQU5oK3IrUHRzdm83cmx2dWVMRG1lKzFvOStLOVNQNHg2ZXJkcitmWTh0K2l5ZG9iNlQ5aHJHb1IwMW12dWpWcDk3VFdrQ3NGRTVCYm1QaFVQVWZqRW9POGNQYjh0LzdGWWVoWC93QnlJNno3R2FHMnBXejFHL3A3akVCRHFyWUtIUDhBN0wzclkveGZJOXlnbXZzOS9zeG42Q1BpVEVYK3psenBaRGEzVG0rbVlkU2RoRSsyUjJxcS9FVm4xamRmNS91R1BwRkR0V2FIcGQ3UzI5UGJiVGpTMmxqRzVGS3o2Ym8vRTE1dWRaSk5xVGIvQUovT2pxaEZKYVFMcWRsZkhaZGYwclF1R0NuZDRmZ3N4SG82R1BUMHA4R1I4ZjhBVHlQOTcvc3pTeHhiMmtWNDAzVGc1TnZVNmpRM1JKRm5VMi9HdG1SSDNobjg2NlBxNXZNVkpmS2RQOXVoT0tYVHI5U3U2ajBpMjFtNDRiUytJc0VQWWVRL3hGZFdIMVRUUzNYM0k1UFRxU3Z6OWlndW8xb2JXTWQ4R3ZTak5TUFBsQnhKMmJxbFR1QThRRVo0bjUwWEg0TXAvSVVYQXBEd1BLWVVMN2QvbGpuMXJBZGVEVzZkTEY3cE9tTjRpNVpRM0xrQWhZbnRBN0VnQ0tYeUxWR2N1MjFzNmd1VkEyd1NweVIyMjBiQ3RnaXpwZk42RlhmTUE0amtSVEpLcUEreVZ4QXdWMHdGYUNTUitsWXc0c2dsdHN5Skg4OWNVR0ZiTzJsTFhoM1gzN1VqZERxTm9mdTNiMXNxTGR4Z3NTQWFUMnZ0QnFYeU5kYXY2WU9xV3p2dWtpZG9FckI3MXpZSVRidDlIWm1sQ0tyeVpPOENXSUVzVlBIcnpYb25ub2liVXB2NGpQeHhRc1lBOEJDU2FkRTVIbVVnQXFKV3NDZ3kzTHRvSVpCQjRJN1VqZ21NcE5FUEYzWWJjRDc5cVhqUTZrTTZYVkZTZU9CeU9LV1VMQ3BCRzFBZTA4N1p3V0I5WjVvY2FHVEQ2SWFpOXJMYWFKSHVhZy9kdElOek1LU2ZHTWJuMThoamJlalphRDdJOVcxS3AvM0o3T2lYamEzbWMvSVkvR3ZLeWV2d3hkWTdrZFVNRTMzbzFlZyt5dWswZWtVMjdSdVBIL2t1Q2ZvT0JYbno5Yk9jdHVpOGNTaWd1bDFCdEs5cHlRYmVKOWFsT043WGt2RXNMR3F6bmlhNTNBYXh0ZFZDa0hNbnRTY0EyY04xQUJja2lLeVQ2TUhUVjJkUW9TZk44WW1sY1pSMkV6SDJzNkJxeFovcnVrc1Z1SmtxT1NQYjFOZC9wUFV3dmhsNkpUakpiaVZQUnZ0bHFOSUZ0OVFCQzhDNE9KOUQ2VmJMK0h4bnZHQ09ieE0wT3I2cHArb2FFZzdicXVJaUpCcmhXR1dPWHhSMHBKbVZ2V2R0dEV1RXZaWDdvY2s3UjZWM0pxbTB0c2xPRFRUWFIyN3JOZHBGQ0c0TlRhQThRV2I2N3ZtcmN4bnRVbGl4NU4xVCtWLytpTnRiN0E2bnFUOVROeGtSQmMyZzNiVGZjdXg2KytPZWFhT0JZS1RmNlA0Q21tdENtanZ2YnNsTFY2OGxnNFh4SGsyV21kcDl2Um9wOGtGS1Z0YiszbitmQVU2RnRScURhMVJPczB3QkEydTlyeXV1ZVQyWWU5VWhqNVEvMDVmdjEvd0J5cDdMSFN2YXZKY3Mvd0JRbHpUdEVLeDhwQmp0eXA5eGl1ZWFsRnFWVS81Ky93RFViVFJUZFR0dnBIYTIwWExMeEVtU3Z3cnR3U1dUZlRKelZhOENLSmJWMlpDNUUvY01TRFhTMjJxWkJxdWlzMXRsWDgyUXdNYlc3ODhWMTRwTmFPZkxGUFpUa2JIWmd4Z2V2SXJ0VzlIREpWdEJRN0plWWhZdU5IZUNKL2VqV2dYc2R0NnU4ZW5td3R5NGJidjVrQjhzaklIeHhTVlVySDAwUjNmMlVXUVFaRURsYzl4SFA2VVgyQmFKZUlSdEFFN1lNeFAxcGtLd2pNQUVXRDVUMjVGQmhSS1MrL3pSSndKN1IvcWdGZkF6b2d3d0dJSEJIb2NWS2Izc3RCT3RNZXYzQ213RitWbkh4TkpTWWRvcjlTWnYzQzhsaS9jOTZ1a2tTYmJFQ1ZWblVuellJL2FtQnBhSTNuSVJnQVJKTlpBWUI0TUZ6T1pnMHlGRHlyVElhVDNtUlN0alVjMnFOcEJJSFlLY2cwT1REeFhZRWxSSVlFdGdUUjdOZkVpd1dTV1U0RXlKRTF0Z3RNZTZOb3YrNTlUMDJqdDNEYThWb2E0eG5hb3lUOUJVcytUNk9OemF1aW1LUDFKS0tQcm1ndGRLNkhZWFRkUHRLREhuYzVkei93RFRjbjhCN1Y4dmxsbDlTK1UzL3N2MFBWaENPTlZGRC9UMnY2M1ZvcVFZSVozN0t2NlZLY1l3aTJQWnF5MiszNFZyQUdQV3VOTHlFemZXdEZjVW0vYXhjVGtkbUZkV0hLbjdaR3J5aW4wdXZPNkNDQ01FSGtWZWVLa0ZPeTB0YXJkQkI0N1Z6dUF4WjZaN1dwV0FlMFI2MUNTbEZoMFUzV0xHczZQcVA2elRxYitrTVNveXlmdlhUaGxET3VFdFNFbGNOK0N6NlYxNjFyTk9JdUJwcU9iMDhvUFk4WktTdEZQOXFlaDJOV3JhclRLcTM0bGxIRGlyZW05UzRleVhRczhmTGFNUmJhN29HblRYR0c0K2F3NTRqMDlLOVMxazFOZjFKUms0ZGZzVzJqNmxaMVFlMnpiWEI4eU45NytlOWMrVEM0ZTVkSFRES3BhSWFtNzRUSmJML3dEay93REUvdU14UzhidVM4ZGlUWEZsTGZ2R3pxUEZIbDNTQ0FjVFhUR0hPUEU1M0xpeG05ZXR2cWR5T0V1RUVRMzNYR01Hb3hnMUdtdEZPU2JEWExTMzdDQzJHREtTQVo4eS93RHlmVWVsVGpMaEwzZno3anRXdEZEZERCemMwN2xMaTVLTHdmaFhveGFxcEswY3pkUFhaSk5ZTHFSZUIzcnpQSDBwSGk0UDJqL1U1YVl2L1VXaVg4ckFqMHEzQ1NFVTA5RVhJdldXeUFRT2VLS3VEQktLbHNvTlNObDBrREJFR09LOURHN1I1K1ZjWkExWUMyd0c0TVR6T0kvZXJXYzVLM2NCMnljU04wOFJROGh2UTA5dzdCSmtFNTV3YXkwRnV5VmlHYUpBUHJOR2hXN0MzNTNHU1RCaVNlL2VnRldHdFc5NnFONXg5N0g0MGpaU0tMSHA0MzJXQmpreDhjVnpaWFVqcXhSdU5qR3N0cXpXeno1T1FQYzFsTTMweXExTGw3cnR1TWtrNHJyT01yZ1FTU29qdnp6OHFZd1FEZW5xUUlqMW9YUnFzOFN2QXlaOHhqa2p0OEtYWXlvOFFIZ2hnSXdBVFd1ZzFaNlBXVG1hRm1vRzZ6d1RCOTZLa0s0MkRkTm9KazQ1elRXRGlhTDdEV2QzV3hjWVI0ZGwya2UrSzRQeEtkWWFYbG83UFJ3cWRtNDB0aTdyOWFiRmdBTWN0Y0lrVzFuSi93QmR6WGl5bkdFYmYvWjZOR3AvcTlQMC9TcnB0SUNMWTdreXpIMWIzcmo0dkkrVWdKVXkyNlRkQzJCZHU1ZDFrTDdkcTU4bmRJWUQxQW00TGpPUkVkNk1GOEI2TVoxbXpGN3hiUWd6OWE5SERPMXhZa2w1STZMVlc3eDI1M0RzVGtmR2prZzRoVHNsYzErcDZicUV1RGM5azV4a2o5NkN4eHlxdklMY2V6VjlINnRaMXRnQmlycTJlWnJ6OHVGNDJWVHRhTXY5cE9qM09tYWc5UTZRUUxSOHoyZDJQaVBTdTcwM3FGbFgwc3Y3a3B3Y2ZkRWgwM3JJMWlLQzhHSUtua2ZJMXN2cHZwc2FHUlRBZmFQcGlhMVRlMFlBdnFQdXlmTml0NmJNOGI0ejZIeTQrU3RkbU92aWRUYnR2dnRYVkhsWlRCVTE2a1hVVyswY2QrNzduRnVYamRRNm02eitFU3drK2xhU2pUNHJzTG5KNmw0RjAxVHZhWVhBYzVBM1RGTzhhVFZFMU50SE9vWFFFdGtNeEpBT0c3eFd3eDJ3WlhWVU9hRHFUMjBRbHlkdUozWlB0VU12cDFKdWtWaGxwYkV0VGRCdm00amJXNXg2MWFFUGJ4Wk9jcmxhSU01dXQ0bHNnTndWcHVLajdXRGxlMEtYMlVYQ3dCaUJCOTQ0cTBGcWhKUGRndkVtMzVHaW40NzJibHJUSzY0eEROdXo3VFhURkhKTjI5Z2syeUpFampQd3B2QkpCVmZjeG5rOW9nZkdpaldNRXFiZTF4QUJtUjhLM2t4T3c1dDZ2ZXloaVFZenlTTWZ6Mm9Qb0tSTUFra0tHWUErL05DeGtpeXMyOW9Gd1FCQm1NeUkvbjBwV010alhTNGExdUlBemtEdUJ4L1BhdVhQK1pJNjhEOXJHOWN3TnhOcUo5d1R1YWhEcllaYlpuTlZlaG1nRVpJbXZRUFBFZ3dMUWNjWkZOdWdhdllWTHlySWpqSEZJMDJPblFRSHhNQXFDVHhNVU5vTjJUQVVHQ1FZSEVFMGpiWXlJcmNHZHdKd1FBUkFIMHJOTTFrZDdFZ1NSQTIrdEd0R1haMWxJUUxsbkgwRkJPMkY2Tkw5ajdpYWU5ZTNBN3JsdmFNZk9COUs4NzE2Y2txOE03UFNQYi9RMkhTdGI0T2haRndXWWwyQXpQcFhsNU1iYzc4SFh5OEIrbmc2eldxclNiU21YUHFKNHBjbituSDdtV3pWNlMvNHJYTGppTFZ2R09DZlQ1Q3ZPa3FwRGxYMXZxcWxTcTlqOUs2TVdKbSs1bHRaMUx4SkRTVE9BSzdzZUtpY3BlQ2oxR3JOcGhjdHlMZzRycmpEbHA5RW0vS0g5SjF1M3FyWlc4Q3J4TUdvejlNNE8wTXNuSUhwOVRjME40M2RJeEtITEwyUDdHdEtLeUxqTVpYRjNFdEgrMGE2dERiWjhqRzAxei8rSThic29zaWtVK3N0ZjN2SHMzVGJ1K3FtWjlxNjhjOWNaSzBTbEQvNmpvWjZUMTFmNnJ3dFNDbDVlTTRZZTFUeitsOXR4Mmg4ZWEzeGxwZ2Z0UllzNnV5ZGRwbC92SURKVTRZVWZTemxCL1RsMEhQalVselhhTXcrczMySFk1WWdnVDcxM0xIVWtqaWMxUXRZdVFpd1RBNXFrMXNTRDBRMUYzZGVuYVNFR004VTBGVWYxQk43TzJyNEZ2TzR3WjVvT0RiRlVpSjFMRUVnd0IycHZwb0hNOEw1Q3lNSG4rZldzNCtBOGlGKzhHREVubWpHTFJtOUNZdTRNZHp4VmFKS1FCMjNFbk5VV2lUZGtWbjA1bWpZb1JOMHNja3hSczFEQ1FTVzgwRVl6UWNobEVPTm5sRVEyWnozajArdEt0aGxva2wwcnZGdFlnWjNIMy9DaXd4SDdiYjFtR2JCNUErZjZVbGxLcDBNZE91S2lqY0hGdVR1aUNaanY4VEZSeUs1V1d4T28waG5WYldkU3pRZGc5RDJwWTJ2QVpHZDZtZjdqa2d3U2Z4cnVSeE1HN1BldUM1ZExNQUZVR093NEZIcFVnSkVyZGtoZjhjOGlLUnlIb2pjdHNPVkVleGtpc3BBYUlidHVESWoxUEZFQndFK3BPS3hnaUZ5cDdIazBySGlIdDNzTE1la21sYXF3OTBQMkx6Z295aHBWcG5uNGlwVGdtaWtKdUx0R2s2WDFEYWIzaUZUSS94NTdUTmVabHhWUjZFWmMxbzFQUUdXL2JSTFpqZWQ5eHgvaXRlYjZoOFhiTFFqb2Q2NTFoTFZud05MQ1drd3VmenFXSEE1UGt6TjBZVFU5VDFGNHVVdUx0a2lUbXZYaGhqSHM1NVRjdWhNQjNmYzE5eDdMRVZhMHZCTjh2a0UybnRzMmJyTVAvcHBvckkxNE53dnRrMjAxdEJKMmcwUHFObTRvbmF0TVR0Uzk4QVRQYWxjbDVRZHJwa05WcEhQTGdkd1ZpYWFPUkx3Q1Z0QVZ2Nm15QXB1TGNIL0FOYzBYR0V0MVJsT1VkUFluclRjMUFCWGFqTGtIdjhBV3E0NmlKa2ZMb0ZjMW11R21heWJoWkRnL3dDNmRZOGZMbFFyelpGSGpaVmI3aWphd1BCZ1JYVFNlMGNyYldtVFhVRkY0ZzBqaGJHNThVQkY0bmNTYys5UHdFNW5SZU8yRFc0RzU2TytLTmtDTTFxTXBFV3VZTUE0L0t0UnVSd3VTVmprODFxTTVBaVlVQ2loR3pnWTVqajNvbXNsdTk1WTkrSXJCQ0tQS1lJZ2NnVUxZM0ZEQWJhcWlFQkhCalB3K0ZZTjBkQkJ6aVNET2ZiK2ZXdHNGREtnYldCWUtDQ1JBNzh4U1hiS3BVZzFsNDNBNGdjZWswUUluWXVIdzFFRHlnbnlpQ1ovNHBaclkrTjBnMm9NM1RoZUJ5SzBWb0RkQ2Q5QWJqN2p1SnhJTlZJZ0FBd09ZQWI2bWlId2VLbmFGTGdtZmxRTXliS2lxV0xlMzgrbEMvQUdnRVcvTU1nY3gzbzJ3cUtaSmZEMjdRaTdnWm1LMVBzQ3BhUjREeUhjM0o0b04vQVZzbFoycmNBVW5BTW4xcFpXME1xUVR4ZG93Uk9Ca1Z1SWJEYVcvY3RYQmNSczVCQnpJUElxZVNDa3FaVEhOeGRteit6V3Z1anB1cEc0U1hDZ3g3R3ZHOVZnWDFFZWhqeVhHeXE2eHEyTnAwM0JpQ1BNT2ZldXIwK05XbVJ6TjBWR25keGNaQ0N3YklJTmRVb3FySXB2b25ldk1waFhKRVI5MmdvSml1VEYzZHBCUjNJUEkyOTZmaXZJcmt3L251TjVYWmhISkFwS1NDcE1QWmxERE84K3g1b05KbXRnZFV4Qkg5eTRZeDk3aWpGSUZzU2RvUE0rbkUxUklEc0VYR1pXU004MHlpQzJjWnM1RS9HaWtac0RjTTRoYVpJVmdHQ2d6Tk1MU0lNdk11S0tGYSs0TTdZaW1Ram9sdXg3MXFOeU9icFdNMXFSbkk4TVFTZlNoUUxQYnNFQlJtdFFlUkFHVGd4M3JVQ3pnRW40K3RFQWExTEVqTUhFQ3RTR1RZNXBVUzQwRXppYzRxZVIxMFZ4SlNlenRnQXNOc2tiU0RJRWltZlZBajNZUlR0RzFaa0gwZ2MvOFVFdkl6ZmdKYnl6RUhIdlFabDBUMHM4Y0NhMDZEaThqRjlRMXd5MjN0QkUxbzZRWmRsZmZKVXRNa2llUGpWU0lGR1dQUG1NeE1VV240TXE4bmd6QUF0M2lKOUt6UUwrU054bXVDQ1JQWUFVRXFDM3lQSW9Fa3NDZUk5S0RzeTBFSCtVYlo3bUtGTTFrd0d6Sk1BOHpTanJzaUdWUVlKTFppdHhiTmFSRlNXSjllMktMVkdqc1l0TEVienRCK2RUbHZvckhUMlcvVE5jYktHMmNvU2UzTmNlYkR5ZG5UaXlVcUZkWnFTYjF3eUdEY2UxVXg0OUlXV1NtSytKdEtrWTlacTNHK3lmT2lWdDRQOEE1SUV4eHVwR21GMEdWMUlXWEJBR2ZKejdlMUNtSzZDSmVSVHRCd0QvQU9zVUhGbXM1Y3VxV0pET0pFZ2hmYWh4YURhRmJqZzdwZTUvL3IvdXFKTVZ0QVh1RGhpd0h3QXBsRmk4a0Q4UzMvN1BQdkF6VGNXQnlTT0c4bUkzU2ZWcUtpeFhOQzkxaGxkZ252Sk5Nay9rU1VsOEViakJ1RUE3OFVVZ04vWWkweE9WK1VaclVCc0VUN24wb3BDV2M3bVpvZ08rZ3pSQ2RFUjJvVUVpU2FBRDJlSnhuNFVhTWNYdDZ6V29BUzIwU1I4YzFxQ09hWmlYd1lQcUtUSjBYdzlrbm0zZEE5UnUrdUtXTHRhRE9QR1ZFWllBd0RNNXpUSkNoME1Cak9UaWo1R1ZVTWRPSWU0QkJBREFBRDFuTkNhTkI5bnJ6c1hKSkgwL2F0RmFOSjdGZFZJdUZaQk0ra1RWQkFNUmtSQkdZSEh0V0IwZWRnVkhsOHdOYWdOb0NKa1RFR2pZcVRDSUJJSlBIcXRLM1hRL0g1SjdRTUFuYnlmZXRib0ZiT081STVHZUtDME1SQWIvQU5wQTdETlpzeVFkSTJnREhmaWtaU0tDbFBLR2ttUFdsdndOOXlSSmRRRW5mRXhIRkowOWxLdGFBZUpQcVRGTzBTVEJPNWJ0RWUxTWxRSk5zOExyN0FBV0I3UldjVVpUZlFmeEc4SVpkcmdpRzNtSTcwbElZanZjQWt1eE1UOGExSTJ3ZHk2ekV5VGp2VEtLRWNnTGdkMm5GT1RZSTVBL1dpaEdSeHlmclJBZEJ6Zy9Pc2F5SWJQdFdOWkxjY1JQcFMwTW1jWnZMQkpyVVpzSE9LSWgwZS9GRXhKc0NDQ0QzQkVVQWtaNHJHUGVnOVRXTWVFWUhhYXhqa3lDVE1uaWFJQ1FtVC83YzBBb1BwWEtsUk9KNTRwWnEwVXhTcGplcllrMm1mYk1GU1FLbGo4MFh6UGFGeWZPWTc4ZHFvaWJxd291S3BVaGdRUkhZVXlNM1F4b2J1MWpHUUlKZ1VKN0RBR2RqRWw1RGVnQW9vRFZrcjVYK3B1WU8zY2ZwTk94Rm9WZGdDVm55KzNhalFMT3N3SjlRVG1nYm80cDI5Z1ZZWUpFVm1neGRCWkMyb0JrajE3VXZiR3VrQllkNUhGTVRPTG5BSkl6OHFBeURMYWZieGozTkk1SW9vczY1Q3A2R0p3YUhZMmtjM1A0YkxIT2ExSzdBMitpQ1hJbWZYdFRPTjlDeGxTMmV0M1FYUEFvT0psT3pzaGorczF1aHV6cElDZ2N3YTNabm9OQ1BZWXNOckRBK05UdHBxaXFTYWRpN1hWOEVnZ3lURXo2VTZpN0pPU1VRZThNY2dLZmMwMUU3UjFoS3lzMWw5ek5YMEJuTVI4Z2FZbVFZbVJPS3dHZTNEZDJqM3JBT0U0N1FNVWEwWW1DSjdmT2xHUjU4RHRXUm1Ea0RnZ0hpaUtlQkJpZjNyR09tZS9QUHJXTWM3amlnRTZCV01jNGtpc1k0ZUI2ZkdzWWtEakl3YXdVRnNrS08zMS9TZ3hvMGdqdnVjQWptQkZCSkpEU2JreUxZTWc0aXNCcW1FY20yZHNyem52TVFlZThVVUVZMFlCZHQzTUg2K2xDUThFRVZYdUFsV1FDWWh1YUptTFhHL3V1TUVFa2lhb0lESWs0NTlJNHJBcWpneWVCSHBRWnYxT3ptQ054QXdJb2cwUjN6QVVjYzk2Rkdza1RKemoxb0JHTFFKUTQyaVB2Um1ra1Vqb21aSUVTeGoxcFE3Wnk1dFZaTzJTS0tUWWJTQkVxYzRrZWxGSml0b2d6S2N3STVNOTZaSVd3YkFCeWVQWTgwUmEyRlhBT0tSbFVUVlVtV081b2tqc0tWdCtCMUZYc0piRVduTEtQTng3VXI3MFBIcHRpanNGVi93RDE3VlZLMmM4bnhUUnhWdGxaREhjY3djUlcyQktKNHdCQWtqOHFJR3lKUGFNK3RhaEd3VndBRVl4UkF5V3dNTWtBbVRRczNFNDZrRGtHaW1LMEVSQ3drUkZLMmlrWXRucnlBSkkrQnJKaG5IVm9CbUlIZW1KSEk5Y0NpWTl4OWUxQXg0ZmpHS3dRbTN5VEhlbHZZL0hWa0k5aG1pSWN3YXhqb0h0ejYwYXN5Q0tRb1luTFRBaWxmWlNOSk5oTngzQXpHUU9lS1doN3RrNzBiMU9HUEpFNGsxb2h5VmFJQnR3VVFNZHFhaExzUFpiYWNnY2pQenJOREpod2pHU0p5WnhUcEFiQzliMFZ6UzlRMUtiRkFEVGowSmdHbmp0RW5MWWtxZ2d3OGlKSkk0UHBXY1FxUkJvM0dTZm1LQ2lGeVJLMnVXOE1rbmpCaWF6UUUwVGJUc3FCeXU0TVlHZStLSGVodWpoVGFBU0FTVzJsUWNnOGZEdFc0c1hraVJ1UXhRQmlaL3lqc2FIQWI2aU9zNU1TVDVwZy9NaXR3WWZxSUxvOUsyc3VQYXQzTGF1aUZnSG56RWRoajg0ck5VTHlCRzBIT0NEanNLM1JnVEtGQmtTTTg5akZHaldpVEtFYUdVaG9CN2NHaFF5YVBLWkhISGVLWGlQeUo3VVpCQk9QYWhUQmFZeDRZQ0FzM2xBK2xLb3NyelNSQmRNeklYU0NKbGV4RUhtamRPaEdrd1g5SmNjbVlCNzhabzhraE9KRnRJd01kNG84a0swUWJUc1dDemswVTBMWGdoNGM3UVQ4S0lEMXUyUzZvM0p3QjcwR2dvODlza2lJVWpCRXptYUlIc0lWYmFwSkVZZ0FVbElyeWRBN2x0eHVRa0F6bW1TRWIxUk1XRTJHUEVjZ1IyQStYZWpURXRDN29WKy9JWWlqUUNLS0RNc2R2ckZhakhWVlpBWmpJOXVLM0VKMFNGZ1JFVEorRkx3R1U2VkVCSjNHVGdRWnB1SXRuQXVESU5hZ0h0cEM3cEVBd2ZXdFJyUEhFKy9GTFFlVkVtdUh1QURGYmdNOGw3SlNXSnljY1VWQXpuYnNtaWlUTTQ1UHBSNGhVaVpscEtrbk9UM29xSUhJMVBRK2lhWFU5UFM5cmcvaXY1Z0ZQK0p5UHpwSlNhZEkwZHJaLzlrPVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3B1YmxpYy9pbWFnZXMvZGFWaW5jaS5qcGdcbiAqKiBtb2R1bGUgaWQgPSAzMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU1nQUFBRkhDQVlBQUFEa3lRTW5BQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSVdYTUFBQUJJQUFBQVNBQkd5V3MrQUFDQUFFbEVRVlI0MnV6OWQ3U2wyWG5lQi83ZXZiOXc4czMzVnM1ZDFRRWQwTjFvWkJBZ1FaQUVLUUlNSWtWUm9tUlpsdTNsc1VjYXJXVnJMTThzengrV3g3YVcxNHc5OXRnZVJ3WFNJaWxSSkNXVEZFR1RvSkNJUnVnY3Fxc3JoNXZ2eVYvYWU3L3p4M2R1VlFHaWFNc1N5V2IxZmRmNlZsMFV1dTY5NTV6OTdEYy9qM0JnRDdMSjcvSjNldkMyL1BPOWdRZjJSL3V6bE4vbHVSOGMzLzRjZ09iM3NPamdMWGhnd0xILzJQc2VJMkJBUkVGQkF4QUFmOTl6QUpJREQvTEFtNWs5RmtpQStMN0gzSGY0QStDQUNpaG5mL3JaMzRlRHQvR2ZOSHZ3Rmp3UWw1eTlEeHdwMER6ZFcxd1VwUGZvL09yeHgrYlhIbzJUdEJNWm80MG9TakpYNlgzL05oeDRqNE1RNjkwQWtnaEluMWs3dHJacW0rOTlaSDc1MHkvdmJIVVc0dWJhNlU3djFGSTJ2V3pudUxJMW1reHZSdGx2M1BIOXIvZW5vNzM3QUtJSFFEbndJQTlxZUhYWGUvd3JUMzdnaDFZay9xc2RpVDZRU1BUd2RwWWROVUhiUmVHT2RhUDQ4U0wzVHplaTFyTkxTOHZYYjR5M3JoSlU3d3V6RGdEeXU3eTVCL1pnZUJBRFJBdXRkcmNUSjZ1aklyZnphYXFwamRRQjQ3TFVZWkVUVzlGWU9UbmY2RHc1MTV0dnovSVVlNUNQSGdEazNmQlp5c1YrLzJyaC9mYlVWUmdSYVVXUnhOYlFpQ0laWkRteEFlOGNzYkVYbHR2emN6UFBFKzMvKzRPMzhRQWdENXJweklVb3dKZldyOTJhNzNSdU42SUlBeHp2ZEltTlliNlJJQWhwWkpIZ3RacmtwMXNtV1o1NWtBT0FIQURrd1FhSnpzcTBGM2ZXZDUxd2ZiSFZZbHBWcE5ZU2kwVUJZNFJLbGNoQ3FNSnlOMm1kd29nVmtRT0FIQURrZ2JhN3piOHNtMDYzUXZuR1FxTTU5dXJ4R29panVoYVRpRVZFSkk0alhKNTNOQzlQUmNaYTlGdnlrQU9RSEFEa2dRdXg5aXRSRGlqZkhnOHZKWkVkb1lHc3FtZ1lRek9PaUt6QldFc2ppaGlQSjdMUTdKMXNwYzJXb25jNzd3Y0FPUURJZ3dxU0lETXY4c0tkR3plck5GazNvSnVUaWJiaUJBSWtWbWduS1JxQ2xHVnBFcUxIbHVlV2wyZmdpQTdPd3dGQUhtaUFLRlFpRW00TWR0WmZuNDYrMEVvYTFTRFBHVlVWalRpbUNsQlVKVDRFckVBMm1wdzRlK2pFazRBNXlFTU9BUEp1eVVNcTU2cnk0dDdXU3d2dDlxUWR4VElxQ2xKckVZRnBXZUpDd0ZxajVUUkxtQlNueEpoSVZhT0RNT3NBSUE5OEhxS3FGZUN2OUxldStHWjZZNjNUMUlCWEVaaExFMklqSkZZUUVZbzhpOUlRblZwYVdKb0RyTlJoMWtHaWZnQ1FCemZNbWlYcWJxZkk5dlo4K1VZM2pqVTFocWwzTktLWXhGcGFzY1dnSXFwR0MzZDJQdTJ1QVVZUDhwQURnTHdid2l3UmNUdkQ0WFJqT241MXZ0Y3Joa1VPUUdRTUlvSXhncW9TZ3BKUHB0M1Y3dUxoV1pLK1g4MDY4Q0FIQUhsZ1BZZ0hTalM0WFZlKzVhM3NpQ2dpcUVjUkJCV2htVVJVM2hNcXY3elVtSCsyMiswMTc4dEJEdktRQTRBOHVGNUVWVDNnTHUvdTNKbXEzRjV1ZGFTb0tnS0tBWm8yb2hWSEJCUmZsYkVmVHg5ZVcxeGQ1RnZMdlFjQU9RRElnNTJIWE94djd1MzU4b1g1VmpOWUVVbU5KYmFHWHFOQnE1R1FSSUp6am5JOFhXMW90SFJmbUhVQWpnT0FQUEJobHN1bmsreldaUFFLTnRvNTFPM1JqaUlVSlhNVmtUR2trYVh5amdpemZMaTNmQm9qOGJlQlJBNEFjbUFQSWtqMngwN2MyK1ArRll5NUZSc2hLQ1Ftb25TZW9JSFlXcHdHeXJLYzg1UGlqSW5zL2FQdkIyZmo0RTE0NE1PczZ1TE94bVlwZXJWaGpIb05HQkZjVUl3SVNXUXdJanFkWnNZR09YdHM4Y2o4ZlhuSVFaaDFBSkFISGlCK1BCME5kMTE1S1k1dGtWcExaQXlKTmZUU21JVm1Tak95VkdXRk9EM2JOdkVpMzFydU5RY0FPYkFIeXFTKytSWHdBZzdWNnMzcCtCVW5aanN5QWlKWUl5UTJJcktXSkRJUzFPT3liTGxsRzBlTXRmZlRCUjE0a0lPMzRBRURpQmdWSkZBUEx6ckEvL2JsMXk3dGVuZE5STlNJa05vSVJUQUNyU1Npd3F0enZudG9idm01dWQ1Y0lzaitmb2dSRVZGOTkzSTVITENhUEhBQUVjU0lvQ3BTZjc2eEM5NmNYVDU4OGtTU1B1bENNSUJrcmtJUWdpcWowcEZYcFN3c0xGWWppaS9zRHZkR0lsSUJydFBxaEdLMzFNOS8rZk1ISHVUQS91aGIwTUJpdTRlSXFJSVh4R3NJK2VYaHppdmUyaXd4VmlKamlLMGhzb1plSTZHWHh1SzhrM3cwUGRNeTZUR2twaElTRVZPNVNsNTQ1WVYzYmNKK0FKQUgwQ0licVlnRUVmSFU5S0podDh5dWw3RFpzb2JZUk5xS1lsUkJFQ0l4QkJXZERrYnRsYzdpV1VFaVp1UHZ6anQ1K2JXWERuS1FBM3R3YkwyL2pROWh0a1NsRmVDdTcyM2YzcWpLTjUxcW1QcUszSHVjS2xQbnFEUmdSY2lMSW82Y25vdWlLRldJVmRXR0VPVEt6U3NIQURtd0I4dU9Iem1CaUtpSWVCR3Boa1UrWGEveUZ5V0tRbW9ORmtFRUltdHB4UkVJNUtHeVVUQm5qNndlV1ppRldGWVFBM0RrMEpFRGdCellnMkgvNWsvOVJRNnZITWFJdVgvTHNMb3lHYnc4c2VabTB4akpOV2poSFU0RDdTUW1zVWFDZW5IVDR0aGMyam5Nak85WFVXT05OU0p5QUpBRGV6QnNxZEhrL0pGVFdHTlZWWU9xT3NCZjNycDliV015dktqR1lFVXdZaWk5UjFYcEpBa21pRTdIazk1eXMzY2E0ZTRhcnFKTXAxTTVBTWlCUFJEV2lHSysvdm8zRlhTL0orS0JhbHdWV1NieWRvbUVUaHhMSzQ0UmhGWVNFMXZCSU9KYzFXdHI4dDRvU2RxQVFldCt5TjVnNzEzNVhoNzBRUjVBKzl6em44ZUtZVEFaWWNUczY0ZEVwYXVpazNQTDNhVWsvWkFOTkVzZnFJS25HVVc0b093VkJlSlVndW80V21oOWFYZXcyeGVrTW1MY2JNZmt3SU1jMklOaEczdGJuRnc5UWh4Rml0eWQ3cTAyZkhtOU10eElqTkNJTEZZRUh6eWQyTktLTEhsd0dHTlgxbnJMaDJmaGxRMGFqRWlkclA5N2YvSGZPd0RJZ1QwWTl0ekRUekhmNmFuY0k1VnpiMjNkMmh4VzVYVTF3bHlTTXBjbXFNS29xRWpFVU9LcGltSTFMam0xUC82dXFsWVFXVnRabzlsb0hnRGt3QjRNSzZvU2F3elVjMWtlY052ajRUaE5HNWNkVWtURzBJeGlQQkJGbGpReXBNWlErcXFWcWozYjY4MDFnVWhFcktLU3hJbGN1WDdsQUNBSDlxQ1lzalBZVTcxL2lTcUUvSFl4ZVdWSzJCNVZKWWloRVVjMG8zb2ROOFpva1pmRzVlWHBsYzdDM0w0SEFVeC8yT2ZWaTY4ZUFPVEFIZ3o3cFMvL0JrK2RlWmhHbktqYzJ4RUp2M0gxemRmSFZYV3hESUUwaW1qWXFGWmlFNGlOa2FvcVFYbDR0Ymx3bXZ1SUhMSXNrNisvOUEzKzZyLytWdzRBY21BUGhoMVpYS1h5WG1kTnc1cFVicmczcUNKN1RZWEtpaUxHek1iZmhXWmtpREJNUjlObHluQTBUcE5vQmhDcnF0SnFOT20wT2djQU9iQUh3N0l5WjJsdUVRUi8zL0JpY1RzYnZUTHhmbHA1VDBCQjlPNlNiV0pFOHl5M2FadytNdGZxTm1kaGxwbFZzK1MxUzY4ZEFPVEFIZ3o3MVc5OGtlVzVCYXlONmkzREdVaXVETGJlRG5IY1YxV2ExdGI2SWFhV2FFdXN3VlVWVW9ZTHZXYTN1eDltcWFyWkcrd3hLcklEZ0J6WWcyUE9PWFhlb2JWVlFOak9wK3RKRXIwdVJvS0FOcU9ZSklwSVlrdGtEVDZVR0dSNXZqdS9LaUoyOXBqSVJuTDkxdlVEZ0J6WWcyTWlzaS95ZVplN2QzczBHTDZkamI3Z3hWUXhDRnJUa3Raa1dDb0EwK0Y0eFhqT0dXTXNxakYxNDFDS01wY0RnQnpZQTJOdlhML0U2dndTNXI0bHFoQjhkWFZ2NityQXU0a1ZJYkVXcEJiNmpLMGhGcU9UNFNUdXBkM2pOb3FTZmVaM1ZUVTMxMjhkZUpBRGU3QnNhN0E3eThUeCs5TzlnM3h5VzYyOGdhQ05LTkpHRkdGbmpJdVJNUkxVUmVUK3ZZdmR4VVhxS2xZa2lCa09CNnd1cmg0QTVNQWVIUHZocHovTVFydTlyMlhvQUxjeEhlOE1nM3NqaW1Nc1NzTmE3SXlCVVFSUjllSUxkKzdZOHRIemRhUW0wWDRsUzlFRGdCellnMlBuajUzaTBXT25rZnVrMm9xeUtIZkwvUFVTaG9tMUVrY1drVHJFU293QlJhdkp0RkZseFNFRWcycWtxbGFEbXY2b0wzL3NlMy93QUNBSDltRFlRbmVPbmZGUUZWUnJrRlJvcUhheThTVW5ZVE94bHFhTjZDWUphV3hweEJZRDVObWtzZFNhT3pNM045L1dHVmVXenBKNDc4TUJRQTdzd2JDaUtubnQ1bFVBblNYcUhxZzJ2ZXRMRks4bjFwSmFTendMczVweFJHeEVoQkEzZ2puZlRwdnpnQkhFR21OTXA5MlJicmY5d0w5dkJ3dFQ3eEw3alZlK3Z2K2xHSE4zaVNycDUxUE9yeDVkblJmemxBc2hMcnluOUo0cUJNcktVemtJSWxQcEpGL1ozTnZhQUp3Z2xhSStqaUs5dlg3bndJTWMySU5qWXMyc1gxaXJVR2xWWnBjbS9WY0NiRGVNcFJGRkpNYVEySHFoS3ZpQWQrSEkwYzdLSTlTY3ZWWlJVNWFsZk8yYlgyZHhmdkVBSUFmMjROaDdIbjZDSkVscVlybFpOZXZhWU9lV0pORkdMUkVkYVNkTmFNUXhzVFVFVVlvaWJ4WER5VXJVVEw5RlArVGR3TnQ3QUpCM21UMTIraUU2cmZhM1NDVGM2TzlzVFFsdnFXalkxeENKVEwwbkVobTByRXFiaUQxLyt2REorUmxBSWxVMWtZM0VSdllBSU84Mis0a1AvTXVjUC9Ub1B6MU1FYUhYbk9PcDA4L3d5U2UrbDBlT3ZZYy8rZEUvOTBjanhCSmhaMjhYRWJuTC9sNWwwK2xta1Y5UGpNa05Lc2FZV3FJdHJoTjNjWTVJNVpIamM2c25tVFVNVmRYNDRKbGtFLzdhdi92L1BBREl1OGw4Y0tnR29lNlg3V3YxR1VIMkh3a2F4SGtuV1pseGZQa1VwMWZQY1dqaEdLZldMcnlqWDl2UC9QTFAwbW8wVlZWREhXYUpBNnBYaHJzdjJDVGVpMjNObVJWWmd4aWhtMFppUWlDZlR0ZXFVWDVLckVUVWE3Z0dNS2VQblpFSG1WVHVvSXIxdTlna0g3TTkycFFxVkNJaXhvaXhSb3hGeE1ncy9pNTlKVHZqYmJtNWM0T3lLaVN5RWFOaXhOdDNYbWUrczh5SjVVZHdya0hoK3UrNDEvZjlILzRVdDdidVNPV2NtYTNUSmc2Tm4xbzUraUVwcThNQndRZVYwanMwS0tQQ3FYcml0Tk82UHRUODYxbWVGU0pTQ2VLeUlnOXJLMnU4OE1vM0R3RHlickYrdGtmcFMxRlZNM3RFVlEwd1kvbW9KY29VRlZUTktCdklwZlUzbVJaVGpCaHBOM3IwbXN0TTg1S2pLL004Y3Z3UmJtemRlTWU4dm1jZmVaSmJtN2NaWnhNQnJFQ2FWV1U0TnIrMGVEUnBQSk03YjFWVmdnYXFvR1NsbzNSQk92Tnp3NzRiZjJFNEhVMkFFc0dWVmVtLytZQ0M0eURFK3Q4STEyY2hsamwvK09HbHMydm4xbVpBU1VEYklyUlJiU25hQ0JwU0Yxd3lLVVpSNFFxek45NHlOM2Zla2xGK1U2eXhmTmVUMy9VdDMxWkVtR3N0OHZDeHAzamZ1ZS80UThoRElESUdFZGtmZjYrODkrWHQ2ZmkxTkk2bVRXT2tFUm5FR0FLQlpod2h3ZU95NGtTMzBWbENKQktSZlEzREIzcjAvY0NEL05OdURqR2lxQUdSSDN2Zm4zbmlleDcvd2IvOHpOa1BuaFpqUmxrMThWazVOYXJhb080TjNKVXNBelVoQkNsY2hnOEY0Mndzdi9YU2J6RWJ6NUI2NWs4a2lSdlNhZlRFR012bStBYXhiZUNEK3dONWJTOWRlbzNqSzRmWkdlNEo5UWk3QmRKbUZKdUg1NVkrMG9CbHhEQjFsVXlyQ3U5VkN1ZTAyKzQwb3JuMkc3ZjY2MjlvVUtlcWxZaTRwY1VsUHZUZUQzSGx4cFVEZ0x5TC9JZk1ic2pvNU5LWi9rcjM2UEhsMXFGLzdhSFZ4ei85ek5ubkhqMjJkTXdpWVpwWG1SUlZZV2NnMlZlSUZXYUE4TUhYaURDekJML09ZNlR5QmNOc2o2M0JiUUhEZkd1Sk5HcVFWOU0va0plWFZ3V1JqYVJ5N201WFBZanc2TXFoc3gzbFBabHpsQ0ZJNlFOQkE4NnJGcVd6VWF1NXRWVU1mNmNvOGdxaEZNU2hHbzRmUG40QWtIZUxKVkVLcUtpcUFPYjFPeS9MYTdkZmZQUEkzSWxody9hK294bk5mZmpvM0ltUG5GbDUrSm1Ianp4eCtzTFI4ejBNYnFOL0o5ejN2dDROUFpSWkhvTmFCTHVmMXdUMUV0UWpZbEFOUEhuNi9WemZldnNQNURYK3BSLzhDUWFUTVp2OXZYMkF4TGwzOXBHRjVTT25tdTBQWldWcEFDbUR3d2VZbEJXVmN6Sy92RkxzdU5FWFJwUFJRSkJTakRnUkUwNGRPNldYcjE4K0FNaTd3WjQ2OFQ0bXhZVEM1WGZ6a0VreGtwZHVmZVBTZkdkbGE2bTcvSkRSNkpnSmpXUEw3YlZuankrZCtNanA1WWNlZis2aEQ1ODh0SERNWGxwL2F5OEU1KytHL0hVZE5HRy9YQ3lTM0FjZ0JTV05teXpQSGVMbTloL01MZnllRXlmWkh1eHhlM2RIVk5WSTNmeUxqNjJzcHFmYXZmZTVzbG9RRWExbVhxUndRVFNvSkhIQ1FLcmYzaDN0YlFwU0FaVVBQdHpaMnRiS0ZRY0FlVGZZKzA1OWtKdDcxeVd2TW1hTFFTS0lxWHhoMzdqenpXdTlUdS95NnR6cTBXYWNIczdMU2dqU2FNVzk0MHV0eGFlUEw1OTQzL3ZQZjNCcGQ5cS91ZEcvTlRJaWdxTC80Wi8rajUvK2s1LzRrei9ZNlhUMlhydjY2bmltdmJHUElGVlZQYnA0a2h2YmZ6QzM4TFBuTHZDTFgvMENSa1RDRENCQWpMRTgzRnQ0dkdQc21YM1ZuTko1blBka3ptTVEwMTNvWHJteWMrYzFhZ3FoU2tTY2F0RGYvdnQvbkxuNUZDdGRqcTBlWTNObkR4LzhBVUFlTkR1MytqQTdreDBLbCtPRC81WXFUZEJnWHIvMTRwM0NWMitkV0RtMjBtMzJqbXRRRTlUam5Vb2k4ZHhLYi9IeFUydW5reSsrK2NYbksxK1VBQ2RYVHNibkRqL3k1OTU3OXBrL2NXVDUyUGpObTI5Y3o4cXBBaXBpUWdoZWIyNWZtN0dFL3Y3YjE5OStrek9yUjZpY28zSk9acnNleWJETXpiT3JSNDh2bXVqWnlnWGpnNUtKTXJmVW83TTBwMHRMdlhpaDFhaXVEYmEva3BYbFdNRFZIZm1nUC90TEYvbjZpeHV5dVRXU25mNVE4cUw4SXorcmRRQ1EzOFhlMm5pZEU0dW5HZVo5Z3ZwOUw3SS92eFFBdWI3ejl1RG0zdFVYank0ZlRWZm5WazYxNHJnUlVQRmVpYXl4am5MdmkyOSsvamZ5S3NzQitlYVZid3lmUFByY29VUTZQM3A2NWZSM0xIUVhiLy9PeFMrL0lRZ0lBWkhRYm5RcC93RERsSlhlUEp2RFBaaDF4WUU0aEJBOS9kQ1pJNmVPclgyd3VkeExXeXZ6TEo4NndzclJWWHdJTXMwS2lZejR6Y25vZDdZbm95M3F2WktnaWxTVk4xVVZiRms1VTVTVmhOazB3dDJ5eHdGQUhoeWJheTB3eW9lb0JyVG1yVldwU1E4Q0VBUmhaN3lkdjdYKytxdUhGZzhWYTR0cnA5dHAwb21NNEVMZ3BkdVhYL3pTRzcvNk9hQ2MvVHVtMVdUcjVPS0Y4eUUzanpiU3R2L0twUzkrdnFpeWNsOEZxblQ1SCtoMXU5RHAwVzZuWkhraFBnU3pYNG43NkhPUHJYNzRRKy85NE9MaDFaNXBONG5qaExKMFZNNlJaUVZKSEl0RTVvMkxtM2V1M2dzVGlVQm1KVy9acitiZDMyZlRQNG9nT1dnVS9oNWVaRktNVUpTZ1FZVjdpckZBcnVoWWtOSG1ZSDNydi83Y2YvWXpYNy8rL0g4YnhHOTFXakdqYWxxOWRQdnlCdlV3SUlxcWdQM3FXMS9hZVBIbTgzOXJXcnJkM1VHNW1NVHR6dXd6K0VOcHVGMWF2OGtmLys2UDBPdTBkRVlKNUFEM3RVdFhibFMrMm9pc3dZckJSaEdOWmtxcjJjQVlpRVRtbDVxdEo0QjVFWG9pekt2U1ZkWE83TSt1cW5hQUpwRHlMZVh2UDFvV0hVRGg5N2JLVmZWTllvejZFTlNJMVVBdGZLblVBWFplWnVaLy9zTGYrT1ZZckh6dzNBZit0UnZEM2ZqbTd0VzNnV0oyYzZyVzFhejBIM3p0NzN4anNYM2sxN3pwUGxwNmJWSno4UmdSNU52VGo1LzRsNTdqeWx0YjdHeFBzY2JndmNlSEFCcFE5WGUvc1hkSzJvaUpZc09icjI3OU03Mit5WGhNTTRucmx6T1RTSGpoN1d1N2xZYWJuVWllcnRsTjZsL01Sb1pLQTc0cVRTVG01Rks3ZTJobk1wTEYrYlJ6K0ZCcnJwRkdhWjdacVdoek5KbFdneXUzYmc2QmZQYVVzd3RENy9Nb0J3QjVVRXhWQ2NGei92QlQzTmg5TXhSVlVXbDljZ3dRN1k2MjVXOTk0WC80aFc1bithRlg3dHo2eUdoODUyWjlJRVJBRFRPZGpST3JKeGMzc3VIaTFtVFVia1NON29pN0RVa0F2dk9adjhUdThCb3Z2UFgzK1A0ZmVweS8rN2UvUmhSWmxwYTZuRDYzeENzdjMyVFlIM1AyWEJlUDB0OHIyYmc5Ull6aGhlZHYveCtLc2JmN0l4UU5zeTNETUJoTlI1YzN0bDc3MElYRlQ2S2hWWmE1Vks3Q0dLSGJickt6TjhCRTlzaWpwNWN2SERxN2RQN01pYmxuMTVibW41NXZuMmlzenAvUE82MjEzWjJkNG8zLytxZC83bi82UjEvNTdZdjNldytST2t3OXRMekc4YlVqZlBXVmJ4d0E1RUV3SHp4LzZxUC9WeDQ3YzBGWGw3cThmT1VsSFUxSFh0RnFka05hSHlwemRXZkQ3VTJIWXlOaGMzWW9aQmJicDZkV1RzK2ZQL2JSUHozSW8rL01mSEhMeHEzMHZ2QktBSnJwSEdlT2ZvZ1gzdnA3L04vLzhpOUpOaTJaVGtyUm9QejZyd1RFaUJnREw3K3dQcnVGYTltQ3BHRTFTU010aTNwY0pVa2pvcWpHM1hSUy90T0JEMlJscWFwNmw1WlVWYXUvLzRYbnYzNW1kZTFPNXYyNVlaWlI1RVdkeTF0aFdwWWthdGErK3hPSC8rekpDL0dLMWVYT3ljTlBtZU9yajlMcExKTTIyOGZIaytxeHdXNnh1TDNULzArLzhkWkxiOSs3WnpRWVkxQU5JYW9KdFErUzlBZkZYcjcrQlo0NjkxNE96eTlUK1lvN3UrdUlpQlhFQXZySXNZZVhUeDE2K2k5YzNycTlzenU0OUhOVk5YSFUvMSt5MUYzcVBuUCtlLy9FcUdyODVLREkyOVpHL2RGay9YT2o4YTA3czlDakZERmhXdXp4d2x1L0lDRlVwcjg3TmVOUllZdkMyYkwwa1hNaHJpb2YxVjlyNUp4YTUwSlVWY0hrbVpQZ3c0eUdGMnhreEZwaE9pbTU4TmdobXMySUV5Y1gyTndZZjh0cmV2Nk50OW5mNTdER21EQ2J5N3A4ZThOOTlNTDV4N05wZWZiNitoYjk4VmkyQjJOdTdleHhaMnNYcHk0K2RhYXgyRzR2cE04OThRT2NXSHVVS08xSjFPaGlralkyYlpuQnh2QlVRK1BlamEzYnIvYkh3NXg3bkZ5aHJFb3RxNHIzbkh1VW14dTNEZ0R5b05nclYxL2lQU2Nmb3h2UGMybmprZ2toN005aDhWM3YrZTdUUVJZK2UzMzN4bHViTzYvK0w2bytCcUpHMG1nK2MrNjdQK1hONGw4WWxXNEpBVEZSZjNmM2pWK2JaRnUzbVMwdEFXRTAzWlNnNWQwOURSRVNWVktCVktFeFMzb2IxSjM1QkNGRzd5YkJsdjFkOGFDNEtraDNya21qR2ROcHA3ejY4aDArL0IxbnVYSHRXelhQSHo5NWpLd3NwZkplMlArNUVIMzQwWWVPbjE1YWZDYjRZQTBJd2VPcWtqeWY0aXBIbzlYbXVmZC9sSnMzSi9MYTVZdHlZL3NLVjI1ZjVQckdtM0wxNnV1eWZyc3ZhVWhQclMwc3k4VmJWMTdKaXR6dEF5VE1rcmpsK1VWdWJkNDVBTWlEWkM5ZGVabXpxdzl4ZWZOdDQ0TzNzOE1xUC9Eczl6L3JwUFdwR3pzMy85ZXQzVGRlRktGaGpZaysrUENuUDlacW4vNi9iRThuaHhSVkVSRnJvdDJkM2RkK1pacnYzV0Uyc2tFOTRXaTFabEpQUmFTcFNuTUdpT2EzUGZ0Z1NiZzNVZnhQbEZlcjBqUG9aNFNnY3ZUNFBNdXJIUzVmMnY2VzEvUHdzY1BrbFpQaE5CUEFHcEZVVmVOZU01MTczN25USDh0SzM2eWNRNE1uK01Cb21qR1k1TVMydzZXTkxiNSs4V3RVNlE2dEpVK0lSb3dudDdoNjlSV2UvK1liMG13c3hFdXRoVk5yaXlzNzM3ejA2a1gyU2VzZytPQjFuRTAxTC9LREhPUkJzOWR1dnlvdStObElmRjJxWGVqMWpsRTJxckxZZWdFTkRVV1NJMHVubCtaN1ovNzQramcvWEplTHRiN3dOUXk5TDBiZjFpT0lGWTFFU0ZWcHpNWlIycC8rekpNbkx6eTZja29EN1RpMW5TalN0Q3ltVmI4LzZtOXZaTnRYTHcvdVhIeGpkeWViVnNNNlZLTlNKUWNLVlhXaStKMmRTUkFSUHZmR0czcmlUSnZybHljOCs3N24rTnJ6WCtYU25VM3BUNmJVQTVYMUpMSkM5TWF0OVZ1anZMalJhVVJ6dTMySEN5b1ZoblozSGt4Q0pKWmpKODd5RTkvOTV6aDYralM5OWdJU1lEclk0dTAzWDJIOXlxL3c2cFd2OCtqeDl5NmVYanY1eHovNDJETXZmT21WcjcwMEEzVVZRcEFzbS9LWmozMFB2L2pidjNZQWtBZkozbDUvcTk0WnFUY05MV0NicHJXNk9EK3Y4NGxPZ0Jhb25lc2VlMlRpNDhjOGVTM1JvYXJXU0pWTk43NHhubTV2TVB2TC9kdS85aHJhYURUajdrLysyZmMvOVlFUG4zbHVkYTMzd1ViTG52RmVXMEUxOXQ2VFRmdCtNdDNMODRuckQvYXE5YTNkOHVhTnErT3YvZVBmdVBMRmpUdWoyMEFzUXFSS3JxcVZCcXF0elZGb3RpTkVSRmRXbGpER0VNZXhyTy8xUmNIby9qeldqTGtrN1dZdGFlK21ZVytPWUF4eDJtQXhickN5c01ERnkxZDQ4aU1mNXMvLzIzK1ozc0lDUkRGVURueUFoYU1jWG42SThhMkluLzlmL2lkZXZmRVZQYmY2dnZQdnYvRDBIN3UrZWZQS3pjMzFmUFl6M05MQ292QU9ac0krQU1nL2owbTlINmlxckhSWDU2TFFPTHpTWGp6NnNVYy85cDB2WGYzR3IxYStKSWs3aDhvUUVsQkZEQ0U0SVZTM043ZGYvVWVWend1UU1Dc0RXeEZwQUszdi9PUWpKLy9WZitzN2Z2TFFrZFozeG1seVdLVVJWNVZTVlk2eUxIRFZCSWRFY2RMb0dGTjJra1o4ckRuWGZMWTMxLzc0L0VMblU2Ky92UG1ycjcxMCs3ZjJkcWRiczg5NFdzOE1VMVZGQ0ZzYk9hMW1xbTlkZkZPQzl5YlVJSS91aG5YUWFhUjBmL3pUSzUrYVh4NmZ1clBYazZXNWVVSVFodE1wZzlHSXM0OWM0SHQrL0VlSnJXVTZIT0RMRXFPZ0prSkNRRUtnMCt6eXlKSDM4Y3F0TDhtYk43K2VIbHQ4OUgwWGpqMTArT2JtK3U0KytZVUF2Zlk3VnhUMEFDRC9RbUNDSGw0NFBDOXFqd2VueWRPbm52Nng5NTM3eVBxWDN2eGYzeEFOemNWV1Q2YjVDQ05HQk9udjdiNzEweHU3cjErYVJWZDFHVmhJVmJYNXAvNmxEejM5VS8vS1IvKzFsYlhlQjN6bGtxSlU5UzZpS0hLODkrU2xKNnZBbURtY2VQSlFVbmpSekNzYW1mbUY1ZWJISG52ODBKUEx5KzJQdlByeW5mL20wcHVicjkxWFNzYTVVTG14K2lMcmk2cmVMVEpJblhlMFZMWFRhS1NOUC9WakgzajhveDgrOTEySFZ0NmZIRHE3ekJlLytKc010alp4d1RPM01NZUhQL3REbkx2d0VGVmVvQUY4UHNXbURiVE1LYVlady82WTIzZnUwSXlhUEhQbW8zenQwbTl5WSt1TnpuUmF0ZXR6VjJ1dlQ0dE1GaGNXOWR5eHcxeTZlZWNBSUErY3pZS0RFeXNudW9qdFRpY2x6bkhzanozOTJaL3FaLzMvYm4zdmxudmtWRnVQemE5d2ErZjY5WjMreGI5N2ErdUYzd3pxOTV1TWRVaWpwSi85MGFjZi9uUC8raWYremU1aTV3TlZKWWpHQ0VIcWtYRkxUYzFlWUNXaGRCbWxMM0JBb1NLWkY2b0FFaHVhM2FpM1ZMVS85ZmpqUnhaYXJmZy9mK21idDc3QnZXRkxCZFVRQW5xZjUxRFZGdEQrc1IvLzBZZCs1RWQrOUhzZU8zZjBrdzB6UGJxKzlRcDcyWmRaZm5TYkpUSGtFNFhTWWVkM3VIYjlCZkxwRmxteGgwaVRibk9WaGM0S3JlWTg2VFJtTkJ3d0dBMDV2SGFJOTV4NkgxOTQ3UXZYWHJ0eGFWam5Xblh6c0Q4YThqLzlnNS9oNS84Ly93bWYvRFAvK2dGQUhrQUxnRTdkZENwR0psbmhxTHpuY1Bmd1kzLzZZMy8ySjMvK3E3OTA3YzNiYjhwRGg4NXpiam0vc3J2N3hSZExsd2NSU1ZTMU1idTU3ZmQ4NXNMcGYvVXZmZnpmWEZ6dHZVOTlyWVZXT3FVS2x0SXJrS0Jhb0NGQThHVGxnTXFWVkI2cU1oQ2NvcUVPNWsxa0pHNUd0dG1NUDNEdTNHcmJXUE1mdnZDMUc4L3ZsMWlCTUdzTTdnTTArY2hIUG56NHIveVZmK2Q3ejUwOSsvM3pMZmYwN2F0ZmlPN3NmbDRrMlNSdXhVU3RGb0dVcEF1bEczUHh6cTh4ZVRNd0dnOXgzakhYYlpPYUNMUkZJemxPVzA4Z0lxZ3EyM3Q3TEMwZTVzbXo3OCsrL1BKVnVNc09VM3NSVmRXLytRdS8vSTdNUXc3S3ZQOThvZFYrRlN2YTZHOVdqeDEvVDNlcHZmS1VNZEtvbkdlK1BYL28xTnFwWTVjM0xqYzNSbU43Y3VYQzhsT25uamhVdU9IVmpmN3RvYXJHSXRKOC9OeGpSLzZWSC9tcHYzQjY4Wkh2ck1hSkpRb2lLVlRlVURvSUNzRTdwdm1FckpoUWxEbVZtOWFMVElYaWk0QldpcThVNXhUMWlpcFM1bzRxOTZ1ZGJxT2JGOVhMZzM0Mm1ZSEUzM2RCeHAvNjFDZVAvTWYvOFYvL1B6LzN6RE4vYnJyMTFiTzNyLzEzcHRJWHNlbFVUSndTbU1PRlFGVmxsS1hIQjBOUmVYSlhNcDU2K3J1TzZiaWljQlhEVVo4cjF5L3pqUmRlSXA4SUM2MEZYT1VvU3NlUjVVTzlkcWQxNmFWTHIxK2pIb3lzUk1RSFZWM3NMWkUybW16djdod0E1RUd3eUVUN0FCSEFWcjZTYXp2WHJ5M1ByMWJ6blpXSHFrb2FSVjdaWHRwdVBIYnl0SEVoNC9wd25DUjI1ZGh6RDczdi9OSGxOYi9ldjlWLy84UFBuZm1Mbi8xTC84WXlweithM1d4SCthMnVqRysweUFxZ1Z4RWlUMWxWWk1XVVNURWhyNlo0TGNtTG5LSUlhQVZhQm5CS2NLQkJDVE0vNFoxS05xbkVHam1hTnFQMTI3Y0dGNFBYYWdZUUZhbFpFdi9rVC96SW85Lzl5ZS8rQy9sZzYvRDF0LzlMYmM3M1JXeEQzQXljTHRUZXlUdFBWbm5LTXVDOVlUajFsQzVnRklvOE1KNDRpcW1Tanp4YjYzMXViZHlpMDF0Z3NiVklOczNVbXFpN3VyemN1cjUxKzJ2YmV6dGpadFNucW9RYkcrdDZaRzJOOWEzTkE0QThDUGJrcVdjWVpnTnh2cnJyVVFiVHZlcVZteSs5UHNvbnJ5ZFJHaHB4dTExNW1qYkUwWW1WdzhSUjRQcGdLSGtXcjV3L2ZPR3BKODg4ZXVUamozNzQ0NnVkMVdjRy9Ud2E5SE1wcHA1aVR5aHV0Tmk5SFhETkNiUkxNbGRSdWdMdkF1ckJPNGVyZk8weFpxRlZDSFdWMVFjbFV2QmVxYXFnWmU3aXVjWDJDZS8xaGUzTjBZWklIV3JONkVQanpUczNtai93eWZkL3BCSHI4YzNOTDJCakwwR2FPTk1rQklOekJVVlZVVTRVNXd6OWdTZkxQU0pDY0ZDNWdITVFpa0F4THBtT0t2TE1NQmtOV04rNlRxZTNURGZ1eW1ReVlhSGJXNHNieWNWWExyOTVPWGp2Z1VwUkx5S2F4REg5NGZBQUlBK0NuVDcwRUx1akhZb3F2ejlkMTdJcXd1V05OMisrZlBNYnY3TTUyWHpaV0x0ZWVYeFpTdXRRWjZGMXFOT1JxUy9EeHQ1ZS9wNWpwODhzTnJ0SHhzTmN5aktRNTQ3UkpLY3NxenArRzdiWXV3TXUzWUxHZ0JBQ1JaVVRuRU9kdzVVT1g5VkQ5L3RldzgwZTd3TGVLVlhoWlRvdU5ZNXNSNnpjdW5WOTcrVVExTTF1YjRCa2UzZkkwNDh0bmpsKzRzSVR1M3N2R09mN0lnSmlGOEF1MWQ4bm16SWRlS29NMG01S0dSekJDOTZEcXdMQngvZ1NwcU9NYkZoU0ZoNE5IdThMdHZwYk5KSjVHbEZEc3l5TGpxd2NXdDRhN0x4d2UzdGo5NTdhbGZxOTRlQWRsNGNjQU9UL29CMWZQc1cxcmNzRURjdzJCdTl0RzRxRXloZlZyZDJydDc1NTlVc3ZYdHA2ODJ0V3pPV3NtRzY2cWh3dXR4dFJwMWxsSzkxT1U5UW1SZUhJbkdlY09PWXZMTEo2WXBYZDlReGZWWVJKZzhtdEZqQkJXOXRVTHFjb1NzcXl3bGNCRGJYaW9IckZCeVVvbEU1eHZnNjN5dHd6blpUNHlwbDJKNVdOamRGdlo5TnF5bXpjbzk0RXhKVDVsajEzNHVpSDFKUmRZN2ZxM3FVNmdqWUlPb2ZYQ0JON0tqeEJBMXJYQ2loZElIakZWNDRpcjZnS1QxV0FPa3ZBWWF4UUZGUDJ4bjFhNmJ5a0ppWDRzTGk0c0xEejlZc3Z2eHhDcUFCbmpQR3p3c0VCUUI0RXU3bDlqUkE4ejU3N29Hd1BOMlpiZ3pNZGN2WnZhQW1BbStUOThadDNYcmoyemV0ZmZ2M1M1dXV2TEM2MHh0LzUxQWVmdzlsTzVieG9nSW1GcDMvMENUN3htYWM0Y2JiRDdhLzlOcHZySlRacFljc1V2NzJDeDZHTlBTcVhRYVZJQU8vcmhTbnZsY3BESHFBTTRMVU90ZkxjTXg3bVV1YVZkTm9wbzFIK2xkMmQ2WVlJN3I1a1BWN2Y3R2RIbC9YODh1cmFXWlB1aU1XSUVmQ3VRTTA4VWVNUUtpVk9wd1N2dUVyclhNUXAzb0gzbmlwM1ZFVWdMeHpPMWZlRk5iVVlhRmFPR0U0bkxMWlhKWW5pcU5OcUo3dVQvdStzNzJ6dEN1S294K3dENzdCRnFnT0EvSFBZdi9YOS93NUtJQzl6bWttVGNUN1NHVkQySzBYM0gwSUxHaytLVWZqc2QzM2ZzMCtkZmZMWlBDOXNWUVVKQ2xvRXVuTXRqcDVlNU1XLzlWL3hpLy93Ny9DbDI1ZFpTbFpwTjdvb0JyKzlpaDhzNEdXSTJpR0pOUlN1Qm9ZR0NFRndLaFFPcWlxUVp4WFRjY2wwbEZNVnBiYmJpVFdSWExwK2JlL1ZtYmNyWjE3RWxoV2FXTzlPSHU5OXVMRkkwMldGR0JXOE9veWtXTnREYUFDQzk0NjhxQWhPY1dWZEZBaEI4UUdDMTlxVGxDVVN0SjRpRVVXQWFURmlPbldzelI4aWpaUGU4dUx5K3ZOdnZ2aEswRkNwcXB1RlcrOG9nQnpzcFA5eldIK3l5eVFmODFkLytEK2cyK3hwMEREeklQajdKblJMb0JSd3Fsb2RQejdmZXVpNTlYTmgvalVicDRwZzYvRkZnV3RmdXM0LytzOCt6MWQvOHdxZmUzdVQxNjkrQlMyL2pvZ2p5eHpEVWNud3lqTFZLeCtGMisranpGb0U4Umpqc09MUjROQ3loQ3dqVEhPcVNVa3hDTGh4aEhIenVHbW5zZEJkZmNnYXM3OExMOVRMa2lYZ1gzeDk4K1hMbDIvOVRpaURhQ3hhQlk5V0RqZmVSc0tJSk83UVRIcWtTVlJ2dVpqWmVGblFtU3FWN05lKzZ4MWlVMy96ZmNMdUpEYnNUSzV6ZGYwYVZxU2QydWhDczlGb2NtOHYvNkFQOGlEWmkxZS93ZVdOdC9qRnIvMGMyNk43dStEZis0bkhtVXh6cGxrcHFoanEvWXBHb3hGMy9tLy83dnQvOUlrbmkrOFBqVGRqYVk3RlQrYVJzb1V4UWhSQlBuTEVyZE1jWG5xSVJkdmcwNS81Q01lZmZaYkxyMjdXaVhmd2lFK1F5V0Y4dGxDZkxJMFEzOERuTWVVNEpreWFSTk1sbXRrNXl0MWxza0dieUIrV2ZEUm5Kc091TmJSZTZvOXYzL28yRHhkTmN5ZWRMdnJJZTdyUDloYmlsZ1cwVUh4V0VuekFtaWEreWhBS0NsZFFWWXIzZ3U2SGVMT3dxNWhVVkpWSFp1UW16dGZleGhpRDl3VjdnNUVlV1RvaFl1WHlGMS85Mm04Nzc4ZXpub2liZWJaM1Rqbi80SmovaTdmVnRTYlRyNWRRSzU1RnFzVEdTdkp2LzhVblAvYk1lK0lmUXN1R3hoNno5aExkZElQbzVobnk5VFBZYW9FUWhNbzVubW8veXFuNUUyeHN0REVySGtsaXFpekRXc0ZYanJKeWhPa0tabk1SYVJSNHFYQ1Z4MVllay92WnpzYUluZjZBdkFnNE53QWJrelM2aHhxTnhTUGMyNFcvWDY4d3ZINTU5ODI5M2V5VncrM29PL3dvNElzNlBLcXlMYkxOQWM0SEt1OHhsU09NUFVVQWljeU12a0tKREhkMXVJd21ZQlNSZ2ppSkNLRWlpaUlteFlBN3Urc2NXamw4ZjBqMWp1eWtId0RrOThIK3h2LzhWV2FycjBicmJiLzR1ejl4OU1nemovZCtPSW50SVc4TVhnTmlsS2k3UVhwNkF4WmZwZG81aWQxOUx6S1pwNnc4YWF0QmYzM01uYXV2VVhsb0pCWlFpaW93clR5NU9pSnJzT09FeWtlVXdZRjRSdm1RemZFZTAyeVQ2V1FYcjU0b2lTbGNoVUhWM1J2Umwvc2VBTzBsY2RLWWFOTk82czY4ZXNXRi9Ud2pKMVFCVndYd01Oek11TGsrSmVtbGRGWmJnS0JlNis2aVF0Q3lkZ2V6N3k3R0lOWVFweUszZDY0RlRMUm5qRlR2WkpBY0FPVDN5UVNwMmR3aGppTVRmK0I5SjU5YldEMzVlQ0VPcllhMGtnVXdDUzRhWU13QXNYMU1lNCtzZHhPM2ZZNXkrd2ppbG1pM205aklrZVVsemdlVVdqWFJJQVRuR2J1QWlsQm9SUlp5S3A5VDZaQzRsVEhZdk02Um51WEgvdnhQa1hjVytQLzk5ZjhHVjVXUkdKUGM1MEZtQk4zWU9EYm1rKzlmZSsreHBkYmpOMitYM0x4VGtCZSt6aWRFYURRTTNYWkV0MTFINWxZTUVRYlhMOW5KSFBGY2d5THpPT2NKbFVjTWlGRkVRRkFDTlhWUW9pbDVsVlhYTjI2dE94LzJkOVhEZ1FkNWx5R0VPdit3Szh1TjVzcFM0NW5FaGs1L01sQmpDbEZuc0ZFSE1SMk1kYVJwaG9rQ0p0bWhXdGpCSG01U2JCMW1ldjBrWm5DY2hhUk5VVGttUlVHQ29RcGdnK0s4VW1tZ1VFOFZQTUVhVGg1Ym9TTnc4Y29ZSHl6THkzTzhOVkNnaWJVMnFseTRIeUF6T1RuaVE4dk45cW1qM1E5Tk0yMU1wNm9pa1ZnalZGWEFCV1dTZVRhM0s1b05nN1hDWkZyVHN2b1FxQVlWNDM2T3BoRkY2ZkRlRXhsYjkyaFVDU0hVRk9EV0VJbjFSVm05Zkh2OTFvdGxXVHJBQ3hMMEhVamtld0NRM3kvVGV3ZXcyNGxTYTdKMldXeWczbE42d2JtTXlBWlFNQ1lpVGc2UnhEbXF1MFJXNkxRejdKRkx0SS9lWVB2bUF1dHZIeUoxNStrMEZ4bWJnSk1LWjRTcWNBUWY2bGhPd0t1d3VlNjRrUXVMYzQreE9kN2lyLzFIL3pNdVdFS2xSSTFJMVpsN01BWXJRcXhLZE9wb2IrM1lrZDc1NWNWSVZsY2JtdWVleWJSa2ZUUG56bWFCcWhDc01CdzdObmVtWkZsSnI1V1FSTGJPT1lwQW1lY2dNNWNRUEVIcmNFczlpQUViV1RXUm5WNGY3djNTeFkydFYyY0R2MDZFZ0tKLzg3LzRTZjdVdi9HM0R3RHlydkVqSU5hWUtLQzJjRXJsSUlnaHNoYjFBZTl6aklJdmMrS2tRMnptVURJcXB6aHZhZmM4Y240YnY3VEo1VGZmd20wZW81cXVvT1VDK0E2Uk1iU3htT0FZYVNDb0kyUWVYM2xTRStFa0poOU93VVlZVzdmL0lwdEU5NFZYRVVnYXg1Sis0b1BIUG5oa3JidmlRNlVoSU1ZcXJWYkVzYU1wblhiTXRWdFRwdE9Bb0dSWnhXQ1VNNTRVckMxMlNHS0xqUUxXZ3lzY1JnU1hDTllJMXBxNlVTTmdvMGdpbTFSRjhKdWdSVjBPcnpPWHVia21mLzMvKzFzSEh1VGQ0VUR1L1RITm5KL21vYWk4NEJXc1ZaSTRSZFRnZkVIaFBCRUZVdVhZdUlXTjV6R2FrN3NNNXp6ZVE2OFpjZXE4WTNQMUxiYTIzbUQ3anVBSHkwVEZNbEkxeUlQZ3E3cFo2SDNBdVFtK21JS3JpRVRRQUNaS01JSTN2cWp1Z1FPanF2RzVrd3RyenoxeCtEdXp2R2g2THhoVG9WcHZBNHRhdWgzaDdJa0diMStkY3ZWbUJrQWNXWnp6ck8rTTZiWlMybzE0TmhjV2NNNUI1YkR0Rkl4Z3JZQ28yaWdXTWVuQU9iZFY1eDFhMWNPVEdwenpCeUhXdThaMUNQdDh0N3F6VjVTanNSdjdNQ05vUXhFY1ZWQ2l4c05rYnN6TzRESnp6WVJHeUNDdmNIUUlKaVc0ak9BOXdZT1UwQ0JpWWM3UWJEaXl5UjJ5NlUyeWthS1RRTkd2R08wVmpFY1ZWYTc0UWdtVllMQ0lOYlNTTnAxdWUyTmorL0tsMldjZjZsWWg2ZnNmWDNseWQzZHlOZ1NITlVJVVdlTFlrc2JRVEExbHBVd25RaEpIR0ExTXBnVkpFaUZHY0pWbmJ6aGxPQkthYVZ6dmpqaFBLQ29FeGJZYVlHcVFpZ1N0Z3R1WlRLc3RhdGtFTDBKUWZXZFNOeHdBNVBmZmtZUnA1bHpsZExmeUdsQmpRbEFxVitGQ1FidTd6TWt6ZjVLdmZlUG51YkwrVFJaYkJna09EWHNZTVppb2JzMHI5VkpVUEdPUFV3eFJrdENRUUVKRk00WmV4ekkzYjVrTVNxYmpuTWt3WXpvcGNWVkFSWW1hVFhxTEt6UzJKckJWQythZ2NIUzFzM1o4cmZmcHJaMThQb21FUm1JSTZrbGpRNWxZeGxJbjVUczdKZG5Fc2JMVVptOVVVRmFleUJyaXFDNC85d2NUTm5jRDgrMEdsb0QzZ1RJclNSRk11NEUxTVVZTWxYT0RvblJqN2pJdGlvTHFlRnJ5d2l2dkxKYkZnMDc2NzZNUFVhM0ZNVldKbjNsNjllVHFjdnREUGtqczlSN1RUWlpOT0hmdTAxeDQ2T1BzRFN0ZXUzaVJjVlpSRllMM1NqRU5aS1dTVFFMRnRDN3BocXFldndvK0VFSkFYZDJuRUF3RUEycXdZa25pR0NPQ3NVSWNXeHBKU3JmWHRoanorczFiL2JkbkYyVDhtZTg4K2JIM25KLy9rVmJUdHFMSUlBYThnNkpVcXNxenZsMXk4Y3FZeWNRUkFsaHJTS0tJbmY2MExoQ2p1Q3BnRExqS3NiNmI0MXlnRVV1OWNPVWNWZ3h4MHNCRUVrWlorWnMzYnUxOUtRU2RpcEF6bXl4K0ozNktCd0Q1ZmJCT0p5WUVsZnRJRWFKT080bU9IZTA5MDJoR3l6VTlXeTB1TzgxSHVORGsvRU1mNXV5WkowbVNGZDU0K3lJN2d6NVpCVlVsT0svMWpvZENXU3FoRFBncTFMdm9zOUhkNEJXdEFxb0JYM255cktUTUsxemxRTUVhQ3dLTlp1Szk4czNyMS9jdUFkSEp3NTNWejN6bjhaODhzdFo0eElENEFNN1Y5UVVGOW9hZUczY3lObmN5eHRPS1JocFJWb0Uwc1lqQzlzNFlNV1kyQWwrWDdsemxHVTQ5YVN6RXRnYUplbytKUkd4czNjYlc2R2Z2Ykl4ZUI1MUpJOGo5c2dnSEFIblE3Yy84NmNlNGNYTXMwK2xkRGZKNGZXTmFQZkhVMmtQTmR2cW9ENGd4Z2c5QzVneDNkbTRSeXdwcks2YzVlL1lSMWxiUHNOTWZjZVAyTGFaRmdRdUdxcWlKR2U2T21SY2Vsd2ZLM0pOTkhOTnh5WGlRTWV4UEdROHlwcE9jcXFnSVB1eGY4Z2hDa3NSVlhycm5iOTRhWEFIaUgvajRzZWNlTzd2NEk4TnhhUFlIdFljb3kwQlJLbGtXMkIxVTdQWnJXYmpSdUtTc0F1MW1qQVpvTlJPY0QrenVUVERXRUh5Z0tNdlpuaTRNcG83WUNrbGswS0FxSUVSMjY5Ym0rT2Y3dyt3bWtJbFF3RHR2aXZjQUlMOVA5c2l4UlZvTENWdmJVNGJEdThPS2NlV0NIanJVN1N3dXQ1OUJURXNVbklmU0N6dlRqSmRmZW9FYmJ3NDRjdVE0Wjg5ZDRNSkQ3NlhYT2NUbEt6ZTV2YjVPVVFhY2h6d1A1TG1uS21vUFVoV2U2YWhrc0RkbFozdElmMmZFYURpbXpBcGM1UWplNDMzQU80ZDNEaEdwcHJuLzZzYlcrT3FaNCsybGYrbEh6ditweGJuTytiMjlndUU0a0JjQlZSaU9ITmR1VDdpek5VV0FaaExUU0NOMmh6bFJKTFFiTVQ0b2FSSXhtVmJraFNPRWdQT09hallDcng2eXFnNjFyQUZVS1p5K2VHY3YrOFZwVmcyQURDamoyTHFISDE1bGEydHlBSkFIMlNLQnpXSEdxYlVlZDdaem1kUzZIUHNOdzJocmN6bzRmV2JwZkJUSFordjlDWkZLWVpJSlV6L2xkNzcwUlg3bDcvNG1HdURRb2NNODhjU3pQSHorS1ZxTlJhNWV1OE9kalcybWVVbGVCSXJDTTU1V0RJYzV3LzZVNFdETWRKSlJsV1hkdWRhQXE3bXY3ajRoQkRUb2NEajEvM2h2a04vKzhVK2Yrc2gzZitUMFo0MkpvbTdQeXZKaUcxVmxNSEhzOVV1R281S2ljT3dPTTZMSTBtN0d4TmF3dFp2UmFrYkUxdFRiTHdqRGNUR2I2SzFYY1VNQWd4S0NrcFdlZHNOaUJTWlo5ZHBtdi9oSHBRdmpHVUFxYTAyd0lvekd4UUZBSGlSNzR0Zzh5OTBHdTVQNlVLWUdWdWRiOUhjTFdkK1ozcCtIV0NDYVRpdVB5bWhob2YwRVloY3FyMXA2WkpwNW5CTzZxMDF1M3JqSzMvbWJmNTlmL2VWZm9TZ3FIcjd3Q0U4OTlUNCs4b0ZQTWhrRVB2ZS8vQ1k3MnhNMnQ0ZHNiUFhaMnhzeEdJNlpaRGxWVmMwMEZiV2VkRkc5TjRXb3FEVUdFeWZmdUhabi9LdHJTMm43VDMvbTNFK3VMUFZPcURyeUxKY2tWZzZ0R3J3THZIMTlRbitZMDJyRzFHUUtPWG5oYURjVHZGZTJCeG05VmtwUWlLM0J1VUJlVkpSbDdkazBCRkFsdG5VT1pTMDBFaXVsMDIvdVRLdmZyRndZQWZtTWFEczBrb2hKVmgwQTVFR3hJd3M5NXBvV1l3MGJneHhWRmEvSXBIQm1rSldtcHZWVXU1K2tNMU9adW5ObjFNOHl2OTFvTmg0SndjemxGVnFXUVZ3VjhCNFdqdlRvcGpGYmw5ZjU5WC80T1g3dDEzK2RhemV1TTcrd3dQV3IxL25TNTcvQ2ovM1FuK1hNeWZkUVpGQ1c5WEJnSGVIdmozK1p1Z0dEWW8zVXpic1FpTlAwenU3WS82MmR2ZW0xNy8vWXNRODgrZkRTOTJWNW1SWkZLVVh1aWFNNlpPdjNBM2pETlBNVVZhQ1JSblJiQ1R0N0dmMXh3ZUpjZzhtMElpc2N2VllOR0dzTS9XRldGd2s4VktYTzFyRnFEK01jWWlOemMxS0YvMkY5VUx5eEgxNko0RlRSYmlkbFBDMFBBUElnMk5HbE5xS0cvclNReldFdXBmZG1wakpsdGFiVjNOZnJTQVFhVXJjdUdrQ3FTbXRqZmJRN0hoVjd4dHJqWU9hRDFvSTMzaW1WVnhwTEtXdkhGcGczQ1RldjNlVHlGMTdrdHovM09iNzQvSmNaNXlYdmVmeEozdnZrczV3Ky9oQ0hsMDR3MTF5aUhjL1JhU3pSYmkxZzR3WlZxQWkrUWhCQ0NCcEhVVjRFKzNkdnJJOS9hM1d4MGYzaDd6NzVRNzEyOGxDUmV4bU5IT054WUh2UGNXdlRzYkh0U0NQRGZEZkJ1Y0J3WEdDTm9kdEpHVTRLQnFPQ1JtTFpIUmJFa1NHTjdWMFdsYjNobE1nYXZCT3F1NFBzZ2lxVFVSSCsxcDF4OGNzKzZKaVpzS2NJd1lqb2FGSytJei9yQTREOEg3QjJJMll3eldXWVZWSzRZRlUxbW9FaTVaNENWQk5vQWMwb3NsRmtiV29qazlhYUh4THY3azUzZHJZbnQ5WHJHc2dLTmNWZ1RieVFlMXdFeVdxRHBiVWVGeFpYT2VSaVdoT2xuQlI4NlpXdjg1VnZmSmtYWDMySjIrdTMyTzd2NHJXQ3RHS1k3ektaN2xDVlV5UUVmRkNNc1dPbjBjL2MzczUrc1NqOTlQRnpTK2ZlODlqS0QwWmRPMWRJVEdFU1NtTzV0Vjd4NXFVK1NXS0lZNHUxaG00cnhqdWxQOHd4UnBocnAweXppdTMrbENneTdBeHk1anRwUFJMalBGWGhtRXdyNGpnaXpDWjVSWENWNnYrNlY3cS9VYml3T2ZNZU9lRFN5SWI1VnN5MDlPL012UExndVArejIyWS9FMEJtZW41M3d5ZnVhV3NraTR2elRRTnBaRU92MjJwOXFDcXJGU3VSblV3elVZSzFVZUlubWRzYjdVNmVuKy9ZNDFjM1I3MzJYSk9razRLMXFOU0NIYVlockIrcjBCV3cweTdIK3pIeGFNeW9tRElzUmt5cWdFRVJDYmd5cHlvY1ZvQlFyNHhIa2QwcmcvbloyMXZUbjZrcVh3SmlPbzNxeUpOellXbWxEYktJSjZiSXU1U2QyMXpmZlpGWHIvUTV0dHptNkdvTEF5ek1OWW1zNGZxZElWbmxtZXMyVUlXZHdaU2d5dFU3QTFibld6Z2ZTQlBCR01XNVFLc1pNWm1HVUhuLzZzRDV2NVU3djA3ZEZDd0FKMGhJWStxcDVuZHE0ZVhndVA5dld5TzJ1S0E0WCsvSGhYdUpkeko3bWtDODFtc2Vta3ZOaWJtVkZiTzB2UGIrdDYvZWJsZGhzbHdXeGZmNG9rd3FIeE5oTU1aZ3NScUU2Zm5UaStYMy9jQ1Ixai8rNGhZdnZMcERXWHJpVmtMU1N1cGJYRUJEb0N3ZFpWbFJPVWRRanpVZVF5Q1VqcnlzWmtzWGdqRUNxcUlxUGlBdmozTitlcWVmLytQS2hVd0VxMHJ5M0VmWERxMGM2blVialNXY1M4bXlpUEZRcWFvSjV4NWJKV2xaWG5seG5aMytsRWZQTElKQXU1MXc5c1FDcjF6YTRzN1dpTVZlZzVXRkpqdDdHZXM3dFRCb3k5YnNKdDJtWlpJRnZQY3NkN3ZGYnU1K0tldnZYUkZ3V29PakFyd3hhRkVGYlNWeUFKQS9xblo0dnNIdVpGWmR1YmNFRmQwSGpKYUl0RC8reU5wVHA1YzdQMUdXMVdPVlNzaW51NGVUYXVLeXJMVGozRFVqb3JveG9MUGlrbmppaHBsNy8vdTZQUFpvd3VMY1lZNGQ2L0hDeXp1OGRYR0xPMWQyVWVvTlBHdnFmVHlEb2xyM0taUnd0eUZ2alloQnhLQ3FRUW9YdUF6NmxYRWVmbWswOGZ1NmdLaVNIRDNhbm4veThjTlBkMXBMYzE0YmVKOHc2QWQydHRmeDVRUlhWUncvUGtlM25mRHFpK3U4Y0hHYk0wZDZzMGxkNWV5eEJXNXNqdGdiNXN4MVVwWVhXb3h2N1hIdHpvQVR5NjFhSjBpRVpnUHlxZEdWZEQ1cXhIN3grckJmQmNXaDZrVWtSTWJva2ZsRnZUUFlabjNnM3JHZi8wRU84bnZZNmVVMkxpaGVWVW9YN2piOVpqbEdDK2drc2UzKzRIT252dXQ5NTViKzhsd2ora0FyamhjYVJoZmFOc1JyODQyMGw1cTRtMW9SVkNvWHhIbVZFRlJjVVBuZ2h4YjVzUjliSlltRkpMTE05eExtVnpvc0x2ZG9wakVTQXZuRWtZOHJxZ0o4SlRXTGlJcGFrV0FRRlNXb2wxd0R0NTNuZDRxS3Y1TVY0V2QyaC81WHlrcHZNcU1kbXIyaytGLys4KzkvNWlNZmZlUW40cVRkclZ5TDBiREY3WnMzeWFaN3VDeUgwcU5BRWxtV2wxcE1DOGVWRzMxYWFVd2pxZS9UeFY0RGE0VGJHMlBLcXFMZHNQVnVTRmFSR01FNXNDWm1NVjNVUkZKQjVQYWR5ZWlMbFhjWmtJbElGUmtibGpzOU5rZkRkL1FaT1BBZ3Y0ZkZSdGpLSEZubDBYQlBiR1lHanZaU04xMzl4Q09IL3RqRGg3cC9Pa0dPT3RCV3gycHZvU091REl4SEpha1llbW5FVXF0a1hGVDBwNDZOUFU5dk9lWEgvL2doT3IyWThTU0NhQlhzbElYRktTYU9XRjFwME45WjRzN3RNVGV1N0xDeFBxRElQWEZpQ0dJdkRjYmwxMFMxVU5YMW9IcE5WYmNxSDI1Vlh2djNnYUtjZVk4SWlGdXRLTDd3OE5Hbk9yM2VXbjlZYVZVc3lXaHZRRmxPMEZDQTh6V25sU3FWQ3lTUjRmelpKUnBwekp0WGRqazAzMkp0c1VWUVpiSFhKQnhTTHQ3WWdWRFJhMXEyK3A1WVBkMW16S0c1TlNMWGxNRmdJdTEyNDB5djBWek1xbUpIWmhRT1FRTWhCSDJubjRFRGdQd2VkbTE3U3BJWUNVSDNCUzczdzZyMjZlWE9pV2VPTGZ6VXVhWDJqL1JXa3M3YStSYWR0VVFRWDU4QWhheGZzWE1yNTg3VktWdTNNMXJqaW03VHNkQ3BDRkhnNHF0OWV2TUpTNnRycUQxQjBzbG82RFloOU5FUTZoSnFFdEdJSTF4Wk10aWJNRC9md0puNHJhMUIvdk5sNGZxS0RvREpMUEhkWjNNczkrUDhXWlFRQWRFVFR4NWRXVHZjZlNvcmNobFBVaDBOZHhrVk8wZ0VsSUVRU2QwWmQ0SFUxQ1RZbFZkT0hHclRzY0tMYjJ3eHppcU9yclFwQzArekVYUHkwRHdYcjI3aEtxVmxMZU5wNE1LeE5ZN01IV1puZHlCQkErckQ0Y1ZHNitqR3FIOUo2NEVEcTRwN0I2NmdINFJZL3l4MlpyWEY1cWcwWVViK05nTkg1NkcxN2xNWGxqdC84ZVR4dVU4Ly9xbXpyVWMvZFpTMWM0YjJBcVJ0YUhRTmpaNmxzeEt6Y3FMSjBZZTZMQjF1RXNlVzRBV1gxVG9GYjd6YTU1VnY3REVhRzNwTFM1Z1l5bXBFbGsveHp1TjlUZWM1SEJUY3VibU5lcS9OVmtPdzBlWHR2ZXlybGZNVFlIOWtJd09tKy8yRkdVQVVpRVNrWWExcC92aWZlT3JqSC96ZzhSK2JUSklvbjZTU1RZY1V4WUF5SDFNVlJTMmo0R3M1QlZGQlpoZDhDRW9qamxoZGFISjdjOHplc0tDVlJ2V00xMndZY2pTdWNFWGc3SkVqdk8raFI5RlFqN2xQczZKbVZVemppOWY2TzY5d2wyMVMvS1RLMVlWd0FKQS9xdGFNSXhubDFiNzNTSUhXUXFOeEl0WGszNVkwK3NRbmYvS3A2Sm52ZjBoc1hCRzhnSTh4eE1qK1RKS3IxK1JNSkxRWFlwYU90MWc0MmtGTlJEWnd4R0lZRGdyZWZPVTJiNzF4amVGZ1FLdG5NV2s5c2V0bUxPMmpRY250NjFzeitoeVJUcS9yOHlvOFB4cGwyek5BN0lOaVg5Wmd2NmxRc3pvSzdiVkQzY1dmK3JQUC9abmVYUGZDYUpCS05zN0VsU044T2FVc3hxZ0xSRkpmN3lFSWVlWUpwU2RLVEMycjRBS1JOY3kzVTNZSE9YdmpnbVppbVdZbFZWRkNjQnhiV2RQdmV1SkpTYU9Zb25JVVpjVjRNbFVOUkdrU2IxOGQ3bjQ1cUJaQWllQ2Q5NkVSMVJ1SUJ3RDVvMWJhVFdKR1dTVytMdWttUU11SXROcFIrc2txeUovNjhBOCtIUC9BVHowdEpxcjVxVVNhQ0NsQ0N0TEV1d3BWeFVTbTFxSFNnTEdHdEJPeGVMSkQzR3VRYlpja0dLTElzcnM5NU9yRjIxeTV1RU5SUW11aFJmQkNXUVR5cVdkdmU0U3JuS2dxclZhcmw3YlNqWTNONFNYVit4V2p2dVVsR0NBV0l5MVZtdC8zNlF2UGZ0LzNQZjVUUmRicmxJV2h5RWRTRmdPS2JFRHdIbEVsVklwbzdUR0MxbVFMUXMyOTZ3S1VWWDJRTzYyRVd4c2p5dEpoMURNWloxUkIxNTg4OStqVytVT0h1OFBweEF3blU0cXlZcHJsQkk5cE5SckRmcGwvZVZ6a2c1a1hjU0lTckJqOTJFT1BjWFZuOHdBZ2YxVHMzLzByZjU3Zi9Qelh1RTgvUEFFNkN0MjJORDd6OE9NclQvOGJmL1U3Wkc1MVh0UmJqTmFLdE9vRndZSkpNRkZLa3JRd1VVSVVXWkxFWW8zRENDUlc2UzZuRkZITWVLY2lDbUN0eFlnd0hreTVmbkdidmEwY2s4UW9oaUwzRkpsbk1zcnhQbENWemg0KzFIdG9ZYW01a3hYNVJwYjUrMEVSSVhmbnYxS1VOdEQ1Qy8vcUJ6OXphSG4rQTNrZW14QlVnbk5VNVFSWFRYR0Z4K2NlTjZwd2xTSkdzTE9sK24xeWFoK1VvZ2hrNDVJeWQwekdVMjV0MXA3SGU3KzNWNFNmTzdGeTdQYXA1WVdIczd5SUtoK2tMRXVNTWFJZUltUHc2SXQzeG9Qck15OVhpWWcvM0Z2UXBYYVhLKzlRZ0J3azZiK0xwV25DNFVQTHNyRzVLeUVFTTFPa1RZOGRYbGxxYTNMaHlRK2VNS3ZIVm5DVmduT0lDNGozMU5ST0FtS1F1QWQ0UkNjWVNUSGlzTEVsU2lyS29yNmFqanpVWWE4dzdGemNKYnJWcCttVnRCTlRWQ1Y3MTNlcHNveERaMWZwTG5VNDk5Z1M1eDd0NHIzUzZqUllQYkk4MytyRy83SUwxWHZINDJyOXp1M0phOS84NnZYWHZ2SDhyWnNoTUdIR2VRV2tILzJPazJjZmV1alFCNzFySklJQlY2R3VxdmRxUTZES1BYN2tjSm5ITkMzVzFHdTdTRWtWb1BUMTdvcUlVQmFPamZVQms5RlV4MWxKbWZsSm8ybCtjWFBvZnZQSzV1YjVENTQ5TlU2VHVHVWx3d2lrY1VSdUtrVGswRkt6L1l3UitaMmdPcDM5YnBKRWtiamczN0haK2dGQXZzMytvLy9ILzRsZitJZWZaemlheUV6c1BnRk5yVFhKVC8ySlQzLzA1VmRlZi9qcGp6d2tjU3lFc3NCTngwUllJalgxN0pQRVdCTWpVVXpsQ294WlFXVUVPaWFXT1V6a0NMSFFTSVJlTnVEUWNZamJNZjZoT1pwNG1tbURwQ20wRjZBOWx4TEhDZDJGT1pxdGxEaUpNRFloaWlKRVluRStyQkhrKzV6empFZjUzb2MrZE83bWF5L2YrUExmKy9sWGZ1WHRpOXUzQVJzbk52M2hIMzdzdXp1dDVId0lOWEZDOEFYR0pnaUJTSlJZbGFMd1lBU1RHRlFVbFFEVzFCNUNGUzA5ZVZaeFo3TlB2ejlXNXdPcXFvV0dmN2pUcjM2MjhxRzh0TDcrNXJBb3IzZWE3WlYyMnhNVUdVOXk5Z1pUS3VlanhOb2p6U1J0VG9vOG1nSEViSStINGNqY3dnRkEvcWpZMWV0M1FGVW1rM3dmSUxFcThROTh6MGRQbG5uMW1jcVA1bzRjU2lqR0U4UkJaRk1pVXVJUVVPT0FGREZKM1hBM2dTQTZ1OHdUVkNLd0NiRVJWRDJOdUdTeFU5Qk1FNkpPZzBPSGwxaWFYeU9PSzZ5cGlFd0xFVnZMQ0VpRWMyNm1ZbXRRdFVRMVNTL1lpazdITExRYThVS25FODYzZXZyTUwvenNXMy9qOVJjM0x6MThZV1gxeExHbDkxc1ROYkpzaXRMQ1JESFdLMG0wUUo3M1FhSFppL0FDM2tqZEhMMUxhVjFMQWcxR09UZXVickczTjhJQVRtV244bnd4OS81dmxpNnNDMFNidzFFK3lQTFhEaTBzUGxVNHRhcTFBbGFqa1pCUEt4cU54cG1UYzB1SFh0dTh0UVZZVk0yNHpPVXJWOS9pbVdObitQck55d2NBZWFmYnIvNzZsOW5hMlVNRW8xb1BJVFpiamNhRk15ZmUvNFV2ZlAyOFowZUswUjEyYis5QTZXa2tjelE3ODRpSk1IRVg1OEdIbXJRd2tNNDIrUnhnRVkwUVNjR2txSzNvTERXUnRNc2syMEtNMG0ya2RCb1J4cVI0RGJOUjhUcXRxRGYzTEQ3VURJV1J0VVFtSmpnLzI3dUF5b05ZbTV3NjAzbjZ1Ny8vb1VQZGVQNHJILzdvWWJ0eWFPNjhkelVCdGNzY1ZWa1JBSW1iK0dDSVJMRE5pTXpYTkN4ZWxXTHE4YVZuUEs2NGRXT1A5WnM3VkVXcHhvaDR6TVYrVWYwWDR6SjhOYWoyZ1FxUldGWFRTK3NiTDUwL2N1U0g0OGgyckxFRUFxMUdnanF3eUtGMm5Ld0JiOHpPbmdtcXRPSjRSbUp4NEVIZTBaWWtDVmV1MzhaYXV6K01HQVBKOTM3eXcwZjcvY0Yzcm05c2RocE4xY2xnS3MxR1JqVnhsT01SUlRXbDFWbWgwWmluMHBxWU5vcWJXQlZFRE1hMHFWeUpTb3lRb2o0Q0xXazBLeEFoU1pRMEVkcmRGdFlLbGdpWERRakJFemRhZUo4anRnbFlZbXRSZFJpcFFCM0dKRVJZTkpTb1ZZeFJNUlpPUE5RK090d0puejE3WkNGSVJleG14RG9TUmRnUUNNV1lzdWlUOXBxWXlKTk42MHFXSXJqYzR5WVYvYjJjcTFkMzJiemR4OGFLc1ZZQ3ZEM005YjlaMzgwL1ArdTdUR1pKZDZLcWVubHo2NjJzS05lTmtiUEdHTnFOcHVSSndYWTVvb1cwdTQzbVVXdE03RU9JRkt5QUpOYktPN1dyZmdDUS9mS1BNVWhOOHk4aCtIMWRqNlRWYXFTbmpoMTUrdlhYMzNyUGNEaEVRMU0yTmtZc3JYWHhCc1I1OHNrV1pUa21TaGV3Y1k4a25rZERSTURpWE1BN1ExWEZPRyt4Vm9qaW1EaE9VQ1kwb29ST1k0bFdLOElZUDlNNmQ2QWV3Wk1QMWltTGpHYnZFQ1p1b2VxSW9waGF5VG5DR29NeGlzR0NDbzFtakdpSzN4andpTVAwcm03Yk8rczdKSzAycHRXZ1NEdll4UVUwRnVLNGpRU0hrekYzajJkUXlzeXpmbnZFMjI5dE1SNld4SW5GMnFCVjBDdURYUC96R3h1VHo4OGFsQ1BxRHI3T0JEaVRuZEZvYzF5V2x3LzFlbWZIa3h5WkVXcEhVYXp0UnJQWnNJM25WanE5WDEwZjlzZjNoVmsrTm5yZ1FkN3BWbFZWTGJGM3IzUGVlUGE5ankyNXF2ekV0V3ZYNXF3UnF0S3hOeWpKY3FGeVFzSk1ocURJeUl1Q1NyZXdVWnM0WHFiVWxOSUhqQmhhU1pNNDZkSHRyaEhFWVpnZ0JMd0VyQW5zeS9TSjFydmNTWE1SN3dNaHBEUXN4SEVIVlkrNktTcUF0REJSQzJ2cVhSQU5FTVZLT2dtVVZ3dVNOeWFjcUlKWXA1UURqN05EU3EwN2RIWitIbk5vSGo4SHJzd0pYcWlLZ0JvWVR4eFhyK3p3OXBzN1RLY2xTU0pFc2VBOG00UE0vL2MzdHJMZkNxcEQ3blh3OXhmSkJhaHU3KzZPM3J4OSs4dXgyTy9JcWlwRkxKMVdrNkp3ZU9kcE41b1hsdHZkUSt2RC9xWkFoSWdOcWs2U1ZwM3dIQURrbld1aDd1Z2E2dkdNQklpWDVuc243dHk2L2RqZTlqYldXTTFLTDd2YmpteFV4L3doRnJUV3NxUkFLRU1nRzQzSXN5RVNSVFRiSFJyTkxsRjNqb1dGTnQyT2toY2pxdWx0NGppaTBSUUdPNXRVU1pOMlp3VWtCZ0lhYkYwTmE4ZTRQTU43SmJMMVltOVZqVEZSQTRPckczeEJVVjlRWE45bThOSk44bzBKa2dlc0tFbHFpQ1JtT0hGTU1rOGNHL3p1Z0dJd1pyZWh0RTkwcVlLaWtURG9WN3oyeWpvM3Iyd2lLclJhRm93U1lHOWM2Zjk0YXp2L2xSQjBOQVBIRktpazVyT1RXWmhWbHM2VjEzZDJYbi8yb2ZPYlo3cWQ0M3Q3QXphOEkyc21rbzBMckhLb1llT2p3T3ZVVTJER2h5QzMrenZ2eUhiNmdjcnR0NExqWGxhTUppc3JpNjBMWjQ5Ly9NN3Q5U01hZ3FLSVZzcjFTMk95cVNmUFlXOE1nNmt3eVdFOFVTWmptRXlVb3FwcE9FTXhwZDJNYUJoSXBBVFp4T29kcE5vbEVrODFHV0NLT3RReTFJVXpjUjdySGFLT01zOHBwaE9xY2tSWmpxamNsT0FyMUJkb2xlTkRSVG1ac1B1MU45bjd4MjhUZGlkRXFsaFg3N2lYQWZvamh5K0Z5QXZaeU5HZmxHejFwOFRiT1hKNVNINXJ5dnJOQ1MrOWVKdXJWemJxc3E2bDFoYzBaanl0OUc5ZjI1eitQZWZENEg3UElTS3VrU1JCUkdZY3UvV295KzJkblkxR0dyMjF2REJIdTVscU0wMVk2SFF3eHVqT2FKUzJUUHhVYkd4Y1Z3alZLTWplZUNpZmV1NWpCeUhXT3owVkFhelVGWm40NlNmT0gyczNHOTkxKzg2R2phekZPOEVvck44YU1kd3FjY1l5S1pRNEZwcHBMVzNnWjB0TVlvVTBTVmxhT3NMQy9ETE54S0pTVXVZbHZzeHB0QllRRXlQRzB1b2RKVW5tWnJnMFJFbWJ5ZDRHazlJUU5aYXdVUU1OR1VoQlVJc3hTeGd2R1BGVTR6NWJYN3JLK01vV3hncUpGU0pqNm8yVm1WWmdKMjFRaVdkN1ZMQStLR2d0eEJ3KzNNSjQ4Qk5IS3dya280cko1Z2dOWUNOYk45QkZYRjdwTDE3Zm1QNXNWZm05YndPSEIvVHc0b0x1anNZTXB0T2dxaDd3cjE2LzBYL3Q2clZiZXVRb295eG5WRlFNc2ltRGZFcWVGYWFieE9mYlNkcnA1OVBKN0F6YVNyMlhkMkFsNndBZzkyeS84bStCUkVTaVJ4NDY5Y3lYdnZ6TnczbWVxOEhJL25UMmVGSlM1TFYyWHpaMERKVTZsTEdDaVlVNEVacE5ZV20remNMQ2N0MmNBNm9xUTZxU1VIbEtOOFRhcEg2U0ZpRkVxQXNvU3VFQ3d4RTRieW5MSEdPVk5EVlk0eUEwSVFpb1VFMXkrdCs4eWVUTlRZSVJJZ3pUM0dOc1RhOFNuRElhT2hxUjBPMG1CSW5vTkQwcml3MGFxYVh5U21RalJpT1BqaHl0UEdZdk9BQTFSclFLZk8zMlR2WXowN3phbkZXcmFxb2V4S1d4RGQxT29wZlhOMWpvdFBmekJ6L0xTY3JKZEhxN1B4cm1veXh2R0tDWkpyU2JLZXFDZEJxTmM0ZTdjNmY3K1hSVFJHTEFlQi9NMnpjdWgzZGFIbklBa0c4RmlCR1JTRlh0d3hkT0xYUmFyUTlkdW55bFlVUUlzM0VuRWNHWHlqajNOQ05MTVhHVVdrKy8ybGlJR3hFdExNMm1KWTRFclhJS0Z5Z2t4NW9wa1JFTUtkNTdLaWRZNDdBeUJtSkV3UG5BY0svUGVEckZtZ1R2U3RKMmkzWnpEcnpnTlVLOEVKbUUzWmZmWnZ1VkxVb2ZhSGQ2cEhIS01OdkRLbVJUcFQveVRJY1RqaTRwVlJLVHRpUG1saXh4MnhLd2pQUEF6bTdKclpzRDNyd3lZS2Z2b1dYUXBVRHA5ZFdOUWZuZkRrYmxUZXBwNGJzOFZrWUlqVWFralViTXYvL2pmNXovNE9kL1Fia25KKzJCWW1NNHVQam8wYU83QzUzMkVZTmdqU1ZyTm1VOG1tcFpsbTFyek5xc2loVXBXQis4Yk94c0gzaVFkemhBOW5zZjBmdWZlZUxrMXViTytXeWFHNUJ2dWRlQ2c3d0tSREZrdWFkME5ZV0lzWWFvVUlLcnkyQmJtd1BVQnd3SlJxWkVqWnJFdkprZUJvblJVS0RXRWtSUm42TWhNSmtNeVBNQzFPQmNSbXFFYnRxcEdkeUQxa2RRRW9xUjQrWTNialBhR0tJTnkxeXpaRGlkc2ptc2FsYVR5dEZ1R2s0ZTdxR2xNcHdNcWFLRVNTbEV6akFwU3RiWEI5emVHTFBaOTR5bmRYaGpjZ01UT3hqWjRoOXU3V1p2Y28rRnBBSzhpSVRseGFaT01vZjNnWC8vNy93Yzd6Ly9FQzljdWFLbDh4N1VxZUt2YmUvZVZwR05PTEpIYXZlaVdHdUlvNGk4cUJwSE92T1B2N205L2x1Vjl6azFBWXVNaXV3QUlPLzA4S3JtclNJK3ZMSnc5a3RmZUg0KytIMjFzbnQ2eWVOcHhXamltRnUyRUJ1Y1U4cXB3em1QalN4NUhsTldDWlZYUnVPUzdseUxkbE14VllteGhxTGFKcmExZkVDYWRvaHRUSEFGV1Q2aUtQSTZGWktZS0xaMHVuV3U0dklSK0FJMTh4Z3Q2TDkyamEwYmU0QXkzN2I0d2pFWU9ucW1YcFZ0dFJPU3RDNGJGMDR4SnVMWHZuRU5WZVhFVW9kUWVhN2VuREFwTERaT1VDMHd0UTRPcms5WldobFN5NWpzU3pRSFFFTlFOcmFuZDBQTi9kaXFxSnhhWXpRRTlZQzd0TDYrTmN6eWl5dWQ3dU1pR3BWbGlROGVNU0lLYVNkS25qblVtMSs1c2Jlek56dUg3OGlDMFFGQXZpMUJCNktGK1Y1ck5CeGYyTjN0ZHdYcWZZNDZ2cXJITlVySGFGd2dzU1ZxUkVpbFRQS0s3ZlUrWlZHU05oSjZDMjBXVnp2MEYxdDA1cFR1bktYZEZob3BXRFBGUnRCT0JaRUtMNkFLUlZtUlY1QkVZUEUwNGc1Q1JGbE1zY0hocWdraFdJbzNkOGxmdmNteHBRYUZWNXJObU9uVXNaQW9VV0pSbEhhN250ZmFuYVNVd2JJN25YSjllOHdnTDVubUdkYkJhQndUUlRGWlhsRjV4UmdES09MOHlqelI5NWRKKzQyZFl0S2Z2Uy83b3ArMG0yMG0yVDBtOXE5ZWZLc0dpdXBNK0FEZkgwL0dyOSsrOWRYVlJ4NzlaQnluU3lJVFFFblRtTWswcDNKdTVYQm43dVNOdloyM2dVaFZ6VXhiWHA4NWZvYXYzN2g4QUpBL2JFdlRsS0lvdmozL2lMN3ZVeDllVStXUm9xaHNVTUhPcFB6cVF3QkdEVVVXRUF0cHl6S1pPcHdxZTRNeDJXU0tHR0Y5WTV2MGNrcHZvY3ZxNFRsV2puUlpXRzdTYUZvYURTR0poYndwcUdaRTlia2t5NFFzVjVwUm9KWEFhSGVYTEpwZ3RDSk9sS3AwaExkMktGK3ZlYWdDaGxGUmNhay9aakcxckxaU2loRFJhRFhabXdxNWc4SFVNeHp0TVp5TWFSbkx0VHh3czE5d3BHTnB0aUtLSXVDZG55MUZ5U3lhVklsY2VHNmwyZnFCcWZycldabnZyL0pXeGhqcE5qdE1zc20zSk5NWGpoeldLNXRib2ZJK29Pb1Z5dXRiMjNmTWUrekVXcnVVeGhIdFJscFBGcWdpTHN3dk5kcm5ST1NMcXBvcDlTaEFZaVBrd0lPOGc5eUdNWVFRaEZydE5VS0lubjN5c1VmZWV1UHkyZWwwaXBnd0U1K3Nnd2xqUVlKUVZYVTlOMjFiNG1sRXU5dWcyVzVRNUFVK2VOUUw0NGxqWTN1SHE1ZDJXVnhLV1QyMndOcnhSZWFXV25RNkVhMm1vVDh3TkJxUVJFSlJlcXFxN3N3M0V4QlhvbHJRU0FWcmxKQjV4cThQU0F0RkVvdUlzRlVxcjl6YVlyNlZjbTVwbmpoSmFIckl5NHBwWHBJVkJidURLVHZEQ1NaVTlFekU5dFJqakxEYUtQQWhFTHpGaDNvd3F2U0tSeldCV0Z6NHJybWsrV3RaVlF4UWpXY2hxSnZtazMraTByVFk3bkRUN2xJNXQxL0pDcGZXTjI3MVI4TnJTV1NPSjBsQ1dUbXh0cDVrZHBWdlJsRnl1cG1rcldtUmoyZmxkZE5PRzNYSDZRQWc3NERFWXpaN2RWK0NibGVXRjlMeFlQenc5V3UzRnB5cmlHTUJDU2hnQ0tneG9QWE9lRjRCa2NFMklycUxEYzQ5ZklUQlhyMG90YmpRSVVsU3BwT1M0VEJuYjIrTUd4ZU0zaDV6NjgxTnVxdGRGdFk2ek0ybDlIb1JzUlhVMTgwOVZJbFJ6SXd3cmxaUXJ0VnhkM3hGY1dkTW94RmhJME5lZUNaNXdZM05FYVh6SEZ2b0VnYjFMVjI1d0doYU1wcGtsTTdUVGcxclRTZ3k1ZVpJaWNYUmEwQlJHb0tDTlJCRmdna3FxbWhaVmtjN1VmcnB5TmhYbkhkM2R6aUcwL0UvMGZXMnhqSXBpcnVWTElGd1ozZDM1OUw2K2l1UEh6dnhmbXRNTE5SU0NjMUd3bVJjU0tSeThsQjNidWx5a2UvczV5RjVWVXJoM1RzR0lPL3FsZHMwVFhIT3lTd3hUNEhtTTA4OXR0eEpHei93OGl0dm5DK0tER3YyQ1pnRmticmNZbEFXRG5WWVBERlBaR3ZaZ1RnMXpNMDNPSHg4amtmZnM4eWpENS9pMkxFNVZ0Y2lWbyswT1hObW1lOTk3bEY2dnN1VjE5NW02OW9lVzllSDdPMU1HSThyc2lKUU91cnVkeEdZVGp6anNXTTg4UlI1b0N6cjdyeEdsbXhuU245dnltQmNVTGxBSEJ1MkJ3Vjcwd0liMVROZFdlNG9uR002elFsQmlhTUlNU0I0eWxLWWhFRHVsTmdvQklQM05RcjNiNHVnaUtxWVNPaWxuZGJ6dzN4Nm0zcVAzUEc3Q0c1ZW41Vm9wYjV4TENLUlFySXlOOTg2c2J6eWljazBhK1JsQVNwNHArUkZoVEVtQkNOZnV6M2N1d1ZVZ2xSQk5mU3ppVDUrN0JUcmc3MEREL0tIYWJQeEVyay9RVitjN3kwTWgrTVRnOEVRR3hrbE9CR1IyWDlVZzhSYUlUaEhXWGphYVVTN1ZTc3RSVkpyaW5mYkVjMEdlRmVBVVZxZGhITzlKWmJ0VVNZM2JuTG04QnliT3lOMitobjlpMU8yM3h3UWQySWFpeEZ6cTIyV0Q4K1RSSmJwc0dBOG1GS1ZGVWtjMFd6RXBJMll1Sk5neGdXdHlKS21FWE9TNGdKYzJlNXpmVy9BNFY2SDFFUTQ3OGxDTGV5WmlzSDdVSk5LRzB2UENpTmZzcDRGZXFZa0lzRUVpMFByUlN3RUFRM09IKzI1NktQV1J0L3czdTJ2bnZ4ZXBpTGlWZFVCN3NybTVyVTBUZlk2N1hZdnF6ekRiTXpVZWFhVlo3SFJYRzVMc2pZN2h6UDVDQlVmQXRhK00rN3VkelZBakRHbzZ0MEUzUmlKbGhmbWptZkR5VEhSUUtzUnl5U3I2dmpMMU1UUUlrb3NRQWcxYjVWQ3EybXdCcG94eExHUVJrclFQbFh3QkdNNDFWM0FiSThaTlR4VmtkRkxJNktsSHMwa1luYzRaVFNweUVlZVVSLzYxMFpzOVBhWVcrdGdVMHRSbEV5R1k3S3NCTXpkMytOa2tuQzgyV0F3eWlsS1IyS0VUaEt4UFM2d05tZHRyZ01ZbkNpUk1VekxrcndzeVVvb25kREdVa2xnNGoyRjk3U29XQlNMQlZUcXBTbXR0K3ZmSHVUVGIvamdmVjJvK3FmajR6TWYrQUMvL3MxdmFsYVcrdzFEUDg3ei9yZ29McllialJPdEpFTzZMUWsrMElvU1VtTmJ0aktQZFJ1Tno0M3lmS3IxSXJ5a2NTeWxlMmVFV2UvNlljVlpEbUpFSkZwYVdqQXJ5d3NYUnNOeGIzbXVvWjk2LzJubU84MmFSTm9LMWlweEJIRnNhdFZZSS9oWnZORm9HQm90UTdNcEpDa2tUVWdUNFdqU1pDNzNxRnFRaE9sb1JDVFFqaTJMN1NiTHZUWUw4eWtMQ3pEZkMzUmpJZXhWYkw2OHpjMXZickorcGMvZWJrRlVCWHBHNlJxaHFjcmwzWXlOY1ZtUHZpZVdPSTFabmU4U1J6RmJnNUt0MFFRZkFvMDB3VVlXc1ZLUHV6aERXZlBXc1dnYmRLd2xvRXp3N0lXU1FzSFZrKzhFOUdKZnk3OSt5MDIreW16TzZ2ZHlJTEcxOUZxdC9XS2ZNeUx1enU1dS83VWJONzZhcGtrUlJSR3hqVmlibjJPdTAxSVFXbEh5bnJYTzNHd1FyUzczVG9wY1hyNXhoWjk0LzhjT0FQS0hhWG1lNzRmY1JsVnRwOVdNMWZtak96dDdFb0xuNDgvTjhhUGY4ekM5ZGxvbnkxYUpJb08xcGc3U1VjSnMxZFVwVkZvREpxODhiNzAxWlB2bWhQWmdSTEczUTZ2ZFFNUlNacE83RFlWbUd0RnJwZlJhRGJxdEJ0MTJUTGNEdlc2ZzA2bDNUWFRneVhjZGs3NGpMVHhMUmppYUpHU0Y4dExXaEVrWlVDT1laa3h2dnMzaHBRNlZnOHZyVSs0TU1qd3c4UlZaQ0JUZVVIaXdZa2pFSUFGNkpMUXdHQUpqS2twMXhBSVc3bVRpL3NzTm5YNUowWDJlWDZlejVkL2Y5ZjBzUytJb1VxbW54YnhDNVVQd20vM0I2K01zMzR0dEpNWllqTEdrU1lJUGdWYWNIRnBzZFk4QlZ1cnhkeXNpY21KcFJkNEo5ZDZEUm1GZHdUV3FLa3VMYzkxaU9qblUzOTBWVldXU0YveXhUNXltckFMLzRMZGVwU2dkY1J3UkdZdU56RXlHUUdZTFREVWhjeFNsckVRZC9zRnZQcytnUCtIc1o4L1FiVm9pRTFHVkJsOFdpSm1GU2lFUUcwTW5TVWlNcFloaUNsdFJtSkk0Y2pVZ2MwT1V4MlNWNS9aZVlKQk5FV01abHpDdUlOMmFjbjQ1SmRPQVdFT3JsYkRZVGJpOE9lSHRyWXdpS0EwYkdJODhWU0VVWHJDaUJHYjlDSVEycVFvRnVlaXRBZFZGbEY2QW45M1MvRGVvOXo2bU00QUVRVUxieEl4RCtidStremUydGpDejhmZjlQR1JqT05qSXZidmRiYmNPbDVYWGFUV1Z2TXpGcTlkRzFGaGVhclVmc3NaOExhakdvdlhZaVErQnZla2Z2aXowdTdxS1pZeXB4MHRtMG1sSDFsWk9KRVovL01iMUc0dk9XMDRjYXNwajU3cGNPSHVjUm15NGRIMlB5aXRwSE5PZWI3TjRhcDYwRlJGSGdvMkU1Ymt1RHpXV21SOW5yTVFGTjlkTEhqcSt3T0pjays3U0JYWjNIRmZlZkFXb1dRdlYxd0g5UG1BaVk0aU13VnBMWkEyUnBRYUpoVmdpTkZpbXBiQlp3TVRWb2QydzhKUkZTVHNLMkRoaW5HVVlhdHJTZnVFWjVCVkZvWVRLNEdmY1Zvak9XcDh5aTVjRWl3SERheVA4LzN1aTd0Y0dWTS83bWhoN3lsMUZLSHdraG9heG11cy9LWmwyOGRhdE9rdS9XOHlxWjl0SzUrd1RwMDZkbjJ1MUg1OWttZFRhN1Vyd2lnYU1NV2I3OHQ3Vzc1VE8xUlNxSW01UzVDRUt3dlprZEFDUVAyU0FSQ0dFRkVnbmsvR3g5YzJ0eitKQzExVWk1NDR0OGRDcEp1MTJpd3RuajNEaStDTGowWWpScU1CYlMrL0VIR25Ua01UQzhVNlB4enZMeU82QUlzdFk3Z2p6dlNiTlZwZEhMbHlnTlhlZXIzemxHMnpldWxFVEk3aEE1UUplb1hSMW4wVUFINVRTSzdsVHlsRG5EUmhGTEpqSUVCa2hSaGo3Mm50WkFsbmxDSldqWVdzR3hOTDVlcmhSaGRMRGRFWXduVmhiLyt3ZzlRNjZnSXFvaWhJYjZ3VDU0a1Rkcnp0MG5YcjNZOEtzZ3o3cmJlaGkxR1RPcHZUOTc2NXAva01mL0NDVmN3eW1VOE5zcmkwclMvdWVFeWZQTExTNzc4K0wwbmdmc0RiR080K3J2TEZXd3ZwaytQbEJQaDB5RzZjSFFqdE50WjlORDBLc2QwS1lCWmpnZmNnS2lueGFjWFMrd1pIRkkxUlpDOWZKTUViNHJvKzhoL2MvZTRhdmZ1MXRYcjh4b0xuWVkzNnR3NjNyTzdoc2lsR0xWMCtyMWFLWWVpNmNtV2RwOVFKSFQ1M2dDOCsveFUvL282K1FobkpHNndtcUFhZEtYb2E2SVRsamMvY3FqTXA2eURDMkZvSkJOV0JqVUNzMG84Q3lFYllLVUJXQ0NsdFR4ZnNwaTcxb1ZvcFdscHBDTEphOTBqUDJucURRTXJaZTNaM2Q5WkZZTVdLeUt1Zy9HZ1gzMHc3ZG5RSGpydWNBUWlKV1d4SnBMWC80VHk4d0tiQXlQOC9WemMyQWlLTU9zNm9yR3h1dkhGMVl1cDRteVJudkFsaytKUkFrcUNlUjZOaUpoYVVMMS9lMnI4NlcxUXlJN0Uwbi96dXF5Z2NBK1gwelZaWDdPdW5HV01FYThWUG5hSGRUanE0czBraldpS1JQNWZvTTk0Yk1MOHp6UFo5NGhrOEVJZGVJcE5YazU5LzhJcSs4ZW9YM2ZzOTVKSUF2UFZGamlhT25ubVY1NlNSaWNwcTlGUjQrZXdnMzNDRTFFVlk5VlFoa3BhZW9GS04xRGJYVmpFaHNIZnE0b0pTVlo1SlZPT2NJSVZCV2pzb3A4eVV3aE0zTTRGQkVsVkVlUVFnMDA5cmpxRUxEQ0YyeEROVVRSUWxMM1RteWZJSnpsVHFWN2N5NzEwRmVHUVQzaTVQZ0xuTnYzN3lncmtScE5BUEhuRW00VnYxdkswSmRXZCtvUjNpOER6T0F1VzljZnZ2SzA2ZlB2RDJYdHM1WVV5dm9pakc0NE5VRzAxcHVkUjh4SXI4WmFxOWpWVlVHK2ZRUC9Zd2NlSkI3bys0aUloZ3JHR000ZDN5Vnc0ZlhXRHQrbGpqS0dVOHZrZVY5ZGpjZGNaeldCVUFWY2tsNTh1Z0NibThINXlNTWxxaTF5b2xIUHNwY2J3bmlHR004ajcvL0hKKzVjWXRYdnZnNTFGdUt2QWFJYndUQ1RGNUFROEJZb2F4cUhjSm94ajFrWTBzdVN1VWdrZ2huRFpHdE9HVThwY0plYmpBb2prQldHcnl6czY1NFhXV0xqWEM4MVdXNTI2UFhiSkpWSGRJRXFaRHFTbi80dVd2YkcvODRxTzdPUUpIdGd5TzJVYkRHYUZjU0NsY1IvbmNJM3Z6OUwzK1pENXcvVCtVcTNadE03Z0prWnpRYURxZlRxOTJrNlgxd0JsUmlhMGlUbU9BMVdtcDJ6clRTdERmTzY3bXNXWVgxRDEwYitsMWI1djNzWnorN240UHNnMFNUeUM1bFdiVzB0akRIZDd6dnZSdzlkWWJ1d2p5ZGhaTXNIL29vaTB0bmlLT0NLaDlUNWxPY3kvRnV5bnduNW9tSFZqQzJ5OXpLWTV4KzZudVpXenFDNmM1Qk0rWFM5ZHZjdUhxRHlFWTFXL3JkWUtSdW9xaXZxWDZDMWhJRCszc25CaUd5cGxhYWltcWxxVVlTMDRoam1rbktYQ3ZsMUh4RUt6WTRvTURqOFBnZ3RWQ1BOL2hnS0lQU2FiVG9OT3BOeG1aa2FEZmFlbWh1ZWZYeGsrZmUyMnkyQW5lRmJXb0cwalJPd3NuRHgzam1rU2NvZ21NWUNtNjQvMzBKYzYvWlpKVGxpTWorR3E3M0llUWJnLzdiUlZrTW5mZFNWaFZCQTFwWENreU1uRC9jblQvQ3ZhVzF1K1AxQndENVE3Qk9weU5SRk8yREEyTkV6aHcvZXBwZ0c5NEhOVGFoMVc3aXF5bnFKOFJKaSs3Y0V5d3VQY3ZjM0dIaVdTOUVmVVVrU3F1MXpPTFJwemoxeE1mcExoL0N0SnNNSm4zKzNzLzlBLzdhZi9qVFBQLzFxN1d3VHVGci9RMkJvSHBYWXVCYmFzNm0zanVSMlo5M1FSTGJHaWd6V2JZMGlqalVqVG03RUdPTndXSElVU3JjRElLelRkaWdyQS82NUdXdHJlTkR1Uit5UlEzQzhVWVVOV2NBVVVHQ0dLUHpjL09zclIzU3Nxb1l1dnlmNmIwdHFvcEhqaC9YeUJpZE1aNDR3RjNiM3JwY1ZOVmV2WGhZdit3NGlqREdZSXp0blZoWVBzNTlZeWZ2QkpBY2hGajFKeUJHakR6NjhJV2tHSlp5YzMyZGkyOWZZVHk0d01yaE5ZekowV29MWlo1Rzl5SG1WaDVsTXJqRmROeEhRNGxwem5HNGU0UzUxZVBZSkFFLzRjMFhYK0cvKzl1L3dpdXZiYk84Y0l4MnN3T2pXbTRnU0MxVVkvZXhNWnZXclVmcTZ3VCtybXN6WUlJUUcxTVRNd1JtZXhzMWVJd1hqczRKdTdseVo2aFVlQ284VVQwNVZxKzZZc2lLZ3AzSm1DTnpUWUlxemdmeGRiTnpaYms3dDd3ekhMek5iQUJMUkRCaVZGVjUvdlVYLzVuZno5MXlnMDY2U2l0TnczQTY5ZnRMVkcvY3VuWG5BMmZPWDAvRW5BNG9JYWdFbE1vN2pKTzVqazNPVVJQMjdZUGtEOTJEdkdzQjhpMENrbElmSkRGMmNQendpdC9kMldKdmQ1ZlJlTUxodEV1Y2RDaUhseUZxRXJVV3NXbUxsb2xJMnl2NGNramNXeVplT0lvWW1HWURmdm5uL2piLzQ4OSttUkNXT1gzMEhCR0Mrb3pZbHNUVzRvS2krK3ZsczBGSWticHBKNnA0RkxQZm8xREJ5RDVpQkRVUVllNlNQZTk3bUtNOVpYTmNvVUdvOEZpRVpCOG1JaVFhc1RzYXM5QzBOSk1ZSHdMT2U5SW9XVDY1dVBTZU4yOWQvL29zT1RhcUt1dmJHK0pjOGM5VVFacnZOUEJCK2FHUG4rSG5mLzBtV1ZrU2FrcFNENFJ4bGcyMlJzTkx5NjN1aDRxcWluemxSSU5TQlkrV21pUW1PdE50dHVaRzJYVDhiUjVFRHdEeUIyd1hMMTdVc2l5WmNUR3BLbHBWVmRacUphb0tPLzBoV1ZhaHhFVE5McTdjUmwyR1RWS0lFNHdHTUlxTkRJSkJmYzZWTjkva2IvejAzK2NYZnUwYlBIVHlTWTRlT2t5b0hLNnNjRVZHSElHMUJsZVAvZDJ0RHRSS2h2djMvZDJLd2QxV1h0QjZnQkFGSXpXN1lpM3VYS3RTZ1dHK3BTd2tNWHVGVW1tb1dSZUJoc1JZSTZnYU1sZXhNWjV5Y25HNXpvQjlSZEJtT3pYMjRYYXIzWjFNSjdXd1RhMnM1ZE0wQldCNXJtYXBOOGJVSjNhL1RDMjFVS2NSdzJCYTBSL25MTTAxK2U5LytRMHFGNlR5L201K0p5SWhxQmJYdGpkdnpoMXRWRVZWUmE2c1M5NHVCUEt5SW00a1o0LzNsazY4bGswM3ViZW5MbitZSUhuWEF1VDU1NS9IR0xOUFY2T3FxcnVEMFhBeGJRUUJHV2NGZVJtb1Z3Z0ZzUzNFamVxdlRZUk5tNWhHRS9CVTJZaGYvd2MvejMvNlgvMWRYbnhybDArOC94TWNYVGxNNVdZeTVhSk14bE9LWG4zekd3UEIzM1VLczQ5Zjd4NkRmUUsxL1JOaDd2N3YvYjczck5vbVNtUnFxYlJPQXc1MUczaFZkZ3ZGNHJFRXZBWmlZN0hCWUlLd1BjbFlhQlVzdEN6QnU1bmNkSEowc2QxZW5Fd24yMEFVVkkwUk1YdkRvUWM0dk5Sa3U1OWpyY0ZJTGMrMk50OWlYRG4yQmxPc3RZeXlDa0NHazVLOVVTNnFTTjNQbUkyeHo3UWViKzN1dkhsc2JtRmJ5M0J5bWswMXVDRGVDd2JMWEpLYzZVU05aMFY0V1pXVWU5TFdlbCtiNVFBZ2Y5RFIxZ3dnWWE4L0hKdzhlenFMNDZRTFVIbkJSRWw5dTlzMkloVmlrem9rQ3dwSnlzYjZUZjc3LytHbitabGYrQnhpVi9uUWU5L0QwdndTemxmSTNVVXJRNVlWOUE3SE5CTkxWYnE3NFpHZzJGcSs5bTUzbTFuNForcE85N2ZrSk55OXdiV2U1NXF4T2JiVGlQbVdJeXNTaGxWSkNCQUlPQUloMUFOT0VaYk1sZXhNSm5RYURTUUVYSlZqNHZqb29kN2NpUnRibTFkbUZhUW9xUHJKZEtvQXIxd1pZTDV0ZFBEYTV1UnVnWU1aNllRSVVqbS92MTl6VjBKQ2hBWklFMml0OS91RHQrK3MzMGpVbmhBVTlkQ01VMUJsbkUzamRod2RTYU9rbDFmbC9WTFdzaCttL1VHRDVkMitjbnMvNFJrbU10bmNmRytRSlBFS3FxaUcvVUFmc1Myd0U5U1hrS1NFSk9MTHYvTlYvdnIvNjcvbEd5OWU0ZEZ6VDNIdXhLbWF0dE1IY0k2cUxERFdFTHpIVnhtTmhxSHU0RlUxT0lKaVJBZzFwL3pNZTl3N0VYZmpxdGxwQy9mUWZMY1VyRkpUbmtZb1NTUXNOaElHWmN4T3J2aTdaVjlQYkdwRnFsZ3QvZW1VNVc2UEpMSlVycUtkTmxmbjI5MUhqWkd2aHFERnZZb1dmdjhYQ2ZjaXd2djdSN1BFYUQrdnV4c1MyZG5aaXBncGRCbERBMGdxNzJWU0ZGZmJyZllISWhOWm93YURnYUFxR3FRVnhZOHVOZHVIYjFWbFBudkpNdnMrK3pMWCswRGhEd0lvQng3a0hrQUNNRjA3dERKTWs1U3NxUEFCcWpJblRneXV5bkErSWxRNXcvNUZmdm1MYi9PZi9PYy9UWCt2NGtOUGZZVFY1VlZRUmIxSGdsSlhhU3Fxb3NCNWo3Q0FCb3ZJZm9KZFk5UEl2ZXBWTFJjOUM3SDBXMC9pdnNhejZMZG1LM2V2YXlOVXFzU3g0VWk3eGJDcWNGNFFBcFVHSWl4V2hFUXRFMWR5Wjlpbm02NmdlSzJLSW1wRTlyR1YrY1hsamQwZE4vdXhzWUsvRzlYeExRQ1JiMnV5M3YvMXZqS3dNVVlhYTZ2ZCtiVzF6aE5wWk05NHI0Mmk4aE0zVWxjNDc4cmdvMmFjRWtXR0VEeVY4OFEyT25wb2NmbTBhYldIZS8xaE5NNkgrMUlVeFF3a3hUOEZLQWNBK2Yyb1pJbUlxbW9RRWQzZTdRL0grZlRPd254SE4rN2NrczNkSVdWUjBHdzJDTTRoU1EvdmN2N0h2LzBML1BXLzhRVVd1a2Y0K1B1ZW90dnQ0YlVlRjVtUm42QWFDTDd1anFzQ1lqRW1xcE56dVVzWWNhK2FwblhwOXg1cTl3RWc2S3dzYkpnTkw4cTlNRXQwUmt0b2hGNHpacWR3ZEpPWWhTUm1Nd3NZNnRKdmd3Z2o5Y1J3R2l5RDZaUkJsckhZc1ZKNVQ1d2taM3VONXRFTjdpcmtKdHpyWkg4N1FMaXZES3N6TU1SU0U3SVlhMGlPSEo0L3ZyTFNlVisza3p6ZDZhVHZqVVI2cnF4d3FxVmZaTHA3cGJDaFVqVFVqMEhFSUNUUXUzRHN4Sjk4dUJOL3gyUXkzZHZibTd6NDVkZGYvcTNTbDN2M1ZiYnViOHo4dnZMNXZ1dERMSzFQYUJDUnNMRzFrNzkxNmZxVlJocHIwRXJXTis3Z3FucW5HeFZFSXZMSmtGZXVWbFErNWIzdmVaWnVxNFAzdnM0WFFrMUI2a010VzZBb1NhdUQ5VkE2eGNieGZRQzVMd25uWG1KZU45RHVlWWR2LzNwL1d6emNQWm16Zm9yQ1hNT3dNMnMwSG1vMUdaWVZoVmRLQWxYd3BNWmlqZEFncHZBNTY2TWhjODBHWXB6RzNoNmViemFmanF6ZGl5TTVIQnV4SWtScFlwSWtramFJamFOSWtzak1SNUdaUjVISk5BY2pwdDFJa2pTTjJ0WklGRVZXcFpFMEc4MzRrZUQ5bWVCY09oNmhaVkVnYW1XaGZhVFJqSlBHRmxjcGZWVy9sbENRV292QllJWEVsYU9udTgzdTAwZFdqdEY4cUxQOXZpZWZlTGcvbVh6OVN5OTk4K1hYTHI5MTgvN2NjZit4MXVLOVB3REl2K0J1T3FQUjZDNVZUVkdVSWMvTGJjVTY1ME5hNUVXdHoxSEU5WnhVOENTdEhtdUgxZ0NsY3E3bXdOSkFVSzFES3grb3lvSVFISkd4T09kSjBvaUYxU1ZNTThIRzV0NlEwWDFWS3lOMS8rTytIUDFlOGx2SFZ2ZGltWHJENjc3b1p6LzRuMFU0c3lXczFXYks5ZkVFaDFDb3g0WjZkOTZJa0lwbGxHWDBzNEtscUVGd1ZhTmp3L2RkT05aNXdsZDZwUEpWRk1kcUkydHNXV21jeElscE5TT01TRU5FR3VOeHFXbHNhTGNUbTBSV3JMVW1zaEdrS1kxMkpLR3NDTTVqazBpREJyck5KVGs4ZDViNTVockJLOUhwTHBmZWZvUHBlRXdNa0NRa0ptSmNlUHdnWWZYa1l4eGVPa1duMVZ5MlJ2Nk1xNm9mUEwxNjhrcy8vUnUvK0orOCt2YkZhL2VGeFdFMmNLb0hIdVJmc0ZWVmRiY1BBaHJLcWdydFRuTWMrU1gvK3V0S2Y1UXhHVTlwdFMxSm1nQ0J5Q2JNZDl0TXBsTTIxdThRcndYUVFLdlZ3VGxIa1U4SnpoRlpZWDZ4emFuengvall4NS9oeEpuajdGMytKbkVjMWFNa3RkKzZHNVBKckRJbTMxYXBNbklQTUhXeFN3ajdma1h1eFR3cTBFaUVkc05RNWdZeHluS3p5VTVlTUhHZWtrQ2lBYXNXWXlBbFFyMWpzeitrMjJoSlpDTmFTWExPRmp5VXVVcXNyYXRrVlJYSU00aHRtUFU4Nm9wQ1VWWWtpWm50c0FTTU1USW9ETDM1US9pd0IxVk9NMDJRT0pMVitiTWNXN2hBYXYvLzdQMTNzRzM1ZGQ4SGZ0YnZ0OU1KTjcvVS9icGZaM1JFVGdRSmtBQ1lRSkVXTGRHaVpKSWppeElsYTJUSlpiazhkdGt6R2xuanFaRmQxdGhUTlZVenRzcFI4bGkyS1Z1V2hxSW8wcVJJaWlRSUVDUkFoQVk2ZDcvdUYyODhhYWRmV1BQSGI1Lzdib01nSlZFQUpBN2U3anJWNzNXL2NPODVlKzNmV3V1YnhqanZRSlhkcmFlNC81NzcrTkp6bitmcTFaZHB1ZzRuQWU4Y1cvZGVRVXpHcXpkZlpXTzB3WVh0QzNtVkZ4Y254Zmpidi9tcGQzMzhDeTg5ZjNzb0RyZGVBdzhMbDdzRjhsVnVzUmhhTEkxUlEreDk2SDA4M056YWF2T2lHTi9ZMytmaytKaWQ3Wkk4ejRneEVyM2o0dTQyUGtUNnJzVzNLM1FRTUsyV1IreHVqWGptYmZmejlGTlhlUHpwaDdsdzVRcTVnakdSZXVNOHRwZ1E0NEsxWS96Z1FYVktIVmw3Y04wQit1WE9FSytLeXAwV3k4aWRQYXNBbVRVVVdjUmIwSmdJanVkSEkrcGxqZGRJSUNiekNCSitNdEljMTN2bVRVTlZsR1NTbWRBYjdWMmtVS0hYU05kRDFHU2U1ME1xV0dzeXFTb0xBajRHakZwV2JVK3h1OGQwZTRwckZsaFRVVlNXQzlNSGVmeWU5NURuNVpEeFhwNjJpbnZiMjl4ejdnSy9YR1I4NFhPZlora2FwcnQ3TUEyOGNQTlhLSElsazR5Yng1ZmwwUXR2MDByS3pRdGI1Ny90TFE4OC9DdlB2L2J5RzV4eG5mOWF0RmZmOEFVeUhvOXBtdVpObTZ5VCtlSWtuMndjWmRidXJwWnpsaWVIZUgrZTZDT0VGcStSalZIRnVLcnd3YkdxV3laank4WHRqUHZmY1MvZjlQNjM4ZlNqanpDYWpva0tVcDlBalBSUnNjVUd4WGdiamRmVHZDbG5XNlprTFJRaWQ0WjJXZE5OMWlkR09ubGltdm5QSUFKNkNpZ21Ya2NrTXpuR0dQWkdJNDY2d0tKdmNRUktNb3dtTTJBclFsVGxjTEZnY3p4bUxCbTU1QkljZEVGUE5mZEdJSVRCZ3RVSWFnS1NqRjF3VGxHTk9HTTR2emZHTWdNVGs5TktNZWJlYzIraExBcktva0RFRW1QQU80K3Fjanc3NEkzOUw1SnZ6dGkrV0hMN29HZmpZZ0g1SVZVZUtMT01FQnkzWnkvUzFhMDhmdTZkYkk4M3Z1VURUNzNydmMrLzl2THROV1p6Qmt6VXV3WHlWYnkrdkRpQTZHTllabGwrVU9UbG83UEZRcHY1c2ZSdFMxa1dOS3NGYlpheldjTFd5TEpSR2Q3N3pBN3ZmK2M1SG5ub2ZzNWZmcFE4THdqTzBjMW14T2k1ZlR6ajQ1OStnVi83N010ODdDTnZUNTY3T2d6WDY3bGNrdCtXR2REQkdQWE9LbmpkUzYxbkRybERjRnlQcW1iZ2toa1JOa2NaODlxVG0rVDdOY296N3BtTXFMMm5pNDVNUFZWY2M3U1VER0hWTk15YWhsRyt5VVplY0N0YTZqNmt6RVNFb29BUVVtdVg1Mm1GTFlPdXZxNDlWWlZUYkl3cFI1N01CTXBKanV0N3lteUtZVVFVZzgwc1ZWa1NZNlJwT2w2OTlqelhqejVINjAvSWN1WCtoOFpzbkxOVW0wcFZLa1l5UW9qMG5hZHRPbHIvS3VmS2U3a3lmbmo3L09idXV5N3NudnNIdDQ4T21tR2pKVy9hQ040dGtLL09GVUk0TTRPa0FybDFjTEI4NG9FciszdDd1OXkrK1RyWGJ0N2cwZVVqaktkakZNTnF1V0p6bFBHdi9jdmZ6bHZmOGdodmZmd3lwVzJ3V1ltdlc1dy9wdXQ3WHI5NXpFOS8vUFA4NGlkZTRObFgzc0JraHZjK2ZZSE56Q1VhKzNBaTJEWFB5a0FjWmhBajZ3WC9nSGVzV3pBU1JYN04vazB1YnBJS2JiZzNOaXZMNWlqU084RmdVQ1BzVFhMbUx1ZkdNbUJKQ0g5T2p0V0JXcS9LN2ZtTTdmR1lLc3V3Um1oY1pKSmxSQjJpRG1OYW1XV1pJY3NzUGtaTWN2Sm1QQ21RYVVFVXhRMkZrK2NaVlRGQ1JHaTY5blIxUGE0cWJoNit4QnZIbjhMbWprSXp2UFBrbVdWbnM4SU5NNWZySGE3emhONFBKbjJPL2VWMVBiOTVqK3hPdDkvMytKVkhMdDQrT2pnUkVadmdvYS9OcHZjdVVQam1mWHA0L2RxTkp2c21ibzhuRTEwMFhsNTRZNTl2cW10V2l3WEdaampYVUZyNC9nOS9FOVphdkJNSUdkcjEzRGg0aVMrOGZKMi8veXRmNERlLytBYjRuR1hiTUttbVBITDVBYzd2M2dQeGFPQ1FuQkp5TVVQK2lEV0dFRFdKRmRmRk1nemxDZGsvUTd4WUQrK3FCSkVoSVJlS2dTOFZoM1d5RVVzbXlxVkp4VW5iMC90QVRrem0yR0tTbVFPV2szckovbkxPUFJzbG1aWGtyQmlIOUp3STBWdHNudHErb2lnd1BoQTFCWmh1VENyYXpDWlUzMEFiRkFzNGRSUzVCWVcyYS9ITzhmeXJ6L0hjMVY5aU1sWXlXeUFTaHBrcllsUXhQckpxK3RUUzZoMGFqbGZsZUhWYmx1MmNDNU9MRi9ZMnRpOER6dzNkNmRlTUZ2OE5YeUFoaERlMVdNY25pLzVvdG5neGlwbUQzYnAyNjVDam8wT3lVVW1XbDdpdUk3aVc0SHBHbzRLbWRyejgrZzErN2xQUDhhdWZ2OHJSY1NDcTVjTE9lYlpHSTFyWGMyNXJtendycUdQRmhYTVh5Yk5uaVJoc1NOcVFESEJSOFhGOU9xUzRnekRRNHVVT2xqalE1TlBKRVljZXpkeGhxbENLVUpXR3hnSFJwRk5LTWphcmlzdlR3R3Z6R1M0cUJVbytuR0taV0txUWNYczI0L3o0QXB2VmlEZm1QYXNRMHFxb040VGdLYkowc3hyclFKUVFvQ2pTcVNLa1pGOHh5UytzQzNEU3p1bDh3empmd0h1SGk4cXQ0emVZMVVzQ0pkWm02ZTRlbGcweEdkWVJPNWVLZmloMEg5STNWM2N6amxZSGVuNzc0alFUYzlta0o4dlhsUEY3ZHdZNUF6cUpFTHdML3JWcnQ2OW1LaWRsVVc3TlZpc09EZy9ZM3RtR0t1SmRUM0FOODhVeG4zbnhHci84K1ZmNTRzdTM2YnVjdmEwOTNuTGZPY2FqVWFLd3U0Yk5jWW1JeGZjOWI5eGNVVjNhb2cvSzBuWFVmYUN1SFhVWGFGM0VCVDNGVkpKdjFGcGhhTGdEdUN1ckVDbXRwYkptVUh1bFZaaHF5akdjMTQ1VnEvUmUwckJqa2hlSkZSalpqRFo2SENIZG5HRXd2a05aZEEydm44eW9Cbk84TnZqaElSSnhJVkk1UzVZSk51dVNnWGRVak0xUytJNVBKNEhKTFVhVnpPWjQ1NWoxeDR6czVOVEZwVzViV28xa0liSnNIUk9iVGpHYkNTWVlWSVJSWmxuNWdJcWtod1pneEJEVWNXdnhPdmMyVjlwVjNTNkdMZmhkcXNuWHE4WFMxRkdFOCtkM1dtbENlelhMT1pyWEhKM01hWllub0JWaU12Szg1QmMrOFJ6Lzc3LzE4MFJYOHZqOWo3SjM3eGFqc2dKSnZyZG9oT2dKMnVCY2l6V0JYL3E1LzRXZmJsc09idDFPR2dnWDhTN2l2QTUzT2NUQkwwc0hSWlhCRUhWZzc0b2h6K0RJUjBRTU80UEpkRkVPSytLWStuemZEMzViUWVrSWRFU01DRG1HT0RBS096dzlubkM2KzBsbWNxK2ZuSkFaQ3pIOU9qMURmZ2xFWWxDOFM0dUIzaW14RDZ6cWp0cEYrdXVwdFNvS2d3bEsxM1c0ZzArajkxcGlqSFI5eTNLMndyZUJGUjNXQ01XNFlKUVo4TW1aTWlxTXh5WGFPVll1SklPOW1ONlBFQ0tyNW9qUHZmcUZUeno3Mm91ZjA1U1FHNytXK2VwM0MrVE9DWExIa2J5cDUvZHU3cDBVVmNWeWVjUzEyd2M4Y3VVZWltcE1waTIyR0ZFV1V6cW5QTGgzam5QYjJ4aHJpZEVqZUNTMmVGZmoreG9qUFgzZkRZN3BrZVZxaVlyaVFpVDRpS3BncmFTMWFUckh5SFQ0aVJHaUI0bHJFd2ZJakxDWkM0MHFoVTNHY01FclJUWDhnaWlvSFZhekNoTFdPR2hTR0FLNGRLc1BweE80a0RMZnpkREMrUkNHd0NCRE9PTytHRlhwZXlYdlUrZnZQWWhSZkFoRUY5aC9iUi9idDlnc0RmNHhLSWR5aTllZWU0bW1GemEzY2k1ZW1IQnhiMExyQXEwTE5DNG1NenhyVWl1cEVjRXdxUXBjYVBFRGM5bTVDRHBtZC9wUThHcWZ1M2x5cStHMzhzTys2cGU5V3h1bmZJMDFDN1Y2L2RvdG5uam9vYWVPOW8rZWFkcWw3RXdMSHJ2L01wUHBEbFVKWlZFaXR1Ulh2L0Fpdmcvc2puTnkwNVA1WTBKN2dPK1BjZDBLN3owaWhyTE1LWE5Ma1F0RFZ6VGNkcEhjUXA1RGtSbHltOXFwUERjWXMvNjFRcDRaaXR5UWlUQ3FZSE9zakhOaE9oYktjbUFXWnNxNFVveFZpZ3pLbkNHMXlpSXhiYlRNWURHNi9uZG1ERlZtSUFqandwS3BuSExCMXZJUFAzQ0hNeFJMK25Pc1RZSXRHWWFmeWFqQTk0cnpqcTNOa3NsNHhHUmFVVlVGZ3NGN2gvZU82VWJKN3M2RXpCaUt6S1pUUVJWckRFVm1rcUhkSUNoenpqTmIxQ3hyeDN6ZTRLbDQrK1Bmb2s5ZmZzYnViRzI2Tnc1dmZ2eHdkandIMmlIVXg5K2RRYjQrSjRrMmRldlBYOW85enI5VWVlYzF2N1kvNDJRKzU5ejVuaGlGL2NNNXpXTE9VeGMzT0RsZU1yYUgwS2RZTm9DOGdHcWNrMmVXR0pXaUVNcmM0bU42SmdjZmtwcElERXFrTERLc0ZYeFE4a3dINGt1YVFXSWhHQWJRTHNKa0pGUmxNWUI0NlZZZUZYRm9rVkxCNmVDV1VwWUpmTFRMak81TTNNWWEzMUJWQ0ZDYVpGYm5ncDZLckFhVlJySlZQRDFGSXBFSWF1L1FZS0lTWTlMQVIyL1oyTjVrZTFwUkZlblc4aTZ3YWpxT0Q5UEpHVUtrekN4WmJoQWo5RDdRdVVCdWhZMHF4MWpsOExEaitWY09PWnczaUxWczdZdzVmM0dFbUpVWWpYcHVZL2ZweCs5LzVLbm5YMy9scWtBMmVBR2IrKysvWDY5ZXZhcDNDK1RyY0IzUFp0ZXpMRnM0eis1czJYRGoxazNFWkZ5N3VjOUxyOTFrdm1qeFhjL2VKRVB3WUlRc04wd3J3KzVtQVRZRFkzQ3VKdzVQU2VNTVpaNmxId3ZrRmpLYmt4ZlpRRHNKV0lrSmVKQmswQ0M1SnBhcUR2aENaakUyWVJVaHBJSGVGb0sxRnVjOTNudDBFRnI1ZFhHV2txTFBBcWVJZkZpdmpRT1VSWG8wU0RRVUNKNUlJR1VpRmdqTlVDUVJ4Y2RJN3l3MlN6aTJEdTFQV1JScG9DOXl6TGdrTTVKT0o0V3l5TmljVklTWUlNYTRCamlIWXEyYm50bTh3UUxlT1Y2N1BtZlZCbmIzSmp4NFpaZTk3UkhkcXVYbytEWnU0d21LM205Y09YL3ZNK09xK3Q5V1RXTkYwbG1XWXF6dm5pQmZxeGJyck9DSFQvN0c1MTkvZU8vODR0NmQwZTdXMlBLNTU2N3oyUys5d1d6WjRwMWlNa3VlMmRQMlNCVnNMbXhPYy9MY2dza1FtdytOU25vR2E3aURVMlRHa2htYmZ1MkFsQk1GTlFaamhSZ2ljUmhPMTZ3VUk0YXlLTWlMREkwUkVTRU9ucnVES0FOajdKM2ZwOGxkc1Nnc0dxSHJJTWFCdHlXSlkyVk1DdS9zUW9wREtJeGxyRGtMOVNoUVlXZ0hOMTRkYUN5ZGl4aGpzREhOTUYzdkdaVUZWZzFlaFRBcXNFVEdROXUwczVVejNTam9uVEpmOUN4V1BhNFBXQ09VbVdXeVVTUlNwQXQwbmVHaFIvWVlqd3JPN1cxUVpKYmxTYzNpcENZM2xsVzNKRGZXWE42OThQVHV4dmJHcW1sbTZ6bGtpTlM3V3lCZjQwTGgzczNSdmVkWmZianlzdjNRaFlyZVJZSjNGSmxsV2xXRUlnRjdrM0hPWkpUbUErZVUzQXBGSnNRWWtaaVl3cU5xQk5IamZZY3RTMEtFS3JjWXpRbFIxKzZDYVM2d2lXQWx3OVBWRDQ0bUdZa0JqS2FiWUkxNW5MSk5oamJIRE5FSnFkNlNGaDUxK0JoUHlaQ25pcTcxTnl6SlVUNEdVZ3MwTUNpRFJnd3BGeUpQWitUcEd4UTE0TndnYXJGQzN5ZWlZSlZEdit6WkxRdzcxakllVzZyU2t1V0N5UXgrN3RBSUcrTUNKbW1wa09jR1l3M1dtRk1MMWhBVkh5TEVTTDNzV000YWdnc0VtWE00dnlFYjVaU2l5QjY4NzhJOXU2L2Z2dkg2R1gvbHV3WHlOYndHNWFySkxvN3pqMVhSL2ZCcWRseFVSYzcyT01lUzVnaXRoTTZsSjlWMFdsSVZHV0tVbU1XVU1LdHBYMnlzUWFLSElOZ3N4NXFFVElzR2RIUE12T2xaTlQxdEgwK2RGdlBNcEpiRmUzeUlpREhJV3VndGhoQUQzbnQ2azl6ZWpjaVE4NjRZRW5KdUIyREVEQ0JpakpFaVJ2cGNjQzdwU0JLZUlxZm9va2FTWG4yTk93aFVXTXpRYnBWRGdjaVpmelFxR3BLZXZ1OGlmZThaalN6em94cmZla0psNmIxSk9mTmlLSExJOGpUd081OGVNRkhCZFdHZzNneFM0bUg3bHBLZ2xiNzNORTFIaklxSzU5Yko2MXpZdUkreEdha1ZlK29ua0hBc3VWc2dYK3NUUkZWMWNCM01wbFhKcE1vWkZ3a01LM0tMUnNXS1JZd3d5ak9xdkVwYWNvbkRLalQ1K1pnc0g4Uk9BU01SaXlFYUQ5WXdIUmYwbW02VXFDa0lkTTI1V3Q4b1VXUGFQb21jVVJrT25kaEE3VTRoQVlJZHdNQVFJMGlpdlE4QnBaU0RlYmJYaUhOSnQzNDZpd3pnczhRN0VkY0pqa2wvcnlxRHUxWTQxYUhJOERzakNlRzJDV1drYmp4Ykd3VzY3TGgxVkxOeHowWVN0V3ZDaGJ5TEdDT1VoU0UwSVFuS2gyTE1nSzd6bU14Z01vc1B3Nm1xeVVjc0x3dThieUhDNGVKYXZIcndvbzZxdlY5NTRmVlhYay9ZcVFZUnVWc2dYNTgxbG9ZMjZxOFhtYjAreXV4OW84eSttV1U3TUhGUkpRYWZia3FVRVAyd29qU1l6Q0REYVdFRnhEdkNnR3ZZTEtOUXBSajhka1VLSWtyYmU5cXV4L3ZVS21VbW1jS2RhdElGTXBzbG5mdEFoUWRTSzZJNkxHL1hXZWR5S3E0eXhtQlI4aXlTV1lVcy9YZm5oKy8yRGs3STJrOWkzY29uZXhMQkltUm5UZTJHbDQrUkdBMFJXQzBERzFNbEYrVmdmOFg1ODFPeUxtQ01rRmtsdU1HZXBMQm80L0VoQVpOR0JBTk1xZ3lUR2VvdTRQdUFXRUZWMHF4WDV0U3JkamhST25uMjZwZXVOcTc0WDI3UER1ZkRvaTJJaUg0dG9xUHZGc2daSkgxNDZhejMxd3RyM3lpdHVZK1lkdlVpQmpPUUNIVWdBdnJnTWI1TFEzR01GRVdKTlJtWkpNZDJIenhxRFVaS1ZCMHlySFhSdE9LVmdXeW9NWjRoRXVucHNMbU9aZ3REVkp0R0hTSUlkSjNWUEp3OE1rUzFXWXd4cDIxVDFHUXZHbFd4b2xnTDN0M3hSRGs5a1FZQkU4Tko0b2VBVWgwV3V3WWxSM0ZBS1JaUkdYNUhURE5VRU5vMnNxcDc4a0pZblRRY0xEdXF6WXJjUldJMmJPU3M2SGlhVXhTR28xbkhvdmF5OW9EMFVjbUNJbFlvUmlsOXl2a0VwdmF1cCszNkdFTThDS0Y2Y2RXNHYvbmE0ZlhQRGhtSUhTa1BVZThPNlY5ai9HTkEwdVB0WlhmUStmQ2NNZWE5MWhxYklzTUdPb2Raa3diVGt6cUVnSVpJSmtLVzBuTVMvaG9GamFubFVucUtva0F5UzlkM3lYUXVSTHdMOU02aFJ2QStEQXhlSWJOMitJSVU1OU0yeTJTV1V6TXNnZUJUbitSOUFGV3lMR1dDWkhLblJWa1hvQXc0U2d3UVhESy9qc1EzRC9wcldyMm0wZ2dENXFFRHZqTHN5Wkp2Y0hycXEwRTBETVowWFFlclZXQm4yNkpOeit5NHBpd3p2QWc3bVpIU0doRkZuQTgwcmFmeGdYbmJkL041ZTZCOW1LTTJGRGJidG5CQk5CWXhwdTFZMzNwaXI3cFQ3UFVudnYvcEwxeS84VGM3SDY0cXNTWnBRZnk2UUY1NTVaVzdRT0hYZ1dyaVVlcFo2NSs3RDExWUk5dUdZZlc2WnRzT3lqNkRJSEZ3UFpHQnVhUWhrVFNNU2VRN3dOcUNnS1Z0V25ybmtCQnhNZUkxMG9lSUJxWHVlb0xHMUI0TmRxSXhwdE1seEloNlQ1N25SSTA0RndrRHpjTzUxSWJabUxJS2pZWmg1WnhvTEFaQmpOTDNnbk5DTjRDQmtTVEJQYnY4c1VPYjV0ZUdjOXpCTFVKcWgxeE1pU1paSm9iTVFCZE9PVElzRjVHOGlGZ1JUcTdONk5xT2E5WXdLbk9mRmZZZ1JGM1ZxNjVmenByanZuVzNJdkxDY3RXL3ZKcTNTMnN5dHFyeDR4ZXJ5WS9GcHIrY1cwc21HV1Zlc2JzeDVkSmtKNyswRVhjK2MvMzZRb21PTTNKYjd0citmTjJLSkF4UEpQL0M0ZXJURCs2T1h5cXNlWmRZd1ZvalJoVG53K0RDTHNRWTBpb1ZCcU80QkFqR0VBblI0WUpIckNHNmpxYnhMSnVlbEsrcExGWWR5N1luQkUvYlJlbzJQYVdOQlRFZVZTaE1LcmplcFg0OEJJY0NzMVdLNzB3UzNlU2tBc2wvSzNnOXBhY1l3NUF4QWwwYjZWM3l5T3J3cDQ1d25Ga0RHWVJzMkZ6NWxHc3puQjJuRHFOWEZmMzdhV09tbFVEaFVTdUlWZEdzYzFINkkySmhwQXV6SmZad21Sa1JHNFhycmZBSkgvVEVlKytDMDRhVVpMWE9XTXQ5OUVYZDkrRytCeDQrakcxMytlam9oTUxtYWNtZ2lHcTAwN3g0NFBMbXpzWXJSL3V2bjRMOEVOZStBbmNMNU90emlqZ2czbGkwMS9aWC9hZTNxK0p0RnNra3BObkQ2REEwcjBWUEJxeTE5QzRRNmk1Uk9DUnB4bU1FcjRFK09KYWRvKzdTL0JGQ29PbHJGcldqN2hUbkZEL2MyRGJqVk1XWDBIYURENGJlQmRRa0NzalNBeExJMWpUQ2RRaVBLRkhTeXRjNkdUQ05kTHFGQUU0VkowSlBkbnJieTVrQ0NhUjRLY0VPTXNjQk5aVWsyL0lhTnp1Tlg0VDQrU1pRSXlUenI1UWZZVUNsN1pQcCszb3JhQkNKYUs5M0RON0NtZGY2cnk2QThjcDFyOTF6Y2UvWEwwNDNubno1Nmh0NXMycUpQcTJxa3ltRGpNOXZuOXQ0NVdoL3ZVTlE3bHFQZnQwSGRTOUNyMHAzWEx0bjJhVVdaY3YxWWJqeDAxcFZBUTJLOXhIdkF5NUVmRmdYaFVKbUNLclVYYVRybGQ3VnFLYnRUZXM5cTg1UlRYZDU0T0tFWnI0WWtITEJxOUxIaUVTVEdLNE1HcEZCaHFzeG5VQmRTS3ZqSXJ0aitpQm1NS01mVnJBdUpDQVNsTTdEMFFLS21DVWpobUdkdTlhM24wWTV5VkFXNjJ3MFVZU28xdlJ5NHR6KzlTWWN1MGdEck5EMURQQW12ZXVwdmd2UWdINTVZY1F2ZXduSmZDR3FxbDQ5UFB6azAvZmQvL3MyeHFPTEIwY3o1aWNyRnZNVmkwWE5mQldteGxRNzNESEhQZ1VJRXg1MGQwai9lcHdnVWRQQ0pseWROVjk0MTMzYk53dllZbWkxUTR4cGlCNW80YjFMSTZ6elN0TW5COE1RRkxWSmUrRzl4M3ZIb3UyWTk4cWlpNng4QWhKLzlMdmZ3WGU5NjM1ZStQWFAwQzZiMU4vRjlBV3NXNmN3cU9taTNLRy94NWc0V0lteXBVa1NPL3c4bXNGR3lBL0NxeGpwaHovdjFqalExQU9saFVRck5zSXdkTXViUFg5dG9xdHJWRVRTaW5nYzVmcVJDemRkSDVmQWZHaVIzRC9HOHVQc0szN1p6eG5hSlFQa24zemhwV2NmbnV3OXUxUFk4MDNkU25PeWtzWHhncU5aUTU1Vk85bk82QzJqOGZnWG1ycGV4N1RKM1JQazYzdUY0VVAzeDAxL2NGRDN2L25BMXVneFRmNDNrdmIvaVpYYWRJR204L1FoMG5sUDV4d2hwdEhYWU9taWNyQjBMRjNFcWREMDBJYmt4bTVNNUROZmVwVnZlK2NqM1Bmd2c3enh4ZWZUUUN5cGxmTkJVd2huU0xQRm1tK2xSZ2txUTdIZWNXSjgweDBvZ2hsOGU2TXFUbEliVnVXQk40NDlzWThKUHpGMkNNVlJqSnFoYUhRWThnTXhDcTVMMzQyeFVRc2p1MlhXc2VqcGh3MVN5NTJJZ3QrcFFFNS9iczlvVC9BQUFJQUFTVVJCVkl4Z2tuQXc2VTBDK0JqTThPZTR4blVuVjkrNGVhME5HbGV1TjUwTG9rR0pJYUFTOGtMTjR6dVRyYTJtcnVlY1NhR0tNWDVOV3EyN2VwRDFnSHFIQ0NxQUZTRjNRZGtlNVpzWHB0VzNldFVzb09LamNqRHZPRjcyMUwxTEFKL3JxUHVXem52bXZlZTRDVnhiZUc0c1BNdE95WE9ZNWpETmhLM1NNczZnVk9IMW04ZUloZmUrNjBsaXQ2UmJMQk5GeFp5aGRReG8rZG9KeGE2WFpTS25jdHpUME0vaE5MQ1NCRlBwWmhReVNiVDNJaFA2SUtBcENzRllPekNMa3dWUWFyY0dGK0NvWk5ZZ2c3OVdPalg3K3JCcC8rN1N4YU5oeU80S2E3d3hFb2FvdGEvME9xMWRFZEhwTk5mTlRZc1JLTEtjSXA5STU3b0V4WW9VR3RXYzM5cTljTEdvdnBrWUNtTkVyRmg2bnpMakorTnBWa3hIbjdsMmZPdmF1cWo0R3JxOG03dWxNUXdmOGRSNktxYTllb3BFdnIzc250dGZ0UzgyM3N1czdmWDJ2T2JsL1laNWswNExIeU9yTm5Dd1VsNCtDYng0Q05mbjRMd3d0ckE3Z2trR1ZnS2JtemtYejFVOGNzK0VoKytwZUdpdjRJVXZ2Y1JMVjIreTk5QWpqTGMyc0tMazFwQlpLQXprSmpGaWpSMUNkZ0JyWmVndGtzcHZqV2VjdGt1aXA5UVJLNm5hRGVuUEt2TUU4dVcySUV2TXJkTmJJWGwxQ2Raa0dNblFhREZpc1RZbnkwcnl2UFRyNk95MWJkSG1LTmYrdWIveWovMCtONDFuTmt1YnU4NTVOa1pUSFdnaVVWWDdxREZlWDgwKzNSbHp6WW9oTTBZalNwR2xoQlRmZHZjWDNqeG04MndnM0g5dDI2eTdMZGFacXdUNllkUllQNTFlUGE2dm5odGxIejgzeVoveE1jcXE4eHpYZ2R3SXMwWTRxQU96MXRQNkZLNVpXYWd5SmJkSzhyZE53cUN5RURaR0JTZDE1S0dMSXpZbkpSc2JFelkzOWxER21ORW1ldzgrd01HTHp4UGN3TFd5Z3gyMXByQWRWY0VQOGx1cnc1TGdkSmhlMjVYZW9hR3NteHc5ZzV5UGN1RkloamxEd0toSmM0em84THhNZjdjTXVJNEF4dWJrbVFIcG5YeVo1a0pFV1B6OXovempEWG1hdG5WK3ZlUENVN2R2WUkxWnYrY0I4Q2YxNHFqZERsK2NpRHdxSUpsTmErdk1HcnFtTStYTytNcjI1dmI0OFBDZ3Zsc2dYOGZMM2VsZW9pb2U2RnlJcTZPNiszd3U0VWhqM0Qyb0E3ZHIySzhqblU5Yko0aFVDR05yeVVXVFZOWW9kcUJ4SXhGck1vb2k0L2lvNFlQM1hlR0Q3N2pDeHM0bWsycUhvcHdnbVVkMzk5aThlSTdGalZ0b1NPdmsweHQ1blZQbzdrU3FwVk5oSURPcTN0bDhEai9XcytaYmVxZEFpaHg4ZDhlazd0UWNtN1Rpalc4aXR5dkdXUEk4UnlXM3dwZWJSQ3ZTTDMvWDcva0gzL0p1bnJ2eENnZkw0eWpnRmZ5aWE1WUwxNzE0cmhnUnV3YXJVRmhGakdqdmVobTcrSTROVzIwZndzbVpPZVJ1Z1h4ZFpwR0JKVDQ4MFhxZ1BXamNaekxSNTA1cS9jQ3RSclVhaldSak5DWWNIWkVOaUhRbWRxQ2FnelZLbmlXU25raFMrTzF0ajNqMGdSMWVPS2k1VlVmZStyYW5xVVpRRkVXeTk3R1cvWEtDdWdmcDZ4WjNlSUlWYytvc0V1TEFCNE5Fa1IvbXBqaVkrZXFBejl3WmlVLzV2ME85SkhRK3M0STFhV2xnWkUxN1Q3TGVkYVVJV1ZyUW5wNGlTcDdsS0VWaEVvOWV6ZzVzbEwvNytYalpycEtHWlRpNUJmRWhCcmNJN2xXZmoyWUNPNFUxT0JPcE1rUHZlczJpWGpvMzNiM3YxWU5ycjR1U0RRR2haMVBxN3M0Z1h5c1FKRXNZaDU3Wlp2WExQdHgrYlJaKzhXWWp0N3dhc1ZhNDc5Nkx1cmt4VVJrTUVOWU0yc3lrRXlUTElzWUVqSWtVdWZDMnQ1empxY2VUKzhrdmZ1NEZQbnZqQnBjdVgySXlHckd4VVZEa0Jmc0hjMTQvck5tNDUwR3lza3d6UVNiSmk4cWt1U09wRVFka2V4akMxK2NGTWRITDE5UHgrcDRmS0ZsREZpTGtFaE5wOGt4bklpcG5Xck9COXo1QUdLbytGWkcxcCtudFoxdXM2Ym10My9WNzNudkg3ZG1oRG5CNFZOUUQ0YWhyWGwwR2QzT2dudWx3MmdrRytsV3pVd1NleUxQY0R2NTNYN05UNU80VzY4dmZrRVRmZUZNV1g0aG9IL1ZsUlY0R2FaenZ6NDNIbzhuNW5UMk9aaWVFR0ZKOFdDWmtGb3hONWd1NU5WUkZ3ZDdPbEcvLzV2dTQvNkY3K0xsUFhXZlJLOGQ5d09hQTlFU1NXZk9QLzlTdjg3Zit0OS9nblU5Y1lYTmpTck9ZSWFlby9ZQ0hSQWJIeGZWcGtNd1dUcDNpejV3Zlp6VWZjWmhGakVEZEJnNVhrY0xZTTc5SEIyTnN1WFBpY0Njc05NOHMxcmo5RzR2WlR4M1gvYUZBSnlMOXhpaVBqKytOK1J1Lyt0cnY2djNlWHh4ellXdUhQamhpak90azNBS2JaMWVtVzI4cmxjZDhEQklWT2hkd1FYRzk1K0tWeTlkdXRpZS8xalIxejUyQXo2LzZOdXR1aS9YbFQ3UVFHV1ZHKzZBYUVwMTY3WVI3Rzl6ZkIvbjFHUG41bXdmN0gzMzgvZTk5ejJ3NXUrLzFONjVKa0FIYzAwVGV5S3hsT2hreEtrb3VuNS93NktNWFdPcVlDNXNGamVTOGZqRG5QLy9iSDJlU0MrTWk0OUxXQnAvOS9HdDgrdFY5L3Q1dnZzd1Bmdk9UVEM1Y1pIWDd4ckRPVFJpSk5jUDZOcWJObEZpaHNBWVhkTmpRRGs2RXA5eU9OVVZlVHRXMjQ4cGdUVEtOTTIrcUtqMDlkYzdtTzJ1TXhMRENXTzhsc1RIZmhHOEU5MDkzWDI2TnB4eXZGZ3lickFENDQzcStiTDE3ZWNmazJxdVRTVzZwQjg5Z1lqRFMrS2ZIdHR3OWdwUEIyY1R3TmJBZnZYdUNmSVhyL28yQ1BpYXF4aG5BYTkzZjlzQzFydTgrdmJreGVlbnlwWXRQN2Q4KzNNR3JxaUo1cGt3bU1CbVZURWNWWlpIendPVXBUenh4aVovNEJ5L3g2dTBsVERlWmJsWlU0NXlZR2JvSSs2c1dyWEoyem05ejZEeEs1TkY3emtQd3VLWVp6S1RURS80VUV4dkVUU3FENi9zcFlIZ25VcG96d2FJeXRHYTVnV1dyaEdDR3h2Mk9GQ28xVUVrRGNwcEpJZ0VyblNEeTZ0Vlo4L2RtVFQ4VGFCRnhvOXpHRnc5cjNqaXVLVXVMOS8va3hiSTkyZUJ3T1JzQ0dkUUF1V3EwbHpiUDdlN20rWHNsaEhGbUxLM3oxQzVJVkNSVFU1MjdmT2xMTDkrNitvSWducThScy9kdWdYeUY2OElrNTZRTlNWMm5iNkpJblBLSlJDUWVIQjd2UC9uWVcwWlZWcnp0NlBBb0U1Q2drZkU0ZVZlVmVZNkk4TWlEMjl3Njd2alpUMXlscmFhTXQ4Wk1wamw1YmlnS3c3aktLTWM1eFRobnRGRlFqWElPdW82dEl1UFN6ZzU5MjBIc1VVZ2NLNTlPS3dZMFBRd2JyWFVMZGpiajhNNTJTazZEUTFWaFZnZWNYeXNQMTZ0aFBmMXhLcFNBSVdERVVXUlJsaTUrL1BtRDVUL3N2Sy9YYlUwZm9wN1VQWDJJWkpuRlpvWnFsSjhhT2Z6alhNZXJPWmUzTDlDNGRsMGdHWkJIWSt6bGN2SmVFK09sMWdlS1BFTUVlaDgwUmpIVmRQVDZxNHRibjRvaHVPSHJ1VnNnWDQvcnNQRmtScGdVQmo4RTFFVDlyVVVTWXFSMzdzYkREenh3b1ZtdEhxbFh0WWxxY0NHUzUwbkREc0s1M1lvdnZIekV6WlZTN202eHRWVXlxZ3hWWlNsTFMxWVp5QVRKRFZtUlZJUVI1ZWFxWVN1MzdFeEd0RjJIYUtMYU94ZFBwYkZyVk5PZVloNXJsU0JmaGxla0lsazd4RGN1c0dvaE44bEpKY2w3eitqZU5TSDVDWkh2cE16emZyOE9QL1hpd2NrWHVZTmdCMVhWdGcrb3FvUVF5WEpEV1dWazF2d1RGY2w5TytkWmRvMjQ0R1Vva0tLTHdUdzAzWDE3cWZwWUNpb1ZtVHZQclBkSVZET2RUT2N6Nno2eFhDMFhncmc3bS9xdlhwSGNMWkRmNXZKUnFYTERJMXRqR2grMEMzcjJKRGxkRkozTVp0MW9OTHE1dDd2ejlHSzV1QmljeDNubytyVEZFcFN5ekhqcCtod21VN1l1YkRHZFpsUWpTelcyakRjczFYYk81bDdCOW03T3hrWkdNUlRKeWl2WDV5c0s3UmxseVJKSDRucUZuTWlRcW1udTZmdEladVVPWjJzZ0w2cWM4U0laaW1vZHZEbXJrMHozVGdIZE9TNlRoRjR4SnBKYlQ3RFo2Njh0M044L1hOYjd2SmxDY3VlUVNnc042VnRQbGhsTUpseDVjSXV0clFuMzNMdk53ZjV2ajVkYzJqN0h3ZUtFY0daUWp6SEsvWnZuN2p1ZjUrK0tNUll1aHVTTTMzdXhpSlI1R2VNay85VmJ4d2MzaHlIOXE5NW0zUzJRMytGcXZlSlZjY004Y3NidC9Pd0hZSTVuczhVRFY2NTBSWmE5WXphYmowV0Z6aWxkSDFGMVZLT2NlUnNvOTNiWVBUZG1QTEZNdDNQTzNWTngrYUZON245b2wzc3ZiN08zVzdHMXM4RjBNNmZhU1BTSzJpbXZ6anFXaldNekY3Q0dpRkRtSmtsM0pXMTNYcnk1NHR4R21kYlZBK291WjA0VFhjdHVoNkhFUmVWa2xmQWJFY1VNRHRsNjZyQ2lHS01ZNmJBRzZuRmw1cVZxWHRpWTViWnBHOWNOUlpGeEI4MU9FYmlxZUI4RllMVjBYTDUvbDVkZXVNMTlEK3h4Y2x4LzViWjJjNGVqMVp5Z2NZMWY1b3JhN2NuVzFwN052amtFUDAwNGxlR2s2d2hleWJJOGJGM2MrL3hMdDY2K2RQWlV1MXNnWDhlcjhaRSsvSTd2dDRZUXpNbHN2di80bzQ5c3hSaWVXaXlXVmhCNnI3aGdtRTV5Vm5YSGFHL0s0OCtjNTRISE4zbjA2UXM4OHZqOTNIZi9mZXp1YkZPVkk4cDhRbG1OcUNaalJxT2NjaVFZRS9FZXJpMENiNXowakl3eUdXVURnVEI1YWUwdmVsNDRySG5zL0JnZFZyNXlaZ2lSdGRjdmR5SVBRNFJiQzA5dU1xeUpHUEZwMmg5c1N4T2Z5Mkhvb1N3NTBGaUsxYmZzN0U0K3NMTTNlY3YyenRpS2tYcTE3RTZwNnJ4Wm95SEo0QUxwV2tlV1dmYk9iMkNNc0ZwMnYrVk52RDAvWm5NOHBlbGJSTVRvMEdhSk1ma0Q0KzF2TXlHY2o1cFNzVzczTGNGSENwdVBNNVBkZktNNytMWGdRM2UzUVA2NXVBUkoxOW1UUk5xdUN5NkVOKzY5ZU9GeVU5Y1B0cTB6U09KS2pVdGhlMi9FKzcvOU1UNzRzYmZ4OEZzZTVPSTk5N0F4M1NZdnh2aGdFRXJ5Ykl3WUM4YWlNa0pzU1o2QjRvZ3VNdXNpWDN6MWdKT0RPWHRiRlRiUEtIUExLNGMxTDkxZThVMFBiZEc1bEc4dWczWitIV2lvWjlhM1FkUHBkRlI3VU1pTncrQUFReFNEa1VBbVBTS09vaWhZbGhObXdTTWFoQkRMM0pvcjQxSHgzcDN0MFZNWExtenVpWkYyc1dpYlZDQ1NuU2tVVkpXdWRRUWZhZXBleHVNQzd3S2pVVTdYK1RmZmpHSUpNWngxMmk5Y0RQYks1cmwzVkJvZlNkNitLblVmNkh4RUVDbXI2c0JQc2srY0xHYkxMOE5EOUc2Qi9ETXFrTExNK0FyeWcydzJuN3NzTDY1ZlBILys2YVp1em5XZEkrYklSNzd2U1g3d3ozd0w3L3pXcDVoc244UGtFMG83aHBqUjlrb01nb29kYUI4WlBvQjNTdlNLNjFwODB5SWhZR1BrNFBhY3p6NTNpMnY3TlRzYkZhTlJ5UzkrOFlDRFpjK0gzcktEYzhrMFlUMWcyN1hsNkJtem4waEM0QS9ySHU5Z2xLVnRGVVFReFVoSVJXS0V0aXc1bHBJOEg0UDBZdGN3dm1xVlorYiswU2gvNSs3dTVCM25MMHgzbytxeWFWeXJLWXo5Yk50RmpJcnJBOHRsUjJhTkZFWEdvNCtlNS9idHhla2I2SUpqVWszRUJTZnJPU1JvbEF1VHJmdTN4THk3ZHo2TEt0SU80YXZPUmNiVjJCU1Q2dFBYam05ZFB6T0gzQzJRZjViWFBmZnRjRzVuajFYZFNJenhyT2wxY1RLZnRYczdPMDFaRkkvYk1SdC81RTk5VVA3UWozMlFTdzllSWkvT1lVeEpaaks2RU9pY1M2bzkxVVNkRDVHMjYzQmRqKzhEWGRPd25CM1JyUnBpSDJrWExXN1ZFNFBuMVJzelhybFZZeEN1SFRhTVJ3VnZlM2o3TkpMQW1NR1ViU2lTNGV4Yk8vdGdyT0hhckdPMkRHeFdDUTFKZFBua0JKbFpzS01KMTN4UEUxcXNSRlNTdldxV0dUSEdJR0lRSkMvTDdPSjRWTHp0M2t1Yjc5N2FHWnUrRDBkMTNYdk9DSnBPajF0TmtXNWxsWkZsaHRtc09YV0JCTmlvSnRLNmJsM2Z1VUkyS3NlakMvbm9ROEgxMDRpeThBbS9qVDVTRnRYSUZ2a0xWNWUzdmtEVXIvb2NjcmRBZmhmWGU3LzVVZXFtbGNXaXdibXdmdHJsUUFXTWptWW55NDk4NzVQYmYvTGYrdkNUMy9YNzMyYkswWVFRREdKS01nTWhPTHJlRTBQYU5JV1FkTzFOMzlLMEsrcDZSdHQyckJhT2V0N1ExeTN0MHJFNHJPbGJqMDFWd0d3VmVlSDZrczRwNzNsa2w3M05BcXlRRjRheU1LY2dZcEp3eUIzTG9pSEY1M2daT0ZoMmJKY0ZZaUxXREd0ZGhLS3F1QjBqQjEyRE5hQVNUZ1ZZeGlTV3NqRkNYdGhoWHNxenNzak83KzZNMzNmcDNxMG5KOU95NjFxL2FGc1h2dncwVWFEdnZKNmNOSU1icFpCbGRzZ09LV2xjS3lJaXlkZWV5c2ZRWHFnMjNwUDVlRjl1aERvRU9YRTllYlFhbzJacTVlcU05bE5kMzdWOGxXa25kd3Zrbi9DcXFweThzTnk4ZGl6eldYUGFLNHZJQ0poc2JZKzMvL3hmK043ditJRWZlZC8zUFByNHBlM2VSK2FkUXpCa1J2QytvMjFxWExQQ3VaN2dlMXg3VE5jMU5Nc1pUZE5UcitiTVRnNXBseDE5cC9Tcmp2bnRKYzJpUzQ2SklkSzFYV3BaYWxpMmdhTmxSL0NSY1praG1UM2RTSW01WStaZ0J0VmhhbWVVNDdwbjFyVHNWRG1xS1puS0drT2VGeHhSY0xQcjBPRmtzZFlrTSswVXhURWtZQWxsbVZPTmNxcFJKdVU0Snl0c05ocm45Kzlzajk5LzhlTEdmVmxtVGc3Mmw3TUJsRDhsRk9yZ0ZyRUdOWU1QYkc5T3lMTUs3ejB4YmJNeWtNSlltMS9hMkh1bThPSHBHS01FVkU1NlI2WUc3NlBzN3U2SlZ0bkhEK1pIeDd4WlphaDNDK1RyZVAzY3IvLzcvQS8vN1M5ejY4Wk1tcWFYTzhYQlNKWHA1dFpvK3kvK1J6LzQvZC81ZlcvL1k1dmI0MHMrUUIvQkdvdTFXWXBIYnZ2QmFjVGdveVA0aHRDdDZMdUcxZXlJdm5XczZwNm05cmpHNDl0SU8yOVpIYTd3ZlpxMCs5N2huYWR1UE1zbURlQ0x4dlBLN1NYelJVY3BKS3NmSTVoTUtBdExtUnZxTmpCYmVXYXJ3TTJaNTlXRG1zM1NVZzN4emxXZU1TNExUbFM0MmdRd1ZUTHRrWUF4OW83MFY5WUZZaWpMaktMS0tjcU1ZbVFsTDZ5WWRJcU5wOVB5TFR1NzQ3ZnVucHRVaTNtNzN6VE9mZGs5ZDNvRDI4eFM1Qm1ib3kxNjcraDlMNUljZXZPb21tMFY0d3RUTWQ4cU1kaE1ERXNmS0kwUkY1UXlLMnl0L1MvczE4YzN6NXdnNGU0SjhuVzhzc3p3MU52dWwwOTk0bVZaTHRyVElSSVlBeHM3dTVQZHYvZ2YvdUR2LzdidmZPWkhpeksvMEx0QVVEME55eEdSWkJIa0FzNTcrdWdJMGRHN0h0ZDd1cTZsYmh4TjI5TzBPVjN0Y0UxUHQyeFpIcmE0eHFFeHRXS2Q4eW5EYjk3VHRHY000QlJzOFBSTnc4RkpOeGc0R0paZDRQcnRKZGNPZTE0OThyeDZVbk4xdG1UcGV3cHJDU3BFVFVUQVdZeThWaS9wb3NPSVFkY2hiT3ZOMkJwVkpNMHhaWmxUakhMeTBwTG5CcHNKTmsrU0FKc1p5c0tlbTJ4VTc3aHdhZXN4RVRrNE9hNlBCdjJHdktsSUZFSkk3OWZ4OGdTVGlHTUdTQVV5bWs3Mzh0R0hjUDAwTjRaRjhPa0VDVkVMa3hlVDNjMlhielhIbnc4aCtETkZjdmNFK1hwZDFncWYrSlVYNWZod0tUSHFldVlZQXh2VGpXcnJQL2hQZitRSFB2VHR6L3p2VFc3T3hhaERLbGlDcmVOZ0p0MTVoNHVCdHExcG16bmU5ZlRka3FhYlUzY05YU09zVnBHMmovUk5SMSszTkROUE8rc0ozb0VPSGx3KzBOUWQrNGNlSCs3Y1k0VVJMazhOcGZVMGJjL0p2R0c1NnRpZk9WNDhhSGhqM25GanRlS2diV2lqSjBoa0VUeUw0RmxGVHgwRCs3NmxpeDRrRUxWSGpKSUdjamp0a0laQ01WYW9xc1FkeXdxVEZKU1pVQlNKazRXSTJOeG9NYzZLb3N3ZjJOb2N2WE04TG1PejZtKzNyWE5EQWF4bmQ0MnFLbUlvOG9MZTkydGVsZ1hLVVRuSzlzcnhPNHp2NzQ4YXRWT1YzRnBDZ0JqVTdPM3U5U2ZhL3RKaXRhaEY1S3MyaDl3dGtIL0U5V04vOWlOTU55cXV2bkpBMnpxamQ0cGpKTUxHZUZKdS9oLy9yei93dmQveTRhZitSREd5bDd6dnhNV1EycWgxUGdZNXpudWNEMm51NkZiRTZHajdoclpkMFhZOVRSMll6MXVhdWlPMFBjRUozZHpSekJ5dTcwRURNVVo2bDBKMFprY3R4ek4zQ2djYVVjNlBET2RIbW1ZT0FUU3liQjJ2emozN3JhY09QWkVVK1d5SGlJVTBXeWdlcFplRVM5alROaW9ONHlteFNrK2RWV1RJV0RRaWxGVkJNY29TVVRHM0tmcEJCTEhydVFWSmhXTW9xbXg3T3EzZXNiVTF1bUtOSEIwZDFVZGZkcEtvUyszVm5aMzZjRkkzd2V0ZU9iMTNJdkl1QzlaSFJjVmdJdEo0TDl2ampld2tOTDkwdkpyZFBzUHUvYWN1a0x0NmtOL2hldmY3SGxwakNES1k5aGxWTXFBVVlRb3kvZU4vK2lNZit1akgzdnFucTBsK3Z3dEJvNHFvNzFNSXBzMHhKazlicWhnSW9TZUVEbXlHK3NRV1JuSzZ0bWUxY0hSdFRKNVZiYUJyb0puM2RLMG5oc1RCOGk2a1RFSWZhQllPb3lsakl4UGxRbVc0dklIYXdYTkVFeXVGVmJEU01ZVGpyRTBaMWlJc0FTc1p4a1lZaUpCcndtTGFVcVhpSUNhdGllaHdtZ3hobkJxRTZNUHBObzZCenhXSFhYS2VDY1lhUWxBeWs3QlZrWElqeTgzM2xGVjJYNTVsZi9WTHo5MzhwZUZFSGtCL1Bkc2VuZHJCT3RkMWpZYVhvMlMxUnI5cGdWNlVVVzdwbmRJdDY1MHJsKzU1OUtYYlY1OVY5Q3hZcVhjTDVHdDB2ZmJhSWJOWncvNnRPU0xZR0hWZEhCTlZKbi95WC8vb0IzN3dYL25nbnlzbnhmMU4xMnRFSmJRTjRoelpkQk1WUTl0MWREN2dnOGYzRHVlVUVLSHVlNkwzZU9mb1dxVnRvZThqNmxPY2REUHY2Wm9Xb21JbDRuekF1elNIckJhT3V2RmtLSVV4ZXI2eWNtNHNaQkxpV2x5RlNPeUNzU2RPWkkyZ2kzQTZaQXVEdDdCbVEzcFVpeElIdjk4N2FWYzZaSm1jK21ldHczdENUTWxZSWFiQTBSQVRwcE1sdnBScXFzcWlNblJkVEhVNXRGMWlVWnRObjhtTStYZnkzRng2OXRrYi82dEwzSzJ6c3RrMXpMNDJGSGV0aGhzbUwyNkxsODFFdUF4WVl4RkIrNjR0cDJ3OWdjamZRelViN3UxLzZsUGtib3YxTzF6M1BiREg4ZUZTVG81ck16eVZUb3ZqKy83Z2U1NzRFMy8yTy83Tjh4ZDIzcXBSTkJJbG9tUjVSVkdORVd0d0xzMExyZS9vWEVNSWl2TWRYYitpN1ZwVzlaTDVyR08xQ3JSdFFMM1N0WUZtN2xnY3Q0VGVJNXJDTEhXd0QzWE9jM2k3cFYxRnJGZ3lSREpUMUlIOHhUYUduM014dnRSSHZuVGN4bC9jYjJ6d21JdVMzS2pCckRHUnRaN2RESkZyS1FXRUlaZlREQkVNREx0Wm01enN6c3dmZDV4V2lqS2pyQXJ5WWhqU2pjSFl0TlN3dWFCR2lER2RabWFZOHNXSWlEV1M1ZGxXVmVadkw0dk1ueHpYTC9rUUE3L1ZudlIwVzdpS25zdlZ4dHRMZUlTbzFDRWdHUG9RRVJWYlZ0Vmlub2RmWHRYTDVWZHJtM1czUUw3QzlkLzh6LzhXeTJYTHF5L2RsSk9qV2xSak5rU0dqMUdtMy9tOTczamt6L3lidisvUFhyNS83d01HRVZVVlJDbHNnUmlMeDlOMVBXM3Y2YnNhRjFxY2F5QmF2SFAwZllkekxmV3FvMTRwdms4K3VLR1BkRXZQNnJqRk4zMGlIb1loNURNcTNnZE9qcHU0T0k2TXpTaGFrOTB5eGp3YmpQbGJSNjc5cjI0MTdjOGV0UEdYOXR2d3kwZE4rR3dmNHVjek1TTnJ6VU9ZZGJlUTRxT05tRk9SMUdrVW01cmh4dGZUVm11ZC9TSHJFMlRkdFF3b2ZaYm4yQ0xENXBhaXNKZ3NtZHpsbVp5YWNVY2RqQ1VHbDBoakpOSHdyU0hMYlZYazJkUFRVV0dYeSs2VnJ2UDlseFVKYTVhQ2p6RzdiL1A4azNrSWI0MCt5Q0o0NmFKaVZhVFh5T1o0US92S2ZITC81T0M2U0pwRFJDUWdvdi8xWC9sditkcy8vYi9lYmJHK0d0ZGc1eW1wdFJLck9xRGt5dVMrSzN1N1AvSmpILzdCUng2LzU2T0VZQUZKVWhFekNJMENJYVNCM1B1VS81R1ppaTVHZkJqamc2WHJEcWliaGxXdGRMMmlQa2tCWXkrRXh1QlhQVHFZVDJ1SWlHcGFEZmUrbmkyNlg2cTk3bStYeFNJNi9jeXliMStvMi9iMjhNUWNna0tTWTNvZncyclo5Ly9aVlBKRm50dnZGNk9idzdvb2RmdkRrWkVpb3ptTmp3N3I2SU5CcWJqT1hGZE5WaEJXOHBTdUZRTjk3Nmw4YXErOGkyUlpjcytPUWNuejVBMjJaa05MaXVHRkNGbVdNdHZMYWNabUdHMGE5SThhSVg3dUN6ZisrcXJ1K1lxdFZnejE3WHJ4dWNwa0p6SHF1UmdpblVSMnBjQUgxZFY4c1RrOVYxM0J5S2MxM3BsRDN2N2syMy9YczhqZEF2bXk2eS84NVIva1ozL3ExL25pNTE1THRPdEV2Q3RFbUJSbFB2M1QvOGIzZk93ZDczencrelg0REZYcFErSlFtY0U0TnpjV05TVWRFYUpQY1dhaHAyM21oTkRnZmFEdkc5bzYwRFVSM3l0OUcraHJqMXNFdW1VLzlQbkpPVEhHVkNUQlIrcmEvZWJoY2YxWDY5YmZtTGVMSmJEaUR2ZkluMWx0cnR1U3FnKytuelhoUDl2UTh2V3F6UDZrU0R3M2lLbkVzSFp2SDBTNWcwY3ZKSXVnZFRqejJXZ0JNWkxhc1pod0Urc0N3UVZpVk1JUUJ5RWlHRHZrdmF1U3BSenJJVGN4blQ1aXdXVEpNcW1jNWhDcWlRVDlFV05FZi9QejEvL2FhdFd2VDVIdTdDelNFdlpOTnFyVmVTcXhPQTJKSW9PSzgzNXJTMGJ2bTA2bVA3ZGNMR3BCcklqWU4yNjhFYjMzZDF1c2Y5cnJMVS9meDVVSDl2aVpuL3hOZWYzVkF3TnEwOXdoVTFWR1AveWozL3JlSC9yUmIvM3owM0YxajZxaWtyd1BqWUZNa2xhaGRmMlFRcFVHVis4N05BUU1odWlnNjJycWxhTmVDbDBYNkR1UGF5TytDL1RMbnRYeDZ0VEtYV01jaWlQZ1hUaTV0Yi84YncrUG0xOERGcVQ0Z2ViTWE4MURXbE10MWdVVEZGem4vVXRXekN5ejVvbzFiQXNpYjdaL2s2R0ZZb2hGME5PQ1dNZkN5ZG9vK3hRckhESVZpNHhSbFZOV0dldVZicGFuRnM0UEJXR3RPUVV6OWZTNEdnREN0RFZUVWFvaXMwOU94dVhxeHEzNUN4cjFiS3VWTkNmR21Ic25XKzh5M2wxeFBoQkJTbXRTL21MQUdHTVdiSllmUDVvZG5hemZoNzd2NDhjLy9TdTZxbGQzQytTZjVycHd6emFmL09YbnVYbmp4SVFRMTBqNUJKaDgrL2U4N2JFLzkrYy85cS9kZStuQzJ5d0dKVWlNZnRnWTZSRGwzT05kUUlJU1hHS2Npb0lHSWZpU3Jxdm8yc2hxT2FkcEFuMGZjRjBnZElGKzdsak5XdnFtVDFIUHAva2dVVFdxTEpidHoxKzlOdi8vK0JDUHVaUE4wUUNka0lBeCtjb0JOYWN1NjczM3I2aks4NWt4NXpNamx5VTk0QWMvTE81a3BRK1RSdUp2M1hHUFh6T0JkZERwQzBLV1c0b3l4NXIwNDNSU3BOWXE1ZkFNcG5kMnVNc0hvN3N3dEYzaFR1UzBHQkdpaitXb3pCNGZqL01iTjI3TzN6Z3pqd2lRdDY0TDU2YmJ1NldQNytxY3orY2FwRElXUWpLd0dJM0hWTnNidi9INjRmVTM3andzTkN6cldpOXNUbGgxN202Qi9HNnViL3JRVzdoMjlZalZzcFcrODJ1RlhBVk1MdDI3dmZmdi9xVS8rTWVlZWZyQjcxRTF1ZE1vUVQwYVF3cXRRV2hkb0c0YVF0Y1BXWUxKaWozNFFOZlY5RjFMMzNhc1ZuUHF1cUgzcVRoY0czRzFwejV1NlZkZHdoaUd4RnRWUmFOSzEvcVhiOXhhL09mSHMvYTU0ZlJZRGNYUld6R2h5c3VZSE5JVEd2Mm1ZK0hPeXdDNUMrRTRoUGh5SmpLMnhseTJ4aFNENWxEV2p1M3IzMjVNT2gzVDFzcWs0aGlxS1lZQXhtQnpTMTVrMk15ZW5oN1dDcGxOMVdiT3ZHTGtqbWxqNE5ST1grUFpBRjlSMS9yeHhxUjhaREl0cjk2NE1YL2pESmhvQVZObCtjNnVLVDdzMm41VWE2UXdCaE9GVGlONWxoZlpxUHJpOWZid2k4SDU5WWthOHN6cW91bE9aeUVSNGRMRlM3enZmZS9qd1ljZTVOVlhYLzNLOCtqZDBralh4My94djZZc3JiU0poSGlXdmo3K2wvL1lCOS83K0JQM2Y1ZGl5OVlQaVdOQnNaSWhHRUlYOEswajlxa2RhcG9sYlYxVHR6VnRXOVAzRFhWN1JOMGUwelp6SkVac1VFeFFvb3ZVeTU2K2RYZFNjaGpzZkZJQ2JuOHliLzYvTi9kWG56clRUbldBTjJMaUpLL2lkalhWN1dxczh1WmlXTk0wMXE4MXJjTzBQdHc0ckx1L1huZitiMmprOWpwaGFyMUtQbVhhUmlHRW1EeTVCSXkxUTR1MURyUkoydmJlQjFRa0hWK2FFUFI0Mmh3TkEzNjg0NE9xTVJXZXNaQmJZZTMySzhaZ0N5dDVsUXZLdzVjdWJQelJCeC9ZZld6NEhJcDFvY3g5L3daRmNVc0Z0WW9HVFNwS2o5TDFmVW5ySHQrb3B1UGhNOHdVakE5eHZYTTRsUVdyNnZxRnRmYnVrUDdiWFgvcFAvN2ZzYm41SGZUT0l5SW14cGlSMGhERzczNy9JK2UvN2FOdi93TjdPenYzdEozVDBoanBtaVZkVTJNeml4aEQ3RHpTT1hKVm5JRjZWaE05Nk1nVHhkQTdUOTlGK3M0VGd0SjBrZWdVRFlwMmdWaDdZaitjR25IZGVrU0lTdDMybno4NGF2NUJqRm9QYlZVSEJDTVNqUkc5NThLVXdoWjg4WTBqU1MzN3FWdzFHMjZxOHN5cnlET1Q1Wmt0ZklqdGNkUDlYT1A4N2MxUitTOFdlZlk0Z3RVWWlXS1RNMk5NWnJoaWRHaVBCdHFKTVVPeEdLeTFLR2xnMXlIUnludEZqV0pqTWdTT1VURXhDYmRDVEhoNUdtSGt0TzBLTWJsR1JpUGtvd3pYT2NIeDNxZWZ1UGl2ZWgvK0gyOWNtMTBiQm5YYkJYZllFbCt6eGp5R1UzRkJHU2VjUlYzbkpJdm13UXZUdlhPSFJ3ZXo0ZnNPcW1xTWlLN2hVV05NUER3NjFGLzcxSzlGRVpFOHp6VUZoZDR0a045eWJXMU51SGpQdHJ6ODRzMDFFYkVRWWJTek85MzRVMy8yKy83STAwOC8vaUZSSk05NlF0c2dzU2V2Y3B4elNBakVHREI1Um1FTWJqV25IQlZwTXRZQUVsaDFLdzVuRFVZTjFsZzBKbzIyYnp6OTBoRTdQNWhjNmVucEVZTVNmR2hXeS83bkRvL3JWNFlodkZ2UEd0Tkp6c1k0NTgvODhQdjU3My95TTRRUTE2RWU2OElZRFRkSDljQ2x6WHNldjdMOXJxck03Z1cyakxEbnZNYW05YzE4MWMyTzV1MG5mYThsS2c5Rk5VYkVwTmtoYzZrNFZBZytZSzFOQ1ZockYvdk1VaFlaK1pBa0dvY1R4S1crRXg4VUNYb0hKRFFRTldLeWhJT0VZVE5tVStnOFVWTnJGdk5rUGxmM1hUN0s3SGM5OXREZWN6ZHZMZjU3NzZNVFJCclg5YlhHcTlQTVJ0TmhWOUd4WlRJS0VmSFJRUXozWllITHdJM2gxTFRwc05QQjEweERETkdMU0tqck9oMThxbnIzQlBsdHJuL3dNNy9KYXRVUlkzTDFFNUZLVmF1UGZkLzdudnpJUjkvMS9WVnVxK2hyTkhURTRNaUtnaEFEZVZIZ1drOGdJRmw2T3FybWpLZFZBZ1ByanFaYnNscTJkUDJRT3U0TUVqSjg1Mm1YbnI1eEJCZVFxTVFZMXFDZ1JoK2thOTJ6MTI4dGZsNlZGWGZ5QUlPQ0xwYTlmc3ZiSCtMbmYrMWxYcjErbkc2eFJMR29CRVlLNDB1NzQ0dmY4dlo3UG54eGQvd2RtK1BpZlNIcUpFUWhzeG01TlpTNXdXYTI3YndjUjNLNWNXdXUvL0JUTDFHM1BVV1pFelhEUkkreGFVQUlRN3VVZUZvV20yWElNS2pJc0pXS1VVLzl1a0pVYkVqa3lYNXdTbEVEV1V3bTN5azdNYlZ6R1lrd0dRZHhWbFpZRU5YbHJNMDNSOFcvK01TajV6Ly8rUy9kK2dLaStPRHo0Nzc5NGtoTW13dlQxY0FTc0FJQm9WKzE1NnV0L0xFc3k1NzMzdWNrNlc1elp0anZnVjVWZTFVOUM3cjhGdE81YitnQytiLzlKei9Hdi9kdi9oZjg3Ui8vdUJocjFrL2ZFclRjM2R2YytpTS85Tkh2bTFUNWhlQlhHclNUcG1rSTNrTlFUSmFoTWFNZkZLV0N3YnNldFJXcWhyYWQwOVFMVnN1RzBFWXlWVlpOb0dzajFndStkdlNySG53WWJxWTRKQzhaWW5BU295NW1pKzRuVHhiZG0wOFBJUnBqa2ptUEtqLy9xWmZsZUhGRzJaaUtZL0tXKzdjZitjNzNYZmt6dTF2bFI0ekladGNIcXJKaU1wNW9rZWRVWlNtVHlZaThLRWVDR1ZscmVQeWhocTJOaWwvNDVJdnNINit3R0tKYTdKQnl1MzdJcnRId0pEVmNreHJsbE1PbE1ZR1JhM1F1UnU2NDFFZUlYaE40cU9tbVZoTHU0MDhIYU9oYno4bmhTbHpYcXpCNitNSDd0bi9rOVJ1ei8yUTJhMnZRYk40MzgzUFp4bjVFcDE2ajlpR0lKRGRJZFcxbko1dWo5NC95NmxjYnJidjdkNmIzUGJ3M3ZlZmN1RHhYWkJ2blBuL2svODZuWDM3MnhTSEdtcUZndnFJajR6ZjhDZktPZHozQ3MxKzRpdXZkK3ZRb1ZiWDRGLzdnQjU1NTRvbjd2a1ZqbTRYWTBmV2VvQmF2UFpta0o2aVBNdWdlRW1uUG1rVDM5cDJoNjFjMGJVZTlpdmd1cHExTmlCZ0hvWGQweTU1MjBkTjFqcjV6eEFIVjlqNXE3M3hjMWYzUFhMdTUrQ25lbkNZYlJtV21XOU9TYjMvUC9menNwOTVnMWZSRHBqT1pRS1V3ZXZLaDgxZSsrNXZ1LzllM3A5bkhpRmdmVkxlMmRtUnZlNU1Zdk9SbHhkYjJPZXdBQUhydjhONWpqT1dwUnkvUzlRMmYvT3pyM0Rpb3NibEJ4WUlFTWdsRVk0aFdoOFNyMUZhZEtzMU5vcG1JNkp1eVNkWjc1S2hEMGNTQmRuSW5zK2ZVWlVHRzNmUHNZRWxidDFoanBGNTFiR1QydlU4OWV2NGp2L29ici8rOElMbWEwRlViNW8ydFl2eFFIbnFtUnZDdG9Xc2lhandiMGozNUw3Mzd2ais2dGNIZUpNc3VaRUgzUkczMThrMWIzRHNlUDl3OTlKYS84dXpMejc5KzV1UTRTMjNSdXdWQ1VzUmRlZWlpZk80M1g1SGhHQ2hVdFhqaTZTdVhmdmlQZmRjZnJzYlpmWXY2Q0NOQ0NBV1ppUmlqcUhlNG9FU1RweE1GZy9PQnZKd2dtak9yRi9RdTBIWVI1MFo0SjdodWpqaEZYYVNaTzVhTGZxQ3ZLOEhIbElFZUlyMFBFa0k4UGp5dWY3cnAvT0Z3Y3B4U3dIc1h0Q3dNcTdablZCcnhQcTRqQ3d1RmFtZGp0UFBkSDNqd2g3Y201dHRqd25MWTN0eVM3ZTFkK243SlpMck45dlllemptOER3bGN5Q3pXd1A3QklTZnpBNjVjdEZ6NnR2djU5V2NQK2R4THg2ZGV3Q0poR01xellUbTF0aEZLWUdCMnh2UUJJUGc0R0Q2a085OW93a1FVd1VkRjFxZk1JQ296a3VJYzVyVmplYklhcUdEcDVHcFgzZWE1cmRIM1Azamx3ckVKMnhmZWVuSHluaWQyd3BNajhXaFFLVE9ENjVWYlIwNDJOakoyZC9MejVhYjlGNklSV3pkZWNpTmN2eDNqOGNLSlNQenV5OVhHalp0Yk8zLzFhSGE4RGt0YUYwamdERTMrRzdwQVhudDFuMDk5NG5rU25VUXlWQXVnK01FZitzamI3ci8vM0R1OWEwelFpR3FHaGo3ZHExR0lYVS9uUE5FR1RKWVJRc1QxQWVkYSt0Q3hYQjJ5cW12YTFoTkRUdlJDMTBXQ2k3amUwNng2NmxXZmpHelRhZ2tYQWlHcWFsU1dkZi9UaDhmTmJ3eUYwYXhKZDlhSStwQXl6bi8xOHplWUxWMWljNXh4VlBrREgzM2tnN3VieGUvck8xZUZvRXduSTdZMng2enFHWWFNSXF0b21ub0E5dktCdEFoSHh5ZTQvcGlkcVJCRGhpc003M3ZyZWJZM1N6NzU3RDdMcHNkSXduWEVKbDhxaTBsMkpackF3UkFpV1RSRTBZUkFTdHBPbVhqbW9UdzhDTlk3NmJXYzBBd0R2Z1RsWkgrSlg1dktEZW0rM2dlYVZYZi8zc2JrajhkbGRYN1h4aWxkSjNXSVNjVm9oU29YN2ptWE1ScGw1S1dZR0ZRSVVPV1pybm9qMTI4M0psRm5OQnZESDNybThvUFhQMTZ2ZnR5NS9wUjE4R1VueVRjdVVQandvL2Z5c3ovMTZ5d1h0ZEdVYzFjQms4ZWZ2Ty9Dai83WXgzN29nZnQzM3QyME14RVQwZEFTSlhub2hNNURGRlJ5ZkJTeWJJUGVCYnF1d1llVTVWMnZaaXdXQzlyRzBmYzliZC9pWFVnRnNrcFU5cjUxWnpDUFNBeFJmUWpTTk82RjJ3ZXIvM3krNkY4OUF3ZzZFYlFzckhvZkVRTnRINlZ1dlNFSnVDcGc4c3lqZS9kKzVEMFAvR2tyOHJhdWMyUlp4dDdPTGtWUkVxSmhiMi92MUQ2dUtFcUtvc0NJc0ZxdGFKb1pvekppVENyNGswV1BZTGwwYWN3OXoyemhmT1RXdFFZeG1scW9BV3dUWXpBMlVVbk1NSStrOWU4ZEI1WEJ6VFJSYjlibTJsRlBqYlROb0ZjeFJtaVhIYmV1bnRDMURwRmtLNVRsMmFEcDkxbmZ0cnYxOGF5Y3p4Y2NyM3FxWEdRNktTaHlnd0t0QzZ6NmxFV1hlUlVqSWpFaVY5OXdIQzlCakNYUE16U0dxc3JLeStPdDdTOWVQN2gxUys3dzJkYnQxamMyVVBqeWk5Y1pqVXRKQmdKcVJTUUhpbS81MW1jZXZPL0t1Vzl5c1ROWUpYaEgxem1JNmJnM1JVWTJIcVZlTzZZVElmcjEwOVhUdHoxdDNlTjdUM0RRdFRIUlNYcWxXM25tUncxZDNTZkc2enJNSTJFSUVvTDZwbkUvdDMvWWZPbnM3Q0ZDTUViMEk5OThEb0R2ZXYrVmRkc3ZtbWFQVW9UeWJZOWRldWYyeHZnZElhYVdhRHFac0RIZEpxcGxPdDFoYTN1WGFqeE9rZEZSQVlzUGtkbmlKQ0hta3VOQ1pMSHlpS1FZQTkyMXZQWDllL3pCSDM2Y0QzemJBeEF5dWpiZ3VoN24zQ0FqRGppWGxJOXJEVXdJZXBwVkVyM2lRM3JGTUFRQnhUUzNyU01iakFGODVQaWdvVzA5eGhyeUlxZW9Db3B4U1RtdEtNY2xXUUd6MlBMcGc1WDh3K3NuY3JQdXFkYjBGb0ZSYm5COVQxZjNhQlB3SzhmSkxIRDdKT0I4VEZFV1lRaGtkUDBqbDZ2cGp6eDQrY3E1NFJRdXpnQ0ozOWd6eUljKytsWSsvb3RmUUljQjF4akswYmdzMy9HdXg3NTVlNk82cDFrZUVLUWpSb01SUzJhRXFHYlkzYWNkZnU5YWZOZWdlTHdYMmlhd1dpNW82bU44NXdoZElMYUJVSHVDVTVxVGptYmVFVnhDM0Jra3M4TmFWSjJQbno0NGFuNVNWUmRuQnZNb0l2clFsUjJ1MzRiditaWXJmUElMdDZYdTdoaldLVlFYZDZkYlR6NTA0VHVxcXR6dStwbG1XU1k3MjNzSm40aVJ5WFNDaU1YYW5LS1UweFh0Ykw2ZzcycXlTdkJCbWMxYmV1ZlpuSlIwaGJKN3BXQ1VqeWoyZHZtTzc3K0hjeGUyK01XZmVaN1ZLbkVqUmU0WTBsa2Iwc2xpQkdQalFFMHhTRWp6UmxZWXhLYVRSTlAvSVE3UmNSS1VkdWx4VFNBdmsrdmllRnd4bWhiWTNLWUJmbGdaM3pxb2NTZWVLenRUbmppL2tUVDJJbFNWUmRVeXJ4MnJPckN4bWVPRGN2c2swSFJLMUlqemppekw4U0ZnckJocHUyKzlNdDcrL3RmazlmOUtWYnZoUFYxSDcrazNiSUhjdkg0a0lzYUlwTWl2R0xWNDVMRjd6Ny8xblE5OElHaHJsS0F4R01tTVJXeEFmVS93aWc4Qkh4cTZmdWlSUTRQM2poZ3pRdGNsdDVLdXdmZVJ2bGRpSHhHdmRJdWVadDZpTHFaK2U4MW9IVm9ORjhMaDhhejU4YU9UNXNWaE1EOWQ2NlpaTlZIZnMweTRkVlFUb3hxRlRJUVNwWGpuRXhlZnVYeHg4NzNlcXpnZlpITzZRVkdNZ0lDeGxxTElFV1BJck1YWS9MVFY3dnQrT0QyVXppZHFmV1l0SVNyVmVjdDBjd3JtSHFLejlNME43bjlneEljKzhpQ2YvOHh0YnQ2Y28wUHkxZG13OVhVa2JWUWx5eE9DYm1KQzJLTUdzc0tBajVCYk5FYUNUMUVScmd0VW80ek5PRWFqTWg0WFZPTWNreHMwcHFFZkpteHRqYmkzalh6SFcvYTR2RmNsV1RDUW1lU29QNjF5dkkyWWtXRlZSMjRkaDZFZHRza3lhWkFSRkVXR1JKZjV0dDBSa2JHcU5yelpNdWdiczBDKzkvZS9oNy83ZHo2Rk1VWlUxWXBJSVVMMnZtOTY3TW56RjdZZTYzd3ZZbTBDNzd4SEJoRlVqQVhPTllTK1Fic3V0VWEreHNhTXZsM1F6R2UweTU2dURyZzJGWWVxNHJwQXMranBHemM4UGRkZXVVb0VEUnJqc25FZmYvM2E3QmVId2xqUEhXRlU1ZkhjM3BpWFhqMEdJSC95L01BWUhQaGlTamtkRjVOM1BYSHhPekxEK2RseVFmQ0I4WGhLbmxtY1M3cnR6RnJRU0F5QnJMQ0laUFI5UzR3dDQxR0ZFRm5WQ3hESWpNVVp3MmpUb3RFU1RVYmZuZEN1VHFocnovYnVpR2ZlZFEvNXN3V3Z2M3BJcytpUnMvaklNSHhvSEF5NWMwUE1CSEVCR3cxaUI4MzZvSlJrb05oWWdiSzBXRnNsVldKdXlITTdpSzdTcVZOV09lZk9iL0RPM1NtUG41dlF1MGd4Yk1aNlRXbUw0MUdHbG1rdGR1TTRVSGZKWmQrYXRGS3JteDRqaGp6UHFGMi8vOHJKN2VlTW1ES2lKV2d6dkxmaEc3YkZpbEdaVENxcDY4NEFtYXJtdTN2VHplLzgyTHUvMCtiWlZIMmRMTmREUDVnU3BNMmZhRWRsRklxTVJUY251QVhXTjdTOVNZS251c00zRWQ4T0trRWZDVjJnV1hUMGRmOG1WUjR4RWxUVkI2Vno0WTJEdy9wLzhUNmVyRm02dzFNczVybGxQQzVPdi9ZdnZIeEU1NEtvWWtVb1ZNa2V1WC9yeXVVTGszZUgyRnRqUkt1eVlqUWFwZTFQOElneEtJTjBselJrWjlZeWF4bzBPdks4WUxucThjNFBERjRobGpBYUcwTG84TjFWbW1WTHQwcXQ0bW9WOEFFdTNiOUpVVm11djM1Q3ZXalRmREg4RXltVDg0a2tVcVBCcEF4Nmt3aVFKbEd5eUFieGxFUkROdmdLQjYrbjhseHJEY1pBTGlrd0tQakk1ZTBKajNpbGFUMGFJT1lwNlRjVlZhSUxCeCs1ZGV5NU5kUFRFODZIdEtiT3MwU2xhYnVlVzhjSGUxVjAvK3JqTytjZlBYRGRmM2xyZHJUaWpKZndOMXlCL090Ly9udjVpYi96YS9TOVMwdEVrVUpWemJkOTlKbTNQUGJVZysvSkpOaXViK202WmRxdXJKMHpoblJaYTNKQ0FIVWVYeTl4YlUvZEtDY0xaZGxDNkJYZlJWeXZtSmhBd3JiMnFUMklaNldyeVUwbnFyWW5zK1p2M3J5MStQU1hnNEpaWm5VK2IvWFN4ZW5wMTk5MlFZeEpTa2RWY212TjZIdSsrWkh2R1kvS0I0TVBhck5jdHJkTGltSDkzSFkxay9IMHRHMUN3US9MaE1WaW1WcVh2cWZ2QjBvSkVMRklxZGpNRUwwbk9FZmZhWXJIRFdIZ2ppV3k1ZVpXUlpidGN2UGFuUG1zSnZnNmtTN1h4ZzREMWQwck9DdmtrbENTYk1oaFZ5dUlDbG1SZ0tnTUNEWWxlNmtxeG9BYWtHSDVxaEhPaVZCcE9oV2NTd0J0VmlZR2NlK1VvaEJjTkZ3OWpLeTN4VEdtd3MwSEl6d2ZJblhmVVhlTHNaSHcrRVpXanV4bytqTzNaa2UzUkNRYjNCL0ROK29KSWlHa0xEeFZ6WUh5ZlI5NC9Na3NrKzErVld2b3ZSQkNzdmZYaURvSEFZeVV0RzJnYldZc2oyNnpXSFNzVnRBMWdhT0Ywdm83U1o4YUZOZkZvZVZLb09CYTJ4MlQ1RlZScEc3Y0w5KzR0ZmpKTTJ6ZEh2RFdtcmk3VmVuSnJPVzVGdzdPZnZtQ25rWUQyR2NlT1hmL3BmTmIzeVRZd2hqQm9sUlZoalhaTUJzNXNyeEk3dWx0bjdBR0gwa05peURHMHJxZXRoMnNSaU5rTmljVUljbGlBZU1UYVNxNS9hUlpBaUN6MEhjUll3MjdGNmRrcGVINDlvckZVVU1jTmxUSk9XVVFsY1dVb1Zqa0JsT3NmUnFGZ0JMTjBIYXR5WXd1UlRpaytHc1piRlJUalc0TVc3RE1Dc1VrSTdOQ0NJUE9KQXF1OTl3OGpoek1RK0w0RHlkUjAvbTE2QVFETEx1R1hnTVRMRWF6RGRmN3JlSDkvY2JlWWkwVzdWcHZuZ0Uyejh6MGtjZnZmeUoyOVRqNnVSZ1R5SzFCZ2dlSnJHN2Z4SFU5NDkzTHJCYUhyRTcyT1psMTFMWFNENmVGNndLdWo0UkJhSVFZdXRxem1uY0pNTlI0dWo5TWtRZEJZdVQyZk5uLzVIelIzZUFPbGQwQk1VYlZXd2UvVlNJcWdrUlZJME0yNE9NUDdqMlVHYm5YdXc3VlNNUWdXRnp3ZU44akNENEUrdDRSTlpKbEdkWW1lVzFaamtCYlhHL3hFUXFiK0I4MkwxRFRKWUp4U0U5Zk5Hbk9FUkJyQ0gxSVduV1hWcm9DaktjbHhnckw0NGJWU2NKKzBpNjZJaThzR3ROVFBncEVLL1JBTWJSU21FSHZIZ3plcC9mUkQwaDdESkVpUkVZS282Qk1YS1FQa2ExUlFaN0pzT1RRd2EwRm1rNTVmZC9UdVVpV0RZSXRraVZxaUJIUnhDcGV0VFVTWWJJeG9janl2cS9YYmhINmpjbkYrby8reWg5R3lUazhXR0NNbkFxS1B2VGhweTVkMk50OGRGS0l3UXF1ZDZnSzFncjdMeHp6Mlo5NGpXQTk5ejdsbU43VFVUY3R5K09JanlSWHdhQ29qMGhJai9ZWVFhelN0NTV1MVdGUEk5QUd6VVFTUmJpMjkvL2I2OWRudjh3ZFRia0RRbGxrT3Aza0hNKzZVN09Fc3djSXFGR3dJcmE2Y3MvdUk1bVZUUitTc2pacVJGV0lvVnV2a3dqZUQ3UVFRMUVVWkRaUmdra3hJMmtENXhVMVFsR1VHQ25vbXc3ZnBUVzA4eEFDZUorS1JRYjB6SWVJelMxV2s3SXlzNGFOYWNXNHlwbWROTXlQYTF4L1REaTN3Y2JXaEt6SUVKdVNvWEtUL0xZMHBsWk9UcVZlZ2pkQ0hnTEZzbWNqdCtRdWtEVXBMaTZMaWxoaFBDa1N5QzVnTWpBaGdaZFJsZXNuZ1ZVL0pBRVBtRkNJdzFvNVJxeTF6T29WenJjVXh1aGtOSlZvNUdidHV0c0Ridm1OeWNYYTNCenhILzlIUDhuUXc2OExKSHZuZXg1K29ETGhua3dVY2tzSUZqOXZtZSt2K054UFhPWGxaK2VJN2JqOXlvSnpENDdZZW5TVVBHamJTT2pqRUtPV0lPMndSbzFkd0hlZTJLZFlNMWsvaFllMzN2bjQyYXZYWnovZXRPNlFNeXBCa2g1SlpjQXZ2c0sxM21DWnlhZ1liVTdHRCtkNVh2UXVERS84THJVbXdaUG5JNXpQMG4rUGErZVMxRnE1enVGZFREZ01rb2lXMWlBbUk4c0sxQS8rUEVNN0k0T1ZxWkxhcFBUenRHbEtOSk5BMUtSRno4cU12WE5UcWxIQnlkR1NvNXN6K3RhenNUT2xHaWVUdVdBaEdIQ2tCMUdhTDRSZ2hIemxtRnlkY1M3UEdJOHpSQlVmTlZrS1pTa1VvU2dzTVNRbFlWU3dWWklvTHVlQlczTzMzbzBQMnZmMDRCS1RYT3diMTNQVXpGQlZSbVVsdWExMDJiZS9jZGpNOW9mdDFacHk4bzFWSUMrK2NJdnB0QlJWUlBWVVZscysvTkRGQjNmM3BsdGlPajE1bzVaYnYzSEU2dG94cjcyOHo3WHJNMVFVd1JKYzVQcm5UcmoxOG9MZHh6WVlueXZ4YVU5TE52VFNFa0Y5cEZrNVZ2TVc1MzFLZEdJd2YxTWx3dUd0dzlYZnVMbS9mSDRvakZQRVhFUmkwM3JHby94TlgvdGYrbE1mNVMvKzFaODdLNmMxNHlvdmdJbXFFSUpUalNLcUdXSXNJWFFZVzJGTW1oMjZ0cU1vaTdRT2RaRzJUZDFFMjNoVUkwaUJ4cFR5SkFTcVBBZHRXU3RSazg1amNHWk0zd1BEYUpFOGU1SFQ1WFU2eFpUSnRHU3lVYktZTlJ3ZExLZ1hEYnZuTjVsc2pUR2tFOENJRUp3a1BrQ01GQWNONC8wVm04YVEyZFF1bWp6bHEvaG9xTnVXTXZPVVJVYVJtZlIxSUFROFNzNk5vNTdaTXRBbko1aWt0RGZEMXllUTU1YkRaazd0R3NiR3NqbmFKQ0szRnE3NTVUNzRtamRIdUgzajRDQlpidmk3Zi9mVHZQTFM0WnFEbGdIWjFsWTEyVHUvL1hBV3kvTGFKMjV5N2RQN2hKTVYrd2N6dnZUeUNXSWNHNVBVTm1sVThwSEZOWjVibnpsaWVubENmcytZSUVMZngvUmhtYVF6bisydk9OeGZvRWFvVE9JOHVSZ1ZJU3pxL3FldjNaei95cHN3aitSZXk2aktXZFU5aDhmTm03Lyt6SEIrWjhMQlNiMCtSY3psaTl0VlZXU2pSRmt4eE5CanJCQmpRRVBBK3lhNUcvcEFDR0hRbkVTOGM0bDZiaktDS3BuTmlBUVU4QUdhcGtaSDRCM2tWUnArb3c0S1FTdlkzQkRiZ084RHJnOTBuVS82K2FqRXRkUG44QlRLTTh1Rmk1dHNiRlVjN1MrWjNWaFFMenUyemsweE94T01HSHByS0gxa3RMK2l2TFdpeUEyMVZmWVBPeFo5b0U5ZVFXaU1IQzlXYkk4SzN2dllaY2JqQ1NyNU1KajNyRHJINjdjYm1zYWpNaXhEWXRwYUJUU1oxYUVzMmlXcWtYRXhJcytyV0h2M3lSdkxreS94RmJMVy8vK3FRUDd2LzY4L1JWWUt2L0h4Ri9pZi80ZGZZYmxzVC8rZktyejgwb0c0UHRqQkRDNEhpdmQveTBNWGQvT05oMi84L0FIWGZ1TzJxdStrYTFmc244d1FFeGlWYWQwVVlpQjB5aWhQRVdWZDV6bTVXbFBPZXZKekkrSkdqakZDMzBXV2k1NlRreHJuUENiTEJzNFZHalZLNS9XNTY3ZVcvMVBUK3NPQmpOZ0NUaUdtUi9sWHZqNzFwUnVudnJyckF0bmVxTWJUeWNiWW1PRnpsYlZsaUlBRW5Lc3BpOGtBVHFhV28xazFHSnNrSk1aWWpDM1N6K01LSHhUVkRHTVVWMmNzWnNwbWxxeDVkTmordUVqeTJ3V2NWenFYT0U2K2Qwa2tOYmpHbThGRk1RNnQyTWFrWkRvdW1YVW5MQTQ3VHBiSGRNdVc3Zk9iWENveThwT2E0NXNMNW0xUDB6dGE1NGw0b3FadFZtWU00NnFrZFlHVHBtSDBlczdlNXBpTjZZUXNuNUJweGh1M1R6aFo5cUJwQ1JFR1FVcmZCV3htMEJnNDZaWXMrNVlNUTVXUFFPenh3aTEvY2RFMys5enhGWXUvcHd2a0wvemxIK2JXOVdQKzEvL3BWN2g5NnlRUitIN2Z1L21Gbi8yczdPL1B1SDNqR09mQ09zdGNBSUtQRWtOY3h4ZFV3eXE5dW4vNzNpdTgwbDA1ZXYyQWpiSEk4V0hMOVZ2SCtPalpIQnY2R0dqN21CcUlHR2w4WkRRdWNDb0U5Y2pjMFMwOHhia1IyYm1TZWVNNE9XNW91M1hZcGhKZE1qZ0xxamNQVDVxL3RuKzRlcEU3RGlVT2lKazE2a1BreTJ3MzcyemVtcDY2ZFhLV1NEY3FURG1xaWhFYTBPakYyQ0taS3NUQkNtc0kzQW5SZ0VhS0xHZlJOZUFWVlRPazRGcGthTHZURFc1byswQlZqZW5tRGMxMG9Nd01nNGNPcXpSalU3NmdjNEd1Ni9GdG4zaFZKcTFVeFZxTVVXeEk2OXNRRldNTjA0bGgwd2xOS0tnUEhNM3hQbDlhZGpSTFI5TUZNaHVvcWhURllJMmtiZUtnOWZNK2t1ZUdaZSs0ZHJLazk1RkYwNE9jVU5pYy9aT2Uza1ZDU0xKZ01VTHdjY0JBTEszdnVkMmNvQm9aMlpJaUc2a25QcnZmemo4OUZNZHZDZDc1UFZrZ0c1c2oycVluTDA3Wit2SnpQLzFwRVdQUXFLS3E1dFRiN0xmYTRHUUQ3MlpqZDJkbis0bk5SejRRYi9XN2xZMHM2b2JyQjBkNEF0WkVnaVRtYVc2VXBHbEtqb0ZLOG9YS01rR2pJYmhJZlgxRnR1aHBDNWlkMUFrdEhwNjZQa2JFR3JkcS9kOTU2ZXJKejRhb3F6T1lSekNEcDlYdVZzWFJyUDJLMzNQeFpsc2FBU2dLbStkWlZrUnYxODVyZzEyb0Foa3g5TVRZRVJWbXN3V2p5UVpabHVGOVJJbmtSVUZlalBGK2hja3FndSt3VWVsZFJLU2o4VUt4cTdpUVRnc0dhYXlzdGVTcUJCL29tejVGVjdzQUFubWVZYlBrc2hpalJhTlNSTVZrQmlOSzdIdEthNW1VQlF1WGNXM2xxRnZGeHBSSzVIdURHUko2ODBsU2JXWUk0enlaUXl6Rk0yOGRGN1lFRnlNVzRYQzF3TWVBMFl4a2Z4WEpoMEhlaFlpZ0hQWXoydGd6RnN2V2FJT2lLQTl2dFBPL2VkS3NycDhwa1BCNytnUVpqMHYrN1gvdHYrQWozL1YybWM5cXNkWklqQ3JlUnl1aUJzR1FCbkNiYlAreG12UTdhMitvWEZVbnh0anhEMzNiaDcvamthM05qM1dybGJoMnhTdlhiekdyRjVTRmdDUU14TnEwbWpXRFUwYzBTdGNIckIzc2JEVEZzNFdvNkxKbnd4cVdQckVNbGZUa1ZFTjBMbjd5NnMzRlQvZ1E1MmUzVmlMRTgzdGpuWXdMYmg4dWY5dnZ1MjI3VTB1Z08vL054OTZIVU9ZbEVZTlZpNUlRczBRTU5BUGoxckpzT3BxbVQxdW16T0I4ZWlJWFpVbmJyc2l5bk5hNUJPeGhDZEZqWThieWFNVjR1OFI3NkQxNHJ6aXZPSi9TcnVJZGE5UkVhK0VPNG8wMWlLWThGS2NSRzlPYVZ6U1NoWUJ4a1hQakVSY2ZQY2Z0V2MxcnQ0NVlOSkhlV1NZMmtwbElVM3ZLU3JCRndiU3NtRTdHYkcvMHJOcWVvc2dvY2t1T29mT2U4UWpLTE5LSUhWeFRCdFpDZ0dXb1dZUW1GWnFwdExJamJkVC95bzM2NUpORGFFL0hWNGh0K3oxVElKTnBsV3c5QmJMTXlzLy96R2RsYlM0OUFINDVrS0hrb0pscUtvejFXdFFZeVVlallwUVYrZGpocS9jLzl0Umo3N24veXIrYytiQzNmM0xFcnovN09jWjV5YWcwOUgwY05qTnBUZGhIS0RUcE4vcldVQlRKRWYzVW9Oa0llVzV4ZllBWU9DY1pWb1FqOVVTaUJwWFgzdGhmL25mN1IvWHJ3MVBxOU1OUVJiYzNLOTNlckhqNTZ2RnYrLzBITmIvRlVhQnVuZXQ3MTA5SFk1QlNlK2Nsc3dGVm0zQnlreUlORkVkZGUwNW1DN2EydHRKSmdDR3FVaFFGWWtwVUhTRU9CdE1ZMnJxaExNWXNiaWdVbnVBaHVQUitCRGVFa2ZZZTU5SjZWNGNvRDlWa0t1ZFZoNDlqRUVwNWcrbDk0bGVOTW1nZE9lRGJEcE43emxWUW5xczRYbmFEQVhhYUcvdkJPVjVWV2RRTjNoaDJKeVB1MzltbUNUMDlBU3ZDcU1oWitKWnhHVmcyaVdvU1ZNbnpqS0E5ODM0RktJWEptT1pqUWN6SlFidjRlNDNyVDdqamEveDdzMEEydDBiTVp3MVZWZEIyYmswRnNESEdmTDJxQmNvMU0zZnYzTmI0eW9ONzIvZmR2M3Yrd3FYdFMrY3VUTTlkZVdqdjR2bUxrd3ZNRnRQbXhhTXlMaS9mTjJtekI0Z2RyMTEvalgvNGhTK3hQWjd5OVAzbjJka1lwYTFRVE1mejZZY2ZMZVBLUWdiTGxXTjg2dEUzV0ZKSkpNWkVvZGdtTVZrUG9MNXgwdnpFMVJ2ekx3MXYvdW1lZlcxM0d6elVxOS9aZmR6YTRvd3Q2S2wrTmFpS04yTFoydGptOEdnZndRNmhvU0V4YWNXaWFyQzI0WGgyeUdRNkJZM2t1UjJBTXlFdlNwcG1qc1pBNXowaUZ1Y2RJaDJsR1RPL1ZaTnRHbHlmcE1WZDcrbjZNRVRMeFFFWGthR2xYRHMwQnZDRHlEdEt3b0Y4U1BTV0xCM3o0OEhScEc1N05DcGxacml3V2RGN3o2cnJ5TEtLM3JsVEU3MHVCR2diRHIzRGhNam14bmdBZEdGYzVTeFdMZU5LcWNxSWI0VGNHSXhSWnJva3FHZUVZU3NmYTFWVzBvbi94RkczK3Z4d2VyUzhPWTNxOXhaUXVKeDFhVER1ZzhTZ1JsR0Rucm9Ham9EcWJlOThjT2RESDMzbTdSY3ZibDE1NkxFTGoxKytiK2ZKemUzeWZGV1ppZGlZeGFiUFZwOTUzWGJQN1p1bXZpUXJOOGEzaDd4MC9TV2VmZWs1eWd3T1Z3dCs1Ym1HUnk1dDhjaWxYZENNM0VDV0Naa0lNVmV5QW9yTWtwdWtOcFFVQ3Bna3RRcldKZ09FdnZlNmpTWDBldnpxSXI3R0hhWGFxZjJsS21LTXlCczM1OW82eDJZNVlkNTlaUWZ5by9rU0VUbHJUYU9rSUJxSkNxUFJTTGEyZGxrc2p0WmVJOFFvdzdvellzVFMxTWNzNTF0TU43WVRTQmgxa0dWa2lPUVlhNG5PbzlGRGhNVnlSVmxPYUR1UFFYQUJtcFduclpPdmNJd0RHVEZMc3dhcXAySW9WTkdRb3JBWk1BaFZCdTE5cFBVUkNaRnhuclo4M2dVeWE1S3UzUmhHUllFTGdYRlo0SDNBYThRRmp3bUdSZWM0V1BROFk0VHh4b1FRSFZsbXlLMmxGY2U0aW5RK1E2T3dhR3RtcnFaQTJNcExLcW1rOTdvL2svYW5sNjQ5NGMxSlZHL1NvLytlS0pDTm5USDl5dUZja0JEaWFWNEhndzdiR0puODIvL25QL1JOMy96QkovL0F3NDlkL0pacVpEWVVKMFMxUG5SRWliVFhGaXgrNllaMno1K2cwOHVFYkVmYitldnkvSXVmNGRYOVE1WSs2V09xWEdtZDQzTlhqemhldFR4eVlZZHpHeE95M0xKY0thdFdxYnhqYzZvSkM5QmtnTFpxa29OSldWb0doM0pzWmlUNnlMbmMzUHZObDNkLzlQeTR5ajU1YmYvbklhNXRRRk9BYzFUdmZZeWxMZlQ4WlBPM0xaQXN5NGgzelA4VTBMcnR1eEMwVTQzNEVIUThub3IzZ2JwZWdRUVFoMGFYMmg1TmdObmg4VEY1TWNGbWFZTVJCdkZRbm8vcCsyU2cwanRIRElHMjcxblVqckljMC9rZUhVUGZwN2tqcGQwbVRmb2FaZzgrclZabGJURVZVNUhJQUN6R2VJZDR1RlJMOUVIUCtTQ1RJa09zd1E4blQrODgxaVFqYkdNTmhVQVdrd1JYQldaMXovR3E0OUxPaUUzZytxTGozcjJTellFTGxtZWVaUnVwMjhpeXI4a1ZjbVBZbVc0VGVxTkwvQ2V1dHllZlZWVi9CdmY0aWl2MmY2NExKQnZJTmo2dVY3U254VEVDcHFOUnNmbVgvc00vK2wwZis3NTMvNnRiMitPSG5Zc0U3NGNQcUZjUmc3dmF5dnhuRDNBM1JlTG9mb0l0T0xwOWkrT1RBNklwc0RaSFF5RFAwM3JURHAzekd3YzFKNHVPUnk5dGM4L09GcjNMQmxLY3NHbzhreUVMbzI0NlZrMHlmVE1DWlpIak5kTDNFTHlTNVpqdG5LZmZlbjd5NXdwanFrOWNPL2k3THJyVERMNlVneG5JalAxdDdTK0h6U3FydWp2VklnRjZjTHhvZXVkcUFZSnptTUpTVlNQYXJxUHYvT0JFbWlncklTU1laYkU4WmpyWlpHOXZMK1dZaUlCRThqd25VaEJKdzN2aVh3bDE2K2xkVDE0SWJkOUJJYWVSME92SlE5ZXk0V0U2ajhNeVFSbU1HZlJOZ2tNQUZTS05FWTQwUkVMdzB6elBmWWprUlNFV2FOcyt5WUlsVWVVblZZbTFCalhRQjlnY1oxUkZSbW1VNDJWTm5zT1Y3UkdiMHhIajBuTjBzdVRXdktkWGh4VmhtbytKemxEa2haNGZiYzVmMmo5b2VYTmN4RmMwanZ2bjB0VmtkMnRLMC9WWUs3Z3VTSXkvcFRnMnFsR3grWC82RDM3NFk5Ly9BKy8vYytPeGViRHJPeEJEYmpNeFJpV1lLTjNyclN6K3dTRmFGemc3b1EvS3JSdFh1WGJ6UmVydUJOYzd0amVtR0dOVFVDYkpJUndpUlpab0lmdUxtbG5kc1QwcDJCeG5ZSk5HSWM4aXpubWFMdUE4NUZuNjZOcytJaG1VT1pTRldYdEhhWjdKNXQ2NGZHcGFsdlcxUmZOU1RDdXA5VHlpVVZVNzczRHhLODhpMTIrZnJBdmwxRVV4aERENndOc2ZlUC8yeHZqeHRsc2hKdGxDbDJXT2Q0NjJhNUpvS1lZVXhnT0lSSnJlTVo1c0ljWU9QS3FVREJWVjZIcFAzWHFhTmhLQ0pVWmhVWGRJaEF5REl3bWdlamRzcmx6QWVZOTNmdENPQkVJUVFwQkJOWmdXR3NwcEVJOGFBOVlRUVErV1h2L2V2STQvYTBMY3NZUzlDR1I1SnJhd0NlMlhaSlU2SFZWTXFwTEZxdWVrZGR5N04rWDh4cGdnVUZpaEdBeXdGM1hQN1huTHJHNDRxVnNDU21FS2RrWWJoQUJaekNTejJmR1M3dU9ydmowK1N4TDk1NzVBL3VRUGZpdEZudkhDYTdlWVRrWjRIeVdjS1E0UnhzREdkR08wK2UvKyt6LzArLzdBRDM3Z3orV0Z2eHhEd0lnUnBSZm5WalNIQzlvalIvL3BCcWt6bkJRMFRjdU5OMTdralJzdjRkd1M3enhOMjFNWU9MKzN3NFZ6NTRqUjQ0S2pkNGwyVVZXR29EQ3JIWTFyMlpoazdHNVdqSExCOVpGNUhZZ0QrSjFuUXBFTHZTYTZTVzdYOUdvd1JrUlFyUXFaYmhiRlc2ZkZwSDFqc1hvK2F2UjNpa1Mxai80ZkowZHZqZWVVenNmc0hZL2YrL0RGdmVtN0ZLeXFrU3haMnBEWkhPK1RIZEdhU0tpYURLZTczckZhOWt6R0d3a0Y5eEhuSXlFRU5CcTZ2bWZWRHR1azRRU2FMenVJRmhNRUx3RVhVelExSWVLZEovUkRrUVFoR2NVTXFUeURTRjFTVVdDTmhLajZXdHZIbnpoWitmL21jT0YvOXFnTm4yKzlQbDlZT3pYb2hkNjdBaEx1WkUzU2Vod3VXckNHOHhzVHptOVY1TVpRWnVhVUVtK05ZSTBaSXU4Q3k2YkdtSUJFeTlodVVPUWxNdXlvb21wMDBmL3FzVnZkUENNeDhQOWNGOGpPNW9qdi90YTM4c2JORTY3Zk9pR0VLRDdFOVFxM0pDVTliVlNqWXZQZis3LzgwUGYrL2gvNHBqOXI3UEplRjVhcUJsRU5kRzZKY3cxdTVabi9lb3M5RVpwV1djMFh2UHpTNTNqOTVpdjB2aDBJZFRva0owSG5PalkzeHV4dTc3SmMxVGp2d2FRTlZnaXBkV3FpWjM5ZVUrYVdyWEZKRENRNzBqaFF3QWNIRDFDcVVVNVY1WWx5TWVBbEdsU0tvbUpqT2hsdGwva3pwZGpaOVdYenBhRHhiRHJVNzFnZzFnaURlK2Zhd1QzYm1wUVhIcngzN3dQak1xdWNEeUpFdkd0Umhhb2FFZFhTOXQzd0JJY1lrOXZJWXJVaXhJeWlyT2g3Uis4VjF3ZENUSXpYcmt1MnFLRERUZXFZcjFxQ0F4dk44UDRFbXFhamJ6cEM3NG1CMDRFOHFRbkJXQjE4czBDRXR1djFwL1pQK3YvMGNPRi91dTdpSzFGWkFHMGQ5Y1p4SHovVjl2RzZpZUhlcXJCNzA3SktlemhSdXQ2eGJIc21wV1YzT21MWmRDbUdPa3VPSjJWdXlZZGNrcDNKaUNyTGtuS3lLeW56Q1Q0RTZDSTlRVWRaVVJuRGwyNzA4eStlb1pkOHhUbmtuM21CZk9TOVQ3Q3pPV2F4YW5ucDZyNWN2M1VpeTdvejNnYzdlQldWSWpJR05uYjNObmYvNGwvKzRYL3h1NzczM1Q5V1ZseU9ZYWtpUVdMczhXNUZESTVpUElKWlNmZEZqeEdMODU2cnIzNk9GMTU1RGhmU2s3THBCdCtsUEgzN1JabGhzNXpNWmx6YzJVTjEwRTlJMmdLaFNRUVZnZjJUaG1YYlUxcURFWk0wSWNQYjZuMlNlNVlqUXpXcU1NYmduTWZhakdRVVhkRjVyMjFianpMTWd5SGt6OTV1VnEra1J1UXJQOEhPWGxXUkVVSVVTY3JVSE1pbnBibHljVy96UXp0YjFWUjltOHgwakVVeGhBaDVYcEhsRmIwTE5KMUw5RzhWVkNPSEowdnliSVF4RnVmU1NaSm1sWFFDZEs2bjYzMENLR05FMWJPc0c5cmFJMzNhN0RuWDBkUjF5Z1JSYytyVWFBellvUjAxWWxCdmxuMmYvYTM5ay82L1dIVCtSVlhXSWFTbmZMU2cyaXlpUHU5Vlhwa1dkbWRVMkh0eWE3UE9CMloxajFqRDVxUmttbWVvc1J3M0xkTnhpWldFNmFRRlFhSzZqS3FjRy91ZXVzblRLcm52TVlDVFNHbUxQS3ErZnRNdnZod2svT2ZuQkhud25oMyttNy84ci9CTHYvRVNiZXZsMnY2SkhCd3ZaTEhxcktwbU9vUy9pREJSWlhObmIyUDczLzczZnVBUGZ1ZjN2UE5QajZibEpRMHJRcXpGOVN1aTd3ak9KUnYrWUdrK0g5RVR3ZVNHRzYrOXdKZWUrd0oxNTA4WnFldGNDa21zT25hMmQyamFubHNIKzVSV21JN0twSWNXUXlRbWhxb0lOa3QrV0xkUGVvNldMYUtSVVo1UmpUTHl3bElXaGlMUHlZdGtxNVBia3NsNG15elBRQUlIUnl0dUh5MWwxWHBXSGQyc0RiOTB1MTA5TjV3Zy84Z0N5VFBCQlIwMDZhbEl6bTFYdTlQU2ZuQmMyZDFSYVFqQmdBekt2WmhFVFZsV1ltMU8yem1XVFVQblV0eXpjejIzRCtjVTJZak1admd3c0g2REcrQWRTKzk2VmsxRDI2ZE1rNmlSdHUyWUhUZDBxNEFORmxGemVob2JTZG9MSkFtaThCWmZaeWZMT3Y3MWcyWDMxMnJYWHh1S1lzRWRGZVZaSGhSTjFGdkxQanliRzhuYTNqOHdxL3R5T2k1NCtPSTI5MTNZVEtJekxGVlZwSUplYjhnMFVkL3ozTkk2ejlYckhvMFpiZXp4TVpCamFWRUNLcFhKNmtYc2ZyVlROenZUWW9WLzVnWHlsLzZOUDh4ODJmREZsMjh3R1JWODZlVmI4c0xWVyt0Wkl4c3l5VXRnREV5QjZWdWV2Ty9Tdi9NWC92QWYvczd2ZnNlZnNFVzJxemlDWHhCOE0yUnFDRUZORXYvTUZmK0tKVE1GUjdldjhmRmYva1VPNXN1MHp0VGs2cEgyN2NsTHRzZ3pzZ3pxVlFOS2NtUnZPbkpycVBLTTNrWDZFQWlhUUxHMTRkbWlqUnl1T2pLclhOaWJVQlhKN015WTlDR05xaWsyeTJtN2p1QjdWblhEeWJ6QlI5WEdtM2g5N243NnhmbngvK1EwTEhtekY5TnZlL2x3R2o5NE9xZ3ZhcWVQWDlsNjMvR3NlWEJ6VWlSK0dNTUpvaEZWaXcrcFdIS2JZVzFCMDBYYUx1RU96anVPNXcxRlhtRnNNc2FMZzgrdVNDSTB1cENNcmp1WDVndzNwUE11VGxvVzh3N2ZLalprWk9RcDY3MFhRbXNJalNWMDltVGx3bis1WDljLzNrZDN3SjJNeFJibzVjN0RZYjJ3OElCMmtmcXdEYy8xUGl3dlRjc25IamkvT2Jxd05VRlVNTVd3WFBDQjQxVkRId0pWbVNkQ1k0d1VtZVh3cE9QYWdTTVE2S01ud2FJR2k1RldJcHRabFRmYS84SWl0amUvRXMzOW4wMkJDUHp3OTMrSWwxNjd5YTM5WS9uU3l6Zmw1dUZjUW9oMlhSaVM4STNwVUNEYjMvYmhaeDcrUC96RlAvS2pIL3pXWi81SVhwYWJFWWZ2WjdqMm1CQWtlVlVGaDRhVUF4eXVaOGgrZ2VzYlB2TnJIK2VOMndlMHZhZnQzT2tLTS9pUUVsbVJRV3VkVUdFVWdpcTlqNmYwa1kxeFJXYnNLWFhhZWFYdTBvWkdFQTVXanFidHFUSkRWUldNcWduR0ZIUjl6N0plc0Z3dVRuWG92Zk80aUJ3czQ0dlBIUi8vSjh2UXZjb2RrN2gvNUF5U1Z0OW1zRXROSjRnUHNYamJRK2ZlVlJYMnlaTmxMMXNiT1dWdWlXb1F5WlBRS2FSWnlYa3dKcU1vcXZSOU5CRmpJSVNlbzVNVlJWR1JEMjRvUGdUOGtGMGltRUh2a2JRZjljclJOWUhnMTJtOFN0dDVtc1lsalg2bkVJU3F6TFVsL0syYjllSi9EQnBQZ05tWjR2QWdNUnVBZjduamlidCttYURFSXM4Vzc3Njg4NEdMRzZOemVXWndRY25MYkpEb0NsR2d6R3pLS0F5cFRiUld1SDNVeGQ2VkRkRm5UZkJpQjR1SVNqSmFkUlI1VVJnam56OEtxeThNeGZFVkgxSmZVeHprdXo3NE51YXJoazkvNFZXNlpMUERqLy9reCtVM3YvaXF0SjBmeEdoNm1xY25JaU5WTFROcnB0Lzl3YmUrN1pzLzh0U0gzdmZSZDcvcnltT1hudTU5UDRxK3dmczVvWnZqK2dha1NPWnJ2a3Q5YmhEQ0FlUXEzRDQ0NUF1dlhHVnRFSnZsS1lEU0plbzU0ank1dGRTRFczcWVXWUltMm9UTjB0WWxhQ3FVeStjMkdWVUZSM1hMOFdJSnNhZHAxeXdUNGJYRGhubmplT3EreUlXdDFOYTQ2Q2h6eTNoVTB0UU9ON2lrTEZvL3Y3YXMvOW84ZEM4T0gwZy96Q0Jha05IeE8xTk9McDNiMU92N3M3UWlWbzBLZGUzdDUrN2Izdmp1ZzZQNXhyTXZITXJqajFvMk4zSjY1d2xSQ0NHa0IwTU0rQkFKSHFhakVTS0crYkxHV01FMURhOWN2Y3E1N1YwMnB1UFRHMzg5bDRpYVpCWG1VKzltSmFYZjZGck9pa25LU3hIeXpGSVVWcmQySzN3ZFYzRWVhKzZFQVBXQXk2eUpveUpqMGZScTVEUmRONFIxZ21ocXYyeG1UTDB6SGJWbG1hZXQyZUNyaFJHcWNYSnk3L3RBY0FFTlNqQm8xM3M1V0xubllsbTlNSTNGOXl4Y240ZkI1ZHVpakRDNjhLM2RtbXc4VWJyQ05MNTdFMHY2YTFvZzczM3FNbDk4WlovVklPbFUxVHQvcVNJLzgwdWZOU0tJcWxvZG5vSkRhTTBZS04vK3hKWExIM24vRTkvejF2Yy85UHZmK2VGM1BIemgwaFhUOUF0VlZuVGRNUkliZkwvQ3V6a3hXc1FwM2p0TU5VWTdHTVZOWE5Od2NQTTZMKytmRUh6a25rbEJWUmFvYXRJeXF3NVB4eUd3ZGxEYVJRYmRzd2c2NVBTbDlGZlltVlpNSnlXNUVhS2ZZYVduOHdJaHRWWEwzdkg1YXdmY3MxeHg3OTRtazZxa0xMTmhrTzlvT3MrcTEzaHI2WDcyUnJQOEI1b2MvRTdWaEFhakUvSi9aSUZZYXpFaTZsV2ppSGhVKy8yNWUvbTdIbnh3T1o0Y2JyNzA2blYrODltYlBQR29ZWHRyQXhsYUpoK1NCdDE3bjZ4N2dxV3dzTHRaMFh2QlNNNThzZUsxNjljbzh6SG5kN2ZKTWt2dkhHM1RzVm8xckJZZFhlM1JrSFFrMk1nZEk4VmtJWlJad1ZqTGFKcGpjeUhQN0RqTGJIUStuUGI1MWhvdGM2czdHNk9rNXdBbTFtcWJ6UFRDOEVUdkJNckRwci94eHJ6NStEUGo3Q2xWOGlHVG1xSklyR1FpM0R4dWVPMzJVaDgrUDlWcGtjdnpONWN2dmJCYy9uY1hKNFU1VjQwL1dqUjEzcEVjWHh5UkNaa2UrRTRhbDA4TUVuN0hFL3VyWFNEYkd4VkZuckZzZW43cDE1K1R0SzROeGhwam9xb2hHWjVaVFhGaHVTYVNZYlV4cVNZLytEMGZlTTg3My9yZ2oxeCs2c0k3SDNuWGc1UEo1aDUxWDlPSGxZU3dnbGdUWEVzTUhhb2R3UWRpM3lPeHBIY0tyV0puQzc3MHVlZjUrRzkrbWhCN2JpNGNzOWJ4MkI2TVIwVnFkQWZyRjlGMVVsTEtuN0M1cFErQjB1U0pNaklrSmluZ2UwK1dXODV0ak9ucURxTks1aU4xRi9BeEhkOWRDTHh5V05PcDh2REZiWXJjNElOUEJSaVZvMlY0OXRxeS9odWQrb016QTZvSDRrZ3NBekQ5TzE2NXpZaFJOWVdaNFFDOWZ2djRtdk84Y2ZuUzVYdW00dzJ1M3pxUTUxKzZ5ZTd1aW52T2J5YlM0aENRbWN5azAwWXFER0ltYXlMVHlqSXFwb3lyZ3NQakphOWVmWVB4ZUlxMTBOWWRxMlZEdStwd1hUTGROaFlzOXZTWmEwUXdabUFjRzhYYUZBVWhTbTZOVVpmc0tsUkV0TXB6WGJVZHU5TWhnR2RvYlFHbVJjYXE5MUdISXZGUlY4L2Vtdi9NbGMzcXU4ZFYvbkN3a3JyYlFmQmpyR2laRzU2N1BlL2VtTGMvZDJGYVhuMzFzUG5ORStlZTJ5TGVFNng1S2JmMjdWMXdHa0VDVVF0Ym1FM0pYei9vWmg5dlErL09zSGkvTmx1c3ZlMEtJK0I4cEN3eTJUK3BKVVMxM2djVE5XWXhhb0ZxaVVpRnlGZ1RHajRHSnFNeTMvNjI5NzdseVQvK0wzMzRqM3pnWFkvLzZQWkRPMDgvL0w2SGkycThoY2FBancyOVh4RGNraGhhWE5mUjk4ZkUwS0RSRTdxQUdndEdhSzQyZk9idlA4K3ZmZTRMSEN4WGlDalJ3MUdqekgya3loT3ZKOFMwb1VxOEhUdUVVc293b3dUeXpCSmpjaWd4V1hJQ0RDNjFENk1xWTF3VTVGazIyT2JFcEFFM1NUeWxxc3hXbnRZNXBxTU1LMGFiM3N2QlVtZXZIZmQvL1ZxMytIazRYWEgyZ004d21vdFZpNkg1UjV3Z081c1RUcGIxK25TMklwSXY2dGJmZTJGcjQ2Rjd6NzgveXpKN1lXOVhOcmMydUhWWTA3dEluaVYyYjR3ZVkrMnBCWkVSUWRVbGd6bE44OFM0c0d4dGxKU0ZzbXBXM0xnMW8xNTB1QzRONkVrMGxUQVZZODNRWkNidktWWFM0cU8wZzB3NWd1SFdyTzUrc2ZkaEFiUWl1TXphK01TVmk3eHcvWTRobmh2V3RMdWpYQnFYZ3QwRzg1VHNwUFh6Q3h0VnZHOTMvUDQ4TTVuTmpSU1pYWHQxZFczdmw2L2ZibjdoNVVYei83eTZhSDVoNGYxclFMdnkvVkdsV2N3RDcrcWlyd1NKQmpHNTJJVVQvdHExc1BnZm5ZYm15OUQwcjE2QmZQQnQ5N0kxTGZBeEpuZHVGK1Z3MW9oUDBWKzVxdWFxVkpLS1lqd1FEQ3RnKzhxbG5Vc2ZlZC9qVDMvL2g5LzJBOS85cmUvOFkyOS8rdEVQTDZMYnV2ZnREOGgwYTJzSW51OEpvZWIvMTk2YkJkbVdYblYrdisvNzluRDJPWGxPRG5lb3VuVnJybEtwTkV1QVNoTklqUUFaQTZLN0JZSEQzWGJ3UUhzSzIyR0hIZTBIUDNYNDFRK20ydzEwUkp0dUVBSFlaaGJkNEE0MGdXaUVKdEJjazJxNlkrYk44VXg3K0tibGgyK2Z2RmtYbFZTYUdsVkZyb2dUZVc5RzVyMlplNSsxMTdmVytnL0J6ZkcrdzdYN2RPMEJ0cGtUeENhbFBxOFFGVms4VS9QbDM3bk1ZMDljb1hZZXBSVnRhOGswR0lrc08yR244ZVFhSm9PY01qTmtXbU9VSXNzenRFbmd1TElvUUlOYmVlNzFzakpaM2lkUlRPZmxVVmxRR0lNTEFaU1FGMm0zRUVKYWlqV2Q1N0J1TVVwVVo3VjdkdC8rMXJQTDJXOEc0a0ZmUFpLU0NVbzJHTEJHU1ZTUit1c2t5T0ZzeVlOMzNhYU9GclhxQ1JnbVJza0hSY0dySDdqekI0ek9KdFlGQm9PUzI4NmRJYzhIdEozUWRBbTBtSnVpLzUzU3BFdXQxQjZqNEh6eSsyaWFqcnEydEszRnRvN2xvcU5wTGM3SDVPdlJIMDJUbkZEcTIwS01pQVN5UENXTmo2SzBWa3BwdWxuVC9Vbm53Z0hRS1lYTHRJcDNueHR6WlcvMk4yRUNTdEg2NS9uWEtBR2xsZHEvdUZHOXVzak4rVm5uTDNjK1BMdDMxRDcrNVd1emYvZll6dnozcjh6YjMycGp1Tm9mVzJ1Z2lUSGFtZTh1cjVISGdCd0dlRXBncDhIL3hoV1ovM1lkM1JIUDEwTCs5cGg0L3ZjLzlVWSs4OWdPcjdwdms3Lzg0amE3aDYyS0VjV0t3SFN6NlM2QmdZamthOE5xN1h0ZWM5KzlyMzN3d2dNUDNIWG00YzNKOENFRGQyNXVydDk5OXR4Wk0xdTBrcCt2bUp6YlNFMFlIc0tTNkJ1QzdlanFBN3AyQisrNjlCVHJONzVTYXBvcmxpLzg3aFdlZm15WHJEU01URUZ0SFd2RGlxWnBjWmxIS3poc0kwL3VON1JlZUdCclNDblFkSkhSU2o1R2FiejM2VXBsZmZKayt2aE9SUmZUc3MwbC9yYkpEUmUySmt4YXk3eXp6RTNIb1hmMHRvWHNIUG1EYVQyOVVwbkJwZWNXN3RjdC9obzNSZUk4RUExS2FweFU1T3hKODZLdS84WHpHL0xzdFQySlNPaVBJdTdKNTNhZWZ2YnEvaWNmdXVmMnZ4ZWpRbXNVUkNackZWVlpjRGd0YWR1MnA4NkdZNTBvS1VxQ0JIUUl5YW5YZTVaTngyelJzbHc2dWphZWNLTUZrWkJrUGxWZk8vUktmemYxUjRpaXM0NjhNRDJBMHhpbDlBbm1UTUtMUFhEaEFoOS83TXJmK04zT2pRb0dtV2F2ZGhJVDJyWUQxRmYyRjVjdVhxLysrYVFxN3Y3aXRkbXplNHQyT3UzY1BDQ3JON2svTVkxYTJUMW5uZmoyU1RuNkJZVWFGSmlSQVZtSTIwR09pV3ZkTFZ5UWJ5MUJ6bTBNK1dmLzQ5L2h4Ly94SC9EK1AzcWNQRlBLdWFnRlZsS2VoWUpTb0JLUndaMFh6a3grOUoxdmV2TWpyN24zUnpiSCthdlhKOE96em9VMTczd1JJZ3pYMWxCS2M3Q2NxenZlY0c4LzcrK1EwSURVeE9qcEdrYzczd1B0aUQ1eERsQUtyU04yTi9MNHY5bm04bGNPOFJLUm9LaXFnaXczVEJjTmJaSWdaRFRVRkFYTXJIQnAyakVQa1FmWFMwYVpZYm5zQ0FyS1FaNkkvcjNGc2VtbFl5UWtUU2p2azZoQ1czZGt1V0dZRDFpclNpYkRBV3VkeGUwZGtodUxGbUh1ek40c3FGL2RxZjIvaDhWZWdLdTNDRFdFREMwRnVTZ2lWNW05Nkh2d243MzNYWHo4ODArSmVJazliZGZ1SFMzbVQxM2UvdGhkdDIrK095K0s5UmlseDFLbDk4cGtQR0s4dGtiYk9vNW1DNnh0MFZyUU92WmtyMlNiVnBZNXpoWFlLbTNHWTBpWVk5Y2RPMkVsZ3h5MTJzaW9ZeUpYVWw1MHZVb0tHRjB3R0F3N1krcVlmdTEwY2xKS014aWQrK3JIOVNxbk1GcVdMbEpidjNvQTRLTEVEMzdseGtmNloxWFdKOENxRi9QeU55RWp4eFlSRWVsQVRFTlVKMUM3N3NTQzhBWFJ2TjlRZ3R5K05lS2RiMzh6Ny9tZmZvK2RnNld5M2l2cmowWFlqZ2xNQW9NN2I5dmMrb2wzZis4YjMveTZCMy9pOXEzUjI0cWNyWEpRNnM0R3VzNUtEQkdkWlF3R0pWM2Jva2FLOGRZUTcxdThXeEpjZzRnbFNzQTV3ZmtPVEtTWlJYRENZRk94dk81NDdBTTdQUFdGUFR3UlRKcUxkeTcwZllPbnFrcUtRY2tLUHpmb0xIcnEySjliUHRjNlhuR200dXlvVEQ1NG1Va0VxTEJTWUZkSmZLeEh2TWFRcGpZNjA2aE05MFFqVGFZVUJacXRRUVhqeU1HeVExcDl5UkkvRnBEbmdGbS9JR3RPM2hTTkZvTmludDRETHpyK3lTLzlQNFFZcGVjZ2VSRTZrUEt6ajEzNnF3dG50ajU5ZG1QOUI4dXkwSU5Ca1R3eEV1Y1lwYUFZRjJSWlJ0TzBoQmlwbXdicjBoSE1lNU4wY0lzaDQ1R21Lbk1tNDRycHRHVjJ0S1N0Tzd4ZmJjcVBCNU40djFJd1RIMUpsaGRVVlNWRmthT1VjcEpBbWNkdlFLMFZqMSsrL05XcHhSR0d1VUtCYUsxaWpMS3lOUXo5KzNWbFRiQ2lDNXhVUWd5cDBDa2hUVXBYaThlVkhzRXFWcnVXWUxTSkt3SkxDT0ZicXlBYjQ1SVBmK3dUMUoxWG5mV3FGMFF3M0RTd0h3S0RkMzdmUXcvK2cvZit3UHRlODhwN2Y2SlpMTFppdEdwUWpYQStzRnpVS0lrcUJvL0pEWm5SMU40ek9qT2tLQlJkV3hOOWkzTVdFWXRFaDQ4TlpBWm5CVDlMamsxV0ZJLzk0UTZQL3ZVT1hwM2NpcWNHMFlmSW9Db3BzNHpPcDkySGpRRnJQUnREVFdHRTNWcjQwbzJhZTg4STk1MGRKMlpiejJYUS9YS3d0UUhkTjUrcExkRlVnNEpCbWFFa3NuYzB4NkRvT2tjeEtOZ2NyN0hzSXRyNHBVM243dnBFejJIN203Z3lRa0MraVNQdVNreGFhU1VTajhlaTlxa3JOM1krK1BIUC9zRjl0Mis5ZHJJMnZtMjhscXJHb0N3d1djN2FZRUNXSnhDZkNHU1pvY2dMMmpaZ2JjZU52Um5XTHFrR0dVM2RKbGlPaDdaMWRNNWpnK0JpU0lESC9wbXJTRU9PUE04WWxBVlpubE1VNXFZR3NhWVI0V1NDaUJMRmJQYlZpV0dmdVQ3bDNvMGg1MGNGMDlaeDBMaVQ5c3oreEZGTlRyNTZIWDdKbENGRDArSEZLSzE4MGtBS3QrdzRqckhHSWFicDJtUXlZVGFiZldzSjBybEFhMzFhOHQzc05VcWwxRWhFcW8yMThzdy8vTEZIZnZDSDN2bm1uNzdyenR0ZU96MmFsYTN0WkgxOVNCUlJ0dTFRcVdZVFlxQXlTYThwQkVId1JOY2tnemlYanBIUk9Ubzd3d1dYbHV2Qm9xc0FHQzU5WnNiVFg5ekhhMGwrNDBSc0FCZEQ3NE1obEdXT3lUUjVQeUZCWnhUOTFLb2FRcFozN00walg5bHRPR2dEOTR4enRrWURWR2F3MGFPaVJ2dUk2b1dQTTVOMFlTWENkTkhTdVNTblh4WlpFa3pyNVVVcms3TldtaGx1T1ZzMWpLdmt5RkJSbEJLdDBzL3FDTjl3Z2x5N01lTjE5NTFoYjlySzlzRnlOUkp0UlNpdTcwOC84OERGMGFjaC91aiswYUdaempOaTBJZ1lzaXhINjNRNk1VWXpxa3hQZDdXVXVlZk1laURFRE4vN2U4eVhGaHM4Tm5oY1NDb210bStnTTVWY3E0b2lveXd5TXBQY1k1TXVWN3JlcVhIbk1NUjRrcHdrU3NHeWZlRis2OW1qbWdjMmh6MHJtZWV4S0cvNVV0R0poa3dsR1VzY0s2V24xMi9leFpYbG9SemFtMzdyNmlZQ0x3MWdKSEpOaExQd1ZaUGpSU2ZJL1hkTWVQcmFqSjJEcFdxN29PSk5aY0pCZ3FITDZQV3ZPSGZ2KzM3NCszN21MVzk2N1h0dnYvM2MyV1hkeW1LK1lES3BsQ0lkVDdvdUhabFdFUEVzTS9qZzhkN2hYTVNGZ0hRV2IxdTYyUFdDejFrdkhaTW5sR21oRVRURE8wdllNTFJYYXBRV2xvc1drMlVKUXFMU0JUR1pSblNHRGFFSHN3bFZXU2JQQ2Qxakc2UkJMZURHdEdQV1dCN1lGTTZQaTE1VkFiTCtnaGJHSkg1Q2JuQVNhSnhMVkZWanNOWlRtS1RkMnpZdFRTdjdVeXNmNmNlNXF5WXdhRlRNMERLV25IMjZiNDBlc0RaZ1hqdlJXa2xJVmNRQzNkR2kyM3R1Wi82Qjczbm8vSnZXaHVZTzE3K2hpOXlRWnpuR1pJbjNJUUVSUzViQm9EU0VrQkZqWUZZTGJlZVNoSStLREtvTWt4c202eVhlS3VwRmgyMGRSbWxNUC9sYjZYK0ZFREdGSWh0RThreFU1K1RHL21IemtXWGJOcXNFRVJIeE1TUzlwSzhSVHgzV3owdUVXOFVVMUMzWklzQ0VrcG1rNjdyWExZNFpqK3A1V1NiSEtzSUFkM3c5YU0rTG9yNW1taUxUTkowL0tmcGNwUVdvSHYrblAvcmFkN3p0RGZmOTNEMTMzdmZHemMyTndsclAvdjZSUWlLWlVVU2ZySUdkZFltU3Vmb0JsZXJoMWVCdEpBWkZQVnRpWTR1ckR5bUdveVE4RUJKZXFIT0I2QlZLaExYYkJyeis3OTdIWC8zYlo5bDc2aUJCSEhvL3V5eExINHNpTFY2cnFrZ2pTaDlRbVdIWjJuUXMwSVpCcnBrVUFZTGl5QXFmMjYwNVA3ZmNzYVlaRHpLaWtIWWVtY0g1a0pyUExEMkJRMGlKN1VQRWFvMlBRWm9PdTcyVTM3L20ydytkUUtrR0JUSHJuNGdONFNTLy9KdUtFSVZuZDJZWXJaSnVRNXI0dEVEeDJITUhuM3p3empQLzV0NDcxbi9XdWxna2tVRkRrV2RJY0FSdDhOSGdmT0xGZE5iamZhUnpuaUl2eUlzUmRXMlpqQXNHNVppdTg0bEVOVytJSG5RUGx6KzJkQ0ExNm1ZQWcwbEFaeUltTTBvRjJiRXo5MmlJOFhsOGk2YXo4SzM5K2plUG0vMTFyRy9wNDY0c0QxNzRlNUFYbUZsOUZlVEMxMTBDYm82UUdIRkJsUE55TWpuV2dMV2YvY2szL2VBUHZlV2gvMld5dHZIcWpUUG5zcklvQ0NFd215OFlEek5NdjB0SVlMWXVDUWpFaVBPVzRXaEVrZWQwcmFPT0hlUGJKM2h2Q1RHZ1l0Sm1EZDRSZk1DNUdkNWJySVZvb2FtRmJKQXp1akNoWGdUY3doMzc0eVdUR0pQSS8wYXp1YkdHTVFyclV3OWlPM2VNVFpKZUVDN1BJamtLN3hVSExyS3drVndwaGtWS3VEelBFcDhnQkh4dlBwbkcwYXpBZmVJOTZrYk5wNjlhOTg4OThRYTNtT0lZRkphSWZiRjM1MnZFNWQwNWsySEJzTXl3THB4OHNLb1lSVFdkM3oyM09YcTR5UFdkM2lmcHpSREM4UmtuU3BiRTVreEJOZHhnVUswekhKN2h6TllkVk9XRXpBd3d1a3o2V1RISkhLN0FpU0wwZTZwMGIwMEJnekVNSm9MS1FDbXR0Tkg0S0UvdUg3Vi9VdGQybitkclQzRXdYL0JTaUs5YlFhb3laL2Rnb2F3THorT0ZLOVQ0SDczdlRlOSsyK3Z2K2UrTVV2ZjZtSUI1MmloY200d3ZqY2tUNEs5WCtqc1dGb3RKTTlaWlR5alN4VmN1bzJzWEtCVlNrNjBCMzRFa0E1aG9MVHJtT052aDI0UVk3YXlnODR6NzMzRVhWOGNGbHo5M0RUcFBWZ2pScDJaeTBYVGtaVTZtK2lUdGJIcWp4SmhzaW8yaEtCSVgwT1NwMXlpc01IZkNZNGVXcVkzY3U5RzdMMm1EaTVHMmMzU3RSZXNrTlpObFJob3I2ckNXNTNiYitQNE8veHduMVJNaDV1aHYxMFB6T0dhMTVleGtRRFVvcVpzdUN1TFN0bG9WejIxUG4zMzIrdnpYMy83R2h4N004L0tNOVduSmFYUkdubWNJNmFpbHRVSHI3Tmpqdzdua3A2aVZKc3N5blBjVWVZWldobEFtcHlydExGb2dHd2haQ1VVRkprL2FZRWsxUGgyN2dvL1hscldkclRCWWZhWGpwUlJmdDRMTWw1MktJdW9FOVhVSWpONzdyb2UvOXdjZmVmQi9YaHRtRHpldFozM2p2RnBmSDZlTDdBTnQyekFjNUlRUWlSRzZ6dUZzOHFMd1BtS3RJeTlMQm1XRkQwSm5MVXdpV1dHSVBqWHNNWFRZYm9GdDV6Z2JhRnFoYVNKdEl6Z2JxVnZCOThMU2EyZEhGSk1oemR6U1RCdDhUUHBMdG5QVW5hWHRQTFcxV045L1B2akVaOVlKOUtaVThxTW9DMFVtU1RVbkNoemF5TndHZEJTMFR6Yk9xV0ZOb0wvZ2d6aVAybHR3L1VZcnYzZ2c3b055a3luWDlXQkVxY2lrL1NZYThxOFhkZWM1dDdXZTRQeUpDSGFzUjJ5OU9yejd3bDNsK3ZqTXc0cWlVSW1sUzR3SkdwN1dGNXJZTy9rNjV3aTlUSkQwbURWNnVMdU5qdFl0YVB3Y2xWbnlLbElNb1NoVmdwd28xZXRrSlI2NWdDd2I5eWVYcjg4KzNsZVBSaW4xZ2d1NWwyeUM5S09FbFovR0FGaTc3K0xXN2UvN29kZi9WK2UzMXQ3dWJLdGlWT3JzK1F1c2psZUNvbTJUendQOUltbTU3T2hzaHpHSjdOSjJsaGlocWlxYzgwUWZvQkxNVU9IYUJtdm54TmppWFlkem5xNFJsbTF5YzdLZEVLeGcrL2w3VXZ5THFMTEFqQ3FXdFdVNVhXSmJteXk5WXFUekhodEMwbnpxejgydGpUU2RJRkduVGJHa1VYRlJLTXBjTVRDS1RBbHpHOWx1a3NxN1VSRkp2U1loQ0xNYTJWL0tjenMyL09JQi9vOEZPY2w1Y0tzRjlJQ003anVRSU9raDF2RGczUmZVNFd3cG5IaENMK29tWE4zWnUzcjd1YlAzRHdhRCswSUl5dnRrS2VCOFNGVmU2MFFaV0traFNsS0ZqNUtPa0M0NkxFdGF0U0RvRnBUdnFiUXJCcUZDVlBxenRlRzRGL1JSTHUxTjI5ODhuRFpQOXhnc3E1VHk2K3NEYVZ2L3Nra1FkV0lqV1FKcldhYlgzdmZ1aDMvczFmZWYrd2VLVUlsRVFsUnNidDdHb0JyME9xeVdwbWw3aEdjYUs0WVFhVnZYei9FRElXaGE2NDRUUkdQb29rVlZjN3hiNG14TjhCM0JDODdDWWlrMGRhVHRCTytFYUFVSk1SR0JyTkEyZ2FZSnlUQityYUsyUWoxckNjRWpXcUZ6UTJPVFlJR1hKRXZqZklKRHRBMVlDN25SNUVVQ0p3NnJnclZ4VHA1SGNvVGc0TUFKKzUzNDRHS25SZVh6VnZ0ZHkxOGN4UGhQRjRTUFNGb0lMaytBMzJLT2xoSkRrOUJkM3lGZS8rdFFTbkYxOTJDRlBWK05SUFd5YWRzWTQ4NjVqZlZYR3Exdml6RktpRUdsVGJ2SHVhUWpGbGR5UXozR3lucUhWVFZ4V0tPSGdieElQdVpGM2s4S2I1a3RhWjAwdEJhMVl6ek0vYklOZi9URXMvdC9FSUlzVjJOdUVXTFhCWGs1VlpEamRiMVNxVEYvNURXM1BmU2V0OTc3MzQ2cTdONFlreGhaakRDWm5LY2NsRGlmenJEMU1va0ZaMWxPQ0lMV2hxNzFPT3VoMzVRdDZ4cHRjdkk4Uy9wS0xoQ3lHU1pyY1RiQlNxeURaU01zbDBKakpRa291MGh3RWRkRmJCZnB1b2pyQXQ1Rm1xVmxmdFN3N0RwcUYvQWRlTnV6ejBUalEvcm9uTVpiQ0Q1Vk9CZWd0Y21yYnpJY1VCU0dJc3NZNURtbFVXUXFDQUdhb1AvNktNVGZiNTNhWGdUNTFKVHdDeTN4czMxRHZyZ0ZHU29DOGpCYmJGTi94MjdpeGZObldMWXRPL3RIcStIZ1NmS1AzdGsvT0JTUjNkR2dmRVdlWjJlZDl4SkNVS3RsWGpMZ05CVDl2V3Jqa2xqVm1EVkxWbXJ5TFBFOHNreFRsam02TUVrVHk0YmpkNGxTNlRydVQxc0doWGx1ZTcvKzVZT2o1aXZjOUg3M0w3WGoxZGRMa0w5UlBmSk1qOTc3QS9mL3pJTjNuL2t4SDlDS29CU0N0WjdoMmhiVnNNSTdqOWFheGFJbHhFQlJEbzVIdXN0NjFTQUwxams2bTFDaWs4a2tLU2gyMEhSTHpLakZXbWhib2UyZ2JpUHQxT05kOHFyd2JjUzdTT3NpdG8wNEZ4TjN2SEhNRHhzTzkyYk1EeFpKNzBrWlhOQzBOYmdPbk5VRW41TERlb2lpanBkTHNhOUdZTWhOc2hJb2NvTlJDcTJpVWpFRzYvVnZUU1g4VGszODg0YjQwUURYVGlCSWozY2VPVnBHWkdLSjdId0hrd1BnOHZZZU53Nm1BRXpXaG9RUVZULytQT1k0WE4vYnY0NXdiVlNWOStRbVA1K0FLa3BGVmc4NWxZNVRlbzdaYUtnbVVKVG1HTTZ1cFBjR3lRd3VDclp6dU5iMWNrZHBxbVdNa3E2TGJsN2IzNzIydS9pM3ZRL0tDdFlmZUFsRzlpSXF5RXFES2IvdjR1WmRyN3gzODRlOEQ1bldxa2RLUjF3UW1yYnRoY01pV1ZGUWxDVmQxMXNTeDBBUWhUS0dLSXJnQTRpbXpIT081aTNMdXFVYWxFbDYvMmpJckd3SlphQnQwM0hLZStrZngwTHdRdGVHVkVGYzZqMmlqN1NkNTJoL3dXeC96bnhhRTF6L1ZET0NEQlVoVTdoYUNEWWtyNHBFNGhkQmxJZ2k3NThFRW9YcHRHV3hBSlBCY0dnWURCSnZaRkJJRTl2NExGRldmSTdGQ1JxcFh6MGxGVW9NU2lxeWJ4aG45YTNHY0ZBUVk1UzZpYUZQa21OSG5zOS81ZWsvVzlUdDlMVVAzUHRmbk4xY2Z4ZEttUkFqald0cFkwMm5Hb2FUakhPREVWbHBrdis1RTVSSzBIOUVQMitsZmF3MjM2dEhJaUpscVQ5MTdlcjhkNndMODVNSWdoY0NBNzZVSzRnK2tSd2pvL1hhUC96eE4vKzlleTZNM3FPTkxyUytxWUFoWkJnellEeGVCNldSR0ZOajNuUUpCeWJRMUEwaFJLYnpHYzVac2l4SElsZ1htYzRieHFNSzd3UFJHN29HdXJ6RDJVaG5CUitTdWFSMXlaYll1NGhyUTI5SUdWZ3VIVWNIU3c3M3B0U3pKZDRsV0lGU2ladGhqR0F5UlRGVTZDSlpNVXRVVVluU3NRZCtxbjZCZEZJMHR3dXczd2FadDE2RkVFUGo5RjhkV3ZtZGpuaXRUNDRhYU5VeGJWWkZoZXI5cFJVNSt1dnlPNzc5Q1ZKU0ZRVkJJaUhHMVVCcUpZZ2doL1A1N28zRHd5OXRUc1pudGRMcmN6YzF0WjVsamc3Vit4RTJ0YWRwRXFjbXkzVHZwWjZXY2dwWTFJa25nazBMenlnaUlxS3NpMC9mT0d4K2Z1K28vVkwvQUdsZXl0WGpheVhJU3FZL1Z6Mzc3eld2dU92ZS8vZ2RyL3JaUVJidlM0eXlsWVozMzRSSHhXUjlFNlVNSXF0alZxTElpaVM4ajhrTXMvbVNHQUxhWkxUV0VTV3dzM2VJY3pBb0I5U2R4YmNhVzN1c2NnUVJuQk5zL3dwZUNEWWRwNndOMkM2d25MWE1qeFkwOHlYUnA3R2swZW5KcDFUaU1xemNDdFBjM3JRKzZrOEV5dzJOT3FmQkNLcW5aTjVFeFhWRThVVFZ4dGhNclh6azBNVmZtRXQ0dEUrT2swU2JrRVFYREFNeVhPOFp1K1EvL0xSbTJYVDhyei8zMDF5OWNjRCswYngvUEIyL0FrQnI3V3ozY1BxbDZ6ZjJ2OUNwWm04MExpNE1xbnhOWjhuQ3Jxc3RCenN6am5abnVOWW5pb0hJc1F6UXdlR0N0dkdZZnAvbEU2MTZPYTN0TDEvYVhueFFSQlluQUpyK3BWbzl2bGFDNkJPOXh3Z1kvNWMvOCs0ZnVlZkMyZmVHTUI5RVNVK1ZJTHEzK1ZJNDUxZ2JiNUlYT1NHa0JPazZ6K0hSRVZwSnd1cDRJVWJGMFdLSmtvQmdrZzV1RE93ZExYdkZLUWdCcEUzQ0NWNGxzUUhuaE9nbC9ibExvc250MHRFdU8yWkhTNXI1RXVkODc3QzY4dXZqcEp4NE9pRm9UUlR6bGIzRy9zdVpkWCtlb1E4VmFxSlE2d3FsWW9KTjRnZzR2QkxZOS9DckRmeGZEZkd4VzU2TVhxRmkvODlqMEFuWjIxc3EvMjJGUktIdUxHdkRDbU1NZGR1ZHJDSUJpSzIxODNsVFg5NjlNWDlVb2E2T0o0TzdpeUk3RzN5a1diUzA4MW9kM0ppeHR6Tm5mM2ZLZEcvT2NsclROcGJkblpwMjJhQmlJUGdnQXRINitNRnJ1ODJ2TmEzYjVYblNQaS9kNnZGQ0NYSmNQWHBJeWZBdHIzL3c3dmU5NTVHZjI1aXNQVFNkSGhHQ0o4YUFqeXMrTXRSTlM5MUd0amJYa1JDVDA2b3liTy91MHpZTnc2b2tlS0VvY280V05UY09Ec216Z3JwTjQrQzI4K3dkemRtWWpBa2hwbTJ1THdsQjZPaUlMc0VjanJGUFhXQSs3NWpQYXBiVEpjNkZoQTlhdVVHaGppazFjWVhlTklvWVRMMmM4NEg5ZWZ0bm5uaWp4bjhXMU9jRWRoV01GR29UUkFzeEJ0VGpIdlZMQytMdkJHU0htOGpjNHlsVnlydGVOQm41dHNCSXZ0VjQ1dG9OZGc2T2VPTXI3eU9FeUtKdUVCSHBiYWJsQkM1S0JPekI0Zkt5cytHeDZLTVg3eS9PcDh0QlUzY3JySldLSWVLc28yczY5bmFYekk0NmhvVVNuZmpwTVVRK3YzM1EvTk85dytiSlc2NlJ2eFZrK0hKSmtPT3R1VEZxN1pGWFgvamhWOTUvOGFmVzF6ZUtnOE9aaXRKZ3NoeFVrUXhTU05wTE4vYW1yRTgyRXllalo1OTU1N2wyNDRneXo0blIwYlFPb3d5WHJ1MnhYQzRwOGd6bndaaU1vOW1DbzZNRms5R1FpS0p1T3FRRm93d09qL1hKdU42MmdYcHBXVXdibHRNRmJkMFJZenh1SmhVYXJSS1RNQWxJYTR6UkVzVlFMOVJuOWhidHY3TEJYKytmZEV0TDNHNkpuL1hJcHcycTFtZ1IxQ2RhK0QrV3hEK1htMnFBZGIvODgwQXMwRExBWUw5TEg1SVh6MjB4cjF1S1RGTzNqaDduRVU5VWtsV2loK21zdWJHM3UvanJldEU5S2lGc0tpVVRSQlVvcFh2bGRMRk8xSFFtc2o3T1ZEWFFTcFE2V3JUKzk2N3YxZi9zeG1INzZJbnEycjNVajFZdmxDQzNWby9SbmVmSEYxLy93UHAvYlp2Wi9TRWE4bUpORVRza0pwSldnazByaWl5amFXc2FxemwvWmpQaHJIeWdMQXBFNVZ5NnRzdHdVS1RtMTlhVXVlTEtqU2t4SkZuOEVEWEdaTnpZUDZCdVc0WlZoZk9lempyY0lxSmNEa0FJam1iWk1UdXNXVTRYZEswOUZvODJScFBwcEZQVmU4ZGdUSElwaXNHb2RxNFBGcDMvaFduYi9IWGZSeHozRWdMV0lYc2Q4UzlhNG9jYjRvZGF3Z3BUZFhMNUZ6S2xZNkdNR0pUa0tMcnYwdkgrcGUwOURxWnpqTllKaVl5UWFkTkR4WStyeVdyNkZrSVV1MmpjNVdVVFB1V0RQQVo2cWlEWENYMnpmelFMajFlbE1hTktiYnZBWHgzTTdMKyt2TFA4elhuanIzeVY1SWd2OWVSNG9UR3Y3aGVEQTZQMTRGM2Y5L0FqYjNqMW5hK2J6NmM4K2RSanFocmV6cm10aWtGdVFWemZsRU9NbnZHbzVNcjF5NXcvdThWNE5FeGFza3B4ZG5OQzAxcTI5dzQ0dDduV0o1VGhqck9iWEw1eFJJeVJMQU9VNXN6bWhHczcrOHlYSGZmZGZRY0kxRTFEV1BRZUU4T1NVc0ExaDlUTEd1L0NzV204V2drUkNNZXlORDZDcXhYS1psR2ovblRXelQ5NXkxSXZuS2lhV1VDeWdLellNNnQrL1pnbWE5QnhxSE9HS3BOdHYzeEozT1REZWZvNXRkYWNIYTNMb3F1bGRwMktNWW84djZKWVlOQzUwSGJUY0ZsTnU0K09oOWs5NjFYMnlvaHFqeHIzMUdZbUY2L3VoZjFwN1M4NUx3Zjl0VG1wbXVpTjBYRTBLcGpOMnBkNmZqeXZncXlxUjlicjQ0N3V1ckI1OWovL3liZjhvL3Z2dnVPVlcxdGJqRWREMVRRTDVrdFBrYS9lMURsQ2tzSFhLdEswRFR2N05iZWRQZE0veHBOU3hyQ3FPSnpYUEhmMU9tV3U2R3p5NkRhbTVQTDFYY3FpU0h5RkdDbUtuT21zWnU5d1RwSG5HSzFaTEJ2cXVtVisyTkhNSGVJVWc3S2txa3BpNlB1UHVESzcxMGpRdEExMGM0TnhHWG1XZlducTIvL3pxRzR1ODN4ZHF1TmpocnFaREs0ZjNUNVBDQ0JUV2dwbHhDaEZwalRMNkY1U04xdEVHQlhKUlRZM0dVWnBRcnBvOFVSZmN0TFFzdTFjM0o0MS90RjU0NS8wSWU0dkd2OUUzY1VyTVRMdmsrS21oSkZTWGlsaW5oczVzelY4MlNaSW9XQW9NUHlaLytoTjczN2tkUS84akNnOXpJeFI0K0dRTTV0YkRNb2krZFdKVDlwVVNTeUtFRHhWV1hKbGU0ZW0wNXpkblBUUWs5U1BWSU1oMDNuRGxaMkRKS0tjbFdpVm1INTdSd3VVaW1RbThmS0xURE5iTHJpOHMwK1psK1I1d2RGMHdXeTZaSDkzeG5TdndTMEY1VFBFNVlqVFJLZnhqY2JWQ25FWnltWmtHUEk4cSt2bzNuLzFhUHBuSi9xSjR5bVVTWnl6a3dJQUoxOVI5VnlPVW1meXRxM2J1ZGJVSElUbUpYbkRsN2JGOXZpMFVtZGt1VG9XZnY0cS9ZazdVVUZQTGtTUEpYTVNDREZkSzJOMDNGaXZPTHMxSkFSaFB1OWVWZ215cWg2bHdQRGkrY21Gbi91cGQvdzM2K1BScTBMdmVocjdjLzZnekJtUHhtUkZpWFBKNURHR2dGSVFvcUhJaFV2WDlwbU1OeWp5cEJhT01sZ3ZqS3NoTGlpZXVyU05TWUtJREljVmcwSEZ3V3hKWndOYVp6am5HUlFaSW9ITDIvdE1aelZOYmVscWk3ZWU2Q0p0YTZtWEhWM2pFbmpSSzhRbi9UeXRFN2pPR0kxWDhxa2J6ZkpYVytkdW5EaGF1Y3pvbUJzakppcVNqQUZmOVpXV2ZvcUlZcnV0bWNlWC9vMWZ6eXVDUk82NWZjSzhjZGliM2dwUktVVDFGVld0cXFsS0ZiVlBDTmUvMGdOR3F4Q0ZxTFZpTWk3SkM4T2x5MGU4SE9KdkpraHljeXIvenZlOTRnMXZlY01EUDUzblpyMlhlTVE1aTQreE4zLzBGRVhpY3hnTlhlZHhQaUZXaThJUVE4ZmxuUmxiRzFzTXloenIweWgzVVRlVWVjNW91TWJ1d1l4WnZVQ2hHSTlHaktvQmk2YWhibHBXQXF5WnpqRktjWGcwWS9kb1R0dTVKSmNta0tYcFZDOWNscFpZUnF1azI2UlY4Z0NKY3RSRTl4dDc5ZklUSXNmU08xWXBGWVpsd2JuMU1kTzZUVFRNcjdFMVRVSktFU3ZoWlhIajIrQ3cwZU5Dc2xMckt3aURJc2RvTGIzbGJyeGxmL0s4eXBwbldvYURUS3BCSm0wWDBGb2x0UmNVczVkQjlUaVpJQ3RRNHNwRmR2S3pmLzl0UDM3MzdXZmVGYVBQMExxdkFvbHBoa3JmbGhaL2tUeFA5c05hYTFyYlVUZWVNdGNzNmptWHQ2ZWMzVGliVUtLZFd4MkdLWXVNSXN1Sm9wZ3RhenJiVW1hRzRXQ0FBSFhiMG5ZTzUyUHl6bXNqZUdpdG93bVdUZ0krQkhyR0xGNGlRWkxodkk4UjY0SklGTXpBZkhLblhyN2Zlbi9qeEhrNUFOSDZJT3VqaXNQNmE0TUpWKytRbDJPMDFoOG5CM0NzbzVVZ1JNZS8vcTJ2L21zVldmK0FhcnZrSlZMWDdtV1RIQ2NUNU9UbWZIQnVjM1RiRHozeTBIOVNaT29oYXkxbFdTUkxMWk9oZFo3VTlsUXlwd3plSXRFalJBYURpa0ZSRWFMQmVvOEdEbyttWE5tZXNia3hJVE1hMzN0elcrdFlOZ3ZLSW1kOXNrSG5JNGV6S1VvSmhkR1VSUVlpV050eE5GdHdNSzFSTGhuS205NDVOWXBnWThERm50M1hzLzBrQ0lVeHFocVYyN1BRL2Z6QmN2bmxQamxxQmRab0hVZGxJZFlIcG5YRGFkeU1FR09TNjNrUlg1dFEyY210NnVVYUp5dklTc1puK0piWDN2bnd4YlA1MzEvTURzNU01NHRrSXhZMFdobXkzQ1FxWnE5cW5qZ2hDVUxTYTY2aENReUhRMFFwdE1xNHZuZklwYXY3YkU3R3ljVEdPN3l6Q2R1ak02TDNGQ1pWRk9zRG5YTWdTWm8vT05kYkRDZG5xTlVvMTZpa25ac3JRNmx5TWpSR0o5dTBzc2hsT0J6NG1LdmZ2WHg0K0lFb3gramJUa0ZZcTBxNXNMbk8vbng1bWhHbjhhTDJJTWNqWGlDNzg3Ykp4VFByZ3d0NWx1RHF6aTY0UGx0UUZFUFdOellZRkNWbHJuc2JyRFNGQ2xFUUlscWxIaUM2aG1GWmNkdlpuRHl2ZU9LWmJUN3orVWU1NTY2TDNINTJnM1pscEtrZ2hFRFRKSHRGZ3lhcUhJa0tvOENZbkJnMEpoaHlmYlBBSnhScEw1aThLb05ha1JlWkZIbW1zako3ZHJlZS9wRVBZWEhyQXF2cG5OeDlicE1ucnQwNGZRZWN4b3RLRUwxS2tPRWdINXpiR0x5eUxNd3d4aHhGb0JvTXlESk41eG9POTY4ajVBd0dBOWJIRS9JaTdTNVdwMVVmSWtZVmtNVmVtbEp4ZHJOZ1dBMTU2dEoxbm5qbVdieTd5Sm5OTlh4SUtoa0oxK1dUZkk2UE9POVpMbTN5NE80ODBhZHBsQ0pWbGRocjhDdVJZMitQekdoTXJsRktxeXczb1E3dTN4MHNsazl5Z3RHbWxJcFZVZUM4NTRPZmUvejA3cC9HaTBxUWs4eEJjMjV6T0J4VjFVTkc1OW9ITDFvWkZXTHk0TWh6Ulc2Z2RaNzUvSkNqNllKQk5XRTRLRmtiRmtRUmpFN2tKc1NnVGNDSVFiekg2TWg5ZDU3anpQcVFLenU3WE4vZFkydDl6R2hZb1hTQ3FqZ0poSDVrWksxanVXaXA1MjBDTHBLbVZrcnJwTENJT3NaZktiMnlJVTdBeWFEa0M0ZDEvVUhudzdHYktzblRUNG84bDdyclR1LzhhWHhqQ2FJU3ZVNmYzNnpXMXlyT0J1bVpaR3BsTEI4Z0drSTBaRHFTVndvZkF0UDVMcnQ3d25nOFlXdDlRalhRU2FRc0pyWmg2UCtMbFZIamVLM2kvbHl4dlR2anVXdlhHRlVqenF5UDB6UkVLWWlScm5OSmI5Y25qVjNkNDlhalJMU3MrTStRMUt6aU1SOWFJb2hoZis3YS8zZHZQbitLbXhBSXZ4S01yb3FDbzlQN2ZocmZaQS9DK2xwK2RsU1pNNmtQWDNrL3FKUWtTZ2lTaEVORkFLV1pqQ3VxMGpLdnAzemxhTWJHWkVRMUdESWNGQ2gxVXhkTGVrOUFpYUJVeG0xblJsUUR3OVViTTU1NDVnclZvR0t5VmhGRHhGcWZGRXRjT0ZheFVTcE5yU1NwbWlmSkRwMlNaR1hQRXFPSUMrRnpPN1BweDBWazFYYzRJR2JKT0pMckJ3ZW5kLzAwdnVFRVdmVWh5amtaSHg0MTR6ejNpQ2psUTBDcERKU2hxbkxLUEcyNVk3UVlyWWlTbzVSaGZXd29jc2Q4ZHNTMW5YM0dvd20zbmQwZ000WVFOQ0Y2bEU1Z2pnVC8wUlJaeGwyM1RaZ01CMXk2ZHNoVGw0NElJUWxGKzVYUVhKQmpKWnZWQUVEMVdyRFNaMnFJUW1zdFNzdThrL0NucmZNM3VPa2U1TFZTc2NnTWE0T0NSZXRPNy9wcGZGTVZSQUhLMmxCTTUyMDJLSk05cncrUkVKUE1aK2NVdytFYTV6WUhERXFkbnRvK0pDMWRTUkkvazBsR1ViUWN6UTc1M0dNSG5OMDZ3K1o0akZKSkd4WThXUVpkbDZHVUExRlVwZUdlTzlhWnJMVThjL21BN1JzenV1Q1RNNnRLSXRPNjl4UFVScUZJbzJVa3VTakZFRkVHcXJYOG1WbFQvK1dKbzVVRHduaFl5UG4xa2N5V3A3M0hhWHp6RlFSQUZabktqRllxOXFZeFdtZU14MlBXSk1ONWkzV09aNjhlVXVhR2Mxc1ZSUzRjbjRORWlBRXlyVG0vT2FBYVJDNXZYK09wNStEZWl4ZVlqTXBldFU4VHhhWXFRRWFVWkNVd0tEUVh6cTVoRzQrYkp0WmlRQWdrVXp6Vmd6NlVTcUlJV2hMRVJJRU1LOU4wK0Q5ZXR1NGFOOEYxUVNrbE1ZZ1VlY2JPOVBSNGRScmZmSUlJSUM1RTcyTVVRc2JtNW5rdTNIRXZ3K0U2U0dyS3ZldHd3WEo5KzRCbHZhQ3NjcEFPQ2F0dGRvQVlpRW9vaXdGM1g4dzRPRnp5ekpVcmpLc0I1OCtzVVZYcjVEazQ3MUhLSnc4UTVURXEyWnB0clZlRUdEbWF0NWlvS05MdS9GZzRJQWxHOURwTkNqRkdJWVpIRDV2Mnd5TFNuUnpyYW9VMG5Yc2VuT0kwVHVNYlRaQmpqRTNyNUdCdGN1N29uanZ2cnRZblcrUkZSZE4ydlkyQkFaVXpySWE4NHY0dHJMVW9sWnlFZ25lSVdCYkxKY3ZGRVhXenhEcUw5YkEySEpCbkdRZEhjeDU5YXM3YTJvSzdMNXp0WlVraldwdWtKTzRrYmQrMVpwVG5VRUZ0RXg0ckp5RjBsZXE5S1FCdDBuUXNMN1JZaVo5dXJOL2hCQ3hiSytMNTlTSFhENWM4Zm1YdjlHNmZ4cmVVSUJHUUxCdnQzMzdidlh0YlcrY3ZkTlpKNkRvVmd2RDBzOWZabng3aHZFTWQwMWdEeWVMTmtLbWM5ZkdRTTVzYmJKN2RZdGd1cVp1RzZieGh1VHhDeExPNVBtUnRtUFBrcFNPMjkyWThlUGR0ckZVRHRPNmhZTXIzdFNHZDJncGp5RXBGclQzQkNVWXBlc2N0c3BWNHNsSEtGT2F5ai9IalBzU1R2VWZNczB4R2cxeE9iL05wZkNzSmtxcEgwa3lMclF0TjUzeVR0dVBDMFZIRFo3LzhCUG5tQVErOTlSV3NUYzZqamVDc3BXdHFPcHZldkxPakticzdCenoreGFjNU96N0huZWZQVXcyMjBDWlNWWnZVOVp5MlhZS2E4c0JkT2R0N2N6Ny94RE5zclUrNDgvd1pqQmEwMHNtZ01zWmp2VmV0RmNNOEkyYlFkcUgzOUVpSzRvaFFsSmxrZytKVHM4UGxveWVxeDdGUnBwTFRvOVZwZkJzcXlJcE50M2M0bXkvcWRqL0xERTgvZDROUGZmRkxQUENHd1BkKy93YnJtMmZJekczNDBOSzJDeFJyZU4raHRVYkNHTmZOMlo4NW5ucHlseWVlM1dVUXRoZ04xaGtPQ2tiVmhMSWMwWFhyTEplSFhGQVo0MkhHMDFjUHVMRS81LzZMWnhqa1dZS1VwTVk3TmVNbTZ4bUxhWlBlZG9taGFESkZPY2haRzFmYmkrZy90S2pidzVPVHF5d3pVbVFaYzUrZDN1WFQrS2JqSk54ZEE5bXk2Y3pEOTkxMTc4SEI0aTNQYkQrcDN2ajlPZC96OWsyVWlvU2cwTmtXM2pxQzcvQ2h3ZnVXR0R4ZE02V3RqeGhVQlZ0bk1xcEpwRk1MbnIyOHplN09nbUZWa2ZkR0sxbGVVUlJyR0ZNd3FncnF0dUh5OWdGZDU1SnNway9iOUxROVQ4dEJyUlRHS1BJaUE2MHBpNXp4WkJoVVlUNzA5Tzd1YnprZnB2UUMwa3FwTUJsV3JBOHJydTZkVHE1TzQxdFBrTlVlSkJORmRuQ3dLUFZnOXBvZi9ydWJaeDU0ZUNOWitvYmtKNkVaOWw3aW51QWJrQldKS2lBcTRvTWxPQS9SVUUwS05tN1A4S2JoK3ZZaFhSMHdPc1AwZUtzc0t5aUxNVlU1UUlubHh1R1UvV2xEcG5xa2NGSWdQOFpaaVNSbGpqeFBQWkRLOU9NM2xvdC9zVDliUEVWQzdCNzdjclRXeVdRMFpIYks5emlOYjJPQ2FLVW9EbWFMbzdlKzgwejJmVzg1LzBZdjVDR0tDcUt4cmNNdFc4Umt5WWpHZVNUYW51SnFpQ0dpbGREVW5tVWQ4QkdLSW1QcmZFVzFvWmk3QmRkMkRsaE1iYklrMWdvbGlqd3JHQTVIYUFXeitZTGQ2YUpQcE9SK3RGSVJUL0FXVUVxSk1hcWVCL3NybC9iMlA4aE5VYmRPS1JXTTFnTENkSG1hSEtmeDdVa1FUaVJJQnVqMXpiSjQ3YXZPdktVY1pKcytSa0RqQThRWTBWbEZWQW9pQ0FHdEFrVTJwRzFtWEwweW82NFR3REF0R3dYYlJVUnBobXM1bTdkbkxOMmNaNTY1UWZTQ01WbWZuWVlpcjhpMHdYVWRlN001blFzVTJpVGwvUlVGVkNGYUVhMkVEMTZielg3RituaEVMOFNnd0dmR3hJMVJSZDJkUWtwTzQ5dGZRWlJTeVZGcXVRenE3ZSs0L2UzVlduYW50U0tpVUZsdTZHSWdPQUZLb25pSWdXcHdIdHNPK2VoSEgyTTI3VGgvdmtLYjFHVGJPaVR1R3FhUEVBQUFCMTlKUkVGVXVrQU1RcDRadHM0TnFkWTFzMmJCM3Y2VTZJUTh5eElkVnd6ZVJhTHp6SnVPTG5nS1kraXAwb2lnb3VheHZiYjUrV25UUGNOTmRVU25JQVFSK2NjLy9rNys5TEZuVHUvdWFYeGJLOGh4RlFGeTJ3WDl4amVmZjNnNHFWNmxFUzBpeW5mSjhXblpPQ1E0eEhma1dxanJkVDd3KzUraGFXcGU5YXAxdEU3WUxlOUJYQ1NTNkxpOTNqb2hSTW95WjIyclJGZHc5Zm91dm9sazJyQmMxZ1FmQ1U0UUd4UGIwRHR5blpGbkJrRXV6NXo3cGIxbC9RbTVTYVh0RjROS0JFNlQ0elMrWTBjc1ZzZXNHSVh4K21EdzZ0ZHRmWCtXcXlxSXhudXdMaG5aQk8vSU11SHljek4rN1ZjL1NRaWU3My9IQlNLZXpnbGRIUWxkeEJRck9IckNoU0NKV3VKNjE2aXl6S25XTW1hemh0Q0FjNTdsc2lIRzVQTkJqR2lTUjBobTlMSlQ4VGV1enVlL0YySmNHV1oyZ05OS1JhV1VHSjI4dWsvak5MNVRGV1IxekNxY0ZmK2FONXg5NDJpdHVCZ0NSRkdLQ0JwRjF3WSs5WmZiL1A1dlA4N2FlTUNQdk9kKzh0emhZc1QwRFlnR2xFbUpFVWw5UkdkaldycDR3VVdJTGlUUVlhWnA1NEY2M3RDMURrVElzbVFESmpHQ3FOaUc4T0VEMS95cnpvZVRIaFJXUVJ3UEt6YkhRK3FtTzAyUTAvaTJoYjdsNzBMQ0JEcWxsYjl5ZWJiOTJKY1BQbGdVSmtSUlNrbkU2T1NIL2RFL2VZNFAvTzdqOVIxM1R0b2YvOG43eU1xT29DSzVWc242UUN0VW5xaXd4aVFGOTlZS1JaVVRZMnJlbzQxNEcybmJnTE9XckVxajMrQmpiKzhXR0ZTbGFKT2hjcjQwQzkwdkx6dDNqWnY2VmxaQk5FcUw4bEdNMXZoNHVqay9qZTljZ3NDeERwdDAzc1h1aVM4Zi91VjhacjVTRmdPVVJtWkhsdi92QTAvN2YvK3h5MDg4OE1yTko5Nzh0anZkWXVteGRVU3ZBT205VEpMcHdZU1pnbWJwQ0ZId1hjQjFDY01sUGxrNmV4dm9Ha2ZiTGltR0JwTWxpbUE2TWlteXdseXJDZjl5R2R5ajNEUm9zVURJakk1clZTRWl3cFhkdzlNN2VocmY4UXF5Y2lEcWdPNnZQcm45OUJOZlB2cW9NVWIyOTV6ODRlOTlaZnF4ano3M2tlOTU4L2t2L2ZCN0hyeWdWTFkyWHdZT1o1NXBiOVVzMHU4dWVnZkpadW01ZkdXSlJ0RWNkdGlGdzNlQjJEdEp1YzdUMVIzenhRd3ZIVm1XUVpRMHNVS3NWZUczRDV2bVl5TEhYaDByRWVVNHlETVpEd3BtenA3ZXpkUDRqdmNneit0RkFPVmNsSTJ6eFZ3aEQvN1poNTk3NXMvLzdQS3Z2Zmt0dDgvZit0Wjdma1NpdVNORVVjYjBIdU5PY0ZZSU1VSFJCVkNpZU96SlE4cTFra0lwMnRvblFDSUtDYW1pTkF0TFBXdnd6cUZWVG5TS1p0a2hDdTlVK01PZHhleFhUdlFkcTVGdU5EM0xzTXd5NXUxcGdwekd0ei9VMTBpT2xRWDBZRHdwMTlkRythdW4welkrOHJZNzczL2trVHYvQjV5KzN5WDloQ1FtYlJUZUM3Wk5LT0NzVUF5SEdWY3VUN20rMS9MSTJ5NHkzVzU2aUcwNmh2bk9zNXcySE80dVdNeVdkSTBqMkFIU2FWem5ZdEI4WktlYi8rK3p1bm1LbTU0ZUs1NjVHSzNGaFhCNkYwL2pQMmlDckQ1LzBpZDlDQXplK3YzM3ZPN2Q3NzdubjdoZ3ZpZTRTUFNpWWhjZ0NKSnJmRXc5aFVUQkIrSEc5UmxmZW15WE43L3pMb2JBd1c1RGJ4dUk3VHkydGpUTER0czVuSFBNRGtWaWs2dEJrVWRIL05DUmIzL3hvRjU4K1VSeXRJRFBzeXptbVJIdlBQWTBRVTdqT3hndmhBVS8yWXVzTExiMFltNzNMajIzZU9MQ3hjbHJsVWlCRGFKQmVRWEJSN3lYMUh5TGNMQzNkSi85N0VHOC9ZRkpxV3pIWno5NXVSKy85bzE4VERLbFdtdEVvalMxNEdvamhkRzdUWEIvZkdEcjMxeTRiZ1ZDVERncjhBS3h5RElaRkJuNzdha0l3Mm44N2ZRZ1h5MVoxSTJkUlhQNTB1eEwxU0NQNDJGeHQ5RjZKSWtCcUd6cnNiVUhwVmpPMitiem45ditRaWdHK2xXdkdrK2UrOEpWdXNhbmN0WEQxNDFPaUZ4QnBHbTlyNmVtbGFnL1hvdjlGN3Z0NHJmYTRLOXhBb1JJTC80R1NKNFpqTmEwOWhSdmRScC8rd2x5TWxGVTJ6cjd6RE1IWDZ4bjNkUERVWGt1SzdQYkVHV0NpNFNJTEJldFBQN2xheCtmdXVMcDE3L3B0amNzdDNlTDZlNHk4Y2UxSmtsYkpadG1IOWxyclAvRTRWUSszclhxdzdQWS91TE1kMStJeUtKUGpKcGpxN1JqOFhpY0Q2ZkpjUnJmZFFseW5DZ2l5TTd1NHRMaFVmTVljT1J0TU1DNGFWeDU1Ym05djM3aW1lbjdYLy9JZmE4ZG1lNzExNyt5QXlpbGxWSzlTbU1RWWIreDRVT0hDL2ZyMS9mdC96M3YvSWRhY1oveUVvLzZwRGhwdSt4VndsaTk1RDIzVCtQbDA2Ui90YTlabWV6a1FLbVVHb2hJQVZSbjFvZDMzWFhYeHV1aWMvZGUzWjUrZW5obWZQaXFoODc4Yi92UDNYaHR2YkNIb0xaRGxOWkh1UktEUEc2OVBMczNzNSt6WGc2NTZTUnJUL3o1MkdrMU0xcHlrMFh2UGU1MFMzNGEzNFVKd21TanBHMjhzbDI0ZGJwVjlBbHo4bk42WTdOYU83ZFZ2bmwrc0N4RFZBYyt5QTBmWXRmNU9MZE9qbnNLYmpxcFdtNTZrb2UrVWtTbEZFV1d5Y1V6bXp5N3MzdUtzVHFONzg0RWVkZVAzTWVuL3VJSzlkTGRXazFNbnhqbXhPZFcvUGJWdjI5Ty9EMmVTQXgvSWlGV3Z0enh4REZLdE5aa1dyTStxdGlkemsvdjFtbDhkL1lnemdicXBjUDdlR3ZUZnRMOTFOOVNGVmFmWDFXSWxlSmhjOHR4S3B5b0d0emFaNFFZcWJ2VExmbHBmQmRYa0JmeC9TYy8zdm82bVZBdjVKaDZlblk2alpkbGdyelF2N215RmxkZkpRRk9rK0UwWGpMeC93TzZJRzNYblFXdmZRQUFBRXgwUlZoMFkyOXRiV1Z1ZEFCR2FXeGxJSE52ZFhKalpUb2dhSFIwY0RvdkwyVnVMbmRwYTJsd1pXUnBZUzV2Y21jdmQybHJhUzlHYVd4bE9sUk5UbFJFYjI1aGRHVnNiRzh5TURFeUxuQnVaMUlRNURBQUFBQWxkRVZZZEdSaGRHVTZZM0psWVhSbEFESXdNVFV0TURNdE1EZFVNak02TlRBNk5Ua3JNREE2TURDZjFKbEZBQUFBSlhSRldIUmtZWFJsT20xdlpHbG1lUUF5TURFMUxUQXpMVEEzVkRJek9qVXdPalU1S3pBd09qQXc3b2toK1FBQUFFWjBSVmgwYzI5bWRIZGhjbVVBU1cxaFoyVk5ZV2RwWTJzZ05pNDJMamt0TnlBeU1ERTBMVEF6TFRBMklGRXhOaUJvZEhSd09pOHZkM2QzTG1sdFlXZGxiV0ZuYVdOckxtOXlaNEhUczhNQUFBQVlkRVZZZEZSb2RXMWlPanBFYjJOMWJXVnVkRG82VUdGblpYTUFNYWYvdXk4QUFBQVlkRVZZZEZSb2RXMWlPanBKYldGblpUbzZhR1ZwWjJoMEFEUXdOREZxcmhJQUFBQVhkRVZZZEZSb2RXMWlPanBKYldGblpUbzZWMmxrZEdnQU1qUTNGQzRWa3dBQUFCbDBSVmgwVkdoMWJXSTZPazFwYldWMGVYQmxBR2x0WVdkbEwzQnVaeit5Vms0QUFBQVhkRVZZZEZSb2RXMWlPanBOVkdsdFpRQXhOREkxTnpjeU1qVTVQdWZEa3dBQUFCSjBSVmgwVkdoMWJXSTZPbE5wZW1VQU1USXpTMEpDNGZ1eWNnQUFBRE4wUlZoMFZHaDFiV0k2T2xWU1NRQm1hV3hsT2k4dkwzUnRjQzlzYjJOaGJHTnZjSGxmWWpnM1l6UTFPV00wTXpRMUxURXVjRzVuRVphWHlBQUFBQUJKUlU1RXJrSmdnZz09XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9kb25hdGVsbG8ucG5nXG4gKiogbW9kdWxlIGlkID0gMzAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFNZ0FBQUU0Q0FZQUFBQWV2Ynd6QUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFCSUFBQUFTQUJHeVdzK0FBQ0FBRWxFUVZSNDJ1ejlaN0NsMTNuZkMvNVdlTk5PSjRmT0FVQ2p1NUVEQVlLWlZMSWt5ekpsT2NpeVpObVc3Wkx2QjZ1bVBPVXB1MVJUTmFxWm1nOE9kK3pyS2M5WTErbmFsaTFMbG1sTEZrbVJFaE5JZ2dRSmdJZ05vSFAzeVduSE42MHdIOVo3RHBvVUpaR1VxTEdrOHhRT3prRTNzSHRqdit1L252Ui8vby9nMFA3WVdLZlRJWW9pZnZSSGY1UzV1VGsrL09FUDg4d3p6d0J3N3R3NTdyNzdidkh4ajM5Y1ZGVkZxOVh5RHovOE1FOC8vYlQvZXErMXZMek1ULzNVVHhGRkVULzJZei9HOTMzZjk5SHRkdm5zWnovN1Irb3pFNGZINW45dSs4bWYvRW15TENOSkVyd1BaOVU1UjYvWG85dnQ4bmYrenQvNVhWL2paMy8yWi9rZi8rTi9jT25TSlFCT25Ub2xyTFhjdkhsVERBWURjY2M1RU5iYS9aKzlsQkloeE5jQ3hBUEVjZXlYbDVjNWZ2eTRyNnJLRzJQNDBwZSt4QWMrOEFFZWVlUVIvdUUvL0lkL0pENS9mWGdFLytlMHYvdDMveTdQUGZjY1pWbVNKSWx3emgwQXhGcUx0WmJoY09qbjV1YlkzdDcrdXEraGxPS0hmL2lIc2RiaXZSZjlmaDhwcFhqeHhSZUY5MTU0NzZYM1hnSUtrQTFRRGdEUzJBRW9tdThlOEVWUnVCczNidmdiTjI0NElZU1A0OWhycmIxemp2RjQ3SC9xcDM2SzgrZlA4N2YvOXQ4KzlDQ0g5dnR2UC9NelA4TkhQL3BSY2ZueVphSW9RZ2h4eHhrVkpFbENWVlZZYS8zYTJ0cHYrZS9uNStjWkRvZWthVXFyMVJMOWZsOFVSU0gyQWVHOTE0QVdvSDBBaUxvRElIY0M0cXVBY2NlWEZVSVk3NzBWUWxqQVNpbGRraVMrMVdyNXQ3Lzk3ZnpLci95S1AvUWdoL1p0c1RmZmZGTzgrZWFiOVB0OW5ITUNRQWdoN3JqUnZaU1MyZG5aT3c4MEFMMWVEeWtseGhpR3c2RWNEb2Y3M2tJQkVSQUpRZUw5QVRnMEVMVmlsWnljNzZTdE9OYUR2SExYTm9kajQ1d0JERWdOT0hBMVlBR1A5MFpBN2IydmdOcGFXK2Q1YnF1cWNoLzcyTWY4WFhmZHhlWExsdzg5eUtIOS90cng0OGRaWDE4WDF0cjlVRWcwSWREKzdZMFFlQ0drbjV1YjgzLy83Lzk5LzlNLy9kTUFIRGx5aE1sa2dyVldGRVVockxWM0FpTVdrSGhJQUJWcjJUbTMyRHY2dHBPelowN09kODcyZXRteGRoSk5leSt5UXZqNkZ6LzErbjk3OXZyMml6LzY5clAzMzNkNi92Rzg5dVhydDBhdjM5Z2NyRDk3WS9QcXFNaTNnUXFvZ1JJb2dGb0lZYVNVZG1wcXl1L3M3UHloOWlLSEh1Ui9NdnQ3ZisvdjhXLyt6Yi9CT1hlUUp3QXliWFhsUTIvLzgzT3ZQZmZKU1gvM2paSDN3b04zTXpNemZqOC8rZG1mL1ZuKzJULzdaNVJsS2FxcUV0NzcvVkFxQmxJZzh4QWY2V1V6MzNIeHlPTVBIWnQ5YXJtYjNSOXBzWlMxNHRrNFMyS0V3bnVIMTRKM1hWenF2ZVBDMHFYN2pzOTlvTnRPamtubi9hbGV1ck96bFE3ZmZXYnV0Wld4ZWUzNnp2Z3JYNzYrK3RMdXBOaHUzbXZ1dmZmT09iKzd1MnNQUTZ4RCszMjF4Y1hGcjhxejl4UG9ZeWN2SkE4OStsMC92bkwxOG0vMmQ5LzRraEFvS2FVdnk1TExseStMT0k3OXovM2N6N0c5dlgyUWZIdnZvd1ljTFNCcng2cjdndzhjZitMSnMvTS9lSHhoNm9rMGpXZlNWcUtjOStSRlNla3NUa0djYXNaNXlia3pDNDlHVWp3Y0tSMnJPRVhtbFlpOW4rdG9NZGVkU1U3ZHM5UjUvOVppcTYrSGt6ZGVjLzcvZXowdm52WnY1VEJlU3VtZGM5Wjd6M3ZmKzE0KytjbFBIZ0xrMEg1djlzd3p6NkNVT2pqa1FnanR2ZWVkNy9yT3U2WTYyYnVUV0gzOHpvUjZiMjlQQ0NIY2hRc1grUGpIUHk0QTRaeVRqZWRJZ0F4b1BYNTY3dFNmZTl2Wkg3aHdiUGJQcGExNGFWSWJxWkxZazBSVWt4S2tJcmMxVGdta2RkalNrRVZhWjYyRVdFVW9xNGhtcCtqdlhFVW9TYXNWTVM1cy9Oa1hyaTZ1cm0wdFRra2w1ckwweGxaZTNBQ005OTQ2NTV3UXdwOCtmZHJ0VitBT0FYSm8zN0k5OU5CRC9QelAvL3dCUUFEZGVBRWVmZUlEMzdlMVZYVGppSjNtNE5mT09mcjlQci80aTc4b2hzT2hlUG5sbDNIT3FUczlSNnpsMU45NHo3bDN2TzNVd28rZVdKNTVTcmRiY1ZHVUtHOFo3K1dpTmlPU2JnSlNJS1hHTzQ4ZmxEQjBsS2JBVFJsMEswRm5YU2FqRWVESklzM2VzQlFmZnVZeTExWjNFSGlja3c4ZWE2ZmZzMXZWLzk1YVcrK0RCSERlZTFGVjFSOUtoTWpEWS9rL2gvMmpmL1NQbUV3bXpNek1pQ2IvVUFpaEFmbklZKzljVHJzTDcxbGJYY25YVjY4VkFUanNKKytzcjYrTHlXUWluWFA3Z0VvRmRJRFc5OTEvL0lFbnp5ejk5R0t2OWI3ZDRTUytkWDFkN0t6dkNlOEZzcFVpVWsxcGFrcHJFY2FSR28rWkdHbzBrOG9nckVGTGphc3JodHRiZE5zSnBmVjg3Tm1yWEZuWlJrcVFDaVN1bzRyeWU0NjBzck1OZ09QbUFwYTd1N3Q4Ny9kK0w0Y0FPYlJ2MmJ6M1BQVFFRK1I1emtIekxoeDI5YjQvOGFNUDV4WG5WbS9mdUxtemZjT0NrT0FQdXQvN3liajNQbW55amJhSExqQjEvdWowMjlJNHVtZG5Vckk5bUlpOHJrbW5XdWpaTnJRam9tNkdUeEpVcXBGSmhKYUtGdEJURGljczBzTjRzMC9kSDZFOGpDY1ZuM3poQnBkWHRvbGppWTRWU2d1aXlLTjhmZCtDRXQrZnhWRzNBWWtXUXNqUmFDUSs4cEdQSElaWWgvYXRXeFJGWkZrbXZQZENDSEhReUp1Ylg4N2l6dEVuakdISnVlcVdwNUtoSHhMQWNVY2lmMUNwYWlmUnRCYk16TGJUMlc0U1ArQWxjV210OXlEaVZvSklOS054eWEzdFB2bDRURHVXWkVxU2FFV3MyclE3WFZhMisyejBCeFNUSVJFU0xUUnBIUFBpalIxZXVMeUtsQjZ0TlVKSm5BV0g5OUxiT1BibCt4ZGk5WkViVlQwRVl1ZGNMWVN3WC96aUZ3OUsxSWNBT2JSdjJqNzk2VS96cFM5OWlicXU5M3NlR3RBUFBmbjlKNjN1Zm1DY0Y2SXFKcHZjd1p1NkF5QnhrNHhuNzc1NythNUhUeTM4aUJmaVpEdUp1dDBzT1ZkYmFNVWRzWmYzY2M2eE84alpISTd3M2pBVlN6bzZJcEtLVnBZeU8zY0VZeng2Tk9ETXNVWHluUUhHT2piMlJseGRIL0RHeXBEYU9ySlVvV0tGbEpMS1dZVHdJa3FrdDdVOVBaTmtUMjBZLzFwUmxCR2doQkRTR0dPWGxwWllYMTgvQk1paGZYUDI1Sk5QY3ZYcVZhNWV2WW9RUW5ydmxSQWk4dDVIaThmdVBxL1QzcWxpTWlwdFBlcnoxWndwM1FBa0F6cHZPemwvOGwxbmx2OVdFdW52VjJrVXhVb2doR1I2ZXA1Qjd0REZIa055SnRHRTJlbU11YWxaWXFVb1J3V1RjVWxWV2t4dHViMjJTVFdhb0NYMHB0b01KNGFYVnpaNDhkb093amhhaVVSSEFpbkExalhPV3JTV0lNQllwOVBJUGRtUzRwY0xtT3puSVRSRWdNTWM1TkIrVi9zcmYrV3Y4UERERHgvd3F4NTc3REhxdWhaYWE5RjB2YlhIeDhlT25Vam1GcGFmU3JKV3R5b21aamdZMUlDOG83T3VtN0NxZlh5cU5mY2RkeC81eVhZVWY5KzRzbEZaR1YrVU5TQ29peEl4Nk5OUmdxV3N3OTFIanpBNzFTVkpZNUlrSnMxU29rZ3pISTI1ZGZzYWRiVkhsa204OHR6WUd2RXJuNy9NaTVjM2NMVUREOFo3dlBlWXlsQVhoa2hKbEpLWTJnbm5FYjRxN3Uxb2VRUlFJdkMraEJCQ05PeGdvaWppZ3gvOElQL2tuL3lUUXc5eWFGOXRSNDhlWlhGeEVhMzFBVHYzRjM3aEYwUlpsaGhqeEIyOUQzWHE3TVhsaGFOM1B6UWM1NklvQ2pjY0QyempPZTVrNEdiVGFkVDdzdytlL2d0THMxTS9NRFkrVm5pOEZDSktZNndVM05qY3hJNXlUbmN6WkpLaWJNeGV0WXUzQmk4amZPMUlsVVMzRTJybmlGU0VzUERjNnh0OC9MVlZoZ0ltV1VRK3FVZzh6RGxQV1Zva0FoMUpwRkxVbGFXMkFtTThzYVkxMzJrZHZUbk1Yd1NpSnA4eTI5dmIrLzBRMytsMFdGeGM1TWlSSTZ5dXJoNEM1TkRnZ3gvOElNODg4d3kvK0l1L0tNYmpNVW9wQUxHenMwTkRLemtnRGlvcDlZWDczM2JCa0p5ZWpDcDJ0L2JLUVgvWDNoRmlLVUIzRXAzK3RTZnYvcE5uNTNvL1ByRytIU1VSMUlhaXNrZ01kVjdTSDQ4WTFCTVdsMDlqeGtNbXhZQ2tLMmxiaWJlTy90NkFXRXR3bGpLdkVWTHd3aHRiZkc0MFl2cFBuR1ZwcWNOa1dKUHY1cmlOQ2U3eUR2V3dRQmMxa1FDbkhNNTdQQkJwd1BzSTY0NkVTcGF2Z05oN2I2dXFRaW5sdlBmK0U1LzRoTDk4K1RKQ0NIL3MyREhxdXViSWtTTkVVY1N6eno1N0NKQS9qcGFtS1NkUG5oVFBQZmNjeGhqUnNIVDMreG43T1lVRzRpVE5rdU9uSDN4cXMxOTFoQkRlMkdxMXlQdWpPd0NpRVVMOXhHT25uN3IvMk14Zks2eVlxU2JXbHhZeExtcXN0U2p2MlpuazlQTWhUejU2bW1peGh4c1ZwSGdFRHJudmlxVENDQ2hMZzNQdzRyVXRYdXg2VG4vd0FiTFpERHhJSVZCU1VSZVd2YlVoNVU1TytlWU85ZFZkaWx0N09BTmFDWXp6dnJKT1JjS2QwRnExNjlvNEFkYUhVclp5Z1Ixc2I5Kys3VlpYVjUyVWtsT25UdEhwZFB6UzBoTDMzWGZmSVVEK3VOckhQdll4Qm9NQlZWWHREeXJkeWRLVmhMNUI1TDNYZDk5OVlWWmtDeGQyVnd2VmFTV2dJcUYwTE8rc1lPa29VaTBkblo3MFI4ZUd0Y01rcWJCT29LUUdCS1gxck8zMWVlVGNBcWRtcDZncmc1WUN2S01vYXNZV3BsSkpGRkpvbE5aOFpYT1g2NmN6anIvek9IRVdZV29YL2tBUHdqcDBJcGc3MlVPY25NSSt0RWl4WFpDL3Vjdms5VzNHbDlhcDkwcTh0MG9iYzZ3VlJUUDkybGdQcHZuLzI2ZkdHKzk5N1p3elFnaDc1Y29WbnlTSjI5dmI0NDAzM3ZCU1NvNGRPOGJKa3lkNSt1bW5Ed0h5eDhIZStjNTM4dlRUVHlOQ1pyNmZRNmc0amVYajcveXJaNnV5dHM5KzVuOWZvYUdpSHpsKzkzRXJrb1d5R3BBbU1jWXdJMlhVdXZNMVRWWDVOL2NtcjgxRnJWdFN1Rk1tTnd4THg4U0FpakxXdHZjNGQ2VExoWk9MZUd1UjNpRThlQ0dSUW1LcUdpdEFTRUVrSmE5dURyaDFJbVg1SFVleEJuenBrRktBQU9kQmlzQ1pSNEozRHVjODJVeEMrMjNMMVBmTU1YenNDTDNWSWNYMUhWRnYxb3R1M0YrKzU5UmkvSUhINzduM1N5OWNYWDMyelpWYk5IUjQ3MzBCVk41NzQ1d3pSVkhZNjlldk81cEpScVdVYjdWYXZQdmQ3K2JlZSsvbDUzN3U1dzRCOGtmZDJ1MjJtRXdtKzBSQ0RlZ2YvV3QvYnlxS2x2L0dsVGN1ZndaWWJ3Q2lPelBIVDR3TFAxWFh4a3VCeUxLa0ZhZHAzTHpVUWRQdDJkWCsxZnZuV3EvTVJmSlVIQ204clJpTngyenQ5Um1OUzZKakxWNjZkSXM0VVN6TjllaE5keWlOcFN3TmtmZjRLRUpxeGViT2dEY1RUL3JnQXM0Q3RjUDd0LzRnVjF1c0ZLaEVvUkZ2RlpxbHdOUU9wNkZ6OXpUSlBkTkM1MGRwNy9oalB5dzdQLzdRc1lWNGNXNzIyT29IN3IveCtSY3UvK2EvLzhqem4zbjF4dFp0SUJWQ2xPQkw3MzNwdmErRkVJWXdxZWkydHJaY3Y5L24vdnZ2eHpubkR6M0lIM0Y3K2VXWFJWbVcrOTRqQXBFSUtlVHlrYnZlT3pOei9CM1BmK0dUSHdWYTN2c29qcVB1OHVtSDdoOFZwdTJjeHpwUG5MWlVrbllpM21vVVdrRGQzQjcwYi9XbnZ0UnFSKytkaWtRMjEwMUVDY2lvUkdLNXViNUhyQVh0VkRHb1N1YUdZM3J0RENVVWlaVEVXVUovbFBQOGFJSis2Z2k2azRFUWxNNGduRWNyZ1hVMjBFbTBST0RBQzR6MUNBbENoVGNUZFNWZEZYRTY3WEQrNkF4MzNkZWRUcXg0WHo0Y014N3YwY2s0OWU1SFR6NTgxL0hwNzN6KzB2cm5mdmtUTDMvMDB1MmRWY0tnVlFtVTN2dXlDY1BNZUR5MmdIMzIyV2Y1M09jK3QzOHBIQUxrajZydDdlMGhwV3htTkVRRVBubjh5ZTllV0Q1MnowOE5CMk8xdG5xaklQQ280aVJwZDBVeWZiYXlhQ0VFVWdxOElGVktaUnhrQk40QnRYZXVlbmxuOHR6Snp2UXRPU3pQSlZtRXFHdnkwUVNzWlZEQzNwNUJMMlVjZi9zQzJ3Sk9YSzlZTmhLZGFLcks4TXBrUlBYdW95U0w3WUEvTDZpTlE4Y1NMVDFLQ1VTRFN3ZTRacUFLb0xDRzJUamxvZlljRjFyVEhJOVNYRjR3NkkrNDNaK3d1emNBNStuMU9zek9MM1puNWhlZk9uZm14TU1QbkR2MnRoY3VyWDdtNWF0cnozMzhpMjljTFl3Yk5ONXpIeXcxWUlxaXNNMWx3QjNlOHhBZ2YxVHM4Y2NmNTlsbm4wVktLWnh6S2lUaVpGS3ErTkczZis5M0VVODl1RHZhZnRQWVluOTJJMW8rZHJibmhXekhrU0pOTlVvSVZCTEpPTkw3aWIxdkRvMER6TE0zdHErKzc5VDhjMTF0N3dKa0tvU2dya21sd09JWmUwZnIvQXh1UHFWT05CdFpUZnJpbUN5SHRkMGhXeGM2cElzZFhHRXdDa2E1SVJLZ0F6QVBqcVZTZ2tRcnZQZE1Lb1Awa3NkN1N6emVtdUZrbERJWmpuaDliWjNOelIyc3RTd3V6bkR1bmhPa1dadXFNdFMxeFNOSVo5cXRkejU1L3QxUFBuYnZFNnRydTdlLzgyMzNmT0xwcjF6L2pROS8vdExybzZMcU4wQXA3Z1JLOCtYL29FR2lEby93dDllT0hUdEdVUlFpei9NbXRBcWNxUWNlZlBMa1ErLzZrYisxbFl1emtmSjJlK1h5VjFadXZyd0ZSUGM5K2gxblpvOC8vQjJqMGsrWHhqVVp2YmNyMTE3NDFQckthMitDcUFpejRFNkFkTjZMWHJ0Vm4rckZqMHZwcDdSV3ZxeXRxQ3BEcEJUdCsyWTU4c2dTY2FMUVVxSzZLZm00UXEzbjNENlJvdTVid0U4czFudlFpaWlTUkJGZ1BNcUdSTjFMMFlSYkh1ODh5Mm1MOTgrZTRqM1RwMGdyZVAzS0xWNi9mSlBkM1NHek0yM3VPbk9FcFNQTHRLZW15ZHBkQkE1VGxuaG5SWkpvcEpEZ25XNm5ldWJZZlBmK1U0dlREeC9wSmlkTWFhclZ2WEhmQnc3WG5Vb3JYMnUvM2E4ZmVwQS9MUFlidi9FYi9NelAvTXgreDN5L2NoVUIrajNmL1NQdjZsZlJnMnZEQWZlZG5GcTQ2L3dqRHozNzJWOTh3M3ZubkdqTlRrcmZHUlUxQ0U5UldmQmVRendIVGJRVCtuTFdReVhBZlBicTJndjM5RTU4NW1STC9YQnVqR3JGRVJyRnNLZUk3bC9BWnBxNjh0amNnTERvcVlpSkhwQmRPSWFNTlhWdHdyaXRGbUFkYm1Md2VMU1dxRWlnSTBWZUdYckV2R1B4RkJmVEhuRnB1WEgxSmxldXIrQk16dEhsR1U0Y1g2TFg2NkYxakpjeFNrZm9TSk9rQ1RxS0tjWmp4djBoazFFdWh1T0N6YTJCSDQ2cjJOVDIzRjNMN2JNTDc3bjdxWXNuWnY3YlI1NjcvajlXK3BPVjV2UEttODl1WHlCaTMzdjZRNEQ4SWJmbDVXV2VlZWFaZzg0M0VCMC9mbnFPMXRHM3J3M0s3ckEwZm1KRXRIenkzTnVYajExNFp2WFd5NnQxVmFyeE1DZXZGWEVyQ1JtNWRYZ24ycUZqRVpLUTVxRFVDTXArWHVYUHJBMC9sQjdwM2gyYituRnBIYlcxVE03T1VYWlNUQTdPK2NEL2ttQ1RDSDNYRkhHaWNNWWlZZ0hPNGZCbzVWRWRqZFFDNHdFcGNjSnhwamZOOXl4ZTVKaHNjZjNxVlY1ODZVM0drNXlUeDJlNTY4eHBlbE5UcEswT1FtaUVsamdYUWpUdkRkN1hEUGYyMk43WTRmYktEamR1YlpQbk5XbWtSUndwRUFJcHBacnVKWGM5ZGQveTN6eDlmT3J4Mjd2algvdjhxK3VmKzhxVmpUVWdFcEQ3a0tOVVRjamx2dDFBT1FUSXQ5bU1NWUxBWk4wdjc2cjczdmI5ZHhzMTlXQlJPbXJyR0U5S2YvYm9xYnZQWFhqaWdkVmJMMitOSjBNeEd1VjJVa2RZSU8wa09BUW92ZDl3dXpPOGNONWpBUHZNOWMzckM0bjgxY2NYV21mS2JqUzN0cFF4V2U2Z0sxQ3BSR2tKSG5Ta01ONVRUcVZvWTlFMmVJcElDV0lGcm9Ra1ZzaElnZ2toMWhuZDV0M3hBdHpjNEpOWGJ6TWU3TkhwZG5uMDhRYzRjdlFJM2hRb3JSRlNZYXduaWR0Z0tpYkRIWFkzdDFtNXZjSEt5ZzRiRzMzNm81SnVLMko1UG1XNms2SWpSWnBseEdsTEtBazRuejBTeVhlTkovVUQ3N2g0OHZQLzRhTXYvZnVQdm5EOUt6N2tiOXA3WkpQTTEvdWZ3YmNMSkljQStUYmJoejcwSWErVXVwTjlHMDB0blRsWGkzU2hORU84ZGFJb0twK2tVK21adXg1NDVPbmZqSjhWSXU1NVJPWTgxS1hCdHhOVWtvb283WFNGVUJLYy9KcjRPeHdPNzNsdW1GL2o0dXlhV2NqbTZ1bVVSRWtpS1pBSWZKTm83OWZCU2ltb2NrTWFTUkl2bVU2VDBBalVualRWT0FsS1NPNnhNUSs2TnFOcmE3ejQ2aTJpUlBISUl4YzRjZllpblpsRnZDc3c1UVFwSmM1WjRrU0RFS3l2clBMbWE1ZTVjbjJkZm45SU40czRjWHlXaDJlNmROc1JjYVJSVWlHRUlFNHpvcXlITVI1VDEySTBHUG9rS2FmTzM1WDlpYi80QVhmeTdpTlR2L1JyWDc3Kzhhc2IvYld2dVNTcWIyZnlmZ2lRYjZOOTRBTWYrTnFFVWtvcGRiZlRPNmJqT0xQV2VsTTdVUlMxeUN2RDhvbHpGNlpuaml6WFZhM3JzcEpDUmpnODFscVBTR2ozRm85R1VSWlgxWGlmUmlYdnlHMlVUblhVZldUeEhac0w2VmxwUFZsaDBWb2oyUzhWQjVBNDd5bU1DenFKRTRQdFJEanA2VHBQbWtoYTdRU3BKTUxEQTFYS2tTR3NiKzJ3c2RYbjFPbEZMajd3QVBQSDdrYW9CTzhMWEpXamxFWW9qUzBMZGpaMmVQM1YxMW03dGNyTzNnQWRDeDY4ZUlMalIrYnBUVStoZEl5cERVckdDS21veXhKbkxWVnRLZklLSFdYRWFWYzRJckpXeW9XTHljV1pxZmJ4a3dzelQvemFzNWYveFNkZnZmWHluUjYwQVlZN0JNZ2ZYdHYzSUhKNmVpNXVwMW0zOU9Cc2VKN2owckkxeUptZVhabzZldUtoZS9kR3U1dldtb25EdGUzRVVyZGlQRTZndTBlMGJuZXFhclI3UjA2elAxR296N3p2NUZQVEozcC8ydlNyckxZZXBSUzI1ZEZlNEwxQUtoRXltT1lrMWM0alNvK0tIVlpKOWlZR2p3WXBpQ1U4cGxvYzM2dTRjWE9YU1ZGeS80TjNjYy9GQjRteUdZU0t3WlRnSFY1cXdGQVZGVmZmdU1MbE42NHhHZzNKRW5qby9oUE16YzJRcFRGS1JhZ293bnVCMGhGS1JsUlZqWEdLOFNnSENaRldhQzJvU2t1cjJ5UEpNb3JDMEp1ZTZWMjhKL3F1V0tuRmRwTDhyeDk1OGVvWHJYVjM1aUQ3WldCL0NKQS96RWlSU3VhMWs4NDZoQWljcHVHa1pHZFkwRWw3K3NROWo5eDk4emYvM1Mxbmk2R3oyWUlEcEpKWTU0Vk91bk5SM0psanNuNjdhVGI2cHNxVG5IaDgrZTdGODNNL1puTTNYNWZHZ3hET2VVcnJ3WHE4QmVFOVVSUk9sQkFDSVR6V2VKd0RUMGpJSjdYSFl1bDV3YUwwN0d6MktZc0o5MTQ0dzcwUFBnb3lDenpnZW9LdkszUWNZNjFoYjNPVnJiVU5kblozNmZZVTgwdEhPSGw4bVpucFdVYWpDZmxnRjZFTVdrWW9CZmx3VEY0TktFdUxjUkloSTR5eFNHbXB5cHlxQ0Y3RmxtT2NxWEhlVStaR1JzZ0hIenMyOTMveWRmMy8rcldYYnp6TmJ4WFYvbjMxSkljQStZTTJxVkZheVVnSmxBaUhzcW9NdTZPUzZVNHRsMDllUEl2M1h6TGxjRUl5elZRdm85ZE5SRms1Wk56cHhkblVOSHNvUWpOTkFwRlVvblg2N1VjL3FCTjlmcmd6eGxrdnBKSjRCNloyU09QQU9KQWdwUXdOUHlFUVVsQjRNTG5CdGpUT1EyMUN3ajR0STlJS2RxMmxPNVZ3OHU2NzBIRUw1d1ZDV0lTT3NhNW1mZVUybTdldVV3ejM4QUtXVHh4bGJ2azRhUlNqQk9TalBuR1NFYytuT09jd2RVMlJHNnBhVWRjVzY0TlRzNmJBVkJaYmd4U09NcS9ZeTJzMk52cXNyTzJ3dGpObWFDd0Q3NlVUL29HcGhlUzdJeTFmcW8zYnIrYnRnK0liOFNTLzVmZU9UOFVjbjRyNS9JM1JJVUQrLzJDK21TZHkxbGJXTzFzTDd4SEdJcHpIQytnUFN6YVRDZTMyM056Qzh2bWpwaHpzcFIzbGp5OTF4ZnhNaXlzcmZSKzEybWwzN3VTeHpkVXZ4ODFEVm9BKy92anl1V2dxZVh2VnI1WEpEYloyT05lY0Erdncxb2VlaHBKSUpZa2poY0hoNnNESXJjZUd0R01nVnBUVzQyckxFWlhSRWhKVDE3UjdHVkVVWWZJOWROSUdGTUpPdVBuR2E5eThjcDBraHU3c0FrZk8za3QzNFFUS1c4cmhOdVZraEswclZCUlJHeWlMQ21NOHhYZ1NjaUducUNxTGN6VmFoczc5M3M2UUs5ZFh1YkhlNStidWtPMjZaSnhLeEh3YjM4dkloUkJ1VW90cXk3NXQ1c3owZzV0djdqenJQZTdPSytockFQTzF3UEJmNytmcFRQTlBmdkEwVC96VGx3NEI4Z2RsZi8zdi9Vdit4Zi9qcnhMQTRSM2cranViK2Q3dXpzM1p0cW5UUk92S1ZFam5LZk9Ld1RBbm0yMjNUcDE3OHZTVk4xOWN6K2J1THdTa2laYWlxaTFSSENkelI4N2ZkK1VsK2JIUVJBY1Z5V2pwdnZsM0tLbU8yN3JFR1llM0RxVmsrRm1BaWlSYVNaUVVZUzJDRGZsSElNa0tiR1hKUnpXZDZRVHJ3VmpQREpvNkw2bHF5MXlhaENUZkc3d3BFRW96MnQxazNOOWh1aGVUVE05dzVyN0hTZElleUF4YmoxRTZJV2xIQ0tHb2lwd3l6eW1Ma3JJd1RXcnRxTXNLVTlhTUJnVnJPMzB1Yisxd2FiZlBwclRrN1FoeGJCcVZ4aEFyaEFEbElLc2RMb3NRU3A1ZFV1S25WS3oreGRxclc4OTQ1L2Q3VFNWZlRVdTUwL2FCWkwrbWgrSnU3cFgrZS8vMzEveGhpUFVINnpnNC8vQjd4QnN2UHUyYlc4NTQ3K3RiMTE3K1NtdnUzSHFXeE1lTDBsRFdGdTlnbkZma1pTYW1Gaytmc0M5L2RsVzRhandZVjlucEVJNEpRRTNQSFRrVHg1M1pxaHA0Z09NUEw1N3BMcmJmai9HcExTeldPWkpXakk0VXpucHNhYWx5ZzQ0VU9wSjQ0ekFUaTNVZXFRVkNDRlNrS0VlR1BLOFJTaEtoNlhsTmY3aUhNWTRrUzRtUzl2N2lCVXc1WVhOOUEyc3FrbmJHMGJ2dUpVbGJlRmMxOTdKSHhoblNTNFJPcWVvMXZNOXh4bEJNQ3FSU0NHL1pXTjNoamR1YlhITUZ0NlJoZDFwUkxjL2lZNFh5b1NYcXZVZjZrRDg1QVRKV0NBbkpkSVpROGxFaHhFL3Jkdkx2VnA1Zi9aaXRiRXpnY0ptZ29PTHZxSklJUERqdzFuc3NiL0c3RE9BR2hiMnpPKzhQQWZJSEVsZkZMSis4eU90dkFjUUM1czJYUG4zbCtMMGZ1SlJraThlekpLSTJqc29ZOHR5VDV5WGRxYVdsaGVXenM4VmtmYmMwODNPRGNRVWdqUE4wcDZZWE90M0ZZenZiZ3dLQm5ENDU5WkRVK3R4a3U4QVdCcTBVV1M5RlpSRXkwWmpLc25Xcmo3V1c1WFB6ek15MlFBbVVGczJ1S3BCS1VFNGN3KzJTYkQ1Qk9JY3lzRGNvOE42SEVxNjNDQm5oaGFUc0R4bjE5MGl6bUtUVG9UTTlIeHhrblZQbld5QTFNcDNDbUpweVBNUTVqM09DcWpSRVdqTHNUM2psalJ1OG1BOVltNHVaVEtXSUxDYjJBbEVaYkdteGxjRkdDdEVRTG1YRHNISE80eXNIRWhGM1lyRHQ4ODd4VXp6ZzNLM25Wai9oblc4QmxSYllKRkpvS1VSUk8yK2M5MUlLV3hsLzhCd2dUQnA3cVB3ZFlMa3owVDhFeUxjVklKS3FySHljdEVTWmovWTczbWI5MXFYTndmYU5MODZmWEh5SGpsVG1yUTlGZmUvSng0V2ZhazFIQzBmT0xLOXNyTzlhNCt6NlhxR0x5aUtWSW0yM1c2M083TkxPTm10VHk1MnB6bEw3ZlhtL1RFZGJPWDVjRTJVSlVTY2xua3JRYVlSUWtuUzZ4Y2JyRzd6eDJXc3NuSm5qekgzTEpFbUV6MnRrNVpqa0ZYVnBHVzJWeUo0bWlSUTRpQ0tGdFo2eUtQRzJ3bG1MakZMeXdxQzB3SGxCZDNvYXBTVDRDSzlxaEsvQUcxd3BxY3VhS3M4cHhtTW00ekhqVWM3bGErdDhaWGVIMjNPS3llbnBBQUxyRVQ0VUZiUlNxQWpNdUVaTFR5M2xRZTlHTkMxMEdRZDZEQXBVSnlLejZUSGdKK3ZTS25kdDk4WDdGck9qcDJmU2M3MU1INDJVU01lbDNhaU4zOHRpb2ZjS2MyVjFXTisrUFNnM1hsM1BOMzJvQWxhTjU5a1B6dzc2SzRjQStUYmI2MS81RkVMSS9mS2phUjVHL1pYUC9zTEgzemwvOXIyUzd0c2xIaWtRRWtGWld6RXVLbWFQM25OaTVmYVY1NDBwekxpSXRQTWVaeXhKbktRejgzUEhjdDlXVTBlbkh4dnZWQmU5QVZkNWhOSkV2UXl5Q0t2RDdTc2xaTDJFa3c4ZVpmMjFkYTU5K1RvMnJ6bi8rR2x3WUszSDFvNjZNaFM1ZzIxTk1xL0pEVmdIUWltVWxOUkZqdFF4ZU1sa05NS1ptc3BLMHQ0MHJod2g0aWxrMmlIU0dsdE9LRWQ5NnJ4Z1BCZ3hHZVhjdXJiT2E3ZlhlVW5uRE8rZndtY0oyb0N5RHVORHNjQkpFZDZURk5DTjBkN2p2YVB3SHVrOHpmUXZYZ3FVVmpqcmtCcVM2UlFaNmJOT2lwODRQNXVzdkt1akh0U1JiRWN5ZlBEQzQ1WEhSN0ZFUTFWN045Z3U3S1hiZy9MVFg3Z3gvT1JucncydjhkVWFjUWRsNDBPNis3ZlJudnZNZjZFN3M4VGUxcTA3bG5BaVFlamg3bXJSN3N4WDg4djNQSUtVN2NxNC9aa2twSVEwYlVWNWYzTmtpV1NjVFhXc3RUaWdreVZpWEx3MHIyZjJua3BtdXc5N0llTW9paEJhb1ZvSjBVeUs3c1RvUktPa1FNbnd2TDBTcE5NdGJHVzUvZG9LK2FRbW0ycmhha3RWV0lxaXBzb05abUtRdlpoejdTN1RsYU1vYzdxOWpLbXBIbkhhQlNsWXYzMmJjalFnNlUxeDVPZ3lRaWFJdUJYQ0xDSHh0Z1FYOHFyQjdoNHZ2M2lWanp6M010ZlBKTmlMOHdpdDhDYXMyaEZlNG56VGx5RjRDdWQ5VXhSb09qMTR0QXkvTHp6Z0hmc2pYT0ZqRGNnUldzNktTSjA2N213YVd5L3JRQllJWW5ZQzVZUVFTb280a3FMVGlmWHBJOTM0aWRQZDVKNmxkalIrZFR1L2JkMUJlR1VQQWZJSFpPUEIxbHVKNGxzb0VRZ1I3VzFkM3o1NjZrSm5ldUg0dzJWWnk2cXk0Y0VMaU9OWUtPRVlEM2RHU2UvSWRGSFZRa2hKSklVYUY1ZG1UR2VuRTZXSlNOSTRDRWdqaUdKTk5KTVN0VFN5T1ZDcU9XRGVlYndVZE9jNzJNcHk0NVdiR09OUU9xYWNWSlNUaXFxc0tBWUZWbm5PSDV2bmpFN1pHd3hwdFJJV2x4ZVFPc0lZeDNpd1RWMU1tRmxjWkdieEdDS1pBbS94MVFoc3RUL0V6bmc0NUpPZmVvRVBQLzhLN3NsRldoZm1jYzdoYktpZ09Sc1VHcVVRRFhzLzVOWGVlN1FRQjVSbEpVQ0tvTXJJUWRMdURwWTFnc2Q1VUZwU1JoSDkydE15aGtRMGNrck5oK29kd2d1UGNVMHVVM3VGNVZTTXVHK3BvMWRlMlN5dU43bklRY0orQ0pBL0lJdmlUSGc4M3J2bW9RbFpsMk9mWlVuLzFGMFBQaUJGdWxoVXRiZldDZS9DdkhjcmE4ZmovbmFKYnFXMUZVckhpbGg2QnZtTCtIVGJ4MGtzVktTb2ZWQWRpZG9SZWpwQmFnRitud0RXeE81Q29GWDR0YzVzaDNLUXMzTnJPM2lQVVVrMUtoanRqZGk5c2MzZzlwRGpkODl6SVcyUmp3dTYzUllMaXdzSUJQMytnTHkvQTk2d2VHU1JPT3ZpNndsNGg2dEhDS254cGdSdmVlSExyL0tmUHZVczJYY2VZL21obzNnYkJPYk13YlZPNHozOFFhVUpQTEw1RWdUNnJ1QXRGUlhYcUZFZUtJazV2MTljQzZWZ0pkbXhzRjVZNXZHMEFPczlWb1R2KzFlVTkxQ1ZUdXdPYTE5VmRxWWRTVGwyN3ZOcm8zclVBTVFDN2hBZ2YwQzJjT1FDZFRVbUxGOTZTNWw5Yy9YTnlha3o1MWxjUHYxWVlYeFNWS2JCRDdRN0xlSEtrYk1JS2FJc3N0NmpKQmg1Q1pIdENKM0dvQlZlU21RM0psMXMwZTJsSkVxRVhvaXg3TzlKY0tVOXVJMmpSQkZIRWNYdWhQNW1uK0hXZ09IT2lQSEdDTE5iVXEwWEdDMTQ2T2cwdW5hMHV5a3o4ek1vcVJpUFIxU1RFVlZ0V0RpeWlKU0FNd2lWSUlUQU80dkpoMnl2cnZHUno3NUEvV0NQRTQ4ZHBUSVZEa0ZsSE1KNWxBOUNkQ0JDaDZqeEhITGZTK0FEUkh6ai9VU0RDaEZ5RWQvb0E5T1VneFZ2aFdtUmxneVJiQm5McksxSm5NTTFiT1pRbVFvejk4UGNNQzZ0YUd0Rkw0MkdHMFg5aVRkM3loM2VHc282OUNEZlRydnJlMDRSZDJMeW5ZS3NQVTFSN0dLTkVXOEZ6a2p2dmN4SE83c256ejZ3bUhSbTc2cHFwMnd6ZGE2VkZGa1NxVHpQbmRjQklNSmJySDREMmVzalpDQVc2bGlSZG1PeWJrS2lGVGlMc3c3cVpseFhDWndQNGd0SXNGNWdDMHM5cnBnTXhneDN4NWpjNEUxencyb1lEeWJjZlhTYW83MFdEbGhZbUEzU3BHV0ZyVXVrZEN3Y1BZS09NMlRVUWVnRW9RVE8xT0FNbi8vQ3k3eWlkamo3M2lQZ0hYbHRtUlNPdW5iWU1JVkZwTlZCcU9XY2I4YkFnbWZCT1JCdjVSMmlHUk1UZnAvNUtaQkNOc0FKVEFIbkhMVzNHR2RRRW1xVlVwdVVTUitHZVVtbVBJcWd5RkxWamtscGlZUmdxUjBqTkplZjJ4cDk3TVpldmRjQXhBRHVzSXIxYmJKejd6N0dyYWRYT1BhKzQyeGYycVhTSzNqcXQ2Nnh0eGlvOXZxYkwreDg4WlAvOGIvZS8rNi9kckdWcE9lTWN4anJtQlFWdlNUUlFtaVVFdDRhSWJ6TElSNmpVMFZWaHRzM2lpVXFVMGdOUlZraHJRUHJzUTBaWGdwQjFIU2pVUXBiV0NiYlk1U1NKSzJZVmlmQzFCWmpRMXdmeFFwaXh4ZXVyWFB2NGd4bVZESWNsMHgxVXB5emVDK2FHL3dndVVKRUdhNGVvNktFd2M0dTErd2VKOTQ1UnhJNWpJRUlTU1FkS0VucFBJTkpqWEFXSVJTK21YSU1vblllSVR4ZU5oR1VvS2x1N1dmc0h1dGRZQkU3ajVZUnJiaEZKKzdRaWpLNmNaZE1Ka3hIWFJhek9WS1Rzbk56azJ0dnZNcm5udnNreDVPY0V6TVoxamlVZy9sMlJDdFdqQXEzY1hXM0d2RTE1TWREZ0h3YnJMT1EwWnBKYUMyMTJIeHBXN2phTXJ3OUV0NTkxVWFvL1M4aGhOQXZmK25EdDNvTDkvejZxZnUvWjluWXFEZXBMSGx1a0ZaS0hXV2FTSU9VbU1sdDVQUUFLUlU2RWRRV2lEVXlrc2o5QTlYa3JsSUlGTTBOTFlKMkxoNnFRVWs5THZFQ0lxVm90UkxxdXNaWWgxQ1NKSTVwdFZPdVQ4cmkxYzNCNFA2WjF1ejI3bEJQVC9kQ2lLUTFXWnFHTXlRa1FpbUVTcEFvcUxaNC9mSVZ6Q25QOUd4R1diNFZEaWtCVWt1VWcxSTZDdXZ3WG9ZZVI1TWpoTVJESWl5TlZ3a1ZLdXN0dGtuTU8zR2JrKzBsenM2ZjRlVFVjWTcxbHVna2JTS2RFQ21OUkZJVkpYVlZVMVVWMjJtSFZxVFozaHZ4OURPZjR0NUJ5WVBMSGVaYUNkMUVvYVV3ZzhwZXVkMnZoM2ZrSDRjQStmMjJIL3UvUE1vekg3bkoxazdCN1plMnhXZ3JweGhXSWQ4VVNQeGJjK2tJWW54WW1SWjJERnErK0xGLzlYU25PM2QwOXVRVDMxOVVlWXdlNGhLSXZKY3FsWmhjWU1TYnRCY3NCb1Ywb0kxSHBZSWtFZ2puc2RhSElSRWxRbUcvWVVuNmhnM21qS1BZblNDMHdOY2g1bGRhNHdBVkM1SWtKa2xqc2s3cVhPMi84TXdYYjN6NTlMdlAvb1d0emQzbG84Y1dpYUtJT0ExSHgxbUxkNkcwaXdnY3dkMk5iVzdrRzNUUFpwamFZNTNDNFNCMEpERE9NYkVocDNBT25EY2M0TUFkVlBzUVRkUERZbERPMDJ0MVdXNHZjMkhoSE9jWHozR3NzMFJIdHhCU2toY1Q4c2tZYVQxU1MycFRZMXlOY1ZYSStacHkzdm16WjlqYTN1SkxMejNMWGRNcDk4eTFmQ3dGZzlvKzl4czNCcC93L2tBVTRyQ1QvdnRwY2FxYXVEbzgzNzNiWTRSQU9PUEVBU2pDdVkyRkVMSDNQc0dqRVNSeE8rck5uWjA2TlgrMGU4LzBrZXhrTlBjYk05SENqcDJkbVlEc281VEI1bENYRWFwMnhQRXE5VnBOclFWNk9pVktOSzFNMDBrMFZXa3BtdVFtaUZFTG5QV1kvWXFSZzJwVVl5WVZVa21VbEVpdHdxNUJLWkJhMFVvVEg2Y1JrVmJYVjkvYy91WHJ0MFkzTHg3dkxiNjlIZi9RN3M0ZzdiUmluS3VveWhwVEczUmRvaElIM2lCc3dhV3IxOWxzajVoclRWRldCSmtnTDVCZW9FUTRnUTZQSTRCQXVsQmxDemlUQ0FteGxuam5jYzZ5MUZuZ3dZVUhlR0R4Zm81UEhhY2J0UkVJbkhkVWRZVjNqcXFxTUhXTk5RWmpMZFlhNnJKaTJCL1EzOXVsdjd2SDV1WW13OG1JazBlUHNyNTVEQ0VuUHRIQ2o0MTc4N01ybzMvNXFldURONXVRdDc3RGd4d0M1UGRxV1NmQ0JIRi9mdjAvdkNFR3V5WGVlZW04My9jWWNmT1ZFUFprSkszNXJIUGtnZG16Unk3TVByUjRjdXJSNlpuc2JCeXJCU1ZFS2lBeTltV1YrUkJpVkpYSHlERHkwT281bERUa2U0WjZVRkJHSS9Sc3d0UzVlVnBUTWFZdWlJUUlnbS9PSTV1U3FyT2dHbm5iWW1lQ3N3YVV3QnNMQXFKWUk1MGlUalJwRm9zbzBjUCsrdVEvYjF6WmU4Rjd6My85MU9YL2ZHU2hON093dFB2ZFdzMUtXK1RDMnlwY3M4NWd5MzZROUJuc2NtVnJGWDBoQ3ZQdnNnRmgwOStRUW9SOFNFcnFVTGJDR29lMG9jcWtJbEJTRUV1TGxEVjNMNTNqVDEvOFN4eFBqbUtyQ21zTnhoanF1a0lJTU1iZ25hY3VDMGJERWVQUm1McXVxYXVLc2lpb3lweTZyaWpMOE8vclNKR2tLUStkdThBSmNjMlBUWEhsMTY4Ti91blB2N1QxakFoOHJJSzMrRmlIQVBtOW10YUNrK2VudWZwU1dJQ3pmbXNrOEY1NmY2Qi90Yjk1TmdIU3hZc3ppeWNmVzN4bytkN3A5eTZjbUhxOGs4YUx3b25FR3lkVUNJdThzd0JTT0JlNHAwR1IzU08xUWxxTGlrR25IajFSRkxzVEp0dGpibS9sbUFlWGlHWXlsQlFZNjRLZXI5Z3ZwWHFjY05SalF6MHBRWW1tSkJ0bVJMeVVSRUtRcGhGeEd0V1RRZm5MdDEvZS9GWHYvUkJ3MTFiNmUvLzZ2Ny80TDRUU3JYZGwyVHVsUTJNdFJaNGprTWhpVEV0S3R0WTNXQm50MEV2YkdPdXh6YVk0aVNWUjRtQ1ZRbENLRHdtWkR3T1BvWHZ1UEVwTGtoZ1dPdlA4eVlmL0hCZm5IeUFmRHBpTWgweUdnOER3ZFo2NnJoZ05odlIzKzJ4dGJGRlhOWFZkb2JTZzFXcGpqS0dxRFBta1lETE9HUTlIVENZNWRWa1RSeGtqTWJ2KzdMWFgvby8vOE9MV2x3bkFLUGhxelMwT0FmSjd0S1NiY3ZtRmJmQUk3NUFlcnc2OGhnajVCWjZrTlpmT1B2UkRkNzE5NmVMTUQwd3ZaSTkyVzFGWDFsSUtKTjY3Z3lrL2hSZWhNaE5HWU4xK0I0eW05azlvWk1SdGphbENCNXpTa2U5TXVQbk1UV2JPTDlCZTZtSWJVdDkrZWRRMVJPOXlXR0NkeFN1SnJ5eFNDclJXT0E4NlZzUkpaS3ZTZm5iMTB2WXZGS05xcXprMEZsQ3ZYdHUrOU44Kzhkci8ybXNua3d0M0gvMkFxM1d5dFQxaWNRNWEzUjZ1SExDMXZrTGZHNlpWV0s5UTFBTHZRamsyZEx0RG1kVzdadWNJd2F1VUZ1cks0S1dtaFNhSk5PKzg1M3U0c1BRb2VJL1NncnJLeWZNeEhpanprcldWTlhhMnRxbXJpamlOU1ZzcGtkV1VlY25PMWk1RlhsS1ZCYzdaMExHM2dXOENudHBaTHRldDBYUDk5UFlkWVZYOXRRbjZJVUMrUld0MUkxemhxUXVEczE0R29xblhkM2lOREU4bXRXaGZmTytKOHcvL3FiditiREtYdmtlbmFrRjVEMVo0NXdWZStERFk1QnFtbkpRSG1XcHR3cTBhYVVrcVkzU3EyUFU1ZzhxaEZDU0pKdGVLT2c4Tk5GdGFScGUzOGNhVExQVlFlS3l4R09lQTBQZW9Cam15OFI2bUlmN0pTSUh6WVg3RSswdmJOL3IvYXZmMjhCb3dKbXlwdFUyMXJmN004N2RlRytiMVAvN0pIM3BpNTY3anMzOTZ0ejlwOXpxUlQxcEcxR1hOeXVvbUkydHdBb3dUQiszdWZROUJRMTAzRHFyUzRjcWdTVzFLU3o2cEVRSktBYjNab3p4eS9EMUVRdUpjaWFOQ1NzOTRNbVo5ZFlPOW5SMU1YZFB0ZGVsTmRaaE1Ddkp4VGxYVWxFV0pNUVpURzZxeXd1SVlsaE4yOGoxMngzMUcxWVJ4bFdOcmMxSzB4RjFheU9lTlB4Qi9PSndIK2IxYW1ta2Vlc2NDWC96NEdxN2lUbkRzNXhsdElMMzNiWXVuSC8yQnUvN1VzZk96ZjBLMTQxTjE1WlNyUXgvQU9pOUVvMVZWR0lkczZyTFdPSVFMTE5wOVRvUTFucnEyUkEyVllxYWJVWXdyaks2SkVrVTVsbmhqd2poR2FaamNHakI2OHlqWm5LWjFjaDFyZzVwaTJjK3h4aExXU1RWK1NRaWtsbUhXUW9uKzd1M2hmN3o5OHVhWEcyQ01lWXYrTFp2di9vVkw2OWYvMGIvOXpQL25yLy93RTVNSHpzNytoWTN0VVRmT01uUXJZWGRZc2JJejVod0w0QVhlaHlrT1ozM1RQWmQ0NFNtc3hWWWhkS3d0VEVZbCtXNkpxajBSOFBhVDcyR3Bjd1NIeFhpUDh3WWl1SDNyRnRldlhHZCtjWjdacVhsc2JhZ3JBOFpSVmhXYitTNXJvdzFHd3pIRG5RRjlKbFNSSmE4cktsdGhyRUVLZ1VnRXRhMFNsM0l5emlKbEp1VnZIMFlmSHZsdjNCNSt4eEdlZS9wZmtXVGZqL05laFBUZ0FCeFpBNDdzZlgvMm5vZWUrc0d6UHpXMTFIclNPaEZYeHZrb0lvRERDNHp6T0JQNkU4b0hkWkhhaGpCSXdNRjNKY01hdGJ5c0VRMGFwUk5ZNThLMUhpdWtrcGlLZmVsT2JHV29ObHBVT3gxRWJ3MFZHYXoxVklNY0lVTlZTVXJSVUZYRmZqV3JuT3prLzNIbDVjMlBFblJ3eDNmRTVPNk94aVpDNEsvZTNsMy9KLy8rcy8vNkovN2tRNk8zM2IvOGw5SXNXV2hsaTB6UDlEQ1hhNHFKSlc0Sm5CUEVRaUZsNklYZ0hKR1R0SlJuSkd1TURlTzkwbm0wQzJHUXJ5V2puWktYcjMrRm5ja3ExN2V1Y1d2ek5xc2JhMVRiRlVkN2k1eWVuU1lWQ2VONlJMOGFjWDE0bTJ1RFc2eU90eGptWS9LZENmM2JlN1RtTy9TbXBxaEdCbWM4V3FwUUhiUE9lK2VGVGZ5anJZVnNlWEs5M0JZQzVmMXZGY1ErQk1nM1lVTEMyUXMvZ3JOZStKQ003NE9qQmJSMW9uby84SlAzZmVDUjl4Ly9pYW01N0g2OEovZWVSQXZodktDeW9KQzQybUVPME9CeFhoQkdJWHl6N2l6Y3Vyanc2N0twU3RYVzR5cUROUll0QmJXV0NDa09ibWx2TE02ZEJIMGNtNDhaMzVnaVdycU5uVmd3QnFWbDA0d1RCNmRkYVdYTXVQck50VXZiSHlySDlhQUJTSEVIM2VMT09XM3ZQVTRJM05yVzBQM2ovL0M1Zi9jVGYvTGhkYW5VMytoMDJtZFBIcHRoNGJuSWw3a1ZMaE5FS2tKNlJhWVZwWFM0dW9UQ292RUJtTWJUbHRDYWJsTzJFcXJLNFF2UGg1LytDSysvK2pMS0dqWjN0N2hXclpHMldqeDYraUhlZnZadEhHa3RZa3ZEMXNZbWI3NStrK2MzWG1OdHRJbndBdWtrV3NWRVNZSXBUV2hBQ1VHVlYzampnNVNRc2NMa3RSZEtISmZTbndSZWFRb3I4bXVmK1NFWDY1c0pyMW9SMjZ0alVaVldlSWR1UXFvTTZQUm0wOW0vOW45OSs1KzcvNTFILzliMGJIcFhGQ28wd3JqOVpuQno2QkZFU2pPcEhPWCtKQ0ZnU29lM0FReDVGY3FlbGZVVWRhQlU0QWdBcUIzV09remxNSVdoR3RmVWhjRWFnNmRGRkgwWFptanhwc1JOVWtxM2hxMEhxRVlnR3BxNWJpR2F4SlhYVjE3ZS9PYzdOL3BYbXRCcXdsZUxRMyt0cktlSEFCSmp2ZjNTcTZ2WFFGNlhVbFR0UkUzdlZxTXVwMUtSeGkwU21hSmxTcUlTbkJlVXBjVjdTNXhLMGppc1lxaEtxQXZMWW11SlJ4ZnU0NUhlT1I2YXVZY2phcDRsc2NCc1BVWFB0SG4vL2UvaHZlZmV3VncyMnlneEdyeUhoZFlzcHpySHllcVlqZTF0OXNZREJBSmJXMHhsMEZtTW1kUVVnNXg2VWxLWGhycXNRMUhBZXlrajllSjRyL3lLZDc3K2VwZkNJVUMrUVR0NnBzZk5OL3RVcGIxempVRUtkSG96NmZTZisrbUhQL2pBRTB0L1k3b2JMVWFoM2kvcUJoQmhKRVBnZ0ZURktCbFJWSUg3SkJ1RzYyUmNvWlVNaDlnM3FvY2VNQ0gwd0h2cXlsSVdscnF5dU1wU0RDdUtVWVdwYXB6VnREdnZ3STFtcUVkYkNDR2hqbkdWUnZmMkVOb2Q1RFlxVVlHMFdObU56U3U3LzM3dDFlMFhtM3hqZit6MHE1cGxkM3FRTzc0T3FqMHZYOTVZL2N5WHI3KzBzejIrNnR1K3RYRHY5SkVzYmFsRXQwbFVoaUFLQkVrS09sTUNIVVVrcVdhcUhhTWplT0xNTy9tUmgvNE05L1JPSW9jR2FadUpBQ1dRa1NKeG1uSW54emtYNk1nMGcxVXVoRzN6TS9NY3llYVlFVzNjcEdhcnY4Tm9NS1lhRjNpbFF0ZzVMckcxeFZ1TE1RYm5ETjU3bjAxbmJ3dzM4eTg2NC9aWHdYMVZtZmNRSU4rZ2RXY1M4bkY5WjJpVklPam9TTGIvL045KytQc2Zlcyt4LzZXVnFjVklLa3JqRzBtcXdCeFZJbmdGWTZHeW5rRlJVMXFIOHlHZktFem9SNlN4UnFKQ3A5bUJkQkJMU1JyRkNPZVpUR3JLSW9nYVZCTkROYWt4ZVlHM0xlYVAvVm44NUFpVHJWVThObERHaFlLNmc0aEJ0ZmZDVTVjQ25Xb2ZSUnEvT3JwY1hSdThVRlJ1MXhnNzVxMXBPdnMxWHVNZ3l2ejZnQkV5TDJ2eDB0V3R6YW9yUncrLzc5VGpTcWZ0U0tZb2tZYXFsZDhqVGlxVTFGaXJpTFVtVm9MelN4ZjU0R00vd1hUY282cEtxcnFrS0hKcVU5SHV0Q21ybXRMV2xGVkJmMmVQTXMrSkVrV3JsWkdtWVlweFoydVRxOWZmNU1idGE5emN1TTNOalRYeXdUZ3dmQVNZMm1LTENtY016anFzRGRoV2tTUnVKMWNHNjVPbnJYSDUxM2pPd3h6a0c3VWYvcHNYK2V4SGJpS1ZFTlljcUxRbmVOTEgzM3Y4N0NOUExmLzVoZWw0MFZ2dmpVTm9JZkZDb0tRTjh3ME5uY0kzVXFDVjhVMzNYUklyQlNxUURKV1ExQTI0dkEwQzA0bFFaSVJ3S0ZJQ0dVZE15ckFDemRRR1Q0LzJ6SGRnK2wyR0s5ZndRZGtHc1Y4eXRoYTN2UWlkQ2FTcmdkS2hsWWlHT1ozUitQN1dZclEwUHhOOWVudGdmKzNLamIwWHdPK0RJNytqZW5Xbk43bFRNTHNoNW51THdPQ3hUa2wyS3lkcVUxRXhvZDJHd282eGFrVGtGVld0VUVLaEVMVGpMaytlL2hOTXBkT014dXRrN1pTRjVXV1VVZ3dIUXp5ZStjVjVlbE5UbEdWT01jclpYTmxnYjJ1SGk0L2NoOWVhejMvaGFaNTc1UVd1cnQxa1l6TEFTbEJKQkdPQnFXcGtJVEhPNDR1NlVROFhTQzJRU2hHbE1WTEtyNVV1UGF4aWZmUFpPY3dzWkdMOTVsamMwU1ZQZWpOSjUvdiswcmtmWDFqSzdoY1dVZHVRRUNvbEtLd0xVM3d5bEhLMWtPUk5QeUJXTWpCY1hSZ2Z6WlFLczBBaTlFYXFPb1JVa1FkVEcvYktFRVpoUGFtS0tZUkRTby9VeXlTOTkyQjNKYVBOTjV0TlZoN3ZnMUFPUW9IeTJFSlEzcjRMZmNSQWV6T292RzhOS0FZanBhSm91YVg1SWQwVDk4L2N0L1JMTjlaR245cmFHZCs2WTFWMWNVZGNmdWVPZDkzOHZFK2wwWUFzSnNhTUo4WUpVNFdZemVlNHVFSTdNSGk4RTBSQ2dvTXpjNDl5ckhjWDNoVEVTVVMzMTBJclJWbmt4R21LcXkzandZaTZMRmpaWE9PTmEyK3d2cmxPM2gvenl1b2xCcG5oK1ZkZVpESXF5T0tFTkVtcGZiajg0eXhsdE5mSEdZMnBETGFxYWJVU1ZLeFJXcUswUWlYYW1jTGN0TFVydjE0UDVCQWczNkROem1ma281cG1yazBKUWV3OTBUdS82K1FEUjAvMzNsTmJkRzFDSWg0ck1NNFRpZENRbTNpSGFkWjVhQnhDQ0NvSGtSUTRaMFBLSVpvR1dqT1Nxa1hZQlloenpVNUFpN0FPWnl5VkJXOExFRXNJOVg3cTFZcHk5eWJPMjRPUlZZRU1IQ2tFTXRFSUliQjVoRmcvanp4V0lyQU40MWRSZVU5Vkc0bVFGN3FSL09uN1QzZS9jM3V1OVM5ZnZiTDlURzNzUGlXL2FnN1FuZUM0ODJ1ZlVoUFh4a2xiT3F6M09CVkVwekVlcjBJRlQzdUhNUlZMdlpNOGZQejlKRExDMWpsYWFXUzdRNVMyU1R0ZDNuanBWYjcwNHBkNTZjb3JYTjlkWlR2dk02a3J2UFc0MnZQNnBTMWFzeG54ZEVabHdoQ1dRbERWQnVzOWFaWlNsVVhJQUgxd2VuRTdSa2NhS1dVSU5TTTlHbXhNWHJmR21jTkc0ZS9CL3MwL2VKNjZka0dXS2RUTG96aFIyWlBmY2Z5ZEtwS3ozdUpWVU14b0hFNlk0S3VzbzZvRldzaUcvaEZXa3Fsd3YrTmswSUp5aFAxaVNvVFZPRTRLOG9hanBEeEk3L0ZTWW5IVWRVbFZuNk11SHFkY0dXUDZxM2h2QTVpOFE0aEE4d2lxaEFhY1F1a0lZeXBzSVJCMUJMNUdPRUtuV1VtRWM4SUxUMWxWblRqeVR5NTA0NFg0N3BsZnVMbzYrZS9iL2NsV0F3Q0hRQ3FkekFFejN0a0VJVEx2M0pSM2RoNGY2QnA3NjVOenQ5N3NKMGZtUVhjVVVTSG9kU05VclBCT2trWWduT0xlSTA4eW04eGlxc21CYnhJNnhwaUs1MS8vTXIvMGhmL0tDNjllWWpRYUg4eUVLS213eGlBRkdHUEpCeVdkdVJZcVVoU2pIQVY0NDNBaVhCS3RiZ3Z2TE00WnRJWW9pWkdCUnU5VnBFUmR1UmVHMjVPWEcwRGMyZk01OUNEZmpKV0ZSVWdoZkdEb2FrQ2RPTk5ibUQvYWZrZ0lFY2R5WDJhZ1VjdndVRnVQc1NDY3VFTjVRMkN0YTZSclFQcEEyOTUvQ0pYekNPTVJOaEFOU3hmVU8xeEQvVllTU25zZnhlQXhpcTBDcWpFZVIxRk1tbjZKQkttdzNpR2xRc29vekhuTHNJOURSRU9rR2lHc3dDUUtUMkQ4ZXUreDNoSkE0cW1NT2R0S281OTY0R3ozM3NFNCs5RHpiKzQ4NzV3M09zN21zdTdzVHlIRVE5WWFpZmVSOXo1enRtN2pmZVdjcllicmRldGovL3lsWG04MkkyNUpwSUxqOTB6VFdjaG9keUxPM0RYRnlhWHpIR3ZmaHdodk40U0NVakdlVkh6czZWL2xVeXNmWjI5dVFyS2NVVnl2TVlVTi9Zdks0R3VMdHk2SUxnd0xodEpEN1REV0hHemdGUkpzYlloYk1TaEhWVnAwRklNVUVEU0toVkRLbUxwK3BweVlRZU1oNzVRZUZZZGNyRy9Rbm5qZlViN3dpWlg5TXk1OUUySTg4ZDVqcDVLV1BoTEpabGxsTXhXVjZoVHJvRFE1U2dpMGhHSmk4STJNelg2V0t6d1k2NGlhcDFFNUYxcTUzbE1iRnpxL0JOcUp4K0o5aTZwNGdOM05jK1M3QmI0dThkWmhiY0hDMGhUamthTXF5eVpuOWxoYmhaS3VWNEZTTHNHSU5ad2RZYXNPWXJxTjFLR3o3QnVQWjUzRjQ0U1Vrc3I1cVU3bWYyaW1MUlpuTzlFLzNCcFVLenJKSGxSeDhoMUNxa1ZwcmZkNHNTKzJRQU0wNXd4VjZkbGE4UWMwOXhzdnJlTzlJVzVGOUtZRk01MnJmT3JlVlI1NjhGNFdabWU0OS93NXVwMDJYN2o4T1Y0WXZRQXprbVFjay9WaWhpMk5IVlhZc3BtekQ1M3dVQ1dzYXN4dTJNWXJUUERRRUJxc2lMQlhSY1NTTEl1Q1Y1RmgwNVpRRWlYa1RUZTB6OW5LNWwrbjczTVlZbjJqWnExRFJ6SjB6OS9hTTZpUG5PbWR6WkpvVVhqWkRBVUZOUTB0RmFPaUNxT3dYb1JWQklXaGxnS0xJRll5MU8rOVIvdm1BVFNyMFdvYjZDZlNDcHh6ZU9Qd3hsS1p1OWplZXB6aFpwdGlsSWQ1anRxeE9KL3cxLy9tWDBZblUveUQvK2N2czd0eE00UmIzaVAyRlVPRXg5bWFzdHBpN0YraFcwWGhkWHNaZFJTaHhtWGdTRFlNWU9ORExwUkl4M2hTYzJ1cjdQUW5wZ1BNSkhGMmJ4eWxNODQ3NzZ3Tm1pUGVpLzE2cjVBaXJGWGJGOEJUQ29GQ094ZTByaUpObmp2R2c1S2JONS9tdi8vYXI2T1ZvTk51a3lTYTVMaGs3dTRaT3ZNZGV2UGRvRE04azFGczVxSFhFemI5QkMreEwvOVRXeVpWU1l3a1VqRlJKTU1tTGNCTFR5Zk8wS2xuWk1zZ0FtQXQ3VFMyMDdMNzlJM2JtMjgwb1ZYMTIvUjlEZ0h5TzlsUC9wMUgrZHdudm96U1dsaGo3aHlaalh1ZFpMWWRKMmxoYkpqWWE5UXlkc3N4b3lMa3M2R2MyNVFXbXhRNjlsQldGbFNvY09HYkc5R0JhQ1NWcFhGb1p5aHF6MkR3QUlPOXh4bHNTcXA4aEtrTUZCWGU5UG5MUC9sOWZQQ0gzc1gvKytjK3plNzJacGg4SlVLcXNQdFBLQWs2UXJnSnc4bHJlRFhDNUYxY1pSRktzaE4zRWJkSExNeXFSajhyME0rRmt1Q0Z1THlhMjkyeHZXS3ROMUxwMlNoT1R5dXRJK2tkM2ptTUNjV3RPMVFqd3cwdEJFS0VoWjdHR2ZZMVhPcmFvcFJDUlNreVV6amJ4cGlhN2J6RTluTlljN3p4eFhXVUVrd3R0Y2g2TWRsc2kySW5kTUYxRlBhYmhEbUFNQUtnSTRVMGtqS3ZVWWxFWmdtMlVVY3BqZUdZN0ZBbEVVVzV5MnpTcHFOaXNpUzd2TE5lL0dwL1BCbmM0VDFzWUFnSTc5OFMxamdFeU85azNzUHkwYk84OGRKMThUVWx6amhTSXJFRTRZRm1lUk9qd2pUaUc4ME9qc3BpalFPaFNIWHdFcll3eEY2VEpCbWpmQnhJaXo2UUY3RUNiMnE4OFJUNUVUWTM3Mko3OHpURjJGRlhPYmFva1hXTkg2K3psVmh1VlFuUHZiek9oei84TE00VXhFbU1qTHJJcEkxTUVwQUtnV05yL1ZPTXErdTBzaGhibWFCNFVsazZ4NmRadWJSQk9uYkVTWkNmRjBpMEY5emVydnpXd0RnUEhlODVyNlh5Y1pJZWk2S1kybFI0RVR5Q2tBSDZnWmxyY1M1NHNLQk9JbEJTSGlpZ2VCL1dYa01GVlFoM1FCQkZDVkdVNHZGNEY4RFgzNnpZVzUrQUgrS3NRUWhIRkFldFlhMGh5alJKUzlOSlcvUjZiVWJsRUFFWVo2bWNSUXZGa1dTYVpURk4xUFdjNmMyU0t1MzdQaS9YdGdlLzlvVXZ2LzdTSGV3QkUyb204b0J3ZGdpUWI4QWVlOThNcjcyNEpueFFGWkI0cndEVjZzN0hxTlowYWMxQjE5d0xpUklTaGFkdVZCS3lTR0Zra09ieGxjWFdGb1JrcmpkUGxLUk1SamttcjNGYWhVTnJhaW96eGU3ZVJXN2ZPTXB3a0dKcmd5bHJxQTJxTnZoOGk1MnRaOW5wYW43bE54N2l1WTg4eS9YWExoRWxLVEtiUWJSNlJLMFdLbzZSM3JOMSszTnM3MzJCS0xOaFFyRnBsQTEzY3pxZG1HeDVpczNiV3h4YjFEZ2NzWkpzN2RXczdkVENCZmI1dTRDSHdOZkFyUGVPU0dsOG5JVVJXaG1LRXhLQnNpYUVoczRTdElROWJqL2t3NGM4YkQ4RDNzOWQ4QWMvNzRzVEN5blJhUloyZWpUZXludUhzeFpUbThEcEdwVG9xR2JVcXVqT3RoQlNVRm1EckNWTDhRd24ydk1zZGFaSmxXYW94dHpJZC95T25kamRVZjdSYTY5dS9ISnQ3UUZqV1lCTjA4U2ZYRjcwYjl5NGZSaGlmYU0yTlg4WFJYRWI3OWJEbWxpRUVsTEtrdy8rNEdNanQvQ08ycjRCU0l5RFdBcmFrV0tVR3hJaGlWUVlHSkxXNFh6UXVFSklva1JUKzVyUklIQ0xoQVJyTEpNOHB0OC93KzdXZzJ5dXR4bjJoemlmNDUwQVk5SE80Q1liN0s1L25xMjk1NGtYdnBQdFN6ZlkzYjZCVGpxSTlnSzAydWcwSW1zbFJNcXp2Zm8wYTJ1L2lveEdTS1hSU3BLMUVrUWttZDBxbUI5UFdKcEtxT1FzVTFuRVNGaHU3UFRaR0JqS3R3cWVMYUFsZ05vWmNCb3ROWW1LN2lnOGhBNlJWaHFob1RaMThDeGVZS3dKdkM5ajhOYUVBMC9URkcybURQZUI0ZmRUQUIrQUlmeCszMTRndkViSUNCazNGNUt6ZU84WkRjZVVrd0duVDgwem4vVTQyVnNta3hIQzJ4RFdDc0YyT1hKWHk1MWhuYnZQYmx6ZSs2ZlZibjI3WVFyc3o3dTRlMDRlOTkveDlzZjR4Ly8yRnc0QjhvMWFWZlNZREkvaS9ac2lrTjJkYW5kblZXL3h3dU1yMjlueTB2Q3FiN2VzOEs0UkQvQ0dURXNTSWNpcmNDdkdTaVBqbUpsc2x0RmtRR0VNZTZNUnRaSFVWWnZCTUdObmI0R2R6U1AwOTJhcGNrZFpqTEUrcU5RSzU1QTQ2c0Z0UnFQYkRJNHVrbVFQc2NoUjR1RTJvcjJBN3l4Q2toQkZubmFuUlJxVkRBZWZaV2Z3TVdROEpvNGlWS0pwOVRMaVRveFdrbTVlSS9keUlxMUlzeGdCbko1YlpDam5HTjU2RTkrc3lWQUhYVUNQcXl1TTBwZ21oUEVFWVFZcFF2MUlDUmx5a0VnZUtJN29TRGVTcHlxVVdnRm5iS09ERmJ4cTBDemU5eVpoNWNFQkpkL3Q2L2J1MXdtYlRsTVQya2tkMDVhQ0o1YlBNOTNxaENhcHQxaGJJNFhBZXV1MGtWL1p2VEg2cGNINjVMUDVzTHBOWUN6blFDV0VNTjU3OTlyVjYvNVBmK0RkSENicDM0VDlsZmYvQTA3ZDg4aFhKVzFTS1RVOWxTYWp3VjA4L1JsSHQ3M043RnlmSktsSVkwTTNycEJFNUdWTVZhVUlGQ2NXanBHSUxxOWR1OHBLWDVMWExjb3laaktPbVl4U2pHbmpqTVBhbXNwYWpBKzNhRkNhYzlqeExsUHBpUGQ4ei92NDNNMFllMzJGcUJoZzIyM296cU8wSkk0Z2pRUnBuRE1wUDhtZ2VBYXRLcEk0UWtXS3BKc1JaWEVRYmhOZ3JhVjBFTHRRZVRET1VmWUh2UCtCaDFucEd5NjkvdVlCaHlScSt2TjFiYWw5Z2ZjV0pYVWpHQjJVUzRSVVlVbG9vMlNTUmpwdzR0MUIrUmpaWk90ZVNvUUhKU0tjREl1QlhCT1dlZThPY2dCckE3bVFwa0ltaFd4Q3JpQTFxbFRvNVVSU0VRbUpNVFZhcVVaQUw0aVdLcW1MZkdBL3Z2N20zc2Q0YTR4NHNnOE9LWVZQazVUeEpPZi85cy8vOVNGQXZobjdvYi8vYWI3NG4vL1BnUklhQm8zRXFMOXR0cmRXdDVMWmV4bHZuMkt0T2tiYUVwUjFCYklta3BPd2JzeEUxSlZDU1VHV1JCVERrbEYrQmljanBGSkJzTmtFWXFIU0ZjNDZURm1IcEw2WkUvRjRSSmtqSnpkNTd3ZWZ3S1luMGRlK2d2QUNOM01VMVdxaGxDQk5GR21ra0hLTFduNmEycjZHVWhwbklJb2pXdE10VktxREFxS1dLT01RaGNGNFI4c0wybUY3RDNZeXdkNjh3bmRlT0VteHVjRjRiM0N3bHd3VjQ0WEVtZUJadksxQ1ZWUUlhc0o2Z2xxR0FTN25nN3lqaWxRNHNFcWhsTUk2MDNTeUpkalF0eE02VERYdTg0ZTlsMWhyaVhTRTB4RjFYWWVHWmlOd3R4K0ZXVk9qZEVRNUdaQm9UYVJWSTJvTlJWZzBSTGZWb3RkSjdhV05sZTJtV3BYdmU0NG05M0JabXZwMmx2cnhKUCs2WitBUUlMK0RTU1ZBeFFmL0xEek8yWnIrM3M2dGFIdHZZbXZid1VIdEpNWjRqRldZdWgyVUF2RW9nczdzZUZpSFlTbWxtelVCTnVqUU50TDlabXh3VmFDTG9JSW9yYmNlYVExaXNrZmF5WGo1VGMvTkc2L2c0d1RabVNhS0EvaVVnRlJycEw1RnJuNEQ2OWN3eGpIY0dXSzhJZWttZUNWQzJWZUcwRVFXQnBlYnBqSHBBbnZMZVlTUWJLeXNjUHFlTGovNDNlL2lGejcwY1d4WkJjcExIQk9uS2FhdXd5cUMvWnUreVNHY042SHZZK0M3ejBuT3ptaWV2bHF5UG9KSktSbllvR2FpVlBBRVNrbVUwdEFvclFmZHFoanJMRXBIZUJzMHU4VCtxVytxUzg0NXBKQUg0UnJPSWtSNG5VaW5DS0hJVWtXdm5aSkdtaVRScnF6S0VUQVJVUGltckN1RXNFb0w0a2o1c2p5Y1NmL1dLQ1o1aFhYNzJ3UDkvaG8xVjQ0MmI1bHFzb2ZNT3RZMDAya05RMEhKMFA2V1RiVm1QNG1WK3dkL1g0VFpFOGhXVGJkWmFOazA5NEpuOGNJaXZFWEZiVXE2WEwwNVFiV0RPRUtTcUNBVEpBVko1TEh5RWtYeVdVUzBoeGhJUmhzRHFuRk8xc3ZJT2lsbFpZSzBxQXpPMEJhR3VqYWt6Y3F6MnUxTDhvU2NZdWZXRFU1ZTZISDY1RkZlZS8xYW1LbXdGb0VqaXBPbXFtU3hqdEMwZElFRFZ0YU90NTJVL08xM3hTeTJOTjkvajJkdjRsZ1plbDdjZEZ6ZDlsemFOT3lXbmtsQkNNbEMvSVJVQ2luRGQ2MERMVVNpU0dLTmN3N2o2a0NsYWZJUXBUUkNTYVNBTkU3cHRhZklZaDBvUGM2QU4xam5oYkhXamZOaUNGUUlVUVdDR2xaRkVxSHczZTR5N1Jic1hYcmpFQ0Rmck9YakVtT3MzMWZYMzk5MVB0NjV2bW1xMFhyVWFoOFhLdWhYMVpWRktobFVRcVJDT2hkMGNwdkdtV3NTVHFIQ1VrcHZIUHNybEZTenpkVlpCOGJnaFFNcDhFcGpSQWVVUWlZYW5XbXlMQ2FKUXJ5dlJFbVZmWUVxZVFGQnlXaWxZUGZxT21aU0ViZGloQkpVZFlobDVEN05Ra29ZRm1BTVVvZTQzWGhQTEFVb2hVSlJXY3ZtYXkvei9nZnZaV1FzYjE2NWdiRVYrV1FQTFFNYk5sSXFjS2kwUktNd3puTnN4dk8vdkErTzlTVGowalBmRXl5MEZIZk53RHRPd0xEd1hPMTdYdDZ5ZlBpTmlwVytZMXdIRVRsblRWQ0psNUtTSEp4dlFLTU90a1U0NzBLalVXbXNOVWpod1ZtT3pjMHgwMjFSVlNYT2U1SW9CcHl2NmtJb0ZRMHFVKyt5djlWV0NPZTk5NmF5UHNvVTEyKys4VHVlZ1VPQS9BNG1oR0M0OWhXRWxQZ3dVRzRCVjQzWHg4SlY2OTQ0UkZYeEY3L3ZBbGZYSjN6eTgyOGlaQ3M4V0FFeWFsUUFoR2hvSEdHSmpYZitnRVFvbXNVdTF0aEFBVG53VXlDMHdnVmhCYUpFa3lhYWRpc20xUkdDTVpQbzB6RDFHdHBZdGk3dHN2N2FiWVIzcEowa0tERTJWU1dsUSs0aGxFUUxtRkthS0ZKNFUxTWJHOTZQbGtnaE1DS29yb2k2NHBnYjg0NEg3dWJheWdhMTk5amE0cVFGNFNsRjBPTldVbUtscGphQ2UwOEtIcnRQbzNjZEhTMnd0Y0NGbElxNkZxUmFjRzVHY3JRck9UT2p1TFJoK01UVml0ZTNiYUFLQTk2NkEyMWg3MzJZUFQrWTZUY2hXVmRoSEVCNkZUYnZDc0NISGZIR0d2Q1dPRklnUmIyNnQvZk15dmJ1YWtNamNZRExzcGlISHp6RDU1NjU5THVlZ2NPUjI5L0Jybnp4MzlFNytqRGxhQVB2N01Fa1lWMk85UEY3MzNVeDdTMDlYRlJXUEhMdklvODlkb3lQZlBRL3MvMzZaNUZSaWxSdHZCVVVoV2tVQkp2dW1HdENLaUZvOUhDd3pkNCs5c3VhUHN4akN5WFJzU2JOWXRxZGlIYVdrTVlTNGh1NHppZlFNMWR4RThQTnI2eXc5dXBOdkxPMHVoa3FDb214a0tKSmtrTjFTYWNSaVlka3BZOGFGMkJEZVRvY3ZsQmw4azNZRTBuRlpHL0FYQ2ZGWkQxdWJQYVJTUmIyZUFnVkZFU2FRb0wzRG04cUhqMDN4Y0twcDdpNjE2TXNKdlRpT2x3RXlnYzVMZ2wxTFNsdElEalBwNUt6TXpJME5DZWV3cndsdkwzZlRRd1ZMZkZWTkNuZmNOL3dEbGRPdUhEOEdNZm41aGpsRTZ3MVZOVGNxbmZFVndZM1gvbnNpNi85YnpkdWI2MDBsYXRDQ0ZGSDdjajVHY25leXVoM1BRT0hIdVIzKzRDOCs2ME1GR2R0ekhpMTE0a0tZOUxzbDMvek1tL3ZUNWk5KzBHdXZ2SnBkbCs5enR1KzU2ZjV3YWZPOC94ckc3eHllUnRUMjROa1U2cFF5YkhPdjdXSVJvb3dXT1FKdDc4T1hlbzAxYlJhbWl4SmlWU042RHdIMHkrZ3hKRHQyMk51UEgrVG5kdmJKSkVpYnFmb1dLTjBpT2VGRktHWnB3UktTMlNrOE5zajdNNElUNkRSeXlaL2NMN0pNNnlrQW1JaDhUaks5VlYrNFBISDJhcmc1bTdkVktOc1dDOWdhNncxV09jNGZldzRDOGZmeFJ2anM3eTI4Z2FMK1M3dk81dXk1cGJKR0RNangvVGtpQ2lha0dsTktTUjFiZW5Ha3ZlZWltaUxpcy9mdG16VXljRnF0WDN2dTk5dGJ5aGRZU2NKNEd4MXNLTE5Xa1BsYTlhS1hhN1VXMzRnQ3BHUHF6ZHZyKzFzK3BCM0JMNlZ3SHNsR0xqaUczditoeEQ0N2UwSC91by80dm5QL05LK0xzbEI1QVdJVGlyZFZEdXhlVzZwU3M5emwzYko0dE9jZisvZm91aHYwNTJab3pPVGN2ZGRjOXpjbmpBWlZ3Z1hrblZIb0xvTDJZUmZzbkV1cXRHNWFrWkMwMFRSeVNLeUxFSHJBWHI2ODJUelY4akhGZGRlMmVMYWM5Y3ArMk9TTktMVlR0RnBqTllhRllXTnNQdjd4S1dTcUNpRVcvRmVRZVFDRFVRMEk4QmhNNXZBMnJDMzNIcEI3UzFDSy9KSmdiMTVoUjk0MnpsKy9wbmJHR09icm5kbzlGVmxTYmZiNGs5K3ozZXdNRHZINVRkZloyOXJnMnpwQWw5MFhhTHVNdGlhMVVneUg0ODVHNjJnTjE5Z1ZnNUpsQ1NhQkhXU0V4bXN0QVViZTVJNGpzTW1LMmNEZGFYUjhucHJISzNaTDJJRFdkSkl5NnVEbTF3WnI3TTEzc05vS2RKMmdxL2NiajB4WSs1WXFRWjRLWVRmK2ZMdUlVQityN1o2NHhXaUpBbHI4Y0p6MlJjczBFdExSeGZhM1ZhN1A2eElsQ0RPWXF4enhMTW5xV2RPTVJvWi91MkhYZ01UeEtKVnJQSE9JWlVNQXo4dUpPOVNCNktmODRDMHpXNXpRWnBvZXUwVXJSeHg5ektkcGVmUjZUcGJ0MFpjK3NJTjFxNXNJSjJsMDAySmt0QXAxenBVMFlMT3J3aGFXRHBVdklnVktxK1JlK05tWTZ3amlhS3dBZFk3aEcrbUtVeGdHbHZoc1RZc3g5bGFYYU1vQkxXVmxOWVJhWTN3SVFkWlhscml5VWNmWktyYjRjcVZOOWhZWCtQbzBlUE1MaXloT3gwaUhZR09hSFY3ekJ3L3prZzY3TXlqeEN1Zm9iWDdNa0pXM0ZncktFclAxYzBCWlQ2Q1ZwY29hNlBqNUNETThrMHRNYXlBY3dpQ3RwZkI4VWE1Z2g0b2FtOUJLNkpJSWFTMFNMbm52ZCtuc2xzaGhJL2FrUjl2VGI3eENPSVFCcis5UGZmeG53T2Q0ZXBLTkF0UEZhRFRtRFRSK1V5V2FkRnBKZGlxUWl1QlR4S2tNbWpuVUVaakJaaks0UENoL29VNktQRW1TYk91VUFmZEt5VkFPNEdXa2l4TmFDV2FOTnVrdS9RQzBkUTFKc01KbDUvWjVQVm5yMUVNSnFTWklrN1NVRFdMTkxHTXNXUEx1TXBSTFVYV3kwS3BXUWxrckZGSzRxOXY0MFlGVHRtd1A5MjdNQS92TEZGRE9nd2p3QjRyUWtmZlN6QldzTDYrUlgrUTRJV2tVZ3J2NGNUUm83em43WTh4MVcxei9kcFZkcmEyV0ZvK3l2ekNJdDFlTDVTVmdhWGxKZTY1NTI2R3d6RnJhK3NrNlhFbUovOE1TWHFFMjg5OGlDKzh0c3RyZTVhVlFZRUhpa0ZCV1F5UldZYVVHcTBpdEk1SWt6UlE3RVZnSFZkMVNTMmdraVlzNkpHaHFpWUU0QmpnL0VvRERvTUlCUlpUR1ArK3YvOCtQdkYvLzhRaFFINHZkbUs2eThwd2dxdnovWEI0WDgwa3VuaFBkUHpNN0p1UDJ0WTc2YmRpaklRMGl4Q1JZbEpIalBJS1pTeTFEM3BYZ1M3aEQ4WnhqYkFIS3dDY2N6Z0pVaXFVRXlpbDZFMVBtSjY5Uld2bUZaemVZT1hxa0RlL2ZJdXQ2eHZZdXFiVjF1aFlJN1Nray9XWWpXYVJ1V0t3TjJLMHRjNnVHREY5eGpGemJDcVVTUk9OV1J1Z1YzYlI2cTA5NDhaWWFocmF1ZkFvb1lKM09lQkVOWnRqYTFBNE1EWEdTNnlvT1haa21jY2Z2RWlubFhINzFrM1dWbGM1ZnVJa2kwdExkTHJkcGh5cm1KMlo1ZUxGOHdpcG1heHRvYldpcmtwMmR2YjQ2SC83TWxkZnZNMnRuWXArWmQ4S1pMM0QxeVZXS0t4eTFMSkVTb1Z6RHExRG4wUjZnYlVWS29La0ZSK0VydDZIUzZFcXpmcGdhM0tOcjVrVWRMWDc1bkxRUXlqOFZydC9jWlorVlpNb0tYSm45K2ZRSXlCUlNtUVBQN0Q4dnFjZUtFOXVNUEhEWVZ1WVRKUEVLdlFUdENlTEZYbHBHSHJlU2k0UFpzdkR3YXdxZzNPZXNuSjQ0MGtqejl6TWtMbkZGWHB6S3hpeHh1YnFMdGRlMytIV3BWVjJWM2RRQXBKRW9STk4xbTZ6MEZuZ1NMSk1iR0pLU2xSUE14Z04yTzJQR2U4V3pKMmFRYlVqM0toaTh2SVdNMVdOeUJyNVVjRDVJRTBrZmFoR2FSa0tCL3ZOeS8zWTN6cFBLaXlwakpoVWh0UEhqL0tlcDU2ZzEybXpzYjdHenZZMlM4dEhtRjlZWkhwNkZ1OGNBc0h5MGhJblQ1NUFDTVh0V3lzWWEyaTEybXh2Yi9QelAvOXYrY0l6bjZjMjlkZC9DTTFTUmRGTVd6cnJHRStHQ09HSjQ0VHBxWG1VMHMwazQxdGxZZThjUW1pRWxLVXBiYjVmMmhVSXJ4SkZPcDErdzk3akVDQmZ4eElDbDJkUzFxS296ZjRrNnI0T2IzenFXSGJ5aWNkT2ZzLzg3R3l5dXYzcmZuSHhTVXgrQXVkVmlPZWRZMWpXeEZMU2loUmw3WnFLaTBNcENSNUdrN0Q5U1BnYXJjZTBPaHNzTHEvVG5kN0crZ0VyNjN0Y3ZiekYyaHVickYvZlpMUTNRZ3BQbkVWRVdjTEN6QktuWjA0ekc4OGdhbzhSaHFxc0dWY0R0dk0rb2lXWlh1b1FkMU9jOWV5OHRJSGFtcUNtWUgrajZENi9UQjZVVVVOb0pScEEyRVpjT3doTENHTHBTU1VzTHk3d3JpY2ZwOWRwczd1N3c4N09Ock56OHh3NWNveGVid29wQTNXazErMXk3cDY3aVpPRVc3ZldxR3VEVklxcXF2aXYvL1cvOE13em44T0dzZDNmT3VlNkR4RHJrRkhvM3dqQndRcnF1cXJvOTNkeFZVbWNoTnpKV0J2V09VamhuVWNJSlhhdDhXUHVrRWtWVXZqdXNTNmp0ZEVoUUw3bDVpQndiWGVBQStHOGw5eXhGRWRKMFhyOG9kbnZ2UGY4MmVNM2IxVCt4dDZMWXU3Q0dwT2RlN0RsS1pSZFFER0hIa0VkUzRTSXFLMUhDSU94VmFDdHU0cHViNDg0Mm1GdVpzRHN6SkRjYmJNekhIQmpkY0RxYXAvTlczdHMzOXBoc0w3TGVEaEJLMEdVS05xOU5uY2R2WWU3WnU4bUlRcWlEVmdHb3dGcnU3ZTRzbjZMT25Zc25PZ3llM3dLNTJIbDJSWEtxMzJXZENOcjYvZjVUUTBaMG9zZ2tkaklEQWt2a041aG1odmNOZ3M0dmFrNGYrb3NSKzUvbkY0N1pXTmpqZjdlSHRQVHN5d3VMdFB0OVJBU3FxcGtxamZGcWRPbmlPS0VqWTF0aXFLZ0xBdVUxdnphci81M2Z2M1hmNjBaMS8yZHpJT3BjSVZDWlcxVUZISVJwU084Q0V4ZmEwcFVWMko4b01JVEdBdENlckRXYjlhVGVzTFhDREVvSlE5RHJOK0xOWittYURaMkt5QVNncGIzcEtkT3R1OTYvM3RQZldCdTVrVDBvWTg5NHpmTFRiTGpYVVRyaXhBL0M3NkRzNHZNVDdXWlZKNjhqTWhrZ2hGOUVIMWlKWWhqUnl0MUtCemp2T2JLNm9qYlcwTzJ0OGFNOXdwR3V4UDZhenYwMTNZb0prVVFna2drM2U0VUYwN2R6OTN6ZDZNSnNwcmJ1M3VzcnQ1aVk3REYxcmlQN2NEQ2JKdVpJejJza0t4L2VaWCsxVjFtUENTcWFWWTJ0N05vdGovUnJGMVF6aU0wb2YvaW1oYWdGMWp2VWQ2UkxwM2dnWWNleGFSdGRyYTNHT3p0MHB1YVlXRnhpWGFuZzFhS29pem9kTHFjUDM4djgvUHpySzZ1VTFWVm1NV1BZejc1NlUveG9RLzlGeWFUYjdTS1pQRTJ4eFlDN3pOMEZJV1JaQ0VRdUNCOGtVUUhWNXRvdktHUXdycmNiRmZqS3VjT1FUZ1ZTUitVUmc4QjhpM1pPeDY4d09kZWZDMXdETU40YlFRazNwTnBLZHZuam5lZVdKbytjdnpHOVYxdTNMZ3V4S2hrN2ZPM21YcmlPQnFERmJ1ZzlvalNGQjA3NGlUTUp5VE5ma0ZySVM4RmE5dWU3ZTJDN2QwSitiaW15QTJUY1VuUkwraHY3REhZM0tVdWFxSllFYVdhWTBzbnVYRHFBWTVNSGNWWGh0Rnd5STJiTjdtK2RwVkM1ZmpNSXhUTXRCSzZpMTBxSzFuOTRnckYyb2kyaDY2R05BSXRHa0hkZ3lHazhEZkovaHQwQ0tVeFBreElXanlZbXRhWmkwUVB2NWNDeGZiR0dvTituMTV2aXVYbFpUcWREa3BLeXFxaTIrMXgvdDU3bUpxYTR1Yk4xVVpGM1JKSE1jOS81UVgrMHkvOU10djkwVUY0OXcyWnQvaDZndlVlN3pPVURrajNyc1k1aTJ6WTF2dE1oU0R0ZzhPVDM1R2dPKys5YzhhUnphU0hBUGxXN0VlKzk3MTg1ZEpWMGppaXFLbzc4NDVzc1pQTmYrRHMwbytmMGNtZmZ2WGoyKzA2blpEYUtid1kwZi9TR3BOT1JPdFVEK0doOXA2dGZrNmtRaGRiYWNjb054U0ZaelNvR0E5ckp1T2cwdTVLUjVYWGxKT0s4ZTZFd1hhZjRlNFFWeHZpV0pLMTJ6eDQ3bUVlT1Bzb21vamhjSS9kMFM2Ym8wMjJXdHZZb3g0emNkaThwamVia2s1M21PU1cxVmZYcVRZbXRBUjBCTFFpU0tJUVlza201ZkIzZ0VNMVNvd0lnWk1jVVBHZHM2VExwMGdlZUFlRmlOalozbUJuYTV1cDZlbmdPZHJkTUE5aWFscFppd3ZuNytYMDZaTmN1WHFEcWk0RDQ5WUxYbjcxVmY3ZEwvd2lPNE1SVWJ1SG1Zend0bXk0bjkrWVh4ZkNnd2dySExTTThJNG1MOVBCYzFpSGI1cWlXc3FCTSs0V1h5MG5Tald1dlhlSEh1UmJvNVFveGVyMnJpanIrazZCNmt3SWtUNTFldkZkRHl6MS9xSkFkS1dKU0dqUm1UMU5VVXlZVFByNFZ3WGpxQ2J2ZWJ3TldydGFCcG5ScW9iUnNLWVlHa3hwd3VLYjBsQVhoa20vWUxRM0poK01HZTlPR1BkemRLU1puejNDbVJPbk9IZjJQTFBUY3d5TEFkdmpMZmJxWFhiTkRxT3F6MmhuZ00wTk9wSjBadG9RUld6ZUhyRjF0WThiVjJRQ09nVHZrVVZoTmVFK20vNU9nSGdmcGdsbHN3MVhOZnd0WjJ1bXpsNWc5ckh2WUdBRnc5MXRobzNuT0hMMEdOMXVEeW1EdEkrVWtuUDMzc09aTTZmWTJOaW1MQ3UwMWtpaFdGdGY1Zi80cFovbjV0cHRZaDFobmNLbkFwdjdSbVA0dDh2U3Z6b2Y4YlpHK0FRZE5leGU1MUNSSUc1RitOcUNsR0VnTEZUZlJ0V2tYcnNESUFjZ2VmMGpWdzhCOHEzWTF0NEFJY1NkNG5BeGtKNlliaS9mUGRQNmZvbnZpTFRyWlp3SVUxVklFWktUbWFsWmxGQWtWMnB1M1ZWVDZvYjhweVZDUWo1eGpJY0dVeGg4WlppTVNrYkRDV1pzY2JuRGppeXlpcGp0TFBQSTNTYzVmdXdZMC9QVHVOZ3hxUHM4di9NbDl2WjJHUTRHakFjamltR0JLMnJpV0pOTnRmRlNzVGNvR0t6dlV1d0VjZWNVNk1qR2V5UVFSeERJclcrSkkreFR5SnUvM3VMUWVJOHBEYk1uNytIWXUvOFV1NlZsWi8wV285R1FWcXZONHRJeTNXNDNKUHBOditUZWMvZHc3dHc5Ykcvdk1SaUdFTXJXbG1IVjU5bnRUOU43eEhML2hXWDJWZ3BHYXdYanZxQVlkVEVUankxS3ZxRTczZFc0Zkl4Rm9wTUUwU2duZ3NjYWg0b2xXSXZRRW05OVBsZ1o3WHhWL3FHbG4xM0syTHc5UGdUSXQyS2YrT0pYUkcxc21Qa01DdTZKOTBTUEhKbCsxMElXUDQ0WDZGWmJJQlN1TGh1QlpCRlV5U1BOckltSlZ6Mlh1bjJLekNIcUlKWlZGUlpUV214bG1Xd1hkUFVVRDV4OWlCTUxKemt5ZndRdEZFbVVraVlaRytNdFhsOS9qV3NiYjNENzJtMjIxcllaNzQ0cFJ3V2lLUlBIV1V3ODM4T2pHSTVLQmx0OWlrR0pyME5aUVF0SWZKQWk2Y1lReHdFYys4TGErTGVFM3J4NHF5SnhzT21qdHN5ZU9jL1NrOS9EMXJoa2EzT2R5WGhFbXJXWVgxaGthbXJxUU8rcXFtcnVQWCtPQng2NG44M05iVlpYMTJtMzIwUTZZbFFOZUhyMW82eklONWs2M2NaWVQrOU1pMktuSXA4WWF1dkp0OFlNcnU1UWpXcUtjVW14Vjd4RitmOHRxM3M4K0FwYlRBTGp4MXFTZGpQalFwakR3WHVVQktWbGJTcFRIdlJBcFBCNHo5S3AzaUZBdmhXN2NOZEpYcjE4dzBzcFpCTmV4ZDZqTHk1T25YeGt1ZmRuWWtGbTRqU3NFU3ZHZUdPSUdrcTVMM084U0hFcXhxM1ZkSy9YNUVjTTVid0tLdTJEbXRGMnp0N3JPM3ovazkvTmovK2x2OHF4SXllSVZJUUFTbE56ZmVNcW4zLzlzM3o2MGlkNTdaWFgyYmtaZ0dGcmk0b2xVUktSZEROMEhHRXREUFpxUm5zRHlsRjFvTXE0N3dGU0QxMEpyVWlRUnA1WUVZYTJwR2drZHZiYnpYZG9WQjBzQW5Vc1hueWNJKy80YmpiNlk5YlhWcGhNeG5TNlBlYm5sNWlabmdIQzhobHJMUGZmZDVGSEgzMkUzYjArMjl1N0dHTVlEb2QwV20yZTMvdzhWNHJYVVVvaFEvb1FwaHE3RVdtcVNMeW5NeE16YzZSTk9hb1liMC9ZdTczSGNHTVBNN0o0MDh4anFjQXlFRW9UeFFydkk3d1N4R2xDMnRaQmhDSlN6WEljNWFVUUh1dHV1N0F4YW44R3hGdnJ2ZjBtdStpSEFMbkQ0a2lMMnRqOTBxN3V0TEwwOUd6M3UxYjNKdmNPWWlXNjB6R1VPZEtIVVZGYjE2SHBGa1ZZNjhtTG5QNmtvQjRYNkkyY2FsNWdqNldRaGNPMGVYV2IxOUkzK2ZLNUx6UDlnV21tWm1lNHZuT05MN3orZVg3ajZZL3gzSE5mWWVmbUR2V2tERUlNTFkzUUtVSnFqUEdNUnBZaUgxSk9hbXhsbTcyRmQxeXdPcXhzeXh4TXRTUzlHQ0x2MFFLRThMelZEbnhMdmx3Y3hGY0M3d1JIN24rQzZZZmZ3ODNOUGZaMnRoaVB4N1RiSFJibUY1bVpuVG5JMVV4VmMvck1hZTY3L3lJN083dXNiMnlGOXlBRVJWSHh6UHJudUZSOENWK0NFeGEwYkxiNEJrYUJjRUdFT2d6dmg3bVlLSXRJT3pGNVgySnppNVFFR2trcWliT0lORXVKMndrcVVpZ3AwWkdpck0wZG0wWEQvSXp3MkhwU3JUanJpenNCQXZEcUY5Y1BBZkxOMm85OTMzdjUwcVZyelRZN2Y3QWNwdHRLdTF1VnUraWtiWjJmNnJCZGxHeHM3cUdFcEpWRTRCeXROS0hYNldBSWJqOHZLNHFpeE9RbFptT011UWIrVklmdWZNYlJ4NWQ1NXVYbmVPMS9lNTJCV3FWemFwYVBmZnBqUFAvTVY5aTZ0bzB0YW5Rc1NMSUloTVlZcUVhZWFqeWh5bXRxWTM1cjJOSDB2SVFDR1VOa29Lc2dWcDRJSDBJcjBZUlFqVUNFYUdaUHZIK0xvdUZxejVFTGp6TDd0dTlnWlhPSHJZMVZ5cUpnWm5hTytma0ZwcVpubWdsSWlYR1cwMmRPODlSVFQxS1dGVnRiMjVSRmdmT2VTQ3QyZDE3bGxaMHZVYlU5bVpTNFNZMkxIRFJLOHZ2NzN3UGxKZ0JGNGdQRDJkcjlLV1NVRE40aklGbEFNNUlzaEVCb3FLb3dCeTFsb1BidnI4TldxUzYzMTBadm1zclcrOUl3RXVFdC9sczZIMy9zQWFKMEdOczB6b1pycUdrTzdnNUc4aTg4Y2E2Nlo3Wk5YVlc4c1Q1QUM3RE9VQnBCRW9lNmFUL1BxWjBMWTdtQTk0YWl5aGtYWTl6SUlyZkgySzVtWnJuRjFHTkxxSGJFZi9xTlgyVHQ5aTY3dC91NHZHNG84SkpKRHJhdU1YV0pyVVB5K1ZXVFFuY3VRUXM0NG9BMUFtUVNPaEZvNS9jRkNmZm5qZTdJd3UvWXhPbURrc25DeGNmSUxqN0p6ZFYxK25zN0ZIbEJkNnJIMHZJUmVyMGUzbnVpS0Vqd0xDOHY4ZFJUVDRLSG5lM2RnNkd2cW5aMHhSYVBMK3poelJLZjNOdGtuWkpXTEtHd1FkRmVoY01zbXowUVllVkMyQ21CZGRqYVlQZEhhSnVyWHpVSm9SQ2hFZWl0d2Vrb0RGVEpPMFN6aFVBcUlVUWtKNjcyYTNkNGp3UFpJT2Y5SVVDK1dhdUtFaFZtUFVLMjE0aDdQSFJ5NmNoQ0dwMnR5NUt0UWNIZXBBb1BVMGdpTFlpbElHaWlPNlFXVk03aVBXU3RDRXNidEdReUNiTDljbENSYnd5eDBtT2xZS3Rmc1dNc3RSSzRSZzdITmN0ZmZ0dUx6bi9Oejc0NVBUSWs1ckVUbU5venRJSkkrRWJwL1VBWDRxMDg5NDRHb1VDeGROL2JpYzgrek5yMkxwUHhpTHF1bUowTG5xUFQ3V0tkQzJPN1FyQ3dNTS9ibjN3UzcyRnRiWjI4S0ZCU2txUVprVjNoWkhLYlZIZytjT0lZRitjVytKWExWN2hVRHlpVkFBdE9lRlRUWTRFZ2FPRkVtR1ppMzh2ZHNZVEFldzRtSXcvQUxRTElFSEpmU1FQdHczNlFwTElzVlZIcldHZnFyblcxODBWam5aTlNlQ2tsajUwL3hqTXYzVGdFeURkcms4R0kwWGl5djM5d2Z5QkszclV3ZlFidlQ1VEcrZEk2a2RjVlNuaVNPQWs2Vk1EMllFeFI1UnlibTZiS0RVS0ZoQm9CV1R2RDZSQ3YyN0tpTUFaZmxVZ0hVemhxQzN0Vk9DaTIyY3F6WDVQOFhWb0NCNHVhZlIyRUlSSmdSa0xwQlpzRkpJbWs0eDFSRStKL0ZjWWFockdPTTdwbkxwTFBubVo3WXhOVFZ4aGptSnFlQ2R5cVRqZElwMFl4UWdoYXJUWlBQdkUyc2l6ajFzM2I1SG5SaEhjUnN0cmlYTzhhMnBjNEltNnZidExOTXY3eWhYdDVZNmZQRjFadWM0V0NMV2NwZlZqbWd4Tm9MYkZTWUpvd1NpcUpVdUtndXJidlpjS0FXZUNGSFN3LzFTSHhqNDFqeWlxbWpXQkd4WDRoaVZMZjFhZVRTR0VhYXJJQW55ajFMY1ZZZit3Qjh2aVo0M3pwamV0Tm9Jc0FMN1ZTZXJhZG5rc2oxWmtVaHJLMlpGbzNDeUVEVFZ3Z2VIVjlteGFXeGFrZWFSS0Z1TG9LdXJYT1dTS3BrQnFLdkVSSmhkY1J4amlrOXZTY0pjSUhjVVVaOUJzS0N5UDMxaVlYZFFjZTl2OVo4RmI0NFMwNEcvUTBhK2xwUndJaFBMdFdNT1VFcVF2Z2svS09CTjBMVk54aS9zR25HR1p6VFBwREJBNnBGTDJwYVJZV0Z1bDJlK0FoaWlLVVVreE45WGpvd1Fmb2RIcXNyVzB3SEk2YTJYU1BHYTV4ejlSTlpqcUN3U0RrUGJGVzdQVUhMQy9POE1DeFJVNjBVMjd2N2ZGbWY4UWJrekY3cnVhMnFiRE9VVGxQSlVMZlNFWkJmY1VTY2hIVnZPdmFHbkFSMm9kT3B6U1d1SERNRURGSHpIeVNrQ1dLU0FsaVJmWHExdUMxU1drbWdYM2luWGZPcjk5ZTV4QWczOG9ITURWTnE5MUM3QTRPUFB2RnUwNTFkQnlmdTd5K28xKzd2ZVhYK21Pa2dJa055dVRUV2NSc3F0QlVPRHdmZnVVS2RHTGlMS0dGWU9sSWwyU3B3MTVwbWR6Y0pZNEZNU21aamFqS0FoTUp0UExFMmxIV1B0QW5Ja0ZtSWFrOWJyK3laSU5mcTVvM3Bwb3VwaVBvOXVkM2dLVndVSldoQVpnYlIrUUZKSkNwUUM5SlZBaXhaTlJtNnZ3ampOb0xqTWZqMER3VWdxbXBhZWJtNW1tMU80QW5TUk9Nc1NSSndrTVBQc2pzN0RUcjZ4dXNiMndpZ05vNDhzRUd4K1dyektjcDFrVklCVVZaTU5WT0tJdWNxemZXT1hYeUdKMXVtK1BXTXFzUzdtLzN5STNoZXBGemV6em1VakZrV3dwTUhGRWtNYTF1aWphU1ltQ3h0VWNuZ200clk2cmRJVUdSV0VHU2UyTHJtWXBqZWxsRUs5RU5OZDhMWjMxL1kyOXkyWHZ2aFFqcnF6MHdxYzBoUUw0Vmk0NmZKZTU4Q2NUYXZ2cStjMVUxOWJHWHJzNWVYZDgweGxuZFN6eFRMV2kzSTA3TWRGaG9KNlJLb0loWkc1VzhtaGltNzU5ai90NVplak9hN2t4TTRSWEZTc1dtcWhpOHVZbllucERsRnVrZHZWaUd5VGpYaUtaNWo3VWVxYUFYZ1hHaVNiQWxXYXp4M21OcWh6RWVLVDE1NlpsOG5hS1d1eU5YV1NrOTJ6VjB3dW9SbGpQQitSTnpUSjE5bUIzUm9kenJrNll4T282Wm1wcG1mbTZlT0VseHpwSWtLVklxWm1lN1BQREEvU3d1THJEWDczUHo1aTJxdWlaTlUxeXhRM2Z5UEhNTGhyTFVwRUljNk81YVo1aWY2VkhiQWErOGZvTnpaNDZRdERMeXlwSUphUG1ZNVY2SHlreno3dG1LdmJ4a2tCZXNUTTFTRmhXeGwyeHVqdGplR3lQd2RLS0lSQ2g4N2FodGpWY2VGUWxhaVVJclQybHFwQkMrcFNVN1JmSHlsWjNSMWVBOHNJUTA1N2RxQngwQzVCdXp5MjljSWxZSExUTUhjR1YxWTlONy95OTE3UDlNSm5pSEVrUlRuWlNMeDZlWlRtT1Vhd1FOcktlY2J2SEE5eDNqd2dQVHBPMGdhdVlxVDMvb0dBcEJ0VE5oNS9JdXJtK2JYa0hZa1o1SWlFWFlVeGhMU0JYRWtVQXJRVzA4dHZZSUhiYXlTaUhJb3REd2M5YXlWNWRVdnhzekE4aGQ4Q3dlUUhhNSs4VERiUHFNdXFwb3R6T3lWb3VabVZsNjNhbkFrZ1dTT0FGZ2VucWFKNTk0bkttcEhqczdlOXk0Zm92UmFJUlVpdlhWMjV4SnJuS3MzV2V3NTBqVExBaTR5VEFYSHNVSlNxZWNQam5OOExVcmZQTHpyL0g0UTJlWm0rMHdHWmRNOHBLS3NMTnhkaXFsa3lqeVdDUDNLdDVZM1dOWVdXUmw2RlVPNzBBYmk1Zmg5U01kNXZialdLR0EybHFNY3lSYUN1UHM1T3JXNEtQcmc3TFB2cEtKeHpYYWZOOVNEdkxIWGppdUczbHVyVzJJd1dnaUdwcEpWRnNyalhXYnAwNjBGNHFKZldSeEtvMGVPRE5MTjRsd0ppeDJrVUJkTzl6alM5ejMza1dtMm9KV3JFaVVBSzhweXdqckZkTnpiZEp1aHZlZWNsRGliTWdMS2dlNWhmRWQzMHNUd2lGdlF6VkhpbENuOFVwZ3BhRDJNS2tkTzZXbCtpYWF3bE5UVTV5NzV6d2l6dkRPTXpjM3kvVDBERE96YzB4TlRSMzBFcklzdk0vcG1Xa2VldkFCNXVmbjJOblpZM05qaTdLc01OYlEzOXZpN1BTUTgwY0ZlVjR3R1k3cGRGdUIxVnZWZ01SNVFacTFFVUl3MTBzWmpIS2VmZkVhbzNIRjdIUW42TzJhME5OUUtpakwxNVhoMHVVTjNuaGpuYjMraUR3dnlLc0s0eDFKckltMUpJazF1aW1uQTR6TG1zcFlYRkQxRWx2RC9NV1gxa1kvdjV2WG13U2h1REtrY01KM1k4V2d0SWNoMWpkcm0vMFJkeEF3RHZKZnBhUXlsVnhzcFZGNjhlNDV1cG1HdW1sVUFiWjJ0RTUzT2Z2K1JWUUhhaXRKSTRXckkvcGpRVjFhT2kxSmRFU1R6YlU1Y3Y4U0t5K3ZjLzNUTjVoc1QzRG1yUk5lRTdUNGN3L2ozSk9GTmdlcGcxUjZkTE1qWFdpRkV0Q3RCZm5ZaHowaXY0TUpJZWoxZXB3L2Y0RlcxaWFKSXhZV0ZtbDNPclJhSGRJMFBRZytza1pCWkhwNm1rY2VlWkQ1dVRtMnRyWlpXVjJuS2l2aUpLSGVLam5aMmVXeHV6dDRBNU5CUkJRcnF0cXdNRFZGVlJ1Y0Y1aWlaandhRWNmaGVEMXd6MUVpWVhuMitldGN1cnpDd3hkT2NHU3hSeHBIMUVXT05SYm5MVko1YWxzVEtZbldRWWphNHFucUdpMEZOWWJLbUlQbVRsSFZlT213bFJGRFk4djFzZm5VamIxOGhXYTlBV0Nsd00yM05iY0cxYmQwUGc2cEprTGhNVjVJbWdtaFVKSFhXdnNMOXg3TldxcVVVNG5BVjVaR0VCRmZlMFNxT1BiZHg1ZzUzcUxJS3lJcE1EWm1aemRpc0pmamdGWVNvWVVFNi9IVEthZWVQTUhNcVJsV1gxeGo1VXNyRkR0RkVFYVFRQUplUXpHR01peFlJcldRVER4WmJja2lSOVlpckZTdy9tRG5PbCtudWU2YldHNTVlWm5USjg4UVJURkprbkRzMkFuYTdUWnAxaUtLb2tZV1ZCTEZNVUpJWm1lbXVYanhQTE16TTJ4djc3QzJ2a2xkMVJoaktJb0pSMW83dk8zY0hLN0tLY3E4MlRxcjZmY256TXo5LzlqNzcyZkx6L3ZPRDN3OTRadE92cW43ZGtJMzBNaUJJTUFnTVlsSkZLWEpIbm1rQ2RxeHZTN1h1c3E3OWdTUGEvK0J0WGQvY05qYXRjZEIwbWhITXhxS2tpaFJsQ2hSRkVtUkVBbUtHUVFJRUVBamR1NmJUdjZHSiswUHovZmN2b0NvOGxpakdSSlNQMVdudXRFSjk1N3pmTDZmOUE3YmFDM3h6cEJubXFveUxCWk50RW96TldkUGJaQkl5WE12M3VCclQ3eElwOWZoL05rdFRtNTA2S1FhcGFKS1BDR1FaMGxyeUJtMzdOWlpsbFVrUTduZzBTcU9Lb3czTEJZbDNucThVTTljbnByUFdSOFdiZVl3b2gwQUtpSENuL1o2L0lVdnNiWTNSaVJwWURLdGhQZCt4VUhQN2p4L2N2MC8rdy9mKzJIZnpPK29abVZjUnJXZ08yYzhvL3ZYdU8wRHAxQXk4cUc5NjdNL1R0aVoxcFRPVWJmMHowVEY1dFhhNkFLYjlsS0dwNGIwVC9RSklsQk5xdWovdmJKemFvT0ZnY1QzTmFhamFRck5zaTJ4R3V1WmxZSGFmdy9BYS90WGN5azRmdklVNTgvZmpaS1MvbURJdVhQbkdJMUdaSG1PMWhydkExb3JzaXdqVFRQV056YTQvLzU3R0E2SFhMbHlsV3ZYYnVCYVgvS3FyRWtXMzJFcnVjSFpjN2ZqVElYM0RvOWlNcDZ4V05iVWpXRmpiUkQzRmo3Z25hTXFhNnB5U1pLbUtDbm9kWEtPYncxeDFyRzNNK0h5OVFQRzB3cEVJTkVKenoxL25VdFg5cU8zZTNBSUtURFd4U0VHanJLdXFZM0JCOHRzc2VSZ3RzQVloMVo2dXQrRWYvYk03dkpMM0xSWE13TGNxTkNoU0NTVHl0M0tJSCthOCszblh1Yk5ENTV0SWVCQ0NCRkVDSVR6WjdjeUlVU3ZxUzI2OVRrUElmcG9CQ1VZM0QwaTZ5VjQ0ekJod0hLUk1wblBDQ3N0TE91cGpjWDdxTWdSRjFlT3lqaWtsbXljWDJkNG9zLzZiV3RjL3RZVnBydFR2UENRUitHRWJKU1I5VHNrV3FPekJOOXlMR3pqRUF0RFVWbk11TVl1b20zMFN0RFpTY21wWThjNWRkczV2UGNNaHlQTzNYNDcvVjRQcFhYclh4NFhubWthM2E0MjFqZTQrKzQ3NmZmN1hMcDBtYjI5QXc3R0J4UlpqdkdCL2VZWlBuek9ZMmVLdmIwOU5vWUZXWmFRZFFQWGQ2Ylk1VDQ3dS90ME04VncwRzlGcytQM3JFUkducVdBUjBxSFRsTHVPWDhjNnh6WGJreG95b3B2Zk9jeVplWDR6bmRleFpvS1ZEVG8xQzFLMXpxUGM0NnljZ2poVVVLeXJBMVpxa0l2VDMzdHdtUFA3VldmYllPaldqWG9VZ28vekZYWTZDUzhPcTV2QmNpZnVzcVM4dlVQWWxrVWFiSllMQkx2TEMza0NTZGlGWkNPTWpidUdVVVhLZEhGMUgwT0ZsT2M5NGZiYW9uQWVFZnBmQVRsSGVKbkJVRkdwVVdkYTA0L2VwSzEyOWE0K0sxTFhIM3BLc1kxMEFTQ2hUUkp5THM1YVM5RHBrblUwVTBVTW9zZWY2NXFhS1kxNWQ2U3hmVUZkdHB3WW5pUzQ4ZFA0TnZkeHRsejUrajMreWlwSW5vM0JMSThKODlTcEZRY1AzYU1lKys5RzZVVUw3NzRNc3RGaVRFTnMrbVVzWjF3V1Q1UDc0NGI1UDJIMFRLaFdrNlFtME1JVUJTYU8rKzVoeWVmZUpKNlBtRi9PbWR0YlVqd1VVSzFLRktjVCtMbVc2WUlMTXV5cGx0a1BIemZhWkpFODhJck81Ukx3OU12M3VENXF4TVNBWVZxU0ZYMFhQUUJqQUVwNDQ0blNRVzFkU2d0UTU1cWdaUVhMMDdNTDg0YnQ5TUd4OHE1Tm9RUWVQbWdacTM0MDEveld3RUNqQWI1eWpoeU5lOWxPTWh6b0tObE5MK0piYUhBdTBDMm50RmZ5MG1RVEVyQmxjbU1wV2xhSDVDV1p5RUNXZ2hzQyswMkxkNHFXaGkzckQ0aUxpa2ZaZHorenRzcHRqcGNmZTRTMWFURVRSb3FOVWRySGMwM0pTUkZTdEx5WjZVVTZLU0RFdUN0cDZrZHhmV1U1Rm9DSWJCMTdCaW5UNStoS0RveE9GcHdWcFpHZ2VzMHpUaTJ0Y1hwMHllWnp5UGN4cmQ4N2FZeEtLbTVNUDgyNXA1TDlIc0ZsUkRjZWZJMnJsOTdpY1ZzVExjN0pBVEIrc1lXWjgrZTQ2WG5ucWFwYW1abHhhRGJ3WmxXTHpvRXZMVzRFRzJ3dFJJeEN4SzQrN1lOK25uS2IvM0IwengvY1M4NlA0UkkvVzE4b0RFQktTSWprbGI5MFhsSUVrV2VhcEVteWQ2NDhiOTBjZG84MDVaVmg3N25XYUw4WmpjTjQwWERONjhzYmdYSXYxa0tlWTErdXlBS2Y0amxvc1JhRzMzOFZsS2NRRHJLMFluRU94Z3ZMZlBLQUlJODBVaS9BcXlFd3dzblJLU3l5aFlINVYzcmU5RXFjZmdXaXI1Kyt3WnBMMlAvcFJ2c3Y3RFA0dnFpdFM2SUVBeWRSWGlrbEN2elM0RktKRVdlTTV4b21sMERJYkI1L0RpblRwMm02SFNRaDJQUlFLZm9rTFlCc24wOFpvN1pkTTd1N2dGU1J2Tk1yUlhlQlM0dW5zZmZlWm4rV3NMU0dXNVFjWS9LU1pLQzVleUFCQThxdzN2WTNPZ3ozbHpuK2FjdnNMU0NCKzQ5UnlmTFdTNHJySzF4VFNSMlNTV3hycFhtRVpLeWRGeTZNbVh2NnBqdFhLSzdFcTAwemprV3RZbWFZZ2hVS3h3bkJLUTZtZ2l0ZFl0bWJzT3ZQSC85NERmYXhudzExclZTQ24rc2wvR20weU4rNjhrci8yWklpMXZSQWZnL0RrUElzMHc1NTdVelVlalppNGpjRFQ2Z2MwMlNwVlMxWjlHRVZ2ekFJNlFtU1ZOOE1GZ1hzRExDckZmY3ZlQWo2QzYwMXNhaEhSYzdGelZ3QVRwYlBaSk9TbEtrWEh2Nkt1VkJTVm9zVUtuQ1pScVYrQmdjV2lJVTVDSWxmVGxoOXR3Q3BUWEhUNTdnK1BIakZKMU9oT0NIUUpMRWpKRmxHVVZSc0RZYWN1N3NiU3lYRmJQNWdxSW9NTWJnbk1NYXh6TVhudVQ2MWpPY085RWhlRUVWSEJmbVY3bFBickc1ZlJ2ajNWZDQ1WldYR2ZTR0NKM2d2ZVhZWnArTGd4RXZ2ckpIbW1nZWZPQnVoRXFSMHBBVU9iWXhWSFdEZFFHbE5NWVl2dlhVSlQ3M2g4K3dYSmFNdWptNmhjUDdvQ2d5RlMzWGhFQnJoUklpT3RsS0ZYcEY1aG92UHZQTXp2aGo0OUtNai9RZXRwWDVDbVZ0d3AvRjFiZ1ZJSUJLc2orV1U3eDN3dnNvRldwRCs2NkhWdVJBUWtCaGJKUzg4VDVnck1QWWtvQ2tzZzdYVHJIaTNEaG1DV3Q5ZEpOYUdjUjR3TWJnY0Vja2NKSnV3c1pkeDNHTlkzTDVnSHBlb3JPRXJKTWhDby8wQ2tXZzc3dHdBYWF2eEZKcysrUUp0cmRQa09jRk1uNlJwRWxLcDFNUUVIUTZIYlkyTnpoMzdpeVR5WlRGWWhtRHdqbVVVbFJWemUvODVtL3lrbjZDKzk5eUV1VkRpN3lWWEd6MmVHRjVsV09qTlhyOUlhL2FxMXkvc2NQR3hoQnJQRXBwenQ5K2dzdlhEcmh3NFFxYjZ3TkcvUjVLQ3FSUWFPMlFCa0x0MlQrWThxV3Z2Y2lYdm5LQnBtN29GaGxTS2xJdFc0NUhJTkd1N1YwaWxVMUxTWm9rSVU4U0VRUlBmZVBTL3YveXlzSHlZcnMrS2xlTnVaTEMreENDRU9MZk9IdmNDcEQybkwvOUJGLzQ0ak92NlVIU1JLVmF5Z3dCSnR5Y2gwc3BDSTNIR3MraThUVFdJNGtmcEhVZTUyTjliYjBqZUlseGdib05ER2pMSzkvYUliUzJvTXJUaWtSNy9JcjZvQ1dqMjdmUVdsT09Gd1RyOE1zR2x5bDBKaGd4SkwyUXNmZktBVVczdzRrVEo5bmMzS0lvaWtPTXU5YUtMTTlSU3RQcGR0bmMyT0RzdWRzNE9CaHpjREJHYTAxVlZZUUFTWnJ5N1M4L3poUFBmWUc3L2s5bjZlVzZ2ZHh4TW1Id2ZLdTV5dTJUUHV0U2NOdkpUVzdzN21HTW9kL3ZrM1dIYkNxSkQ0RXYvT0dUUFBIa0N6enk0RzEwOGdKbkRhYXVzYlhueXRVeG4vL1M4M3pycVZjQWo5WVJheWJhY2xPSnVDUVVUclFXMHl0V3JneVpWaUxBNVdkMzUvL2JTL3ZMQzhUZ1dMYUxRU2NFNGN3dzU5eDZ6dWRlT09CV0J2bXp5aUR5aittMWlrUW5Va21oRHIzQWcyanBPYkM0UEtlWkdWQWEwM2ljOFFnWERtSHBrZFVxcUwzakpnS3lSWHExVUJKdmo3Q0MyZzlpQlJpU0luSWlzbDZHR3hhSUVEQ2xJVmlQS0MyamZBTzFrN0IvZVV5bjM0dkJzYkZKbHVldDRXVWd6M0tFbENSSlFuOHc0TlNwazV3NnNjMTh2b1FnOE43VE5BWmpEYlp4ZlAwTFgrQzduL3ROVHIxL3hQcVpQaDBWUGRoOWlQNkN6Z3FlWCs3eG1IeVZ2OVE3aFpZdzdPUk1GM0hQMFNsU2hNNjQ5NzY3V0pRTjMvam04eno3NGhWdVA3VkJNSUd5YkxoNDhZRFBQUFlzejc5NEhmQlJCZEVGOGl4cTVtb1ZLUVhPK1VOeTEwcXFTQXNwa09MS2kvdkwvL0dibHlkZmFNdXErZEhHWEVCNCthQU02NTNreit4dTNBcVExZnI1ZFdlK21MckZVdHYyd1kvMU43MEVxNTJTeGF0THV2Y2N4L3VTYW03aWxDVlIwWHdtQkx5THVLcm94QlR4cEM3NG03endFSTF6VmcyNmJEM1VZek1hTVVySVNDS0tqYXBBcFlyTjlCamljdHk1OUljRHRrK2NaRzF0blN4TFkzWURldDFldEdLVGtsNi96NGtUMjl4MitqUjFIZUVXU211eUxLY3NsMWpqZU9MNUovakVwMytOL3JiazdKdU9SeE1VSldsY1pFa21JaW91aENCNFlySERiV1NjcDROckRNSWE5bmV1RTV4bHVIa2EwMVRjZTljcGVvWG04NDg5eWU3ZWdqTWJQYjc1NURXKytjU3JYTDAyQmhuUVdwSWtHcVZFMUN4dXpYWUNZRjNjUFlXV3BxdTFCQ0V1WDloYi9uKytlWFh5S1JmQ0tqanF0dTl3UW9pZ3BRaldlNzUrZVhvclFQNHNUN0RMd3lmOTZ2UjYzVVFuSk00SExJSjBSY1FRQVZkWmRwNjZ3ZHJwSVY2Qms5QXNEYUlUOERwT2FseHJjMlpkaUJPY05qQkNLMEFnUkt5dGhZLzBXR2M5UVVTUmhkQjZHY1orUnhCOEpCQnQ2ZzNFZnNKaXRtUXdHbkxpeEVuV056WklXdFlmQ0RwNVRwYW01RVZCVVJUY2R0dHBOamMybU04WGVCOW9qS1ZwR2tMd2VPZjUwamUreE85OTQzZndweVRadTg2Z09wcmdBNVdKcnJkYUNpSndPYUFRVk5ieXlmRmxmaUk3emptUmtTZ05VckNZellBYkpLbW1uazdZR0NTY083WEJiMzMyTy96R3RXZVpURXJxZ3dWNUswT1VhMFdSYVZJZDZieFNScUZzS1dpTmV3S3FaUmdDdTVkbTljOSs1ZEw0ZDBNSTg5ZG5EaWxGRUNIdVBYejRzNzBidHdJRXdLK0FiRGM5anJJczFZUmFOZGFqWW5MQU9ZRnRuM00zbnQ2aHVuc0RrMlR4TjlPQU1RNEV1TVppZmFEeDRKekh1SnVUSzlGYVFRY2ZNVldKYXIwNTJrREJSd0ZkWjZLa3B3aWVidEpoSXp1RzNZZktWWXcyMWppeGZZTFIyaHBwa3Nhc0pBU0RRUit0TlVYUkljOXl6dDUyaHRPblRqR2R6a0FJckRXWXBzRTVTNWJrUEhIdDJ6ejI4dWU1dm5PTlJHcHU3OTZPeE9OODlFcFBWV3pMbElqd0ZYeXNZK1lZdm1qM1NPUUdteXFoR0F3UUlUQWI3NkNVd2phV3k1ZjNtZXd0eUx4Z3NqT25xaTJORUN3YWo1YUJUckI0R1pBaUlVK2pWMkpqTFNFdWlXTFphd1JMVTEzZnI4elB2ekExdngxQ1dMVEJVYlo5aHhWQytMVWlaWGRSL3lrQjdiY0M1SC8zWEx0aE9DS2pCc0IwdW1oUzI1aVZFWUwxOFFubjI4Vkd0YmVrK2V5TGhEZWZnVTRPU3VKQ1hOcDVIM0RHNDBQczhHVVFHTitXVUt2cGxvK05lOVR5Qlc4allZb2tsbVFpUkR4VFIyWVVkTEJqZ2ZPVzlZMk5hRll6SEtCMUJCeW1XVWFuVTlEdDlFalRsS0pUY1BMRU5pZTJ0NW0zazZxbWFhaWJHdWNkM2dhZXZmWWRIci8yZVlydG5QWDVGdk1iWXhJWlNGVmNkcm8yR0tLS2hVUWg0ODliMk0xT2FQaDljNE1mMGV2Y3E5Y1JRcERsR2JzNys0d1BLcDUrL2pwZmYvSVMxMjZNT2RiTk1JbkVXRXRqSEUwSU5OWXpMeDFONDhrU1F4TUVwWEY0SDN1b0VLdTdneVhoWjYvVTRXTUJwc0NNbXhNckY1OHJnZDFGSGU3WTZQSGkzdnhXZ1B6Yk9BZnpha1hhWHZYWXdUbHZ0VlpPUzRWMWhpck9lbkUrb0NWSUo1aDhaNGZadUtIM2puUElORUhrR2kvQUMwbVFVV2tqL21PKzlmT09YUGFvRDlYQ0tKeHZaWHNDWm1GUW1VWjFFcFNFM0JiNGFVNDFOZ2poMk5qY1pQdkVTUWFER0J3Q3lQS01UdEVoeS9ORENNbVoweWZwRkIzS3NxS3FhcXE2d3JWNHB1RGd3dFh2OHZYeDUyRlFVOWlVM25xWDRDeEZvZHBwWFF3UUV3SkN4YkdhRXBKTXhlbGJDSkgrdTRmalUrYUEyVFRsNFhUQVlscXh0MVB5NHN1N3ZQanFQb3ZLRUtSa2JocXFzbWw3ckVBcTRzT2dNWjZsaVQ4Nm9Ea2locGRvTlhGUy9zdjl4djFXSU15T1pJNFZsTVFmVGZ2L05vTGpWb0MweDdsV1pmQm8zeTZWVFRSMkJRcXhJUzc1alBkYzI2dTVzbGRTMTQ3aTRwU1R5NHF0ZDUxSGhBNGkxNjFOc1dnTk1GY3FpRkhrVEF1QnFReHUyUkJrbkl6Wkp1QkVRTGNxYjBMQ3dQVXhMM2dXMTJha1djYldzV01jVy9seHFQaXg2U1NoMyt1VEpFbGNBdVk1Nitzam1zYmczWklzenlpcktnWkdpSk96RjNhZjVZOG1mOEJjemVsM2MvQ0MrWDZHOXdXZGJvSkN0TDZBQW8vQUJRRkJ4QjZ0dmIreFI0amw0SjQxL1BieUVzOHVjelp2TkZ4N2RZLzkvU1hUZ3hKYk5iaXFBV3RJbGNDMUkzTXZCQTVIVUlJOFVSU0pCdUZ3YlkrbkV6MnRndnpGQytQNkk2WDErMjF3TEk4RVIzaDlUZnh2Njl3S0VHQStXeUplbTBIOGxXdmo2WHFXalZlaDQwTGdZR0Y0NGZLQzhkSnlhaXZuamt6UUU0SGx4WDMySGc5MDNuWUgrbmdmNjZJMFNYQWhjaHBhOFpsZ2ZWejF0dG1FRmlGY2V4ZjFjUk5KbW1kMHl3NzJsY0QweHB5OFU3QjE3RGpIangrbjArMGlaZlR5NkJRRmFacVNwbkU3UGhqMk9YM3FKTTU2bG1VWkY1aWxwMjRkbmtTUWZQZjZVM3h0L0htV2FvRjNFcThGM1Y1R1o1QlN6aUZMSkptVXJiR25RSW1JUGZQQjQ0Vm9UV3BFVkVvUllGMmduaHV1WFY3eTVRc3ZVbCtlc041NFJsNmpURlJPZE5iaEc0dnpnU1NSZEZQZDN1cG9ZNUFtc1ZIMzN1RkNDRkxJcWtKKy9NV2Q1Y2ZtdFJzVFJWc09keDJ2enh5M0F1VGZ3YW5xWnJWY2kwUi9DTi82enF2VGUwNmQzOUd0VVBOa1lmbldDMU9taTRZUHZubVRSeDdhb0trdE81Zm5ORmNkeXhkdXNGTjdpdmZkVFQ3TWNkWWZ3a2RpcnhGWDhzWjV2UFU0SmJIR1JXWEN0bmxQbGFhelg3QjRzYVNwREwxK24rM3RFNnh0ckVmR1g5UUtwY2h6dXQxdXkrVklXVnNiY3R1Wk03Z1FrY05DQ09iek9Vb3J0TkkwMXZMUytMdDhZL3FIMUhLSjhwTFdxSW1nb0xkV0lCaVFKMUVlMUxkR09sSUlnbS9oNXUxT1FvbEFRRklieC9pZzV1ckxVL1plblRIZm1iSy9QK2FsZ3dxNWhDNmFWRUFoQTRXTTMyT21GWW1PbzEySmlOQVNLVkFTckJkQkJoaVg3c0ozRDVhL09xM3R3WkhncU51K0kveTdESTViQWRLZTk3M25JVzc4K2hlcEkzNG5BUDVndktqWDFrZFZ2Wnd4WFZSODU2VUpPNU9hdTA4V2JQWVNqZzBWSjg1MldONlg4YW5mcXBsZHJ1REZIZmFiUVBHdU8raHVkaEV1Z1BVWTZ3aTFRemJ4U1d5Y3YyazdFQ0dzNURvanY1NHh2eHhWM1h1REFkc25UckM1c1VXYVJjYWZsSkpldjBlU3BIU0tBbU1zeDQ5dmNkdVpNNWpHWWhwRFZaWE1XNDhPaU5wWkwrdy96VGNtZjBnbFNrS0kvbVNKa2xIS00wQ25tNUVWb3dqckNBTFZ2Z3ZPUm1sUTUrSit4cmYxamJHV0d6Y3FkbDZhY0hCbFNqMnRLR2RMN0t6Qkx6eW1ndG8zb0NETklVa2dTUVFMWWVoSjZDU0tya2dJU1JUZ0U5NFRuQkNMMm5OMTFydzhxKzBlTjVXTm11L1ZjOXdLa0grSDU3M3Zlb0NmL3hlZkNTMm8xNGVBbjg4V3RWQnFEREk4L2NKWVhMeGVjbnc5NWRSbWdYV2U2WjdsdGpzSzN2UlFGeVdPOFpzZnQ3eHlhWTU2K1FiVnNtYjUwQ21HNXphaWpiS051eEN6ckFtcEpraEphQ0pBVWl0SmJuTFVLNUxGZm9sVWt2WE5UYmEzVHpJY0RrblNKQzRLcGFUVDdjU3NrYVRNRnd1MnRqWTRjK28wNWJMQ09rZFQxM0c1SmdWTjNlQkt6NDY3d2pjbVg2U2hKQkhSRVZiSjJGTzBmeFNsQlVXYXhJRmRpenV6TmtTenpEYUFmZXVLdTZ3OSs5ZEtkbDRhTTk5ZFVpMXE2bmxKTlMrcFp4YlhhcXBIUTlDNGhEVkVkUE5ZZTBwdDBScDBJa2t6QlZPTHZyNUVOcDVKaE9VK2h4UUxmS2krMzhGeEswRGFjK1hhQVhWdGdwUXl4RUU4enZ0Z3ByUGxpeGRlSGU4OCtjTGtXSllLenAvbzBNMDBQc0N5ZEh6cnEzT09ieC9uN1crVnBCbys4aXNYdWZEU2dteDN5djVqSmRYdWdvMEhUMGEwcmd1RVZJTVhCT3R3UGtJdHVsV0J1Q1JZVGtyU1BHTnpZNVBqMnlmbzlmdG9yUkJDa0xhYzhpekx5ZEtjcG1rNGVYS2J1Kys2aS8zOUE0UmNvV0FqNDFGSmhaYWFiMTkrbkJkNEJxc3F0SWcrN2l2L3pOVlFPNHBRQkdRaUl4U205UzJVZ1BVY1F2U2RoK1hDY3YzS2t2SFZHZlcweGpxUE5aYTZyS2ptTmU1SUVTU09lQzBvRWUzZmRJdEM5dTBvck5xcnFhK1Y2TnFSQWs2SXVSTmM5RDZVUjNxT293aWVmK2RIM1FvUCtOUm52dGwrcUdMbGJxdUFiSGQvTWQrZExZNU41ODNkWjdZS2NXNjdLMUlWbS9hTllVcTVNSGpSNFk2N3R6bTk3VG0ybGZIc2hTVUhFNHNPZ2QyTE0rWmxRMmVyRXoxRkdrK3dMbXJOR2tpbUNWd0dNemQwdWgyMlQ1emcrUFkydlg2RWlnZ0VuVzZYTE04cGlnS2xGUFBsblB2dnY1Zjc3cjJIY2xranBFUkppZk8rZFpYMUJBTFBqcC9rbWZMck5KUklvVnFQOU5DaWZGZUJFc2RTeG5xa2pzTGJTc1RGb0d3dnR3OVExcDd4ZnMzdXhUbXpHMHRzYVRDMXBWbldWTE1GaThtU1p1Ymp2dldJU1dnSU1Zdm9GTkpNa3VRSldpZG9LWEV6ei9KYWhXLzh6ZTJUa3E4R3JUNVJPWCtSMTdJRC9mZnJidHdLa1Bhc0RRdXM4NklGa0dvZzM5MWZORG9KRCthSmZPVGVzd1BSemJWSXBVQUU2R1NLZmovRkd3TkJNbHpyY2NlNWxQdnY2Vkthd082KzRlRUgrcnozd1lRZnZqUGgrUXRMWmczUlNxMVJGQWNGNFZvZ21IQ0lxVHAyYkRXcGlwa2pMd3FTUkdPdG9hcHFoSUEzdi9sTm5EbDltdGtzTGdEakVNQmhyVVdLMktEUTJlNEFBSUFBU1VSQlZQZy9jZjNMZkczbk1SYTJRc2pZamEvUXhKTG92bnZvWHhNQ1ZlTkpFMEd2bzF0VHo1dUJzMWhhOXErWFRLNHRLYWMxemFMR2xBWmJHdXJaa3VWa1RyT3crQXJDaWxiVFVnS2toaVNMTDUxS2tqUkJxNFJxeDFMdk5qRkZyY0FNQUZJOFVRbCswL2d3YmdPa09aSkJ2aS9uVm9uVm5wTW5oano5N0xWVjYrd0FJNld3UlphRkU4T0VVUzhWQXRBaWJzR045YTBrcUdQLzJnNlhzdzN1ZlhpVE56K3FlZUxGSmVrbzViLzZMODRpTzVMLzZaOWU0dXNmZjVXemR3N29uTm5HakJWbVlSQktNaHlOMkQ1eGd0Rm9qU3pQa0MwQ1YrdUVOSTBlNFBQNW5MVzFOVDc0d2ZlUlp6azdPL3NvcFZxY1ZxdnlHQVJWWGZIMXkxL21Xd2RmeGxtRGJCeEJTWUtMMzVDUTRQSFJkUXJBUjdKV3MyaWdreUpGTEtVQXFzWXhueGxtZXpYVnVNRXNEYTYyMk1aUmx3M052S1NhTFdnV0ZsdUJOM0RVeGtxcW1EbDBBakpWNkN4RkNVVjVyYWJjcjFrOWlZaHZka0JnZE9DWnl2b0RWcXFJclVhWi9ENm1rRnNCMHA3cHJDSlBGVlhqZkN5SHNTRmc3N25qK1BYalhlOXNZL1ROdWgyYU9uTE54eFBMc1UzRmVHZVBaNStvR1p4WjV6Yy9lOENqYitueHJhY01GNTViOHNYUFR6aS9tYUtxSEg4bGFma1hDYU8xZGJaUGJOUHZEMGgwRXZ1Tk5LWGI2ZUtjUTBuRmVITEEydHFJRDM3Z2ZmUzdmZmIyeHdnQmRWV1JwdG5oNG03M1lKZXZYUDBpMzUwK1NmQXVXZ2xrQ3VkOTNQNXJnV3BoeXdFWjl6QUJHdU9vU2tQdzBVck9lYWhxeDN6YXNCdzNtRmtzcDJ4dGNiVUY2NkpZeEtLa1hEVFVpMENvWDN1RGhZaTJERG9IbFV0MHFsRmVVVjZ2cVNmbTBNam1jR1FZS2Z4WGJmQi81T1BreXRLeUF3T3dDZHk0VldKOS93UGsrTEdlV0N5TkNFRklJWVFHa3R0T3JZbFRXOTEzbXFwZUUxS3NQR3R3THRBdEZOYUJ0WUgxOVFSdkd1WjdDM3FaNE9VWEYzejdpUVhYTGk3SnRNQWxtMWk5aVF1U0xNL1kyanJHaVJNbjZBK0dKRzIyMEVsQ25tZGtlV3pFeCtNRGJyLzlITzk3MzQrUVpUa0grK05ERk80S0xTeUZZRkhPZWV6bHovTGt3UlBZeW1CdDNHVzBqVWRyQlNoYUY5d1dkT2hpNXFrclI3VlhvWU1qSDJYTUY1YloxRkJPTFdaaGNZM0RHUjlMcThyRXZtTmVVaTlMVE9Od1ZmUXB1UmtkSUJKUVdWUWdVVnFpYWtGMXZjSE83ZEdnT0FSVUJWZ0krSWlGM3d1dkJTUDZyQzJ2NmxzWjVQdC9uSXVEVGlHQ0R5Rll3SDMzaGIxWDdqODMvR3FhcWJQR3REMktqRnZ5K2R3eTZLZnM3bHUycHdtZGdhZXNESS9lMWVQQnMxMTg4RndmU3o3N2JjbDROL0k2dXQyQ1k4ZTMyZGpjcEZOMFVGcWp0VVluQ1ZvcGhvTWgwK21NOFdUTXZmZmV6YnZmOVU3S3N1RmdNbjVOU2VWOTNGSXZXZkNWcTEvaytlcTdFVG04akpkUWVBOVNvWFZFQkJzTFBraUVETWdRclphOWpmL1dxUFlzbjlwbmNxcUhyWHpzS1JwSHNCNWpQTmE0NkdYb0E3YXgwU3JOK05oemhPaVJHRnBkTnFIank2OVN3eEthc2NHYmNPaDE0bSsrd2pCVllaanB6MTViTkI4N01yMnlnSmRTUkZWRTkzM3IwVzhGeU5FanBZencwQ003c1dzN3M4WHUxSHh4czl2NVlITXcyMUF5WGdZcG9hd2RnMDdjakYrNVpsaTNndi9wMXk5eGFpdmp2dHM2OUhvakhuOCs1ZnFCSTAxVjY5NTBuTkhhR2xrVyt3MGxaZlEvVHhPS29tQjNidzlqR3Q3MXpuZnd3QVAzYytQR0RvdGxHY0dPSVNvUW1yWWhYOW9sbjd2NHU3d3dlWWJGd2xIT0crcHhpYmVPWXF0SFVtaThDOGdRQ000ZGFuYXBscXhsalNjMGprYkR5ZjJhdlM5ZlE5MjFqdk10S3RsNXZQSDR4dEVzR2t4dE1jYmhRcFNMOXE3bDU3Zk5oSkN4OXdEb0ZTbFpBL1hFUkJSQkd4eVdRK2M0T2hMeDZDaXRCbXVkUC9ya0N3Y0hNbEQ3RUF3dGpQMzRJQXQzSHV2eXhITjd0d0xrQitHRUVPVTRyWFdIQWVLZE04Ky9NdmxPNzY3K2Q5TkV2Y3NiRjJSQUNDR3dMckNzSEltV1hOK3BPYjdaWTNzdDVkTmZtL0RFaXdtYm14S2hBNTFPenRyYUJzZU9INmZmNzBlQ2s0d1NQa0lLaXFKRGxxWHM3Y1dMOE43M3ZvZDc3cjZIcTFldXNyZDNnREVOYVpxaGxJeEMwanJsMnZJcWY3VDdSVjZzbjZlZU5PeGQyT1hnK29URi9wTGU5cERpeENDV005WmoyNFdnRkI0cjQvWTgySUJ0SE01NkZORFZnczZUZSt6dVZkUjNEUEZGR3NsZGJTbm1XMFN5V0ttMHREYk52cm1aUFZDUUZwS05mby9iaDF2c1hadHd5ZTBlbGxSSEZ4b2JDZHllQ1U0V2V2Wks1VjQyTGhoQk9CU2RKZ1IvYlZLRmQ5KzF6bVBmeHp0eHF3YzVjdWFMbXFKSXNkWUpnWkN0ckhReVd6VCtqdFBEOVNMbExkWTZ2WEo2SXJUd2R5MlpMZzJwbHFSRndiVjVqNDNOTFhTUzBPdjMyTjQreWZFMk9IU1NITm9OZERvZGVyMCtaYmxrUEI2enRyYkdCOTcvUHU2NC9SeFhyMTVqZDIrZk5JMU52ZFlhS1NSYUoxemN1OFFudi9zSm5yL3lOTk1YRDdqNnpEVW0xOFlRb0R2c3NIbjNNWXExUXpHOG00dkJRQlRTOWlHV1Q5WXhNbkRQZ2VIVkN6c281em5sSUZ5WllaWUdheDBHYUVwRE1EYXF0OVFHMDBTdmRsY0ZmTjFtMUJTRzZ4bDNiRzV5MS9BRWZWVVFCT3pNNTVnV3k3V0tvMjBGZHhXd2xTbldSdjNMRjB2MzYxZW0xUTZ3RkZCTEtlekpVUkdtcGVYcEs3UHY2NTI0bFVGZWQzNzhnMi9tYzQ4OUZjYVRoU2RnZ0hvK0w4djl1ZnZHNkhoNlVVaHpKOTYzcXV4UmxMcXVMQ0VFdnY2QzQ0WVpNQnBHQjZsK2Y4RFc4ZU9zcmEyUjV6bFNLWlNJUW01Rm5sTjBDcFpseVdReTRmYmJ6L0dqSC93QWE2TVJ1N3Y3R0dQcGRqcEFsTzVwbWdiclBDOTk5enY4K2kvL1BGZjNYa0dVRHJkbzBNSFQ2eWVFczJzVVd3TjBxcU1CU2V1REx0b051eEVDSFdJdllIMWcxQVR1dUY0eWYyV1A2YkppYkFSbk4vdWNiQXpacXhPbTFyQ2JhSm9pcGM0VmhrRFRHS3BsUTdQd3VES0tlUmREeWNaYWwxUDVCa1BWSVZjNVdpczJSMFA2K3dmTTl3L3diVmwxWE1BWkJaa2c1Rmtxa2p5NU1OK3ZEa2U3SVdhUE1NaDF1UHdEY0I5dUJjanJUcHBLMXRkNmpDY0xMeUtKMEFMMjhXOWVldm5zajkvMWpGRHFEbU9jdEM2UVNrZ0Z6Q3JCamJyTHRiTEFCVUdXeFJIdThlUEhHUXdHcEdrV2plNWI3clhTVVRSNmYvK0FwcWtQZzJQUTczUHgwaFhxdXNZYUcrVkMyOUZRa3VWODViT2Y0YmQrNFdlWlg3K0dicVZMazNaWUpmWnJSSG1EY0hXQ083ZE9mZHNhY3BBak0wMXdBUzBEU3NUQUVBRk8xb0ZqVjVmTXIwMVlHc093U0ZrR2cwWFE3V2FVZUh6cFNXdkQrckpoMzhLZUNvd1hOVlhsOENaZStHSk4wdThVbkV6V2taV25TcHQyanlNcHNvemp3eUZYSjFNeTd6Z2xZQjBpa2xnS01lZ1Y1Y1R4bGVkMzVwUFZhSmZvRmgyZXVUcjdnYmdQdDBxczE1MlhYcjdDOVJ1elEwbW05ajNLNnRwdzV1VGFvRmVJdDFTMXlRU0lWQXFtVGNhTHN4NzdkWTZVbW02dnk3Rmp4OXNSN29Ba1RaRlNJb1ZFU1lWU0d1YzlpOFdjTk5HODdTMlA4dTUzdlpNMFRibDgrU3JUNll6Z28ybU05N0VvS2N1U0wvek9KL250WC93RmxyczNTRlFjRW1nZEw1dldrS1pRSklHK3RmU21DNG9iRStTeWlhV1FpbG5MZTlDbDVaNkRoaE9YWnh4Y24wYWZjU2xSQ0RJbFVFSXlHdlRRVWlLa1FxbjR5bVdnYUF6ZHhpRWE4RTRnV3A5M05Rc2M3dzJSU3JGWUxLSTdyb2lhV2tvcHB1TUoyOWF5TGtBcHlCSW9VazJ2bDErOGJ2bTE1M1lYRjl2UmJpMEVKcE1pRExTaTlPRldnUHlnbkRlOTZjMXhnMXd0a1JIRXV2Sk5UNFFnQlhJWGdqaDNzditvdC9hWWxvSkpsZlBLckV2bEU5SXNZVFFhY2VMa0tUWTNOeW1LQXEzMG9UcUpsQW9wSmNZYTZyb2lTUkorK0lkL2lMZS8vVzJFRUxoMjdRYmo4YVJWVjRuUUVHTWFadk01di9QUmovQUh2L29Sekd4TW9rREpOakFVSkRxS08yY3A1Q2xrcWFUUWtuNkEvcndtMjF2U216ZUkwcUpzNFA2NUk3czQ1ZktOTVZLckNFejBrQ2VhUEVuSmxFSktnWmVDUmRYUU9FOWpMZFBsRW1NY3ZVTFQxN0NlU2ZwQ0lKb0FqU01ZUzcvZmk1ZEtTYnFkYnJTdUZwRE41K2lxZ3ZiclRsUG9GeGxGci9qYWwyL01QekZlbWpGUUNrR05FTjc2NEFzbGZ5QUM1Qzk4aWZXdWQvOElCd2Y3dlB2ZDcrT1RuL3c0dTdzaDJxR0h3K3loUWtBS0laSlhMbzMzcHZkdGZsdUwvSjdMazBSUHloU1BwTnN0V0Z0ZlozMWprMzZ2VDVxbWlKYVpGMExBT1ljUURpRUVUZE93c2JIT2UzL2tQWnkvNHc2cXFtYi9ZTXg4TnNjNlJ5b1R5cXFrMSt1eFA1L3hxWTkraEsvLzNpZkIxS1E2Wmc0bDRrVlRiUmJKRWxCU2tHbEpvaldKVkZFVlJBbHlwZWlVRGFrVGpJSmlPYSs1T0ZraWxVU3VucEFoU3V4b3JWSGUweGlIemhPa1RtaXFocktxU1pEUlZKUm9PcHJJUUtGaGxDdm1aV0JSTDVqczNTRHZqWERPMHhoRHI5c2xDWnIrb01mdVpJeVVVY28wMFNvTXVubnRsUHIybFhFMVhnMjVRb2gwL2lUWDdGZjJCK0orL0lVUGtDLys0UmQ0MDhOdjVxTWYvUmVpYVJxY0R5c3pUMDNyTmdVVUlZUWtTZlArcTd0RmtNaXdLQVZhUy9xOUxwdGJXNnl2YjhTc29lT1VDcUpRM0dwL3NYcWRQbjJhRC8zb0J6aHhZcHZKZU1yQmVCejl5UE1NQktScFJwcmxYSHJsRlQ3M3NWL21xY2MraTJySlIwb2V5UjY2VlJ2U2tHaUpscEpFYVZLbFVGSkY1MTRwWXBaUWtzMWVSbDAxWEptVXBJbUs0aExHRVJKQll5ekdRemVMRHJKSnFnbGUwQzh5aFBkSUg1Z3RsdlFTalhPQmhiRm9yY2p6aExLeGRISTRlN3hISjB1NXVtaHdYdE0wRFF1aS9LbElVd1FDTFFKNUp1aGtxUml1ZHk5Lyt1cnM2NDMxcS9XSUUwS0V6bm9SVGp5NnpZVlB2WGdyUUw3ZloyMXRqZVBIdDdseDQ3bzRPRGpBZXkrSmNIZTlDZ3doUkMrRVVKdzdkL3M5dzhId0ordEd2ejhFbitSRnltQXdZR1ByR0tQUmlEVExVREtXSnlHQXN5WXFKa3A1Q09DNys2NjdlTytQdklkZXI4dmUzZ0d6Mlp5bU1YRU1LeFNkb2d0QzhzeVRUL0x4bi8yblhML3dKRkw0dzBKWXRzR1JLRWlVSUU4ajRTcFJDaTBWcVZJRUJGbWlvbWVpRCt3dkRFSktUdlFEcit6TmFVeTBOaE5LWWEyTlpLYmdXY3NUVkt1VEd4djV1TFhvRnpuZExHVzlVMkE5VEt1R3hzVGZxMnBIa2lhYzN1N1R5VFBLeXJDVzFod3M5akdNU05NRTZ4eEpYcEFtbWt3WmtrUXg2R1EwcC92dTFmR3lQcklpOFlCWG1Xb0ZyTGtWSU4rUDgvRERqL0RxcXk4em1VenczblBseW1VeG04MEVJRU1JUjdOR0IrZ01Cb1BSMmR2T2ZUalJ5VThUdUF1QjduUjZyRzlzc0xHeFFiZmJJMG1UNkdHQlJDcUpNZVp3TSs5Y3ZKQnZmY3VqL05EYjNrYWVGK3pzN0xDM1B5WkpJdWZEV1J2SHNDRnc4Y1VYK2RTLy9IbDJYbmdTcmNQaFpxMFZaRVMxZlVlZUNGSWRneU5SaWtTcXlMTm9qVFN1ekJwdUxBM2p4dkhBVnArckIzTm04NUlpVGVLbUhNOW9PR0N0MzZXcEcweUlZMkZqQWsxajBlMy9WRXBJcFNEUGNxNHZHaW9YU0pLY0crTTVuVXd3R09RRUI0dmFSUWtqQWwxbEtlYzdUS29sK1hBdHFqMFdDU21PYnBhVGp6cThzcGJsK1NqdjhScVlZMkJ4ZlJGNGlGc0I4djA0NTgvZlNhZlRRU21GOTU3cGRMb0tqSlY1Wndya1FBRVV4NDRkUDNYMnpObWZDdDcvKzg3NWtVNDB2VjZmemMxTlJtdHJkRHBkbE5Zb3BWcjJuMndKaWRIV3pUbEx2OWZuYlc5L0syOTY2Q0drbE96dTdySi9NTVo3aDdXeHBISXVhdlkrODYydjgzdS85UFBzdlBvOEt2VUV6eEYxYzlBQ01nMVpJa2kwSkUwUzBqWkFKSUs1OGN5c1pXOWhXQmhQZzZSSWNnWjVRV1VhVEdXcDVvYXNrOUFiZE5qb0ZReDdQY3JFVVZZTEhJNjZjUkhFNkJ5dDFqWjJhY2l6bEVKS2xCVDRMS1VwVW9Kd3pCYzFMa2c2L1FpL3Q4NWhuWStxak0yRStiVUZUZEVueFpDbG1xMStoK1VvNTVyeFpLMVF4czN3aUtyMnovM09DN2NDNU4vbCtabWYrUSs0Y2VNNmx5OWY1c2FONnlLU2o0UU1JYXpJVWZwSTFzZ0gvY0hhcWRPbjM5N3JkUDg5Nzl3N3ZROTVudWRodUxZbU5qYzNHUXlIaDA1TldaWWhFQkhIRlh4aytZbVlGVTZlT01IN1AvQStUbXh2MHpTRzJXek9lREtGQUlsT1FVRGROQVRnRzE5OGpFLyt5LytGeGQ3VnFFZmJicitsWE1GRTJ0SXFpVVl5ZVpLUTZyZ05HVmVXU1cyWm1JQlhHcTh5R211Wkx3MDlEY2Y2UFpxcUlUdVdzR3djMWxzNmlRYnZDVldGcVN6THFzSGhTRnFqb0VYZFVGdkhzcmJVcGFGSVUyNC90c1pvMUQvVXpiMDJIaU5VNUsvZ281cEszc2tKQ0hRUU9GOFJsalYyVVpKM0JJT2lSM2U5NEpzNG5BdVpMcExlMGM5SkVML1BINlR6NXpwQTN2MnU5L0Q4aGVmb2RBcUVFRnkrZkVuTTUzUGhuQlVoc09vMVVpQVhRblJDQ1BtSkV5ZlBudHcrK2RNaGhCOTMxaDhYVW9UQmNNRG0xcFpZVzF1ajZIUWk3RU5LMGpSeXhVMWpLT3VLMERMODZxcm16Sm5UL05pUC9TaGJXMXZNNTNNbWt5bnorUkpuSGM0N2NKRUZhSXpsc2QvOUpJOTk0cGVwRi9zb0ZURmhjc1hLV3dXSGhEUnArd3VWVURuWXF4cm1KbEFGd2RJR0RBcHJCSFhkWUtxR1ZNRHBma0dSS0x3UmpQS0NWRHV5SW1HdDN5RkpGTjRZWktiWW4xc3EzeUN5REtValROMDFoanpSZEpJVUZUenpzcUxJK2xSYU0wY3g2dlp3T2txcWFxa0lJbnFrSkhsQ01JSEYwb0p4OURxQ1lTZmwyS2pMcFNTd1l6eHJrazdTVGRZNVFvOFBJUHdQd0dqM0wwU0F2UG5OajNCaSt3VFhybDNsbDMvNVh3bXRFNmJUcVF6Qmk3YlhPR3pFZ1k3U3VuUFgrYnNlN25WNy83Rno5b2U5RDBtVzUyRTRISW10clUwR2cyRUVET3E0ejhqem5PRmdTRm1XVkhYME92YytHc0s4NmVHSGVPdGJIbVZqZloyeUxCbFBwc3huODBOSHB4QUNVbXB1M0xqTzQ3Ly9PM3p0RDM0SFU4Mmo3bTJJeW9wcUZTQ0FicHR6aCtDZ0RsVFdNRzhDQjVXbkRwQWttcmtOR0dzcHZDY1hNUlYyMDRRemF4MnEycUtFSXNzVndVVHBsbVZqS0VMQVdsaldCaVVrMit2cnFBQ05zWFJrU3E2VHlJMXZoYXVGOTB5V1M5S2lvSk9BVndsRm9xSk5BaHphWk0vbkRiTzlFbHNaZWprVXVXYXIzeU1aWm55bnFYQmEwVDREOU5FQUVhMTM0VTNVMXEwQStUTS8vK0FmL0NOZWVPRUYrdjArMzMzbUdlYnp1WmhOcDYwRU5hb05qcU85UnI2NXRYWHl4UEVUSDhpejdLZXNNZWVGRUtMZjc4ZXNzYjVCNTBqV2tFSlM1QVZyYTJzc0ZndG1zMm5rT1RoSG51ZTgvMzN2NVlFSDdzTjd6M2c4WWJGWVVsVTE4OW1jcXE3eDN0UHJqOUIyektVblA4SGpmL0E3QkZQaldvMnNwQTBLMWY0WWhLQU9ncmtSMUY1U0I2Z2N6SnJBM0lJbU1EVUdDZlNBVG10MktRT2NXZTl3WXRobE9pa3gxdElwK2hTcHBtcWliWnhRa2hwQmJTeTVsSVRTTW5OeFFwVW1tbUcvZzNVUjRSd0UwZVVxd0d5eG9IR2VOTkYwaXBURVdSWlZneGVDMmFSaTkvb2NqS09UUVNlWEREczVXK3Nkdm1scjlxMGoweG9FVWlVeVBSSWdTQ2xGcGpKaE1PRldnUHhiT3YvRC8vRGY4YmYrMWsveCs3Ly9hWXhweEdReUVmNm1Vc25SQ1ZWV2REcUQ4N2ZmOFk1RUozOVRLZjFEVFdPS0xFc1pqdGJaM05oa01CcVM1eGxLNmNNK285dnJNUmdNbUUybnpPYXpkdnRlMCsvM2VOOTdmNFFISDd3Zll3eGxXVEVlVDJtYUJnS1VWUVZBcno5aXZuK1pNK0x6bU1sVExPc0dZV0o5a2FXZ1ZldVZJU1VOQ2lzMUpnZ1d4ck8wbmxsdHFHMlVBODJrSUVXZ0NmR2JFbkhDSllqa3FEdFByS09sWkZGVkxCcUx5aEk4VUZZTnZVN0dUSUZHTU5LU3BVdFlsRFZPZU5Jc1FSTHdUYXRValNCUmtrVnRtUzJXek9zYXFSU3plY25WNjFPS0lrV25pdkdrWW55d0JPdEpOSFF5UVNkTjJCNTAyVldlcng4c0VFVkc4RDdnZzBvTDNlR21mWkdBbHZsNHE4VDZzejF2Zi9zUDgvTExMN0s3dTh1eFk4ZjU1amUvS2ZiMmRvWDNmaVhqczVwUXhlQVFJdC9hM05xKzdjeHRmMFVKK2ROTjA1eDB1TkRyOVVRYzMyN1I3WFZKVnRCMG9oVnp0OXNsVFZJT0RnNm9xakxDeGtQZ3ZudnY0UzF2ZlpSVEowOVExeld6Mlp6NWZOazZ4M3BNMHpBYXJRSHd6UzgreHM2cmY4Q1pEL1Q1MGxNVGJPM3BhRVV2MDJnVk04Yk1RMmtGWGlyS3lsTWFTMlVjamJXdkFZaWxBWklRRHFjTXNzMGVRa0EvVVF4VHhXSlJrV3ZOb0Z1Z0U4MWtFYlBKSzdzTFJ2MHVxZEt4WDFHS2ZpZkZpamlKVWpaZ2pFVWxpa1JFNy9UbHNvSUF2VFJES3NtMXlaejkvUkxFQWxycElkSHFZQlVaOUF2TjFxQ0w3aVg4L3M0K2xaUjBWL3BkTGhCV1RxY2dmbER2MXArTEFQbktWNzdNYmJlZFJTbkY3dTZPdUhIanV2VGV5Kzgxb2VwMHVvUGJiNy9qSFoyOCtFbnYzRnVNTjcwa1RjTndPQlFibTFzTWgwUHlWb05xOVRSTFcvdGtZeHJLWlJseFV0WkNnRWNmZVpqM3ZQdGRaSGxHWFRmTVpndm04eVdOYWRvbFlDRExDNUlrNVl1LzgzRWUrNDFmWW1zRFB1M1djUlBMbWZVK2FNblNlblpMdzd4eE5DYWE3bmg0RGVhbDRDWWJUd0dKajVNR0plSi9oeEFCaVFDTmNIejJxVXYwTThYeGZzRnhMVm5MRTdSV2pGSk4xbWd1SFpUTXFvWTdOdnZJMXVZZ1Y1TEtPNlFRakxvRlFzWVNyTGFPdEJXZXRzNHpYelRNNTFHS0tMSUwyL0cyaUppd1hxRVlkQXVPclhYNXdzR01pOHVhL2pEaXMxcjZybTlLVS9GOTFMejZjeDBnNzN6bk85bmIyK1BDaFFzTUJrTm1zNmx3em9rUWdndzN0K0dIdllZUW9uUG05Sm16R3h1YmYxTXIvZGVhdXQ1UVNvbWkwMlZqYzBOc2JtN1I2YTZ5Umx4ZEs2WG9kanJvSktGY0xsdnJzb0IxbHJYMU5kNyt0cmR5ejkxM3gzSmpObWMyVzdCWUxPSW0zVGdJa09jZG5MVjgramMrd2g5OC9KY0kxakJlS0o1K1pjSGNPZzRxdzdKeFZJM0RpUUJTSWhPSjdpV2tJYUJNZS9GOElMRWU2VUlMRG11MzY4VGxvU1FHeDZwQ0tXdFBXVlVjTE9IVmNVbDY1WUN0WGthUktqWjdIYWFWNGNMMU1iVUxhS1c0ZmEyZ3FSdHNpSUxXM1N3bENOQkI0cXluTGh2MjVpWFRlVVZWUno5MWI4T2g4U2h0QmtzMWRISkJQOU9NaXBUSHh6TWUzNXVTZFBWcnhybENvTEpPMHVVSVlEWU9MMlM0RlNEL2htZHJZNHYxOVhVbWt3bUFHSThQVm51Tm85dnd3eWE4S0lyKy9mYzk4TU9wVHY1KzB6U1BHR05VbmhjTWhrUFdOemNZRFVldFhiSnF2UU1GV3NXU0NpR1l6MmR4dWlJRXBxbTU3Yll6ZlBDREgyQnJjNVBKZElxeGx1V2laRDVmUkdLVHRYRS9JaFZYWG4ySkwzejhGL25PMTcvSXZLcVlWcDZEQ21hdVpTTVdDZm14Z3VGYVRyWlJrSzNsaUU2S0tsSkNiV25HRmM1QnFBeHV2OFRzTExDVEpkbmN4dlFvNDY2RTluSUtHZDEwcGFEVjA0bU9UYzU3TGg5RW00Y0wxMmVISmh0TmdLL2ZtUExTdkdJalZTUWgwRldDalVFZXlXREcwalNXWlZYVE5ORUJ5cmV0aVE4Y0xoTlhOblhkRkFhWllxdWJjME42dnJZM3g4dW9CN3p5WUFreEt3cWQ2YXpsYzkzS0lIOFdKMDB6ZnU3bmZvRi84bC8rUTc3OCtKZUZkWGIxRUYyVlZBbVFDU0h5RUVKSEtaWGRjL2U5OTR5R283L3NuUHRRWGRlbmhaUmhPQnlLdGZWMTF0YzNiMDZvVkRTVHBIV1pGVUsyTEw0bzUrbGNoSS9jYys4OXZPKzk3MkhRSDdCL2NNREJlQktkYW4zQVd0T2lkejFsVlhQMTVRdDg4L2Mrd28yWG4yYTlseUtsWlZIVmdHU3dYYkIyL3dacjkyMHd1SzJMNm1VNEliRkJVRGNCWDN0czVham5sbWJlVU0xcWJLR3BNcWlTR21VdHVvVGNRZW9oYjhVVFZQdUVEdUtJMm9pSTBqOHVEc3BvVmk4aWpRL3JLZWNWNHdDYkFpb3RxSm82MnNZWkc2ZHAvdEN4bXBhNWV6aU1YUzB4T3huMEM4bFdQK2RhTHZsaXVXU1pDVkowKzRDSkZnb3l1bXdGVTdzNkJNSVA4cDE3UXdUSWovLzRYK0w2OWV0Y3VQQUNQL2R6L3h0cGxvbWQzUjBSUWhBaEJCVkNTSTVPcUVJSStmYjJpYlY3N3I3blE5NzVmMys1V053REpGbVdoLzV3S0RZMzRqWTh5N0oyemk5djVuNGZDRVFOYTlQNkRWcHJXRjlmNDRkLzZPMmNQMzhISU5qZDIyZG5keGZ2QWxycnVQbVdDcHdQYVpMeTdMZS9MSjc4M0s5VDcxK2xreGZVdFVFRlNXZTd4d052UDhuR1c0K1RIaXNJV21GOW9Lb0N0dmJSQzkzSFpzTDdxRWdpRzRlWTFiQm9jTXNLMzVpb0t4V2lQcWNNa1BrV0grTWpKRVZ5OHlsdlE3elFvUlhCWFZIMzBuWTBYSWlJRGxZTytrS2dkWlFYeXJTa2JPTGZzeXRMaERhRCtIQno4MzB6T0FURGZzNmxRYzVYbmFIT016cFp3TmNHMllwa0h6cEIraUJJaU5MMXR6TEluLzQ4OU5CRC9PN3ZmcEwzdi8rRFZOV0N4eC8vb3JEV0N1ZmNVVWg2M3I2eWZyL2ZQM1A2dGp1UEg5LytLV2ZkankzbTg0RlNtbTZ2eDlyNnVsaGJYNmZiOWhwQ0NKUlVMZHZPM3hSM0prcjl1MWE5L01UMmNUNzg0eC9pNUlrVEhCeU1XUzZYMFNESHVRZ1ZOd1lwVlpUeUViTDUxbU9mZGs5KzlsYzd3UzRBaWJlT2JDM24rTnUyT1BXT1k2VGJYUm9IVmVPcGEwZGxhQlhnaWZwVkxtcFcyY3JoUzB0b0xOS0hLSnpRTkpGdjN0SWxnZ0NuWUJtZ2RQR1NwKzNsZDl5MEpmVkVYOEhzU0xOLzlOVUVRU29Db2xVOThhMVBpSmNTYTZJSzR5b3dqb0luRXdWNUJzTmMwbC92OHVKYWoxZVVRSkhRYVhXMDdDcXFFSytGLzY4MmpFZW1XTGZHdlA4SGoxS0s3ZTF0bm5ycVNlR2NFOVphMlpaVlI4R0ZIUVRaZ3c4OGRPZlc1dGFQVzJNL01KL083blRPeVU2dngyZzRaRzE5ay80Z2twbGtTeVdOU2lHQ3hyUTJaVzBtRVVMZ25LUGI3WEQvL2ZmeDhKdmVSTC9mWjMvL2dMSXNxZXVHZ0VDcGhHbzZSd2pCY0xUR1lqRy84Zm5QZi82enYvZXJ2ekJmVi9XSFJwM3N0cUpRWXZqMjQraTNiV0tQRlJnZmFFekFlSEJCUkdWR0YzQXVCb2xwUEs1MkJPUHhsY1hNRzh5c3BwNVhtUGt5UnRDcWdWQnR6c3piNW53QnRvcS92VHh5NjhTUkpaQTg4c0VuUjVyOGxWZUlEMkNiYUJGWDJSQTMrQ0tLVTZ3Q1E4aWJiTWF1aGw2dTZCN3I4L0tKRVZkU1JWSzdWb3VyNWNQVThqWGR1VlFTS1VUd1hnUWhSUWl0RnFrUUF1LzlUYXZoV3dIeUo1Ky85M2QraG1lZWVacFhMcjRpbHNzbGRWMGZIZDBtUlB4VUVVSW9lcjErN3gzdmVPZjdpN3o0cWYzZHZUZFZkWlZxclJtdHI3RzJ0czV3T0tRbzRqUktDdEVpY0NWS3FRaE5YMGx6Qmc5Q1lveGxOQnJ5b3g5OFArZnZQRTlkMVV3bVUrcTZ4dm1vN09HY1o3a3MwVWtTdE5MaTZ0WExMMzNxZHovNVN4LzlsVjkrd2hpak43dkp4YnR1VjMvajNnK2Rlamg5eDdaY0NCQXVZTnVIdi9NQmIySmdCQjl3VGFCWjFVSk53QzBzZm1HZ2NmamE0cW9HdTZ5eDB5WTJEakkrSGtRQk1oZm9SRUpYME93Nnd2S205aTFFOWVjZ0JXSGx1dHZlVmQyT1pXTUdqZW9VZGZzbHVHak1pR2tDaVJaSUxRZ3VDajhrS1dRS2lrVFFYZTlTblJ4eGVhdkhOTlYwZk1CbERtY2R0cko0WTl2SXV5bC91c0tWcUVTczdsODRPc202bFVIK2hIUG5uWGV4dDdmSGllMXRYbjdsSmZIOEM4OHpuOCtQY2pWV080M0R2Y2I1ODNlZXZQZWUrLzZXYmN6ZjJOdmQzYlRHMHUxMHczQnRUYXl0cmRIcnI3S0dKTkZKcTN0YnQwREJKa0l1MnNrVlFXQ3Q1ZGl4TFQ3MG94L2crUEh0dUJRczZ4WkR4ZUdVeWpsUHA5UEJPKzlmZVBIQ003LzZhNy84djM3bU03Ly9iSnZWa3RGRGE0dDcvLzdkeWZEc1FKUWVuRm14emFPcFozRFI0aXc0a0Q3YUVHQUNwdmE0T2lvZXN1cEhuTWZWQnR1MEtvV0J3enBLNVFLZGFiUldaR2xDblRvVzF5ckN3dCtjQStlU2tDamN3cUpNT0pUK2RHMGZJeDFJSmFoZFcxNFJzNWxxK3h0Q2EzMnQ0NlNzU0tIVFQ2bk9iWEwxdG5YbWVZb1hNWlVMNXdtTnhOUVNiME03Vmp1U1FJaElBYUdVTThZdGdqK1VuZnVCN0VSK29BSmtiVzJkeVdUTTh4ZWVGMFI4azN3ZGZtcFZRbWVuVDUvWlBuM3E5QStOaG10L1pUYWR2YTFjTHZNc3kxamJXR2R0YlYwTVJ5T3lMSStaUW12U0pDVk5FK3E2b1dtYXR0WVZMZGNpRXB1U0pPWFJ0enpDMjk3NlZvUVFIQndjMERRR1l5THJ6eGlEc3g0aEZFbWlxY3BxOHN4M3YvTzVmLzdQLzlsSHYvWEV0eTRpU0FqNGU5NTUvUFQ3L3BQNy9rNzNSUGYrc3ZGQ1NVR21ZcVl3UHI3cHpnZXNFQ1FpRXVCMWlCVGR4bnFFY2RIdHlRZGNiYUpMYkdQeHRyMUw3WlpIWnBBa2lpeE4wV25VOXRWSmJFd1dOMHBDN1NNTXVCTnRGT2hLeE55Z1dsK09WYUFFWXNhd29WMDQwa0pyMng1anhVZkpVaGoxTmNsR2grV0RwNWh1RDZpSmRWbldaa2poUEVGR0oxd3FFZDJrMnZJcHRIN3dQaUNFRWlIVXdSejVFZ2doaEN6THdtdzJ1eFVnUjArU0pCaGplT2FacDRWekZtdnRpc1IwRkQ5VkFFVzMyKzM5MEErLzR5MTVXdnpOcHE1L2FENmJqcHozRE5kR2pFWnJERWVqZG5TYkhLSnVlNzB1QkJoUEp0Uk5oV3pGMjJTYk9ackdNQmowZU5jNzM4Rjk5OTFIVlZYTVpuT1VVb2RiOCtCaHVTd3BpazRRUW9pOXZkMXJuLy84NS83RlAvL0ZYL2prd2NIQlFnaWhRZ2poL0ZzMnozendQN252NzNWUGRoK3BiUkJKNjBpbGxjQVNiWlZ0UzVBU3JWRk4wZ2FNY3BDMGdSRmN6QjdCT0Z4dGNZMkpHVVhFZDBTbkFwMnIxZ282UmJTYmNLVWszVUdPYzRGeTBvRFM4UVVFTGZCQ0VZeHp1aktOOWlIeklMMklLTnhTUUZmR1psNEJtWVJVeFpKS1pwS2tseUpQak5nN2Y0enlaQjhWUEVrQTRRVmFnQThlNTZOQmo1RGlVQXZzNkFraHRKN3JvVEtsM1Q4U0lCNElLMmZndjlBQjhoLytSLzhCKy9zSHZQZmRqL0RmLzc5L2p1dlhyeU9FRUl2RllUbjF4emJoUUxhOWZlTFlndysrNmEvbmFmcVRaVm5kVnBiTGtLWVpHNk9SR0kzVzZQYTZaSzJpU0pLbURQb0RwSlEwVGMxaXNiaVpPVmE3ampheG56dDdHMjk3KzF2WjNOaGdNcGxTVmRWaFhiNWNMTnZDQ0FLRTVYTHBMbDI2OUkzSEh2dmNSejc2SzcvODVicXV5OWE2TFF3Mjh2NlAvWi92L2V2YnR3L2VVVGRPSklrVWVFOFRJcllLQW9rU1dDdFJNbUNESTdqb3pPU2JnRzFCckVLSVEraUlheHltYnJBdEFoY1pUVGV6UENGSlZuQ1lFSmVET29waHkwUXlHSFlSTXFPczNjM2lSUWhzVDFQQ2JwaVVYeWw2b3g4cTYrclllRHhHdENQalJFTGVOdXVsZ201SGtxeGx5SzBCNnN3NjAwR0I2YVdvRUVESmFNYmpBdElIaEpheHQyb0RSRXB4T0dzTzdmY1ZaVmNoQ0xGc1NuTndORGh1bFZqdGVmS0pwM25vNFFmNGIvLzcvNDNKWkNLY2M1RXdjek13a3B2ekdmTEJZREE0ZCs3MkIwK2RPUFh2V2V0KzlHRC9vS08wWm0xOVhReUhJL3I5UG5sZXRGd05SVjdrOUxvOTZxWm1QcDVoV3RiZVN0bHdOYVhLaW9KSEgzMkVoeDkrQ05NWURnN0diVUNaNkwzUlRyV3NjeGhqR2UrUG0rZWUvKzd2L2ZZblAvRnpYLzNxVjE1dTF3a2hoS0IxS3ZPLytROGUvQ3UzUDdEK0V6NEVGYVRBQTNXUTdZSXRVTnFBZFZGb1FmdjRoRGJCc3pRZTEzaUU4eFNwcEs2Z3RCNWZXN3h4bURvT0JTQ3FwNmU1SnMwU2xJcmNsQlc3U3JoQThCYVpwaFM5REtFRDdxREV0STY2SzdOUDZmMUxSaVhmMmI3bjdoOE8rM3ZjbU0yZ2llWGJUdHRUaHd5U1VjTGc1SWorOXBCOFVKQU9NblJYSTNURXRxU1p3Z1VRM29FU1NCa1E5bWJqSDF6TWhEN0U1djVtL3lFUnNKamRXTzYvUGtEK3dtZVFORTA1ZHZ3WXp6MzNuSmd2RnBSbEtZL2dweElnYmFkVGVaN24zWFBuN2ppL2ZYejd4NHM4L3l2eitmd1lDTlh0OXhrT0J3d0dRNHBPaHpSSm8vcGZua2YxOURSbFBENWdQcC9qVzdlbCtBQ05QM29mMk56WTRKM3ZmQWUzbnp2SGJEYUxYSTBRTUhWRFZWVXNGc3VvY1pWbEdGTnk3ZXFWblQvNm84Yy85dHUvL1lsZnZuVDUwbzEyQ2UxWDcrR1AvcDA3SDdyNzdjZCtzblpoMkZpUGRWQVJoWjVTSlNocno2eUpIYkIxbG1VVmtKNzQ1UFVnYlVEV0R1TWR0bmFFWllQWlgwVHJhT2NoK0tpRnBWWHJSaFUxZ0VKcm55Q2xSTFoydEVvcFpKcWd2VU5Mc01Rbk9rS2dwRmhTMlc5TG9laXZyZldzTSt4bUNiNE5rQlY4Uk9TQ1pLTWdHM1hKdWpsSnFxS0ZXMndrMnZLMFhSWW1FdUhqb2xNRVVFUmxsQkJDYS9iamtEb0djbFJ3a1lDWXo2N05WeVdXRjBLMG5LdS9nRk9zRDMzb3h6Z1lIL0QwMDAvanJPWGIzMzVDN096Y0VNYVkxNVJUUW9pY3FFR1ZibTl2Yjk1Ly93TS9McEYvMHpsLzkzdytsMm1hMHV2M0dReUdkSHU5UTBGb3JUU2owWWkxMFlpbWFkamQzNk5jTHVNVHR3VWV0ak4ydEZZOCtPQURQUExtaCtrVTNZaWxhZ3gxMDdDL3Q0OFE4aEF6MUZnYmR2ZjIyTm01OGUzSEgvL2l2L2lYdi9TTGZ3RE1oQkIxQ01HdHN0MWRqMndjZS9qSFR2MmtUZVNaUmUycEtvY01BcEZKbEl4N0RseHNaRTNycTVIWmdIU0Mya1FiQWh0Q3ZNaXREbFZvTzJOaFBWZ1hGUkMxSWsyaldtTlFFcWxVVy9mSDcwdExqU2dVV2lVUkJoSUNBdDltVFVtSUcvWkwxTzVDMHV1ZmwwSW9KU1dxMWNtNk9SZUdVQWRNWmJHMXdScEhVa1JPakhkeHd5Kzh3SEJ6TnhJZzlsZkdJMzA3TnE0TnpycVc2TkZhVmJkRUxROHpXN3NvK3lQd1NxbGdyUTEvb1Vxc2UrKzdqOGw0ektjLy9YdTg1YTF2QXhER0dLNWN1U3o1NHpJN1JRZ2g3L2Y3L2Z2dXZmOHQvWDcvcnhGNGQxWFhRNjAxdzlGYUdBNkhvdFB0VU9SeHA2R1VwTlBwc0xhMlRwWmxUQ2RUeHBPb0dISnpkQnN4RWQ0SCtyMGU3MzczTzdudnZudVp6eUpQUEFndzdkaTIxeHZFR2o1eUcwSlQxKzdaWjUvNS9PLzh6bS8vcjQ5LytVdlBDRmdpUk5XNlR5a0JXVnFvN0wxLzY0NFBiWnpwdlh0WmU2RkVJRThrU1NMd0xkR3BibFdmWlB2S2hjQklnVEd4NzNBMlhpeGpQTXJIZmlLNDBFcVdSalNma29KVXF5aVEwQWFJa0FJdE5CQkgxU2lKU3VQNnoxVU9hd0k2VFhIZTRRSkJRcU9jKzNvNXI2NnVueDcrcU5KYTZ5UUpVc2pYd2owRVVFTXpybGgyRnlSRmd0QlJmMVhtVWZNMFNJbHRQS3F5aUZUaGxJaURCUmZhdnNsaVY1TTNRVndPUm8yd29IUHRoZUtxcTIyRXU0ZWJKVllMUVAzekh5Q0R3WkIvK0UvK01mK3YvOGQvZ3hDQzd6ejFwTERXSG0zQ1Y1dndBc2lWVnAySEhuelRuY2UzanY4MWE5MlBtYm81SVpVUy9VRS85UHQ5MFI4TVJLZlRqZktZS2s1dnV0MGV3K0VJcFNUVHlZVEpkSEs0QmhQdENOZTNkZTNXNWlidmZlOTdPSDNxRk5QcGpPV3liUFdyNGxNeDFRbG9nWFV1U0NGRldWVUgzLzcydHo3NXIvN1Z2L2pGWjc3N3pLdEFGYUFrT2lCSlJPUXFQZnErVTdjLytQWmpmMTByMFVHTElFR2ttY1lFT0NpallxRnpBZXNDeGtGakk2VEV1cmlRMHpyU1hvT1BUM3huUGQ0NFhHa1FUVUFqb25lNTFsRi9TNnNZSEZyRndBK3hRU1lSN2EvRmhhQzE4ZCtTUWlGVndGb25aT0JsTXluL3lQdmdPc1BCd0FjdnF1VWlqbUxGa1ExaU8zanlDODlpYjlGNm1pZ0lnc1FIWkI1MVFvTVFKQzRnblk5SWdNcGlLeGNOUHhzSHhxRkNRQ2lGYkdtN1FnaFVvYXZKMWZsVDNvWHlkZFBtUC85TitzLzh2Yi9QOHhlZTU0Lys2SEgrNy8vNHY4SjdKNFFRb3FxcUZVVGs2SFJxaFo4YS9mQVB2ZU5IZXIzK2Z6Q2Z6ZTYxMXFwT3J4ZDZ2Ujc5Zmw4VW5jNGhSQ1Q2YnZSWlg5OUFTVWxWMVN5WERZMXAwRnJqbk1NN0Y0UERlenJkTHZmZGV3OFBQSEFmV1phenQ3ZVA4NTZtYWVJRmFyRllJUVM4OXl5WFM3KzN1L3YwWTQ5OS9sOTk5RmMrOHBtOS9iMnhFR0laUWlqYnZnTWdKWkNrdWNyZjg1ZHYrL0hoTUx1amJGeVFTZ2daRkVpRnR5N1dEdTJuMzBacTI3M0dtc1M3Z0trZDFuaEVFQ2dFdHJMVWt5cit1S3d4aXpLNjMyWlJNRUtzOE8weU5nQ3VNZGk2SmkweWRLSUpQZ0lLbmZPSDZGc1JsZGJIWVZiK3EyWmF2YWp6OUhqVzY0NjhjOEkwVlFpdW5YVEoxd1lJRHR6TXNFaG5iV1BlbHFrKzloMUpJbkZTME14TSszNnZQQXdkcG1vd2pjRUhTTE9Fdk1qYTBUcENwM28rdTdaNG1XaTE1dG9leEsrdHJYRndjUERuTTBEZS80RVA4T1hISHlkSjR0WmFheTJtMDRsb3NUV3YwYnB0bS9CTUtkVjk0SUVIN3o1MTh2UlBKRW55bDJmVDJhWlVpbzNOSWIxZVR4UkZoend2MEltS1RMVzhZRFJhcDlQSjhjNHpiWnZ3TE10WkxqMU4zVVFNZ3hSWTR4bU5odnpJZTk3RkhlZnZZTEZZY25Bd2pqaXFzUElXaDRCRkNCSFNKQkdOTWRYTEw3MzQrZi9mUC8vNW4vM1M0MTk2VmdpeEJJNEdSeUFheFNZaG9ONzU0VFAzM1BQbWpSOGorQ1JJQVZiUVRSUW14UExLQjBGdG8zSkk4QUxuVlN6NVFqZ2tOaG5qQ1Q3RVVha0RXem5Nb3NGVUJsTTNOTWJHcVZlaUVUcVdWVXJKUTRvcldzY1NyQld1c3phV1ZzSEZDK3RDQ0VMaXRQZWZxU2JsTjBNSWRkb3RPbm12TzdTbXdacEd2R1p5SkY4TDRnb0c2bG1OeWhmb0ZXZ3JCSFNXWUJvSWlZb052dmZJVkJOOHdGdmZUckRpUXdjaDI3L21neTR5NFh5NDBTek5qWmd6ZzFWUytVNm5FMzc2cDM4Ni9NLy84Ly84NXk5QTdycnJibzRkUDRaU21rLzgxbStJZGt5NndrNnAxd0VMQ3lsbGZzZnQ1OCtkUDMvbmg1TWsvVkZuN2ZtbWFaSmV2eCs2M2E3b2RydGtlUjdaZlNMV3JwMXVoNDMxRGRJc1o3R1l4eVpjQ0lvOEoySzFxa002blpDQysrNi9qMGNmZlROcm95SDcrMk9xcXNiWjZBenJuQ05OVXhiTGtycXBRNTdsVENiakswODk5ZVRIUHZvckgvbjRrMDkrK3hKUWhSQVdzUm8vbkZpMW0zMlNyTkQ5ZC8vVnN4L1d1VHpsUXdnQ0laUlU1RHJCMU5IZXpOb1FuV1N0T0FRakVpU1NBQ0tRSlJBS2pmUlJhTTdVL3RBVE1GaUhDSUUwVGVua0dVRkVaeG5WTGdPVlZsZ25jRnFpdWpsU3E4aC9OejcyTlM0dS85cUY1Sk4rVXY2Nk0yNEdoTzdhb0MrbHpFMVZZZXFLUXduSG84SEJUU2h3S0FQMWRJbHVwNEcrQlNKS0xTUC94SHRNYVJGUm96Mk9tNDNEbXpnWmkxWU9KZ0pFaThRM1MzTnh1VmZ1SUhDRVNGTlpaZjgvTnlYV1AveEgveGl0TmYvVC8vai9aWHY3QksrOC9JcVFVckMzdDdmYWFlanZVVTdseDQ0ZFczdjQ0VWZlczc2MjhYZVdpOFc5enJrc1NkTlFkQW82blk0b2lzamYxbG9qaENCSm9rajBhRGpFKzhCNGZFQ1NKSFE2SGNxcVpES2QwRFFtUWhsQ0lNOXpIbjNrWWQ3MnRyZmduT2Z5NWFzdGcwMUUzb1lRMUhYTllsblNORTFRU3Z0cjE2NCs4ZkhmL05nLy9kU25mdmNieStWeTFvSmhWNWJFS3p0dmNTUUxKbWZPRDdhUG5lNCtJcVJNUklocWhDN0EzQVJxTDdCZUVHMXA0aVdMd2VsUjdTMlViZU9xcGNkbktqNXg2eWpLRUV6c1F5U3hyd2dpeEF3aUJSNlBVTEdlVC9JRTRUd2kwUWprWWFQdmpNZTJkRmhDdU80WDliK3F4c3VYVnpsaWVHSjRyT2ozcy9sNEhLd3pJcXhNREw5WGdMVE1STHR3bE1reXZzL2VnMHZKc29URytaaTlsTUEzRnR1Q0s1c3lZdFpFS3drbnBVUW9LVlNtM1dLLytuSTlyU3VCTUlGZ3ZmZStMTXNmdUJIdnYxR0EvUGYvM1gvTGYvM2YvRC9wZHJzODlkU1RvaXlYb21tYTFiSnZsVFZXVy9BMFRkUCsvZmMvZU8vdDUyNy82MW1hL2RpeVhJNmtVcUhUN1ZKMENsSGtCVm1XbzVPb0phWjE1RmQwdTEzeXJLQXhodWxrZ2xReUNxVXRJa2ZjT1JlRm80VmdZMlBFMjkvMkZ1Njk1MjVtOHdXN08zdlVWVTNUTkhSNzBUWEpXWWRwRERaQ1dwYXZ2dkQ4Rno3MjY3LzI4NC85NFJlZUlTNlRGMGVDd3g1cElQWFJNdkhEUDMzbld3ZHIyUjFTU0FSZ3ZhQjIwVzJIT0Z6RmhkaGJTQjlpcURqQU9ValVvVktCbElJa0ZRU25jSm1pVGlWS2dHbDlFSVdNR0NaUGlFaGtxUTVMTFoxcGNLRVZUWWlUTU8vYTdCSDNFQmJuL3JEYW1YMGxCR29Bb1NoNngzdkhFU0UxVFMxc1hSSzgrK1A5eDFINUZPSTdZZWFXU2k2am40aUlxZFExRXFramdzdlo2S251eW9hbXJQRE90WUVkTi80eWxvYlg2MW56WXZCaHhkdHlRT2kwZm94djZBQjU0SUVIR0kvSFpGblVpdnFWWC9tbzJOdmJvMTMwSFoxT1pTQnlDTGxVcXZQb0k0L2VlK2Y1dXo0a2xYcXZNZWFPc3Fwa1huUkNVUlFpejNPeUxDWFJLYkxsaEI4R1JwNlRwaW56K1l6RllvR1VFUnRWVmVORFdQUktBdlNlZSs3aVRXOTZrUFcxRWRQWm5QMzlNUWVUU1d0N3BxaXFtcnFxYUpvbU5NYUUzZDJkbDE5NDRmbmYrTVJ2L2VZbnYvdmRaeTYzamZpeUxhbWFWZlBZUHRhTzlsSHB2UTl2YnQ3NTRQcVA1RVV5TU1iamdpQjRoUWorMEl0Y0JuRll1YmpRVHB1VVFHcEpFQkU2N29SQUpRcmh3Q2xQa2ltS1FVNWRwTlN6RXFXaldueVdaWWNYV0NjcUtwQ3Nsb01FWE9QYlVYSEFXbzlkN1NxRXVPS241U2RzNHlhcldjSHdaSGRqZEx4enR0d2Y2K1Y4aW1tYTd5MjhzOHFYa2tPRitXQUNabWxpMlNzazRUQjdxRU9jbGJleFFiZU5pU1BxZHBnQWhLUklSRE52dnJyM3d2NkZOamlNRU1LM3IvQ3pQL3V6Yjl3QUVVTHduZTk4aC9Qbnp4TkM0TWFONitMRkYxOFEzdnZWUGtPdGxuMGhoQTZFN096WnM4ZmYvdlozL0tWQmYvQlhsRkxubDh0bElxVUt3OUZJWkZsR251V0grNHpWM3FMWDZ6SWNqdUt5VHNCaU1XZXhYSkpsR2M2NVF4aklLa0MwMWp6NnlKdDUyOXNleFRuSGpSdDdsR1ZGVlZaeFNhV2pxMU5kMXdnaE9Uall0OTk5NXBtdmZQWHJmL1J6bi8zc1o3NEp6SVVRWlJzY1RmdWhPYVdVSHczWG1DL21WRlVaZXlraEVrSkk3M3ZMc2R1NmErbDlWVzBSU0R3Q0tRSmFDbXJucVEwWTUyT0oxSVpYQUlRU2hDQ2dkc2hFb1pXa3NnNkNSeW1CVGhScEp5RmY2MUFlTEFqV2tlUUpuVjZHQzU1QVZEbEV0UFRaRlY3THhnQnhObUNNeDFzZmhKUkdHUHZKYW0vNXpKRXlVVytmWDF2dmI2VHJ5MG5KY2pxbXFjclhOdWZ5ajVkWGg4SGpXOHlZYXFoakhVMmFwVWdkUzdUZ1BNNTVuTEh0VWpacFZXSWlHVjBtZWxFdjdMZXJnMnEyeXRCQ0NBK3dzN1B6eHM0Z0lRUTJOemVaeitkaWIyOVBlTytGOS80b2Rpb0g4aEJDWGhSRi81RkgzbkwvdmZmYzh6TlNKdStxeW1YSGg0Qk9Fb2FkcmtqU0NEMlBIbjZxSmRBSXVyMGU2K3ZyS0ttWUwyWXNGa3NFZ2p5TkhJNjZxUS9mOUNSSldCdU5lUENoKzdudHRqT1VaY24rZnB4U1NSRXpVYUlTdkE5VVZZM1dPbFJWZGUzcHA1LzZuVi83dFYvNTJJc3Z2ZmhTVzBvdFF3alY2Z09UVXZwK2YrRFAzbjRuMTYrOEdwcW1scTFpaWhhQ1ZDcVpuTHl6LzlhOHI3ZnJ5Z1dkQ0dHOWJ5RWFrWFc5R3UyYTRIRXRXRStJQ0NFUElXQVFaS0pWV1ZqdFFOcnByOVNTenFoZzJjdHA1aVZwbmhCa2lNR0dRTWxvYXh2MXFRTE9lSHk3VzRtMDNSQm5aTVk5MWV6TlArNnNXN2Fsb3dUVTJzbitzYlFuTnJPUlFPVXJHTlNSb0RqNm8zM2Q2RGZFZnQ1V0htaGE4MDl3Umg3S3NqdlRrcVJXY2tDUnFvbEtFNFNTbDVhN3l5ZVBaR2tyaFBEK0J3MkE5YWN0c2ZiMjlvU1VVbmp2MVpFdCtBbzdsUUdkTjcvNWtUdlBuajMzb2VQSFQveUVWdXJNYkRZVFNtdUtWY2JRK2hBYnRRS25wVWxDcDl0bE9CaWdsYUp1R3JSVWJLekhEWG0zMTZYWDdjU3lxeWpJc3BUQm9FK3YyNlZwR3NxeTR1QWdOdXRhS1lLTWV3Q0V3RGtUaEVCY3ZYTGx5YzkrN3ZkLzlqYysvckV2MVhVOVd3VkgrMkZaQkZaSjZaVlU0ZnlkNS9rZnZ2YlY4TUZVdHNJUXNhY0tQaVNuenc5SForOGVQQ1FKc2tnVmpZZlNCbXJYOHJpRkpJUUlIUWt1WmprbEFTOE9qZmhRZ2laZVpxeUxVSkdvTkJneFRra2lTYklFWHpXa2FXeUFWME1JMGNxOUJ4OXdiWGZrWGFDcFhaVGxDVUZJUkVWdFBsMVBxeXRIcG5BSklJcEJPa295T2trdk1EcmRZellwcUt2eTVwcHVOYXVUMytNQ3lCWlc0c0hYSGtORmNENHVFdHZQdEtrYmZOUEVuWXdTZUJIOUUzV3VqVFArSzN2UDc3L1VmajB4cXdWOCtBSFcvZm5YRFpEVlpFcDQ3L1dLd0xTaXZJWVEwdnZ1dS8vc205Lzh5Ri91Rk4zM0prbHlqekUyalZNaUpYUVNzMFZveDQ1cG1rYjByWkowdTExT2JHK3pzYkhCY0RnNG5QTVAra09TUkpNa0NWbWVrYll5b0FRdzFtQ3NaZDQyNHNaWXZIT1VaWW0xanFJb3FNb3krSUF3eHBSUFBmbnR4ei96bVUvL3d1Y2YrNE1uZ0ZJSXNXaDNHNnNwbFIva3FWL3I1dFRvVUpVVi85bXBkUXFkTUxOR1FKRHQ3a1BmOCthTjI3ZFA5eDZTU0lHU1dCZDVFSjZBUUdKYWNKN3dFY1VhV21XMVJNWW12alVJcGJhT1lFTXJLUlRWVFBCdDBGZ2ZZUnZpSmdJNWhJQlNJdkxtVnhLaklUYmt4Z2FheHEvVURZTncva3RtV3YxKzhLRnFzMGNBa2lSWDJlaFljVHJwa0luYzB6dlJaVGdlc3JjMHVKbTlXV3FGMTJXU3RreGN5WnF1TkxlczhTRE1vWDZ2RDFIa0l2WmFLa29weWRqRWkwUmZuN3c2L1l3cHpiUjl6eTNndlFpQnZQMHEzNEFCY3JSOWF4MWZ3NkhHYlFnaEg2MnRyYi81NFVkKzVPeHQ1LzY2VXZwUjA1aXNhWnFRWlJuSHRyYkUybHBrOW1WWlJwNW5qTlpHSEQ5K25JMk5kUktka09jNWVaNjJBZ3FTbHI5L3FIemhmY0JaeDd4cHNLM1diUWl4cjNEZWs2UXB6a1hyQVdNTWk4V3lSZkVHakdsZWZPcXBiMy8wVjMvMW81OSs2ZVVYcjZ4NmpSQkNmVmdEZzVkU2hDTFZuT2dsSVpHQ2I3M3dMRXZqWkFnYzBmWVZhWkxKOU5IM25ueFBWdWkxNEFnbUNPSGJFYklpTHJpZDVLWmNxSlNVVlZRZ1ZBUzhqNldSc1k2bTlpdUswRXFuTm1yOStvQ3JMSzR5YUsxUTdjUXFCSDlJUW9KMmtSNWE5Wk4yMlVnUXlCQ3VVellmcTZmbDVmYmFyUmpzWW5Dc0tHU3V6Z1dGU0FzUjBuNHErdHREeWtYSi9OS1VVSVdiUWZLOWJzQUt5TmoyUHNKRnZvcndFZWpsV2dLWVRHTnd0SHBqUWVXSnMwMTRmUGU3dTArM2dWSEhuaWg0aElqSzIyL0FBQkZIMmpiNXVuS3FBSW9QLzlpSHo5OTMvd04vWjJOajg4TlptZzJWRktKcEdtNDdlNXM0Zi80T05yZTJ5TklzbHE4QmdvaVh5YlZxTDRJSVhWaVdOY0dYSk1tcVo2amlrL2NJMkRDMFQ4c1ZRODIyQmpScG11SnQzS0k3NTROT0VyRmNMT3FMcjc3eTVVOTkrbmQvN3ZISC8vQkpZK3djT05xSXI4YUxQa0J3UHJBekxkbVpsbkxsa1I0SW90V0ZUb1NnQ0NGa0o4LzJ0MDZkSHp3Y0VMcDJQaXlOYnpOSXExN280bVd2cmNQWStQVkswZkpDWEF2OWJxSlFWUm9FbmdCZXhBYTc1VTZFeGxHT0syeHQ2ZmJUbHNleU1nTVZoMitKWFFFY203aGZhZnNZTDBQNHVwa3N2OTErbjIwalRCb0NZdXYyd1NqcDZoUE9lMVFtU1hzSnZXUDk2SGJySE11OUJiNEtoNUpDTjJmUk40TW1jRFBEZUIrRDFBVWZSOUVCbEk1aUdLRmRBQWt0UmRMSjlnNWVHdit1cmV3VVFVMkk1VldBb0d4THozMkRsVmhIQTBPMXk3NXM1Y0wwd0FNUGJQMm4vNWYvOUFQMzNIUHYzeGdNQmc5bGFhclNOTU5hMS9JdkltYktHSXMxOGQwT0xsQzNlS21WYW5xYUpGaGpvbTZTQUd0ZDY3SGRzTG9aVXE3VXdIMDc1blY0NThueURLMFRRaUFJcFVpeVRJeEdhMkozZCtmZ3dvWG5mdk9YZnVrWC84V0ZGeTVjT2JMYldEWGlialY3UC9xOWhoQWtBdW5DNGJaOE5kYk5hUFhWVHQ3ZVB6Y2NaU2VkRDFRdUhISFk4K2cyRUdhTnBUU2V1bW1EeDRKcklqL0NOQUhiZUtTTENGMVAxUEQxSnNyaitNclJMS0xNajR5c08xWnNRVlNyMGRtT1hJME5WRTI3R0hReDJ5cDR4Yy9LajFXTDVxRE5ITTFSQ0dKM0xkdEtjclZXT1VjRGlGeVREanhkMDhlVURRRFZ2TVF0SGFFNXNnRnFwWDVXVTdPVk1rbFk4VWZzYXgrblFvQ0lPNCtROW5OTVpmOWcvTkxCazBCRG9GcGhzQTQzZzlNM1ZvQ0lJNEZ4dE5mb0NDSHlEM3pnQTJmLzgvL2JmLzczVDU4KzgrTlZXUTlOWTBOVk5tSTJ2WUpLTkhtZTA1aW9STmhpc2xwa3JVQ3FGbTNhWGszckhWWGR0STJzeERRV1kxdUVyWGV4dkhJT1oxMlFVdUlKRkVVSHBaU1FRaUpraURWNWJaaE5wOU9MRjEvOXhyZWYrTmJ2ZmVTWGYrbHoxMjljM3hNUm1sNnVwaVpIQWlPODdpR2dXNTZQRnRFeVF4OVpES1loMEFVNmIzckhpWWQwSXRjYjQ0SUFrU2NLSVR6T3hPYmJFWitrc3BYM040WUlNL0VCVjBmRmt1RGlyc0RiVnNIUnRrMkpCMXRaekxUR0xadm9OdFd5NzZTS1RUbkVTWlh6c1U4eGpjTVlSNGpibWpxVXpTZVh1NHZuMnF2ZDNCelN4cEZaVXVnVE1wVmJ6ZExoUEFJbFlqblVTY2pYdW5UTHFJRFk2SXBtYWZEMVRYam1ZWlMxWDY2UWJZbDNOTkhyRnRiZTRzSlVuZ3FoMUl2amx3NCszc3lhNlpHU3p3b3BRajdNS1BjcmZwQ1AvaE5LcXRkWWxJVVFpcnZ1dkhQdHAzNzZiNy9uelE4LzhwTjUzbjNyenM1ZUloQWhTUkpoclNYTk04cXlwTi92UjJLTWkvZXdhY0dCN1RLRkpFMElBY3JTdENJRG1qUk5XOVYwRjdPRWRSQUV4alJJcVZZWnhEZE5FNlJVdnNoenYxZ3N6V3cybTF5OWV2blY1NTkvL3NrWG5uLys2YTkrN1krKzlmUXpUMThINmpZNHF0ZVZWT0Y3UEFCV09MRUVTRUkwYlZLRExFblh1dW13U09USVFWSFZybnYyZFA5UklTbVFnbHdJTWlsWkduOW9PK0RiWFVWd1VkcEhRU1JDMVk1bVpxTWduSTNhV0xSWlVZU0FFZ3Jsd1MwczliakNHVWVTcXdqYVhWMUtBWUhZckZzYkcrUllXb1hnUEd6bXlWNVkxdCtlT2IrcWRnNUYxOXZzcUVXZURLMUhOWlpRbVppZkVpMXdoY1owVXRKdWpuY3V3dTZkSi9oV1hhVVZxbHZwL2NyWDlTSXI1ZGJWSWxUcUJKVnFzbjV1N05KK2V2eml3WFB0NTNBVDF5WUkrU2dQYjVRQUVVZXFUUlhyYnBIRmhSL1pULzJ0djNYWFgvMnJmK1B2RlVYbkx4bGpoazNUaU9Gb1JLY29SRk0zekJkenROTDBlajJVamtMRmRWMUZjbytJV2xPSlRrS1NhaEtkaUtwMVd6TEdrdWVyMkluY2JlY2N3WHZiR05NMGpWMlU1V1R4L0hQUFg3cDY3ZXJsMld5MkdJOFBKc1kwNCtWOHNYTmpkL2ZTem8zcjQxZGVmWGxzclMzYmo3SUI2aERDYXVsbnY4ZEdQSDZQa0llYlNwM0ZuY2Y3YTdkdmRJK2ZXZXU4YVMxUDd0am9wQ2M3aWJvdEpFcFZ0UXZKNThjbmJsd29SWHBiQnk5Z3VaRlNGWXBhUjVmTjBzUFNlYnlVS05FSzJkcEFzQ0pLaUU0cW10cFRyV2l0UGdhU1ZoTHBCTTI0cEpwRUJYYVZ4Q1ZqTUE3U3VOZHhQc1NBOCtGUVU4dDdSQzlWNGFmZmNtNUxHL2V1Ly9VVDMzeHVmMUsrWGxsVXA0WE9pMUcyYVZ0ZWZHajdCOXJHUHdnUmxWR2tiT2ZTN1NQRkhrR2l5WnRMenhVOFhyVG9lOS9lbnJoWmwyU0REa21XdkxEL3l0N25YT05tUitBN1RrZ1JPaHZGb2FmSUd5V0RyRlpDV2dpUmhCQVNxYVQ2TC8vUlAvbmh0NzcxYmYvWExNOGZMY3RLRFFZRFJxTlJPejF5bEZVVmRKSVFna2NLU1YzVktLV0UxcG8wemFJMWNKYWp0QktoZmE1TnhoT25sR3JxcG1sMmJsVEw4V1I4WUl5OWFxMlp6V2F6WmphZFRQWVBEc2JYcmwxOTVmbm5uNy8yeXNzdjdjM204d2tFNDcxM0xkMTF0ZVZ5Z0JOQ21CREpUT2JJNXRnbFNSS3lMQXZ6K1p6VzlsbXVBSlFCOHUxK3V2bU9PN2J1dW1PajgrYjFJbjI0U0pONzEzcnBDU2xsNmtNUUNDbksycUMxcEpsWTdMNkY1Nm9vaE5CUnVFUmd1Z3F6bFZKbkFqbklLWktFdmVDcHRjUjYwZllKVUZlT2V0bFFHMDlUVzd6MXBGcEhEVnpuc1dWRDhCNlZLWlNTN1ZnOEVxWmNpS1FyNTZQZ25HL2hLODRIM254bUpPN2ZIcVNKVmoveFUrKy83OEkvL1kxdmZMek4vaXVCMGlRZnBMMThsSjQza2ZUWG9vWWpzYXB1SW9iS0dvZHBHcXB4aGRsenJ5MUtqK0t5NWMwTUVrdmwrT3Rwb3BCYW83S0VySmN0NnYzeUU3dlA3SDYzelJ4MS9KendPdGNCUkppOE1uMURCWWhvTjhaS0tTWGUrdGEzcmYybHYvUlgvdko5OTk3L0g5ZDFmWThQbFZ0Zld3dWRibGVrYVJxVTBxSTJGWjJpRUVHc2NOV1M0RDFKa3ZpNnJwdWRuWjJGbE5KYlkrcXFycWNIKy9zM3hwUHg3clZyMS9hYXB0bXI2K3JnNnRXcis2Kysrc3IrVTk5NWN0ZGFXM0ZUZk53ZWFhaHBTZjByZ24rN2N3dUh6N2dRZ2x2OWVvdWpDa21TaE1GZ2dGWTZMQmFMb3pUZkRPait3eDk5NkQxdk9ydjFrNkd1N3Mra09OTlVKak8xb1o0MlFVaXhXbjRGNlluQjdYd1VLM0FSR2tJZEVLVkhIalFrbDBweUpYSGRrZ1pCRUlIcFJzWmNTR2FhQ0VFSk1Vak1vc2FXY1RqaGxVSzEyemZ2UENxSllFeXRGQ0lWclNDRHdMc1crZUU5MXNSWFl6MTNIUi94L3J0T1lJMGhUL1hXVys3ZS9tcy8vTUNwYjM3NU81Y3ZISG5vWmRrZ0c2bE9lcjYyMFdwWnRQMk1xVDIyc1JFbVloelZwS1RaYWVMei91aHBhY1BCSGUzY1dsblRFRUdYS2xFa1dScUtVVmNvclo2OSt1emU1NElQaTZPOVI0aVlyREE4TzJSK2ZmNkdDUkRSN2g3RWU5LzdQdmwzLys3ZmU5ZUpFNmYraXlSSkh5V0VZYS9mYzFwcGx5U0o4ODZGdXE0aDFCaHJxdWwwdW5kaloyYzZIaDlVVGRNMDgvbHN6eGo3eXU3T3pxVWJONjdQRWNJMVZkM001clA1OVJ2WHh4Y3Z2YnB3MXBuWEJZRS8wano3MXdXQ2IwdWtvMy9PQTBFSTRVTUloejl2Znd4cmEydWgzVHlIYytmTzhyV3ZmbTBsRzc2YXlLVjNIUnR0UEh6dXpOOWU3M2QrWWpaZGtPb0UyOHp4YmhFRVFTZ2h3VGlzaWIyU2J5d1kzLzZQYVIxakltQXcrSFkyYkFNeWVES2xHTlFPZlgxSzNoalNSRERQTlR2T3NGaFVHT2Z3d1VjSjBzYmc1YzFGZzVDeEtVZkcwYTVzbFVCV09sM2V0cHRzRjhVWUhqeTd3YjNuVG5Ld3YwL2RHQWJkOUlFUFBIcnVSNzc4bmN0WDJrc3B0QlJaWGlRREkxVW0zS3BIaXNTbXByS1loY0ZXY2VKb1orWlAza21FSTQ4czBYNTZDWWcweWhIcFJKTVBPaUxyWmN2NTVkbkhGenZMaTBkNkQ5dWljTUp5YjhudzNKQTN3dEZIRVRqOWZqKzg3MzN2djNmUUgvelZ2ZDNkTUoxT1B6K2JUcHVxcnZ4aXNiaHg3ZHExbmZsaVpweDFBWVNyNjJwOC9jYjE2NVBKZUZ6WHRYSE91ZVZ5YWN1eU5FY3UvbXN1OVpHMzJmOEpyM0FrS0FJUXBKU0hzakR0cjYvMkllSElpeEFQSjA2Y29DZ0tubnZ1T2ZyQ2sya3BLdXVQaXB4bjd6eC82djVFSkc5YUxodzI2Q0NERWtHbnFLS2xNTFFqVnAxNmhMTzRVSk1JMTI2UkF6NDRtdEppWElQeElYcHdlUENxSnVRcFZpb3FZK09PWis3WVNEUDZQakN1TEFjcU1OZFFhNG1UZ1NCRHF6b1NZckMwejMyMWdzNkx1SVNMZlVjNEhBcDBSeW0yY0JocjJkamM0TWJWYTRUTUZ5YzN1KzkvMjMwbnZ2clZaNjVlQXZ4ZHcvemVCeEwxSDVrWHA2UDVWZ2N2SkkwTk5BdURueHZzcktHWlY5VExFbGU2ZnoxMmVMaFpmcTI0NWxrM0Q4VmF4N3ZhUGJiMzdON25ndk5WMjNzWWhMQTZVNzdZS01Mc3lveXJYNy82aGdtUXcyKzUzKy96aGNlK2NQRVhmdUVYL3VzYk42NEZhMTNpdlZQZWUwVUlqamk3UHZvV0hlR2R4Y3ZiUXBmZGluZ1dUVTNEMGN3UWptU0dsUmJTWVFiNFhwZmUrK2hLb1pVbUwzS2tpSXc2QUsxMDJObmRlWTNFNVhnOFpqNmZNNWxNcUtiN0JDRVIrTlZnS2RGSzVtYzJSdmRuV3A4dzBWbEdDS1ZJaXh5ZHA3akdVbFVOenZrSWtSR3hwZGRKREE2bE5TRTRmRlVockVOWVF6QVdLOXRhdmxwZ2hhQnFHaFpWVFpGbDJNYWdsR1M3eU5rT01LbHF4a3ZMVEhnV2hVSWxvRk9OVHlSZVNZU1N1SFpMNzBPSWRQWkR2bmtneVJURHpaeEdRTm5VNUZsQ3A5ZGxXUzQ0TnNyZjlQNUhidnZRa3kvcy9HclZXRGZNZUdoUU5tOEpqMTlLSmpwd1k5UkhuQnBHbi9SNWpTbWJLSTVkbTBQODJMLzI4VEUvU0tFb0JoMUJFQzhmdkxqL0w4djljcThOamhvd0FuelNTK21mSGpDN1BPT05jdlNSaXg2dVhMa1NybHk1c250ay9IblRZVmdJS2VJSlJ5NjJqMXJFNGZEQ3IwcWVWYmx6OU1mVmJyWlY2Z3hDaUtPL0Ywc0tJVUxkTks4UHduOHR0UEhxWExwMDZlWTNtR1pSaDdsRjVBTHAyZlgrNk9SYS95R0VsTVkyTFV6Rm9yVWlWU2tHZzZzYUhKQXFSZU1jUVVoV3pMdXcwdFpOVXFUd0pDb0JhZEFFdElwTnRmV2VxakZNbDFXczB4RTBOdTUyYklEY3c4aENianpkcFVNbmtyVit6dGcwVEsyQmszMzhldEZpdStMRWFyWC84QzdRWDlma0hSVVJ3OUxUMURWRnA2QmN6RVBUMlBUT2s4UDNQWGo3MWplKzl1elZxeTc0MjY4dnkyNVdDOFNzd2oyN2g5L3NvVzRiUldzMjczRXJhZE0veFZaYkpJTE9XcGVzV3pUTnRQcTk4WXNIMzJtREkvWWViV2xsRmlid0JqdjZkVWx6aGVYMFJ5WkJ6VkZzMUdzQ2hQYVNFeTg4cjVFZTQyZ0pSRnNxa2FacEtJb0MwNWhEb1dscmJaalBaeEFDZDk5MUYzLzRwUzhkY2xDT1huenJMUFA1LzdIRzdzVnJ1empuWlNDb2RqcW5IN2x0Ky9iMUluK2tybTN3UG1DZEZhNnRXK3FtUkNWcEhNTXExWTVCaVNqZFZnV3hhUnFDQ0xnUVllaEtDbFNlSHJwVWFhM0pwU1JQSGNOdUZ5RUZwckhVMWpDckcyWlZ3OUo3bG1XRmJlSHVkZTNZV3hnbTB5V3BOYWhKU2ZpaE0xZ3BDUzBnMGJTN2o3eW42QXlTS0tqdEhLVjFkTEVvcmNteVREUjFGUVpGZHZiZGJ6cjU3bSs5Y1AxVGpRKzllZFdJeTdWblVnZVVEOGhyVThMMUJVb0lNaWxJQUlTbnNxMHRBdithV2p3SzBxMkUvbFkvaU1CVEJ5OGNmTXFXRWRwek9OWkZlRlZFQ3ZXVlA3cjhoZzBRWHRjTHZKNGRFRmFrcHRjOTlZK2FuN3pHQ01XNTErWnJwUlJsV1ZLV2NVVHlscmUrbGZPMzM4NUhQdnJMaDl2MDV5OWMrSjVaNFU5ejdqdDluTzlldm80VVFvU0FsSUpVU3FFMjh2VCs2Y0Zzc3hHQ3dhQW5NQUpyRFBWOGlWYUtYcDZSU0JVMy9WVkRsaVNJRUIxcGhZUXdpekQxUEVudzNxR0Z3SG5IWWxuRjJiNXdKRktnRTQwUG5yeklNTFZCVlZFZWRkU3pkS2NwQk1IVjJaTGdESWx6Q0djUnhySjA0SzR2NlZ5Ync2bGgzSnEzWmp0Q0N2b2JHU3FST09lWkxHdXVIY3c1Zm13ZFp5MUpsbEl0bDhKYW05NXpldTJIYnQ4ZVBiTy9QKzRzWkdCbkdSY3d1UlFvQWdJWG5hV2lKblkwWEdrL2ZOc0dTWDNrU1JtK0IveGRyVW42eC90a25leGdkbm42YStOWEppOGZnYmtZQkM3TDA2RHpKTXozNTd4Uk0wajRIa085MTc0WFVqSWFyWkZsR1oyaVExMVhoL1JZcFZTNDhNSUZWdmpDUCtseWUrODVjZUlFZy80QTV4eFhyMTVsT3Btd1dDd08vOHowejlBYlFnalFVZ25YT2xQNUVOVFdjTkE1ZTJ6amZGbFdNaDBNZ2hCU2hIWlNoQkNvSklsU29hMnFZZFNJaTFBU0xUWFdOaXMvYjVSU2VHZHB2S2VxRytyR2tLYjZFRTRqUkloS2pVS1NkWEpVbmtVd1psblJ6eTFuTm9aTTVuT01Od1JySXdMWkJ1WXUrbldJU1ExYkRtZFdRbkF1QmtjbUNTNkt6cFh6aG1kZjNPSEJ6UkZnSXo1TlJFbWdVUy9kdnYvY3h0MmZ2cnd2VjNpYUxHS0hjQjZrVW9RUXFKMDdyTFZYRTl5Y200WXNwcTJWWGpOeUZDQjZrRzFrSWV2bXdkYnVpZjBYRHI3Wi9qT0h5QVdCQ0d2REVjUGhnTy91UC8rR0N4RDV1aExyZitjVnZzZUpuZzdPUmFDaWM2NzkrUi9ma2xwcnVYcjFLczgrOXl3WFhyakFzODkrbDI5ODh4di9WcjZ4di84emY0ZExleE9jOThKSHJ4RU5xSTF1dm5INzl1WURXYWNyc3lRVjgwV0pNWmFxYkVBcFpLSVBiZG0wU3RBNmlVdTZXSXBoamNXM2hqdDFWZUZzN0YvS3FxSW9VblNpc000UlFzdnpNQlpiMTNSR0kvcHJRenlCMlhMSndsb21WVVZkVlNnaDhDSTZQTGx3Y3lmbnkzWUUyemlhMnBIbWttS2dveUFERVUyWlpvckwrM01XeXhvaElrUkU2d1JqYkVpa3lPODdQYm8zYURXd1I5eHRLKytwZ1NSSnlaV0tqYVk0d3JvVk4vVWFWbTljcDMxbFIzYUZtUkQwUkNMU0xOMmZ2anI5dldwYVYwY2dTNGNjb29QeGhKZGV1U2drOExmL3hsOTlRNWRZZi9Ld3dudjI5L2ZmTU45WW1oZlVMZ2dmdCtlSHNJdDdUMjZkeW5XeTNYUzZJa2h3alNmUk9xS09BOWlxSnNnb3NteE5qZFNhdEZYbENONWhuU1dFUUpwblNDRlp6cGVraWFKZkZPU2RsTVk2clBPb0xBRnI4YzZTRkgyYzkxeS9mSjN4d1FHMWMzZ0JCNU01ZFdQeFNtQ3NZMVdSSmpMNm1NZlJjY0JZVUlsa2RMdzQ3TXVVaW43amFaRlFpZ1hUYWNWZ2tHT2NJMGtUcG91NXNNNnA0K3ZGMlVFdkU5T0RLT1p0VzJ5WEpOSUtCQ0ZTRGNQUm5tTWx0SERUaHUyb3I2R1NFUjR6RUFXRHFrdDNXcWltS081NGZvTm5ydS90emJnSjM3R0FyNm9LSldYWVdGOWJzZlQvL0FYSUcrM3NYN3ZDeHRxSXE5ZHZpSEFrZzd6cDlMRTdzMjZ2azlsQXRYSzNCUklsY1pWaFlTMHlVU1JGUmxVMUZGSWkweFNCb0s0YVpwTTUxbnM2UldSRUd1OVFhR1FTOVdjVEFVcm5FV3hwSFRyTktQbzlkbmQydVhIdFJsd2ZTSmpXTlZjUFprQmdXWHNrZ2FaZFFUUXJTb2FNamxET080YWJDVHFSa1JQVDZzL0gxYWNrN2FlVVZkVmFKRWk4a3pnUGRkMkkyYUxhY3UzVWJWWDNyTkNaUG5nTU4yMmhPVngzaDlmVTNySUZyaVVoMG1melZKRm1HZjNSa01Gb1NFNDJrajMxTXljZnZuLzd5VmN1L3JOblhuaTVFa0xZSXhOTkF0alJhTVFiYll6MTV6WkFGbGN2c3BoTmhWaXBJWUphSC9SNko3dkZmY0dISEttaWJFMHJKZVNQeUlGcXBlaDJPMmlWZ0xNNFowblRoTXJaeUZWQllPcUt5anBDb2hFS0ZCR1NMcVVpMFpLbXJFazZCWU9ORWNiVXpNYlRDSXhTQ285bnVteFlsSVpDUmY2cTBvS3FDWlN0eTZ3UVlLWEUyVUIvcU9uMGRCUzJibzFvYmlKOFFSVUp4a2JJaUVwU2tqUkJTTWxpYWZqdXF3ZXlYRFovVEtSRWNkTk51bHFWZEVkNkVNOXJQZFpYcFo4TFVObUF3Y0IwR1JlV0F5ZFVvb291L3NQM2JtOTFWT0NmUHZYU0s4OGNIZnFFRVB6MTNWMzMxSFBQM3dxUUg0VHowc3VYS0t1R0FCSWhGQ0hJaDA1dkhUOTU4dmc5T2t0bDZoM2xNdXJOTGxwSXZpWWdBdVNkZ2pSSnlMczlxc1dDdXF5d3hsTFh6V3NvZFZKRzJaNjgyeUhOa21pc0dTY1VJQVNEclhXa2dQbmVOQWFqaXRCOUJFem1GY0k3WEZ1eU5DNXc0R09ncVZhUE02U2FYdkNNK2dsV0NsYlV1eFlYUkdnVjdNdktzRXlpV0RSU1JlMHNDUzllbXZDRkp5NkQ5WWNYWDd3V1dvVTRNcVZTUjZBVlJ3UHFzSWRzaHkvS09vU05FNzdKd1lST25xR3lsRHhQazhHdy85NDcxZ2VqYzZmZitjKys4TTBuZm44Nm0wZFlVUWgrc1ZqNnA1NSs1bGFKOVlOd250K2JvTFJxZFhXQ0JEZ3g2bTRJSDBZK0JFd1ZyU21jc1FUanNDTFNZOU1pUXloRlhWV2tBWFNXNEt4aE9aMnhLQ3VjYytTdGJKRW54TC92REdsZWtPVjVLNDNqNkc1MjhRZ1crN3ZVdGNHMitISnJMRFVoQm0rSXFGd3BCZGNNMFEycTlmT1RlVUtxSk52emtubzd4L3Fid0lVVkd6R1ZVV2JJMUE1WE9FeGpTYktBOXhIUC91eWxNZnNIU3pMK09Cbkc4bHJIZzlWbWVQVnIrblc0b05YZlQ5clhha0VXUW1CV1Z2aXlRa2toSm5zVG5hWDZMYVAxaldOdjJqbzIrdkppOFV2V2h4b2hESzhSRUhyalRiSCtYSjF3T09pTmpzYUF1dmUyazhlYXB1NVV5Mmdwb0VSMFY3TE80WTBsNitRa3FXYTVXRkNXTlZWWll1c0dxU1RlMlVpVlVCSmpMWjZZRVZZWnhkcUdacm1rV1N6UVNsUDBlbFRMSlNwSjBaMkN0TWhKc2hTWktDYkxpcktLMlVocmNGclNCSUdXa1gwYUFKVnAxdmRtWk1FVGtsWTBHb0VNQVJWOHErMGJPZjNTZXhJVmxkMmo1d2xVamVmWmkrTkQ0dFlxTzZnakM2OVZjQ1JIZmwwY0NZNFZjRGZ3V3UxVmVYTkhpQlFDclRTNlZaeHh6akZibEZ5OWZPWE0zc1dMNzh5VkxGYkpTN3plOHZaV0J2bituaU9mUndEa1ZwYmNFWXdkVkkwTDFqbmhnd2ZuQ002VHBnbXAwc3pMSmVQcG5DUlB5SnFHZnE5QUVEQSt5bm11NUcyY2g3SmNSamVvUE1GWnlIc3BvVEdvTk9YNnhWZVo3QjJRSndsVmJkQWk4dnlhNExreFhWSTNqaUtCUEZQTWdxQWdNSW1MK0VoV0tSczZ0cUc4WTRqWGl0RFlWbHBJUk9uUDFnTEJWb1k4Q0lwVTRiMm5yaUx2LzhtWDlyaTRNejhNaEtQR0xCeFpCTW9qNDl5akJpNnJ2NmVPbEZyWmtaK3Z5ak1aWWNZQUZFbEc4STdHQjN6d3pqcS9zd2lIMVp0NEk5NmhQOWNCY2lRNC9CM2JXeXB0NmkyWEtHbThFTDRWZnpDTklkT2FJa3Z4enJKY1J0TWoyWUlGaEE4MFZVWFRnaGVkdFFncFdTNHJ2UGZrZVliU09qNXBHMFBTS1hEZXNwelBVRXJRdEF2RWxXaTJjeDVUR3pJRmVTclJTakpmUkIrL0trQVg2QW5vQm9mcTVOUWJuV2ppS1NKUlhyUTJ5MXBIYkZoVFdkWUNkSXNrMG42dDQ4YU5BNzd5M1d1VU5sN2M1c2psVDNrdGhQdG9ZNzdLR3ZwSXRuRkhBa3UrYm1HMlNqbUoxbVJwZ1NTd0tPZElBZ0ttVG9xbmdnMzJzRzI2RlNBL1lKRnhCRVc4S0V2enFXOCsvZm4xTEZzL05oemN0NzdXVzh1MHpCS2RFRlJVSFZBNjZ1VXFtWktsQ1NxTnhqMWFLd1NSUXhHRXdEaUxGcG9zUzBnU0hWMWRxekk2N0NRSnMyczN3SG15TEtXUkFiT3NhSm9HYXdOVlpWb0Z5QWh4cjUxbmJsdk5yQkFZQ3NobEhLbjZ0UUxYeStPT2hHaHJoUXNJclZGS1JLV1VwYUhySUdtSjRjRjdidXd2Mlo5V3I0RlpyL29Jdyt2VUt0cEFXRmxuZFlnT1FiUWNPSE9rRkxQdG53MUgraGdySkNsUU5jdFk2a1ZjcHBDQzJZMFFYdUdQVXgxdUJjZ1BVSWwxaUNLK1Bwblh2ejZkLzRGR1hEaS9OWHJyVDl5MTlSOVhzOG5aMml0eXFWZ2ZESkZKQXQ0ejdIVVJCRHA1aHBhSzJ2dllleHk2dVhwMFI5UHRkVWhUamZNT3BYTjBwOE5rNzRDbXF1bmtHVVczZzUvTjBWSVFFczNTVk96TUZzeXFoaHd3d2xNNWNCWVdJYUFEZENSb0ZUVjYzWWwrL1BKOUc1dytJTFFrMFRMeVE1eEhMQzNuQmgyRWdNWllza1R4NHJVSmkwVnoySndmelE3K2V3Uk1kYVFYTVVBVEFqa3J2TmJOdnVON01jaGpTUlh4YUVrTFhaRUlrRnp6c04vR1JJUVcrQkNHRUNhM0F1UUg0N1NhQUlkWnhJUHdVcFp2TzlGYjc0VnFZKzVNdURyZUY4dlNvcmlPRFlJaVRWanZkOWdhOVRpK3RVNnZ5T09ITHdTVmk3VFlUbEhRN1VSWHAyWGRrQmM1U1Y0dzNaOVExeFU2VmNoVTB6U1IxQjBFQkNreElUQmVWUEd5dGRPcmVlTnBmQ1FvbmxEUVZlMkgwczlvK2huQk9GVHJiU2lFaUJ2MGR0cFZWNDY4ZHF4dHhBMCt3UFZGdzFlZjM4RWJGNWVCMzZOM1dQVWZYa2JPeWNxSmFrVWNueE9sWFpJalU2dVUxeXFSK3ZiWFVxbElaT3l2VmhsTEN1SEtFRjVkK3JDM1dxTWdDRG9FTm9GYkFmSURjSlNLT2xxdkxibHc5eDNyYmQ0ejBqOHhuaTU2MXJoUVNJblhraURpc25CUzFreXFPWmZIZTRRWHI1QWtDWnZkbkV5cktHR2ZwUFJFSUhjYUtoZGRvNG9jVXk2cHl5VkJ0dnE1d1ZHWDlhclVvM0dPUmRXd0xFM3NCVkpCa2dnbXk2amJlMXNPbVYvdE9RVG1lQStUS0VUajR1SlF4dUJJRW9VUFVmYW5LZzFudkdUWVNha2JTNm9WMzd5d3c4VnIwd2hmUDlLRXIwN1JUcDRNVVNPNWNZNkZNWWRCNDQ2OGFsN3JvN09TMTh6YW56Y0lLZ0o5QkNuaFVPOU1DcHhTNHFKMWg5Nk9qb0FYU2diM0JsQXkrUXNSSUErZFA4ZHpyMTZock4zcXlTYXlMRmQvOTRmdSszQy9tZDB4WDlZNHV4UzlOR1dRWjZBVnM3cG1LaHBzS3hrYnBNSGFoaXVUSmRhM25CZ3ZjRjR5Nk9WME96bVoxcXozOWlPOFhRcnlia1pQNVVqdllpTnRZOGxobldOYU5qU05vNU5FcVp6NTBsTjdPSm5DUUxVd0R3T2huMUllNjBZT2VzczlGNnV4YnVzSFVsc1BPeVYzcncxd1FGVTc1cFhsR3hkMkVHMmdoU01YZTlWM0ZFa1NBOUFha3RhUWsvYmlCeUtKWTZVOHVvSzdoeU05U2syVXFXdzljUkErVUhuUFNMYjZwb0hnQ1kwVDhoVnVDZ2Q1SUdndEVZNWJBZktEY0VhakVmTFMxZmFCTEJRaGlMdTNCcVB0UExsZkZodkppYlFma3Q1VUlBSk5YVEZmTGlqcm1sNmh5SktjeXJob254QThqYlZ4SWVjOWpmRUk2N204UDZPOE1ZOXlqRXJncENUWGtsRXZJODlTVGd3THRrWWRWQkFvRDAxam1Td3JsUER4cWV3RFN4OWg3WVc2U2FrVlVsS2U2dE1VQ2FHeHNaNFhOMVhkcmZVUitUdHZ1Rk1tbk5yb3Nxd05XZ3F1N0N6WW4xU0hNOVVWSlhSMUp4TVJBNnp5RVhEWm1JWW1oTU5HZkdYeWNuUVhVbkxJcGFaZXlRK3RaRlBiZjNjS3pIMmdVQ3FzNWNrcm9URmZIQnYzblJiL2FFVlVtdkdaMXJ4VU43Y0M1QWZocE5VaXFnUkdrcXdDNUVpeFZzNm1tNDN4TEpvZ3R0WkdqTFkycVYzRFlyRmdjSDJYdmYxOWxHaDlPMEpnMFJpTWRmZ1FmUWJqbEN1d1FXeXV2WStQYVJzY3hqcjJ4NGJHdzZ2WFpDeUhwR1NRS0VLQS9XVk41a0ZaNk9TU0pNQ3dMUVB0cW9ZZnBOVC8vL2JlTE5qUzlDclBmTmIzL2NPZXpwUnpWbVhXbEZLcEp0V2dFUWxyUUJTdGxtM0FnRHVnamQxaG9zTWRBVVFRQkJHK3NpL2NnZHQzN2I0ZzJoMXRkd2R5ZzBRNEVMSXhOa1l5UW9Ba2JGa0RtbXFlc25MT2syZmMwejk4dytxTDc5OG5UeFc0b3kxVllhbHlyNGhkZVNyelpHVkc3Zi9kYTNyWCt4NFo0TnZrR2l0WlVqYkpGclp0bXBUVUI5czFENTQ0U3VNRDNrZUtYczZMMThicGtPdlFybG9PTitxcTFONGRqSlBhaFVzWE40ODRGcVBjdGdOTWYvR2dKSy8xbEJJRW5FTE1DNElJVGZETXZhZFdsVFl2bkNuTHoweDM5N2NPVldzUjBEekc1UlRydXlXZWUrbzVZdWdxaTA2UWVpaTZXcytiZ1l2S2JGSVRtcHI1Wk1wb2RjakcwU01jV1R0Q05aMXk0OFltKzlNSjg3b2h4b2owZTNqVjVNc24wSVNBYXdLTmEybmR6WDJBTjZsWGtFd0lVV2hhaDQrd1AwMU5PY0JlVEd6ZFFZQ2hLcExCYmpDTU1rRk1aSEp5U0cyRnpDc21TN3BZMWdnaFJyd213TVM5aG9lSEk5WkhKVHZ6Q2lOUXRaN3QvZVpnOHJSb3BCMnZQT3JKRHBWY2h6ZDRoL2tmaXgvdG9Sckp4WGdnQ1pOTDRvd05yYVhJU3hUWXFXYk1YY3VnYWU0dUJyMjNiR1gyUzg2SEE2MkN4U0JnQ1pEdmtyamdJaWJMaEJBTzJCYXJSVFpxR2xjZ1FsSGtLRXAwRGZVY1d1K1l6MnY2WlEvMU1DcUdETW9CeDlhRnFKN2Q2UnlWZEo4Nm5UZk1xUkh2R1BUenp0RXEwRWlrOFVxUkdXeHVHUFlOTVVTYU9uWk1YMkhTS0ZVRHprY3lJK3g1S0RKREx4UDJWM0ttRzcwa0xXOVR0c3FNcEFWbDEvM09keXZ1R0F0dmZkTUdNOWNrczA2YlNwL1NwZ2NZdmZuQUwwQVFEMDJ5RHZja2xsZUtFWmhEZTQ5d3FJOEpoMzRPMGkxSzNUU0VFTWp6Y3JGTVZOTzJkdVpjSG1MMHZGTEtTYTlYOVJJZzN6VWpYbDdOYlpEczdOcmdMS3Fqa0J4Z2s3ZTNScUpHaUpISlpFWTFubEc3Z0dTV29wZUJNZlRMZ3RQSCtvbTNGVnYyOTJkc2VjaEpYSzdhZTFydkVCUEpGWWFqdEpkb25HTStyY2tFeXI0bG9yUmVNWGJ4c0FtVnd2SGNFZ3JZT3piQUd0UEp5TkRwOFNheHVpeTN6Q3BIYjl2eDZPMG5pRVRtamNQSGlCakxhcGt4R2haVVNGTGZmaFVJN0NzZThGZHV4VG0wNDdBSERic2MvTlB6U2s1V1VLVTBTY2ZYUjBXRFQ4b3ZJRUcxVldFdktxSGpIMzlQTGdodmhUM0lnaHduM2VUVUd2UllDRnJPWFNBYW9kL0xhZHFJTFlXVjRZRDlyYjBEcTJXYld6UXE4N3FtYVIyOU1rZXJOR3J0bFQyT0hjbFMzNkJLNHgzajZZekdPZklpb3loekd1OXhiVXVSR1VxYjZPZFZteVJEK3BsZ05TM28ra1hHV21IWVdiSEVVWmtXZ3QzakZIeXlVN0NaWlRadTBLc1ZQM0RuYlJ4ZjY3RTduZE80cEVkYTVKYk52VGxQWHRyRHFiNkNXcks0KzFpY3lSNW04UjVlL3VXdkFFM25TM0xvdnhGNXBhQWlVU2xGS1l5aDlaNG1CalVnWHRsdW9sN3NWajJML29OTTBvWGtFaURmUmRFSlJ4enN0NXhLNDFWampOSFVMa3JqQXJrMTJNSlJUV1lZSXdTZm1MSjVubEYxRXhlUjVBYmxHOGVzY1JTak11bGtvWWtSSEEwYnE2dEVZR1UwQkFKYit4UFVCVFRQcVgzeVFXbGJ4YWhRWnBMT2EwVlp6UzBNTXJaSEJ0UFYrVVlOU096VTBnM3ovWnBzcytXRFowOXk1dGlBdlZuRnJFbVNxRVdXZ1B6Rlp6YlptalN2eUFpTHBlQmh3SmhEWlZOeENDVCswTDRrSEFKSDhhcU1FdzlBcHhBRDJVSTNyQk9MZDNDaFVsNDZoQ2tWMEJNWmNzVXRxU2JmVmZnNExFOEVrR2NpdmcwU094SC9HQU4xQ0RDWkU5b1dZMHphUFFpSk5pNGt6cE5Hckpya2ZlR1RIMkhqSGFvd25jMm8yMEJ2cFVmWkt4Q2drSXd5V3JMZWtFWWoxZDRZb3FBbXc1SkdyTmhrK2xtS2NxTlUydHd3aU1sbk9VQ1MrQW1SOFpXSzRWaDUvSUd6M0g1OHlNNjRvbktwdERKRzZKY1pGNjd1Y3VIS1BqMzk4eVY2RGxOTE9BU1l3OFlvaHh2elJVWjVOYUh4OEVPVHhzaUpidTgwTGl5ZnZRcC82cFRkem1iTkE5SEk5MjZaZFN0a2tOalZDeUdJM1Jkam10RDZMQWxDSi9xNEQ1R3FkaDJkUEUyaVRMVEo5U29Fb3RIa3d3ZVlYcFl5aDhKOFhqTWV6MUJyOExVaGlpRXpqdW04WW1jOHh1VHBWbDFSbkkvc1Y0RVZTU0xVV1o2OENUMlJYWFZFWjJoSjVSUWh3dHpEVHNzWjIrZGQ5NTFtWTdYa3h2Nk14aVhhZTFSbGJWQmlKYkM1TlNWdkF4dmN0SlpTSXlsN3hKdDdEdml6NU1XYVArdTFseDBDenVITFEzdTR4Q0xSWTN3TWRNZm5BcndjNFk5YVpjcE44NFJvZ2VaN3RBdDV3d0prWVJ4NmMwaWo3dks0dVhKWEZ1Yytoa0Vib2dRZkVKTzB2VUtFMmprS2E4bU13V1lSMzBZMEJHSnVhSjBuejVKdkI1b2VRS2N4N1QrY294OXkrbm5PWkRaUHJscGQ2ZVBiZ0VoaTN0WnRaTFVVb2tsbU9DNEtWMktncVNOcldjYXdLSWtURC91ZW83YmszSm5UbkQ2eGlzbGdaenJIR2lFdkxDNUUxb2NsUmlKWE5pZnM3MWFVVVltZExkb3E2WXgzc1FtZjZNMTZaeUgrcVlkNmlzVU9aR0UvYXc0dEdnOWJjZlVQWlJ0RFVseHB1OXdoTUJQNDEyUGxXOXkwMS9aZEw2SitDWkR2cm5qMDVCcFBiVTlqazViQVhwWDIycXk2ZXZ0Nk1hMGFmOXlGUUpaWnZJOEVXdnI5SHNZYWZFZzlDTjIyMkdTR1FDU3FTU2V1bWpLQUR3SFRDZWRKakF5TGd2bDB4clJ4WklWTkJxVjFpelhnVzBmYnBuYllXaUhQQkI4VWgrRjlqNzZGamZVQnMvR2MrYmloQ1EwYkp3dE9IQjFTbHBaQW9Lb0MxaHFLd3FCQXY1ZkVzNjl1VDVoTWE0eDZOb1lHNzlKR1hqcHhxOElhcEkySWkyUUdjaXVvTVRRUjZxaTBtblNDMjI1SDhXci9pZnJRaHcya2pmbUI0UWlRb2ZNSVZ4WDZ1ZkNsQ243TEt4TU9XNjJCdG5wejRiZ0V5SGRKclBjc25lM0dZbC9tOTB4NUpTK0xaOHFxdVR0cXhCcVRuSnhRMnRaaE1wTStWMjJxeEh0bGpnOE92QktNMG9aSUpvYmdQQzZtekpCbldkb2wrTUM4YVhHYVBOc1JjRzA2c21wOW9JN1NmV0lybWJYVUxqQVB5dlRLSHRXMU1UNGs3dGJHYW85K0w4UEZnS3M5SVNpOU1wVjFDelp2VlRlTXB4WHp4bk41YzA1ZkxMMVJ3WHllVERpejNOTDRpSXRDSmdHVHdiQXc1QjJSTXUvMWNGR3BYYUNKNEZTb21wWW1ScG9RYjlwMkhkcUo2S0ZtbnU3SFFXWTJqWmovYytyOHkxYTU1dUJhaDZ1YVR0RjlrVGoydy9mbWMyVGZxQUM1OCtRUnRxYTFORDZJZG1jTm0zdGpaMkxjTElRaXhyaWVpUXd4SXRyNUtJS2tNYTIxWkZtU0tLbWFObEhKYzlOSkE2VXM0bndrK0FTU3pCZ2lrV2xiNDBMRUlqam4wdTl0SGFpdzJ5UkgyMUV1YWZQdEloT1RZVVJwdmFNTmp0Q1JKR01IQnVjVFZUNHZMR1V2dzFwbGZ6cG5ienBIRlo2NFBLYVplKzVlSDVGbkdVVW1EUHNsZVdhSlVkbWR1YVFrbnd1ajBsTDJ5NlRkbFdVRTF4S2RZOVRMMlJqMFdDa3kxbm85ZWxuR2tlR1FmcGFUaWRDekZ1bE9hZzg3dkJyQUdETWQ5WXJQVGxyL1JJUmRFbzl4NFVVZnJhQXJGbTMwZS9jNWVzTUM1Tnl4ZFM3dnp4WjNFZ2NtcFM5UDZ0MW45K3MvdmYvc1NidlJrN2ZONnNaMjJnNVlZeEFsUGVTWlVMV2VFQlhKVFdkU21idzZnbGRDNnp2QUpKY3A2YTRTUTRpRUdQQ0pCNVo4QlZXWjFFcXUwTGZTalllRmxWR0pLWEpVQTZHelhVd05lQVFqNUhuR3lxaWtLQXd1dE94TjVreXJCbFY0NGZxVXB5K1B1ZS9vQ3JldjlJaWE5THg2Wlk0MWhpSXpESE5MUDRkQllTbUxuTXpLZ1M1LzFBUnc1MEp5SjlDQWFMb2hXU2x5VmpMTFJyL0hIVWVQc3RicjA4dHpWc29DRFI0YmxSS3d4dVNsTlU5UG5mOWFCNDZGM1Zvd0VFY1dIUWhNNC9mdWMvU0dMYkVVbUx0NGVHampTT1JVVzZ2ZW1EWE5VelBycmxTK1BpUEJXQ09XR0hPaVNTVERuWjB4Mkl4c1VGQmtGdTlDc21DMmdNWk8yVVFSalJUV1lqTkRrZVVnbHRZNWduTmtKb1BTVXJ1SWl6V0REQnF2U0JCV0I0YXNYN0JuRE5HbGNnK1J6bXJaa09XR3NtZndvV1hlcFBKTk9rZmNLenR6dm5saG43a0ducldPWVcvQXNhekhLb0w2UUJzaTA2cENRNkJmOUJJVDJLUXJ4Tm04UWpEMGl6eHQrMXVQY3c3WFJEREo2V1UycWNoekljc3NtY0NKdFNNY1gxbGhkN3hQNFJ3MURVYWhpYkdNclZ2QlNFdlVBeUg0aFExMWxwd2R2cWZqRFp0QnptK1BLYktNMHNwQ2YrcGcwaWxnenUvUHIxMmIreStlR0pici9kemNpUkc3TjVscEFHeWVFVlhGV0VPdkxCQnI4REY1YzRTb2hCaHhJZEkyTGxrNUcwTmRKUkVISHlOVjNTWUF4VlNLamV2SVpoMFpTdHIvNVRadHY0dWo2d1JqMHQxN25pZUZ4a0lvU3dzU21OY040M21ENjh4RFhVaFUrWXZiRmRlajUvaGJqckwrbGhQVXQ2OHd2MjFFSEJWazNhZDdvUkJkUUNKa1dVYlpLN0VpM1hSUHlhM0ZHQU14WlJKZEtFdDJsNDVDK3JzRDlQb2xyV3U1Y3UwNjNuazBhdWZBeTlWRzlUZG1rZWU0NlNibFM5QStxRFd3NVpjQSthNE5Zd3huVnROdGgxZVZRN3dnOVZIalhodjJZbFk4ZGFUZmF5QWJpSmdOSmRyR3Q5akN5c0xVTlVhVnVuYkVrTWErODdxaGJWM0tLdDN1d3BpazVWRzdscnB1YU5ya1FsdFhnZDBxVW5XS0pabWtHY0JvclU5eGRJWEdPN3g2MnRqaVFrTlFUK3NjdGZPcGJNb3QybmtVR29RYk8zTXV4OERSdDUzbXR2dFBzWFp5eEdDdGgxM3YwWjdvTTc5OWhEc3hvRDArb01ndHRnbEVGOGlTMDF5U1FsSkZRNkk2RjNtVzJNSytPK3UxWUxOMDFndkNhRGlpTFBNa3VsMG5aa0VBOVJDRDhMazkrRVJJQTY1NnNmc0lncTRBTy9GNy94bDZRd01reE1qYW9FaW1teVN2YUgzbHJreTM1KzNraFhIekRSZjBtd0Z6ZnVyamRTTjJ3eGhUSWtqVE5xWnFHMjI4MTdwMVRPZXRWRldMQzZFakZONXNjVFFxVGQyaUlyUXU0anpVRG02azJ5dFdKYVd2d3NKRGJ6dkgyOTUxSCt0clE0bzhXUnJZYnN5OE9FaXFnMmZlZXFxbVpUS3J1Ylk1NWZ6bW5ONTlSem43anJPTWp2VG9qM0o2dzV4ZUw4T1dsampNaVVmNjFLZUd1TE5yaER2VzhCc2wwUUN6RmordGljR25iQmNDV1pFeEdQU1RaVU5VYkpheWg3RlFGRG5EUVIvdlczYjNKL2pRc2JRRWFXQnJEdjkwQnM5MDRLZ0ExeXR0UEhGMHdPYk12U0dlb1RlOExsWVpJeS9OVys1Wkgram1yR0h1UXp5MFhJNkFiM3h3VCt6T3ZnbzgwYk5tZEt5WG5TdU5uRDQrS042eFd0ajdoN25jNVZ3MThDR1U4M2xxM0YxSXNwL1dHbzJ4WWRTemtvbmduTWRZd1N1NG9EVGQzZlpRWUV0aFhhQW9jL3BySTBZckEwWlZ3KzMyR0tkT0hXRm5iOEwxN1RFMzlxYk02cGFvTU9vWGhCaVMwVjhSNmE4cHgrNVlaM0MwcE13Tmc5eUN5TUZNdFNCeHgzSVY0b29RVmxiZzdBcnpPaEF2N3hGZTNrZXVUK0RDSHRZTFRkWGdHazl1QlhvVzV3SnFPbUVJNzlqYTJxSHkwSHJGQ3Vta05wbVRmSGthK1NZM1ZVZ0RRc3hHQmNNM2I4RDEyUklnM3d2eDlPNmNNNnREM25leTVMTlhvOXBHNHJRTjJsbnZIdWJ6RlFoTkhXSjFhZGJ1QXZuNWFmdlp2alVieDByN3lFajB6Ukw4dlZZNEpTS25ZOVNOVEZUYU5vb1BVTGVCMENrakxvWkZRYUhTMUJNMDNZMUdEemh6NWppM256M0szczRlYlYzVFZBMlpOYXdQZS9TTG5MTW5OaEJyRGh5bnJ1Mk9FUkhtVGN2bWZNN3daSi8rSUNNM1FwbmJaQlBkeVFZdENNd2lzdEJWSndyWWdkRGVmUVIzMnlwdTdnaVh4OGlrUmErT2FiYm1tTDJLdkE2WTNDQXhvaXE0T3RMNFpOTldtTFNkandwNVAvZXpUTDRZOXRzcGV0UHZYa1J3VFZCWks5OHd6OCt0b0t6SXBmR01mejZlY2ZkYWp5TzlYTmZMakt1ek5yb1FEM1ppQ2c2bDV1YlJYQlpWODZrUDA2a1BsMGg2Ym1zRnJBM0UzRnNLZCtkQ1QrRjBWRDFqd1dTRkhhN2VQcnFqWDVvOE5KRjZ2MEdiUUsrd1RMMWlmQ1FiNU56NWpqdTQ3OEhiMFNiUStrRFZKTnZwdGcxTXF4clRUYk1tczRaWjdSZ01DbHlNakNjVjl0aUE3UFNJTEV1OVFwNGxoWkxrTTVnT21UcjNFTEtzczQ0T2lUdVc1czRHelMzeHpCcStEc2pwVlppMXVCdHoycTBwOCswWk1wNVRBQ0ZYVEIzcGlZTHpSS2RFUlhwM3IrdWd0SFA1NnZVV2NLb2FFS0l4RW9kckpjLysyeGVXQVBsZWpKZjJFM25pOGJ1TzZMajF1aCtqV0pFUTB3bEc1MHlvVHRQemRPQksxWUdtampDdTRVcXQ4ZGxPTnFvUUdGaFlBM3FqWVg3ODBiOTEzOCtkdkdQbDRmbk0wZXcxTXAwNmJHbHBtc2g4N0NpeWpLZE85aGhQcm5HTUhOdEVqa3JHWUdqSkJzTFJ0UldNTmN6bUxVVmhXSEVGVVdCU08wYURrbWs5U1g5aWJzaXR3V1RKS3lUVDVMWXJpYWljSEJoVWlKSnUyTDFQeXBHMlZESWYwT1JsZ0JpUXd0SU9DK293b0FxZTFnUUthK2ozU3dwTThrdDBFZHRHOHR3d2V1aDRuRDIvMDZxcUV5UWd5Y2syK0cvVFIzb0prTytlK0xGN2ozTmo3Z2dSY210MHZjdzQwc3ZqOVZuTGJ1MFdSM2NMcXo2anJ6ektlL1hMS094N3VBSDA5L2VhSzVlZjNmdm9rVHRYZm41MGNuQnU5WFJQeTRqTUdzWHZ0S3plWm9sdFpOOUY5dW9wdm9sNER6MXJzSjJ0d1JCRFVKak5HemE4WVJTZ0RNcXFXTVpWVFYwS2d5SWRZQmtycUFqV3BIbkx3cW83TjRKcVVqQXhKTWNvTWNsR3I3Q0N6d3lhUlNTWEpIa2EwMGREMUdRUm5ZdEprN25NRUUyM0R6bGVJdFpvMGN1SXhseXJ4KzJsamc3dFJTUXVURnQzTGsvZlVNK0x2ZFVBOHZUMm5BdmptcWJiS1V6YXdFKzg1U1EzS3NkVzVSUmoxRmlMR0JNVmljYllhSzBKSWhKVTFYWExNQ2NpcllpMFhmK1M2bkFsWFBuV3poV2IyMnVqRS8ySFVWWk5WTjI4UE5mSmpRYWJaUkpDY3F3MXlTNEVhNFZhaEIwWGNFYVlFdGxwUFZNWHVPSURMOVkxTDg1cVhoalBlT0xTSnRteGdsTnYyU0RQb0pkWitvVkJUSG9iRXlWZHNKMDh6OEtFMngvb1gybW5nS2pFb0lTZ2VCZFJyNmlMK0xuRHpWc2tSb3cxR0d1eEpEVVRzV21SbVJlVytiajV5dVVudG43YnpkMFVxQVQ1enpwRkx3SHlQUndMSnQxWHJvM1pycnF4cEUzTWsrZzlSbFdqUm8weGFwWmwwUmdUWTdMdkRjWVlMeUtMRGYxQm93cm85ZWYzcncrT0R1cVZFLzIzVkJNM3VQajE3YXU5RTZPWUYxay9kc3FDWXFEVjVHNGJmS1NkTzJ4dXNVYUliU1IyL21yZFdKWHR2VG5UL1NsM3ZlMEV4KzhZVVZnWUZBYlRVZW1OQVVRWFJoejRxSVNPU09BN0FxV2hFNEFJaXZjeGFXeDVSWDBFSC9DMXc4MGQ2Z00yTTlqTWtKVUZ0c2pBQ0dLTmlEVnh2Ti84OXVZejIxL1dxSE9nRmhIWDcvZkNtKzQ3eDlibTlodHJsOFl5WGhuZUU5M045ZS9DOXYyUlJ4N1JmcjhmUlNTY08zY3V2UFd0YnczSGp4OTNaVmt1emk0cUVoZHBFdHF3OTVYZmZQYVRMMzU5K3plZStQejFQNHFScnhXRGZFQk1GbStMa3NZWVNWN3MzU0x2b0s2emdyRkNrUnV5ekJJYkIrT1ozMWpwYlo0OE02ektRbGtyaFg2dUdLdVVoYUhNRGRZS05oT3lUSkJ1NmhRMGJmZWxvL0FMaWY4aGNLRFllSk9wSm1pTWVPZlMzekhjOUwxVlFLeWdSbVp1MnI0VVhXZ2hsVmNpRW84ZlA4RlAvZVJQc3N3Z3QxQzg0bXhWbGFxcWNNNnh1N3ZMei83c3ovTHd3dzl6OGVKRkJiUnBtbGVjVkFRWDQrYXplOCsxKy9YWFR6MTAvRDFpN0gzcU5mWE9TQ2Z5bkI3U2F0d1MyMGplcytBamNWR3MrRWkxTTJOMmVXK3Z2anI3Z3hNbiswOCsrdmpwQndhNVpLUENZaVFwaXdTNTZZMVlHSVB2K29FWWxiYnJtelVxSVhUZkZ5RUdpQ0Y1VGNjMkV0dEFQVzFwNTRuelZaWTVHcFc4eUREV29NYVE5M1BFbWhlM0w0Ny85WFJ6ZGhXb1JLUVdrYkMydnFiVnJPYUZGMTU0UXowRDJSSUcvLy9pNnRXckIxLy8waS85RWwvOTZsZTVlUEVpdi9BTHY4Qlh2dklWZnUvM2ZpOXViVzM1VklFbGJMV1RWcXRNL003RjZaZkxQWGN1NzJkM1o0TThONWxnaXd3N3lEU3pvTFVIYXlWR0lWWmUyM2tyYmx3eDM1bFhzNjM1TS9WMi9kbnFXdlgxVXg4NDlZR2pLeVlURlMyTlNPM1ROVmpSWFlSNTc4bXpIQ3VDR3NneXdZU2IycnB0akJTYVJzakdwdWxYakpydWtidDBhYXpCSkM0YU5yZUlOZWxsdWl2SzJqKzM4L0xlVlE2ZGpLaXFYcjUwV2MrY1BmT0dlOStYQVBrMjRoLy80Mzk4OFBYZitCdC9nMGNmZlZTLzhwV3Z5TTdPVHZyY3Z5bXhxZFZlRTEvNjNNWGZYRGsxK3Nid1dQLzkvZlh5Y2FONmQzQXVsd0lqUm9pU2gvTFl5dFhaMXVSSXV6Y2YrRms3YnNiTk4rdHgreWZWZHZOVlAvV1RvbWRYemoyOGZ1Y2dGMk0wTmVLUmxBVkVoRXdNTWFUK1NUWGxLSTJwSjRrQjB1OUp5OGZPYVBkbVl5L3B2MmNXL1ZlTStJTmpzZzd0eHFoUjZuYmVQdE9NMndscE1SaTZDWlo2Ny9uQzU3NndCTWd5WGhsLzkrLytYZjdoUC95SFBQSEVFL3EydDcyTnA1OStXcXVxUWxWYk9yRUlOMjc4enJpWjdEekgwMnRuMXo1ZDlNdzUzOVlQUi96OTNvVThHdzUyZXBlbXYrTm5zL3RkME51MTVYUE5YdnUxZHVMMnUvZW92M2E4dDNiSDNhTTdjMk9NS0ZoUkNwdEt0U29FRUV1Um0wU25GNGdvS29BSTBTZ2FFbFhFR0tFTlN0c0dRbmNocVhrR3BWSkxOMjd1L0E5RkpFMjhZaVRMTWpHR2NiVlZuZWVtSUVNd3htZzZObnRqeGhJZ3IwSDgvYi8vOTdIVzh1aWpqK3J1N2k3ajhUanU3dTV5cU55SzNSalk3Vi9ZbndMUFNDYWZNYm1NVktQbHhzenZ0OU02TDh3ZlJ5R0VKaTRrMERNUitxcnc2QWRPM2JHMlZoNWRYUFVGQld1RUVxRXhpb2FJR2lHM0hZWGRwUDJJU0VRTXFkVHE5TDBXakUzVDdWQ2lDRzFueHBubkdTcEM2R3l4TlVSc2JzbXNJTUtrbnJrYmg2WjJVVVJpdjkvWHFxcmVrTy90Y29yMUdrVUlnY3VYTC9OTHYvUkxQUDc0NDZocU5NWjRZNHdUa1pwMGlqcnRYaFAxdWhlcWVEbldYSXl0WGhWaHg3VnhKelJ4ci91ZU9WQ3I0dktlelI1Nzc4bEhCcjFpSlFiVW1yU2JNRUJtaENJelNaQkJrdys3b0NUeEZVMUtLQjNOWFJJR1VGMkFJNVZSSVNyUkpYRWZrU1R1WXlYOW1oaERsbHMxaVJ0MmFidzV2UVkzRjRTRHdVQi85RWQvOUEzN3ZpNEI4aHJHcHo3MUtVSTZ0VlZWMWZ2dnYxK0h3MkVRRVM4aWpZaFVJaklUa1ltSTdJdkllUEZTWlV5NnE1aDBJK04ya1gzdWZzdlJZMmZ1T25KL1puT2JHeU1nWkVoM3ZKVW82RlZJdmgzcUFnVEZTT290Y3VsR3lXbFZubzdIdXV3aENuWGo4VDUwbDdpSzh4NGYwd0dWc1lhOHpEQWlZcTM0dHZZdlRXOVUrM1NPVVVBc2lrS24wK2tiOWoxZGxsaXZjZnppTC83aXdkZnZmdmU3dGFvcW5Vd21ZdElGMG1MeWMzajdjT0E4b0txTG4xODRNWnN6SjA0T2YvcHZ2dXZ4OWRYK202TEd0Q01oN1ZPc2RBY3BvUlBKVXlnR09SckF4MVNDaGM0WkYxVjhRZ1pHa3R5UEQ1b3VKVHREME9DUzE2WWc2YzZldEhRMDFpQ1ptYzMyNmljNTVOU21xbkU4SGxQWDlSSWd5L2d2aiszdGJhcXE0dXpaczNyeDRrV0d3eUZyYTJ0eE9Cd1NRbEpFaVRHaXFseS9mcDJxcWc1TVpVVWtGekg1ei96MDQ0ODk5dWpHVDB5SzdXRWJrK0ZuejNTMzZ5S0lHRElEUFF2ejdtR1BDQkZCTmVLaTRrTHFPNHdSWXVCQTI4dUZwQ1c1eUNhNjRCb2UrRVRMZ1NDRkdLbjNyMHd2SHdKNVZGV2FwdEVPL0V1QUxPTy9MSDc3dDMvNzRHc1JZVGFiTVp2Ti9neGY2V2QrNW1mNDNkLzlYZWtBMGlucmFPK2VlKzRjZmVBRDcvbFFQcnh5Y2lkdXFoZ2srTVFRdENMa1JtZ2p1S2hZVlVvUjJvNWh1VkNXREJGc3B6bmNSdTNHdk4zVjA4TEw4QkN0aGM0dzFKQXlrR1RkemtUWW0rL1Z1d3VBZE9QZENQRHBUMzk2MllNczR6dUxCZHYxejR2TnpjM0VsVXJOUWlZaXBTcjV1OTl4L3ozdmZOZmJ2dS9VeXB0RUtzUkhUMmxTYVpVWlN5NzJvUEVXRW1EeWpxallkbWZHcW9MVEpEMkVwcEV0c2J2OTdVQVVROFM1bEZyU1gwRVA5SGdSVWF5SnJ2WVhRaHZHUUVRSXhwallpWU8vb1dNSmtPK0MrT3huUDh2MjlyWlIxWVVNYnRudjkzb2ZlZnk5YngrdURFN2RjK1l4dlhmdG5UU05nMFZKMUxVdm9wYWVzUXp6bk5KbUZNWmlqU1dxSG1oeStaakVycnNubnNPWCtZc3ZGMVkzMG0zVE01dlU3SzAxbWhWVzUvdk5oV2JtSnFRVnl4dVN1YnNFeUhkWmZPQURId0JZOUI2aXFsMzIwT3p4RDc3N25zYy85SDAvWWtJb01tdmt3ZHUvbjRlR2IwTmk5NFRxVFRaeWFVMmlseWlJZHN1K21DeVhKU2pTT2VndTVnTGVKNEU2WTB5U1RZMUpTRTVEeWpEUzBkdkZHdFNJaUJGWFRkcnp2ZzN1OFBaOFkyTmpDWkJsdkw1eDc3MzNJaUlTWTF5b2VoWkErZGYrOHZzZkc2ME96NnBHQ0o2VnNzOTc3dmh2ZVdqbG5lQU1RVk1SRkdLU01RWEJSNmg5b0dxVHFtTkl2NVVjNlVDVEhMRU96SEJpSWl0U2VkUUZ2UGZFemt0UlREckdNa1pFWXh5MzgvWlNsek9DaUVScnJiNzk3VzlmQW1RWnJ5ODQ1dk81cU9vQ0hMbXE1dmU5K2E3ajczN3ZXNysvYjJWZ0ZwNVEwZEhMZTd6ajdJZDU5NG0vVEw4WkVVSWdxaEF4K0VCU2NBemFLYW9rc1Rsak9zNVdWS0tQRU5MeVVEVFovMnFNcUVhSUlKcVU3VldWTExNWUkyb3lVZS9DdE5wdnRsSXJsVFJTYjRYK1l6bkYrcThjNit2cnNydTdlMWdUdWdUSy8vRi8rTkdIYmp0eDVFR3orQUNMcmx0L1EyRkw3anYrR0tjR1ozaG0rMDk1YnZJVUlUWlVxaFRXRWdKWTBqaFlGQXBKc2tPcGR6RW9rUmdETWNTYlh1cVpRV01FbFFVOUpta05kNDFPRExyVnp2Mk1oYVZ6OXozeitYelpwQy9qOVluVHAwL3o2Ny8rNjlSMXZUQnZ5b0RpTFcrK2EvMEQ3My9zaDlaWCtpZFpPQ21yVHllSUpvZm9NTnB5WkhpVWQ1MzlJWDd3N0YvblpEaE5mV05HMjdsUDVVYklKRTIzMG1WaWx6R2thL0NqcGw4TU1XM1hYVXhYaGFwa1dZYk5iTmZEcTFocnlLSmNEM1ZZK0gzRVJRYjUrdGUvdml5eGx2SGF4OC8rN004Q0IrTmRvNnBXUkhwQThaTS84Wkg3M256M0hlOGlJaXBaNHFwaklDdFNxUldTblFMQll6VncyL3FkZk9DdUQzTm0rdzdhSjZjVVZVUkY4TjJudkRHZFAzclVwRURSOVNDbVd3ekdtSnJ6MEhiMGtxenpZdXl1SGNVS1o5ZlhUOXg1N01oaEswTlZWVTZjT0xFc3NaYnh1cFJXaTVIU29yektWYlVZRFFmOVJ4NjU5eDFyRyt2SDhWNUZPNG1yckE5aTBIYUthQVRKT2wwZkE2N2k5TVpSZnZLSC8zdWVmZUpydkhqeFcvaFZ1TjVyZWNidjRtTGlWb2toWFE3NlFQUkpHQTdTWmoxWk5zUUQ0V3Bya2tLY0NKcUo0VlJlYmx6cEZaYk9zZlo3M2Z0OENaRHY4cmh5NVFwRlVRQVlWVjFNcm9wM3YrdlIyNzcvWFk5OGlPQXlNVG1ZTG9Pb2dxOE95RnNMVXdFTmJVY1BVVVpseG1PUHZwMjd6NXpsbVc5OG5kUHRqRWVPbk9WcW5QUDg3alV1alBmWThuVjNRWmpFc0pPbFExb1VKaEtqcHRHdVFPelFlVzgya251eS92US9lZDl5YUcwQzhPS0xMeTRCc296WE5vNGNPY0luUC9sSnFxbzZHTzEydTQvaUovNzZYMzN2eHZGamQ5R09PMHRabXhyMDRDSDZwTW9lQXhvRHhtUm84RjJabE9nbmltRTRXdUgrUng3bDBvVUx2UGpNQ3h3dExRK2ZmWWo1VWNlelc5ZTVOdDNud3Y0ZWUwWEx2TFZzVnpORUxEYlBrU3lqS0hKNldjWmFrWEd1TitMUndTcDFDT054Vlh0NGhaVWg3M2pITy9qeWw3KzhCTWd5WHB2NHVaLzdPVDcrOFk4em44K2w2ejB5RVNsVU5Ydm9MWGZkOXFIdmYrd2ptYzFLeEdpNlduTGdEMXRwQm1KSUV5M0ZKQ09mdGtZa1dTOEU1MUZOVWtDMzNYNEcxUERjY3kveWphKy94S2tUR3p5NGNwVDdpM1cyelFhVHBxWVplVzcwcC9nMWh6dGEwMVlOempzS2diWGNNckpHckhkY3VqRjU5cVdyZTlWaGNDUXJ1amQrbGJWczB2OENveXhMM3YvKzk0c2toZWswMmxVdGdPS3YvNVgzUEhMeTJQbzlKcXFJS1FTeG9CRU5EZzErNGJPQVNEcUYxZWp4cmlXRzBFbjFOTGkySWZpVzFqVlU4emxyRzJ1ODlaRUhPWFhiR1M1ZjNlV1AvOE9UUFB2Q1pYempXYzk3SE1sNzNGNE9PRXBCUGcva004ZW9WVVlSSkVRYTc0bkFySGE3NDFuVEhwNWdyYSt2OC9mKzN0OWJsbGpMZU8zaTZ0V3JYTDkrZlpFT0xKQXJGTWVQcmEyLzg2MTN2RGY2ZGsyTlNWZDlIYmxRYkMvWitFUVBKSEFFNy9CdGkzY09NUmJuUEs1SkR1Y3hlcnhYdkhQNEVBaHQ0TVRKRFZaVys5eTR0c1h6TDF6Z3VlZXZzYkUyWURRc0lVYW1zNHFxVG9hai9jSVFOVjBaRm1JeHh0UXU2cGlPNG02TVVSSFIrWHl1UC9aalA3WUV5REplbS9qYmYvdHY4OUdQZnBUdWRpSTE1MEtKVXY3Qy8vU2o5OTErWXZUWTVmTXZ5Y3F4RTJScHZwU2FjVEZwRDBKYWJFUlhKNGRhRGNRWTBPQUpQbW43eE5oNWw3aEFOWjhucnBZS3JxbUp2bVZ0ZmNpNWMyZTROdWh4K2ZJV2w2N3NZa1VwRGVUU3FUTkNwL0VyUkJXcVlNWXpaM2E1dVFPSklxS1R5WVJMbHk0dFM2eGx2SFp4KysyM2k2cWFHR01HNUNqbDZlUHJvM2UrKzRFZnZQUGVPODVzdnZ5TU52TlptbGJGemxVOU5Lbk02c2E2cWtJTUFWSEJtTzUrUE11UmpzSHIycGE2cW1pYmhyYXFhSnFLR0R4dDIxQlZGZDYxYkt3UE9YZjNLZTQ0ZTRwZXIwOElpUlpmbEFXU1dhTEpjR3BvbzZXTlpqS3AyMzBPalhnWHZjZlpzMmVYQUZuR2F4TVhMbHlRL2YzOWc5NURSRXFnL1BDSDNuN0hnM2VlZU1mYStycGRIUWdYbnZvR2FtemFkWmc4N1QyNlYxeU1kNU9CNW9IQUFwcEVJN3hyYWR1V3RtMEkzdU85dzdVTlB2ZzB4ZzBlYy9QQWw2S3dESWQ5SW9hNkNUZ1BVUzFHTEdWUk1Pb1g1RWJyeWJ5YWs4akRFVlVWRWF5OU5VUTVsd0Q1QzRyUGYvN3p6T2Z6Zzk0RDZCVkYzdnZMSDM3UCswNmZYSDhUd2ZEbVJ4NlNiMzN4UDNMMXlpWElUSHA3Yklsa0paaUMyTmJFbUppNk1YaFVVNE1lUWtoZkE4RjdnaysvRnJ2bG4zY3R3VG1jOHplUHBycnl5N2UrVTN6blp0OGppaEF4b3N3YXQvLzg1WjF4VjFwRkVkRWpSNDdveHovKzhTVkFsdkdkeHcvLzhBOEQ0TDJYUmUvUjdUM3l2L25mZmVpQjkvK2xSLzZLVWJGSXptampHRWVPOVBpVFQvOCtUVDFOZmJFZGd1U29yMUlXQ1NIWkhSaWJnQkFqeHRodXVwV3NFRFJHTkNvK2RGbkVPVnpiNGx1SDk0RkV4QTFvZE4zMWVoS3B0a1lXK2xjczVCZGI3MjljM1o3TXU3d1RqVEY2N05neHZmZmVlNWNBV2NaM0ZsZXVYR0U0SEhMYmJiZUpxa3FNMFpLMjVyM1JjREQ0cVIvLzBBOGVQYkp5TitTSVdMSVllZXp0YjJINzBubis5RSsrU0xTS1NucDR4VmdrS3hZVkZkRUhRdkRkV2p2UlJvelk1TTN1UXJxb1ZjVTVSd2lobzVNRW1ycWhiVnFxcXFWdFBUR0VORTRtSFUxbG1kQXJMSU4rcmxsbVl1dkR1R3I5Z3Fpb2dPWjVma3RzMFpjQWVaMmpxaXJlKzk3M3ZxcjNvRkRWN0NkLy9JY2VlUGpSZTk5dmZaT0p6Wk9HYUhBYzJWampQZTk1TTMvd2J6N050Nzc4cHdnT0RZbXdLTmFtUmowcU1RYXN6YkZaamk1NkUwa3FKTVlZdlBONDUzSE8wZFF0emlXZjl4QmpBa1pVNnNZeG1WYTB6dU44b0drOTg3cWxkU2t6QlEydWF0MTIyL3IyMEJSTE56YzNsejNJTXI3em1NL25mT2xMWDZKcG1wdDdENlVjRG5xRHYvVlRIMzcva1pYaG5aS01OeEtseE0xQURROCs5R2J1dm11TmYvSC9mSkliMTI4Z2Vaa21XcDN3ZEpMd3ljanlIbGxlWW14R0NKR21ycW1yS2drQys5Q2R6eHBBaUZHVFFGeE00bkF4UnBxNkpjYVFUSGRJbXI0K1JCb1hhRjBRalhpbmNhcXFCelFUVmVYKysrOC91QnRaQW1RWjMzWTgvUEREZk94akh5UEd1QkJSTDREaWIvN1VmM1B2UGVmT3ZEODNOdStJR3hCYW9rc1ByR3JHRDM3d1VXNC9Cci96aVgvRGVEWk5tM1NWQkl5c0lDOUt4TjcwSlFSRGNDa3pXSk9SNVRrMnN3U2ZUbW1kODUwUVhPY1Y0c0tCSzI2TUVXc04xaVNwSDJzNkI5M0N1djFaVW5KZkFNUVlvNWN2WDlaYjVUMWNBdVIxaktJb1VGVlJWYU9xbVNwRm1abmVEMzM0UFgvcCtQSFZjekYwYWxTaFRTUkVsT2hiZ3ZjTWhpdjgxWSs4bmQwckwvQTd2L0V2cWVvS2srWFlyQ0FyKzVpc1JNU21qYmx6aWZEckE4RkhmSmM5dkFzZ2N2RHZnblM2dktiTFJoSG5VMzhpUUpZbEdhSE1Kdi8xUExlRXVCQ3A3bFNFVkxYWDYvSGpQLzdqUzRBczQ5dVBYLzNWWDJWbFpXWEJ1MXFNZHZPLzlIMFBuWHpnM0pudks4UVUzWkVHaEJwaUlJWkFjQzNlMVlCbGRXMmRIM2ovVy9qYWw3N0VILzMrRjlDRjdLRUt4dWFJelRFMlQ5a2pLb2pGQjBkZFY3ZzJqWFUxS3BrMVpGa2lUYWhxNmpGUTJ0WjFvbHFwdk1wdEVxek9zMlNsTUcvODdxV3R5Y0k1NklDbzZKeTdaZDdISlVCZXgreFJsdVVpZzFnUnlhdzErWWNmZjlkOTUrNDQvWUFHVDFwT2QrV1ZUK1ZWN0lDU3VJbVcwNmVQOEtIM3ZabmYvOVJuK1BKLyttcVM0dTIyN0RGRXRMdWNiZHUyRTg0Mm5VT3R3WHRQMDdURXFJUVkwL1FyUnF3UnFxb2xoSmpxdnN4MndEQ1VDeVBScUxRK3pyZkcxWmliRmc0cUl0b0pkTjhTc2VSaXZVN3gwa3N2RVVJUUVWbWMxQlliYXl2RkF3Kys2YjFadnplSVZhdWhtVWd1Rm1LRHhqU3QwczRGTjNiM0g5WVdQUHpXdTlqZG0vSWJILzBFUFd0NTRPRUhDQ0hkaGtSTnhNUUVscVIxbFU3T1U0TWVOU1M5M3RDSlVvdkIrNEIzUG8yS1l5Q3pLVUU0SDdFMk9lSEdxQmlidGRPcWJRNWxEMTNvQ1M4enlESytZNERNNTNORXhBaGtxcHFmUHI2MmN2YjAwYnNRRVdPRTBNdzZ4VU5MOUQ0ZFFIV1d6WW1ONjlKNDF4Uzg0N0UzY2R1SmpIL3lUejdHRTE5N3NwT0VUOXYyR0NGR1FkVWNiTW1EVHdKd1J0TFBGVVdlQkt1ZFQyTmQ1M0d0UDdqN0RTRTU0WWFnVksybkRVcUlzZDNlbTdpdU1sTVJ3WHRQMjdaTGdDempPNHRQZk9JVE1wdk5KTVpveEVpbS9ZZ213UUFBRS9kSlJFRlVxdkxXQis0NGU5ZlpJMmVrYmNRa1ZRU20rOXRFa3hGaklMaWF0cGtSWEkwWWtBNEFZT2tOQnp6K0EyOWxZeVh5UC84di93ZC84UHRmUUx0UGVzVVFWWWxFeEFpWnpSQ3hCNTZEZVphbDcrdVl2c0VselN5NjBXNmlsMGgzVDZ1RW9Ha3JqeElUQVV4RjVDQjdpTWdTSU12NDltTTBHckcvdjgraXZPb2FkSFBpeE1ZcDIrK3RhZWVEVmc3WENMNWhQdGtsNnczQW1PNmhOcDJ1cUdLdG9TaDdaRm1QMWRWVmZ1eXZ2SjEzUDNLUy8rdWZmWnpmK0kzZllUYWJrNWNsMXVhQVJTUTUxQnByc0RiREdFdlVtNGRXYUNxaDZqclJUdEtXZnFHWnhRSTBha1NZek9iTnBHb2RzSmdsSzhENTgrZVhQY2d5dnNOUEhtTUlJUWhnWTFRclF1Lzd2KytSZTdKc1VLYWhsbUt5a3RYanR6UGR2a1pUUTI5MDlPQXFNSHFQYzNOQ1ZFejNMaGt4cksydjhVTWZmSkRWbFFHZit0Um5lZjc1bC9uZ0I3K1BlOTk4Qi8xK254QUN4bmlRQ0NMWVRzemFCWThQRVI4aU1TaStreWUxeGlacG9NN2dVeFdLekxJN21lTHcwY2VrcEtpdnVrZGZacEJsZkZ2eDh6Ly84NHN2UlZXTkNCWXdkOTk1YXYzdDczam9uWVhZSWtsVkpmWkoxbHRuZU9RVWRWTXg2eGFDTml1UnhRNVJ0VHV0OWNsQnFoaFFsRU1lZS9odS90cUgzOHJ1MWhYKzkzL3lhL3pxUnovSmswOCtUOWFOYWxPajM0azVxSFI5U21vbTZzcmhmRGdRa3JQR0pDK1JFQ255bkZuakdNOW1ybkxoZk91Q096VG12ZVZpbVVGZTQvRGVzN0t5d213MjYvaFhrb0dhSC8zSWUrOWNYZDg0SXhoQkQ3a0hTRWJlVzJYdDlEbW0yNWRwV29jMUZ1OTlSeUdwMHhXaUdreGVKTHZuc2tmUlJzNmVPYzZIZjZEazh0VTl2dm4wSmY3WlI1L2xnZnZ1NXR4ZHQzSEhtWk5reG1LTXhkb01TQkkvM2tWYWw0UWZjbXN4Sm8xNVE0ek02b2J0OFJqbldzNmVYUEhYYTc5SmNyTzlKYlBIRWlDdlUvK3h2cjR1bTV1YkMxa2ZDOWlINzcvbnpyd28xaGRhY0dtbGJSTVB5NVJrWmNuYXFaSnEvd1p1UHNhV0E3SnlTR0NYcHBwMzNLcmtiOTQwamhBaXh1YXNycTJ4c3I3Qm0rKzltNTI5S2RzNys4eW11M3pqV3p2MGVnT0tMRSthdXlFd20xVHM3OC9ZbjFSSThMZ21FRFFRb21jOG45TDZodlZoai9WUlNhK1hLMjFZK0JIR1d4VWtTNEM4eHZIZ2d3L3lXNy8xV3d2MnJsVlZ1enJxRCs2NTU4emQvVHdmb0NnYTVhWVpZTWMrQkVReUJodTNFMWFPNDZzSm9aNnhrcGZreFpUUU5waXNTRTE1MDZKcUdIb0luU1ZvTlpzeUhCYWNPRHBrWjN2TTljMWQ5bmR1c0xNL28vWEtmTjV3NWRvdWUzdHoxSWUwNzlCRWRlL2xodFZoeHUzSDFsZ2RsQXpLakY2Wis4M2RuVzBnQ0VSRTFCakR1WFBuZVBiWlo1Y0FXY2EzRjVjdlgyWStueThjYXkxZzd6cDdjbVg5NU5FMzVabTEybGFkR0xWTmQrZXlzSHBhVlBvUm14WFkwVG9oTHduMWxGSURXcGJrUlkraUxHbmFobXJ1b0hhSTk5UlZ6WHcrbzVyUGFSdUhzYkN4UGlDM1FyKzB0SzNueG5ha1dpbFI3NmdxajJoZ3JWZXdNaWdvTXN1b2x6UHNGZVNab1YvbVV1UTI3a3liZExVbFJHTk1qREhxQXc4OHNBVElNcjc5K09WZi91VUZPQllqWG5QbjJkT2p2QnlzNlVLaG5md1FLUFRnMVBYZzY4NTQwQXBJMFVzanBxanA0S2x0bVUvbk5JMW5OcThJemxIWERmUFpuTFpwaURIaVdrL2Jlb3d4OU11Y0dDTERYc242YUVCMEFhdUJYbTRwaXl5UkVqT2h5RzJpbnBpY29yUVlhK3J4dk4ybmN3NGgyUjVvMHpUTEhtUVozMzYwYmJzNEpqb1FwMzd6bSsvYVdCMk5WcEFNa2E0bTBxNElpNzdMS0tUZGgvb0Q5ZlpGTXk4aVlNQlhGZlY4a3I1TkEwMWQ0VjJnbWxmTXA5T09SQ2kwcmV1a2dCWTNJT252Rm53Nm9qSmlrdk90UmxRTmc2SkloRVlyRkpuVllTOW5mOVplMkI3WG02UWR5S0pSNTkvOXUzKzNCTWd5dnJQb1pEa1hEYnA1N05INzMzVHE2TkhiVVFPMm42UkROU0N4dTJUdHpEWFRzWWJwUUpNTWJRNDBlVU1nQmsrV0ZhajZKTjZnRWU4ZFRWMG40WWFvaWJEWXVkNkc3alpkTzZDRXBOaU9FU0d6aGlKUHBWVy95REJXeUROTGxobktJdFB6bTVOdm5yKytmOE9JeEpoY3BlS3RPTVZhN2tGZVo2d0FrdVZsejJaRmpraW5QaEpRMFZTNWFMeXA0SDdvOFZPTkJOL2lYVVB3RFcxVElVWW95aDRpYVNwMWM3a2RLY3NNYSt5Qks0TE51bzI4U09Ka1dVTlpaUFRLZ3JWUm45R2d4L3Fveitxd3BDeHlla1ZPbm1VWVk2UnVRM1Y1ZS9LTnVnMWV3VWxLZS9HMjIyNjc1ZDdBWlFaNWZjRUJZQ1RQaXFhWm1aMlhuaUtUR2g4QzNqbjZneEhHNWhSbGo3dy93dVE5REJGdEs0Z2UzOVpvQkdQVDNia3hHYWhERUxLc0lMT1d1cnNnOUtwa2VWb01PdWN4SW5nZnlYT0xpTkEySGwzcFUxcEQ5QUZpWkZSYStyMzA2OFpJeWg2NVpkYTQ4ODlkMlhzMnB0TEtMK1IramgwN3h1WExsNWNBV2Nackc5WDFsK0x6WDlqWFpucE5UdDkrSkdsWGhjRCt2akt2V2pBWmVaNnVCSzB0OEQ2UTV6bWowWWc4ejhtTEVwdGxCSjhhZFVYSjhnSnJNL0k4cHpFT3lRTDlzby9VTGQ0SHNzd1NRcFlHeWRHVDU0WkJMOGVLMEZRTi9Vem9aZEtKMEtVc2syZWl3MzdtbnI2Njk3a25MKzVlQjF6M0NzWVlmZE9iM25STDJLNHRBZklYR3pxOS9wd083M3NMZDk1L2pyTGZ4N2ROdXRQd0hsVnd2cVdlVmJoMlNyVmZNWjNYek9ZT3NYMUNNS3h0ckhMMDJISFcxbytSRjBPaVdseW82UTJIdEM1Z2JjdGdZREZXY0swanp5dzJ5enFkckVSTzdQZHljbXZSV0VOd0ZBWmNTRGVLdmRJaW9tVFdpQXZ4OGhPWGRqOC9xZHlzQTRjSG9uTk9QL0dKVDl4U1RONGxRRjR2UktReDcwR0RZQXgrOWNoR0xBY3JWb01ERVRRbzBRZmFOakt2SGJVSFp3VS9LaGdOK3F5MExlT2RNVzMwN04zWTUrckZDeFM5SVVVNVpMUzZ3ZXJhQ3RZVzVGbEJsdWNZTVlUZ3NWbEdWdWhCUXg1OUpQaElyeXh3NHBGQlRxT095YlJCRlFhOWpEd1RKRTIyNHZWeDlaVXZQSFB0K1E0Y3JZaDRFWW5hU1k0dWU1Qmx2Q1lZNGVhWmF0d2VOOWU4RkxzMnM4ZWlRRjFWYk4zWTQ4Wjh3c3kyMUgwSW80eldra1FXS28rMWtjR1JqS01NV1BOS082dXA2eHJuYWk2L3ZNa0xqWkFWaVFKdkJJbzh3NW9NUk1qeW5IWmFJNklZSzVpczQxd1ZsdENDODJtTG4yV2RVU2RDa1JrRWRwKzd0djhuMDhydEFXMzNDbm1lNjlyYUdwdWJtMHVBTE9NMWl5aVM3cGlldmpDK3VOL3E1ckVzUDRaWUxtN2U0THh1VVoySVNOOVEyQjZxQmhzRkZ5SnRHV2xzNElvMFBGVk5XWStXWTBYR2thekhzYkxQY0ZDenMxc3hxMmRjdnJCRDQ0WEJZTWpheW9qTUp0bWVvc3lKd1pQbkdiYTVlZXZ1dlpKbGxyS0lCMElOeG9BeDZMVDF6Ly9oRTFlK3ZzZ2VRQkFSdmUyMjIvUzk3MzB2SC92WXg1WUFXY1ozRmlzcks5UjFyZDc3cUVvQXdwZStlZkhHZk80dWljZ0QrMXQ3WEpodk03OHpFTldReDR4QXNsQ3pHR0ozdDVGT1lJVTJWNjVhei9YZ3NWWE55bnpPc2NheVhscFdqU1ZEbUZXT3phMHRibXh1MCsvM1dWa1pNdWdWU1huUmdwaVc0Qlh2a3Y1VmtXY1lUVHNTYXdRUjBjeWE1dm5yZTUvYjNLOXVpT0JWRTBCVU5aWmxlY3R0MEJleDNJTzh4dkdMdi9pTG5ENTllbkdpNm9IdzRvV3R2YzNOL1djYUg5MzIvcDd1OWlybUlXbmpOaEgySnkxMUZRa0tUUXpNdkdQcVBQT1FkSzBzQnEvS09QTThtODM1WERIbU00eDVPbFJNTFl4R1BjNmNXR1Y5bE9IYU9lY3ZYT2FKWnk1d2JXdWZXWlUyKzBWUmtCZEpUQzVkR3lZbEV6R2kxZ2p6MWwzNDhrdGJud3RSbXk1N2VHTk1VRlY5K3VtbnVSWDdqMlVHZVIxaWQzZVh3V0JBMTM4RUVYeUlXai83MHVZTGIzdTRHbCt0ZG82Nm80SEtSWElyWkNKb0NIaFJvdWI0V0tXeHF4VTJ0K2RzREh2RWtPZ214NGREZkpneE01NGJ1ZWR5YkRGUk9lNHNaL09DVThNZS9WNU9XV1RzN002NWNQa2FXWmF6TWhxeU9pZ3Bpb3pnMHBCQWpFSFM4bDZzUlM5c3pmL1Q4MWZIbHdDblNpc2l3UmlqSjA2YzRQcjE2L3ptYi83bU1vTXM0enVQN2UxdHpwOC9yMTFFTkkxS1AvdkZaNTU1NGJuekwrOFVZNkpOdEt1NWR5alFYeGxBYmdneGt0bU1YbDVRVlYzZm9FblR5c2ZJcEUzZm4xdERhWktiYlVYa2FXcSt3SlNuQnA0d3lGbGY2WEg2eEFwMzM3Yk9xR2U1Y1dPYjUxKyt4c3ZYZDNHQmRFRzQwSVZQcDdiVHkvdnovemlwMnJsQVE3YzkzOWpZMEE5LytNTzNoSnZ0Znk3czhwRitiZU5iMy9vVy9YNGY3NzBzV0wxQS91S0ZHNzQvVXRlL3YzallGUXhkVUhWUlJWWG9aMzJDUnByZ09vRUY0ZktOTVNxUkxDc0lQaElpVkM1MFBLN2tIK2lEMHJwSWpoQVZydmlXTFEyY0hBMDQxaXNvOG93aU4rU2RpTnpXN29TdDNSblRxaVV6bGpJek9paU5USjM3Nmg4OWRmVVRWM2ZtMjhCOFVXSU5oME45My92ZXAxLzR3aGR1MmZkem1VRmVoMGgrSEVHTk1aRzBhR3VieHRmLzk3Lzg4aCs5ZEdudmkySkVYVlI4Rk1adHhkeFZGTFk4RUZEd0liQTNyckRXNHJ4Mm9BR3pZQUVEcFJWc2xvcGtOWUlWUVQxY2JHditZTGJIWGk5amRkVGorTEVSR3lzbEc2TWVwemFHakhxRzZ6dTcvSWR2dnNEdWRDWjVicVl2M1pqOCsyK2MzNzY2QUViSHZkS3RyYTFiU2tWeG1VSCtncUlvQ2xaV1Z2REpaaUJsRWNFMjg4RFJNNlB5bmdlUHZpOUM3bFZ3UWFsY1F6OHZHR1I5ckZVMnQ4WTg4OElOTms3MGlkRmc1Q2FSMFhTTlF3aEt5Q0tOVjZJVGJCVGF5aUdaWmR3NnJyY05kNHlHOUh4RVF6aFFjVGNpcWZGVXozVGVVQlQ1azE5OGNmUFhYN3cydnRabGo5b1k0MVpXVnVLcFU2ZjQzZC85M1Z2NnZWeG1rTmNoWnJNWmYrZnYvQjFPbkRpUnZNN0FvVFJBOC96WHRyNjFmVzMrZEc0RjBhZ2h3dHdITG82M3VUR2ZrTm1TaXhmM21Vd2JzdHdtMzQ2RHExeEJTUW9sTGlxekp1QlZpVjd4UG9uR3FZSUc1ZnhreHVmR3U4eXR4U3VNVmtxR3ZZeTZhdkhPYy9ySWtMS1hWOSs2dFBNSG4zL3Eyc3RkOWpqWW5QL0lqL3dJLytBZi9JTmIvcjFjQXVSMWluZSs4NTJzcjY4aklnZGxGdEE4OTlXdFMrZWYyLy9qMXNmbVlIQXF3cVQxWEpyc3NEM1o0L3o1WFQxMllraVdHeHBpbW1vaFdBRTBlUWhHb1BaS2JvVVFOY2xnNXdaUW9rQmhEUzlOSm54cFBtYXdQc0o3WlRLdWNIVkRKcXE5SXVQWTJ2Q1pKeTd0L2xFSWNVN1huS3RxS0lwQ3o1NDlxdzg5OU5BU0lNdEgrZldKcG1tNGV2V3F4aGpWR0JNV0FIRzFuLy94djNyeFV6dFg1bDh1ckVocHdFZ3lydW1YOE16bEs4MkxMMnp2SERuV2k0cVF4NlFTSk1iUWV2QXhZa2tJOFNGU1pvYkNtTzRvdGxOaXRJS1I5TDNmM05ybUJvSEpmczMyMWdRclNyL01aREFvOTUrNU52NzFKeS90UGk4M2FTVmVSUFQwNmRNOCsreXp0NVROd1JJZ2Y4SHgwei85MDN6OTYxL25JeC81aUpJc2xFUDNLZDI4OE1YcjU1LzkydGJ2emV1dzE2clNCaVVUeGVhcUY4NVBkdkxDYnZVR0dkTzlRSmdyRWlLWk1mZ0FHaE94TUNpNE5pS2lTVStYQktKTWhNSmFDaVA0Y2NPTkY3ZDQ4dGtyWE4vY1I1S1VxUTc2dWQrZnU4OTgvcG1ybjQrcXRVTFZsVmRCUk9LMWE5ZjBvWWNlNGozdmVjOFNJTXRIK2ZXTDU1OS9uc2NlZTR6UmFLU2F6bFlkVUFQTnYvKzFaejU3OGZuOXp5RHFWYU1XaFZBMTBYM3o4OWVlT0g2cTMrWjVadW9xTUF1UmlZUDltYWV0STBSRGpFbGJLemhsNXBVMnB0djFMRGNRbE5ubW1LMFh0dGg2ZnBObVhMRnpiWi9wWkU2V0crMlhsdHFITC83QkU1ZC85ZnJlZktkcnpCdkFXMnRqVVJUVWRjM096czd5RFZ3QzVQV1BmL1NQL2hGbFdiNWk1Q3RDdlg5bGR1UHp2LzNTeDZaN3pWUERYTEFXYm16Vzg1Mlh4MCt2bitnWHhsanlMTGs5dFVIWjM2dVo3dFhNS3MrMDlreWFKTitqZFlEZGhuYXZZZWZ5bUplL2RKNExYM3lKdlplMjhMVWpSbVUyYWJBQ1JXYVkxdjVMWDNqMitxOTg2WVVienkybVZvRHJ5a0R0OS9zYVkrUlhmdVZYbG0vZUVpQ3ZiM3p3Z3gvazRZY2Y1dDU3NytYbzBhTUxrRGhWS29UcWljOWNmT3E1TDIzK2FnNDdWZ3dYbnRoN2VuVzltSnk2WTdSQlNJcnJDenE2V0F0Rnh0d0ZwazFnYjliaUtvOXZBdnNYOXJuKzVDWVh2M3lSeTkrNlJEMXJFQ3VvRVV4RWpRdFlJN0Z4NFUvLzhPbHIvK3NmUG5udGE2U3lhcjZZWEZscjQxdmYrdFpieWh4bkNaRHZndmpHTjc3QjhlUEhhWnFHN3JZN1RiU1VPVUZuZi9ocnovejdpOC9zL2RydVRydDE1YW1kTHh3LzFmT0RsZDZnYW9OaTlFRDMwMWlERjVKRnN3OU1OaXVpUXQxRW1qYlF6QnJjcEtMc0ZaVERIb2lvRVVGQm93dTd1N1A2MC8vMjY1ZCsrWXN2M1BoR0I0N1pvakVIWXBabFRLZFQzZC9mWDc1cGgySzVLUHdMaUtlZmZwcXpaODh5bVV3V245QUhPb3JOeExXWEwwMmYzNXY2YTFlK3RmWGxleDQ2Y3ZmeGMwZmZQNTFGbzRnNGIyaERUS1BjaFRPdGMyeGRIR05XQ29xZ1RLL09tZTNOOExPYXNpem85UXZOeWd3ZjlGSzlXLy9iMlkzNUo3L3kwdmJIbjc4eGVVRnVncVBwc2tmc0psYzZIQTV2eWFPby82OVlzbm4vZ2tKVmFkdDJjV1ZJMTdBckVLNThZL3ZhbFc5c2Z4SW8zL240bVllc1NKdFpHVFN0YW9oUlFxZHRsVnNETWRLNjZId2JKcjFldnRyY3FMTFoxcFIyWEtrZ1luSkROUGhxN3I0MHVWRjliT2ZsOFZkaTFMM0ZjRURUajIzMzUwZFZqUjJ4OHBZbUpTNHp5SC9sMk4zZFhYeTUyQThlUHNzOVVFNXZBL3Y5alg1Wjlvc1RZbVFZdkpvWVlrZFlqRVNVYXQ3dVhYOTY2d3ZIM25MMDlQenl1TGZ6d2cyaWQ1S1hXUzJaZlhteTMveUxyWmNuLzNSOGJmWXRWY1pkcjdGb3lCZGxWVGowNXpJZWo3bHg0OGJ5alZvQzVMc3E0cXVBRXZldVRPZlAvOGNyWDUzTzNGTW1zOU1RVlVMVXZOWFlkNWtpR2RUYnpaVkxYNzc2cjQrYzI3aHIvNFdkRTlPcjQwMk1QT21iK0s5MnIxWC9kTy95L1BkOTVUZTdVbXJHVFlidWdVb0p0NmpmeDM5cHlQSi93WC8xLy84SFZna2tWZXNTNkFNRk1EcjE0SW03anIvNXlKdnk0LzM3OHJYaXJsR2VIWjlmbVc4Lytlbm4vN2VUajV4NHBONmNuTnM5di91VnR0R25tcG0vM3ZVV2ZsRlNjVlBiS3ZKSytkQWxPSllBK1o0SmN3Z2t0Z05IMlFHbUk3VlRERTRPVjFlUERRZjRhRys4dUhNTlJXTlVyMUdyUXdCd2g4cW9QODhBWnhsTGdIelBna1JlQlpUc0VFamtWZjJMSEFKRjdJQ3dlTDI2eDFpQ1l3bVFOOVI3c1FDTFBaUmR6S3RBOG1mNmwwTS9GMTgxQ0ZqR0VpQnZ5UGRGL3B3WGY4N0RyNGRBdzdMSFdBTGtWbTdvWC8zd0w0SHdPc2IvQzZ5UFJTREd2TVk3QUFBQVJuUkZXSFJqYjIxdFpXNTBBRVpwYkdVZ2MyOTFjbU5sT2lCb2RIUndPaTh2Wlc0dWQybHJhWEJsWkdsaExtOXlaeTkzYVd0cEwwWnBiR1U2VkUxT1ZFeGxiekl3TVRJdWNHNW5KWEhHRmdBQUFDVjBSVmgwWkdGMFpUcGpjbVZoZEdVQU1qQXhNeTB3T1MweE5sUXlNem95TnpvME1Tc3dNRG93TUkxY3dtQUFBQUFsZEVWWWRHUmhkR1U2Ylc5a2FXWjVBREl3TVRNdE1Ea3RNVFpVTWpNNk1qYzZOREVyTURBNk1ERDhBWHJjQUFBQVJuUkZXSFJ6YjJaMGQyRnlaUUJKYldGblpVMWhaMmxqYXlBMkxqWXVPUzAzSURJd01USXRNRGd0TVRjZ1VURTJJR2gwZEhBNkx5OTNkM2N1YVcxaFoyVnRZV2RwWTJzdWIzSm5uTDI1U0FBQUFCaDBSVmgwVkdoMWJXSTZPa1J2WTNWdFpXNTBPanBRWVdkbGN3QXhwLys3THdBQUFCaDBSVmgwVkdoMWJXSTZPa2x0WVdkbE9qcG9aV2xuYUhRQU16a3plNE9XZlFBQUFCZDBSVmgwVkdoMWJXSTZPa2x0WVdkbE9qcFhhV1IwYUFBeU5USjlYOUJkQUFBQUdYUkZXSFJVYUhWdFlqbzZUV2x0WlhSNWNHVUFhVzFoWjJVdmNHNW5QN0pXVGdBQUFCZDBSVmgwVkdoMWJXSTZPazFVYVcxbEFERXpOemt6TnpRd05qRk5UdGdmQUFBQUVuUkZXSFJVYUhWdFlqbzZVMmw2WlFBeE16SkxRa0prSi95bkFBQUFNM1JGV0hSVWFIVnRZam82VlZKSkFHWnBiR1U2THk4dmRHMXdMMnh2WTJGc1kyOXdlVjgyWVdJellXTXhNVGhoWXpBdE1TNXdibWYrY3ViakFBQUFBRWxGVGtTdVFtQ0NcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL2xlb25hcmRvLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDMwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUG9BQUFGZkNBWUFBQUJuU3RIVUFBQUFCbUpMUjBRQS93RC9BUCtndmFlVEFBQUFDWEJJV1hNQUFBQklBQUFBU0FCR3lXcytBQUNBQUVsRVFWUjQydXo5VjVTbFYzWWVDSDc3blBPN2E4T2I5QWxrSnBBQUVsVUFxZ3BWS08vSlloVk5VU1FsVXFSSWlhVFlUV21rdGRUVFBRL3pNUE13ODlBemE3Vm1UUzlOczlXYWtkaFN5NUF0aWlJcDJxcGllUTl2RWtqdndrZGMvN3RqOWp5Yy8wYmVEQ1JLcE1ncUFxaTcxL29SaU1nYmNTUHUvYit6M2JlL1RmamVHdjBaSDhlWTJ0U205cGRtNm5zSWNQb09uMDhDbktlZ245clUzamhBcDd0OEZCTVh2UWJJWFhWTmduNEs5cWxON1hVSTlJUGVXd0NRNDQ5RWtOWG5CSUFJWUFZc015eHd4K1dtM24xcVUzdDllM1J4QU9RQkFFVkF3SHpuODQ3UlN3VExqQktBbWJqczVNTmlKWkFiTjMzbnBqYTFQNGZKNzJJK1B2YmFDa0JFL29vWmlBQ0VoK2FDMlhmZFgxKzVkeVdhcTBleXR0a3o0MUJkMGUySVlESjBaeVVJcFdYODhGc1c4UEptT24zM3BqYTF2eUtQVGdkeWNRVWdKRUlNUnN4QWNPWndQUGZmZkhycDNMMUg0cmVIaWJpSENRSUd1Nk91ZnZZenp3eWUvWC8raDYyWEFFZ0NpQ2RDZGVHaDc5NStvc1doRXROM2JtcFQreXNPM1drUzVBQVNaaVFBZ2g5Lzk4dzkvNGNmV2Zya0E4ZmlqODgyNVRFUkNjWHdBWG81c2g4OWZqZyt2OUFLLzhYLzZkZHZmcGJ1elBPWkFYWU0zaGxxQkpLbXVmclVwdlpYRkxwUGh1ejdJQWNRQTJqOHYvL3VrWGYvblI5YStQbUhUeVNmcU1keUJRNWtDbWFYT1labFNLWjRycUdPTE5XaW8ybGZYbm5xeG1Dck9qRHVxTUozVW9NYm5RSUE4Skd6ODdpOGswM2Z4YWxON1hzTTlQM0NHeEZpQU5HaDJYRHUxLzcrMFkvLzhMdG1mdkhJWXZDNEJCSm53TEFnWWhDRW9FRmYwbUFvbVV0QWo4SjVhYVB3eVJ1OTUzdVpTYWtLMlRGdXZSR1lDUHp1VXpQMGxlc0QvTkk3Vi9IdDY0UHBPem0xcVgyUGdhNklFSUlSQ1VMdGYvNzd4ei82OGJlM2ZuR21LYyt5aG1STEFCTVJBMElDMlVCaWIxdGltQ25xalFSdDdaSVVwSlpYMm1IM1QxL2V1empoMGZjOXV4VEVoWGI0YXc4dlVxZ0V2bm10UDMwbnB6YTE3eUhRSlFBbENCRUR3WVBIa3RWZi9mVFN6eDFlQ0I1M0JnSVdKS1FIZUpFVGRyY1Z1dHNTa2docEJ0ellaSFJIektFVVNUdFdzMGxJbDU2NU9kaW84blV6QmpxQmtHcm5tSUZoYmxBNllKQ2I2YnM1dGFtOWhxbS9aS0FUQUhMc3lURHZmYkM1VkEvRUVYS1FrcGxKRWF3aDdIWUlWNjlMakVZQ2tnSHRIRFo3RnFQY0lRd2xNWU5ub3VDK2R4MmYvZEZ2WE8ydG5kOFkzU1JDd3V5QjdwZ2RNY1J6YTBOZWFJWVFOQzNPVFcxcTMvUFFIYjRRRi83Q1J4WWZ2bSsrL3VHQTVhd3VnZEZBMHFYTEVsZXZDWFFIaEt4a2JQUU5ydTFvZElaMm53ZW5KRUVTeVprNFdGbG9CRnRmdU5TNTdCaU9Eb1R3RE9KQ1c0d0tDemVGK3RTbTlqMEZlakFHKzgrOCsvQVREVlgvUUg4Z2s1MDlSWnM3RXIwK29VaUJVVzZ4MWRYWUdwaDlwcHNnL3dNZ0JJR0lRMEZKTTFKTGNVaVhuMThiYmxaOWRYczdoQWM3Qm9nSVBBWDYxS2IyUFFNNlZTQVBBSWpadUxaOGRLNytXRE1KNXpKTnZEdDB0RGMwMk94cXJPL2syT3VYc05iQlZTZ1ZRb0NGWjc0TElwSUV6TmJDMlNRUTltWXZlMkd6WCtaMEFPeFNFTHZxQjBSS3drNWQrOVNtOWozeDZPTVdtN3l3TWVycDFDNWV1akc0LzZWcmcvQ0Zhd08rdXA3UjdrQ2pzSXdTRE1zRWdFRWdrQUJBQkNrSVJBUVFtQUF4VXcrT2hrcHNQM3RyY0xrd3ptQml5bzE1WE1NSGxCQzRkN0dKM1ZFeGZXZW5Oclh2RXRBbnZib0FFSlRPbVF2Ym84dVhyL1dYcjkvcTN0dnRwMUpiNzNGSkVGZ0lFUGx4TmxHaFY0QkFnanovbFlrYzRBSWxvcGxtdU1UZzh5K3REM2NPaHZDb0duWktFczBrNFJUb1U1dmE5eUIwMzc4SUNEVnpTUUkzNWhWT1MvQXFNNE5Ja0JBQ1NnaElRVkJDUUZTZVhJSkFGWUxCQUFraXk4eFJFaXdJSmJEVHoxL1k2cGRaOVpBeDJCMFJPSlFTelZqUjNxaWN2ck5UbTlwM0VlZ0hRUThBUWVFd0RJQXNKRDROZG0waUlpVVZLU2tnaFlDU29tcStFNlFBSEFPRy9FbWhBSVNCQkJPd05CdmZTd0xiNTI4TlhpNk5Hd1BkQW1EaGVYWm9KeUdtUUovYTFMNjdvZnNrNENlQkwvc08xeU5Da1VpK2o5azFISU5JQ2tSU1FnbUJVUHFlT2h6QUFtRGw4M1RKOEdWMUlsYWhrTzBrV05ER1BYVnBhOVNwaENyOHpEcVJFMFM4Mkl5d001eUc3bE9iMm5jN1I2K0M3bGQ1ZDltenVGYVhSREh4V2NzMklaS3NwS0JRU2FncVQzY0VYM25IN2ZrMWNvQWdVTW5BWEQxY21LMEh5YTFPOXUzdFFaSGl0amlGQThDRmRseE1oU21tTnJYdnVrYy9hR1BRQ3dEVU43alNsbGhTeEdjWUVFSUlFa0w2L0Z3SWlPclI0eW9iaUVEajRYUkJwQWxZYUVaSGpYVTNMbXlNWGk2dDIxZWlZWUFMTSsydlRXMXFmNVZBQndIQ0FUYTN1RmtqSEJad0p4d0FJU1FKSlJDUThHMDE0VDI3bzZyTk52NXU4bDhYa2xSYU9uVmhmZkRIL1V6ckNhL3VSMmFVaEl3Q3NMSFRkM2hxVThOM1grNTVIRU5yQUlLck1MN3ZjSG10eFA5OFJMaFpJWXFIaDFJNklVa0lFQnBoZ0ZnSUVBQW1COGNBQ3dIRERCWU1SUlltRUJobTFoWEdqZlhuOXRWbEdYQmVmMmJLZjUvYTFMNVhIcDFmNC85Vnp1Z29ZRHNoM00vT3p0cktzMHM1OXVxKzdFNVYrTzdkTlNNVUVydkRjdnZiVnpyLzRjTG00SUoxWEZRSHlkaXI3OHRFQzBWZ084WDcxS2FtdnNzZ3B3bXZUbVBQWG5sZXNhSHhqWUQ0MStkaC9oNG9YNUJDTUFpa0NhaExoWUFCWm9FQ0RoRUoxRUR1NnZZUTM3emVlZmI1VzcybkMyMUQ5Z00wQ3JmbHBJa2RFNUVERkhFWWh5aHozMjQ3Ky9CRElBRE5wSTRvRE8rc0dCTEJHSVBubjM4ZS9YNi80cy9mZVVpTTA0aDZyWWFISHo0SHBRTHNkYnQ0L3JubnBuZlMxTDd2YzNSNkRhOU9EQ0IxV0lzSUlnQS9hcXdSam9oa29FQlNnSVRZQjVoempBdWJBL1BaODV2aXBjMCtNbU9mQm1FYnQ0a3orL1BxNDZlU1FrSUlBV3NzUUlTZHpTMHNyaXhUSElRVWhDRkpLY2tYQXdVcHBZaUlhSE56azRxaW1DVCszRjQyNGRGUFlSVFM2cUZEcElLQThqeW5uWjBkek0yMDhZN0hIc2ExRzdlbWQ5WFV2dTl5OUVtQVQrYnIrMEFxR2JTaDhiOHI0dVVabUo4WVpUbkxNQUJKQVJDQmxhQjBtUFBsbldIdi9QWndjM2RVTGpQakpBVDlRMUwwYjFpNy93UkdDQzhqdlIrNk13TkdXNGVKZ3B3UUF0Y3VYWUh3M3B1c3RmdUhVT1c5aVlnb0RFTXdNMVgvY0x2TjUwZGpVWmFhdi9XdGJ6dm5YdDNHazBMd2V4NS9GRzk5OEQ3OHYvNlhmelc5dzZiMmZlUFIvN01lWHpNS3g3Z1NFWm9LZk1iQWtRTnpwZzJ1N3c3cDJWdmQzWXU3NmVjSGhWa0NhQm1BQkdPUmdQc2dpT0h3TWc1dzN3L0VFQVNBbUptTTFrSnJMWnh6d2prbm1GbFdsM0xPS1d1dGNzNUo1NXoveUU3dC83OXp5am1XNCs5enpwRnpqcGlaOHFMRXJmVU5ZakNPckN6VDNFd2J6SXh6OTkyTFM5ZW5YbjVxMzM5QXYyTXB3L2dxR0FNVzlJb1VwQzN6cUZlWXIxN2NTWGV1N09YTG5jeEliVkdIb0VNQVJ4TlJRUXRFSjBtS0RUaStjcGUvNTJBSUxnQklabGJNSEV4OERKZzVaT1lBZnNRMkJDZ0VPS3crcjc2Mi8vK1NtY1g0cWc0UmdKbWtrTFMydVlVWFhybUVkck5CUk1EYXhqYVVKRFFiTVk2c3RMRXdWOGRlZDdxQVltcHZ2dEQ5b0kzemFqMytuQUc3by9uS3lPSi9GTGx0R2JaVVdEN0VBQkhqdlNSeFVnYUJzS1VtSmpDWU5ZRkNkbWhDOGhFQTlTcDhud1IxZWNEVFQyNlFrVUtJTWVnRmlJVHYxRE1CRUZYb2ZyZEZrTlpYK21BQXRzeTNWMGM1WnV1TWNWSUtaNTNqRjE2NTVIemt6M0RPYTkwUkVXWmFDZUlvUkY1TU9mbFRlM01DZmRLYmp3VWZ4L203WllaTkxXdFlaQUJxQUZJQXY4WkFRb3kzTzJPcCtna2hnYnBKc3lWVUdKSE9zcWh3YVlNSWhxU0ExWVlxVHl1cncyU2NxRmNxdGFUR29YcXowWlFyUzRlQ3E5ZXZRWnQ4djNKLzV2UTkwZWxUcHhPdUFvTCtZS0I3dlg3WjZlenF0YlgxMGpubmhCQ0dpRFV6RERQcjZybU10YzRDY1A1QVlNc0FnMEhXT2RiYTR0ck5MdWRGaVZhekFRTFFHd3luZCtMVTNuUWUvV0RiYmJKWU4vYnk0NTU0SGNBRkFQK01IYyt5czJlcWlKd2dxTldlVzZUVGIzbFhZclQrMkF2Zi9LelZaV3FrQ2x5ZXBuOWk4dklTTTk4VjZNd2NMaTB0aFIvN3lFZVc3enQ5K3V6aVFuTHNxOS84N0xWWExyOThiWlR2Y1NobTFYLzdELzdQNzMzYjI5NzVZY2d3SkVHeVB4amN2SG5qNXMzcmw4NXZQZi9NMDY4OCtld0xyMXk3dWRidjlQb215N0l4eUhVVlJXZ0FocGx0OVp5T0NHNDRLbHlhbGl5bElDa2xTeUwwUnlNc0w4NWljN3N6dlJ1bjl0MHJoUDBWUC9lWTRMcmZXNis4OExpS1hnUFFxUExpWDRIRVQ4TWhSdVZtZ3lqQ3lwRjd6ZExSazNUajJvdHViK3VHSlNnaWdhOEtvWDVkcDhYVFZ1dTg4cTZvdkx6NnlJYytOUHRUUC9FVDcvblFoejc4Q1VHOWh5L2UvTGQxUkozKyt2YU5GMGY1c0RnNjg3SG84WWQvNFo3NTVTUExxUHJwK1NqRnp2VkxMaEVhVVNnN1gvaksxNy82N1BtWFh5cks4dXJ6TDc3ODhoOTkvcXQ3dzFGYTNBM3c0NE9MaUN3QXg4eU9pRGlKSXhoamVINnVEV3NNdG5aNzB6dHlhbSthWXR3ZFZoSGdnRHNyNWp6eHVRQlFBSmdsUVc4aFFjMEs2SERPY3IrejA5MjhjYWxNKy8yNkk2dElzaEpLblZCUjlGYWhaR1pMdlFIdjJaTWdESkwvN3IvOTd4NzY1Vi82cFovNW9VLzg0TThrY1hqbTJSZi9mYmlaZjQ1a3M1czBGdmpJQS9kKzVNU2pEL3pjMFpuR2tRWmJBeUtCL2w0SGF4ZGZRbUJITk5OcVVXY3dxQS82TzJlY3k5OHgxNjQva1VUQmFSSkFzMUhYL2NISWFHUEcybm1UOU53N2NuNGlJbU1zQkJHVWtxU1VoSEloY2pNZHNaM2Ftd3pvTlVXUWdxZ2V5Q3BKdndQb2s0VTdDV0FYREFiak9CanRNV2hJQ0tFQ1pRSEViQjFVSkRVYlRxMnpDeUIzbUExZmcrTitFQVRKMy90N3YzcnVILzZEZi9pclorKzc3NE9DVWJ0NTlUeGZXdnM5Y3FvZ2lnUTNrOU44WnVGdm9SMmZCc01TRVZQYUg5RE96YXZVam9rYWpUcDk5WnZmb04vNjQ5L2dQL24yNy9EVmpmUHl3dFdYNmp1ZGpYdGF6ZVJkelZwOG9oYlhvbmF6WVl1aTRLSTA0OUJkWVpKNGMwQ2tveXdOQ3lHSW5NQURaMnQ0MzRQemVPSHFkTTNVMU40a1FKZlZDS29VQk9NWVRIZk41OGM1ZlFuZ1dRQURBSFVRdWlCY0lNSzhpcUlaRUxFdERWbk5HMDdicCtHNGJvMXBPMk12QUZqL3BWLzY1ZnYvbTMvMGovN20wYU5IMzhKbEtZYWRMbDY1OUVYUmM5OG1FaFp4M0tLekt6OUpxNjEzRWJNbWtrUlptbUxuNW1YVWxRTUQrTkkzdm9EUFBmVmJTSTV0MDhNZldLRDd6czNnbm5OTkhEb2RJV3JveUxqeVpCUUdqNFJDbkkwQ2NTeVVRakFoTDBwamNEc3RHWGNGL0IvSW5pR290V0VaQ2xwZERuRjhQc0dMVndab3hBcTVuczdXVCswTkRuVERnSEZBWVJuajJSTytUWEI1cllHWUN4WGdud1B3UlFDeHMvYXNNMllFeGdzUUdGQklmT1RrMmZieDArZm1hODJaZmhKRjJYLzF5Ny80a2FMTTNuWHIxbzF3Zm5hT1JudGI5UExtN3lGWDI3QXNjWHptWFRpejhFa3dNNFFrbE5aaWQvMEdFaXJSNiszaGM5LytBMXdhZkE3M1B3NmNQbGRIYXhabzFKanFpYUQyaktMVm96R09uNDY1dGNCUlhKZEhHbzN3TFVyS2N3SGtJU21GTWRZTmphL0dxd21nVHpMenlMQUZHTmplSzZnNzBHakdBUWE1UVMyU2VPTGVXVHg2ckluekc2UHBYVHUxTjE2Ty9tZTBTUW90QWVnQzJBR1FnYUNKNk1NZ0tnQitBUUp6QkhySDdNSnE4NTZ6ajRyWmhkV1Z2T2pjdTdPOWR2by8vdlp2TkQvNzJUK2tRYWVEUXZlUU4xNEU0aHd4cmVMKzlzY3drNnpBT1FQSUFMdWI2K0JSQjkzT0RqNy96TzlqMFBnMjdudUh4TUtzZ29LRklvZUFHU0ozWU0wSUE0ZDJrMm4xY0l3anAycFlQbEpEZXk2YVZZb2VZa1AzTld1MXhZWDVtYkkzeUxyV09wcDQ3Vy96NlJrMEdCbHNkZ3M0Qm8wS0EyWlFxQVJPTGRYd2d3OHRvSk5abkY1cTRNck9sSEF6dFRjdjBNZlg1S0JKalloK0VJcmFBSy9BWWdFVzRhQzNSenZyTjhwUnZ5TjNkMjZ1dkhUcHBkcHVaNWZXMXpmdzlXOS9FeTlmZVJtOVlRK3pDdzJjbm44YlZxSUhFUVFSZ2xvRGc4RUFnNTJiNk81dDRXc1gvd1J1OFVYYzk3QkF1eVpBMmdIV3kxVkhBU09NR1RJQy9Qd053enFtUURscXRDUVdEaVU0ZExKR1M2dnh2Q0Q1b00xeDMweXJGV2pMRzJtVzY4cTcwNEZDblFCRE1IdGhIU2tJRE5EZVNPTnpyM1JvcFJYamYvaXBCL0Jybjc4K3ZYdW45cVlBT2syRThIZTd4cUF2L2VkOEFvd0ZPSVFnZ0oxRE5oeHdkMmVqdEdVaEhMT3dBbWkzWmhDSkdCY3VYc1d0cXdNa1lnSHZmK3ZISVYwZFNiTUJKc0xXNW5YY3VuRVpMNng5RmVHUjh6aDluME10Sk1BeFNCQVVNY0xRUWNwcUx4UlZzL1BDYjV4d1JDREJGSVNPMnZNU1IrK05lZmxvTEZWTUsyWEtaMDNPN2JKMDEwcGpOQmhCSlpjM3p1SEZoSmNYREpCelRMbXhLSTFEcGgzKzhaOWNvU2k4TFpFOTNVNHp0VGVMUjU4c3pBRjNqS09pQVBBeUhEYkFXQUN3Q2tDRGNBc2doS0ZxdG1iYVF1ZVd5bUdCdHozOENQN1JyL3pYMkI2czQ5cTFkVWdYNDdIN0g4WHk0aktTZWhQOTNoQlhMcDdIeGJXdklUNXlIaWRPR3lnaWFFTndMQ0FFUTBqQVdjSm9KR0NaSUNRZ2hYOVNRd0lrQ1VJQnJBQXBIS0xBMGV5aXdySFRNYyt1aEhVUW5Rb1F6MjF0WlJlME5UbjhUdmxJQ2xMVkppckp0MEcvSDlZN0FNUENFQWd3bGlFRlVTUUZsbG9SK3RPMTBWTjdrNFR1QndFL2VaVUFyZ0o0cGNyZm53UHduNkpZWG9uaWNCVlN6anJ0Y09iRXZmaXBILzVSbkRwMUFzOWNmaDQ3WFEwV05VUlJnTldsVlFnSzBVc3ZZS2Y4R3NUQ3k1Zy9ibUJJUWR0cVpCYUFBNkUwaER3bldQaU5NZ0lFRVRBWUJDRVpTckJmR0ZrSjJZcHF1MVNRQ0ZwY1VueGlOUTZPTDllT0h6bFVuK3NOczdWaVlJVzJYRGdHS21tc1VCQUZvQU5nbnlqZUNVRmdaZ3FrUUQxUzZHWDZqaGRNQ0FraEZkaDlyNnYyZHhzUnFFd0Y4S2ZrdEpNd0JmcDN2b05leTh1UHIxMEE1NGx3QWNER3ZXZm4rTmk5OHc5M2Q0Ykwyamo4NmkvOElqNzUwWS9qMTM3OW4rT3puLzB5VkZ5SDRRRG5YN21JemM0cldENjFDeXgrQTY1eEZXR2JRWUdzWW1lL3RsVTdRbTVFdFRZS1VDRkFrc0NHOW9HdHdJaVVReUlkQW1JNEVMUVRFQkpBd2NDM05UV3VXTXlOb0k0bHdmRlBubHQ4NUFmdlczem94SHl5VW85Vlk2RVpSQURjSUxlR0dRRVJCVVIzdE9XcWFUbi9VVnRHUHpQN2VuemoxNHBJRUJHOUZ0RHBPMXgvWGtRZnVPaTFmNGFRQUpqZzNGL0c4MC90VFFwMGZJY2JZYkxmYmxHTnZyempneWNlUG5uLzRudHZYUjgwTzZNVU56ZHU0T1ZMbC9EVmIzd1Q2eHRieUhNRFJVTTg4czRBSC9sMGhOYVJYWXl5RlBtUUFDTWdBNDhxYXdEbnAxRjk2QzRBSVJpM043WXoyQkVDVlIwS0VKQUNrT1IvSlFlQzB3UjZVc005WjFCMkhISG15STJnT01OQ0xPV3hCMVliRDcvbjFPemo3enN6LzhRVDk4Njk2OTZsK215aDNhQ1Q2c0k0bG9Jb3dKMUxMTzhZdnlVaVVZRnNQSHNQZm0xQWllOXcwVjBpaUlOZis4OTkvOTB2NXdqTy9YbWUrenY5M25TWDMzRjZXTHlHcVRmWTc4c1RCVG8zOFRXTHlURlVyemdqbUZXTmhFcmFjekZ2YmdsY3ZIaVZybDY5Q1Z0YTFGc3hIbmhzRnAvKzY4czQrOVltQklWSU80Q3pRQ0FZTmdTeTNJK1ZFZ0NsZkVoTyswOURJR0k0Sm5BRnNWSVRYUFd2aGdua0dKQUVLUmo4aWtIK2dnYVgvall0TlZCYVJqKzFZR1paQzJValVtZ21vVGk4MGt6czNPbjQ3VS9jTS92SnIxL3AvTUh2UHJ2MTJZdGI2V1poYkFCR3dUNVZLZUcxN1Awd2tKZkljUWNLbFF3aW5sZ2VUeUFTdUQyQ08xbnd2SDFnK2pGY3JuNG0zNWJjdmcxRXZ2Tm52Q3JDcWpiY0hnd254bE9GMytsNzNjVDMrKzk1TFFEZitUY2ZUUEcrVS9vMzllaHZGTTlPUlBENzF1NTQvMFVWNWdZQTFNcVIyYmUwNWh1UEhUODFGeDg3UG9QNVpJRTZ2U0htVmtKODZxZE80R2QvK1NoT25tMUFPNGwwQUxEMWFhU01BQ2NJMXZwQ1d5RDlQY2lXNEhKQ3Rnc1VROEJhQVZZRVp3bVd5Wk4rMkg4OUx3VnlMVkE0QWJybVlMNmw0WVlPSUliV1FEOXp5RFVqa0FLaElncVZvRUQ2WThVQzVKaGpDYkYwWnFueDJEdnVhWit0UlRMYjZKZmJvOUpLZ01ZOCtyRW81dVRuNG9EbkgrZjVrNDhKRG54L2NPQ3hrMTVUSHJpQ3UveU1nNy9QM1g2SGc4OGZmSWZ2Ty9pY2QvdGI1WDhtb2hBSERnZnhuNGtLcHg3OTlWcWNjOHdraU56RWNwZEpvVWdRUVpXNUZrcUZXRDA2Z3dkT0xPQTlIenFLNXZFQjdqdmJSQmhaOVBzTWt4SmdmRFhkZ21DMWZ3SVZNRUk0QkVRdzFqcyt4NFF5RXlBQmtHSzRnYTh0c1NCZklQTlpLSWk5TjFlN0R2cnBFclpuWWRtWHpvZUZRMVk0S0VrSUE0S1NoRWdSQWprZTZHTlNrbEJvcGtIaDRsWVl2dU9uSGoxODl2aDg3VGQvNTluTi8vanRxNzB0eS90VGN2dlRjUlBYNUpvcWQ1ZlExb1BFai9TTlBUMFRNL09CTGJVSFBPRTRUWkFIUFBQaysrSU9mTytydm44aTlSQlZPTUhmNFh0ZkM3aDNlL3hyRFViOVdiMytGT2l2TzZRem85MXFzSE5NZytGb1VwNlpxcXEwWU1OQm5tb0IrUEI1NWZRZWpoeUtBZGxFZitBZ2g0QkpCVkF5bFBPdmhxd0RKQUYyL280d2t1QUhYY2Q1T2hEUE1BUVl4aEpNNFJWcWJWWDBwaEJnNTcwOHdLaS9YS0pjTjNEc1pYVFN3aUV2SEpRaXhFRlZ5V2RBU0VJWStpM3hESUlTZ0ZKRVVRaU1Na2UyNVBiYmpzMzkzSEl6T2pYZjJQcU5yOTQwbTRYalBCRG9LUlVhWjEzaDJOb3l6M1NlanZRRTZBOENoa0Frd1V5VjhDVVJDYkJ6RGtJQWJuOUxMZVBWak1SSjlSMVpSVkFRUXBLMWxvVVU3S3liUEZ3bUFVWUhvZ1JCSklqM1JYdjV0WUF1N2xMT1AxaUV0WGNCdkQzd2RZdFhheUJNZ2Y1R3NEd3Y0WndiNjYxUG52d1NoTUNVTEVrTHRGb0N4ODdFbUYwSVlLeUQ3MXdETGdWc3lmc3lORUdOOWd0c3pqS2NCa3dod0RtREZDQVZFQ2dHU1VhdUJVcnR1Zm5PQ1lpS1RGTU9QWCtmQkNGZUwyR3ZGYkRhd1RKaFZEaFk1OUNJSlVqNFNLQXdEbEVnWUFDVWpsR1BKY0tLTCtkMTZJaVNSTUJveDZQY0JmZk0xOS83ODA4Y3ZhZDlSZXc5c3l0TEI1SEZZVVRHbU1KYTQvSnNkR256NXBVL3lQcTlLM2VDZ2doZzI1cGZQREc3ZFBneEVEV0llU2lrWkFnSzRGd21oSWhMWXpxRDNhMm5PNXRyVzdpVHNDUUFjQmdHeVVQbkhqdlhiTFhudEdQRjFnaG14Q0RLd3pCc2dOMWc3ZWExNXk1ZU9ILzlib1hVeFNNbjc1dGRYRG5ybkpWaFdJc0FTT3RNQ0hCcWk3eTdjK3ZhTjdxZG5lMkp0TkpCVUswMXYzZ3FDR01FVWtIcnNxL0wzRmxyczFHdnV3dm1jZ0xRNHdqbjRPZUVPeVhCNmZzSjdHOW9vQmRsQ1VFRUlZaXNkVlZJU0FwZ0ZZZFIrTEYzLzBCeThyNmFTSk9YWVlJU3hoRUNZaEFUaGxzV3poS0NBTEN1dW9zVlVHYUFaVUpVWllCR0U4Q0FzSUN0UHFjU1NITkNhWHlZTG9nZ2xUOHdMQUFyQ2VIQVFGMHZZRExyOWJLY0x5YzBFK1Yzd0R0ZlpoS0NvQlJCa0lCeFFHa0pUTUxYNmdYQnVxb2FwUVExNmdMV3NqZ1VoOGQrK1JFNjlyczNZbnh0S3phRFVWN0d0VHFFa2dpUzJvY2M4N2s5Y2ZPZkRydTdMOS8yWW96RzdOeWhJL2VjL2NXNTVjTWZENUlhbVR3VHpsb2Z4QU9XSFJPcHdKbGpwLzcwMmt0UC9kUDFhNWN1VFlJaFVESis5TEYzZnZpUnQ3LzNsNlZVcTFsZXNOWUZITE5TS25DQkNrVTlTZmpreVRPZlorZis2YVZMcjF5WTlNWUxoNC9mOStEYjN2K3I3ZG1GeDlKaEQwR1VTQ0dsY003Q09lTk1uZzdESVBobncwSDNONHd4WGdDVUlOdUxTNTlvemk3OFRSWEdjM0VRb1NqU1VaNk5qTEhtaHJIMm54V0QvcE1BaEpRSUdzMTZXd2c1R1BSSHU4Ylk5RUR1RHR5V0wvdStBcnQ2by84QkRBaDIrL3B3NDBLUC9KdWYvdUY3Zi96alAvYVdOVHdadjd6OUhKc0NwQVRES3FCSUdVWEtFSUxoYkFWVUFzeUlZUjFWcFM1Q0NiL1N5WTJqeDhJVDBhMEJ5b3hCb1FCSlQxdVR4cE5sSUFnb0dlRjZDUnBvWkpyaGVMemlIWENPL2Y4THI1NmhwSUJqUUR1SFFDbDBVa0luTmJCR0l3bUY3ODhMSUM4ZDRzQ3pjTFZsbmsrQUh6eGtPQmpkNnYvcnA2KzlzRFp3M2JpV0hKNWRYRDI5ZFBpZTk3Wm01cFBlenVadjZUSmZGeklRMW1pYVd6bjBZKzM1cFkvdWJOOHN5TkY2UGhwa1JoY2xnRUFJYWZKMEpGYVBuMWs4Y3UvOUgxVkNOSUl3L3ZWME5Od2hvc0E1NHhibUY4NmVldUNSWDliT0xyN3d3cE8zQnQxK2J0bGFLYVZrWmg0TitzSHhrMmRtSDM3a25SOTgvSDAvRU1sYTZ6ZlRMTzBwRlVvaGxXb3ZMdjk4YzNiaGJkY3Z2ZERmV2J0K1ZRVmh4b1MyTXpvUVNpYXp5NGRYR3ZPTFAzYnM5QU85WVgvd2luT0dzMkowdXIydzlQT21LQmVINmU1MkxxVWljR0NjYlVDcDFYcHJabFFNK2h0QklGeXJIWCs0VmsrZUlKS0RwSkU4cFV2MzlYNjNmNlhJaXoyOG1rNzlmYldCOHcwTmRQSXhPMVhhY0pJSUFUT0wrKzQ1TnZjVG4vekV4eFpuNSs1LzZWb2ZWanRTN0ZjeUd3dm92b0V6M21NNkFFNHdXQktjRkRDV0lDekJsTlV4VXZvWWdVUlZBM0MrM2NhaWNoRUd0NHR3emxQaGFsc2E0bWFPNGNpaXRJd2s4S0U2dzJjR3F1TEVzd1dDZ0x3MFBRdDBNb0hOYm9Fc0w5Qk9CT0NBclBSUloxbzRCRktnTkE1eElHaXJDelJqUVk4ZWFpUUxIejdKLytJcmExZGYza2tQZDNiV29xVGU0RVp6L20wejgwdjNGdmx3RU1SMU1tWGhHczJaNWU3dWhycDI2WHltODJ6ZGpFYS9BK0JXZFVqV0lmR09YbS9yN2NZVmk3TkxoeDlmUEhyeVVOcnY3Y2tnSk9lTWFEU2E4emMyTjFkdVhINHgzMWkvY1RYcjlmNkVIVjhiVjlCRktONDlLSVlmYkM0ZmJUZWFjNCt2SEQ5enZOL3ZaRW9wbjVOTGVmUzViMzJPT2pzYjJXQjMrMnV1TEw4Q1FLbGEvWFJqZHVZSG9scHRmblorNWNUTTh1RmZpbXFEUFdOS3VOMzFacGFPVm9hZHZkMnMxL3RkSXFUTjJibEhaUmllVUpLT3kwQ2VUUnF0dDlVaU94c0U0bS9wVXM5Q1dGdHJ0dDdYYUVTMzRQaGY3bW45RzlZUEJQQmRjdmxwZSszMWF1OTV4eU80Zm11amFxZVJWM1lGSWhCaUlpVC85ZC82eVErODc1M3YvcW1vMW1wZjJYNmFoL2s2a1JNd0xHQlNCejB3WGwrU3E2WHE4SzJ4VWdob0poU3BRNTQ3T0FoZmhYZEFXVEoweVREV2QzVlppUDBLKzM0bUxBQmxISktiR2R4V2dWeFBiSThRRlZWV2VSYWRyeHN5Z2tBQ01zUkcxMkM5azRKTmlhV0dRcUFJbS8wUzNhRUh1aEMrQkJFcVB3RmpyQzhHOWpNWDFNSmd0VjBMVGw3ZUhLenVkWWMxclhNTStudVVwNlBFc1dzN2E5cldsRE85dlczWjJWN0hzTnVKcFpTUmtPSUxiTjBWRUtVa1JVeUNQdW1jZmRRWUkvTjBRTVJ1bHBsWGd6QmNsVXF0RFB2ZDFzYXRhN2g1N1ZJZ0JWYkRJTDZzeS9LYlJEUVFnUXhVcEQ1aXRIbDRsS2EwdTdzbGpDN2I3Tnc4Q1RHYnA0T1ozWTJidEx0NWszU1J0MGlJeUdyOUZTSFZXanpUdm9lQVQrbzByZVhweUZscjJ0b1V5ODZhNVhUWW54bDA5NlMxVG9LaHBWTFBSL1g2QjZTVXg3VXVoV1VUTm1mbkQ4ZHg4SlpzbEs5Mk9zTlhzclQ0azNxOUZyWWFyYk5sWHE0TkI0T3ZNYitxU3UrK240cHliMGlnbnp4NkJJMWFRanQ3M1hIK0ZSQlJ6SXpnL1k4L2N1S0hQL3FobnoxejZyNkhOUXUrdlAwczdRNDNZSXlBWVlCVEExZFlFQUc2Wk9pcXVxNXpoeUozS0F5UTU4NVBoQkhCV1VDWERsbzdzUE4zaTJiQU9NOTVaZEErSDRVRUllZ1ppQ3NqbU54QkJnU3FRQ29GUVFoVW4vczJYaFFyR0ZaWTJ5dXgyOHNRUzhaY0VrQkt3dlhkSElQTVliNFpvUmtyQkpJUUtJSWlnbFFDOVVpaVhWT29SUW9FeU9WbTFHeEhLdXFKR3VUc0liS201R3pRNjFwalIzazZMSW84eTBpcU9FcHFsQS83UTEza0w0SG9hYloyQUNBQ3M0UGorVEJLanMwdXJDWmdqYlRmS2ZJMHpjc2lINlNEcnJZNmo0NmN1SSt5WWI4WTdHeGZkZXl1T0dldkFsRHNXTnJTcmtvWkhsczZmQ3hoVjZDN3R6V3l4ZzdBM00vVElaSjZQV28wV3J4OTg5b09zN3ZBMXI3STdFaVBSbUV4SEM2cE1KeFhpb0swMzlGRm5qbGRsaUJCWkV1Tk1oMUtBT1NzZWFiTTg1ck84MVhyVEdUS01pQkJTeVRrRElVeEtJalduVFV2UmdHV1NhZ1ZKNE5TUm5GZjUvbUdjMDdqMWUzRGFlaitlcldON1Yza1JURlp6WlhqOFAzc3FYdVhHdlhHaWFJMEtCMHhYRWpHQ2pBekZQbkNtM0dBU1MyMEFTRDl2NVdsZ3hFRUYvbzhPNGdFVURBRUhBVDdvcGtUL3Z1ZFl4QXNtQVhDeUxlam5RQ2tjNkN0QW1aZ0lJU1h5Q0lKaEVyNEpRNlYrM2NNQ0NXeE5YRFk2WTFRRmdWbWFncEpJQ0drd0Y2cTBSMXAxRU1GYlJ4R2ppRUYwS29yeEZJZ0RBUmt0WGpTTVNOU0VvRWlmT0QrQlJ3K1RQak1MZGJQZE8yelpaWi9vOHlLakFEQmpFSUc0UWVYajU1NGJHN3BrQVdMT0lpaVQ1bXlTSU1nVkdXZVpWcVhTMUZjSytKNmdyMzFLN2Q2MjV1Zk13WnJSSlFibzFWcnB2MUFHRWMvOU5qN2Y0aDJOMjV4R0NYM1NTbm1neUFNaDZOZXFjdHlvZG1lejZNa3hvMExUNjEzdDlaL24wUjRTd3BSTW5obTZkakpUejN3OWcrZVhqcDh5a0pRUzZuZ1IwRWlNcnJVZzg0V3lpS2xZV2VqazQrR24yR1N0MGpJVnRKdWZYejUrTW5WblZzMzlweXpGMVVRTGhYRmNOdXdUVUV1TVlOaTA1WkZXTmFUeGJEWlJtdCs3bjVUUzQ1bXc5MDQ3M1ZFZS83UVl6RlRrRWFEWjQzV0kxOXB1WU5ZTXkzR3ZWNXR0OU9ETWZ0am1ZS0l4cXVSZ3NYNSthVWdpRnFqTEljTUZEa0grSFVwM3ZNNkthQ2xRTlkzTU1aNUtTdkRNRXFBbElCd0Zpb1FmcTQ4QUVKeGV3ck5zZSt2a3lBb0NTaEpDQVFnaUVHU29ESUgxU2tCWmdncEpncUdYaW9yTHkwQ0lwQWtERWNhRzkwY29XRE1OUUtFeXMrWEY5Wml1MTlBa2YrOG4ya3dnUGxHQ0hZTVI0eEMrL0tnYzd5ZkFoU2x6LzFQTndTUzFSTE5BVy8reVZieGRGcmFidVhCMHQxYjF5NkZVYVNPblhyb2tWcTkvZGhvMUNNSUFTRWtZcWtRRTRIQXRyZXpmbkh6NXJWLzFkL3JmUjVlb3c4QWtBMzdYMURSMDhPSDN2N0JuMXc5ZnU5WmdNNnFJSUFnZ1RaV3djeHNkSWxyRjUvYnZIYjV3ci9LdXIzZkJ6RFd2aUpyN1pYVm8yZit3YUZqWjg3MGV6c3JSVDZDY3hZRWg2VFJSRGJzcnU5dGJQeEdPa3IvRUVBUEFFa2xNYiswK2pjV2p4NlBBWHJRbU9KY25zVTA2dmVhZVgvME1oeCtUd1hxWEJBRVA1ajMrakJaRnJSbjVtWWdRd2daTTBFS1kyM0xPdHNDc0lZREs3YW5IdjMxWFlVYkg4TjNjTGFGRU1IYzNNSnlvekhUS2pVamtvelNXSlRhSVJBQzJqcmtJNHZDT09RR0tES0hWRHRZQURKZ0tPc2duUUlKQnJUMzVsYjZFTjB3SUtVSGVLQTh5RU1KejM4Zno3YnNhYUNuNFFUdDUrVVk1L2pHVi9pTkJHN3Vac2h5aC9sR2dEZ2dDQ0t3WTBBUmRnY0Zpc0lpRGlTMGNURE1xRWNLcFhiWTdsak0xSlNQRUNSRFFQaVVZT0psMEtYRFlxTFVEejI0L1BoaUxSajkreWR2L1VFbkxUdEVGRGpyTG01ZXZmUlBiS2svRk1XMU9NOUc1TUJ3MWphQ0lCeXhZd1YyblR3YmZxRy8xM3NTUUg0QURMZldybHo0bndoaUxRaWorNElvNmFzZ2lLd3hjVkp2Wk5ab1RrZjlkSGRyN2FXczIvc3FnRzcxS2hBUmVMQzcvWVVYdnY2NWNuNzV5QlBaYUJBYlU0NnMxU0hBaGtpNFViOXpPUjJsZitvUEJ3b0JMa2ZkN205djM3emVac0xEQkpMRzZubFRGcUZKeTh1dU5MOEo0RHdJUjEwMVpwZ09lN0JsaXZiTUlnNmRPRWVEM2c0WG5ZM0ZzRkg3Q2F2Ti8yaDFtZUhWaXJ3OEJmcnJ0NjFXclRTK1RaWVJSRUtJSUpZcVZNWVljRkVRckFCcndNRENsSXpSMEdDWVdaU3BRWjViYU92OHlLa1Y0RUNBRFFOV2dtTUpPQUdyZkF0TlNTQUVRekxnSElFajRlVmJtYUJCNE14QnJ1Y29VZ01aU2tpdkZlRnBLbjZSTTFRb3NOa3IwT21YbUsySFNFSUpNTU5haGxRQy9iVEV6cUJFcFB6YllweERHRWlFaWxEa0ZvRVVubTVMUUJKRUNFT0ZTRG1FU2tLQW9DVERXSXRjZ3lMdDV0OTlhdjRINGtCR3YvUE0ybis4dnBldUE1Qkc2eGMzcmwyNnNFOUc4VmRRaGJSVWZleE50Si91WU5heGM2T2JsMTc2NXdCYUZjOW96SzhmcytuSzZvQ284bUFldjFVRWdMYlhybjEyZSszYTErR1hkT2pxZXlmSkxkWFlEMmNBU0pmRnk3dnJOLzh4U1RrUGhpS2lCanRPbkxNNWdEMEEwcFRtYWdLNTJWeVlYODZ6RWJKUkgzT0x4OUZzTFdMdDJublNXVlpYS3ZxRVVPcHoxdWdiWUJaM0lmUHdGT2h2b0hZYlEwaHJtUnhySktvT2dvVFZqTHl3R0E0Tk9yczUwbUVKVzFvWTY5bHNVZ29ZSlJERUVrWVFWR0VSY0FEckpBSm1oTFFQVzFEZ1I5VWMrYUpjV1FKT0VzS2VCdTBXSVBLODlUQVEreTAxWC9VVVdPdms2STQwRmhvUjZySEVtT1d0QktHMERwdjlFbEpLUktGRVZ2alVKSkFDUldHOXdBVUJtWFZZcU5ldzFFNGdTVU5LZjlZSnZ3UUdnZ2hSeGdnSVNKUnFmdWpzL0VjUHowV3RmL3VOVy8vaW1SdmQ2NEpJT09ZKzd0d2tNMW1ndWxzYmFoSVFxZ0p5RDNmOGhYY2NDdndheGE1cXpvL0hSSmE3ZlM4bURoWXZwK1Y0eE03Y21PQko3Ry94a1VxMUdzMTJzMUdmdFVLR0tOTTlzQ1UwWmhhNHM3TkduYzBOcDRzY1JKbDJ6dVVUazN6ZlY2YmU0TWkrNHlZeDF0cFM4ekFyeWdMTXRYb05URGFnWWM5aGQydUFqVnM5OUhaSFlHTmhuUU9rZ0ZJU0tnd1FSQ0hDV29BNENSRWtDaXF6aUNwL1JDQ2ZyQ3N2VVMwY1F4cUJnUDFNckRRT2RpT0hIV2hFaWZJNjlkYUJIRUVxUWhoSWJQUkcyT2prV0cwbnFNY1N4QlZiRGdUSGpNNm9SSzRkWnBMUWgreVdVWThWWERXSUtnWEJNS01WQllnVWdWMEdGcjZuSnlXcW4wTmdRWkFoSTNDZXdodUFvck1yalhmOTNMdU95WDhsNko4OGRiMXpzNUtxQXU2a2lONk5GMzVYcnZ2dGk4VUJqM2ozVWRuYmo2a1lDSGZNMDJNaXV1QURqeC96NHRXQmc4WlRHYVIwYzh2TGIybTAyNTkyakNWbkxhS29obUtVNHFWdmZoRXlVVkMxcUdPMC9sMVRsaThBZUtuNmVma1U2RzhjN3ozaEM4YmhJZXVkenQ2dHdYRFliZGJydFRUUDBBd1hzWFU5d3d2UFhrVGFTK0dzMTZWZ0JsZ0tDQ2tobElJS0FxZ2tSdEtxb2RHdW85YW9acXJnSmFOQ0FoUUxpSUFoSVJDQVlRMGpsQUxPR0VTZEVwRVNFRUtnMEg0WkJZT1JDSW05WVlFYjJ4bmFTWWd3RUw2SUJrQ1NyL2pucFVWbldFSUppVkpiWktYUDBaVVFNTVlpa2dUTmpObEdqRVlza1JZbFFpWFJpTVUrVFJhT0lTVkJrb0FSQkJFUUZCaHA0UVJJQktlV0c0OS8rdEZEblVMYlgzdHh2WitURDZmSGsyN2pTVGlMVncrV1RIcllnNU5razdudVFXK08xNGdJN3BoSHI0YVI3alpaTmo1UUpvRi9SenU0c2JoOHRMRzQvQ21ZWWpVZERpRmxpTGhXeDdEYjVYNW5wNHgwSXVkWGo3UURGU2Y5bmUydldhM1R1MFF1UE0zUlg2L05meUhneHZyS3ZoanVpTWd5YzdtNXZiMDdTdk5SdXptRHkxZGZ4czFibDdBVXJlQThYMFpwQmxEQzMwUE16cmZWaWhKY0ZJQVFVRmtHclRYWU9vQWFFRlVoemxXM3ByVkF5RjZMV1J1Q2t3U1dGbEZxRU9VV1FTQmdxL3ZHT1NCUUF0cGFYTmtZb1JZcXRPc0JKRldIVkpXM08yYjBNbzFDTzlRamlWRnBFQ3FKSUpSZzV4QUtyeTdiU2dMTU53TlliVDJMVHhBS0JxVHo1SmxScHJHNWwrTldKOE5hSjBXYWF6anJsVy9BSk80N1BoT2NQdEw2Nkk4K2NpZ3RqUHNubDdkSEJjREVkM3AxTTVGcjR5NGU5bFVGME5jb24zd25BSWs3VXExeDIrRFZzK01IbjA4U2tRUVFNS0RBSEJUcFVCUjVLcE5RRVFuaUxCMGk2L1dnczN3Z3BQeFNzejE3ZnhDRUowYzBPZzRoM01SaFp1OXlDTDJwN1ExSm1HazJHdWdQQnJCZUtrbFVONEVDUUhNejdmclJ3NGZlbWFXOUkxLzg0aC9nYTEvOURDVks0Y0g3ejZGV1M3RFhHU0l2UzBoRkU5VjcvMTluTFd4Wndtb0w0c3JiU3drV3REOW1DaUk0QjFqTGZ1YmNNS0xkQW8xdUFTSDk0OFpCaHBRQ3QvWXlERVlHYy9VSW9SVDdmSGV2VmVPN0F1dmRGRXI2ZEZjSVFpTU9NT2IwU2lIUXJJZFlhSWNJQllNRW9LMVhuUTJVUkZvNlBIVnBENTkvWlJ1WGJJbDBKUVl2MXlGV205RHRFS05Jb09NY1hyelJwV2RmMmFVanJlamUxZG1hdkxxWFBqVXFiVG5oemZmRGR5R0k0MXJBUk9SVGh6czJ4WUVod0g3M085Mk5iZmJxT1hTNiswRWdwSFJDU2xmcDJoMmNQUitIN09QTnVxRVFJcFJLQmN3Y2d6bXMxNXFOZXJQNWlEYm04S2cvNUh6UUk2czFSS0JlbkZ0ZUhyVm5GMDZYWmFtSDNlNC9LZFAwT1FEWlJHM0NZa3FZZWYxYlVaYVlrQ3NhNzFWWEY2NWUzWHIyK2FlZUgvVTIzbmJqNmlzeUNBSjM3ZW9sMnQ3ZW91WFZJM2o4clcvRHRmV2IyTzF1WXpBY3dLOHdyNGdzenNFNUI5c2Z3R29EclRXMGFhTnU2NGdTaGdzRjJES1VKRWdCV09IcHJQRk9oakszRUVxQTJmZlZRMG5valRSMit5VWFjUUNsdktDa2RleHpjK0VwZVR2OUhIbHAwVW9VakhWb1JnR1NvQ0xET0tCZUQ3RTRHMEZVQld3bEJHU1ZZYS92WnZqYXhSMk1Wa01jLzVFVFdMbDNCdldhZ2kwWVpxeDRRd1JUYVBSMk1seDlZVTk5L29zMzVMSVZQMzY4RlQrOU95dy93OHhoSlUxRjQ3SkhFRW9FU25CWmZLZTVqeXI0L3d0WWtOUmh5Z0lnT3c2enh0NThzdWdXRVZFWTEycXRXclA1R0lSNHFDeXlQVjNvOHExUGZPemgrZVhEajMzOXM3K05ZdEFYVWFKQXJkaVJESThsamVhOVpaRUgvZDJkZjVVUEIxOEVjMzZYRklVeHBjQytmbTA0R2sxR2Y1TmVRQTJHZy9MV3pjdDVubmFQTnByeGJLTVdoMUVVa25XV2U3MGR4TkxSWXJ1Tlk0ZVBJWWxqcE5rSWpzY1RaY1RFUk93WXV0VElSaW55WVE1VFdqampKZFNJL1RDS2N3eGpIR3hoVWV2a1NJd0RLUUVHUXdydjlhL3ZEQ0ZJWUtZUklaUUVkcmZyQzVJSXBXRmMyZW9ERUFpREFHRWdNTnNJRVZTUlJqMEpzVGdUUXdubkorU0VCNjhTd0RDeitOckZYYVN6TWM1OS9DUU8zZGVDSGxvTU4wdllhcmJWYWdlakxRU0E1bXlBb3cvTVkvN2tMRjU0Y1ZlbE82bmRMc3lYcW5MQmZtNWU2WGR3b0NRV0Z4dVltVW5RNitWM0NjNy9mUGlvTmRzSW9oZ3FqaEdHRWJRdUVUZmJZT2ZJNm5MU2l3ZVZGNDhCSkVTVXpDMnRuRzNPemY1a1VFdituZ2pVZXlIRTQ0ZU9uMzdpM0tNZk9Idno2dmxvWi9jV21xMDUxOTNhekp4aFk4c3l5dE1VbzM3L2ovUFI4SDl4MXE1VmJjUGlRS2ZoKzhia0cvbVhud0Q1SGRjb056c2FlRkhGUVJZM29rZ2tpb0k0S3B2dHBwQUJLZVlTZ2tzMGFqSG1XZzBvcWFBZHJIVTBrRklaSXFHSWZNQlE1aVZHdlNIUzNoREZxSVF6dm5kZldrWlJHSmlSeHN4SW82a0VoUEl2cHlTQjdaNXZwYlZxRmNpdEw5Q05KOTBLeTlqcVoxanZqTkJJWWlnbDBJNEQxRU9KMHZxRFoyRW1SaElCUmpzUGNnQ1NQRHZ2bTFjN0tBOGxPSDF1MlN2YVNFSXRydVl2aVJBbkFqSWdoQUt3ZlkxRU1qZzNVRUdBK1NNdHQ5UEpMMXk3TmZoNjlWSk9palV3TTdNZm9nSEZjWUJ1Ti9zTHZVOVJvNFY4MkVjWTEwRFNNLzdLSW9mTzB0Y0NlUUlnanVLNFBiZXkrcTVhcS9rUFFPS1R3MEcvM3QvWnlWMmhvM052KzFEUzYyd0hYLy9TZitRODY1TXB5dXVtTkgra2kveHBVK29MT2krL1pjcnkzN0RqaXhYQTh3TWc5M0srM3lmdE52bEcvd09JaUlRUXFPU045b1BLTERjN1c3dWpKOWM3bzZmN2hiN1l6OHNYTW1NM1NwQWVXVmVPck5GN282SEpqQW1EVUpGVTZ1S3dWLzYyTHZHeU1VNkJlVllJSVpVVUxBWEJHazFGVm1EVUgyRTBLbERtQnFOaEFSb1VPQzRsMXlOVkNTNFRqR0ZzOVhJSUVvaERDVlY1YUJLM2MvUmhZYkRlVGNFTXRCb1I2cUZFT3duOFZCb3o0a2lpSG8vbjBmM0VHdnVPSUo2NTJzR05PdkRRRHg1RDNBb0JNQ2lTQ0dOQ0hCTTBKSndBaE9TcXh6NXU4d21VUTRQV2NvTFplMmV6elZ2RFYzWTNSenRWQjJOU2xZV05jYjZGSlFqV09SanpYKzRBZ3lpdVVpU1EwWnFzMXNUV2lnTzUrQjBnYjgvTkgyc3ZMUDFvVUl2L3JpNkxCM3ZkamsyNy9ZdTJLTDdPanBjRzNaM2E5YXN2c2d3RkFTTEx1djNmdDhiOGN3QmZCdkNuSVBveXdPc1Z3SXNxTjcvamI3ek5acG9DL1hWdFFvajlOdHZ0RHMyZFdtT21zTnVEVHZiSzd2YndwYlZiM1cvZjJ1aCtQU3ZMRjNxRDlQbGhYajZYVzd0bENPdWw1ZCs5Zm1uMzl3YUQ0amxuN2FVd0FLUkFrOEFOU1JDQlVwQktBY3dvaGhueVFZcDhrQ0xLRGU2YmFaQUtCRE5BU2hKR2hVRnZXQ0FJL0tCS0tBbENlcTY5c1F4dEdhVzIyT2xuaUVLRlpoeGl0aDRpVkFMR09rUktvRlZUUGg4WlUwekFNQmE0ZUhPQTUvSVVELy93UFpoZFRnQkZpSnNTVVFpVWhpcWFHa016K2JsM0VESk5nQ0tJVUtEV0VrU2xwYVFXTGpZYlVlUFdyZUd6ZzI0K1hzMTZSKzVxak9PaU1CQlNJSzRGK000NSs0RlF2ZEVFUUhEV2I2UjB4cEF4SlRsakJEdTdyeUdBMjZxdU1ZaHFBT0s0UFR1L2N2TFV6MGtoL2s2ZWo1YVZVbkRhOW9zMC9TM0hkczg1KytpbzM0MmROWWdiRFFyQ2FLQk4rUmxYNm1lcjl6MnZDbS81QVU5K1cxM0dOL2Y0K3dYb2IyakN6TEVqUjVIbEdUYTN0a0JFanBuTkJOZ3RBRTFFSVRPUFQvRmNaNmF6ZHJWemNWeDhDa09WdE9kcXJkM3Q0Y0I1Y1FKVkZQaTJZN3JVYU1xM3h4RjlDQktQV1dmbjJGcElDQ2dRMkJnb1NTN1Q1dFphTDFNbm84WnFJQVJLNjlCTlN3UlNvQlVyaEVRdzF0ZW5IWHNpakdQR3FQRERLdlU0UkJRSWhGWFZQUW9sYXJHZlJwTlZqS0tOZzNQQXhrNktwN1o3T1BtcEUxZzhWSWN1clJlbmNJUjZ4SWdEaG1VQ0JZeUF2YUNGa0F3M3NoQWtnTkF2azdDNUk1ZVd3WDFuNTk3MzhSODZkZVBmL2EvUC9mTjBVRnJ5N2ZyYllDZXdZM2JzYXhoL1prUW9KYXZveFlmL3BzanU2TUZYQTBnSEphaGpBaG9Nc0lwcngyVWN2eHV1Yk5ScURVY1FsSXNzQnZna0FDdWtWRUVZSVdrMUlWU0FNaStJTFJ2NEFScFhmY3dQVk5qdEhjVTNxbnFnMHh6OTlXOFBQM2dPU2tycTlicXd6aDFjd0RncC9YeFFGbm5jTzNiV3Vpd2RGbnZzQlFiTEtzeXp6dklveit4RmErVnpRYUEyQkpHV1F1WU82SkdTUTZuVXpUQkp2cjQzTkwrN3Z0RzcwRTdDNHd2dHBEWElOZS8wQ21ySEFacWhncllPcGZPaWtMbDJNTVl2V052dVp5QWhNTk9JMGE2SGlLcHgyU1JVbmo3TERFRUU0MURsdEE1UDN0aEQ4T2dDemo2eENtZmRmcjI0dEFLS2dIcklLSmxRT29GUVZTa29BQWhDR0JHa0FqVDdud2tDcTFpRWpWcDB4SlhZdm5SeDc1VnFxK3NCUlZYaXNWQ2wvVE9FNzBwSkwwQm5IVGxyaWRuZExVVDNGWFdpdUNxNjFRRFVQZGlwbGpTU3Q4WngvQjdCM0M2ekFudGJtK2p2N1pDejlyb0sxTFBOdWJuanJibjV1U0NLcVV6ekl1djF2Mnp5NHJjQjNwanc1cFBodW4xVmovLzdTaHJ5RGU3UnJiVjQ5b1huZWFhUkVLQlJHT0dxTlVTMzF6UGQyWmNsM0VtL25OZ1h4dm5kZXJoWldsN08wdko2ZTdiMmhWcWlWa2hTSkpTS2plTlJkeVBkN082TXNpMmdsbHplRnZWWS9WeGg3UHplSU9mbFpreUQwcUxRWHIvZGdUSElEQUxoZGR6VFVxTmRyNkVXU3NSS3dEZ1BiTC94eGJmU2hQQVMwRW9TbnQvb0l6OWN4NE9QSDRhenZ2cnYweGV2UDVjYklDcjlQSzNXL2crSXFtV1B0UkNRRVZlcm9RQ09GWUk2azJEbVpGWXRQdmpXNVovYVhCL2RlT2JwdFc4UlVPT0pFSjdCYkF5czBZWUE4TW85czlpNDNIblZlOUdlbTRQUkJtVStnbk5NenBXVDIxd09MbDhJQWNocVk4eTRqUmFUd09yUzRXUHZqK3YxRDVzc1g4eEdJd3o3SGVRbUpSRkpIWERRYlM4c25LN1ZHN1BhV01wSHcyN1c2L3lCenZMZkFQQnlCZTdKWHJuR0pQbUh4TzEyd2ZmWnF1azN0RWUvY2VzbTVscE5SR29FRWhLRkFXS3YwTUxXT2lhaThlV0l5RlpyMEN6ZHZnem9EbTgvK2YrVGxXaGI1TG96SEJUWEIvM2lXbTh2dTlMdlpMZnlWQStyZnkvN3VibmhyTE85WVhGS1NaSE1OMkl1TFpPdDJHL0dBZHBZUDNPdURYSnRNZHRJMElvRE9QWmlHSEVnZklXKzh1WWtDSTJhd28ydElWNnlHc2MvZUF5dHVRalFESzRxOHdTZ3RGVitMdnhXR1NhdmdLUEFpSlduNXNocUZ0OVZTWTNKTElLSUtJZ0pLbEJ6c1FxYlcrdWpsL3FEZkZEUkN2YkJQbjRkRnc2M1NBWVN3MDZHajk4L2o5a2t3TWFnUUtBRW9xUUc2eHlWWlVuT3VvTTg5ZjJXR2ZrOFBKQksxZHV6c3cvRmplWlpDTXdKS1k4OS9NNFBmNm85di9RVGV6dGJKM3ZkUFQzc2RhamViTXF3VVdNVmhnanI5VVdsd25ObFhyU0huZDExbmFiL1V1ZjUvOForaTI1eElGeWZiS0V4d3FRUzYzZmZjUS9rRk9pdlU4dUtFbkVrcXBsdllQbFFDMFpiNk5KaWJxa0JJWWpIRjNzRkN1Y1pHdjRqZ2U0STVYSDNqU2NIaHo3R24rdnF4ckxXY2JFN0xLNlcyZ2FIWit0blp1dFJhQ3RoQ0dQZGZxOWVDc0l3S3dFaXpOUWlQekJEaEZvazBVeVVINWxWQWtFb2tOUVV1djBjVCs4TU1mZjRDcGJ2bVlFeERxNWtDSHU3VmVlWFM4RHZaQmozSFlRdjVJbHhHOEw1bTVzcUlRMDk5RlJhVlpORVNzZzREbGFpSURBdlBMZjV3a1RSYXI4d1IwUnNqWVBSRG1WdThQaXhOanFab2JWK1FWSVFaWGxCVmhzNHY3bENIQWpUOS92aUFGU3QzbGhkT256a3J6WG01Lzl1R01jZkRxUG8zU2Z1ZSt0N1Q1NTkyMk03R3pkYk42NmMzeTNMVVNhbFNHQlp1TktTeVF0cGk3SlpaaWxNbm4ybFRFZi9QNnYxZjNLTURkd2VqUzBQdkZmQWJkcWpCemdKN0JNYXBrQi9ZMWxhTUlyU0UxcmlKSUF1UE5CWGo4eDQ3eWdGR3MySXM1Rm01L2pnbE5YRVlyODdwNi8ySXdHOGF2aGo4dHJuaHh2SFJhN2Qya0lqV3B5dGg2ZVVsRlFZQytmWXo3MVhtT3RuSlpxMUVMVW9RR2tkb2xCaXZoMGlpZ1NVRkZDS0lBTUJxeDJlWGV2QjNqZURvdzh1SUJBZTBOWXdBdWxYTm8vM0dZSDlZa2Z0Q0tVRlFnSWtWOE03VEREV3o3SkhxdW9xQlFxbWIxQ21EckloT2F6SnNOYUtscUpHdkg3NXhlM3JFL1dPL1hGVFc0RWNBTDIwT2FKZWJwQWJSNDZabkhPQ21jVkVOVDJzUUI2REtBRVFLaW5xTXd1emo4NnVIUDdsS0VsK1ZPdnk1TERmbTV0YlBycDA3bTBmV2xpLzlrcjB5ck5mSFVWSldMTGdwaWwxWE9iRmVaMFhmMksxdm15SzhubTIrait4TS8vYVdYekRNWG9IUVA2ZFdXLyt4Y0QzbzhrMzJ4ODBHaFlvUzE5OGI3WVRGSVdHTlY3c3Njek5aQnZ1RHB1YlMxQVVsakZlM3JoUDhTUTNHZjRUa2FWWDd6dmIzLzVoR2FOQllmWnFTdDVUQytTS24wWmxzcFh1R3dIbzV3VVcyM1VvUDVpRG1ZWkNzeDc0MDhWNTJhbElFaTdjN0dGakljYnEyMWNSeGdyc0t0VmE2ZDJ5TmtCbUNNYjVpRWFJYWtzTUE0bGtLT0hGTGEzMUxEeExBb0VBRkRFc0JHQUFHbGxRSk1nU2NhMFpOcE4yMU96c0ZoZDIxZ2E3RTNXTy9ZazBJbUloaUFDSXdyeXEwRFlacG85NzRnbUlvbHFqZm1UNTZQR2ZuRnVZLzhWQXliZVAwcUxWMmR3Y3NlUDg3Q1B2aWRoYVBQWGwvNFFvZEtxV1JFaytLb1RXNWxtdyszVjI3dmNBZkJIQTV3bjBMV3Q1blcvM3h3KzJ6OFlNdisvSENQMzdCK2lUMXV1a3lFWWxpdHdnei9Scmdod0Fpc0o2V0VzZkVzZEppQ1FPT0Fna0cyTXJ0VGk0QTdMQmQxdnNKek50ZC90cHVWNEx4TDNOT0Z3Y3ErQkVTdnI5RHNaaHZobURtUkVxZ1VZUzdOTmlqZlViVnJkMlVweTNGZ3RQSEVaekpnWnJCeWJod3c0TEZMbERPZDY5RG44QUVHN243WkdzMWtYQjgrYkwwaDgwU3FLU25nTFMxRUVYaktnbVVWb2lGVEJhcytGS3ZSM2gvRE83NTNXdXMycFA5T1JFRzZvQnZsZVJYWWhlRmFiWGlLZyt0N1Q4amtOSGovK0RKSWsvVVZwM3FMKzdTN3RiR3kva2Fmb2ZqQzdOM3RhdGs5Y3ZQbzh5N1dOK2ZrYkFjWGMwelA2OUtjcC9DZVlYNEhYckJnQ0dmTHVpUHI0T2RsTllqR21OVS92K0FQcWZ4L1lsbXl0V2JhTVZJd2drZ2tBaXkzU1YzK08xTHR5UkR3SWkxWFp6bUpYZGRoeWNhU1RoakpRQ1VTQkpHMStGandNZnR0ZVRBTFZJK2wwUnhrRktBWjBiUExNOWhIeGtHWXNuWnlDYzgvMmdxb0pZRmc1YU0xaFVrT1dxSmN5K3BTWXFaWW5TQW9ValNBa0VWYkl1aEplY1FzWCtIUFlzUkNUQmtxQUxSMEVnWkwwUnJpVHRlTzNDTTl2WG5PV0RmK2NrWFRVQUVBcENURVRqQVpTRVBNanJBS0xtL096anMwdkwvNGhKdlZWcm5mUTZ1N2JiMmZ0eW1lWC9nUmpXc2YyQlBCMDJ5anpsWnJPT1pyTkJ4dHFyV1piOWVwbVg1eXVQbmVKT0FzeGtWZDBCc0hTN2NGako3b3Z2ZUxCUGdUNEZQTmd4UXErWERtY1plZkhxa0QvMGR6eTVWNi9qNWVyQWtDTnRiMmxyOWFHWjJuMjFTTlZGcFJZWlNMbi80R2JOTStKY2xUNHFLZkRLUmcrN3F6V3NQTFFFZUU0TWhQUUNFMzZwSTREU1FaTDM0TTU1R1dwWmRjR3Q5WHgzVVZYZmt3Qm8xUmtvSFV6QklDbFFhb0V3SWdSTkJVZ0JvU29SVE1zYzE0S2FETlZ5bXJrckc5ZDZPeE5IMmI2Ty9uNFZIVWdZaUpaYlVmM3Nhbk14Q1dYY3owM0l2amMrMDF5YSsxdFNCbThyOGxUbFJZWWl6MG1YaFhhV1h3U3pJNkp6VVpMTXpDMHMwTXhNaXdGUU5ocXRaV24yZWEzdHJRcmdZNkJQOXNaTlZXSzA1T21zVEo2ZnY4K0ZkbE9nVDRIK243TWkwOGhTamV3MVFuNVYzV200VXlCaDByTVRFVVMvc0RlTmNjRnNMVHdWS1psWU1KWEd5elZIZ1VRdFZyNzlab0V3RU5qYUcrRmxxekgvNkNxYXpSRGxVRU1YRGhncjB6Z2ZNN3VoZ2NrTVpPUTN4aGpOdm50a3ZWY3ZyZDhqRjRXRUpBU1NrREhvT0F6M0xHUWlJUUovUUFnQnlOQkxVSk1rQkFwRTdMZzVteXlLUU5LdHEvMlhSdDI4UEFEeWFCeWVoMG9rRHgxdXpmM1Uydzk5NkVmZXV2SXI1NDYxemhXT0I5djlzblFrRHNmMTVGTkVZa2xyUzlsZ1FObGdBRnVXSVppdkJHRjRzYlV3TnplN3RId3FycmVweUF1YjlqdTdvK0hvZDdLMC9BSUQvUWxQWGh3b3R1Mm5FMUlJcnRjVDFHczF6dlBDajk5TlFUNEYrbC9XQzJmdlJQamQ1SkNJR1c0dkt5K3pkYzNGVm5KdmFXMHc5dXExV0tBV0tWaS9Gd3BGWWZEY1ZoL3UzbmtzSFcyRExmdmxqOXJCT29LMWZna0ZseFpsWnVCQUVLRkVJQWxVaGVyc3FtVVQ3RGV6aHBXQ0xiUGYwaXBEUWhBUllIMXhydHFqNnRWdks3MUtHRWFnV0RRYjBSRWkycjM2OHQ0Tm94MU5lUElJUUxMVWl0cWZmR1Q1M0U4OGZ1aHZuejNjK3V2MVd2REFpU08xQjArczFNNXVEYm14WjZQM2tnb2ZLdk1pU1BzOTZEeGpZZ2NDclFWUjlPM1d3c0s3NisyWjl3RWlIQTBHNmFqZi9VWStHdjNUb2pDL1p4M3ZIQUM1Z1E5VVBNQjkzY01MV0FoQ0dBUlFTaUxOOHVuTk9RWDZYNTZOUVI1NW9KTjdOZGduY2xyUzI2UHlXZ1IzSkZSMFBBa0RvYVNnVmkzd29vK0c0UnpqMnU0UU4rc0t5dyt1UUVyaDgyMGxmT1ZQTzNCcVFJRUVXNGFWQW9nVXdxQUNOUk9JQ0ZVRTdobDRmbkFEU3ZvQ25SU0FqUHpXR0JDaExMMVNEcGNNM2JGZ0MwUjFnaVFpT0hDdEpxSjZMVG95R0pocmE5ZDZuWEZlM29wVi9ZRkRyY1cvOXZqaEQzN2lyVXUvZkhnaGVUZExxcW1FcUxDT0x1L2ErUmUyM1ZzMmgrNmVmSmdHeGFDUFJyTkpNL010Tk9vaDZzMmFhY3pNSG9zYXpYYzc0OEowTU5qcTkvWitKeCtOZnMxcSszWEhQRHpneGZlTGJVR2dRSUo0MG1Nek00cFNUMEgrSFV4Tlg0Sy9tTkdydmZqNEREQVlhNlV6Q3dmY2ZIcXQ5Lzk1eU5wbUxRamZvWVFRVW5xUlppRUluVjZPaTNtSnhvT0hFUVFTVmx0WUVpQmlpRURBV1F1MkRvVjJDRU1CR2ZnblZaWEtUVzRxVVF6aGlkeGpWY1dzcThFWndUVTg4emNPMlBmakpjQ1ZqSFRRbExDWmcwc3RxT21uM0F5RHlzTHgwbko4L09ISFYzOWthMzI0RjNWeWMyUysxanl6MURoN2NyRjI5c2hTN2R6QXFwV0x0eHpia2ttZ3BFNndqTTlkMGZ6dHl6ZGxhRk02UGhPNDY5b3hBQm1BU0ZzZ2pPSWxHYWlsVVpxWGFUcDZJZTMxZnRzWi9VZHd2TVArZFR0WWROc1AwN1UySEFRS2RocWFUNEgrdmJUOFR0RHpBUm5sOFNsQUJEUnp5eGRmMmhyOTR5U0svbzluRHJVZWN3eG01eldmcnZReW1KVVdXdk1OV0cwaEZNRld1Ynd6dnVKRWRVK1hkUVZEQlo3eWFxd1hrSXpBTU5YdWRXZDlqcTRFd1E0TnNwVEJJb0tVZm9Nc1JRSmVRY3VUY2h3RFlVdkNEQzFzd1pBS2tNUmdSV1FaT0hPNjlZNzJFMGRNYmJ1SVdyWGd4R283WG5Ja3dtYzNnS2U2Z3E5MExOa3lSYTNleEttSEhnYmlHOVFpamJtWkVIR2loSFBndmUzdHJMOG50NWhkU1VTSlVvRmhwWjUzbHYrdEtmSW5jWnRsZU5DVE8vTHlldnU2TmxxYjZZMDNEZDMvNmt6Y2R2SjN5OWVaQ0twMHZMZVhGcmNXNnRGOU0vVm9VUW5CVzkwVUYwdE5NL2N2SVlyVjdSOVNUZFdQeFNpZDgxMEE0d0RMWHBySzcyQURqR0V2K3d3Q0dRZWRHVStpaWFXWHBSR2VjZWNZc0tYekduYUtRRXI0UWh6NXcwTXFnZ1JEY1BYM2JCZG9yaFhxbEZEM3pOZkNZM0VnV3plR0xQLzR1dUd2YkVyYzZPUzBzM2tMa0FGT3YvWDlLTE1VejN6MUR3RE9VQVFSTHEvMTBSS2cxVlowYWJrZWZObGE5NlZSWWI1cGpQbWkxZnIzblM0dlY2Q2VuRHA3bFZxckdJOGVUVyt6S2RCZkoySDh3UW84RG9KZE85NFpaR2E3SHNwamtSSkxsem9wc3VVR1dxdHRHb05YQ1Boa0d4N1ExbnJxcTZrNDg4emVPNCtyQVNHaG1uWDN6RGlUV3I5c0loQlFvYWlvc243SEc1ZU1NQkw3WUhjTXVOekhIU0wyQkhsVk9NZ3JLZWhDaXJoaktHSkd5ZUFuTncyK3RFWjRmdGZSY05pbllMaU5RMktJcUxXRXBEbVBGNy8xT1hSNlcrQWt3YkNmNDh5TXdFKy9mUlUvOGRhVi9NUDN6OCsvNWRoTXN0NHJ2cmsxS0Y0aVB6ZGVIQ2k2bFJNZ1p4Sml2TktKcDBDZkF2MTFZWXcvMDNwT0I0Q0dwVmtmcE9YTm9qQ3JtOW9jYnA1ZXBxUVdNRGttcW5yZzNxdlRiUlVJQmd4ODBVMkNJY0VWVGMwTFJxTFNqQmZTTDNadzhCR0FVbDdoUnNCdmZKR0JuNHdUa3h4UlNXQkpNRVNnSFExNUlRWGRLaUJMUmhRUU5qTEdsemFZUG4vRDBlYWdwSExVeCtGZ2dCKzZKOEh4MlJxZXZMNkRpeGZPWTlEZFJOSnVJYXkxOGRCU2dsOTQxeUkrZFA4OEZ1dGhhNkVWTHEyMjQxTm5scFBHaSt2RGwzZEh1a3YwS3E1NlZWMG5KNlFFU1FrUlJNeEdUMEUrQmZvYjZpelkvemdvek1aR043dEVrc0o0SnA2UG0zRTlrTUlSUExxcEVxbnd3bkczQlZGOEVRNFFERGp0LzkyT2RlZkJYaE5lK2dPQnlMUGgvSFZiaU1KVmlZWWczd01zdGUvUlI3c2w0a3NwZUtQdzRoY0FMdlVZZjNpRDhkU21nWEVFa3cxd2JxSEFyenl4aEhPSDJ2aWpsM2J3N1NzN01FV0dxTmJBek1JaWdxQ0JENTZzNDkwbmFuQU9HSXdjckhFc0FYRjBMajdjamlQN2hRdDdUenZtbER6STd5VENFRUVvNVJsdXpvR2RuZDQ5VTZDL0ljTDV1MUZueVFLN090Y3YyZEp1VWlBUHhWR3dvUHhJTFRudGtTMlVCNnlwZm9xb1JtNUVGY0k3QWh4VFJZT3RRbi95eFRxcEJCaWVCaXZJVDJzeTBUNEZWaENCaWFBemgzaWpRT05HQmpuUUNBSkNxQVFZRHArOUNielNsMkNuUVhEUXVzRFJwc1FIVHMyZ2tRVG9hWU1MV3lsc1ZNZnk0YU13RkNGQmhnOGREYkVRQ2FTbW1wUzFJSGJFekN4akdSeEtwT28rZGF2M0F0MnBCYkEvT3lDcW9SK255K21OTkFYNkd3Ym9CNzM2NU1SYk91emwxL0pSc1NzSUoydk5lRjdGSVRzQ2tSUVFrdmEzUS9zYzNPZnBxTUp6dHY3Y1lIaDJHMEJ3eG9HcmZXejd5K1JGVlNlc1Fud2l3RmpBYXFDNVcyQitXeU15RnVSSjZBaUlVRmlMTDYxckZCUWhrQUw5VGdlRHZWMXM3WTZ3MGd6eHRwTU45SjNDalN4QkVkWlJHa1k1N09CdHE0VDNuMjRoQ1FoNTZXQk5OYVF1UUlLSW5FWVNRSWFmdTd6emVlTTRIVThFMGdSdm5aMEQyNmtubndMOURRSjBBUndjcFpwY1F1aXFoM0UrTEcrbHcySWJTcHhLbXZGY0dFcEg0dmFTOVRFWFRHQmNrUE5NT0didnFTRUlRbnJnMjlKVjY1UjhKWjBBejVnUkJMQmZ0ZVFLQzIyQmVMZkEzRWFHMkRtL1k4NzVXWGJKd0V0ZGlmTTloZElCbmEwdDlIYTJVV1lwVm1ja2Z1aVJKYnl3Si9Ednp1ZTRPWkxJc2hKaDBjRW43cS9odmFkbTBVb1VvcGdBRFNoTHFDbENuanFrbW1FdFU2NVp2N0tUZld0blZHejRGVThWMEgxWGorWCt5cXlwVFlIK0J2THFFNnRCRDRidys4QXZNNzJXOXZOTlpuZFByUkhQaDVGaWRwVkM0MzVGbmlvUkM2NFVaRHpvUlZXWVE2V1l4QlZMamdMaFNUZU80YXdma0NFQXBXSEluc2JzclJIRW9JUmhoekFRV0tvSmhJcnc5UjJCTDI0cHJPOE5zTE54RTFrMmdCVUdGQVJZV1p3RjFacjRyZk1GMXZ0QWYyOFBwOW9XUC91dUJYenM0VG1ROEo2OEhubkJpMmJvVDd0aHpzaU1nd2draEJUWUhoVFh6MjhObnE2V2NaVHdtNm45YXNncDBLZEFmNk1CblY4TmRMd0cyRm5uWmkzdFpkY2M4V3JTU0pabElLbGFvMGJFRE9INHRxNGNDS3o5d2tkWnlWQ1JJRmpyd0V4UVNrQXFILzdMNm5kUWtxQkxSdG5UbU4xSTBlaVhJQVlXbXdHT3p3Z01OUEE3MXhRK2N4TzRzYjZOb3J1T01oMGdhYzJpT2IrQU9LbEQxaFp3YWRkZ3U5TkRXQXp3dnFNQmZ1emNQQjVZYWFCZFY1RE9UNzNNSm9Ra0VpaWRoSGFBQlNPM3dPWkk4L1d0dm5qcGV2Zlc5VUh4dGVydi83N2NpellGK3B2RUdMZWxaNW1BYXFrcTg5MEI3Nm1lcGQwYzlmS1hpcUtzeGZYb2NCUUhYb0xHTXBtUmhtWHZtVkdSYUVoVW5scjYxdHgrRVU5V0pCanlMVFlsQ1lhQlBEVm8zMHJSNkpSNGZzL2ltVDJOcTkwQ0wzY2Ruc1JwUExjWDRkYlZpMEM2amJsWmliUXdTSWM1WEttUjlVY1k5bm9ZN3U1Z05YSDQ2VWZtOEtPUExDTUpGQlI3ZlR5Uk0xcENBSllRU01iQVNRaDJHQTRNc2dKNDZ2SXVmdStwVzNadFdMeGNPSHpEZVlBZjFIempwV2FNVVRsbHd2MUZiVXFCL1I2Wm5VQjlHSUNsSUJybDdLRjdkN0J6UGl4ZldidXcrOThYdytMSzhiT3JQN1V3MzFpU2dZVExEWkYyWU8wUUtBRW9naHNMUXdyUGRCUEt0OVJZRUxUMUcxNkpnTEoweUV1SDlsREQ3R1Q0MDAySDUzdU1RbXM0Qmc0ZlA0UER3VkYwdHY0VVhPd2hxc2RZNitjb0NvdTZrbmprVUloNklwRkl3a3pjd3JtVkZ0NTZ1QVVEaHpBVzJPNlcyTnZJRUJCUWxCWlpZWkdFQ2xJcXRPc1NRbmh4eGtlUHpLRWRCZlRpNXFEKzlWdWQrbDZxVXlMSXFxTlhsUlNtV2xCVGovNUdQVmtGMEs3NXZMVXdkemg5NEU1cEtnZUFuWEV1SFJRdjlYYUh0eUJ3TklyQ1dUQ1RiN0V4c1dWWUllQ01nODBzU0hsd1QvNWtnbWZCT2dla09hUHNsTmg4cm9zdlhrbHhhUWdVV1laQlp4ZUhEcDNDMllmZmlVdlBmd01YbnY4R2JDQ2duWUxMY3B4NW9JVlBmZUlFSGp3MGgzdG5HN2gzcVlsemgxdFlia1UrWXJHQWNrQkVBck8xQUlsU2VPWGFFRm5oc05KTzBCYlNFM3NJU0hOLzJCeVpTK1I5SzYzNlhxNHZYZDRkWGFqa24wcFVsZmRRU1k2Vm5IcjBLZERmZU9ZWUNHVWxCbS93V2xTNlNiQTdBQ2d6YzZQWEhiMllEN09aVU1yRmVDWUpLWkJrL1NvWDM3ZFMxVExIaWtWWEZkSEJmdVFjMWpHeXpPRHFjd09jdjJHd045SW9od08wNnlubVdnNHFXa1NaYTF4NC9odlEwSUFLRVVEall6KzRnci96eTJmdzBHT3phSjZ1WVJCSVhOL01jT0g2Q0RlN0pUYUhHb1ZqcUVBaUNnVkNBbUFkc2hKSXdnQnp0UUNCOUZMWG85d2h5eXl5MG1HWUdvd0thM2N5L2NyNXJjRUxtQWpmQ1hDQkZDNEtGRWJGRk9oVG9MOEJMZGNWeUFHUThrVzJpYkxUWkovOU51QUpjQ1h2RExyNWs3MUJsb3RRcnFnZ2FNS3hjRVRNNDBWbjhPUVphOXp0azhMNnIrMXVGWGpsNlQ1dTNNaVJGeVZjMmNQYkh4UDQrLy93SktKWTRUTy85d0t1WHp3UG8zTWt6U1lZRVQ3NHdVWDg3QzhjUTZzZW9jd1p0WlpBYXo3QzdMRTZaQzFBZDYvQTNtNkJ6YUhHZG1aUXNPL1hFL2xhZ0xhTVppREFEc2h6aDZ6MGUrVElnYVFVWUVIQjBMak8wMnZkYndJWTBuaG5IbUNsRkJ3cndWT1BQZ1g2Rzk1SVRNQjczRE43ZGM0K0huc2xCb29pTmM5M3RnZVh5N0pzaytOWklvcEpDQzlnWjV3WGs2allzN3F3c0liUjJ5dnd5cE45N0cyWDBHV09VYitESng0UDhYLzl2NTNDNGFNUmZ1czMxbkQraFY2RlFJV3dWb2QxQWgvNndCek9QbGdIU1FkYmV0RUtJUmt5SURTV1k2QVpJZTBiSUhjWWFZdGJ1em5XdWlVNnFmSEt0QWFvS1FFaEJiTENZWkJhNU15ZTVTY1pRU0RsME5qdGI5N1krd0tBWGtVQTlFQVh3dFVpeGNPcFI1OEMvWTBmeTkvMjRUTDBwRFcrMDd0UGh2QlZOWnJJYXJmVzIwdWZIdlpIbVRGMmpxUnNLQ1VWckZlcllWUVNVYzdCT2NiVmx3ZllYYzlnV2NOWUMzYU1wUVhDV3g5dFlXYkdlOXdyVnd5R1dZaTRYUWM0UUtpQTk3eTNoWk1uRW9qQVYvRFpFcXdkNXdNT3NoRWhDME5zcnFVb2VnVkFRSzROTm9jRnRrY2E3UHcyMktHMTZPWUdSV2tSMU5SK0wxOHBRWm14RzkrKzBmbFQ2N2hUU1VWcEFvd1V3aVdobkFKOUN2UTNsNG54UUR2ZEVjSWZMTkxaS3BRWFlFckx6TDdZMnh0ZEtySUN4cm8yRXhva0pSRVJ3emtTa2xDVUJwczNTOEFKc0RVd3hzS1dCZGF2ZDdHOEd1TmQ3NTJENVFBWHJ3VFk3U2FBY3dnb3gzdWVpUEhKVDg5aWZsR0JyR2ZtV1Uyd2hUOUlqQ05rQlVFRUNqc2ppOHVYZHVHeUVrWTdhR09oclVNL0wzR3pPOEwxdlNIV09rUHM1Q1VHUnFOZmFLU0ZKcElDVnREV1V6ZDdueXVOM2EyQVhoSmdwQlN1RmtvZTVGT2cvNFdMd05PWDRQVmpWZ05DQVRJQVd3MENnOW05YW5XVS81emhBSzRCa003Z3FaMmJnN1hlWHZyODdITGpnNjI1eHJuMlhMM2RiTmVRY0FDZFd3aG5vVlFNVTVaSXUxMlVhWXBqeHhLY09kUENWNzZjNGRkL3ZZL25uaWxRWkJrVzVnMSsrRlB6ZVArN0Z6RWJSN0NsUXlnQWhBS09HQllFclgzZUQ4MWd6WmlkcjBFdU5YRHR4UTBzUmhLaEZBaVZnQkVDeGxxVTFucGxWdXV3bVJlK2g4YU05aUJCSElXcUhvcDRrSHNCVjFURkJnSXdIbXlaMnRTanY2bU1IVHhmdmZwWU1XdnV4aElicjNJVDhNcXM3RFJ2akxyRjVVRi9ORXlIZVp5UHNwYlJUdVhERU1VSTZQZTd5UG9EYUoyREFvbVorUlpZMVBCN3Y5UEg4OC9seUlZcGpoM0o4Yk8vdUlvZi9yRkRTSUlBZ3g1QWlvREFyNTUxSU9qU1h3VEFEQmlqa1VPZU9XUUY0OUxWRGtiOUZGRkFGVW5Jejg4S0llQ1lJWWxBMVpZSkVvSXRnN0xTYm04UGk4OE9DN3RSMVNMS2NZNGVCNHFIdVo3ZUdGT1AvdVl6VTFTbk1BRXFWRENGWDlUNG1uazd3WUwzMldSYmV1VCtlRzgwdkp3UHpRK1hXZktJVkVXZ0M0UCs5amFZSGRyTGk0QWdESEtCMy9ydGJiQVRFQzdIVzk4UzRtZCsvaVRlOXM0MmJNblFraEUyUGZ0dU5CSXc3TjNzbUVOdkdVQkFrTkpMVVlkS0lLNkgyTndlK0pWUU5RT3FSbUdqSUFRNzU3WHZwSUIxWENuVGlpSXJ6U3U3dzNKOW9tb3gzczJPd2t6RDlpblEzK1FXeHcza1JUYnB5aWU5K0hnMWtnVEROdHJ0aFVaNzl0M01hR1JwdnlpS0lqcDg4bHd0aW11MGVlTWllcDF0R0dFQXh4anU5djB5UjJ0aHJVR3pFZUU5NzV2SDMvaVp3emh6Zngyc0xhd0ZPQ2Z3RU5DbVVtMnNkTnVjSWpnQldFZmdpQ0JyQkJFSlJFbUE5a3lDTlNKMFVvTUFCbUJBU2VsRkxjSVFRa3IvTTV4aGRvNUtvdDJ0ZnY0VjdiZy9QdWNtRGpOMlU3YjdGT2pmRjZHOFpiQmp3cXUzbG80WEthakdUUHZleGRVamZ5T3VOVCtZRmFsdzBwbVo1U05xYnZsSWEvdm1aVFVjN0NHb2hiQ2FJUElDNzNwM0RhZk9ObEFVRnFFa0pGR0l4OSsraE9NbkVqaWgvWlNjSUlRUmd6T2d6QWxGQVdUT2E5QWpCRmpDVi9XcktWcEZnSlFDU1MyRVZBS0dMWlNVWG8vZU9SVEdRQVlCcEhPQWMzNEloOGdPcy9MbHRYNzVGTzdjTzcrL0xOSFpLZEtuUUgrVFc1NWx4SHdIeU1kN3gyTUFpVlFxbmwxYWZudGpadVp2cXloNVpKUU82M3M3RzBqcUxTeXRuc0JnZHhQcjF5NUFKQ0ZzNlpDQThhbWZPWXEvOGJlUFlYRTVobkd1WXJFeGpDYlkwa3ZCQ01Hd2xpQmlnQk1DVnptMTBneXJDS1VSME1ZcnoxYnI1SkRVL0taWUpRWENVSUZLUmhpRmtDSGZaZ0JaQzZkOXZoMkdJVG5tWHI5d1g4NE1iNUluRFk2WEpqcUdWNUJpTVFYNkZPaHZaaU9DYzI2OFE0eHdlNE5wVklHOE5yZTg5TUhtM1B5dkJDbzVuUmVaMmxtL09jejZ2VFJVOFV4dmR6UFlYYjlHVVJLQ3dnaEpNOGRQL3N4Si9NQ1BycURkRm9DemtDQ1lvdnJoMGtJRUJHTzhucHdqd0JyQ01CUElIY0dHQkJZQWFjQm9MMXBwRGFNMERuQ0VJSkdZV1l5UVhBdWdsQUFLRDNDU0FnSUVKZnhtV2lVRmdrREJHSXRPYjdpNW03bW4vVkZ6eCtRYUEwQnBMYUpnV25XZkF2M05Iclo3a0UvbTR5R0FLQWpDMnR6SzZrZnJNKzFmQllrVFJUNFNuYTJOcmF6Zi95TjJYT3R0YjM1OHNMY2RFZ0h0bFFWb20rQURQN0NNSC9ucGViOTZXVHVFMHNFNUQrd3lJeEFrSkJpYUNMYVNvQzF5UWxZU0JvWFhuUVA4TWtobkFXY2NpQWpseUEvU3lKQXd1eEJoZnJrR3BSUUt4ekRhSUl3Q1JJRUNRQWhEaFhvOWdiT1cwMUdlcDZWN3FwdWJHeFc0SnpYai9BcGtBSU5weFgwSzlEZUR6U3dzd0JnRFZZMmI5N2EzRHhiZUpyMTVySUlnbWwxZStYaGpidlpYbFF5UEZVVXVPanViTjRmZHptK3ljNWNCZk1JYW5WZ0RDQ1doWkFESE1ZcWNVT1orZkZVcGdpVDJLNVkxb1N5cTBqMEw1RnI0SHJka1pDTWdHd0JPQUdWdVlUS0dFUVFWQ1RqTm9BQ29Od1NzOGR0ZDRwckU0Wk5OdEdZamRMdjkvYnlkQ0ZCS29sNlBFUVNDTzRNUlpYbXhzNXU3enpubUFWNjk2M3k2Y0drSzlEZGJoTzc3MGRhM2tjWmlORjdldFJLRTJRL1ppV1RVYUp5WldWejZlV1ozZERqb3dWbUxScXN0ZEZGUzJ1OEJ3QURBVUlWaGMyWnBoV3FOV1F3M2V5aEdKYlJlUUQxa0JOTDV3UmRMS0V1QnREb0VsQUJFQ0doTDBCbGhtQU9wOXBSWGFmeWFwNndFV2pFZ1FwOVZOMmNFaFBQaWoxWXlqdDFUeHdOdlhjU3ptMTBJSVJDSElVZ1FwQkFvc3hKd0NtV2h5N1N3VDNWeit3cHVUNnhwVkZOclNoS0hTbkJhVElVaHAwQi9rNWl6RnM0NXlrY2pPQy9jTG9pSW1IbXl5aDVXVjJDMU9hNklqeHRtSWtHaVZtdkFXcmRDVXZ3MWdINkxDRitLNnpYUlhsejZXR05tcnBtTk1vVGN4WU9uamlKbVFMS0RkSURXQWl5QW9NWkltQ0FVSXkwRXBDZXYrVTJySmNHVVFKWTdTQUVrRlVkZEtpQ09DSUlZbGdtMW1sOE9vYldERlJKdmYvY3FSdGYyTUxvMUJJUkFXUlN3eGdJTURnSkZSYW4zZGt2KzQ5eTRIZklhY1hkSVNEVkNpVVlvTVpvQ2ZRcjBON3BGdFJxS05FVnZiNithVS9WaGVnWHlzYnpiZUI5NURLQkd6S0VwY3pzYTlXMVNheUpLNmpCRmp1MjFXeUx0ZFIyQjhscXJOYnQ0Nk1pSnFGWlBlbnM5U05uREQvLzFWYno5L1N2SUxjR1ZBTEdGWVlIU0VHenBpMjdsRUJobEJJUSt5c2dOSVNzWjVjaDR3Y2xJb0hCQVBmTDcxblhKQ0NRamFRQXFBS1JsQ0FFWVo3RnlPTUhKYzB0NDV0WUFSVjVXK1FkQmhRcGdGQ05MWDlwSnpiZDg4b0FjRTBBWFJDZ3RNMkdxTGpNRitodmNrbG9ObGdncUNHQzBKakFUSHlUQjNBWjVCQ0FCVUdNZ2xsSVYxdGhkSnRFcTBwSHJiSzZMTEIwNEdRYmJVWktFOHlzcm53amo1QzJqd1VqVmFpTjgvTWNPNDMwZldZRktIQ3o4dHBmTUNEZ1dHUFVGOHN4RFRBYU1KR0NVbXBDbVhxMjExQXdqZ0RnZ3hFMVJWZWZaVTNPRlgvUVlDSVlnaGdpQWdCamFNR1FnY00rNVJWeDljZ09EVzMxRVlRQmpEQU9BQlYxZEc1Uy9VVm9lNFBhdXRkdEFGOFJnNEhwdnV1dDhDdlEzTk1oalpHbUtwRlpESlJaQmR3RjRNSkdieDlVVkJrRTRzN0I2NkoxUnZka2FEZ2JvNzJ5VEVBNnR4VGx5Sk8rUDQrUmtXS3UzczFIcVNQYnpEL3pJa2ZBdDcxd1V0ckFRZ1VNVVYxN1hlcTU2bmdOcFRuNUh1dksvaFRWK29hTVFoQ1FDa0FSKythSmtSSW9SQkpXdWZFZ2d3VEFnc0NNb3diRGFId0NTRFk2ZXFPSFlnd3Q0Y1dNQVdNZFNDR2hqT3B1Wit6ZDdxYmxRaGV1VG0xT2RuOXBqeHRTYlQ0SCtaaWkreFVrTXJUVVpyZTlHaGdrclVOZVRlbjNCV2xOamRnMnJDN0Y4OU5TN1dndHpuKzd1YmMvdGJhNlIwU1hhelNhaUlLUzAxRFV1ZEsyM3ZjMmpmditsK3grZDd4ODZNWHVPSExjRU1ZeEd0Y3loQXJxRzc0dFg0SFlsb1NoOWJ1NHFFUXlpYXMyeVlhOHNxenpncmZCVmUxWHRleU5pUURKMDRRZHhaQUFvNmJCNmFnNlh2cjRHU2kwTElXd24wNysvTml6L3lEcldPTEFpbWZ6Q0JtNkVDcDFzMmxLYkF2ME5iRUpKRURPc01XUzBPY2haSCtmaVlSaEZqYVVqUnoraXd2QUhISE5rZFZGVHhIYjE1SDNIODN3NDI5dmRBU1FnZzlEdTdlenVCRXJsQUxTMXpqbm1QZWZjSHdJTHMxYmJNMUpKR1BZRExCRXpPQ1d3OWhKV3BpUTR6U2hLOGlIN3lDSExIWlFrMU9vU3RZU1JoUDYzQ3dKR1Fvd2dZYkFpT0VjZ3g3QzJXaVFoQVZuM0VqZ3NDRFpuekI5dVltYWxpYzdGanNpY2UzSnRvSCtyMEc1MEFPU3VDdG1kbEdMYVZwc0MvYzFoV2FuaGpBVnU5OGpWQk1oaklwSE1yUng2Yjl4by9nb0pPcXZMRWtJbVdGdzZnakNwNGVvcnp5S0lBa2dLM2FqVHVjYU0zeXBLdlRFQm5CR0FQV2Y0L1FMTTdJQkNBMUVDR0UwWTdSRkN3UkIxSU11QVlnaVVGaGlsRmtYdTRCaUlRa0tyenBodE96UmJEbUZZNWZGZ1JMRURPYUF3QWdVSkh3Vm92ODFWS094dmczRmd4QTJGeGRNTHVQWHkzdFcxUWZHdmU3bTVDVStLR2YrdSsweTRTQkphc2FTTlFUbkYraFRvYjJ4anY3TGhJQkZtY2tBbFhENjA5RWlyM2Z3RlNIbG0yTzl4ZDN1TG8xcURWbzgrZ0oyMTYxUmtQY3pNdGJpenZiZXAwL3gvQi9BWklneVk5L1BjZ0JsaGtlc0JHNVM2OUt2UEJZRmM0ZWxtSEJNS0IrUldvRUNsdjk0dFFZWEQ3T0VJUzBjSkN6TVd6WnFGVW94UUFteThEbDBRKzRVUk1tSWs1SkFyUXI4dk1Tb2xXREJjSlRWbEhSQUdqTVdqRGExYnlXZTMxa2ZQdXdNOTg0bmNuSW1BR2xrV2dpWkhjcWMyQmZvYkxXNEhXRGgvZSs5LzVRNyt1cHFabXovWm1Kbi8yU2dNSDB2VFZBNzJkbDlPKy8xclpaWS9ldlg4MHd1alhnZTF1dUpJRWpjYjhWNi9JNzdpbkVzcmtKZTRQZDVwczJIWkxRc3VIQUNsQUswSk1tQ29HbEFhZ2hNRUdRQmtDS0lrTkVLQlJnU3NIbkpZT3VLUXhCYVI4cit2RkVCWWMzN1loZnhRUzY0SnhJeGF5T0FhVUdhRXd2Z2FnTmhmNCt4NGJyV085ckYyaG90N0pUbDJQc2JZbjNQWnI3cVZJRnpQOTJXMDlsZlpBTUNKRTNNUVFxQmVEd0FBenoyM1ByMmZwa0IvSFp2ZDEzaWxBMEJYN2ZuNVE0dXJxeitkMUdydksvTkM5WFoyTHFhOTNtK0N1V2JLNGkzclZ5OHdFWkdRTFZJTHMxU3IwM3k5TVZnWTlFYzNjTHROeFZWMG9QYTJobHVqekkwS1E1QUJnWjEvV2wwQ0ptTWdJaWpwMjJYdEdVSnpUbUcrYmJGMHlDS01ISVFBQXVFQTVhTUFZd21zSzBGSDRkZXBhT2NYVVFnRnpNNFlkUHNTbVpGdzhGOHJORmhHS21qT0pxdHhMVlNqUVQ1NXdPM1hKNWhCdXJROHFhWlRnWndCVDU4OWZMaU5YaStsSC8veHQvTDU4MXNBQUsybmhKb3AwRjlIRmlVSmRGSEFaOEQ3Ti9pWTNxcUNPSjZKbTYwZlFSRDlTS0ZOM085MnNseVhHeklNQmphM3A4Rm9BaUFaeUR4TzRnQWdLWVNvQ3lGV0FYeWhLbWhWdWpURUFMdDBVQXpUa2RacDVpVmVwUEtQTXJxU3A4a0JJMzE0UGR0eW1HMHdadWNjZ29EaERJRlU1YjBMUWpxU2dBU0tBWUV0RU04d1JPRFp1bzRGdFBiVitHYURZYnNPdzBKNHZYb0JhQXMwV3NueGVqTmFHQTN5QVc1M0ZteDE0Tmx4bnM0TUpvTHpuS0hiMDYzWHIrL2g4dVVkYnJjVC9QZi8vV2ZJcjVheUhBUVM3VmFFbmQxMGVwTk5nZjVYWisyNWVhVEQ0ZTBRMWIzS215c0FVaEFkSStBSEhMZzk3SFZ5NjF3K3M3VHlRRHJzTGZhMnQ4L2IwbnhkU0hWZmMzNnhtYlRuVldrZER6cTlqU3pMWDY3eTNYSGV1NS8vVzJPTGJGQm1SZWFnQWdsaDJBTzlaRGkvbnh4SlhhQTk2ekEvYTlHc1cwU0JQNHBJK3RaYTRRUkdScURYRjRocnZoMlhqUWpGQ0lnVEJqbTN2eEhHTVVFcFJxUE9FTUpCVzBBTFNaWVpjVDA0R3NWcUdjQWFFVm12aUFkaWhzTHRQam9EY014dzdQMzUvdklLclowRHdKMU95bjV0RSsvSCtFVEVSSVM1dVFTdFZvd3JWL2FtTjk0VTZOODdtMTFhaHFzR1ZjbzhwNG01OHNsQmxSQkFwTFdleWJOc3BkWnVJNmszZzJBbWxIbVdCZmxnMUhUR1BnbmdzNjJGaFUrMTV4YmU0eGhpdDlQYkcreDJmN01zOUhuY3VZV1VLdTJYZ0ptemZyZnNGTG16cWk0RnRGK2RVbzRjWUJsQ0VaS1lNYmZnMEdvNUpJSHphNTJyRmErNUVlanRDVGhKaUdaOERaRkNSaFQ2M25taENYQitueG96KzMzc2xnREJrQkZCV2taV09ncGtnRGlKWmxRZzIwUUlBYmJNY0FDa1g5WkE0NktjcWZMM3NZY2ZqNnM2Wmg0ZkJQYjJJY0RPYU11N2UrbDRFQWpNNENoU2NJNm5ZZjBCbTZyQWZwY3NxVGVRcFNNeVpZa0psWmhKa01jWVUxc2RKMUtJZTV2MStvbEdzMFhXc3V6c2JHTFk3ZHdFNDNPelMwdExNNHNMSHhSU3RZczAxZDN0cmYrMXpQUC9EY0FRdmlkZFRvVEM0NTY4bUYxcDNydDBxUFZBRUtsUUcwWlpNTG5DUVR0R0dBZ2NQc1JZV0xTUXhIQkR3UGFxYWw1UVRiWmxZai9mdG9aUTVJVGhydStoUXhDS2twQ1hoTUtJYWhyT0YvMTBLV0NaUUFKWVRoYng0S0hENGgwUDFnOHR6SVdKMXVTaVNOYWNoV1JHQ1dZR1FRRWNWVVhKaUloQ29qc1lnbkxpRWhNSEpvRkJKQWhGWVRBY2xpQWljczRmV0VMUWRONTFDdlR2bnZtaWtpTlRhamhySjBGK3g1REt4Q1ZCV0pGaDlFaGNiMUp2YjRlendSNjEyckdZbld2T05tWm0zeEhGclVORm5ybTl6ZlUvS2RQMGZ3S3dCejhRTWtrOGdmZVVGQUd3alhaeVpQWFk3R05oS09wd2dDMGNXY05nWnRScmhOWFZLZ1JuQXBjRVp3bEdDWkQwRERjUkFFNFFuQVYwSlZCUmRIM2d6WXBnTldBTUlkT2VRU2NBT0N1UTlobnBnTUVHNkE5R2VPYWJ0MUNQNU54SFAvaVdCNDhmYTc5N3BrWHZlc3ZESzIrSmsrQm9HQVVuMnExNE9RZ2tDU0ZJU2lFQUtHWS9yUWNnSUVMb280RlhnWjRBQ0s1YWxzNEJ4dmpOTkVSRVFoRHVPZEhHa1VOTmJPOWswOUI5YW4rSm5yemRSTjRib01qeThjYmlnenoyNk1BVkVsSFlubC9VTXd0TFdaRmx0Vkd2eDQxR25SdjFxQUdJUjRVektFWmQ5SFk3ejVScCt2OWw1cTBLNE1XQkhKY21RbDZiRGNyaGNLaE5YRmNVS21LWCs4R1dKSkdvMXdVQVJwRktJSENRRGMrVUl3ZHdXZTJFWTk4cTArd0ZJR1ZFYUswd2xIUXdqcEFYWGxUQ01zSFA1amhRemhDQ0lFTEFPSUxXakE0WDlJZi81aUx1V2IxZXU3NitWMXU3MlY5Y1hxN2YrOEFEaTAvOCtDZnZkVGZYaDZNck43SzFYai92RFlkbDF1M2xUdzBIeGNWU20yR2FsanRwcW5ldGRXWGw3UzNBbW5sZnJNTDRzQjhXNEhGZjNqSXpTeWxnakVOdlVPejc5V1lqQWhIUUh4UlRvRS90TCtMT3ZVNmFzKzVnNFMwRUVBa2hrNlJSbnllaVF3NXUxaGc5SzJRdzM1eGZla3hJbGV6ZHVvRlJ2OHZGVUpyQkhzRTV0Z3htNTNqVFd2ZlByTFV2VmdBZjAwakhPUzZxNXhvRFhmUTdhVy9ReWJOYUk0U1JJSkVaVUNRaFd3SEN3UFBhcFdWWUE0UUxCTXNFd1F6cnZCZm42dWhnUnpBNWcrSEZJWWtFcEdDRUNhTXNnUWlNWEJNMENFRTErRUlrUEUvZU1jNDh0SUR1eU5BZi9ic1hrQTRMYnRSak5PcXhlTi9ibG9NSDc1c1JTWVFrVU1IOElLMnpObzZIbVhsZnIxL28wYkRNQnYzc3l2Yk84SXVqVkY4enBiczJHaFhyUlduTEEwWElnNkFYQUt6V3p0MjROV0FsL2FsRmxjNWxyMTlnWmJtQmpjM2hGT2hUK3k4emRneWhGRGxiSHV5VlJ3QkZ6Wm1aSTNNckszL2JzWDI4TkVVOXo3TzZDbXF5M216SGUxdHIxT3Z1TUlPdmxtWDVaT0dMVVAwcUZ6OFA0S3Z3Rk5mSmtIMFM2SlZIWndNZ0hIWkc2NzFPdHQ2ZVQrNFJrU1FJSWdrZ2pBbXVZTGlVdmRKcnp0QkRnbWZmZXlJTnc3ZlNtQUF6QWx3WG9KREJMUUkwd0JsZ0lvSVZBRGw0L1RrUVJBUUlZcEJqQ0NJRWRRa0Zod2NlWGNMRmwzYXdjNmxEdi9nMzM0TlBmdXgrNm5ldlluZXZnNFVad2NPaHhDaHpGQWFDV2pLSXcwQWtVYWlhVWFnVzY4MzRiWGxoOG54VW5zL1M4Z3RHMjYvMmgrVjJiNUFQaTl5a0FEUVJhV1l1SndxVGhwa05RSzdVbG9uZ0FJTFdEbUVnV1lqdnJ3bTVLZEQva2sxbnhiamFmbEFoSnBaS0pIR2ovb2tnakg2aTBIbTl6QXR5QnBoZFhvSFZKWGQzTjBBQ0dveHZPZVovVzRGOFVGMWpVc3prRFBjZHFxbTQzYUt5QU1nNmJLYUQvRVkyMEpvS0Y4cElJQWtsb3RCN09FY0FSd1FWa09laE9rK29vUklJQk1NeHdUREJHTjlhVTdLcWtXY005QjFLQTNDTlVDWUNtU1U0QWt3cEVBbEdRQXhtUWw0d3lwNUZGQ2c4OGJGNzhkUWZYY0ZIMy84QWxoWm1BYmVKTk4rRHNVUnhMS2llQ0dqaklDMEFLMkFpaWJLVWxCc3JoQlQxSUZhUE5adlJ1V1l0L0xSMjd1WGhzSHhxWjJmNHJaczN1OWZUektUVjZ6SjU2YXBpYjVuaGlPRHl3amdoQ0lWWHIyRUFtSnVyWVdtaGp2T3ZiRStMY1ZQN2MzajFPeXZzNCtLYmltdTErMVFTLzFmRzZzTlpPcks5cloyK0xVckVTVjJWZVlheUhGRFlxRE9JcnRsU1B3ZEd2d0p6T1JHdTczdXNDWkRmM3E1ZVBXOVZrRU90RVQ3WWJDY1BFeEF5aUJydEFDdkxBZUlhUVVhRUlHS0lCREFnR0ovaCtoYTFBNHdSc0s0NlBZakEwbTlvTVlMZ0RHQUtCaFJRQmhKNVZaQmpCempqZjQ0eFFHRUpaQmdFUnRLS2NmMTZIOGdNemowd2crSHdCb1lqamRKSXY1TFpBYU9SUTFrNmtDQllCN0xXa1dNUWc4SE1iTFJUS3BBenE2dXRVM096eWJzV2x4b1B6YzNYb2tZOUxIcTlQTGVXSjJjSUpPNFUyUnhIUGNpeTIxemtSajNFYkR2QjV0WndDdlNwL1ZsUnpwTlRhZnRWZGhJaXFiWGJmMTBvOVJGamRERHNkQy9vTFA4amEyMDdIZlFYMGtFWFFraUtHMjNCNEtaejdxTFQ1bVVBYVhYbEU5N2NIZ0Q1UklXZ3VzbXBhazJ4bTUxYmFMNGRSQzBoSlZZT3haaWJWU0RCVUFFUVJaNThZaXlCUVhDdTZocEkzMW9iTDJqZ2FzRWl3VmZpT1JSQVFxRGs5bUVBSWlqbklBd2pqSUV3QUtRQ3dwclhsWE5NNkk0WXozL2pKajc0N2tjUmhnMFUrUjdTVFBzcE9PdDN1R25Edm9vdi9GNDM2ZHRreE14RVJERGFJcEFTN1psUUpFbXdORDlYZS92Q2JIemY2bElqcWlXcTJOcE94M1JnV2JYcGJyZmpQRkZuSC9oRVJDU0FzclEwR3BXb0pRcmF1R25vL25xeVgzcm5VYVNseGNXZERLRVNzTXllT08wVHNqR05BbCs2MnZrcktNbmRRWTdodUZGL1FJYnFJOHd1S2ROODRJcnlUNXZOZWpmTDhrUVhPUU1ZZ0tnSWpaMVhZWHdvVE56RGVwUjlic0tMMzZIR01nSHl5UUdSTWFQTWd2ME9zM1JRWENvSzNaZEtISXByQ3ZXR2dxZ0dSdmJMaGZCYTdkYjZkcGtnZ3BTK1orQTB3TVIrQk02T240aWhKQkRWSEpSaXlHcGVIZkFpRmhDRUlHUUlabWdub0RVZ0dHaWxBdFltZUdaRXVIRHpPaDU3NkNIWWNnZEVQWlRiQnRZTUVJWUNqYnBDVVRwSVJUQkdvbGFUc0k1aHJZT1NqblJoa1pjYWtpUTZ2WkxqSUZLdFd2eEk2MWg0NXVqaDFuTVAzTGYwcHhldjdIM3p1UmUzYnVhNTZWWHZ3V1JJYnlaZnk5R29kS05SeVZJU0VZamJyUmpPTVFiRE4wOWwvZzNsMFU4djFzRU1KSUZFSEVoOCtkLzlkWHptVHk2aG0xb2tnWVFTaEVnU1FrVUlwSUFnUXF3RWRsT05ScVJRanlUUzBuNnZRRDcyNkFHQXVMV3c4Rk5DcVE4NGExWFc3Mys5MWFoZlBYUjQrY2NJZER6TGM4M2dyNGExNUphSzRuc0lJRnVXeitzcyt3cUEzbVRPT1ZGNGU2MVZ5dnNjZWdDQnRVek5kdlRPcUI0ZGJjOGw0dGc5ZFlTQjk5QWlJSVNSUHhySzFKTmtITVBuNU5hSDhNWjRlaXNKZ0p6UHZlc0pNRDlyTURkajBVd2NHckZETFdiRUVTTk9nRnJDQ1BjUEFLQ2VPTVF4bzk1Z0hEc2k4UENqZGRSbUJoQkpIeXhMTk9yTFVESkdyN3VIdkFCa1FHZzFKSlFpbEpxaGxJODBCQVNZQ1k0ZGlzSmdNQ3p4N1BPYmRQTkdINTFlZ1U0M0M3VzJSNEpBUHJ5MFdEOXo3b0hGMVdZejFEZHVEVWJWYTFVSlp0M3hlcUVLUmdBUWhDUUtBK2tGTW9zM3p5YlgxN1ZILzhHUGZBelB2L1FpYnR5NkNTSkNQWlRvQ3VHcnVvSnc4Z2YrT1NJbGFHOWtJTVh0UkhXTWdsRDRvcE1TeElLQStIdTMzbWVTSkFNQTg4THlZek56N2FUVDcxZ0dydFRiYzJmQ1d2M2VwSloxQ1BoNkdNY3ZKYTNtKzBnS1dhYnB6WEk0K2hxQUR1NnlmUEF1QU1maDR6UFkzUnFoeUxXcktLYmp4MmFkbmVHMzU1YmFqOVJxc2lrRWtXTy9BMGxZMy8vV0JhQ0hqS0RwZ1ZrNmdxNEF6ZzRJWWthOXpvaUZSUXhHMG5aUVlkVitZMFk2RkJnTUpZUmd6TTFieUpDUkdqL0pKZ1VqbHY1c0l1ZC9zVnBUUVpKRnFxK0RHZ0hJYXFoUVlaRUMyS3NPdlYyTE5ITXdscEVWUG1lWGdoQUdBbW5GZTNHT2tSZUVScU9HTE10SXhRUkhEazgvdjhGRjZWckhEcmZmZWZMRXpHTm56eXc5Y2VxZStjOTkrZXZYUDNmaDR0NFZlRG50Z0puSDdVbmhpM2F3ek95TWNaeGxlaHkrOHhUb2Y0bjJ2aWZlQXlFRWhCQzRjZk1tTGx5K0NBQzQ1L2dKWExoMHNVcDltVjdhSEpKMTR6bEdVRFhXS082cUpWZzlqQWhNQUNrcGVDL1ZBTUNIWm1JOGZHd0dnUkw0blNmWC9rSy8rL0hIUDRpOHQ0Zk44ODhjRE5rbnErN1JzTnVOWm1kbnFGNnZ5YUxkZUV4R2NUUE5TdDN2RHI1cHJmc1B6VmJ6dldFVW56TzZ6RjFaZms0WHhkY21QTGg5TFlDUDdjZzlzOGh6dzBYaDVSclpENTh4TTRwUnYzaVp3RmxySm13Q25xdnVnR3BSSXFCc2xkd1RJQ1dnUWkvNktBUlFxenZVMnc3Tm1rTW9uTitMTG9CTVM2LytTb3pNU2FTNVFCSTdNQkVLNTN2eWdYUmdBSVpGcFdYdEsvSERuQ0JKUVpDczFpbDJJV0pnNXJoQ09DdXd0eTZ3ZGtXanYySEJGckRhcHhGUkZkYVgycURLcTdHeVhNUDlwNWN4Tjl0RXQ2dXhzdENnbmIyYzg4TGl3cldPbXA5SkhtN1d3M3VmZVB6WUk2ZnVXZnpjTjc1MTQwdTdlK2wxQVBYcS9SbUQzUUF3MXJLMTFqcStrenY3aGdmOFgybm8vck0vOGRNNGR1UUlHbzBHdE5ZVVJSRU5oa1BhM3QwaEFQVGNTeStJM3FCUFlCWUVDT3RZVkdtNGhKOWpudVJDcS8yTElVR2VGKzJMT0NDN3IzZ0l0QkpGaDJackZFaUI4MnY5djlEZk1IdjBYcGdpbzlIT0J0MGxkSTdnS2E1c2pJbktvbmlybENLTzQ5cENVcXMzYlpGU054ME1HN056QzdWVzZ3a2wxYndwaW91amJ1OWZPbXZQNDdiczByaksvcHBnUDN4eUJvTk9ScU5CT1M3SWpVazZnWFBjT0h5aS9hNTc3NTlmaUdzU1VnbHk4RHh3S1lGUStyRlREcXBpSEFOUndHZzBHVW1URVNWVjY5QUpRQURHeVdvNUdpRTNBcG9FNG5yMU9QTEFEaVFqbEE2Uy9NK3pUTkFzWU5oUHhVbnlLNWRMOXRMVFN2ZzNMZ2lCeGl4aFpsa2libFhTTTVxd01CTkFTRUtXTzJTWmdkRU8xckZYeDhrMUFpRVFxZ0MxSk1TeHd5MmFuNnRUTFFtUlpocnJHNE93MXkrT0x5N1VIamgyZU9aVXZSNlp0WTMrTG00dnlybWpXSWM3WldqcFFFbzJCZnFmeDRTUStNa2YrVFRXTnpib0R6N3p4OVRyOVhENTZtWGEzZHNqRWlTVVZOSTZLNDB4a3BrbFR3TDVkdTRiVEZTMlE1cVFTdWJiQXhEakZvc1A3WWxnSEtNekt0RkxOYzZ1dG5GaW9ZRnJ1NlAvc2hld1ZrTXg3Rk14NkhrNjJLdmxvY1o4OXUyeUxKczZMNCszNXhhaU1BcGxrUThGbEZxSTQvb1o1M2hPbDBWUlp0a2Zab1BoNzhLVFpGNGx1L1RhSG4wRzJ4c2pLZ3N6WGdDaDRPbTFpWE9NNDJmbXo5NTdkdUdrRElWd0pJZ0I2TkkzQ1NnZ1JNTGgwQ2hITXpOd2lVRFFJaVIxUDU4dTZiWUlzeU5DNlFoRTQwbzhJSWxSN1ZHc2VudGNqYThTU2lQQkRoQ1ZEcndnSUJTK2ZlYXFhVk1TdnIzbnVLcitFeUdLdlJqR3pMTEUvQ0V2T2IyOXJqM1BuZ0JqZmVuY09zYmEraEI3ZXlNY1BkeUFsQXBsWVpFRUF2VWtvSVhaR3MyMFltUzV3YzdlcU43dEZmZXNIR28rK09oYlZtYWVmM0hySlIvSzcwZGdkQ0Fxb3dPRlRyeFJ3ZjVkRDkyWEd5RnFnVVFvQmFRUTJPNlBzRmM0a0JENHYvdy8vdS9VYmpaUmxBWHQ3cFhqSlFhVDY0Z210NVlJWDgrRklFL3c4aDRiRU5YalVVMVlWdDFnRUhuTndqRXZXc0N6cFd4ZU9wY1d1ZXNFbXBhYkNXcnQrTDg0TkJ2OC84bjdyeUJic3l1L0UvdHQ4NW5qMGw5YmRjc1h5c0lVWEFOb2gwWTN5U2FiRk5ta21wUkVEczF3S0RFVW1obHhZdlNnME52b1FjOEtQVWloR01WSU00eFFjSWFpcUtFNGJBNDVaSGV6SFJzTm9BQVVDa0I1ZDIzZXRNZDhidSs5OUxEMnljeTZxT2F3S2JTaFZCRVoxMVRlekpQbjIyYXQvL3FiZXpkSlhaL0I2QXN4U3NZVWlCUVhQclVCL200NUdyWGp1dmlGb1d2cXcvMGpFMU1zVjJaSjZBZEUwdnNrK2UrQS9Rdkk4SC92Smdld0NsTElBNldtR0dXMXJncnY3anBuUXdqaUJ3U2JSQ09VaktYeThHUzc0b1g3QzQ1bUphODhYQkNtdXZtZDAwcG9iZU1Xa3RWeVBPa210eWp3bG9JaTlOWW5kWmNKQ2srMHdXQXdURjNFR3JXbDhnajkyVUZnY0M1emQ0MzZQc2RrOEhrR1ZvMGQwNm02NERBYThlNnJIYzM3aVhFZDFWRTNKU2FUa3BObHk4MDdKenovMUdVTys4UVFFblhsRUdNWTFSTjJkbXFPVHp1NWY3Q2k3NFpINzgyYlB3NjhEUHpMZFlXWUQ4Wk9SQzZ5RHRjZlBNQlorTGVxcFA4OTIrakdhQXpQMmpwcDdRK1UzeGtUd29Cenpod2NIUm9STWZGOGsxd1VnVGlVL09HTnprUzlDRmJPUGY0dFlKMHhybkRHand0WFhkMm9Sc2FZK05iQjZuNGJZZ3VtTkVpWGIvZ2VHSkt5cFJoaVN0KzdjOG9MM3BwLzA0ZlduNXhjQk4vY1djVWhVdml5M0tycityRnlQUHBVSXI3WXRhdXdjMm5uc3BOb1Q0OFA5bGZ6NWN0SlVtbmduaWc1NXR2QXQvZ3dqL3RmQ2NLdC82dnFnbnBTbUtQN0s5WnpZcFZzU2hwUHk4bjFoemN1Q2VLSFFjOERDWWt3Q0VrU3o3UXJubDh0cVVKaVo5SHoxUHRMN2p3MWdnMkRUZnB0STFaRktqbXNRYkxMcFRYNnJGTXdMTzhidXNwU2Jlbnp5ZW5MWUdCSTZ6bTkwR0hwcytkY1NvYVFETFZMcXBqTGcyNEpockNlejF1b1N1R3BaMHUyTDN1KzkzWEwyOTlXMHd1eGhoZ1RNU1plZTJlT2RTWFg5bVk2MnpkcWlvRVQ2dHB6cFhKbWEyc2s4OU5PYnQ0OHZmclNKNjc4alNSc25wNzI3NjFXL2NuOXc5VUhLWWt6aGxMa0xDcXF2OUREcHdlZWhYSE9TSXp5L3g4Yi9YLzJsUnVjTklGLy9wMEQ3cDcyRjNvYllYL1ZZMWJHeUZsSlpJeHpCUVl4TWNiMWJYd0dYaGxqUE1oNVVvbmdMUmhyY2RZWUpxVXY5eWJGMWtaZFhITFdqclluZnZxeHk1UHJWemZxSzVjM3FvZkd0YjlTVmRhOGVXL3hHMy92dDIvLzQxZHZ6OSthZDhHamJpWWZLcnVTd05HcVQyL2NtL1B3OXBnUGpuNlhsa1JscWNxUUh4eHRGY1lZZi9XeHgvK1U5KzR2eFJUMm1tNDU4blVwVlZXWkVIcTNhcHNEUWY0RjhKWUljK0E0byt3THp2UENMeXJUL3BYL25SNDE5RzNJSEJDNFFBcUplNWNtVjdhMng4OTBiU3p3RmlTcEsweUNsMVlydnBEbWxJVVFDNE1Md2lOM1YrejBBemVmSGRIc09GSUVUNkx3QmdsWmE4NzVUZDhNdXVHS0hVTk1NTzgwL2FYMEFxTGdYRDhZQmZ1c25Cay9SckdJMFZnblkxVjc1aEFTaGlDaXQwTW04ZlJHTmUrelRjY25mM3pLWksvZ3RkK2FJM2Nhd3FnZ3hzU2k3WGoxalFNSzY5amNHSEhhSmthRkpRV2hDNUd5dExqQ212R3M0b25IdC8ybHZjbkhYV0VmOHRhMk1hWGw3YnVMZi9LMWwyLzlOd2VIcTFzaHBOSVl1cnpoUDhTaHZ6RGlCR0JVZTVsTksrN2RYLzcvM2tiZm1aYUlRRWpDN2VPZXd1blk1dXdpMStka2pNWU81WDVIckNCbUNPa2lNdjBoUXdZQjd6RE9XVk9PQ2x2TzZtTDY1Tzc0eXM2NDJKMVd4ZlZyTy9XVGorNk1INTlXL29vdjNHaFVtcklzekNnSkxpWjhMemhmR3ZPNXA3WS85dlNWNlUvOXh1dEhmKysvK3ZyTmYvanUvZVl3bmJQVzFraSt4Q1RjT1c3azhxeG1VbnRadHIrTDJhbWlXVHFBWHQvb1dySzc4ZDZWaDJ4UmZDbUU3cWxtdVdCeGNvcHpWcmFxRVlrazBkc255czN4djVQYTRUOGJtdjVmUERBckh4NjRRZjU3cVZveGZpaFUzRjVzZXg1NmRPc1JaODNPTUdBa0p2QVdJOEt6c2VPbjQ0TEtKWUxvNWlRejRXYjNCMjY4bkhqdnhRbW5Pd1hHS0Z1dHNFcUVDY2tTMHRydFZmdnJpS0VKQnRNSlpTbkV2QkJFWUJDZGZ4WTJRVEtVWHJCZWd4clhsRnNsOFdoTEVFWDU5NGdvOTkzRGdDSGtuL0dSNTBaVW13V3YvTW9SaTljQ3hoa0s3emc4V1BIMnUwZDg2c1VLaXlYRWxIcytROThsaXRKUTE1YmtDNXcxdGh2U3BhSzBXT1BscWZIMkkzczc0eDk3OWZ2N2YrZDdyKzMveXFvWjVrQXBJcXYxR081Q0Q1OWdIWUFMS1lsY3Z6cmwwdDZZYjc1eTc5OStNTzZ2L2ZRemhORHo3djJHY2VWbys4ZzcrNDE1L2U2U1JSK050Y2JtbnVjTURSZmR3S1Z3WmlaUWNXNFN1QTRSSEkzcmV2ejAxYTFMejE4WlBmM0N0WTFuLytpemwzL3E1MTY0OHBlLytOVHVMN3oweU5ZZi8vaU56Wjk4NU5MNEU5N1pSNnJTN1ZhbDNhaEtNeWs4UlJManU0Uk5TWXdWb1hUNHFyUzdsemJxbHk3TlJyT0RaZi8yL1huZlh1aXR6a293UVdUVkI3eXp2enY2NHhweCt2Qk5YZ0YyWTN2cjgzVmQvdWt3OUR1TDQ2TkZ0MmdPNGhDTCtlbmNuNTdNcFo1cytvM3RuVzFqemRXK2E3OHZTZDdQRzcxOW9Hd1hvK1h4NzNpclQ2NXRNUzR0aC90TE8vVFJQZ0FHMWk5OS91RWYyN3c4K1Z5d3Rvd1lNd2c4blhyK2VGaHdoVWd3cWtNM0pqOGRvOSswWGtUOFhGaGQ5UVJ2V1FWSHhHQVJZdEs2UFdIT1N2b1VOSTY1aTRhWXROUzM2TTN1ckg1OWo5N2VPTEJPVDVZNEdMV2gwc2gxbGNrSzlGRmRabE0weEtSR0Y5WXFncGVTb1pwNVJwZHFtdFBJNmppUW9oQlQ1UGIra3IzZEVadXppbUZJVkxVbGhVUk1FQ0o0YS9CZWQ3ODFFRVBDT1dOOFlYM2gzZVc5M2ZIbnIxeVpYUmVSKzh0bGZ4S2pGQmM0RWZZQm9vMGtFZG8yTUI0VnBxNDhoWGM4ZkgzekQ1VnA1ZTlxby8vRm4zeUdVV201ZFREbllORmpyVEhORUUxTVlwUGlPeTRsY1JlUThjcm9SNzMrRmYyb09MZFNXbi9VbjM3aTZpUC83aGNmL1pzLzkrelczL3pNWTl0Lzh2SExreTl0am90SGZlRzJyVGVUQUVVWHhTVXhXRy9OcUFLamZHaGpMV1pVV2JOUkdWTjVZMUlTTXdSWWRLbTh2RlUvdnpzcnkzdno3bnYzRjkyYTEzanhwaFJyakhobnplVlp3Yno5WGJIbjFodjk0aFJndXJHejg3T0Y5ei9aOVczWkxGYi9YREQveUZmMU16R0VVUmpDMjBQWGpTZWJXNFVZOW95MzAxN3Bydk9QdU5IWGZJQWYrTzkvOHVYTDdHMFUzRW1lZTI4Zk1uVEJJT0x6MkxFQzZySjBXNS8rNHFNL1g4M3FaM3B3ZzhBVDB2Tm4wb29iSmhKRVphWnJkTVJJRnJrT2lzaVg4OFF3dHN4M1MwSlE4Q3dhZ3hoTEZDM2pPMUdKcXRnc2JRVUtMOURsRTdDQ3lnc21aYzkzb3dCY1hNL1gwVjU5ZmZ5bXBObnJKdi9aWm9SZTF1VWk2bjZqWkI3UHp2V2FiaW1jM3UrUW1GZzJBU1J4NDlxTUdLRHJOVVUyUnNFWEZtdkE1OVBUTzZzZWN5SGh2VFhXWUp5MzVjWkcvYkVybHlhZjJ0cXNROWZIZS9ONWx4NUE1cytldjBKR1JsYk53UDVCWXpabUZaTlJ3YVhkTWZ0L1NEYjc3NnAwcndySC9rbGptajRpZ3NsbHJoV3dLWW5sd3lNd2IvUW1MeTZDYTV1MUw2OU1xMnBXdThwWlV4MnVRaWl0cVlJazg4ZzRmR3pLNnZPVDBmVEthaENHWVUzeEVweERTbTlNSEFSalZNMFVrc1ZuMFVPVmhOZ0x4aWxkYzlrbFFoUmpNVEpmaHVMR3p1VG52L3pjbGVPalJmK2YzemxwNDRWZVN6RWJFVEh5YjR5aXJ2RUhDNEoxYnVwOThiREFLQXhEbDFKNno0K25qMC9IOVVaVlhaS1QrL3N2dDZ2bTdiWlovTFF2U2xNVkpZdHowQzErZUlNYmtkL0IrS3dxRElVemRBZExjTmFrUGhqa3JGTDFJcGk5YTdQZDBheDZOTFN4aU43eXFTcnlKK09TcTJWVTBjckZBaVpsZjlaOHprbWhSSVM5MTFzT2Rpcm1HNVptTUlUZWFWOXRoQ0VaMm1ncHJDaWpiaUZVSVZGTWxmY2VCSmF0bzdXQ0Z4M0Q5V0pWdDUrRVlNRG51ektHM0Q1a0o5clNDNE14cEtoTVNHZUVoQVdyTmxVdVFtMEQ1WTduVXorMWg1akVhMThON0d4V3ZQbk9DWmQzUnp6MTZDNTlBT3NNZlovb3UwalhBV1BQeHRUVEQ4SjQ1T202U09rTVVsaERIMjFNd214YVB2V3BUMXo5ai9kMng1OTk2KzNEdi8ydDc5eDdzKzNDSXFmaHJNazJ2ZUk5Z3NuUHJlc2pYUmZsMnBYSnYzMDkrdFBYWnR3K1hKcmZldjB1eDhzdW0vQ0psUXZvK0lXWmRwSDc3V0pjMnVycHE1UEpDdzlQcjIrVXhjTTdkWEh0OHFTNmpKaGRFVGFPVitGZTdjeGtTQ2xZWjNldDlkT21TK2E0U1hTRHBuaU9ScnFoUTZjejNZMlJXaGdOZzdKbnZNL2tPS2Z6MVREby8xczJpVUZsaXhLaTFBOXZUMzdoazQvc2ZQZmcxVHUvUEtTMEZuNUVnV2lFTk1Ray93YmR6SVVUWHI5WFVkV1hYVkU4WnAxMUV0TkJDdkZZYUI2MUcrTmlNcHU1YnJYY0dvYmh6YktxZjhvYSttNEliK2J4MjhVUmpsam54SG5IMFBWbi9mZC85TzgveDZvSi9LTi9jcHVqUmVCNEdjd3diN0oveWtWdk9sT0FGTHRYcHBlU3RkT1loRS9iamwrZzVkYTdDOTRWNGJrYk5kdGpTNHhHZGVZWGdxS015NENaTTR5UElsdHZkN3ovZk0xS0xIMHlGRW1vbmRBbDFhd1hDSlhWbkhSbmxkRmcxOEJhZ3FaMVRPdEk1UklqbXdpRENta2tLK2ZXVDhLSU1telU4TjFvNHV2WlFhUkl2YVRjSkl1T1lvaUpqUzNIWjM3bUNzYkFkMy96RG9VemZQTTcrN3p3ekRaMjhLemF5TGkyTEJ0bDZ6Vjlvb29hRGduZ3ZLVnBJMWh3aFRPand0QjFRZG9tMUkvZTJQeGpONjVQUDNacGIvUmZmdXM3Ky8vdCt6ZFBEL25CSUlwQmhHQU04ZjdCRW1mZzZLUVJnSzJOaXVQVDd0K09qZTZzNWI5OStiMDFXbTBscFFmenZOYzlZUUdVbjM5aTgvSW5ibXc4ZkhtemV1eVJ5Nk5QUG5hcGZuYkRGNCthd1V6RVlkNjdPM0M2RE15cWlwaWdHU0xIeTRIVFZhUnlrV1V2OUZFb25XR1VnL3VzTlJSZVpaRWhDWVV4akd0RFdla3RYaGxER0lURlVwVlAzaGxDU0pTRk1jNloxT0gySHI4MC9VdVA3VTNmZk9QdTZkc1pNOUR4aWNGMklhVzdKLzN2OWozOEFhbG8xeXl2ckU1TzkvYXVYV2UyczdQUmgrN0ZidFc2bUZMcStwWWs0bnhaUGx4NDcyT014MFBmdjU3TDlZdll3VWR5c2NZalhabk9HZjdCYngyU29ocTY1ZW1GZndEN0tGMWQ3RW1TNnJOVjRNK1VMZHNwY2pMYjR0MUgvaVNuMXl6YmQvOHh6SThRQ295WHN3MStsdnVDVWw0dnZkbFNYcDhpVTB1UlIyc2lVTnRFdmRZWkNCUVZXbFdWNENxMW1ZcUQwQmwxbmtuUllQTlAyUWZMa0F3dUEzemVhQm1QaFFHckFLTlJ2bjFxaEtJMjJmaGRENEJnTkRqU1c0R1FxR3ZISjM3OENsMFRhYnFldDk4NjV0dmYzZWVsRjYvUmRlcFM2eDBNVWZEV01IU1JvbER3d0JmS0VZaERRb1pFWnd6T1dTTXBzVm9PVEtmRlU1LzU1TFgvNWRWTGs2ZGZmK3Zvdi82VjMzai9PL3lnTSsxYUFodnYzbDhsRVdGVWUxa3VlaDYrdnNrSHQwNys4Ry8wUlRNWWF3MURTQitWNTEydkY5Zm5uN3AwNVVlZjNIbmhzWjNpSjYvTXFrL3RiSmFYZDdlS0dVWk0xeVg2bUdUa2pZd0xXSWpROWdJaUhDOTY3aThIbk1Ic1RVcTJKMDdCRzJ2dy9zTklsREV3cmkyemlhRXF5SW9yUTRoQzI4bVpQdHA1dzFnc2ZSUzhOOVpaa2IzTituT1BYNW4rOU0zajFYK3g2a0tmRDZaMUdXOUMrcDBOZ24vdUY1NWdQYi82Zi8vZHR5N1FVajcwVHl6Qy9zR2RXKy9FWWJpeGUvMXFOZHZhL29xWW80UXh0WUJZN3g2dXA2TUJBeUVNODc1cDMzMkE0cXBsdTV6djg3LzUxMThreE1SMDZ2bmF5NGRtdVJ3eW9mZU1NSFQyUEl5aEJoa0J4WTNOOHVFL1VuU2pyOVFETzFib3U4Z2puLzBTSC9zTGY0dVVFdUdYQ3N5Ly9MOUJscVZLSGlDbGxJTWNyUDUrdEFqY2VML2g5UGtDSTNJMkpxdWNNQVREcXJPWU5wRmFvQlFxbS92b3FDTTFaeEw5WUFqQlVEalJNVm8ycWhBTHRsTEVQUVE5TUpMVnVUdWloMCt6VUc1K01UVU13WnlkTEgyQVlDMlZFV1NJVkxYajJjOWY1dUR1a3RPVGxsLzc2bDNHNHpGWDltYlpXVnAzbzBWZlc3TG5ScGplcXJsRzB3YUdRUzJ4eTlLYUdNV2NuUFl5blJTakp4L2Ivbk9YOXNZdmJtNVUvOFZ2L3ZiTlg5cy9hUGFOd2VVdmVYR2lnekhhR08xZG1zcFAvK1FqL05OZmVvK2J0LzlnTnZ1L2JwMXFUcHVCM0ljL1NQRWNBZlVUVnpZdi9kblAzUGowVjU3ZStRdWZmbVR6TDIzWDVlZTlzYnZlVXNVaGlReEpURkRTcy9SaTVxZlJuQ3lqTWNhWXRrL21hTm1iSmlRenJSM1hkMnFxeWxLWGhxcTBheGQvUk1BWGh1blVNcDFabkRVWklOSzNPRVpvZWlFa3ZmRTA1a1BUUDFNUzhJWXVKck5vNDliZGsvWTNGdTF3ZkpGNWxuc3NDbWY0NjMvcmhmenZZTFl6WW11NzVOV1g3L1BTRjY3dy8valBYOHQ5cElVazlnRitlNjJnbWh4MmJmUHcwQTFYWTkrWEtjYWlISStNeFpoaDZEYXRrZDIyN1V6ZnRLLzF5K2EvRnBHVEN3U05hSXlKeGhpeHpoSkQ1RXMvY2hWakRQK0gvOU4zZWZWN0o2WnBva21pU3ZFTHo2TTJoakhDV0tEK0l4K2JQZllmdkxUNUo3NnlZNTZjT2x3VUNLRmsrTUpmeGQ5NERtTXEzbk1BQUlBQVNVUkJWRmZVbUkwcnBIZCtHeGIzd0JaSXoxbHB2RVlMVERJWUQ1TkY1UEJxeVRCeGxDN3Ivc1V3UkoyZkQ2MmhHNVRDV2hRNld4ZkFSSTF1a253eVNUSm5NL2lRMURIV0ZvWStXbGFOcFQ4RkU4R1Y1MkdMeHF0aHBTazRTMmxKeWRBdG9GdXE4eXpXTXZSQ05TbVo3WXhZSG5RY0g3VXNsb0dIcm0yb0Fpb3pmSVpCMlprYUI2R1hUYnBRbXgyZmRDUVJ5c0tyWExaUFpnZ0pRWmhPeXN0WExrMCt0YmM3cWRzdTNyMS8yQ3o0c1B4MURmWktqTXBaZVAvbWdzSmJUdWJ0SDdxTmJoNzR1RmlxWC9RbUgvMnhqMTkvNXM5Ky9LRmZlUDd5K0M5ZG5SWmZySzFzeGlqR1dhUXVERFpoSlJuVHRja3NqeE45QTIyYk9HMGlZb1JtRU5wc0ptZ016S1lGMWxtNmVINWh4cVNsK0dSc0tTdURpSHFjaFFnaFpOQnVuVW9zYXo2OVllaUVvZGVIYXB3eGZSSnpmOTZONzg2YmwwOVd3enVvdjFyUXpVV3kxb2l6OE8vL2J6N0pLMTgvWUg0U3FDWUZvN0dqS0N3ZnZMTXd6VEtZR01VWW5UVFpDNlBFOWVFM3daZ1Z5SDdmTk9PKzZ5NGJZNHZOM2N2R1lGaWVITnZtZE9uYXhXclJOKzEvbDFMNkpUNXNMaEh5bUYrZWVtYUhnLzBWbHkrTk9UcnF6RnZ2bmhxMVN4S2JJNDErNEhrQW84OCt1L240Zi9KSHJ2NkZINzFjLzNocHpTaEVpK2w2d3NiakZELzVWNmluVzRCZ3lqRmdTZS85TmhMekZUZUk5c1ByWVZKV0V0UkRJbGpEelowYUgzVk0xdldXa1BOaFhBbjFDT3BLZTk5RXRvbFduaDQyMzNrR3puNmZqRTVPVWpJTUEvU2RJU3pWbWNZNVlUaUZJVmg4cVJaVk1SaUs0cHhMSDRKbXZLY0V3UmtHWTRsUm1HeldXT000dnJma2d3OU9tVTRLZHJmSGRIMmlLQ3hORTFUS1hEaFNXa3Y5RkptM1ZyME1EbzhibkxOVXBVTkVhTnBvUXNJTWcwaFZ1ZkhXWnYzYzd2Ym9rblAyM3EwNzg0TU1nbjZJZ2d3YUJtbXRvUjhpNDFGSjB3NS9hRGE2ZVdCMDlLR1IyWG8wdGplck4vL21Uejcxa3ovNStQYmZ1RG90Zm5ia3VGWVZWaFVUWUx3elJpTEdXWU4xaG5hUkdGckJlRjBZcDAwZ1JPVTNTd0xwSS8yUTJOc3MySnVWZEVHeXQ3ajIyamFDRTlWZTJueGJpRUEvQ01NQVRTdXNta1RoWUZSa29uc1VZcStIUVFTNmtGaTBRVDQ0WEw1MnRPeS9uYzVaYUdkeTBDVHdMLzdKTFhQci9aVTlPZTdOL0tnenh3ZWRXWndPOXZTb3N6R3FpZzc1Z2NOdlhlR3NQZHRiWDVYR2pmd3pmbFJ2YkcxZVl1aTc3dlQrL1ZlR3R2KzJwUFRQUk9TZkE3Y2ZvTDBtQTNMcHlvUW5uOW5oblRlT2VPMk5ZKzRmdEdiVkRJaklXc0YzOFhtTWdmRW5QN0h6eUwvN1Z4Ly95bC8vMHQ2ZisreTAvSW5DbWxrVXZaVkpBdldNNHJtdjREZDJjL05XWXNiYnhMdHZrdTY5Z2JHVlByd0xoYWhaMnpVVWhxcExmRENxbVR1SGRlb0YzK2Q1ZW1XMUE0aVoxbXB5SDROWno4THppTXlTNTlpNWpCTGRaQ0pneEdCTDdmSDd6dEFlcVIxMU1ucDdodzU4b1FFVElSbVMxODhYZE13M0pQMCtNUWl6N1RIOU1uRC8xcHo5bzRhWFBua1o1eHpMSmxDVmxtRklaem9CNHl6cERGTVZxc3B4Zk5KeHVtaloyUnFkSFFKdG0xQVBPOFFZVzB6R3hSUGJXNk5ITm1iMTRkdnZIZCs5MEhwZEhJMm12bytNcW9JZis4SU5xdEwvdnJQbzNML2lKci9ZaTUvUHhRMGphOHdFR0QrMk8zbjA1NTY5K3JjdVQvMFhyVE9sTlVqaGpCSFJxcGFvNlozT0c2cFJKcEFab1I1ck9UNWZSbHlla2JaRHBHc0RRV0JqWExBMUxVQUVqNUl1eUVRSG0xOVpUTkMyd3ZFOGNyS0lWTjR3TGd6R0NFNzVzdnB3Z3FLMFVSUnQ3V0tTTGlUZXZqKy9mYkFjZmowTGp6OFVnbURBcnBiQmRsMXlLWXBOVVZ5SzRsUEM2eTBxL2lNMitOa0JPTm5jZnJTZWpiNDRtbzUvYWpRYmZjSFkrRkJSMXVWa3ZFVzNXZ3pMMCtOL0xFbitBZkRid01HRlRmNGhnNGtZaFhmZlBDSWxaZlMxYlZnbms1eDliMk0wMWdrWS9meWZ1dkhpWC9zcmovM2xMMzV5OWo5OHdab1hwaWV4VEJFeGE5R0I5WmptQ0QvWnd6MzIwbGtKTE9VSUVzUzNYb1poaFNuY2gyMHpzblNWRXFvaDRRVnVYaHNSY3M0NlhwK0xFU1crclBQYmpNMGs4YURJZmxnejZLelZ3aUVhd3FCL0gzT0ZGcU1hQ0lBaHRGcG14VUxiZ1lEQldKWElSVGtuNmtSamlVWmx0REZCaklZWWRPYnVDOC9xb09INHVLT29ESjk3YVkvRkloQUd3VHRMMjBXYzAyclI1elpoU1BvQVJvWG4vdUdTN2UwS1l4MElySnFnYkx0ODA0aGd2TE1QejZiVm94dXpldis5RDA1dVorTVBlVkNqNEp6TlBncm1EM3lqLzQ2bHVqR210c1pNUlB1L0tWQmRHbGVQZnU2aHpWK29TanZ5emxBVytZZEh5NngrVU9IRUVPWEN3MWVycDVoZzNrUWtRZGNubG0yZ1RRbnJMTlBLc3pQMlZJWEZlVFVJckF0RFBYSVlEMDJFWlN0MGc3RHFFaWtLaFROTWFzdGtZaW5LWEhibXR6a00ybXVISkxRaTBnN0MvWGw3Zk9lMC9kVWhydUVuSFN2emcwR0lEOHBpeXdjM3VESGFHeHZEQ01QVzl0V3JQemVlenY2UzgrNmxKUEx3MEhTbDl4V1Q2U1o5djNKUmhnMUVZZ3JwRnVyVHZxNHEwa1VFUCtxMWFLeTFhbVltUDJnaERZeXF5cy8rNGw5NDRuTi8vczllLyt0UFB6UCtxWTFDTmpmdTl2aTVLT2M5WFp3UEpEaTlpNzN4Y2N6V05YM296dU0yOXZCSDc1TStlQld4cFc1c2s0VmE2MTVkbVVWTW04akpyT0NnS2lCbFJWb211RGluZjNaNVJDYkpxT2xqM29USkt1R21DOHAvWDM4TVViUGN1a0UzcWF5ZmlOTktJcUdIaWkrMEpWaTJscUZUQURhMHlxa1lsb2wya2RUWE9VTFhKb3gxdEt1QjVXSEQyKytjOE5nakV4NjZNdUc5bXczZTJiVkRwQnBSNWhzOW9CV2dOZEIxa2YzREpROWYzMkFZRW1GSU5NMlF4WXE2MGZzK2lUWG0wbWprcjByaTlidjdpN3NYYUxKeHpZY1lRbUozWnl4RjRianorK3c0NjM0SGx0ZjVMVzVNWldBa1VJa1NpaVliNDNMMnlPNzQybWNmdWY3Rnh5YnVDNlBTRlFZeEtZSXJvSzRNelRJaFNlZmFNUXBoVUZ1VG1IVEczZmZDL2tIUHFvbTBJZEd0bldNTWpKemwwcVNrcWgxbWpiNGFWVDQxQVpwQlA3ZjBoc0xySEZmUVU5bWNsVi9uQm9odG8zWkVmWjhJQmdiQnRFTk03eDB1djlFTzZjQjhOTXROSndyR1ZNYWF5aHBUWjNwcnJhajJEM3lNOHIvWmNuWHh4NHF5K0l3eHVPWHBxV2xQVjRRK01IUU5LU1V6bW0zczR0eVR4ckl0S2IyUHlFbldCS1FIRGxzcllCR3hIN0hKSzJCaXNaUC8wWjkvNG9zLy8rY2UrcDlmdVZwK2RoV2tLb1lrTzBmQnVOTUVVY2RUQ21wbEprcDdncHpjeGQ3NEZHYTh3ZEZKeXovNzdwSlgzajdtOHZGM21kQ1Jrb1VJSm1hK2VqSklyeWFSUlNtTWg4aitUc1hnSFNZSVZzaCs3T3Y1cXo2TElUUGRrdWp0ckFHTzBBMXFXUldUR2xHRXFENTFaNW16R1AxU0tRY2xDb1JvbUhlV1BxcGhSVGZvMTBtRDBuRmpMN1RMeEpCdit4Q0UwRVZDTUp6ZU8yVzFHTGl6ditManorMnltRWRXVGFEMGxwUmJRZU9VbnhHaUtMa2lLaS8vM3Y1QzNXMm1GYXMyMHJiaFRFdWZjbXgwUHlSak1KZXEwbFZ0RzE0N21YZnpDN2Q2V20vMi9ZUGw3L3NtZjNDalg3ekpML2JqNDFGZGozLzgrY2NlK1ZQUGJQejRIM3RpOTJlKzh2aWxQL3FGaDdmK3lHN2hmMnhXMjgxSjVVd0lpbTd2YkR0S0QwMnJaQVlEU21peEpwTVR0TXhMR080ZDlmUXhLV3NwSmtSRWYwMnd1MUZTMXNwMWxxUU1xNURVNHFndUxLUENZTkZGM0lXRUViQmlHSHBoNklVd3BHeVVvUCsrYXhQRGtGUnNZNUUrU2ZIdXdmSzFSUmZleEZBWUE5WWFiNndwalRYVjJRME5sUWlGeUZud1gva0ErRFdkYlZmYlYyOU1yenoxL083akR6MDZlMnpWOHNtWTdDT1NFZ2xqeEZpR3BtSG8yOVIzblVnQzUyM3RDbjlkaEhub2hsZnlhN0RXR3ZlQTBPZWpDRWtLK01Ib2ovL3NqV2YvQjMvNjRmL0Z3NCtWbis2aStPUGp4TGdXczdOSytLTjBObzdNNDU0TXNCbms2RDNvVys3dHZjVGYvdlY5L3Q3TEIzenJxT1o2dU11VDZYMmljOHFVVy92YnJKTkpuY0ZzR1daTy8zeHpXbUdDVUVUdEoyVEliRHVqbTd5NVVNcGJBMTB3TEh0TG0wTWRqZEZTM05oczlXSzFxVlZ3VFA5dENBWTdpQ2E2WW5CNS9KYXNtbUFFZERadnZTRTVROStyWlhTTWlhRlBoQ0MwODU2d2FuanYxcEtxY0Z6ZW5UQmZETG9XUlpSanZKWllpbnJTeGFqbC9iSUozTG0zWUhkN3JGaFRGeGxDMUZJY2c0aVltS0R2b3lzS2Z3Tmo3cngvOCtTTkIxcXhwTm51ZnpBYWR2OEErUGJnclRFeXh0Ui81WTk4OWpPZm50bS80dHY1SnhlcllSS0dWRW5FdDMxdlpUb2lHTDBvS20rcFI3Q3hZZWw2b1cxZzVQVW5HOUphQkpLWmJCNUdVMCtWSEVOSXJJYUlpTVdRaUpKZ1BUdlBDM1FOdnJrSUtRZ0RjdVo2TW5LWk9wbXJnaWk2WU5hZTVPdUZSR1pSK2NKUU9WZE9TL2VJTVdZVE5hUndhamhnZWwxbnFycmIyQ3FubzdHZmxvWGJtRXg5ZGZuYWVMYTVWY3dlZldMeit2YWwrdUhSdUxwaUNqdXFKbTY3S0Z6Vjk2bjRmLzJYTjJldmZIMkpMNHpCcVdraFFER2VtbXBVazBKcnJIRmliREVlNy9KU3NlZS91bjluK1hiZlJTM2ZqU21zWG1pRGlBU1JEN1VXYTNSLy9PaU4yZFpuUG5QcFQ5OTRiUFJwVndaVGw0WnFiQ2xIMEoxWTZ1SmNiMlhXdzhPMWlCeUx2UFpQZWV0MGczLzYyblc2T3k4enVDbS9kZWxqZkpiWDJZd0hERkppVERvSDVkQnlTSmFBVHp5MVhMRTR0THcrSGFzUGV4SnNGcnNNQXpSaUdNVGdzcERGaUc1UzB0b2hSRGV2c3lqcEJUM1FKYmRkUGx1UnhLU2hhZGJBMUdxTHNFaktuUE5XcThWNFppS29veENKdXNHVGdQR1cwY1lJNXgyVDJ2SHIvL0lXbC83RWpObTBZTlZrTVZNWGlURlJGMTdkYzVKZVBERWx0alpxOWc4V0hKMDI3TzVNOElXbDc0Tk9jekxIMzZqM3BTQXltVTJxUC9INEl6dGZlL3U5dzFmejRkd0RUa1NpTVlheWNLYnJnL3hCYlBRSHkvWWlsK3Zsbi9xeFR6LzkrYjN4djlmdjcvLzQvcUl0bGlHSkpLR3c2cU5lVklhaXNEaWdLZzIrTXZpUnhSVVIwK2xEYjN2MTk2cTh5WXdxd1JXV29qSjB2YWkxY0FiYUxBN3h5cFFyVzR1MTJiQlF4NlQ2T1RhRE0xbVJaSXl5cTF5aC9mOHc1RU1nbDE5ZHI1dmJENGF1QTBsaTZzSVZEMjNXbjMzbmNQVkxlSHR2WTdNY1g3NCtxbmV2akhlM2R1cExPenZGcnZPVVR6d3gyN3U4TzdvNktvcUh4Rkc2a1NtZE5YN29USkc4S1VPeWhiVmlob1NOV0NpRnlhYkhXb3Z6bGpUdlNhc1dST2lYU3pNYTExU1RpVllXQ1hmajhlMVAvTkUvZmVOL2RiemZ2SExuNXZ6Vy9MaTkrZnAzRHI1eDUrYmlYb3BTaGhCRGpKSk1GdnlLVnNsVjRVejF1VTlmL3VJblByWDlzNkhFSDdWV1VvQXJPMUJXc054empHZVc4ampxclpPdktqRUdXNmh0Uk9vV2ZPeWR2OHVYM2k3NXYvenE5MWxWdSt4OTVjL3p3YlVuMkdqMk1WYTVCemhscksxTGFGcUlObEdTZU9uZUthTW04cjN0S2NGYWFxczAwcFFFRzYxV1hRQlJXNjlrMWZMR1JCaHM3cEdENEgwMnJCUTlrSzBSK3JCMnRsRnFyRStTQWQwTUgyU0dYaUhLbkJTM2RndlZBeU5HSVFSOTNlV29vSjZNMk9najl3OGF2dnZhUHA5NDlncnp4ZHEwVWwxeWhteUFLYm1TSEFaaE9pNm9Lc2Q4MGJPNU1XSlVPYnJHRUdMRUo2TjZ2dng2UWhUS3dqMi90VkYvMmp2N2JvanA0alRGcWpRNnBUK29HeDArN0Z4YUN2ak5qY24yajkrWS9SbVpIMyt4YWRwaUVDVGt0SXlJY3BxclVvMzluRFc0VXVlaHpVcG9XMkhWQ1M0bzJHYXNvU29zdnJaNEI2NjBGSlhqWkJVSm9uRytZaUNrUk5za3VpNHkycXgwYzF1akxrbkdJRVpCRXVmMGhvZ2lORUZYNEppa3RtM1dVRGlvQ21WVExWckRrRVFYbElGR01FWHB6TWFvZk9RVG43NzBwYy85ekxYcW9ZY21UK3hlSGwyWmJmcU5vakRqMGh0ZmVpRjA0bEl2TGdvdVdhVTZSWXlZRXBhZE5WMUFqTk9pYkFpR1ZZQ21pOWxpeCtHZDQvS05MWTRQNWpRbkhURU9sTGFnN3pvS1Z4S0NyMXp0bjM3MjA1Y2UrOWduZG1PTTBuMzJ6dktkVysrY2ZuMTUycjM3L3Bzbjc3NzUydUc3cHlmZElnUXhrcVJFcExwOGFiTDUzSXM3WDU1ZWNydUpKSGR2SmhPN3lJMUxobEdSV0cxN2p2ZEtMblV0MG1VZ3pSaWx1SjZWcHpBTksvNjloeGVzYmlUK2o5OC80SzJtNXVYaEtaNU9MK045T2xPWWlUTm54bWtTd1hSS1VQSSs4ZnhxeVRSRXZyOHo0YlR5dW9oRUtHUE9kL0VRRUlLeFp4WlV6cXJrMUJnaFdrTm5WQ09QMVhZc3JQSmhYV1dOYmc2VEdFVERKV0kwV0t1QmFuaXJiYUZBMFFiU0lqQVVEb3doRGttVGJaMmpxZ3I2cW1CalUzanR6V011YlUrWlRVYzAzWEFHeWprTVpXbHpObzAreHE1UFhONlpjZXZ1S1ZjdnpkU1J0bkkwVFdCd0NmRm1QY0F3Z2lUclREV1pWRDkxYVcvNnk3ZnZuaTQ1cDFxZldZTHRibzg1T0ZyOWdkN29IaWljOStWZitZbG52ekJOeTU5WnpKdFJMMGFNRldPdE9VdEFzVlo3NGxnSm01dVc3VXVXOGNTeE9Jb3M1Z214Q3BDbHd1THpiUjZ6d1VDZkVpbUl1bjhNaVdhSUdDREVSQjhpYlIrMUQvZGE5Z3VHY1ExdGJ4aFYrcTRXWXFCSnhFR3JndGdKMFFoMXJjR0J4a1BoRFZVcnJKYkt2ckhHNG8yNlZHek02dG1qUDdiM0Y1Lzc0aFdQaVBjR20xSTBzUlBhUnRKZ1JZd1RrM1BBR0FMU2l6WFdZYnhKakYzQ2lqRnRiMGxHc0FqZU96YTNLcnJGVFNSc3NyRzlSNVFGMkFYR0dmcW1ZVFJTdTlSdTZGZ3VCdE4wMENjS0dWTGhyUmxkdmo3OTVLVnIwK2VKS2FiUGgvYjJlL092ZmZ1VmU3OTZkTkxlMzcrN3VuZjdnMFZ6NWFIcG81Y2UyL2prYVdQTXlGcTVmbDJZZU9IK2ZUZzBsdTFMc0xoUnNIRTRVRWVkYmhqUjI1bTFNQ1RISTI4NnozLzRoVDIySDcvT0wxNTdtdnBSS0c5ZkpwN2Uwb05USk0vU2xmUWlFYVFYcERlSTE1TDk4YU9HdlJSNVl6cmlnN0trS1owYVBhWnp1eW5KeG5OMlVDNkVjV3BXRWRjSWRzcmhUd0twVjRXSUxjL2xRcVpRZ296Tjgva1ExQmJMWkFtckFJU0U3U000aXhWbE9ZcTFaOGg2NlQyN1c1NTNGOGU4OGU0aEw3MTRuUkFUemlpUGZzMGg4RjZyU2NVMllEVHlGTjV5WjMvTzdzNFVhMVhlMm5WQlNVSFdJaUo0YTB3UUdJLzl4MmFUOG9YYmNEY1RvVHlhK21yeXVKVGZ6MzdkWGJqTjE4WUpOVkE5OWNTamV6LzUyTzdQMTEzM28zMFRySFhXWUtFSkNwWVZHYUc4OGRDSVJ4NnJrUlJwVzZFdUlmUkMwMmdadlVaaEtxL3o4SlRPQjlhclZWUUNBcUpTVk8rd3pqQkVZWHRTY0gydnh1VVphcDByZ1hIbHNSYmFUay96RUhVQk9RK1RpY05YYWs5VTFvYWl0Z3laLzk1MjZheVhTd2FTRlZaOU5FZDlLTGR1YlB1dUZTUDV4aThLUXpYQzJnSWJvelhXR21PY01URVlNN1FHNjRRK1dGYWRwVEF3TGhKVm9ja2szaHUyZGdxTzd5OTQ3L1c3bU9ReHRpSmxKVWZzQXVWb2hCR2hYYTJJY2VDcGx5NmI4Vlp0WWxCanRZd3h1T1J0NldvMzJ0eXNIbnZ5dWQwZitmam5ybnp4cWVlM1AxblA2bzBuSHR0ODlwbm5OajlyRExaMllxWmp0V3oreHRjaVgvMk5nZGtVdGgvVFpKUDZPR0w2ODRtdXlSOXJpcEJZR05XV2owMGp6MTNmNWhPZit4U3pPOThuM25rZkNxOUFXWkdyZ1h5dFMyZVFmcTM5VTJ5a1RvbnJYY2VWZWNkNFNNeFN3RVZoS1k1T1ZLU0NxTWtGRWJXWGpsQjRaYytscU92RFdrWFRHekhFd21aZWZaNzVHMFBJOHRxbWh6NHFzWUM0dHFmU2xpQmhNRm1nMHZlSmZqWFFMVHBTSDBoSnFhejNEeG9lZm1qS2JGcHI2R0orZjd5MzJxZXZtWmE1ZWhYZzVMVGwwdTZVSkFuQm5QWHB6bVZnRVdOU1NzazVPMW11aGc5T1R0dVhjL2srQUVHcHphUzZLbjVmR1hMdWdiSzl5S01qLy9sSGRwNStiR1QrWERHRWgySVNvb0ZtU0xUNTVpMEtqY3k1Y2JYQ0pQamdacURyWUdObU9EM1JCK3FkOXQ1Rm5vVWJ5VFBXL1BjaDZDdzhZUFRJYzJ2K3VqQWJlYTd2VkdBMWxxZXV6cEdvazVOSW54bHpROGc5dXRmRnFPV3BuQkZyWEtFUG9Ha1Q3WkJJVWRseU9FTTdKQTZXTFZlZjJrVUdNUmJNcU1hTUoyS01VeXVrR0ExeDBBTWxTYTVLZXRWYU82Y2cwcHFwRllQNm00MW5CVTg4ZjRuSlJzV3RkKzV4Y1B1SWJ0NFNlNzFaZlZtcEtpdjJQUEhpTmgvLzhZZlBuQ1c4QmNHWUlNWllDOFloMFZ2RW10STRNNWx0ajY4Kzh0VDJpMWYzSmsvdnpDaDlJUnpmQzV3dUlsdDdGbC9CL1gxaEVNdk9GVSszVzhBS1pvdVlZNVVVR1NkcW1JTFI3MEdLaGlwMlBOcSt3U3dlRStkM2tkVVJ4aXZyeGVTS3pKanp3MktkQkdGUW1Xa2FJSFV3WGtVdXJ3YXU5RDJQdGkyUHp4c2VianUyUTJDMFNteUV5TGpRTW4ydFdFdEFzallEYWhyeUtNNW1SeHZPakNSVHlJQnJzcVNvempYT0c2UlBDaFJhbTZYS1F1b1M4YmdsOUltdWovU0xqcjRaV0hPWGg2QmwvYlhMVTVvMllwMDUwMVJrZDgwemdVcktBT0ppMmJNeEs2bnJnbllWNkh1MUh2UGU0ZXlhRFdoRUJKdWlITTBYM1RkV3piRGdBVWZmcGgxK1g4RTQ5MERKWGdLVnRXYjBFNDlzZk9scVhmeWN4NDRpU0JmRnRERVJSS2dxdjNaMllWcDVtbFhLem83UUQ5QTIyUm5mUWxGbUFVSVV5dHJpbkpJUnlzcmdDc1BSYWFRM3NPaWlJcDBZdXBBb2pHRlNGd3dSK3FDRW1MSnlGT09DWlJOSm9tYURrT2YwVVJlZk5UcDhsanlEMWZtcjBQYXc2aExkRUpVT200U1FoTU51Z0hISlpGYmpDME5abXB4QW9vS1pOSUJFWWRrWm1zRXEyeXQvakFvZEtTbmZYa2VCaGMyYnlGZ2VmMzZYNjQ5dGN2T2RFMDRPVitwcFhoZmdTMEpNM0hoNmc1LzdxeTlTakNyYUxtR3RPWFBzT09jZ2k3RVlrNnh1L0pDRW9STnZneFFiWThFNzRlMzNCdDUrSy9EWUU0NkhIakZjdmVIWXUrNFE2K2lTWlZGN1pzdUJFVW1ERXVNRjd2bUYyeExyZE9JeGZ4dkNNYWJ5NTgxZHV2RENjaTl0ak5HNDR5alFHV2oxMTVnTWFUQndLcmlWTU80anU0dkF3MGNkajUyMlBIbXk0c2w1d3lOTng2T2g1N0pFcGhMWkhnSmxTdlNpY2pMalRKNVZHNGI4dWxPamY2OStoZGw2eDY2bk1vWTRDSEZJeEtCQ0pta2pzZGZaZDcvb2FGY2R4bGhTU3FRa0hKMzBiRzVVMUdXUnF3a0ZjNjFiUDJzVndLeWpXUmVMSGd4Y3VqUlJKbWRJOUlQYTZyaHNhWjZTbXA0NGF5ZnpSZi9WNDVQbUZoZU1KYk9xN1E4T2RjOTd4SXhLTjlxb3lodWxkWk13cERQRlR6SmdyYXFRWXI0VlUxUUVYVTlJT0QzVnBNM1NhTmtUT2tVMHk5SmdNeU5PckZCV2x1VEFGNVpTaE5KcVpLNG1aaHI2S0p3c0FydGUrM3VKUW9yNWF4V0dicG1nTUl4S1RmMFlRajUxZytUeG1pYUNPMnNvdmFXdUJWOWFwTkhaZWdnSmk4RUhPTHg1eXJVYm02UXU0b0lsZElaVjFpK1BDbEdsVmp6dkkxa3Z0RjVMMlRqb3ZCZ0h0Uk5xcjVCNmlKSHJEMC9ZdVRUbDdxMFZWVzNZdWpUbC9vR1FPaFhMakRjcitpR3FSRElrQnJldVhQUVFTY2xrRHpmb29qRlZnU0ZFYVhwaE9WaTJSb2xIbnk2NS9taEJPWVZlRW91Rk1EOFZ0aTliU2dkOWFYbmorcFNuMzF1d0ZRYWl6ODUwNjVGWjVHd0R1eElZZWUzQk85V1d5L3JuSDlUcFJYbzl4Rm4zc0ZaN2RUcjlIUExoS0VNdXAwZjVnRmdyMGlvdDg2ZE5nMWw0WkJJWUpKQ3MwR0s1UmNsUjVUbW9QTGZMaXR1dW9NK08zTEZXMnF1TjU3MTVpT0NTWUVJa2RWcTFzVWJkYTAvWFJvWlZJSVJJMS9aVVZVRVNLRXRMMDBmZWVQdUlGejUybWE1UGpDcEg0YklReFhtc3FFZThNY3JDMjk0ZWMrdk9NZGV1VFJtTkMwNVBXbEtNbWhoclFBcC9KaFh3M2w2WmpNdW5pc0o5Y3hoaSs0QjJuVCt3Rzkxa01zakl1NDJQWDk3NGlhMjZlQ2tFTWRZYk0rUWZPT1ZTeGhxb3ZXTmFPYXJhVW8yY0VoWkVBYmMrNkdoanlPTkM1eFJ0MWRKVmIvTVVZYm1LU0JDYVBtbi9MN29KWTB4c2p3bzJKNTdDR2txci9sNkYwNmNyU1REbzRWQVdPVU43cllBN1Z4NW1nMmxsYWJWOVl0WEcvUFZWNU5La3lGQlo5cTdPS0kxUVdsMzhSYVo3Um12VWIxcjBCbFNqdyt4eGxyUy90UG5uc2w3L3YzcW02UmpwZTk5cStONTNWalJ0enhCNmx2TUJZeXRpaklSMndGSXdtUlNNeHpxOXVPaEE2SzBLTjVSMGtzdHNETjBpR1FjS1Nsb29hc2ZtdHNXWGFxaHc5MWJpamU5RVpodVc2ZFFpRVU2c295MGNHKzFBbFM5bCtaRDhRclE4OXhrMDZ6TjNYWEtzaHBpelNBbnAxdnozdFRSTkx0d1crcjVJVnRlN0xGNHhjYjI2YzJuZXc5QVpoa1lJaTRoWkpPd0s2dFBJcFpPQmg1WWRUeTQ2UGpaZnNUVkVkbEpnRkJJTDcxaUtJY3dEcGt0UUtISFZpOUMzaWI1TmlyUm51bXJvaGVWeFF6anRHTHFCWnRsaW5WcFpwUmlvU3M5aUdkallxQmlQUzdwZTlSY3haeEQwUWJCT1FjVWg2TXp0Wks1ampMS3czTHAxbkh0NlZjMmRhVlJGeEZwclFrekwwM243bTIwWG1ueWpEOGFjc1JyazkvdEcvNUFrTlluWXFHSU9kZll4aHJxMGlQVXNPKzNScDdWbnJVb3JLNzNsVjcxdUhrM1EwSDY4eUM3K1E2WkpscVgrR3lFbmRCZ04wWE1DS2FTMXJTWmRUQXdoWXRFeHpra3JSQ2YwS1N2YXJJSjJ4a0ZWYXNzQWxyRE9XQXNxYUltWnM1eFVlNEczaGpacko2MkZZckRNbHozZHFtZGNsRWdReGliaEhYaXJxU1NsRWVvcXFXWHhHZE5Pa0I1OEpUcGV5U1BFWlBYMWxoVzgvZnFTMy9pbEJjTXdwcXhIckU3bWhMNVhweFNnT1IzeHpWODU1czZiUFUrOFVQUGNwM2Z3cGRkUzJPaGkwMzVZNktLbFJBR3J2aFUyS25WVURkMjV5YmpONW96WEhyTE1aaFpmV0xWc1N1QnQ0azVSWW5lbnZIZzBwOHd6YmJwc2xPY014cC9sTG1XZHR0N29pcUtTcGNINWxCZ2dEZG1xMlo3YmJJck5udDlHTi9lSFZuSmNlOUtkaHorc3diMlVHWExScVEyVmFjQTB3c3dHdm5oMFF1OHRKNlhqOWFybW05TUpidzZXZWVtd0dNcnNOSkl5aVNhR1NBcmEwc1Uya05xb0FGeU1wQmhKMGVHdEpWbExqQkZuWWI3c3ViUTNwbWtHZ2xINWFvdzY4cldZREw0SklTWk9UMXZ1SDZ4NCtza2RobjRnaE1Ca01zWjdSOWNOK01KcnpwTVhxdEk5WFpaK2ZKSGxLQ0xXbWpNM0d2bjlMdDNQRHVVK3BOZ09jVG5FTkhobkNtTkV2TGVtZGxhSkNFT2lRZ1VuOWNUU0oySFZDZ0doOEJabmxiMkdOUml2ektFdWEvdVNBZHFVTTdkMHN5Wmc1QjBsaHFiVHZpZUtjTklFdXBRb0txOGJ6RWttZndpRHFMaGx2WmpVRVZIT3RlaWNCMmF0dWQ0ZXNFbGZXNUFFbGFNb0hJdkRPYWVITGROcHBhTzZvTWh1V1NSc2tiK0hRRWtpR2tNd0JwOFJLZXR5YmxpV3BjU3NQbkhXOE03Yng5eTZkVXhScURZYVBKSWl3M0tGTHgzSldmcXU1Kzc3anBQN2M3WjNTNTU0ZGhzVGhTSXI5TTRRVTVQTHgwNklUVUFLVHhjMWNNRWJhSTFCY0F3eE1hdUZyVzFER1BTd001azJHZ2JoZE9hNU42dTVkcmZGejVNZUVtY3VLM3JQbUh6a3k0WGt1clZ6NW5walM4eTM5Z3BNZWQ3NG1iVmd3ZVNFcVBDQWNOUEptUTVCSmJCclFvMmNqV1BXRkZwS0NGWWRaVXdQVzAzZzgyYkJVMGNOM3l0cnZyWXo1WDJ4TkdpcjRLSmdjcnlMNUhVYXVrQ0tDVEV3aEloazlpUUduUGNrR1hBdWNYQzA0dEx1aUtwMFp5UWJ5Y0JjVXZkUVJJUmhDQlNGNWM2OUpTZW5IVmV2Ym5IN3pqRjlOMlNrM2lBU2NDNDdKRG03TmFyOHc5YVlXK2s4WHV6TUpHeXpkcHkwa2YvZHp6NEV3UC82RjIvK3ZwVHVCVkJGa2VyNXk3T245OGJWcDcweFpSYUhtRDZuVjFhRnBkVE1KY1lqUjUrZ1QzcTZGMDV2Ykl6SjhqL3QxU1ZUVVpzbU1aOUhWc3ZJb2syY0xJTDI1UmE2SnRKM1dyYUhUR204Zm5YTTVVc2xWYW5sOFBvMmowUG12aWZWbzhlb3QzZThVQkN0czc1Y1R1Y05TVmkyaWFhUFJCSHMyTk9FeEwyakJhT3RFWnM3WTZ6VFdCakpjOWUxVTBMWEcxYXRaVGtvRXV5OWlqdGNxUlJOMWx4K3B6OTNWVmsrZUcvT2QxNDVvR3NIdkxja2hLRlZNR2R6YjB6SzROaDBObEwvOFhISnBZY202b0dlT1FkRFVrdmx5aW5RMTdSQ21BZkZMVEl5VFE1UlVQczRneldHTkFoRlV0RjhZY0QwZ2gxUUE4ZXJobGhaeWxXaXlxVzFtUE5iK1d6aiszT3A2bm9EU3pSblk3bDEzTklaOHI0RzlaSUtWQWljZzMrY20wNmNlN0hrWXQ3bDc3Mm1MTWVjQkpQYkFKTmZRRUk1OEtNdThVZzM4TVN5WTJjWThNQUt3MnFBdmxlYXRXN3lTRmdOZFBPT0lRcEhoNmYwN1VCZEZYbzV1TFhEVEtRZmhLNkxURWVsNmpFeUNTeWx6QmNKQ1dzTWJkUGlDOC90dXd2YU5uTDU4b3lOYWMxODBlWVp2RDFQOHdUeDN2bmxxdi9nZE42OW5KS2tpM0prWTVCWjdXWFZKLzZETDEybWRKWjNqM3BxWnhsNXk2SlB2eWNiL2FLUlFmbmkxYzFuOTBiVjV4MVVNVUhUUnpQdlFwNXBPekl1bW5ucmVyc1hQaU94M2xBVUJtZVVxREFFUVlMNmVqY3I3Wk5qVXNHQU1zcTA1STlaNTJNejBkczZ3Mk1QVFhqb2FrWG9kVk00WnloS3RTcXFheDNIblpXQVJ2dHA1M1VXdmo1d1VsU0VOb2dDTjEwUWdrQ2JZTkVIanVjcnpLUml0alhXWHQvazE1OXZHMk9nR1N6endkSkgzWVYxS1Rpdml6NWwrYVhOaGdwYWpsb0tZL25lSzBlY3ppUGU2Ly92VmkwcEtzQ1pFbFQxaE5Ga1RNakk3ZFViWXlhekFwZHZrNWc3RVpWOUN6RWtGaWNCYS9XR0R0Rms0dzY5d2RkS1A1UEFKd1dwS3FOZWJxRXgxR09ocUlXdXRqUWpqOGRSU3p3Ymo1bDR3UWwyVFRWZGI5eDEwbUw2c0RXbURMa2t6eHBQeVgxODZ2UFhHakpkdFRBZlVsWVljMkcyZjdFRnlOVWVTWWs5bXBTbmZ6WWhDMW9FeGszaThuemd4ckpuZXhtd01iRkNXUFRxS3RRMVBjdWpubmJaSXpIeWJPSHhGdTUyS3RJWHJIb2hkRW95YU50SVVYaXF1cUJQS3J6cW85QWxCWnBqaUhSRDRQaTA0K2k0WVcrblptdXJwdlJlZVJGdHIrdmZxRU9OYUo5dVY4MndmM0xhL25vL3hIREIreUFaa0M3ejhYLzFuWVg1enIzRzFNNnlHcEt4d0dKWUUzbCtlS1c3UE9CcW1ybyt0a05JWVZSN0VuSUczc1NrQnZsRE1veEdqbDVFUWFyQ1lwTGVxRDdUSlVQdXAyTkd6R1BleE40cnBiRXFMV1ZoV0xhUmxNQlZGaHN0UGtDbHpSSEpRRkdxeGp4WjNmeHIzS0J2RTEydlphNzMybGRhdThhT2REUVRvM0lBaWtMcGsyVnBtWTA4OHo3UXREclhKaG1XcHgyTGs1N2FsU3BhcUxYM3gwQS9tQnduSkJncmpKeWNPYUZhVUU1NGdOZ0x5UmxDWWVrSFlUb2U4ZFJqTS9iM2p6RzJ3RGhoc2xFejIvRGNmdmNrTThHVzdGeTZURjFaanZaYmJyMDk1K3ExS3R0aXJXMlk5QkFNeG1DaTBMU1JQRlhDSHZjVTA0SnlwTHlHWmxCQlNhZ3RlSmpZcEhOK0MvVk1pVVZPdE1ZNnFncE90enpYSlhGcDN1R01FUDBGUXNzRlVzMWFpMDdLS0x2THBYWi9ZY04zblBYS1E2OTRnWGZheHBEMHoyc2lDdXNBeER6SmNJVjg2TGFYc3hsOWJoMWkvblAyeElqSjBJbmFUTlZONHVIUU1pa3N6NHd0NzJCWUlEUXlzS29UczVGbkxQQ1lUUGptdllMdnIxYmMyQzJ4cFhyZnBWaFRPakJpMlp6VkZGWEJha2gwWXRqUG12ZlRObkYvSHBpV2pyZm1QVU1VdHZhbVRMZkd2UC9lTWFVelZLV243L29NVm10RjJIY0R6cG9OWjgwc3p6cXF0ZmVBVWhFa2VXZmt6anlrdTR1QXQwYWNRZHFnN0xraGlmenNJMXY4NG52SFA5UWVmYjNoNDdKUGZUS2tvckxFa1BEb0dHelpERVF2K01JVGdON0F4Q3ROc20rU212aWxqSUIycWlLeXptQ1Y5SUV0b2ZKT0t4dVhYVGZjT1VvdUJvSW9XMjRJMEVYdHBZd2ROTG5ONmh4K0dLRHI4b2dsS2pMcThpRVFnMkR5TVJqaWVieGo2UTFWWVJnS1ErWDE1K2t3eEJUcGpwZXM1ajM5MURPSm9yeHJMTVpxSHo1Q0tEUE9VT1hNTU1sRGV4TVVQVTRyb1V1UU5pQjRRelZ4UFAzY05yLzkxYnNZbWJDM2U0MW1mQXgya1c4dm9WdXVtQitmc0h2NU12T1RucnZ2TGVsZTJxS3NIRzJBMHExUmZTVVc5WVBROVlrb1VKY0dtd3lwU3pSQkQ4SjZaVmd1TFJ0akNHTkRxaHlTTFpWTkZxZVlxQnNsbnNKUUdkNi9OT1owOE53NFdER1N4TkFhVXNONW1JTE53aU4zWmwydnFxMmtpUHk2WWwvZjdFWVVhTVdDalluVWRKcWJ0bFJIMkdtcHIwZENndEpodlNQME9yNDFiajJjMHRlZGN0MHBNVDlYcjB5NE9KeVRXWmE5WmQ1QmJCSjdLMzFPQnlIU0x5UFdKcW9TbGl2aHRjTUZ6MjFXL0k4L01XYTJZekVqcmY2TVViYWp5YVp2S1JOeVFvSlZyMnZ6ZEVqY21TdlI2NVZkNGViaG1OM0xVNXJDTXQ0cStmN2RKWjExRk1ZUXVnRm5MWVd6SkdOTjRlMVY3K3dWNE1RWWFwSHpaa2FFRUZPR1BvVVV0THdYbTkvOXoxK2VHdk5EQU96OEEwWjI2OThuWDVpK3JHeTAzcXF4Z0ZXU2lWSDdFUEJhTXE3VlJYSElOM3R0R2ZyRWFobDFGcHNFWDFtMTk3VzZJWDFoenVzMlovQ2xvMHRSeHp0T0RRQzhDRzJJekJjOUtXbVV6bnFzbC9KTWRUeFdkbFFjTWdjN0krS3NGVktnZm1LWlhqbXVEU0VtVnExaFVqbmFKQXhXa2VWbTFURmY5TXlhaWxFYldhMzB0WXl0WlZvcUNoOFRHa2JvMUk4dUJaUGxscW9JczluaUtFcHVZMnppeVpkMmVQWmJXM3o5MSs4Um01N05TenMwVFdTOFVUR0VTTjhFVGc3dU05M1lvQ3BMVEtrL254R1ZTc1pNYkhIWjViWmRSWlpOcExJR0c0Mldkb1BnU0hTRHp2U0hMdEV1b2FrTXk0bGhaMktaVnJyUktSUkVzeVg0UXN1RzNsdmV2emJpcFBJOGViUmlSM3FHYUpSQmw5RjJIYnZsWldLTkl1Zlpva055ak5OYVNTOUpjRkVQb0lXZEVCNTVrWERsRVpWODd1N3dtKytkOE1yTkZidXppcjNUdHpGRHc1T3p3RjdaRTlPQUcrWkkzMklHTGJGZGFUSFJNc1FhNlMxV291WmJGcm1xaUVLWlMveCtnS0VUdWtYa2VCRTQ2UWNWVEFsME1TRXp3OHdWekt5R2dmaENpQmxISXVTS0pWY1c0bUhicjRGRHkzTlRkZDc1MGF2YmRKbktPMitGazZzemJoNVhmUFZlenl2SFBYZm5QU2R0VDdMT1Rrc3YzcG1IeXNJK2JvMTVsd3VlUHptSTFHV0Qwb3RvUnBMczFSUkVXSVgwUTBYZDEyQ2s2S1FydFJHSk1ZajJsTjZjaVF1c00xUWpUeE1pMFhEV3l4YUZZVHF4TkExMFRjckFtUVdYUGR1Q2xwN0dHOG9pbC9IT1VJOGR6WkQwb1hxTEY1QVlFVW1jem52NkxwQkNZTFdNdURXeUdWVkNhUkpuRXNPaU10aENlMStiYVk0eDZLMCtxblVNdUdqV0xpWktweXk4WVZKVkhKNHVPSnEzVEJZVjQ0bGpQSEc1WEZSc1FXVkhxbjgyZWI3ZDk1cjQ2VDI0S1ZCWjNLQkpKaEt6ZjNqbCtjcWZmcHA2VXZQMTM3ekZ6YmVQbWMxbWpNc3h5N0JRMDhPbTRlVG9rTDFMVjVEb2FCcGh0QUdsVTRVV2tzMHRSVk9hWTByMGZTUU5pVkh0em1iMlJyS3JTaSswUnVoVzBLMHM3ZEt3TWJGc3o4QWJDd25HSkhWWmpTcm5xMHppYUZ6eWN1RjU5R2pGSTZuRmk0S2RralZYV2s2dmt4RFhNM2JGS1l6TlU1WjhUU0VRU2NqR2pNMHYvUmpsczU4bmJWM25WOThML0wzaGtIZkRXelQzUDJEajZtZUp6SGhoMHZFM3ZueVp4Ni9VTEcrOVR6eTRpVCsraXptOXkzQjBrL1o0QWZ0M0dCY0JVNHhKeGltZ24vUVF0d0lqWStpelgwSG9oRDRsbXBSMHBtVXRPMVZCRlJ4djNSWjJGK292YUNmQ2xVdU9lcXJTMnlSS3VpSW9ieUdhZFhyTVdwZ0RiakNNdlJZZTA1SGhXdVY0ZG5QRUYyL1UzRjhtN3MwRFg5L3YrUHJod1B2THhHSklWWWhwWW94Q0pzaVo3Tjd3NFRqbWM4TXZFZU9Na2U4ZE5XZldzajhNcnZ1RHBCbC9lVnBmdTc1UmYyRnM3RTRJZ3ZIV2RDSFNwNFIzRG1jVjNCcU5ISnNURHhxU29EZHJVaTc0bWhlYjFnc2tOMmZXS2l1SnJERVBHSlp0VU5ycGtBZ2hrUXdNTVZGWG51ZWZlWVNkblUyTXNSUjFpUzhjWFJ2cG1wajdPRTM2Y0pseVc5WHFMV2FpUVRMeWEzTC9ib3poNkRod3Noam9oa1MwaG5rL2NPOWtpYWtLcHRNeFZlMHBLMHRkTzZwU2pSSGFxQ21oQmlqelJOVG1mRER2dFgrUHh0QWtvMm1pbVVrNGRJSXJTeDUvZHBjYlQyMVQxNDQzdjN1SDFiSm42QUkyUSt3cEN1VjR4bW9abUd4YWRxK05JRWsyejFUWGxDZ3ExejA2N09sWGdkQkZpdHBuampaSzhrZ0dpVWtKSVgxQ29ub0JkSzNhZHptcnJpaTJGM3dVeEZtc0NHa3UyQWhwWXJsWFY5eTNucXBQVEZ4VTYrWm96blBhc3ZqS1pFZlhNdzY4dTBDWFRlQkt4eWd0Y08rOGpMbjVMZnpCMi96eWEzTis3YlUzS1cvK0V2ZGYvUlcrLzgxZlpldlJwMWpObnVUaEcxZDUvcVhuS0s0L1FmM0VpMVRQL1FqRngzOGM4OHlQSWgvL011bVp6OUJNOWpnK1BpS2RIbEs3Z241UVFsQWY0R1FRZWxHZSs3S1BuQXlEcmxkcnFhemwrNnNsTzVYakN6czF2UlhhQlAvczVwSy8vL294Ym1uWTdBcE1iNm05VlZEVlFYTHJRWVE1ODZVLzI0N21YRFVuU1Rram02WGoydFR4aVdzVlgzeG94Q2QzQ3o1enVlU0wxMnI3K0t4c2d0QmQzU2o4VnUxTTZVemNHWHMyS2hldVRIMm92VTN6UHExSGIyS055cXY3SHdJYTkxRTl1Z0N5NkVMVDluRVZDc0U0WXlRbmE4UWtyTHFBc3hDdFllZ2pCRUdpMEFYQkdKMmpqOGVXcG9WVkU1VlhLNUxmbElRMWpwaDdjaXN3clIxSFRzUHpVdVdWYklQUURJN2o1Y0RCMFRHYjB5blRXYUtxYWx4aDJkMnJhSTRYR0dQcGVrTklscUlzSWZXSUcwZ3hZVnlrTEpUSkZxSmFGNDNIbHJMVW04L2t1VHBpQ0NHeVdqWXNseDFkVTJVN29uV2xLamlqSXBDc2VNeHh3RHBuVDBuZGJyc1dGbk8xbkI1dE9yeFhtbXlJQ2V2aCt1UGIxTk9LYjMxMW4wVVQ4Q0k4LzVucmJPd2EvdVUvZWw4UHVSaVluNnd3c3FYVHBhampIZWNNZlNjVWxjTVdobTZlR0h1ZGFCaXJETDJRRXdoOGR2SlpqeDZ0VVd1dG9WY2poYzJwSmMwY3dlaHRYQXphMS9xcEVHUEVpdUZrcCtTM25PZlJlY1BqZmNmRVIrTEtLR1BPNXhpWjN1aHB2MDVaT0VQbzEwRU5RZ29XNHdUendadkVkOS9nejVsL3lnc05mTzNvZ0crWnlEKzdlWlAzZnVQdllmN2tDN3g2Ty9CVGk1YU5TWW5ZQ210cVNGUGNkQmNmb0huMEU1dysvVk0wTDd6TmIvOVgvMmNlZnUxWGVXUldZTDJIWFBFTWVSMmVFYWZVUGdnYkkxODdQdUdyN1RGN0d6ZjR5aU1UK2dLK1hJeFozT3o1MzM3MUZxVllmbnh2Z3grNU51R3h2WUlyVThkazVyQ0ZFRW9CbjZ1YjlZYlA1cFhpemt2aGRVNm5FZGd0REZjdWxVWVNMajB5L3BIKzJhMFhUcnQ0T0NBbmZTdkhiWko3R0ZrY0xlT2JRMkR4eGtILy9mL3dGOS85clNEU3JyL0YrcTM5UGJ2UnQrdHkrMk9YcGoreU9TMXZSSFNtUFNRbHR4aWJMWVdzb2E0Y3RiTzBiYUpiSklZbTBiYjY0M3FucFh1Zk5lZVNCRnM0akxkclZ5bTgxUkpxdmt3a0VhWEtadHFVV01OaU1iQTlnYjB0eC9GaHkyclIwalo5SGowNWZPbloySjB5bXBaczdteXpmWG1YOFd5VHlXeEdOUjFSakR5ajJaaHk0a2xvYjljRk9GbEcrcEFZa25EVWROdzVYdENrUkRXcXFFY1Y1Y2hUajUzS1hVc2R0eFZPS0l1MVdrMUhlZDRKTVJrV3ZlV2t0U3c3aTNFR1gyYXFaOUN4bUJoREw0YmxvdWZydi93dVFReWJPNWNaMm9MWnJzVUN5eE1EVG5qNDhZcUhIOXRVNXRsNmFwVXB4Y2taNXZkYlZzdWdQSVZ4b1N5L3pGUlZZa2ZlWkVuRkdVWGxza2hINkR0OURzNFkyazRORjdXTlVURFBsWW9IMkNTSU14ek5LZzVIQmNFYU5tTFV0dW84d3pnem9CUnJXVk5jVFR3WEZKSFRiY21qMWtJQzE4dklTM3NWZi9UR2lKOStaTWFOT3ZMVUJqeDd0ZWJKUnk5VEZtcy9Wdld0U3pFU2hrRG9vK0lGbzIxNC9QTjgvVGh5OE1HN2JLYVdvdkQ1YzZFTlFodlVmekNLNEkxaEVTTmZuODk1TDdWOHAyMlpsWjZQNzFYczFvWVhaeE9lbkkxNTlYakYzMy9yZ0wvenhnRy91ci9remZ1UmswT1lud3JqYUtrR3BXN2IwdndncXJYZVFXc0FNNDhHVXdZVVU4UzVhRWJqd201dlROM1Y3WWw3OUZKVlBMZm5peGN2cGZKemsyWDFoZFdwT1g3bFlQVzF1OTNRV1IzRnB4K1dhUDNpUnM5MEQxV3hlV3ZITDE3ZmZHbWo5aytIcUF2R1dzTWdRdE5wOG9UMUZ1TU5OWVorbFJpNmxEWExTakdObVdGVWpYVE9iZ3RMVWFsSXBhNGNQa2ZpdXRMU0RZblRaY2haMk5tRlU0UzJDMHpyZ2tldjFqVEx5UHcwTWo4TjdCOTJIQjRQM0R2b3VIZDNRYk5za05TUllrL29lMkljc0M2cFpWWHBLS3lqbm81d1RqZzU3am1hQjVwZUhXaVBtNTc3aTRaVkZDYlRtdW5HbUxMMldHZnhwYVdxbkJKL3hPaDRxdEIxVzJRTmVqc1k1bzFsMGF0UllWa3FEdEFOZWhoWVoralIrWHpYSjc3MWF6ZHg0eTAydDNaSlljQlhQYzQ2aG1hazBsby9jT242RkZlNHMwWXVSYTJtckxNc2p4cm14ejF1V3BHQ2drcXVkR2ZvdklZTjVFQ0VyT3p5emhDRENqN1NJSFE5ekJzOXBHSXlpb3FMdWFDNFVQMkFRK2dMeTcyNjVsNWRZcEpRaDBTUkVYZldubW5ySHYwQ0djWm1ISVk4Z2xTd1RuR045ZWp1MnNqem1TM2hwZjc3UExyL0wzRTN2d1ZIdDBoSE40a2tCbC9SUjFIbjErVG9Bc3hYUGVId0F6WkhpV3JZSjk2L3hkaXAxMXNRb1IyRVJSOXBvdmJjR01OaUNIeXZuV05xWmRMOSttRkRMNWJuZGlvMlI4SkQwNElmdjdURnBiTGtyWk9PMTQ4YnZoOEQzMG53Mzd4N3hHL2U2L2pPT3cxSCt3UDl5aUFMdFNZejd0eTlVd050T2ZQSE8rdnQ1U3pYWFVnbTlTMWhmbUQ2dzlzeS8rNDcvZmYrbjYrYy9yMS85TTdwZi9wMzN0bi94VmRPVnlkUkZBMnhabTJZOWNPZG82K0RUeElneDAyLzZsTTZEdW1jK1ZnNFN3cUpyZy9ZMG1PeFd1TGFoRW5DNEZTS09wMDU2a0tqZll3MStOb3dSSWZMbTMvVlJMMlI4b2pOQzlTVlZRdWhvTnJoc0E0TjhKYjlrNTdqbzVZaEdCYTVXdWdISWFXVVN5WjE1anhaTEJtUFZtek1DcXF4dzVwRXR3ekVUcWdLU3dncG13NHFHU1lseWJUSXBFU1pxSUtJSVNUNlFYdGJaMVJ6Ym8xV00xRzBYNVZrR0dMQ09YTHZySUVFNi9IVGVrTU5EZ1pqV1NRTjFTNUhKUzkrK1VuZStHYWdjSTV1Q0x6eWErOWpyZVhTMVVkd3h2RzlsdzlwVi9DVFAvc3d1M3NWSmx2UURrbG9sNEZxVnBIQ25IWklWTmF3bWdjb3JCTFp6aFJkT3RwVUc2YUVpTVhucEpRV3c5QWtIZTkxUWxNYVJnV1VJMHZiV2thVm9hNmdySFcwV0loUU9tZzJQSzlPTi9oZ1ByQjNyMk0wUkhiYlFKWFVGdG1FZk5zYjlXRWowMGpQVFNreml5NmVJL1JEcDNNbDR3MTJQaWQ4NDljSTMvNHRUT1d3a3hxNThVbmk3QXBwZkltMDlTZ21KV1ozMytMeTY3K0VPNzJIYVh0V1d4VnRudWVQQzhPcU1Jd0xwNzREb25uR0NhR3VQVEx5Rk5iU3g4ai85YTBqUGxnRi9zWXpXenk3VmJCbjRLOTlmSmZQWFozeEQ5NCs1cGZ2bi9EOTl3Nlpyd0t2dWpreUpNYUY0NkZyRTU0YUYvekl6Z2E3NDVJclk4L1Z5bENWaHMzU1VoWDZQaTlYd3JJVlRFalNpaXhqei8zYkorSDI5L2U3OTQvYThNSGJUZlBLOXhlclYrNjAvZTB1eWJLSmFqRDlVZlB1SHpicWZxWmw2bUphbkxUaFRqdUtRMkVvVXhUNmtPamJpSWpRRFJIYlc1QkFxQnoxeURIMmh1bk1NWms0SElZb09rTlBTUkg1RUhJT211aE4xd2VsTlpxZ0JJUEtxZUZrMTJzWlh4U09Lc2NrTDVZcWJZMUdOeEZXRHg0NEgvRjFRNklQc0Z3RXhtUFA1a1pCYW9WK21lZ2thc3VSQlJsclM5K2hpd3A2bWV3dUcxUUFvU1lRdWNkTE9rcTBGbUttYTZZSVEzSjZ3QVhMS2hxV1BmUlJNRm15V0dRY280bW9uanEzUGx0WDloaFZwNlNZR0tLS0lnakMvZHNmZ0ZYeDBQSGhRTHNNdUsyQ0ptWnpEbVBwaG9oempxRWZvQW1VV3pVR3E0YVltWUtjQmoyb1FrZ01VU2lpVXhaZW9VWVBFWVBOWU4wd0NFMXBHWmVHY1VnTUFmcGFKd3BsTUl4R3VYSXhDU3Rhc1N4M0N1NU1TbVFKczJYZzRaT1c2NnVPY1JhSVhBVG0xdHlJaXd4WkVZTjBPaG96cGZhTE9DR0tSM3dCSkZJanVHNkp2ZmZQc0hHZ3BNU1BOdlFrNjFkSU5QVGlpY0Zna3pyRTV0QVlKb1VsakxKclZpdWNoRWdTWVR3ZDRVY2xpRkRFU052My9JT2J4N3c5Yi9tZlByWExsNitOcWNlUjU2OTVib3d2ODdNbjIvempEdzc0QjI4ZjhPYThvNGtKUDNOZ2hXOGNuZkRkZm1Cek5tRnpWTEZWZW13UU5sTmlhaTNlT2s2WEhTM0kvdDBUT1I3U0c2Zkw0Zi8rd2FwN2M1WFN2U1J5TENKdFV0UTltZk5SOTBWMUFJWFJuNjM5LzlKUDBuMkVPZVJaS3Nram0rUEh0NnZpcFFJN0ZwM3NzK2dHbXFBM3RjdnNzNzFaeWQ1T3lkYUdaelJ5T0dNb25Ea3I1WUtvWExXMGhxYlJSV2lza21HTUpVdFFEVjBYejhMdCs2Qjg5NWhuOUxXeHpDYWVFUEp0dmtaQ2xWMTB4cWtNU1JpeWkwelhxOUgra0lUVFFXaENvb25DY1pzNFB1NVpyZ2E2SVRJZ0hLeGFEcnRJTlM2WWJZNlpUQ3NOa0hCVzlmYUZlcHVGdkdwVG5oNE0wWExjV0k0YXkya2pMSHQxelZtYkZxU2tsTnVZdEMrYXp5UGYrYTJHc05CcFN0TXQ2ZHFHMkErRVlTQ2xpSy9IUFB6RUxrODhNNk1vSGFzZTJnRzZCTTBxRWhjRFRZaWNublFVWlpGeER4MU4ydXh2MTNlQlp0NnhPRzBaSXBqQ3FmdktPcXJZS0lLL2pxMUtXUml3YWhKTm8xZC95Qk1FZzFaQm9IMm5SK1d3NGcyTDJuR3pyTGhUbDl6M0JZdVVTL25DWkxtV25MblRyTmwyYTRkZXlUZTlaQi9CbE9tQTYxWkZwYmtseVk1VkE5d1BwRDZTcENRa3J5RU4yUE5JcHdzVGdUVWJyd25DS2thT2hwNzd0YVdZVmpobnNVNXhDeHNUSDZ3NmZuTi9TVDhZSHA5V2JFOE0xaVVtMXZQQzVvd2Z1VHpEQUtzWVNiVldJTkpGU2dPVjl4U0ZnOXF6Y1BCQjIvUCtFTGlaSXJmaXdKM1E4ZDM3cDJZL3BPV2RWZmNQVjBNOFNDS0R5YTVYRjV4bmhnYzg0Sk9JeUkxUnpWNVpjcjhmZms5dTlBaUV3MlYvcTl1TSsyUGpkbzBnM2hqanZVTkNvb3VST3FuSVliR01qTndBbXdXMXRWUk95OVoyZ0dBVWtXK2F4R0dYYUR2ZDVKWFgyM2hVT3VveUMyQzgrbVZYaGFXT2ppRWxyUGQwZmVUZTBVQlphdCtjOG9McjRjeEJwZ3VKRU5PWmgwTEtldUlpTzlaMk1XbWdZMHhxS2hDMCszWEdaaFRTSWtFeGdTRWtocVNnVGpOQUg3U1BqVGt0aEF3ME9pL0tnVzloMFlpS2E0YUU5enAzNm9LeXVGUStxcXlJRDk1cVdSd09GTTdRdHdQTjZTSlRRL1hOTDBZanh0TVprODBLWXcyTE5yRktGMXpkdmJaUE83c1Q3dDY2VGJlcTFFYkxhWjhzUmpkZ09TN29GaDM3SHh5UUVseDZlSWZ0SzFOR2RVa3dpU0pyQ1lxMTZHVVFqSTJZS0N5eVRmS3NkeFNWSWZhT09JYTZ6a3BCcStORWh6RHgwRTRNSjNYQjNiMEsraEc3WFdDN2k0eFBBdHZMZ2UwK1VGdWwzZGFTOENpb2FLdHpObDI2NE04bVNSMWlTUnJ0WlFpNitsUDIrMDZKRkpUZkg3UC93Wm05bFZIeGt4akZlTENveE5RWWRmZXBDZ1ZraDZDSFFVYktEN3FlLy8zM2IvSHR3eVYvN1prZGZ1U2hNWmRxWVgrZWVMd1k4UitQSCtaUG5LejQ1YU5qZnUzZUtiZERZdDROdUw2bkdrcW1VUmhqOEVXaFZTSGdyU09hWkVycmlHSzJlbXZxUVo5a1NEQVlaVFdmWmUxZHlHdzdxOWdyWnhsNzkzc3lYbHN2cS9UKzhlck94eS9ORGpkS3dSdGpyRkdBeGx0bG1GbWpDM2paUnphVDEveTB6ckJNNnZZU3JYckJTUlNhVmNRa0tDc2R2eFZHUlNkcmJ5N2pMTmJyQmsxWjhPS2NwVWs2VTI5ajR1QjBPS3NINDdxUHp1Vm15SDFZekNPbTllalJPVTJKRVpNbkI5bW9QeHJCSlYwTVZtQ2o4TlRXMFBlUkVOVm1DR3NvUmhaYkdycGt6anptTlJWVTU5cHRVTFljZVFFckVxL3FxeVNhVmlKSk1OWnllakp3ODkyQVN3cFdEVU5MYkJZUUJoM2RPVU5SMWJqQzR5c1ZCNFdVM1h3dXhFcGJhNmlzWTNPclpuNjBwSnBXT3RXd2hvaGtFcEpuOTZFWmNlaDU3OVZidlBYTjk5aCtlSWNiVDE1bU5DN29FVnpsS0REVVJ2M0loNVZrempjY3JoSmRFR1lUQlFURFlCbTFtYWVReTNrUms1VjhNTFdKeWdoc0dJSXJ1UlVOaTVuUUw0WE5WZUJTREpRSWUyM1AzakpROVlsU0VxVVRYQlk4dWV4Q0l5R2JpK1JLU0wza3NxYzdPV0JSZERRWVJJTWdOSE05eTArek41NVNyRE80V3p0RzB3cXB2Rm8rOVphMnlWOHZKb29oMEE0OWYvL2RmYjU5WjhsZmZtYVBQL3ZpSm85ZExsaWVKdllQNGRQRmpFOXRUL2pLOWdiLy9ONEpYenR0T080SEZxdVc1Q3pqdXRCSXAreFM2NXlCcE92WWlCUkc0dy9TeFkrOHVjT0ZrTS96RHdQakNpWUZ2emNiUFhPZjVJUFQ1cWdKOFhaRVltbXR5L3BhaXJ3SkJTM05COGxhOU95R2VieU14S2lzTTFkWXJGUGpDcGVVdldaWW14S3FGNWpyRXFVeEZGNk4vWXhBN2ZYMERrSEZFc01RbVovMmVLZEladWdUUTB5MFhTQ0tVSldPcXZJTVNlMm9VbFEzSEQxeGROY1BNYkZxQXZPdTU3VFRzdDJzRzBtRW5kSnlsUFJXRHlFcFM2KzA0QlVweG1RT3ZESDBRUzJOK2tIVmM0VXpoS3g4cys1ODlobEV4VFRXR2Q1Nm8rWGVCMHNteHBPTWtGTFBqZWN1TTlrb3VQdmVNUWQzRzN4WjVSbTB1dTJhVFBKSm9yUGhKRURsS2IzbFVoSSt1SHRNdlRPbHJEejlhc0FYbG8zdEdveWxxRDFQdm5pTngyOXM4UDJYYi9IcTl3NllINjI0OGJFcmJGM2V3Q2ZvUlJoTTltRy82S2lUWUQ1QXYwcjBBbTBoekZjNlpoeFBMRldsRVVqaXlTS1hmQTFGS0laRWFjR1hjTnpDZk50eldwWVlaM0FpYkN3RHN6YmdnMUNHeEhRWnFMckVDTUUzU2RtVEFkSmNjQ0w0SUZSbGprZU9RcGQ5QkgzSThtT2pnS0hONWh0cDdSdm9RRXJEVVdYWUh4VnM3bzVwUTFJang4S2UyVStQUm1yN0ZVSmc1QlBmUDFueG4vekdUWDdqem9KLzUxTTcvTmpERXg2NTRUaFpCbEpqK1BMR2pDOWRuZkRLU2N2WGpwYnNSOE1kRFBkRFlqREt5bXh6cU9jUWhFYWdLcDN2azFRQ0s2QUJHdEZmTDRacnBnc01WUUFtdFdXanNqOTBNQzVkc0FCSXdPcW9IZDY4TXBQVENyYWRNVEtxbkpuM0F6RXArRk1XN2t6azROYnBLU0w0c2ROTW9TQ1VSZzBHWWxRZjk2SXcrY1RXemRqTWhhclhHOWQ3cGZON1p4RWpqQXRMNHkycGpZUVlFV2ZWdFRUdkpKL0hTczViN1ROenJ0dVFvR3NIRmsydmxVWWZPVzBIVmlHeEhBTE5vSE4wMVArZndpbm80UXFoajVFdUNxc2hzVmdsaXRKU281NTNOaG9Lcnd1c0MzcFFEVUhuM0FESlFoc3kydXkweEIxNXJTOFg3eDRSN3Q1aTdqd1VZL3JRVThTU2g2NWRSYVJpdnRqSEZTVlZYVktOUENGcDFVSDZjUDV1TEoxdW1DNWlUNVljM2psaTk2SGQ3SWt1aEpBSVVSMVZleEYyOXFaODRjdVBNOXZiNGRWdkhQRGFWOS9sOHVOYlhIN3NLdFhZRTF5MjRyN2d0VzVzTmlLUGhxR0JVUnZ4VGxtQzVjcHFBTWRJcUVlV29sakxnc0dYV2F5Q1lUSXhUS3RFd0xBUVF6dG90dmt3OGV4VDZHMmNEQzRtWWcrbUUxeWp4bzQwRVpwRTJVYmMzWVlZaGMwaytFbUpyejFEbjNBUmJCOEpEc1pSWi8vT1FLZ3NxeUM4MjNvT0RMeDFLQnoyUFUrT0Myd2ZsZWRRR0ZLczhpZ3lNUnJWaERBd2hFamhoYWFQL1AzdkhmS3RPMHQrNW9sTmZ2N2pXL3pvdzJOR0c0WitTTGdPdmpBYjhkTGxta1V2SEEvQ20zM2dka2dNd08wK2NqSWttZzcyaGhHanl2cnRTOVVubjlncTJCNzUvdG5MdFh0c3R5cDJScTRxS3plK3RRenYvK0xMeDcvNEgvMmo5MjVmSk9DbGxGVit2d2VvdTJpQURpTFEzRjUwN3p5NWwwNEV0cTAzak5Dak8xZklaNmRpSElRMDZDeTk5S3I4V2JZQkdZUytWSkRJWkJiL2tQdXBGSVYrME53MThuaHI2Sk5xenIwOW94Z1dHSkxWOFZ0Q1M3dDJpQ1FFNnhXcGIvdEF1eHhZTkFQTFBySm9lMDZXUFNmdFFKZlI1ejdKMlFsMjVxQXZDZ29TRXg0WVZZazRSUG9RYWRySWZCa3gzakt6aHFuWG9JWTI2NzY3WHZ2eXhVcmxzajR6RVVMVXpYNjVpbng1YThVVkgyRXAvTWluSS9zM0pod3RoTHV0NWM1cXhQYytXUEhleTBlY0xCc0tYMUk0SFExT3RncDZBUmZWRVRka2JYckt0M3lLQnFrTEprUGc3Z2YzcVNjMTA1MHBwdmFFeUpsWG54akRjWitZR2N2VEwreXdlL2thYjcweTU0M1h2OGZCN1RlNTl2UWVPMWUyS0Vxdkk2K29TT3laQnQ0YWVtdHBveWF2RkFaOEVPeVFzQjJVeTZTZWdkbEJ0NnFWb3graTNyUjFyVUVLWHFCME9SSTI1VG1nQVNrZ0ZJWTd4d09IeDVIWlRvSDFqdE1VV2ZXQzN5bXcyNTdWeVVCN3Q4VTdtTzJVelBacXJBZHBOWlpMdWdRaFVxekRGa1ZkZjVlRDRLWU8vOTRKenNIbVJxVVlURWpFV3VpSFNOY1BlTzhZajBjTUlkSjJuVlp2QnQ0Njd2aFB2NzdQcjc4LzU0ODl2Y2tmZjNLVHoxNGRNOXRTbjNxekVzb0FsNzNsS1ZQU2k3b2d0U2tSZ3M3MVQ4MEcxcHRpYXZtVFB2RkhZNUxZUmdtbnAvSDA1djV3ZTFUNzFaMW02Tis4MzFVZnRuWXpZbjVJVHBLL1U0OGVNU1lpRWc3YWZqOGtPWmFzNnZGT0paNXRIMVIrbWgxaVQ1dEJhWFZlYlppR1BwRUdPWXMyVmlOSGFQckEwQVp5NnBhaTYxR2RheGFMSGtrcEd6aTRNeFRab3ZMQUFTMW5CVmhKb2cyUllSVnBoOER4cXVkZzNuTGNCYnFRbEJXVmd3WGtJMGhNNXB5dXpFWFRrMkVRNGhDMTl4OFNiUzhVdlZDdk4wLzJuYjhZeFh6YUpIV0JLUzFybVhhSXdvdDF3MC9NVm96NmhKU0dUNzFRTVF3alRockxZV081MzhBSHh4dTgvSDdITDM2ejRidkhMU0Y2SnBzK0M0WFUrR0RreVpIVGEwNi92bm83S2Rrc0hQZFBWeHk5ZngvbkhjYU9jNWlBRU1UbFRXc2hDa1VJVExmZ0UxKzR3Wk5QdnNEWHZ2cGJ2UEhicjdKMStaQXJqKzZ4c1QxaEdCVm5tZlRXVzF4S2xKVmhNSllCd1NhaE1JSWZ3UGVSMVJDeGhhVWNlVVpqUzdIU0RENkpZQTRUbzZsVmdveFRiejFWSDRMeE9ybEplZG5OUEJRampaTXFLdGpZY3pSVGkvVVdXM3RpR3JGOGZFelhKdFVIakN5MnREQlc5NXhoU01UQmtZSytSak5FeXV3ZTNGZWVZNk9tcEpkMktvNU9lbWloS2gxMTZlaEtmNGJ0VE1ZanVqNWtLK2Z6Sk5wWDlodmVPTzM0cCsrYzhxWExVMzdpeHBUcld5WFA3bFRzZWNlUXMrSEhtUjg5RFk0bXFZbG9NSEJ2TWZET0tzeERrOTVZaFhoM0ZlU040MVY0N1Z1MzJ2ZWFZSTYvczc4NmZYUFJuT1FqTUN0RHRGWDdZUnBQUElpNnIyMyt5M3Z6OXZhcWoyK0ZTbDZVSkM1WnFBcUhIeUpEMU5CNXNjS2lGV3ByNlVyTFdseHJDMHRSNkluZTlwRlZwMHkwRU5SSXNjODFpUXc2bHcrU01uakNtVjkyekpHMmdvSlJTWVJsSDFqMkE1VlhjSEJqVXJJSVVSZWphSjljRlphNVJEVzcrSWlTeGZEaHYwOFhhcVd1SDJqN1NEc0l0b3V3MG1pb3BsUG5FQ1BDY2hYUGFLbEQxTGFqTnlxa0NjQ1dUVHcvN1JsNVlXaXRSZ2NCUTV2b2VoMUI3cFdHemIyYUd4c2x6Kzk0L3ZFcisvekttNmNVbzVLeWNtZmpweTZ1VldSeTd2cGlEWDVhVVpZRmsxWEx5ZDBURHB6RHNnZHBSQWlPSWdvaE9VMFVMWldESUUyUE16Zlp1ekhpNXg3Nk03eiszUmY1MnRkK2llLys1bHZNdGl0MnJteXlmVzJIZWxvcDI4NGFxcWdpcE1JWlRCSjhkcjh0bk1FNGg2d0N0azIwd2VNTC9UeWZTLzgycWRoSU1uM01XNVU2bjNuRnFmZ2E0d3ZHbTBvU0QxR25DTVhZbkswUFl5MlRTVW5oVmZwMTlQNlN4YjBWMDkwUmswc2p2UkFHSWZZS3BKcVFBeDJHQkVNazlKb0ZNQmxYekpjQlRLUXNMWFh0NllhU0ZGV2xXZGNWRzlQQU1LeVl4Nml1Ty9sMWRrUGkrOGNyM2psdStJZHZITE5WTzE2OE11S2xxMU1LOUpsS0psQjQ2emhKY05vTXZIYThrdE91ajdlT21wZFBqc04vZG52VkgwVzRENXprZnIyL3NBUS9kQytOQy9ORDc5RXYvcGRFQ0FaWTlmSDRZTlc5ZldWU3JaeTFHd0JGVXJBbXBLampzc3FxcTJZaVI5UmtuMEVUYVp0QVAwUXR0UVZLcjFGT1E0aDB2ZnFacjBQbFM2ZDlwU2FnYXI4VVUyTFpEVFJ0MEdnZzd4aFBTajcreURaN214WGowaE1GZHU0dXVEb2JjYlRxdVgyOFJHTGd0SWM3eTBnZnp6Mnp6QVB2cG4yQWZSU1QwSFFEeTZabjBnV0s0T243UkxQS1ZzSnBuYjJkalFOVFRnNTE1bXlVMW9ubHltemd5aWc3Mk1Uc3BocVZYQk4wN2VtTVB3Z3BXbTVjbXZBWHZsRHl1U2NiM3B4Tk9CMFhaOHkvTHVSeFlkWUNySW14THFrUlIrVXNtMUc0Kzk0aEdNUE9qVjNLY1VVVk5iZGMwMDJVY3V5TXhRK0Iyd2ZmWTJONnpBdWYrU1JQZnV3NXZ2T3RyL0xHNjkvazl1djczSHpyZ0szTFV6WXViekxlSEZPTks4clNVWTkwSXpzUnZHZ0o3b3g2cjNrVXhuVzlNR1J6Q0djTjlCSHBJNjZ3K05yaGlzd2N2T0FobDNLTG9iZVhIcHJpek5rQm55S0lVVHduNVRDRmtDdzluc043SFozMStNcERIMGdaekNVSXBnMllQdEl0ZXVZbks3cHVqUFVsM2pXYUNXZ05aV0dwUzhjd09JYkJrcHlqcm10bTAwQUlMYXU1bk50a1plTks4ZkRCb3VlOUJieDIydkpieHkzVGNZa1ZOVW54WlVGWmVsemhtYTg2Vm4zRXhNRWN0SDExcHduSFFMdFdBbHlJS1EvbjlwajZQaFRXY05wSHVUNHRmbS9IYStpMEp0eGI5Vzg5YXpsMGhkMndCc2JlNFVSSFhyVlhpV3JNZVZaS2RoR1NDTTBReitmYmE4bGwzdFVwSkh3VUxjdEZHTnJBMEFlNkVGbjFBMTAvc0JvaXgyMWcza2NXTWJFN0tmbUxYM3FDeXpzanVwaFl0b0h2M1R6bDdmMDU5dzVXTE5wQWw0UW1SQ3hDWllWTm84ZG15ai9zZXFPN0M2RWpGNVNWaWtTR3hOQU50S3VCMGNnVG5XRUFPbnNlMldQUHhud1pDUmVEU1liQkdMd1RuaHdQN0pSUk9lZFpiUnlqcHIxRXlSVGFvTytIRVcxaEt1OTQ0ZktVOGpUeThzR0tabnRFU2pveWxKZ25MbW05K0JQRllxQzBpbVZNQ3NPa0MreS9mWjhra2ExcnV4QnJrQUxKWDhObEVLOFNpKzBEUnljM2FZWTVXeHZQOEtXZitnby8rbU4vaExmZS9CN2ZlZlhydlAzTzk3bjM3bnVVWTBlMVdUSGJuTEM1UFdXNk05WFJwemVVa3dKdkxkWUlwYmQwM2RxTVV2RGU2b2d3Q21FVmtGNG9Od3FLa2VyOG96Rm5nWnNpY3RabXJiMy9jZWRiUVRuNzlrTm1sR0toM2hzaFNYR1NadFVwNVRmcXVKU1lzTTFBbUhjY243UTBpNDV2ZlBNV1R6MjJRMVZibG8xKy9iSjBWRldpSHp6RG9MbHNSZktNNnBvd0RRekRRTjl3NWl6YjlWcWlGM3F1MEFkaDBRYnFjYUVnZElyNFpJblJVanZOV0s4S0swVlpjT3hjN1V4VUpnd2ZNcHQ0Y0x5VzFxcTdyOTVaOHN4Ty9YdHlvNS8zNmNJQWxHL2VYN3oxcGNkMjdvbmhNV09ockIxVjQ1aXZBcjBraW1Sb1UrU2tDU3J5Nk9NWjlmR3NURFlxQlIzeTZVMk9MMnE3Z2RXeVk3SHFXUFFEaXo1dzFBYVdnekNJNm91emZSaGhOZkRQWDkrbnNIRG51R1hSQmxhOWpzS0lpVE9Mczl5QXI3S3Q3VGpIV2NvRi84SDFXbEtMajNNSGdDZ1FRcVJ0TzFhTGpycDJTaDhjc3ZsR2pwcUtuR2RvdTF6U3BpUzAwYkJWSmg0ZEJ5b2d0R3U5c21FMUdKYkowWWRza0JEMXR2SUdLcVAwMlNFSXpYRkhIeUJ0MWpsYVNvazRoY3NwcEpseEVZSGErNHczQ0h0anl6QVAzSC9ua0JnaThlb09JWTRweGlWZTFCcmFXa3RuaGRKWlJpS2t4WnhtOVRWT1IrOXpiZTlUUFArSlQvUGt4NTduNlBBZXQ5NS9tL2ZlZTRzUGJyM0gvdXYzdUJYdVU4OHM0NDJLOFd6Q2RHdENOYXZ4bGFmTzdVYmhMWVUzK0NDNGtDZ2MrTXFUYktJZm9EQXBUenp6ZENEa1ZGMVpNKy8wZlRTNXVyTVdYR0V4VnEvVlpOYmNpeHl4TEpEaU9sRTNWeThoWXZwSVhQU3NUbGEwcTU3UUI5NjdOZWUzWDM2ZkY1NjlvdGhTRWdwbnFTdEgzM3U2M3VlMElLRXFTK0tvWnRFbGhpNW1nOHJNb0E3cXZhZmNmcFZpaHlFcW9Vc1pPcVFRU1BuMUxacUJXUTdid0p4dDZvc2ZTWlZxSWlMbkJlYjY5My83MVlQZmt4djliTE5uVis1NGY5VWRka2x1aDVpaU05Wmh6Wm1Vc0FzUjhRNkRZZDROOUVGZFlDcW5QNVhlSnBuT21sRUZ5YWYxc3VrNU9tbTRkOUp3MUEyc1lvNVR2cUNEdUFpaURTSHhtMjhmYUsyVHYxYUJ3WEdlS3VUUEFWMDkyUzg0Q2N1SGVoUGQxSVkxd2VIOGg0NTlJTFE5UTlPem11dlAxdmZLZUxQWlNzdHFHcUxtZk9mMEVSWER3R09ia1VjM2doNTJPY29wT2JWdUhvSnlBMUpVUjFvRG1LalZUVEtHUlJjNDdpT3hkSmtLbW0rcFRBUUpTY2tZSnM5ZE5xY2o3TUV4U1pRb2MzWHF1RG1QM0gvM2lMNFBiRjdlWnJJOW94U1VLaXNCNXkyeDFMQ0xXcUFjQWllcjl6azl2c3ZPN3VOYzIzMlJLMWNmNXZxMXgvamNqM3lab2UrNGVmTmR2djN0cjNOdi96M204eVB1dlhIRXJYQ0VMWVRSbHFPZWpSaE5hc2F6RVdWVlVGYkYyZVl2eTR6Vk9LREpHenNwaGhORTZjNHBLS0hLcmwwY2JNTHBtNHRMK3ZPZlBiOU1naUpYTmpMb1ZDVU9DYnBBYkFkQ016RE1HL3FWMm11M3E0RzJDWHo3bFgwKzl2UWxpa0wxL2NxQnNGU0ZwZktPNENMQldncnZxT3FhNlRRUSs1WjJJV2RVM1RDQXE5UVhMMFJWYzg0WFBWdWI2b3ZvVk9ORFRJa1lOUG5GV295M3RuYldtQmpsd1pzOGlrajZDSlBXMzlNQUIzbUF2U01pTk84Y3I3NTJkWFAweFNySlpaSlFHVU5kT0lZaHNzNU5HR0k2QTR5VThxTWU3VEZCSHlPcnJsY0ZWb3ljcmpydUxYVVUxcTNsaEIrQkRKb0xFUmVhQ1NnZmVoZHM3dmZpaGMrL2lLby9pREplUk5uTmhiOUxhLzlkcHd0TmhpRkgrS2lSWlZVVmVtTlZCbC9ZYk8rak4xQVF0ZVVkSWt4OTRqT1hBMWZHUXVveVU2dUUyR25PdXljaG9veTNsRjFSQTRZK3Y0ZHRtemlLUXA5M3RRMzVQVVdSYkRtemVURlFGMVNsd3psTHloaUlkNGE5aVdPWVIwNXZ6aG02Z1c3Vk1tMDNLR2RqZk9XSXdaS2lwYzlBWHkwSkg0VENkTnorNEZYdUg3M0wzdmFqWE41NmxvM1JOY3F5NHJublA4VW5QL1Y1am84UGVmK0R0K2liQm9QbjdiZS94MXR2djBwb2VrN3ZMN2pkSG9JSkZDVlU0NEtpY0Zodm1XNXZVdFdhUWxyNDdBWmF1ck9ET0E1YTVxNWJGR2NOUmVFd2hhY285YkJ3VGhPQlRBeVluRSt1dDNpZWtNeGJ3a21qclVBZkNhdE9kZUdTbUM4NlVrcmN1blhLdDErNXcrYysvUkRIZlU4eXlvdDNWaFdOM2x1VjlFYW9pb0tOZW9UWmlCeUZnYTZSTXgrRm1KUVBFdk9CUFc4aXM2bE9CRkpTTzI5SlFwSjA3bEVQS1NVSkYyam1LZVBMNlFFVDdkK1hwSmFMK3lMa1pLRCtPN2RPM3ZyOGplMjVlSGM1NlVzekxwZVBOanRxcEQ0aEtaR3NwU2N4U0dUVkRUVGQrZmhyUGtTNkNGMU92dmdvUkp3TFJ2UGxBOW5PeUljMzlmcmZPRDVNS3ZtZDNyWDBBTnArTWRFbFdCMzlFSVhZRHd4dHEyTW1jNTVnWXEyYUQvU0puS2xqc0tJa29TRVpudHFGNS9ZUzFnaXh6WDViaGFGTmhpNVpCbXUxUmNoZWQ2cHNVT1J6Q01KaEV6azFsc1dRc0NlOWdqL1pzbWxZdjk1TUgvWk94M21GOThTb1NTNFl3NlFTcmdKM0Y0blZ2WWJRQllhbVk3YTdRYlU1eFplZVdIcThWOHVya0JkQ2xjQkc2QTlQV2MxZjRlN2hPMXpkZTVxclc4OFE0bFdkOFZjam52bllKeEZKak9xYUwzenh4K2k3bmhCNjVxZW52UHZ1Njd6NTVxc3NteVhOYWs2eldqTDBnZnR2SEdOTXlGbm5VVXZmUEVrUnpsTlJpN0xBRlE3bkNzcFJ5WGg3QXBSWTQ4OXNvblhDSE04T0JzVjNJdUcwcFRsZVFkWlhTRW9VMW5KMDByRllLSDI2YlFOZi8vcHRYdnI0TlhaMlJ1enZMNVd4NXkzT09Rb2ZHYnpEWmdLOUx3cnF1bVp6QzA3Y3dOQ3FEK0VRd0RpaDlCQ0NIdENySnJEaDNkbUNTcUlNeldVejRJM0ZPV3V0dFU2RDRpK0dXUHplcHpMOVRxajdoVnZkUkpCMDB2UkgzUkJQSm9XVG1GVm5POU9TVmErZTdHbUlkTTFBbXlMUkNZdDI0SERaY2RJTW5QWUpqVnorc0V4dUxkbTV1Rm5MQ3hzeFhaRHpQRGdTU3grMjd2ckl0eXg5eEsxKzhVYS9lQmdrQjlRS3NuZ0hLUVJDMXhPY3A4L3RnU0xlV1NXWGpRVHJzMVFWQlJhZjJ4UnVUSVRVWGtncFJZakpLaDg3KzZLVDgrbVNrV3kxQmFFWGp0dklxUmk2Sm1DYmtCZTNBbkRyOTY5d2F0NlJPcVhsOVVGeWNJQ091ekNHaVFrOFdSZmNXeVR1SGZZY3R5ZjBUY3RrM2xCdVRLaG1JNlV6bHc1ZmFEeVUvZ3pneFdBN2lQMkNkeGZmNEhENk5sY3VQYzMxdlJlSXNrM2hhNXh6ck5vT0pGS1hGYlBaRmxjdVhlZVpqNzJBK2FNL1Q0aUJ4ZnlVcm11Sk1iSi83eFloOXZSOXgrSGhQcEJvKzRZWUEyM1gwdmM5ZmI5Zy8rQW1kMjdmb1J3TDQ1MFo5YWlrS0x3U3J2S2hsNUp1WWlQYWsvZXJubTdlMGplOWVpWVBFUmtDM2p1YXR1UE8vUVV4YW9Dbk1YQnkydkcxbDIvenN6L3pKTVBnT1Q2T0ZJV2xLaTJTL0ZuazhrQmdWSG1jR3hNTmpDWFIyMERYNkxTbHJpeTFnNk41b292Q2ZEV29XV2RaNUJCSHhTRmlFQ1NKS1FzL3FVbzM2b2Q0dEo2Uy9rSEVKdjlPOC9RQU1PL2kvcTNqNXBXcDk4OG1aTlRGckFncVBFT3ZJN1FtREJ3MEhmZVdMY2RkeEpZZWNRNVRXNm9FbzVTd1NjdjVlVlRTcjdtZ2kvWDUxN053andjMmFueGdzejc0KzkvcHhESVA2SExsUWsrdm1BR1lFWlQxaFpJK1JrTGI2b0F6QkdRSWhINmdyMHFLVVlFdE5ROHVHUlhPSkdQWUtlRHBEU2lNTVBTS0txOWpaTklBTmdvdUN6R3NPeWZCR0ZFNTY2cExISzRHVGlMMG1Va29vcjE3UkRlNzl4ckRORGhEWFBWY0xRdkdwZWQwTmFnT0lDVndqaWpDVnVWNCtNWW1MOTg2NGZaeHkybmYwRGNEOVdwRnZaeFFWUlZGVmVMSEpiWXFLTHpWMUZpakpoa3U4OG1IMVNISGg3L0IzYnV2Yy9YeU0xelplNVp4dlVIaHgxUytwZytSWWJsa3NaZ3pIbzJwcWhydlBMUFpCcFBKREVuQ2xTc1A1VXgxU3dpQmZ1ajFvKy9vaDRIamswTysrK3JYK081MzMrYjI3VGxYbnRpbDNod3oyYXF6T2FWU2ExTm1rTWdRejJLWCtsVlB1K3lJL2FDZ2JGUXdMOGJJblhzclZxdDRObDBSZ2E0TGZPMGJOM255aVUyZWVXb1hhenNPRGx2NjNoS0RwYXk4OGpkRWNFbkxxWG84SXNaRWFWcWNpU3dXT1VzZzYra0hvR2tUWFJjb0NrZkNRa3IwUVZOMXJMVllZNnpWRUQ1bGtBay9MT0xidi9HTmZnN0lDVUd6b2RQSld3ZXJ0eDdmR3JkRGxORXFKT1pOUjdOVVJMTlBpWk8yNTg2eUp6bkhzNDlzOFluSHQzR1ZvKzBUODlYQTNmMDVoeWR6RGs4N1FxTkJpZUZDVDUwdWVONm1CMjVvOHhHQW1uL2d0cGVQS0VsNG9FajZnVDg3WUFTMlVxTklaL1BJSndwRHB5YVRyaC9vMnhhL0tyQkZvWFBTdWpqTFpqUGVFb3pqc2V1T3g3YkxNeXVud2Roc1RLa2hpTDAzOUlPbEY4VXhLZzgycU00OGluRGFCTzR1Qms1aUpQUkR6aDVmcSsrTVpzSVZsbURWQmFNL2JYampnME5pVkhkWDQzUVdKYUszM2FMcHViWmgrUHlqTzN5ZEl6NDRibWdPQThOcVFiZm9xV2MxNWFpaWFHdjhaSVNyQzR4MVNsYkpVVmMrSlVxQmVyQWMzdC9uOFA1OTNwcCtuWjNkYTF6ZGU0cWRqVWZZbkZ6Qis1cUlvUjBDV1BVQkdGVTFHTzJuWTR5a2tJZ3BabGNnVVRmaHVpYUVudHUzM3VaclgvMDFidCs5eWFYSDkzam82YXZNcGlWbGFiUEtLcTBIeklSV2d4T0hOdEF2T3ByRmlxSHJjM3lVOHYydHN4d3RlbzdubWd2d29lZHU0T1NrNDJ2ZnVNZVRUMXhqYzhNeERHcWhQUXpLUFpES1o5VmVvRFRDaEFJekhoR3NKWVlXWjNwTkNmTEttM2VaUExYcUlxTlJVbXV0ZktsaExERkZyQys5TWFiODhGSVYvaUEzdWx5NCtLSmFRVktldHNQTnBrL3pMcWFkMWFBejc2UEZrcVBUaHZ1OTZwaXY3b3o1bVdldjhlVGVsSTJOa2tWS0hDeDc1b3VlT3ljZFI2ZUJvZGY5TmN0anIvVEE1bnlRcW1vZTZNZk5BK1g2Z3lXNitZaURZZjM1OGNMRHBnQlRnNnN5RWVKQ09LTmtCVmtja3BieFR2dHI0eHpXT1l5MVdPdHdoVWVzcGZLV1QzOThrNGMzYWxLbnBQd1FETjFnR0pLbHkwU1poS2hoUWhBc2FseG9qWnBqek52SVFkTnkwblhxdVlpaS9DWnZiSlB6aUZSNmF6SGRnQjkwaktmMFYyWGdTWWhZWStuRHdNbXE1ZUc5TFQ3N3lEYUZnL2VPR3ZxbEVJZWVvUjN3NHhWK1ZGRTBZK3JSQ0ZONHhCbUt3dU85bWpNNG9KRkVuUVFuaWE2ZGMzeDR5Z2Z2dmNsMHVzM1Z2VWU1dlBzb3Mra3VzOGt1U2JhSUNTcGZxSldZODR4SFU2cHFoRWlpNjlXclhJeHdiLzgyLy9JM2Y1bXYvdmF2c0g5eWgrdlBYK1BTUXp0cUIxWTc1YTFueStBNHFIMjFESW0rSGVpV0hlMWl4ZXI0RkNPR3NpNnhSZ2xaaTFYUHZmc053L0NEYUkxazV1V2JieDN4MnV0SFBQL01EaHV6U3JQc1FwTVBXSzIyUkpRbFU0dkRsQ1hMSVVJS0ZCWDBYYUpkbTRGYVpTOHVtc1IwRkRIV2diUDBROFNYOWl6OE1pK3lzeVdjMTV6NWc5N28rVmFYQWFqZU8xNjlmclRzYi9jcDNwajNnMm1XclRsYWROenBFcWRSMGNzbmRxYzhmWFdEK3ljTjM3dDd5bHVIQzI0ZXJyaDMydEwwOGF6SDloZnNiTUlGWUl3SE5qSWZ0Z28vcytGWWYvN0ZudjdCMi9yaTE3bFlJUmlmTFl4RytrTHNCVjl5WVczbWx3K2diRk9WUWtTSWlCbHlyMmZPd0s4aEdaNi9QdVlMVCt4Z1hRWnExdTZ2enRBdmRKNGVvODAyMTRJZzlBazZzaEZtRXVaZDRPNTh4ZEZ5cVp4d0xud2ZhODkxKzlhZUhXNVBqRHpiM25OdnBRdDB2WkpOMHBsNU13U2FMakFwUEorNnNzWElXZDQrYmxnTWtXRXBoRDVnbW9CZjlnempocUl1c2Q0VENvOHZWR0JpbmFXM2hsV0lPSlFCNkF6WVplVDQ4Q1ozUHZpQVVmVTE2c21ZamRrT2wzWWZaVHJab2ZBajZ0RUk1eXhsTVFXam83WEQrMGVzMmlWSkJyNzczWmQ1L2ZYdlVvd2RqejUvblhwYU15NE5vMEl5SFZhQnRaaXRzUWlSRUNMTm9xV1pyd2lOaGxZV1JhSFB6UWlMWnVET3ZSVk5FMzdIaFc4TUhCK3YrTVkzUCtESng3ZXBxcEt0RGUzTkQ0NWFCRTMya1pSb3N3K2Vzd1pKVVkwKzFoYmJVZjBJcThLUytrVFhKVlp0b0NnTXhuZ2QvOFdrK0l3M0thVU1LZjUrTnVqL09xWDdta01DcE1OVmYzalVEdStIb1gvcGVObVVKNmN0Kzh0QUo1b2M1MFE0bWJmODlodjMrTzd0VTk0N2JUbG9oN09ZMXZJQklDMTh4RWpzbzJpcTZZRmJtd2YrcnJqd2c5Z0hDcUlQQ1ZnY21BTGNDRXh4SHVOMDNwZExSaVEwZ3NqYTlhWmNXeG5MR1lKaWNsQmhpR0NTNVhPUGpIbmhvWnJZWjBtQ2dhcEt1RUdKTWtZeTFWYzRpNXdlUk51WExncXJYamhhRHR4ZnRLeWFZUjNOcGlpSnVlaTdaczRzMUVsd09LN1kyWjNoaktWUDhSekZ6c1NhWmQrZmNSc0tiM2w2WjhMRVdkNDZhVGpzQXFFWERVRG9Ca0lUY0VXTHF4Mm04aFRlVXppUEZKN0N1eld1ZUI1bUtZSTNsZ0tZbjV3UTB5R0o5Nm1LYjFQWEpWVXhaalNxczJOdVRVZ0Q3YXBqNkFkV3F5VnhDRFJkeDNSenltUnJSdWt0UlF4NGNhU2dJWXErRUdLSXRFMUMra2hzQjVhbkRhZEhjMExYSzY1VGxuaW45ZHZ4dkdmL29HRzVDdi9LcW5ndFQzM3R0WHQ4NTd2MytOeW5iMkFvc2JhazdVTG1KVmhDakRUdG9EcjNHSEhXNGd1SEw2STZIaWVvS28rWWxPWEIwSFNKeVRpQkNXclVHWUpKeVZCNVYxbG42bzhvVFA5UWJQUjBvWHgzZDVidHkyWHNmdnIrOGFvNlhFV0d2TW1ML09hOXY3L2d2ZnRMam9aSWU2NWxVTjEzcG83Mm5JZCtYSnhwOHhFbCtJWEk3ck5iL0lGQWtMUGUzbDRzMmZQbWlPczBVcFNqN0lwelBwSXh1aG1VMENCbndRUEdYdkRCTnViQzB6aFhDcDgvS1dGclV2Q1R6OCtvQzhPd1NrcVN5VWt1Y2Fta0dZOVF5SnBHeTlraEU2SVFCemhaQlc3UFcwNjZvSWRIM2xEcnp6MHpXc3p1UFpMMUJzY3BNR3dtQ3F0S3R3K0pIQk1NS2JIc095cnZWTU12aHF2amtocmhNQXJ2enp1T3VrSEhRVUZJZlNBTUFkUDFCRytKM2lIZTBWbUxzL1pjdjJyTUdYL0M1a1BlR2ZXWDc1cUI1WExBbXRXNUlaelJDc003UjFsNHJOVTNhRlNQdFNycWVvclNZcjFTb1BxUXp2empoamJTclFaQzA5T2NyR2ptUy9vdVJ4VGI4d3JuK0tUbC9tRkwxOFovN1Exd2N0cnc5Vys4eThlZXVzTDI1aFFrY1hsdkRLeG8yc1JxMlVHS0ZGVkJzOUwxNEl5R2RhYWtBUjFpaFBIVUk1SUlTOVYvcUV3NEVFT2lxSlI4YlFSdmphbk0yay83RHdrWXg0VzJObVFqTy9mKzhlclZSeXY2WlpkWUpxUzRRR2hKS2pzMUZ6Ym5XYUNGNUxMZ2dWTDdMSVFpVHg5L2dQamlQZ0tVdXpoNnUrak5zeTdKWW41UkYvOStUY2xOTVJzUG1uT21rMEhPb29Xc3phWHYyclUwYzlmTnVpSllhN1d6MjJsTWhzY3ZWWHpxMGRHNXAzcFNweFlKNmltMzlqU3pJampKQW9JOEcvZkcwRW5pZUJtNGVkcXlDUEdNbTdCbXc2Mi9weEhsZUtkNGJnWFVvS2FkcFhNc3UxNlZZT2E4amtrcGNkdzBiSTdxWE5ycTRURnlsaWZHbnIyNjVKVTd4eHhsd3dRRXBGZk52N2lJRkRHRGdjb2hzQmtjWE50c3IwZC9PZ2EzV2FXaENiUGtNYXgxRm0rOVNuZ2wwUTBLa0tsUFlJRjMyZVpUUkVrYklTa2xOZ21oQzNTTG50VnBRNzlxYUpjTnFSOXcyZHhSRFVFVEp5Y2RCd2Z0Ui9ia0g1ckx1Z3VMSnkrcXQ5NDU1T3N2djgrWGYrSmpXR3NZMVFXVHNXZi8zakZIaDZmczdFNVlMQUpkTjlBUG1wVHFuZE04UVpzWStrQWpVSTlVN2pwZmFRbnZjL0t2cVRML0l5UVRoMmp6OHZwRFY3cXYzNVllY0hjVzNUdWpZSDkxRmZqVDJVL0FjRUZudDk2WVVkbWFDd01IdVNLWWRLb0gyUFF3aWhmOC9OWWVGdTY4SWwwYk41M0pPK1Yzd0NjdnN1Y29OQ1UwRmJsNkZpV0FaS0JYTHlKN2JzUW9PU2Z1REhsTXVzalhEYjNKdGFyaEI0c3RUVGhWcmYwTDE4WTh0RldRK2h3K2FQai9jUGVud1pabDJYMGY5dHZER2U3MDVwd3pLMnVlZXFwR0EreEdrMENER0VpQkFrV1FoSVN3S0ZpeUxNdGkySXFRRmVGdzJQcm80WVBENFhEWVlZY3NoOE1PMi96aVFSSWxVeEluRVJBSkNzVGNjM1ZYZFExWlZUbS84UTdubkQzNnc5cjN2cGRaMVNRUlFScGd2WWpzckg2WjllcTllOC9hZTYzLytnK2JEaUZGdFhraFhYRmhYZmNJMm9CTmNvb2VMaDEzNXlzU21hWXFUTUIxY2ZOa05FKzI1eGNsT25IbVBIdWpSdFJpU3I3ampVSWlpeHF2ZDRHUnRheFBzS1NnR3p6NzQ1Ylh0aG8rbXZjOFNKa0Y1Lzg5RWtRbkpwZ1pTRnJZam11cnJKVFY1a0RVUm15a1dTdlBRb0lnSkI3VFdEQlpzdWpXVkdnRlRWVmpqSlh4U0VuM3dSRHdQaEtLOENrT0RyZnNHVlk5d1FkeWlsaFZ0bE1LVnYzQTJabG5mdVkzTGorZjlLRkhHanVXdEo0UUVqZ3hjbElSVml2UDE3LzVJYy9jM0VibnhKMzM3ak9mZHp4OHZPREdzL3ZzN1UxNStQQUJYZS9MaUdBd01aRzFwUHltbEZsMW5sUVpScTNCdVV3L1JKcmlxdVJkSUkwcXBSVWpuZkpVUGNuVitpTnhvK2NMWHRNZXNKMlBKKy81K0g4c1laSmYwN0F0MHdoZGdubUVkd084SGVGaGhFZHI4WmlHVmxqSzdGbll5bkJOdytjMDdDdVlBdVB5dkZ4bzQwV0xIcmhJZTFVYjBHa2RwWjBydVcxemhhU0RjQ0VLckJnZHBDUmZYQ0duemJvdDNxU2FySmx2ZFNtaWVQNDJaTTd6eEhTcGxSUmg4Sm50MXZLVmx5YllWakdzSWhwUmMya055MEd6U2hwWFRDS2RGcXJybWl5amk0UHA0Qk9QRnozenptSER1Y3B1UFlKc0RycTg0ZDlJNFJkaHpQSEtzOWZXZ0dKd1FWQjVvemQ4LzhGRnpsWTk3ZlowYzFwb05ENTZPdWZZbWpTNGZtRGs0YkhQSEpuQ1k5RG5DcjkxeW5XK2tHTy8vb1lVNjlkUENqWVdpMmlqeTBFUUV5RUw3bUNNMmFUWlVtaVhhcjBOY1VGV21pSGlmQ0Q1d2wvd2ZnT1FHaTBhZVI4anEzbmc3TVF4OVBHSDJ5MFZkcGF1WWJyVGdqRjBnOFAxam1nRGVTbTk2Z2NmSHZOWC83L2ZnSnc1UFZwU0dmaktWMi95MlRldWNYcnNPVDNycWF5bHJoVkRMd1FsWXd4VnBmSE9NeWl4SHh1MWx0RW9zK3dEcTVVcUpMaTBmcWpiRU5OMi9pTTJveitOZTRXeURXTUZiMXY0WDdYd1gyUjRQa0FWNFhHQ3h4N3VlemlMTU9RbkJmVUF5Z20vd0JnWTEzQmc0TEtDcThCTEZtNFkyRlp3dFc3dGpyYTZYcTY4cklxS3UwcEVZcEJzVmQ3QVNtNDRMaEFpbnVDem0zVkV6bm1Bd0xxTk1LV1FkRGtJMW44bko0ajZmQ1JYeGYzVjJ1THhyb3B1dlUvOHNWY24vTlRuWnFLbnJ6UXFDVndlSWd5ZHhudVJNOFppemhVekF0aEZhWEVIRDQ5UFBYZVBPcGFMVUlDeGM0d2djRjVrVDZQR1pPa0dWZ2dRZE5abkhwMTVybXhWak90aWRsSFVkb3ZCc1JPaW9PV1UvTHdNZmU5b1J3M0dHbHJudVpTaGRYQVlZVm12dWY5UEh2MXJlYW14WlJWWmVQdldyTEVSUWVYWEFHTE1xWUFvSW13eFZZWFNtcEFTMFRsc3pzUVF5bllqa1ZJaXhTQWQyZnBnMHJKU2pDbXpXbm1XQzBlM2lnU2ZQOWFtS3dQVlNGTzNGY3JJR2s4M2xxcHVhRVl0ZFJOWXFBVkRIUWpXazA4Q3prWGVmZjk0ODJVbWs1cmJ6KzN4ekxXV3YvVzlRN3pMN08yMURHVnNVRnFMdnQ5b25QTkZJNS9vZlhGSUVnOGdpYUlDcFpWT0dXV3pVdnRQUVZPZkpNLzRReW4wZkdIOXZQbGNnQStYOEZERDN5czJZT3Z3bmFkeHNvK0I0Rmw0SXFjQkhnSnZLMkdTVGtxUjc0OWErOEpYLzl4elAvZktqeHk4c1p4N1hka1NFTmdyM3Y3dU1kLzZ2WThZdWc3emxEL09wbERYWE9NTE4rTUdNVmJuQVFKYXM4bktLdXBDK1RyNkhFQ1VCMU5vb3RaVzhpYVhOM1V5aFI5NWRzWkg5eDEvLzl0TFZJYnRVUzJ4UGZzV2xUVTJHSklTR3l3ZE0wMlNFekRxWXJ5WUV5ZEx6NE9UZ2Q3bnpkcVJIL0xpNVU5NGM1WStNaDhDWTJ1WTFKcFJwVXNVa3F6eEtxTlpEbzV1OEV5YnVzenhVdXplSlZhZHcxUVZLSThDMmd4dGdGRmg4SjNXNElvT1JhbnoyS2VMODVTK2NEZnBDNFNIdk9uTlN2QkZ5aWp2U3M2OWpBUWhlSHpaZitja256TUYvRlBsQzd1VThhdUIxZHd6RkFQSlhObzZiUlhWeU5DTWF1cW1vbWtNemJpbWJtc0p0L1NSSENRaVc5Y1Y0NUY0NW12bjZlMkFDd3VZcHllZThxNzMvTTIvOHg2LzlidjN1SE5uenRYTE0vbCswTmpLVXFkVU9zdU10UVpiSjRpS3JnODBXZ0pNNnNiZ2N4UUZZc0V2SzAyanpnV1dGeEdFK0lkOW8zOFN5U3doODNtSTBQOFFaNmI0RDdGcjB4ZmNOZW9zaGlzaENrNjFmTzYxL2VielAzWERQUHZ5dGg1OExnR0JzRnBsRGw2L3pNR2xLVi8vVzkvbndWSWNBYlErdjhuelUydTI5WDgxbGU5YTUzUFlYcWtueTJjOUdxalNsaW90bGtkVlZXR3JHaVh4S3lpbHFJREdLSDdyVzB0Kzh6ZE9tS3FhTFN0TCtYdTk1OUtPNWJQUGIwRmoyZHR1ZU8zNmxNWm9jb3BpOWhnVFBzS3FUNXdzSElmTDRYd2NlUklyK2tRdzh1TE5Qc1RNY29oYzJhcFJ1a1pScUtLYkdUK1RWV2JsSGFPNmtnQkFsR2luZ1JnamxiVVlhOERIalROb2xXSHNvUTZ3cXFDejBGdlJCYXoxQ210QWhjSytGVXZ3SjVGV1ZkcVBrQklxSnlsb3JTWHBoM1Z5UWNscVM2bmNtSmtZdlVoN2ZhQmJSRUovWHVCbXJCbnZ0TXkyeDB4M0pveW5EWFZUU1hxczBlY3BQc1dYY0ZnNWh0NHpBS2EyakxlbjVNR0ROVVEzRU1NQXkvTVhPc1hNOTc5L2pGS3dzejFpYTZ1bDYzMjV5VE8rcFBBb0ZKVzFOT3MxNEpCUWxXWnJWSkdWeHBwSTBibmtLQ2tnelZOOHI4MkhZUDEvZURPNmV1cUNXWVBqL29KNlZIMkNsaVEvdFMzanFSOXdYZWgrUXozUFdHMVUvZGt2SFR4LzZlcm9XVGRrN3J6ZjVkTmpwd3lhNlhhRHQ1WkxPeE0rdDdkREcrR3hkeXpER3RvN0I5YzIvWkE2bnpYVkJiLzFOV3ErNWwrckN5Q1VrRlNrVlRUR1lHeUZzYmJjK09KM3A0MG1BbS9lNy9oaXFuaG11OEVseGNSWWRwc2F0MHg4Ly9jWFBIQ08weHk1ZldQTTZ5L3U4TmxuZDlodXRhRHZxZEJlejhwOC9nbE1QL1ZENkwyYlFpOEVuSGtmdUR5cnFhMmhjM0V6V09kOFRoQStYUFJzdDZOTk8xeDZTbUtNNGc1VVc4d1EwY1VLZiswOHF6Sk1IWXdkK0FvR0E5NUNid1J4Vld2L2VmM2tBWlRYcThtczBFcU1QdGZvdmFLRVo4amFTVnhBeWkzcGZhQmZSWHlmOFVNdSt2WHlkU3RGdTl0dzVlWWVsMi9zc25kNXh2WnVRMXRya1lnTzBzNEhsd3JsTnRNamV2UnVQakJmRG5nRlZhVVpxMG9PQXgvb2ZDWTZWK0ovenYzVVNIRGwwb1JSVytGY3hPaElqTUwySzhrQkpCMWxIaTNiQnhmZ3JNc00zdE5XSW1JU3NEY3BVcTdMcHRuL1VadlI4MU1YNDBYRThLSWdqVS9vT0Q5VzZHdG1aOEZnekZQQXVYMzJsZjFyQjlkM3Z2REIrLzNXVzk5N2tCZkxxRzQ5czgxMm93bERzYWpxQXdxNFBobHhxNTV4Wjc3Z3cwVkh5QWw5MFNKS25kODZXVDNGdWx2UEdhV3QwcHZpVm1odE1VWVlNNW5NNEIzWkRZd21FeWFUR1hVdGhUOGVqNW5zQjE3c0ZhbnZDY2NuckRwUHRGWmFacTI0MmRSc0Q0NlQ5NWI4M2Jzci9xdmZmY2dyTCt6eCtxMFp1K09hdzRYbndXa240WWxQY2ZjL3FiQ2Z2dVhYQjhNaWlycXQwb3B1ODBia0RkTXZSL0VCV0RqSGRsWExUYXdMZjk0SG5QTzBUWTFiQmJTUHhkUkQ2aS9telRsSzZ3UTFUVVh4dDdRd2FNa1hTcVhZOVlWWmFlMlFZNVNBbE92WGVBMG9wcEtnaTQra2tPWFdkaVZJVTh6a0JKQ3NGZTNNc25WcGkwdlBISER6OWg2WHI0d1p6eXpiVzVaeExlQ2Y3eU9yTHRPNWhGc0VmTWo0a0ZpTks5cEpoWHFrT0owN1NXZHBLMXBqeURHUm5LUHJRckdqT25jbnFhem0wc0ZFMm5PckdkeDZ6WGcrV3B0czBjYVZsQ0VCR0hzdkRNcHBLM002R1pWalVzVW90aWJUWFh3YzlSK0JHZjFpNHUzNkxvaFAwa2MrUm1iYmZOS1dzVmlEQ2dvVkMrajhGQWRtVFdQSlNabnJmL2RYUDN4T0VkVUxMKzdsejMveENwV3hNRVJjZVNqV2xOSFRwV05MYVY3YW1yRnRLejVhcmpnTm5zajVvbklOcmdWZjVtMTdYdlRraTkrOEtpMWJJcVdJcVJxMnRtYk10cmE0Y3ZrNk4yN2M0SXR2L0JnNzdZemQ4UTdic3hFSEI1ZFpuQjJqKzU3bDhSSHZmZnYzK2Y1di94YjNmdkIyc1l5V1JKa1lZR0lOTVNiYzQ0RmZ2Zk0rZjMxc2VlUGxmV2FWNWNISlN0aG1aU2ROdVFVL3h0UEorWWtENENKbDJQbklmT1haM2FveFJoUml1ZmpSU1Rxc0hKTEhxNTZ0M1dZelYyc2xkdHJlUmJTSzFHM0ZNRVJHNndrbmY1ekF0RDQ4bWlCNzBnaWNBSWRGZmhoS1JKcVFJMHJRWmhFOHB4Z2hSM0p4SDhwZWR2WnJFaEFYdHdvRkw2bG5GVnRYWmx5L3RjZXQyM3ZzWFp1eXM5K3d2VzJvalR6RTR6YlR0cGtRTmZNNURNblF6eXpMUlJSM29DRmlHaGxXZ2s4c2UwKzJSZ2c4VHN3dytyRVdmL2p1L0djZWpTejdlMk5TVWpTMVpkRU40alZYVmJnZzRocksrQ0UrZ0pJcUl3Y2NXR05JT1o2RFAyS0txK0pUdDNuK3B6eWsyMy9Ndi9leFM2V1JYMnIrbEZZOFBuVXFxZlAveU1kVzRlcmM3U2tYWkZYWEk3dC84OVowNzVXWDk5aTd2RVVYSmRvNG9laUdqTzhDM3FoaTFCRHBmS0N5aXBrMTNCNjFQRndtRG4xZ1VHdnlTMWxSWFVqdGZIckdGVmVteEhneVpYOTNqNWRlZXBXZi9NbWY0clhYUDhmMWF6ZTVldVU2czYxdGNvTDN2L3Q3SlBON05GdG5CSmEwc3dxZnpoZy9DNjk4eVhQNTU1N2gzdHNCZDlhak1wdytjRHg4WjZBN2RkeS9jNG9aV3I1NjhBckxkcGZqcG1aeGVwOTJUekVKaHl6bWM3R0oyc3dWYk13b1U4em5RTWdGTWYzNnRYY3hjOXdIOXFkV2ROckZoejluaWFDV2xGb0JtVHJuYWJXQmxFb2hhaFN5MGpKYWZOOXFsNGpxeVlkdk13U1UvWkFyQkNpVllRSjBIaGIrd3B1OEpoOFZLdkdUVDBIK2g5NWhHZEMxWm5aNXhOVm5MM0g5bVgwdVhadHgvWHJMenE2bGFTVXhKL3VFRGhsVHlZSFNhTWd6VUwzQ05vS3hkS3NTNTZ3emFxZGwzMGZjM1RsRHltTENVVm1xdXNYV0E2NlNmWkVxU082dG0xdHN6V3JtQzlHM0MvSXY1cU1iZkNFSkpwS2VlcmkwRWd1eW5DQ21TTTVSZXhpbGtwSHhSMm1QL2tOUG0zR3BvWC9VditlNE1QWThYV1RGYm1jOTYwOTMyL0dQLyt5dDUxNy8wdFZ0UDJRV3AxNWxMN1k4blU4TVhrUVJIaTJtbEJZZW4zV01La09Ja1pRVEV4VHpKU3lWU0UrTkxldVc2dHdJUDZmenRWbUtpcmFkY2Z2V0MvejhuL2xUZk8xclA4Tm5Qdk1GOXZZT3p0K0tHRkhHOE40UGZzRFgzL3NyN0Q3M2U1aVZoQ1RJaXJUdzRYT20ycXQ0N3FzamNtakpGNXhPQVE0L1dLSzZiVzQrL3hWMlo1OWxaL1paaHFGbHVScjRxLy9SZjhqZitkVy93YVA1QjNoNnJGVTByU0Y0OFVVN08razV2TC9FRFpHaEMvZ3VQQ0VFU3NES1JaeFBWTm93WkY4b3IrZWNBUlIwVHVURTdhUXRSWDcreS9sQXNncFRHN0tYeEZXbEtDU2Y4eHExNjdWa2FldlhMZGxPQVZ6NnA0YTQvQWU4cXBSUk5MT0svWnM3M0g3bENsZHY3SERwY3N2ZWZrVXpNWXhiYUJ1Um8wYWwwSTBreVhvdmtjNU5KZC8zMGl1bUV5MHR2ZFZVU3huNTh0NklidUc0LzNpSnRnWmpEYWFwTVpWRmxiVkhUaEx3OE5xcmx4bTFGWDBuejZFdXJiN2FDSnZXRjBaeDk4MFo3ekxXeXA4Rkg4Vm16UVZDVW5xZTJjdkNLVWxQZzNMcWo4Q04vckdQNDMrTXcrQWY5WDRXSjZrMW9HZjJyczUyVE4wOEcwSW1oWmhOSHhST0lwMThrU29HbndwRUw2Nm9Ma1FHTC83d09XZDhLcTE5RUZBa0d3bjdhK29uVjBBS1JmQ0tnLzFyL01xdi9DWCs0bC84Yi9EYTY1OUZhdzB4a3YxQURwR3NOY29heUlaMzMvazlCcjZQWmtMczFJYlpvdGZFblFoRFNBdzVvdzFvbllvcVRscTVTODlOc05iVCs3L09oOFBmNDB4L252M3BHMXphZVlOLys5LzV5L3hyLzhhL3puZmUvVTNldXZzUE9CM2VKNmhUc2dyVVRVVllPUjY5ZjhMaVpPQ2pkODc0L2Q5OHlQMFBGb1FoYmg2MlBpUTZuNWlNRGN0aVJuWSttTWl0cmxYbWROR3owMVJVRkpEc3dnTWJRaFI1YXFVbEJDRi9YSVB3QklubkFtRFRBbHNYME5VL1VKKzRacWcybXEyck02Ni9jTUROWncrNGRIM0czbjdGN3JaaGV3cldabkZVVERBeTBJNHpBU1VqUUlRaEtlb2hNUjFsc05BcFRRclNDOVhXWXJUMG5NUGVpS09IYy9yVmdHMHFqTlZVeHVCcVE5U2llZ3N4NDBKbU5tc1kra1R2SWsxdDZVT1FEWTdXeFVGaURlTG16VXF4cW1SY3pJVjMwTHVJTVJaRFZ2Rjh2ZmJramY1UGNVbzMvT0Y4S0tXVXpqbXZUV1ZhWUhUcnBZT1hyejI3OHd0Yk8rMmV6cG13Q0dvSW1WVUNQeVJTbENTT0dETDkzUlBTeWhGaVpPVVRzMUdGODJMOXZCb1NRejZudGJwUWlDZG1EUllwRW9ySjVJRC93Yi96Ny9Kdi9Wdi9OamR2M0lRUXljR1R2U2YzUzNMMGFHM1FUY3Y4ZE01di9kYi9rNTBySHpHZGlpbWwxcm40dFYrWVhTVjhGYXZ6NXJvVjlwMG1PQkZCZU4vaWZXWSt2TS9oNHZjNW52OE9NUTRjN0x6Szh6ZmY0SlZudnNnemwxK2hOaFhPbnpHNE01cFI1dVp6V3p6N3loYXZmMm1QVjEvZm9XMDBpMlhrN014TFo1UWxFbXZXV255VWVPZ05lbnlCQ2VoQ1psd1pHaXY3OXBTbGEwaFowR3BsRE1Gb29Ybm1jek9RanhGVDFEbDMvaUtpZXRFaTdBLzBNRGFhZzJkMmVlRUxOM251NWN2Y2ZHYkt3WDdGN2t4TG1tcWxtTlRTUGVteXhxdE54cFRGZm80UWtzSTdtRlFaMnlnR3AxajdxNnBpcGxFcFJWWWExd2RPVDFhb3loS0dnQnNjdnZPa3BieWg2OWYwcFJjdXlUcTBSR29QdlZTd09Cekg0cjBmR2ZxSTkvSjZWRlpqakpKWUtEa05jNlcxeWwxNEhPSHZSTGtyZldsNGc0SlVhVW1NL2xRVmVya0liQm56bW5ac3A4OTk1dHFYOTY1dS9lbnh4RmFLakUrb0xvRWJKSmt4SkpuWGcwOE1SMHZpNlJKRjVyU1BOSlZDcTd3cDlDNDlTVDlhdTNVbUxXMVc4SVpmK1ZmK0V2L0QvOUcveDdpcVNTdkpLU2Nsa25mRTRER2pDZHBhbExHODg5WjN1UHZvUCtYNmM1M0libTJtTmtLQ1VVVzhZWFdtTVpuYVpvekpHMUtLMFdzZXNTWW1SWEFRblFiVmtMS2hUMmVjZG0rU1ltUm45QXF0M1dKbjZ6cTNMMytSL2VrelZFb3h1Q042TnllRWhLMDFWMiszZk9GSDk3ajl3all4d2Z6VXNWd0dmSUpKYmFpTWREMlo4MFNaZkVGbW1sSm0xbGFsQ0hLWk1TV3ZMaVhGZ0tJbW9Rb3QvR25FZFoydmtENU9UTnQ0RElRL3dBT2hHODMrclcyZSs5d05icjJ3ejhIVmxvT0RtdWxVMDVCUlZtRU50R1c2WGRNck00cVJ6VlQ2ZkpEVWxXSTBrYkd0NzhBSFNZdDFQcEdTd2xwRlZXbHlWaHcrbkxQb3ZQRG16NWI0azU0OG5IK3QwN09lNjllMjJOOGJZWTJpV3dXNlh0S0VVK0VEcHlRN2RCOGtobHZvMWxMa3RSVi92eEJ6VGpIbjdQTkhYZ3I5NU9sQ1Y2cVk0SDZLQ2wwcnBkYUYzZ0R0N3VYSjF2VVhEbjV1YTNmOG82T3hKcUZVbjhSQ2VXMEZUSUxRQjJJc2hvRDNqaVFDcWJTc0k2c1lYS1J6bVQ2ZEQwR2JCelJCemhvZjRlV1hYdU4vOWovOW4zUHQ0Qko1Nk5FcGtyd1RaeEF0YlppcDIzSnlLNzd6cmIrTEdmOHVXMXRlVmdlcHFNc01FbEtnTTVYSmhmQ1NOLzdSS2FoTk5heURITEtYdHpnRlljZkZVTk1QQTBOWWNXbnlCcTNaSXllUFZwYWQ2WFZ1N3J6Tzd1UXFWdmNFL1FobEJveUdwbExjZUdiRVM1L2JaMmQveE1tUnl5ZVArbjVTbXppcXRYVlJJb3JXL1BRTmIxLzBKalJXVXhzbHFId1d3MFVTeklmRWtVKzBWbTdEOEFuR1IvbXA0dVlweGFFdWZPbC9uQmJlMUlydGExT2VlZlVhdDErNnhLV0RocTB0U3p2U1dDTU9RRzBqanF0VzU0MWV3WWlKQzQwUmt3K3RvVEtaY1pNa250a3JWcjNNemlsQjN3dkZOaGNQZkcwMHdTWHVmWFRDWXI1a09GNFJ6OElUMy9RNktlZmxGL2RwVzh0eTZWbXR2QkNTQ3ZpeUJ1T1VpaGd0cTBIbnM1aE5GbW54bW85Z1luNHduTi9vNitZbkZJN09IKzU2N1ovaXJiNWhxSTZuemNnYWZjTzdpT3RqYmlaYXBaZzNMNUpXR2o4NFZpc3ZKZ2kxbGRTT25CbGJPT3dDSnlxaG4vS0l6MDhSaTNQSVdGM3p5My94TC9McXE2OURDT2k2aFp3a3VVVVZTNlp5RFNxak9UMDZaZG0vdytUU0lPQmJsamN6WkhXdWlNc1pWWlJyRjBYck9xMTE3aG1Ka3M4bFZMQVFUWkFiSVFkRmxiY3gxVWdtT09mbEwyaEZiU1k4Ty90UnJqVFBjTGY3VGU1MmY1ZXo4QVBJaWhnTXUzdUduL3d6TjdoeWZjcXYvaWQzSG4zMDJ3K0g1Tk96V2xGRmRlNUV1R1lQYWlWaEU2ZWRaMXpwRFpnazJtNUIyNjJDU211aVRhalN3dVlmQWhoZDlNWmYzeHdOWWhWMjhvOG9kbVZodEZkeitjWWUxMjdzY0hDNVpXZkgwb3dVdHBMQ3Jtc1lXV25aZlZTUzZOcktLQVlDQ05ZS3h2VjZWSkVpVDBubVo3OElCSlJRa1gxR3g0U3hRbE85ZW4yTGV4OGM4WjNmZjBqdTBzZmFFS1VVZHo0NDRlNjlPYy9jMnFHcERiYlNRdU5jeTV5VnBxb3NLVldrbUxFMjBYdm9Cem1jS3EySUlhRVVtc3dPbWZZVE5sQ1M3WjQvbllXKzhZcW82bXFzalRrSVE2SmJ4bHkxVmlVbmpwNVZwVmtjOTd6NzlpT3Eybkt3T3hWdnM2WWlMbnBVU3RRYUhxMGlXK284T0Y3emNaODVEN3owNHZQOHdqLy9aOFZmekZSQ2JTVkQ5QnNwbHNxQXRhQU5kKzkrQ09ZdTQxRXExczR5QytaVUNydG9wMVVSVkdoemNSMlZVVWJRL1JSS25IQSs1OUhyREltRTBZcmQ5aHFqYXUrY1FpSFhCZGtIL0dxSlgybXVWMS9sWU9kbDduUy94dDM1cjRPZGc1ZU1zeGRmMzFZN1YxNmQvdGFWaVg3djF6L013NWtYNldxVzhJaTFpQ29Yd3N0SkY5Z1pXZHJTaDY5MTV5Z1lhNUdhR2lRMTFjVW5pLzJIUFkveHdwK1B5cTIrZkpwY3NSNEZERFF6dzliQmxOMUxXK3pzdDR4bmhtYXNhU29aajZxeVNuUkJXbmN1aUdWMCtZWkVVU2lpWm9OMFNTbWVzeVRkS2dwVGJsekpwVkdpcjJOTWpFWVZMN3h3aWZ0dkhmSDRiUDZKUDFQWEI3Nzl2WWRjdVR4bE5Lb1l0UlhERURaY2ZXTTBXbGxpakJqalpkT2pZSER5dnE1RklEN2tsRExkRDRNOTdCOXczUGtEdGREODBmaFFXVkdocUlPTGRBdFAzMFZDRlByZzRmMEYzLzM2UjhTWW1FMWJZb2lvMnNDNHdUdUpRYXFWdEtQSHJqQzVQb0ZrYjRvanlTLzkrVi9reFpkZmtWdFlyOWtkUWk0UlV6OGpENU5XQk84NWZQUUJ5UjZTTklTbzZYdkRNR2dHcC9GUjQ1TWlLQzFwRnloaWxKdkhSMFVmRFYzU09PVHZ4YWpJWGhHZEdGTklpNS9SR0tidGRhd2FrUWNuS0xpMVlDMnFzaWpUNEYxUHQxakEyUzdQMnovSGE5di9LazI2aVVrOXJSSGx3YzZPM2YzeW43bDkvZlUvK1d6VmpHclUyaHppS2ZSY0svQXhzM0NoWk9UbERmM1hHTVhFU2pydTROTkdHdzgvM0t6em9zZ2hYVGpCeCtWMmY2S04wM0xJMVJQRmRMZGxaM2VMN2YweDA5MkcwY2hJdTY0emJabTdlNi9vbkNvNWRYa1R4N1RSd2lQcXdKRDFob2FieTAwZkl0QWF0Rkdra0RmRWZFbXpGVmJPN3NHVTUxKzdUTjNhanpIUTEvdi9kOTQ5NXVpb1l6S3BHWStxa3RRalFScmFDUDNXR0lPMWh0cXFEWWFSTXhpVnNVWnU2M3dldy9ULzMxbjVqMEtSQXlySG5ITE0zcnZJY3VIbFRWQ0tkNzcza0cvKzd2dFVsZUhxdFYyczFnd3VnVFhrcXRySVFJUFBqSUJlL0FRK3h2QlJTdUdBcTVmMitabWYvVG5hMGFpd2ROUzVHTDJxejMyYnRFRDBpOU1sOCtVSDZHbVB0NXBjZ1psQ004MjA0MFJUSjlvbVVUZVpxaXByTnYyVXVpZEp4cGhZTm1jd0dhWHpCZGZaUkZOUG1VNXVDbnBNSXVzTGI0MHg2Tm95bnN3WXozYm9WMmNzRDFjY3BDL1N2LzFGRnZmR1ROckFxTW5vbE5WbzIraVh2M1pUUGZlak4xSEdFT1A1Mm9jTEV0MUtaUlo5eEllMElYaGtKYmQ2Q3FsRUNrRmNrM1hVeDF2My9FT0VEV3Z0a0MzRlhqM3hYb0J0b0prWVJwTUowNjBKdS9zanRyY3Rvd1phazZuSzl4c2lKWWRlMm5HaUZJNHBlM3djeEhuR3UvSWNwTUpLMCtzWVpsQldZMmNWVmFWS2JsMEpjeXpJdVFLdTN0eGg3MkR5eVd1L25PazZ6emUrOHdCVVpqYXQyZGxxc2NhZ0VYZFhYWFFSMWxSb282aUs5NEV2QVpLaHdDQW9QT3JqMFlLcXVBbDllZ3U5dUM0cXJWVE8yUWFmV00wZDgrT2ViLzcySGI3emV4K3dmekRsNXJPWHBGaDkyb1JWWldQd1FhUnZYUmxwMTRHTFQ1dE9ybjNGdnZER0d6ejMwb3ZuSUYwU01YVU9uaHdHOHZLTUhHTkpUMVFzNW1mRTVoNW00bENWa3V0cEJMRlJSQ05ydXFUT2VRUStLOEw2VjFKaUs0WDg3Z3Y0SnRoWG1Sa0w0TmpXVnhtUGI0bXZqaktRSUhrbks1NFN0N1NjbjlFdnp0amEyZ09sZVBqZ1BrY2Znbi93QmNieGVZenlOSlVFTUxaYmhzLzg2ZWU0L01KK0FTRVZzVHo0YWMwV05EQ2t4SHdJRzl1c1VGWlBaQ0V6NlEzV0lITzcxdjl3STg5OG9ZWG5Bcjk1ZkdGK054YXFSbEUxRlhWVE05c2ZzWDkxeEdpczBZVWoydGp6WUF0aC9wVUVXZ1J3bzVpRDJFS2pUY1VrY0gybzUvSWVQREZTS0pISnJrMUpjOEdBbkl1TXh6VUhsNlpGYWZmeHd5eWx6QS9lUGVUZS9RVmJzNGJ0clZZQXZXTGpySlRDYUJIdXJFRmFXVDBxUXNxRVVIRFF6RkFvNEU4ZUtmbmpyTTFQVjZITG1KTkRTTjY1RkpSUzlNdkE3Ly85OTNubjIvZTVmZnVBVzdjdkZYT0R0UGFZa2htcktLeTZsT216QkNGOG91V1VVc1NVc0FwKzZxdGZZV3Q3aHhTOUpLR2tTQnFHc2d5UHhVM0JvQXJqcGxzZFUwMlBhS3hIRjVSUEpRSFp4SFJTNFp5aDkxSzBHUUhwQW9xSUprYkoxRjQ1UlJjMGZkWkVvd2hSNFh1Rmp4bWZERlZ6ZzFGOXRYd2ZXV3lZVXBiQXg1UlFNZE8yTFRFNGNrNDBUU3Q4LzhVWnNiK0VPdmt4cW5BRnJRTFdLbkpPYkIrMGZQN1B2TXoyMVMzSkg0L25CSTRnWWF6NGtKbTdKQzQrU201UW81VHNwdFZUcjJjcThsVDl5YmY3MDZLYitCUVN2MmJhYVF1bUVyKzQwYmpteXMwcE8vc1ZWWmx0aTQzOVprT3d0dDRLU1E1V1k0VE9tbU54RjVwY1ZDdXFqZWxtQ0FLWXhTeGMraERsOTM0VmhHVlpvcHRUeU1RSVZXMHhWdjB3NGdkZEYzajduVU9xMmxEVm12R29lb0pBcERZMlkwb2F3aElmRlJKWXZTR0RHcVUrdnNCWWMrTS9qWVYrOFJsS3djVWhES0hQQ3JyZU1mU09sMSs3eXJNdlhDYWhDRDVJdW1qS3hKRHdnOGZGUkFkMHhjckcvNUFIemlDaDhsY3VYK2JIdi94bDJscU1FbE1VNG9PdUcxUlZROTJpcWtwb2RUbmhseDFuSisvVE5vL1pIM3ZHVnZiSzZ4dlprS2xKTkRsaWZTYjFrSHhKUFkxc1BPT0NVM2luY0NpOFVyaXNvYzAwazB6VEp0ckdzRFc1aGFFbGVGZVErMGdPZ1R3TUVCd3BpcktxcWxxQ0Y0Sk0zemxXL1lyQmQ1dytidGdlZm9vcVhpTm1pV2ZLS1hMMXVSMmUvZkp0NnJiWnpLOXIvWDR1TSt6cGtFcUdYaGIrdHpvUHYxVHF5VEZrUGVWazlROUg0UytPdW5VcGNuMWhQbGRhZ2cwdjNkamk4dlV4ZGRtRjE1WW5CVWxzekdsa1oxMW9aYldGdGszWUptTXFjZmV0akh6dk9TTXJ0WmdsUnkxa25NLzBRYkxQZzB0NEwyR0pJU1NDajdqT0N4ZkNmbkpKNUxJdmYrc0hoM3g0OTR6cHRLVnBLcXpWR3pyc1duMGtvUldiNHBab0oxUHNMek8rQkFEL3NPNzJVMW5vNjR6b05DeGROM1QrTU1kRTlGRTFqV1YzZjFZa2twbTZNUmdyVjBuS0dlK2pHQXB3emtvTGZJS3J6SVc5N28vKzJJL3kzT3VmMzRCd1NwOC9WY0pmRnNaQ1JvR3BjRUVSMVFtVlhlSzlzS3hXZzJJMWFIcXZHSndoQkJGVDFEb3pJbUY5UW5XWnZFRFlQaUdqKzB4OUZqSEhDVFhQaEFHYzE0UWtZOXBvdE12dTdGVUlrZFN0V0IwOVpuNzhtQkFjV01ueFNpR2dUWVV5Vm03a0VIbDA5SWplcldpYWh0NE56STlIcFBuekRLN0Z4VXlJd3NKLzdrZXVjK1dsQTVHS0dpSHdWQmRhOEM1a0huYVJwWThrWTJnYUt5aTIvbVRsUll5RlExQjljZ3YvZExGcllLSmdxd2l4TXhCOVpySTE0cGxYOTVodEdkYXF6NVNoWkVkU3FWUmErSFc0Z0F5MzFtUnFtMmpyekxUSmpKcEVYU1dhS3FQVk9lcVl2SmhieHBDRldWbDI2REdrVFNDRTZ3TDlmS0NiTzBLUTJPTi8yTWR5NVhqeis0OVJHblozeDB3bkxjYnFEYUNwbGNacUk0R2NGNW1STXFPbnJEaEViV0lIMHdWVzhUL1YxRVg5aDN5YmI0cjk2T0Y4dnB3UHZ6ME0wY1VRVkRmdjgrT0hTL291eUU3WGFsUmxKRjAxRjZKOHlTUzdhSUd6ZGo1cHlsellsaE4xMnhwKzRhZi9KTHU3dTBUWGs0ZCtvOTZTRmpHU2dpOHlTaUFrUXQ5QmU4aGdBcWVyaXNXWm9WdHErazZ6Y29aRjBweG13MUd3ekxQQld5MEJFYVl3NHhLWUtMZE1wY0c2aEQ2TG1PT0lEWW1vWWVrMGl1dE1xMmRKTVdHckNvWVZ3OWtoTVVYSmNTMEtOSlNtNngwZ2M5L2RleDlCempSMWd3K2VvUS9Nanl6elJVM25KY2JaeGN4b1ZuSHpqUnVZdGhGTmZ6R1dHQzVJcjg5ODVuRXZiUWcxSHdBQWdBQkpSRUZVS3NHMk1odVlYZlB4dE5xMUdhUkdvYTNhdFBGUEh3Z1hpejRpOXI5anJmQ0RZdXRnaTgvLzhXZTVjWHRLWllzTGJMR0kxb2tDc3FxU05GdVNaMG94cEhKamV5L1QxbnFjc0FYZ2pFRStId3N1RWFJaWVBRVhMWUNUOXpnbDhFTmtXRGpjNFBHOUVJeCs2RU5iV3YwN0h4eHpjdG96YWkyN1d5MXRMWXFwWENqSGRWWFIxSmExNlc1S1FxRGgvQ3o3eEFuem4yWjR5eC8yakw1K0JtSkt1VitkOWQvdDVzT0hzUVRKTDQ5N0huOTRndXVDR0c1cFFZYU5FVk0rVTF0aEdUekZ2ckhJdW0ya1lXWVVEWERyK1JkNDR5cy9UbHRWd29BekZjb1dxWkxTaGRlYzVYTko0aUNVNmdueExyMExCRFMyeXV5T0FsY21qb1BXczlNRXhrMmliVEs2Z3FnRmVFdFdvV3NoZ3dTakNXTk4yTkd3cGJEVFF0M3NDdmhpTFRON2xYaDB6T3J4UjhRWUdPMWZZZS9HQzdUam1SaGdsczVqR0hxNWtXSmlmbmJHMGRFRHhxT2F5alpseDUxSW5XSHhPTk1QUW1WTlNXeXJMdDNlWWYrNWZiTFdHMis4aTVSVkh6SVBCL0F4TWZTT21OUEd4LzdwOU5xMVQzOEtHYXVncVRSV3E0OTFueGNQNEp5aFJ6TnJhNjdkMnVOUC9QeHJ2UHJHWlVhRjhkYVlURnY4ODEyQXdTbWNLK0d3V1d5eFIxbk1MWWVnR0lJaVJJMHJCZ2M2eTBIUjk0clZVdUc4NERLUzFSWkpQcEY4UGkveW5Jays0b2FJYzBGU1kxWU81LzdSbSt5emhlT2IzMzFJVlJsR281cnB0S1dxN01iclRxbE16aEZyQzJ0U2JjN042RE9ITVc4RWZwc0xMLzFUVGx2OFF5UE01TFd6M3JrdFZYaHc1K2pkWm1UL05pWWZLRlJyamFyUEhpOUlHUzVkMzhaWXRVRkFReFJ1dHI1d2kxL1F2a3ZCRjlDblcyVis5STNQYyszV00wQ21haWVDTElkSWRoSlFRQktYRVl4QkoybmxRMW9SV0tLeXVMWml4ZWxFYVhIRFZMbnMzazBCZTRMYTVMWEZyUENGcUpKaUZ1dmpzVHdFUm1jeW1pNWtsRzdaMzNxZGR2c1NZZWhKS1c0VVVjTnFRSnNLb3pRcFNuQ2ZOWm0rN3prOGZrem5PaTVkM3FmclRqR21KZWZNYVRmbjRkbVNXUVdqVnVqRDNtZlFpbWUrZEpPVGo0NVluYTQyNEZoTUpaVTJnMU1RVTZMM2VhTTV2MmpTOGNTTlhvclhoNHl5VU5WQzdRMmZkQ05XaHNuZWlPMWIyenozeDI2d2YzUEdaRmFWbHZzYzJETkpnRXN2RUFrbXkyYkFSWmwzbTFyMjY5NExxbTVIc3JGUFdWcDJsU0U1eGRBWEhrT2Y2TS84SmxJcitvU1BpVkJwY3N5NFZjRDNrcVl5OUo2aDkydlo5RC8wSS9qSW5Udkh2UGpjSG50YkkrcWxFMVdiTlhpWDhJVjJiTFVrNWc2K0dHOEliTE84WUNQMWhNVmEveWtzOUZ4V2FqR0wvVVlBZkxkMHArOTk5LzVmbTJ6VnF5dTM5djZVTXZvMVl3MW5qeGZrbE5nNW1PRlRab2lKbU1WU1VpUHQyTm85dFY2Zm5sb2VQbTBsQk8relgvZzhzOW1NNkJ3NUpGYkhoMWpiVU5sYVNETFdFQVluYmljNVV6Zmc0aG1SZ1R3VXJyUlNESTBtRzlHaWwraHpsQ24yeGxwdEFDdWZGYTZzZTlZcU9oUEZWTkNYREhLSWJJK3VzN2YvT1pRZVk3Q1l1aWE1bmppczZCY0wrdVVDVzdVMHpaZ1FBOHZsbk9BamQrL2ZKZWJJYkxwRDlJNXVkWUl6SzQ1V3h4ejNBOHdyckJLQXpidUVENG5aMVNsWFAzT0RkLy91TzFKVk1XKzg0eTNpdEhyWVI2S0c2ZHFzNHlsLzBvK1pDSlppcnhIdXZWTHkvOWR1dTNaY2NmMkwxM254VHp6RDFhc1RScFZHVHhTeDBwSnZaekoxY2QwTm5vMGYvTnB3UTJVMk8rbWtGSDJVblBrcUtSb0x0czRid1h4UzRMS0VKdVNRU1VNa2UrRmMxTFVtdTBRc2VlY2hSb2JPNHpwUGNKN2x2R081ZFA5WUt5NmxZTEVZZU9mZEkzYStjSU9xMGxpcnNkWXdESTVZZG9MR1FGM0wramZIalhPMlhWdms4OE56U1Q1VkZOaGNWbXZyRzkyaGNFTVh2cjl6TUJ2RzA5SG5GZW8xOFhDRDAwY0xoczdSVE50Q0psR29uTENGaGxnVmhwUlp1NUNXYUtKTTRzcmxiVjU0NFhtTWl6aTN4UGVlNWVrSmRUTWx0d29mT3psdVEyVHdua3htYTFhem5COXlObC9oT28xRlVkZFNIOG11V1I4SlpSUXhLekJDNUZBWitrRXhETkkybzgvam5oS0ZNWlZsQlJjajdFeGZZRnhmcG50NFNBZzkwKzE5L0RCZ214RmJ1dzBxUmM3T0Zwd2Nud0tKb2U4SU1mTHUrMjhYZW11a3FscjZiczVxT0dJNXpGa05EcnN3V0IzUkllSkxnSVJTY0hCN2wvdmZibGtlTHRHNjFIQTZ0M0VlTWp5TzhvWk1DdWY5WWtyTTB4dU5kVnMrK0V5akZKUEcwS25FeWlmYW5aYm52M3FiMTMvdWVXWUhEWGJ3bUppd0U0T3lrdWFudE1LWVRLMHpGWmxLS1p6SkJGL1dlVnFJNFQ0cVhGQW9JeUlqdlE3UmNBcFZYdnVRRkozWE9HU3RsbEJRU1lFM1kwMEttWDRWU0VvUlhTUU1FaGpoWFdBKzcrbFc3aDlkNUZxMDV0NUgzbjMvaUZ1M2R0aVp0bFIyd0ZwVGZBYlBLYzRXVU9JK3RUNVR6L0xIRThMVHA3TFFxOW9VNURWZXRJYjJoUnBOVmpRcDU0azFJaU5UV2l1dE0vUGpKWXV6am5ZNndyUTFkdG95TWhwZmpCWFhEa3hyc29JcW91bnRuUmttWmc3dlBhVHZCK0VvWjBYVlZpeTZsY3krclBlMWtnMitYQ3g1K09pTTkrNG5mTGFNcldGVUpjWnR4dGFncW94RnNzWnlrSnRhb1ZBaDAzV2lpVjd2akJXWnJBV0dTVmwyckZwRm1tcktsWjB2b2pDWTJxTHJzVVFlRlZLM3FscmE2UUZkci9CaGdUV0tsQ0xIang3eTBiMzNlZkhGNTRneEVuSm1OTm9pVjVidVZKUlYwVXZBaExUbHVRUlVaQ1o3WTNhdTc3QTZXaFhldTBRbG1TUnJzSFUwOVFtU3Fqa3BncEduQWJsUFdxMDVsOUFvYWdObTB2TEt6Ny9NQzErOXhXVGJZbkxBV0VVOXM1c2tWcTBMU0ttRnAxN1p6S1RPdUI0V2hWNllDNkZJSVpSZGcyVGhhUTB1YXJwQjBlaE1xeE5KS2JxbzZEMjRRcUdPWE5EanU0UmZlRUpyU0VNZ0RwSG9BOTRGVmt2L3libHRGejZhMmpEYnFqRW1jbnJtbU04SDNuN25rRGMrZTUybXNiUlZSVFZ1ZU9nR3ZKUExRS2w4a1JEb2tZaXlpNFgrLzVlYi9RK2wwTWV6bGhnVHk5TU9wVlRLT1V1aEMwaWhEdStldmplZTF2L1o5c0gwUUd2MTdKcEZvWTFXem5uQ1VjQzBFczVYanl5bTJQV3N3dytGcmw1bWFXUG9WMHZ1Zm5TWDJlNEhEUDBLVzFtVU1xUVlaVlVYWlFNL0RFTUpFQkNGMjdzUEhuRG52aU9ieExqUlZFWmgxN3J6VnROT0ZKT1I2TS9GY2tuUk8wVnlVT25NcUU2WTBsUEdkSjVWWnJOQ21jRFc3Qm9IazFmSklWR054bWhUa1dOQVdVWEtSWnByTEhYYlV0VVZ5OFdDZHJURmcwZmZ3VmFXU3dmWEN4SThZSzFsRVFZTyt4UGh0eWNoZ2VoR2ttWDBFRGV4Ump2WGQzajRnNGVFM205ODlaS1NtWDA5b2daZ1VZcCtuT1VRTUU4SmhmSW5BSFZMRjVudGpuajlaMS9ndVorNFJUdXphQkxXaUJkK3BRVTRXNDhGT21mc090NmhCRjQyTFVRdEtiUE9LM0lVbW5KTVdvZzhwWnRidzllRGg0UXVpTHUwN3YyUVdTMENnNHZValJFT2tzOXltL3RNNkNRME1mbklhakd3bUx0UFRNUEpHYXpSN08yT3VIbHRpOG1rNHZoc1NjNXpqbzhkZCsrZWNmdVpQZmFtTFpkVTVyWHhObS9lci9rdjM3dEg1OElHZFM5ZmIxQ3d2QkFqOE9sdTNYUE9MRTY2TEZGSStTTDY3Z0FUUXpwNTd6c1Avc01yei9TUHRpN04vdVc2dGorR1VyVXhKbGRWVmpGRS9HckE1OHhJSlpycVBGOXRUViszUmhmRVd0T3ZGbnovclc4eTJabGliSU5Xa3J6aXZTdnNNRWVJbnNFTk5LTVJwcklzenM1NDU4NjdQSGpZTWJDaXJqVjFiU1REdTlJMGpXWThNOHltbXRGWTVzaWNaUzJVa2hna0dDWEVpVTNzY1ZMRTBnclhsZVpnOTdPTW1zdEUxNWNFMXl5Q21oalJ4cEJDSkVXUE1acVlvL2lTeGNEUjhTRlhyMTVqUEpyUkRSMDZCdHl3NHY3Umh5ejlFbHRKa0VSQzJseGx4VHM5TGh6VWx2SE9pSFpud3ZGSEo5aHlNT28xS3k2Zmc1dTV0RmlockNwcnpwTnpQMmtkRklGcVV2UE1UenpMczE5N2htWnEwSWdrVklJWVJjbW5vMWhhaVJKSkRrQ3JTN290aXFiT0dKdm9PMFdLaXFqeXh2d2laeEc0NUtUWlVZbUpTUXhyZXJGWHJQcEV2MG9NWGFSYlJXSVVRbzN2SXAxUEJBMmhDL1FyeDlCSkJ0dlpXYzh3aENkWWNMbGdCUHU3STE1NWJwZWIxN2FZVGh2bVMwOWJXeXFqaWZHRTQ1T2VqejQ0NXBYWHIvSHEzb2hicmVWR2RVQU1pYjl6NXo2OWordDg1S3d5OHd4SFQrL1FQN1dGZm5hMEt0N2ZPbXZaZmNhaUVsTGwyZExBNHNHZDAvOXlmam84M0xzeSs2WFJ0UDY1cWpKN0p0c3NLak90WWdpRWNxd2JMYk41dWtCeXI2d3BHbW5GNy83ZXIyTm5OZHZUZldLSytPREpPYk83ZDRYOS9jdU1aek51dmZnQ1NtditxMS83Mi96OXYvK3JIQjA5eG80cVR1TEFvOU1UUnBPR3JlMFIyOXN0MDFuTlpGb3ozYTZZYmxucVJtTXFSV3RGMWpsNE1ibG82N3pwQWxRWkdWek9WSGJNL3V5TGNoTWFzMUdaVWY0L1dlRzdKVGxsUW9qa21KaE9weng4OUpEVnNPVFNwV3ZFSkQ3cFRUTWlwc2pTcjRCRVZWZllXbThpbDNNQmg5UVFDUWxNWTdqMTdEN1QzbkhuOFlxcTJHREhYT2k5VCszT0F5STFEWVdmVVArUXZheXltaHRmdU1yTFgzdUd5VTVWNUw0Q3JKbmlyNWZXVWw2dFN1aWl6T0ZyV3EweG1hcktURXltVmdydlZRbHRWTVVIUURIRWN0Z2tVWVc1VWpJaFFiK01MTTRDZlgrT2Z2Y3JNZFRzblpCa2h0VkF0M0JrSCtoWEEvTXpkMjQxWFM2aVVXdDU0WmtkUHZmS0FjL2UzSlk4Z1M3SU5rY3JUdWM5ZlEvalNuUGRhbTZUdVRheFRHYVdyZDJLbitFeVI1M25IM3owaUV6TzVUV2RKd2tkZlRxbkkzOHFDMzJ0SlJuTk5EbEJ2d3daUlNKL1RJNnJWcWY5Ti92RmNMaDNkZmI5eVhiN2k2TlIvUmxqalNiR2hEWEtOYlVhemdJMkZuUldyN25TaWJveVdDMlpYdDFxem4vOW5kOGk5SkdkZHN4MHNzMXJuL2tDTDN6bU5WNTQ4VFcyZC9mb3VwNy94Ly90Mytkdi9aZi9NVldUdVBMY2pIRXpZM2RWc1RoNXhLUDNUamx1S3JMV3RFM05lTHRsdGoxaDkyRE03cVV4MTI2T2FQZE5TV3NWQUV3SENUZW9ESXdxQ1hYb1EyQ3JmWjNkeWF0aVJKbVN5R1hYa0wzVzVKUklJZUo3UjNTZTFXcE8wN1M4ZCtjZFV2YU1SMk84SDRTTlpTcVVxUmhVUkJrbENMQlJNdHBZQ0VOQytZU1pWTEQwbUVuTndmVnRmdkpLdzFzL2VNU3ZmdnVJM2tXc0xtQm1QbWNhYmxaS1BCbW90NzdaTCtiWFgzcHVsMWQvNGphenJScmx5eDVlNWZNV1g2MkpOdEsrNnl5Q1FZdHNMYXlHMWlZbXRSUzdyWFF4dkRUa2trczNiUGdTcFlpZGRDSXh3bXFWV0swaXd5clNPK0d3YXkxa21hRVB1RDRTZktSYk9OemdpRDV5Y3VybytyQzV5YWZqbWx2WHBqeC9lNGZYWDl4amQ2c1dSeU9mYUd5TlZwNjMzajNpclhlT1NEN3p4MTg2NEt1MzlyaGtOTHN6eGUzbnQ3SGpLVTQ5NE9mRFZWQ1ovK0wwRVVwTStidVlQekdoUllIazlwMTI3dE5WNkd2T2RjcmtxamJLdXcwd0Z5N3dYeEl3U2pGLzlQaWpzLytvWHc1dlRYZkgvOXg0VXYxRTNkcGJLaHZTMWlpN1J4MGhacFhpdWR3dlJrbm9yR3RacmJqbHdQR2poOXk0L1RLLzhQTy94UFBQdk1BTEw3N0NwZXZYYWRzeHErV0t2L2szL2lyZisvQ3Y4eE8vdU1mMW03dE1abGJpZ1B5WW4xaFdQSDY0SXNaTTEwZFdLNFdMaXRQVHhIU211SEpkOGN5em1la2tZVkltZUdrbkpTSzV6TzVSVWRsRVhiZmN2dklucU8wV0pMRWdGbU81akZvbklCWTdtQlNENUtJWnc5bjhsTzkrL3h2c2JPOXMya3V0RFZwYkZySGp6TThsbkhCTkZrOFNlYVJqeHAwNHpMUkNOWlpLSzl4MnkxNWI4NWRmbXZEOGpRbi95Vzg4NEwySG5iVHQ2and4TXowbFV1bkw1eHJXaWFIeVo3TzlscGQvNGhtdXZyU0R6cExSRkl0emYyVUxtcWN6S3JBQlRxMlZ2YmpKaFRHaWhJc1FvcHdnYTJLUEM5TFNweWc4OGxrdGJFTlhOUDhwd3pCa0Z2TkkzeVZpRkg1RmpvbmNSV0pseENaOFBzaDZ0bk1FRjFpY2RaeWM5dVFNazFIRkM4L3M4c0x0WFc3Zm1MRzcwOUEyV3ZDRFNyRXpzVHc4NnZuOTd6N2dkNy85Z0dHSWZQbUZBLzdFQzVjNGFDeUVSS1ZIVEdjdHBqSmN2MTRUaHBaZmFtN2lnMVovODdzUG9rcjVVUkxZNHduNmh3SmxqRlpLa1M5TkdoNlZITDVQVGFFRDZOeWcxUEQwbWlId3BJOUJCT0xpWlBpZDFabDdmK3RnOUYrUHB2WFBORTMxSTdZeE4rdHBwZlBjWlZRUmZCVUJtQThKNXpPMlZ6VEI4dk4vL3VmNXBWLzVOL25NSzU5ajFMUnlMMmpSRHI3NzFuZDU4NTIveVZmL3VWMnVYcHRDRG1UbEtPRzNYREl6bm4xeEpzVmoxTVpMekRsaDExdWpxRVlacFNQWlFYU0t2aGN3S2FXTUc2RHpoc1dRZUhIblZhNWYrbUtoNEZMQXBieTV5ZGNvVTFYVnBEcmloNTd0N1QyKysvM3ZzMWljY2V2bUxiU1M2OWVIZ1pneUQ1ZUhMTjJLdWpXYnJVT01DUmVrYXdvclQwNEp1OVdRTXRTemh1L1BsM3psd1BMTFg3M0dTMWVtL0tlLytZQmZmL09ZMHo0OFFTbSsrTVlrenJPd20vSkd0VzNGelRldWMrUDFTMmhUVWxQSkJDVmRoU3JjVmFVcExiem84bTFod3NsNlR3NnUzbWw4eUpoYVp2bmdaZjNXSjAzUW9xRXZ0aFAwU1E0Rjd4THprOERxVEpEem1FQ2xUT3dDZVFna0cvR25BMzdlNDBFRVVZTmpkYnFnVW9sQlFkdFlibC9mNHRsclcwekdWc0JjWURTUzdmZTMzanJtNy8zT1BiNzNnMk84VDN6dW1SMisrdUlCbDBjVzZ6SjJaS2hhemFNSEo2d1ducXFGNmN6UW4yYiszS3RYT1Y0TStYZnVuQ3pFaHlMYmZJNXQ2Z3dxcHFRR0gybnFLdTlQYWc2WDd0TlQ2TXZUd0hpcWNhS0h6bVVuKy9UYTRlTDZMYVNVL2NuRDFjbnlaUGgyTzdHdk5HMzFTcXY0aFFwZVJHMFVnNXYvaVZGV1dyLzB5MytKZi8yLzkrL3k3TFBQQTBvS1N0WjN6TS9PZVBQTjMrTGFiYy8xbXkwcURpV1NXUjQrbFRLcGFKNURVS0NTWUFJV1JoT050aGx0SktvMUpvV1BtbVRrUUZCWmJsUnJGU29taktsNTd1YlAwamI3Wk84MzN3T3B0UERXaUU5ZWpIaFhXbk50NlB1QmQ5Ny9BWHQ3KzlTMkpxTUlRVExFbG43Qmg2Y2ZFSWlNYkZYVVUyS1g1R1BKU0svRjlOSVlVWTBSTTBlZDVjTjU1TVdaNFF2UGJYTnpaOFQrYk1ULzY3ZnUwZmQrQThpbHAxWnI2eFZjUXZ6UXJ0M2E1cm5QWHNVRUdJNEhsRkVrcmJCN0dtT0ZKanVxTXJYSnhLeXdWYUpDYnZjMWRWamx3cEN6d2lvTVFhUnIyV1Nha2V6M1RSU2FhNG9aWTRTcGJMVXc2ZnFoT05pV24xY0M2cVBjRkNIaDVqMCtSSG92QU4xeTN1UDd5TTdVMHJuQTJXTGc4S1RqdVJ0YlpBeldLcVpqeS9ISmltOTk4eUh2dlQrbkhnSS85OG9sZGljTlYzYkhYSjgyakxKd0kzWjJ4RXJxKzkvcjZMcEkzVnF1WFRmVVd6QmFhdjdGejF4WGZjaWpiOXc5VlJHaERLelp4NGlTTmc4aHBqTmdYSnU4UGE0NFhmbC9ZclZtL3JCdmRPK0VkbVVNMk5wSUltYk1mRUt4UHhIRm5HTHVYUjhmZEV2M2RoV3piOGsvQ2xpbFpHV3ROVXByUlJmaHgzL3FhL3ozL3lmL0hpKys4cG9vQkZOUnJ4bEpVZTNtYys3YytSMjJMdCtocVFjVW9qelNSbVk4bzg3Qkltc3oybEtZYmRJTnlJNjY3T0hYeGc3ckZCUzFkbzdUaEJ5NGZmV3p2UEh5djBnVnhBeE5yODBvalJSaUxpWVR5WHY2K1lKdXRjUVl3NGNmM2VHdGQ3N0RwZjE5cXFvV2s0amdTU0Z5MUovdzF1RmJKQit3bGNFMFZpYUJoU1A1Uks0TnFyTG9TWVdwVEFrSWhLQVVhZWw1YVNMa2hkcG9PcWZwSEp4MmpzN0ZKMElmbnliS0pHQzJQK1pMWDN1T0s5ZG5oQ0dpS3cydGdjYVFhekZpYUhSbVZDV1JiV3BGYlROV0szUUFrelB0QkdvcnE2OWNsR3JESUZ6M3RmVlRTQW9mNVBlMXBiSjM4cGZuODhqUUpYeWY4SU1rcU9aQ1BjWnFuRThzejNvR0Y2VFllOGVqK3d0VXlzeG1OU0VxbG4xZ05LcDQ5dVkyczFGTjZqMkhENWQ4K1BZcGs2QjU5ZktNVjY3dmNQdlNsS3U3WS9Zbk5lT3MwRDR6bVdnbUU4WGp4NEhUMHlRbUdDVmxkbTlmUy9hZXFmU0xseWJ0MlJCKzhPRnAvN0JJVmRlMlVxazBLY1VVUkdHMFlsSlZkRDUrT2xwM0xyQ3I2cEhGOXpHWEVmV1RidlUxWFRaY09BbmpJcVJmQTM2a2haK3BTeWlxVWlvUEllZXRyUzMxRi8rVlgxRXZmZWF6MGg2cjRrR2o1RlpYZ0hjRFpuUkdxcGJrTEh1eUhFQW5KYTA5NTc3dFdhMkpFRWtZY2VVN0RGbVJlNHFRWk0yUUVBZlR1aEdqREV6aTJadC9qTGFlb1VLV25lQjZaVkNjWkhLTUVxWVFJa2JYR0MxUkNPOTk4QzRocm1qYkZwUW01WWd4R3FjU1I4dEQrcUdqUWhQN0NGTVJ0Q2lmVUQ3RHlGSk5UREhha0xJMVJtRWJ3Nk5RMGF2SVZJUExtWlBsd0szOU1UNUhmdk90eDdpUW5wRC9YaXg2MHhpZS9kd1Zibnp1TXJFWElGQnRWK2lwUEZaWmlXYmZYakNUcUhRU0Zwd0JVMmZSOU5jWjVUSnBJVGY1a0RXckZhUkZaTHl2eFlJcjVZMTU1UkFockpMa21zV01XMFh5RUhCRG9ITjU0MW1YdFNhNXlHcnBHV0xDdTBES21hT2pGWXVWNTlKTU0yNHJkbmNxVG5ySG84TUZiNzM1Z09OUlJlb2l0VFhzN0l5WVRRM2FDNjEyVUpsUnJaaG9CWU04UDF0YkJqZGtGZ3ZoY3dTZmFSckQ2U3FSSDhLVnkwWTl1aC95VGRYYy9wVWZ1ZldYeWZ4dmYvMjlvOThHeGpubnNORUpaWExLT2ZjdVpGMWJaZlEvT2MrWlB6S0ZuaElidlhCNVJuaXFsVThYUkREcFFzRzdJZU1qL0c4NitNMEtmcjVKM0I3REpDYWFMMzNseStxTFgvNEtWcElzNWRiVjVrSit1S0xyNTV6a0J5U3ZtQnBOWTVQTWo1c1lYQzB5eWMzT09aZjV0WWcva3JoYnBnQ3JwV0krRjExN00xTlVqZkNkVVo3ZDJSNVg5MTVIWXlGN2lYcUttUnhpMmJFb3RMV0VvY090T3J6M0dHMzU0S01QdVh2L0l5NGZYTHZnTTZmd09lT0ozSnZmQXpKMlhMRk9pMGhGVlZGNXYwbFZNVEVUZklTbVFwT3BLMDBlVlR4MmtmMlo0bWlST1p4N1V0Wjg1YVZMSEowTnZIMzNGSU9FT0d3aWNFdmF3T1diVzd6eVl6ZkFhUFFZUmxOTHJnUVRhR3Vad2RzU2FLRzBDSUxyRW5MUjFoSnhMVVFXUlY1QW1ndU5kYWdVUVN0eUMzMFVtNlpVQ2pnbldaY3RUengrRUc4cGs5TEdhRE92NWNzdWlwUE1mR0I1dWhJQUxrWVdLOC94VVU5TWNMcEtMQit0MEZhejN5b3UyOFJ3c3VTc2IyalFUR2VXTm9qS1RSZU53N1RSYkZXS3ZFeGtuNWhzV1hLR281Tkl5a282TXBUUTd6UE1sNGtRWVdkcTFMMHU2R2x0WC92bEw5Nzh5MmREK0Y5OC9lN3BtMHFwU2M0NVhSQUZab0NWaTJuMVQ5QkQ4bzlNb1FPczVuN0RTQUt3WXZhU1UzcmlJdEdmY01QSEFPOUdlREJrL3Y0eTgvSnB5cytQalBtUkwzL3RKNzk0L2ViTnFWZ3l5U0FvODd1QkhBa2hNVi9jd3pTSFlEVGVTMUZUWnZDMVIxb3VwaFF4UVZLNitOYXBUUStiWWlGc0JJMHY4c1NjWU9qQkJVT0lIYmN2UDhla3Zjb21nU0RuSW9vUlNqRGVvVERZcWthellyazRZYms0NHp0dmZwM1Y2cGhMQjg4TG95OUZsTllZcFRsY1B1YkluYUtNUlJrdGUrbWMwVnFqSnhWVnJVaVZJZmd5c3JSV0NrRzJlRGlqZWVBVW53RVdRK1JzNWNtNjR0SnN4TTk4N2hySFM4ZkRrMjd6b0t4YnJNbWs1cFVmdmNYMnpSMlVnZEZJMGsxVGxqWjhiQ2tjQjhGSVVwZkpyZG9FN3VVc2dGd01paGprcG5hMUlobUZUZUI5SmxYRk9kY2x2SWRWaUtKdTZ5UXdJU2V4L25VK2liVllFTXV0NUNQOTByTTg2WEFyUjc4YUNFR01TaDQvV2hTclpsZzV3QWNhQlplcW9vN0xRck90SzhQdXFHSzN0aHoxQVdNMU85T0svYkVoTHhOZG56allOclFqemVORHo2clB0TFVtYXlXZFRhMW90R2dBT3Bld3ltQ3RWcG1jOTQzOXpGLzQzUFYvODdUMy8rdjNqbFlmYXFWUzJzVE5DdG54M0RyMG44eU8vWTlVb1Y5czQ4dG90Z2tFTjFid3FxZGEraWM0dzFseXB4OHJwZnFRODV0Zis1Ti84djVQLzhJdjNoeE5wbE14V1hURkNpcWg2Z1pTWnVoNlRrNSt3TmJvREZPbmNySUlxQmFDS3Nqd3ViVndTa0p4Mmh3N0VaTExlRmM0MlRuVDFxS3NhbTB1QXBiRWtEVDdXNjlpZFN2cHJHZ3dXdHJwS0lVcnJKVkU2QWRpekd4dDdYSnllc1MzMy94ZFJvMGl4bDdNYW0xRGlna2ZQUGZPN3JFYU9pcFRGekJQYjVob3F0SEV0aUd0TndYV2lGeFdGMVdZaFJRVVE4bWJuM2VCYmtoc2IybjZFSG4yOG93M250dmpiMy83UHRxVlZGQWxEL0xOMXk1ejQvUFhpQXFxUnJZWDY2U1V4Z2hRa1ZHNFhxRkRaS0l5bzdGaVZDVXlvaWQzWGxEekROaEdySk96VTVpWXFhSmtqWWNBeXg3TzFqTjRUQnR0ZVF4eXF4SWtnY1VIU1p2cEY1N0ZhVTgvSHdpREkvaEF6Sm5Ed3lXbnArNUo2K3UxNTNxRWJvaTBnMmQ3UE9MYXpwaExXeU5jU0tKS2RJSDdIL1g0VWNXc2JSaVBGZlhZY0hnYWNiMGt2MEFtWlBHSXE1THdBTG9pRUZvRitiUEtLbDFWU3IxOGVmSVQvOFpYYmcvL3dXKzgvNys3YzdUNlFDazF2aURkWHUvMUk5STFab0QvenA5NGp0cG8vdmUvOW9NLytIYUxQNklmT1lNZjVLWmNmOHJXQ21QVTAwaThLK3ZkSHVpVlVuM08yUnRqcXYvV3Ivd3JMejM3ekswRGhoNzZWZDU4NFRXZ1pDMnJ4UW1MNFMyVURxUW9xeFJqRU1LR3ljVURUR1J4TXBLTHU2aVBXZ3dXRmVpNk9FV1hrN015YStOSWlSdXFHOC9COWk3WDlqK0QwVFZyYjdFY1l0bWR5ei9uRUVraEZEKzNURlczbk0wSDZuckM3dDRCMWpaWVc1TklaQVc5NjNtOFBNSVlROU9JSWl4cFJWUnE0d0lUUXVhaTA4VGFyMTZUcWJYd3doZE8wZldLczJWa09RU3MwbWlsQ1NueEU2OWU1cVViMjdqaWJrck9USGRHdlBCanQ2Z2JRNnN6b3pMT0dDV2srUkNreUczSTZGT1BYVVZzeXFndWxRZ3JzWUt5TmhkZnRRSzJwVUorUVZHZ0VnYVhPRGtOTE04Q3F6N2luWGdSeEppTDMxc2lPTEdHeWpIaitraTNjblNMbm1IVk0vUU9IeE9uWnoxSFI5MmFjdjBFVThVaTFscldhQ1p0elhQWHQ3bDVaWUxMaWJrUEJCZTRkMi9POTk5OXpPOSsveUhkNExsKzBMQllCdWJMUUZVcG1sWVhsMW1LUkZXWWlaTkczb3ZPSlZ5UVE4QVlyU2ExYWw3YW0velVmL3ZIYi8vcnoreU5iK1NjRzNYT05LNEFRODVhQmhkVVcya3FyWVhhL1dtNTBUL3BJd2JRUmk1VHF5QUp0TVlGNnF3SG5GSXE1Sno3VjE5K2VmVGFhNjg5UDZtcVdRb2hhMnRWVG1rei9PY1VTU2x4ZlBvaFR0MHA1b1hDeFVaSlcxNlVSMFdNVXZiQVd0SkFZcUE0akVwd1FMWVpQWUdHdkNHY2JMSzVDSXhHTjVpMnQxRnh2VFlRaVd1T29TUzNGRFRaQjVKM2FLVllMcGE4L2M1M21NMW1YTDUwRTJNcjJaK2o4TjV4TXB4eU9zeHBSalcyMWlYTVFJcFhsclFsa1FRSlBzaGExbEVLaFRLeWg2OG1GYTEzS0NMSHkwaUtNS28waW93UHNEV3ErTm5Ycm5EbmNNblJZa0RWbGhlK2RKTXJ0N2RwYTVpTWRNbWVrMTlhWnhvTDlmcWdyTmFCR2huWGEvUUFiUzFlYnFxa3JhUUlRNVRBQ0tQRTJqbGs4RnJSKzBnM2QwS1lLVzZSMmN0SWtBdm1rRXVSZXhkWWxabThtNjhJem90NzZ4QjQ5R2oxaWVvMGpUZ1JUU3JGdEszWW1ZN1ltelc0bkNXblBXU0dWU0FGMmRTY0RZNjM3NTh5YlMwcVM0aWlNV3B6c0l1bnUwWWwwVFpVR25veWcwdlVaYlN5bGNKbmxXdkwrSldENlovKzVTL2VmUGgvK1kzMy84cmo1WEF4bkRaZjBCY2xoZUswYzFTaTZ2bjAzT2lmdUlvYk1sdEdNYk95RnF1c1RVOHhNMU5LS1FIcEwveUZQMy96MHZVYnQyWEkxdWUzZUU2U3I2WTB3M0xGUi9kL2cxdy9KQ2RMRlA5dG1SbHptY3ZYMU0zaW1ycHBVYXRNVzJkR2RjYWF4SHJzdDVYd3VpdGJRZ0dOL1BuTzdGbXNiVW5CRVZjZGNiRmdmY1ZtclRjemUvSWVQM2h5VEJ3ZkgzSjZlc3hzT2hiR203YWdERDU0ZlBSOGNIS0hHQjFXUytGcUxlUVVYUklWVTBIK2xSRlRES3VnS1c0NjJxb3kweXZHVmc2SCtUSlFWNWJ4cU40a3JnNCtNVzB0cjEyWlVWdkwzdFVaTC8vb2RTWWp4YWlWZjErbGpGNWJRYnRFTlVUR09qRWFaYVl6cUZ0RnFqWDFOdFMxN0xwOUw2K3RIMkJZaVFJdFJqQ3NFMHFsbTFzdEF0MHF5cnkvUm1kenNXNWVXMWVISklqN2ZHQjUyckU4V2VJSElaeUVHRGs4N09pNjhERlRDVlZJUHpPam1FMHFadU9XeWxhY0xqM0VURldjZkkzV2pJeGhWRm1NMWJ4OS81amZlUE1odll0TVJySnpUeGw4NmJGVFNyaDF4SEp4bmswSlZsN2NlNXhQK0pqVkVKUEtJVysvdURQK3hULzdtYXQvYWxMYlNaWWtxOUdhZkpoek5rb3A3V1BpSDd4N3hQLzFOMzZVZi9PLytTOS9lbS8wcHp2N1AvNmxML0M5ZCsrb2gwZkhXVnFtdE9GMFdHUHRUMzdsS3k5YzN0Ky9RbDJodFZiclVBWUpVRlFrcFhuMDhDNG55MjlUN1JsODBpaVZNSWcrVzZTUkZIQmxrek54Ym9Tb2l3Q2p5TDIwVXNTa1dYY1pHVlVzb3hMV2pMaTA5VG1NYXNoNWZaUExxaXQ3WDN6cU1qa2tZa2k0b1dmb0J6NzQ4SDFTOXRSMlRJeEJYR3UxeFh2UDJYREd2ZVY5bWJrTDBxd0x5NDhvdkt1RWFPV3J1Z0JFa2o2TjBoSXdhQ3BGV0NYcUpON3U4eTR5YWl0QjQ5ZEVDeU8zNmpON0Uvb0k1bk5YbU82TlNDWFdxTTZaNUJQUmlsWHlzRXhZazVodWFaUld4RzJOaW1JWVVUVVpuVE1COGRTTFNURUVzY1JlWjhybndrbUlUakxUNWtlZWJoVnByWmIzcGpBU1UzRzRGREpUd2kwZC9XTEFMWHVTRHdWQVRSd2RkWnpOL1NjNngxVEFWTU9rMVV6R0xWdlRsbXU3SS9hbURUb21GcWVPRURPMk5sUStNV3RyZ3M0TU9YRnZ2bURuVWMzT2JJK3hNcmlRNUhXVmlHU0drTVVDUEplUVRhM29YYVJ4WWs4ZW85aFFrM1BlYXV6Tkg3dTU4Nit1ZkZ6K2Y3NXg5KytFbUo3WU5DVVozdlBiajVkNWIvZHY1N2I5ODUvK1FqOHE3ZGQvL2MzdmltUHJrNzZRR3VBbmZ2ekxCOWV1WFgzVldqMWVsNml5Um1EOGtwS2FZdVNERDc3T29PNWhraFh2YlNWRnV5Wmt4TWdHRVpiZ0NJWE94VEZHQ1habTZ2UGRjbFdBSnVlTE5ieldKQVoyUjdlWlRaNG5PVTlZTFdtbjJ5U2JTVDVzaURlRVFPcDdYTjhSUW1DK25QUCtCKzlzUE5DVjBtaHQ4TkZqamVYeDhoRmQ2ckNqR2wyYm9nWUVkYUdOWEhjaktXWnNFa3FxeXpCcjVlYVBLVk9GeUw3S0hDOGlaOHZBdURiRmJUVnY1TFhTS21WZXZiYkY4WUVVZVhRSlcxblprUnV3Vm9JVjh0U2dHMDFTSWx4eFNXR3R2R1pERDFoTk5nSit4U0xiVFJyd21WeEoyeTVBSFN3V2lhNFhYb0Vmb2pEaWxGaEpSWmRJTG9yQll4L29GZ09yK2FyYzVPSXBjSEk2Y0h6aVBqYVhyMXZaR2hnYnhlNnM0ZGtyTzl6WW16SnVMWTNWck9hZVlZZ2IvM3BiS1ViR2tvMG1LRmdzT3Q2NmYwSlRHejV6WTJjamo5NWNCTVYxSjRSeU9TZ1lOeHFGb3Vza2lHUWQ2cEJDeWdmajZ2bWZlbkgvdit0aWRQL1JOKzc5VnhlNlZJbWhsd1ZOOHM2cDczL3ZlN3h3TU1zL2VEei9kTGJ1VDF6cE1hNm5HSlZTV2hlNUFleS84R2YrOUFzSGx3NWVKa01PUVhwdFUxMUk4YlFzVCtiY2Zmd043TmlMWlhGWkVLL1AwblZTWnlwOGErZkZ5c2lYQkZWZHlUdnJ2Q0o0Sld3b0JKU1NiRVNoWXNZWTJScS9URjN0Z1Eva0dJbDlUM2Q4eUhCMlF2U2VOUFJrNy9COVQ3Y1N4NXNQNzM3QTBka2pSdU1SVFR0Rm00b1lTMnFMMGp6dWpvaFpZcFd0UFgvSUtpTzNkeXB0cnJheUN2U0R2RjZobUV6STRRRk5nakdaUjNQUDRETmJveHByVk9IS2l5ZTZjSG9NSm1ieWV5ZW9oVU1CZFpHdWFhdW9Lc0VCYktWUTFYa0VsY3BRR3luNnFJU0FKRjhYY2lqWWhCSHdiUWlLYmxETWw1bXpaV2JWSlZMSlNrdERKQTZSSEJMZVJYeGZDbnpwV1oxMXpFOFdyT2FkcU5KUzR2UnM0UEI0d0g5Q0R2SEdhOTVxbnJreTVmTXZYT1dGYTl2TUpoVjFiWmpXaGtsdHhHSWNDRDVoalFCaEk2UFpxV3ZHVlUzWERYejMvY2Y4NE9HQ1ZGSlQrMEhrc1RGbGtjcUdKRkpwcFJoWkxXdkJmRzYrbVZMRys2eFN6UG42VnZQU1Q3OTA2Vi83NlpjdnZjNTVDMStYWHphRFdxNDYvdDdmL3cyMFZyeDhaZnFwYjkwSklheHpza29TanpJNVo3MjNzelA2N09lLytOTHUzc0ZWeWg0M3ErTGVudGRuZmVMK3ZYZFo4QVAyeHFhQTRPTERyZ3ZnSmpIQ3hXTzhGSHVLSmNUUGk1V1Vyb3QzT05KMnBndnR2bGhJUld3MmJJMXZZMklGeWRQT2RzbE9IR0V5aWVSN01aVHducE9qUjZ4V0F6SEIrM2ZlQVJLejZUWkdWM2p4SmtKclErY1dISFhIOHRDV2xCQ2x3QnJoWFljU1F3VEZEYnZjOExVUnNFajgxQ1JXYWtMR2hNeWpzMEJsRFpPeEZmUzRJUDlLS1FZWFM1S3p3bjEwUnYzZUtYemhnTnFLTDl0UXN0bld1MDhTR0Z1SU1tWnRvaW5hOGJVcVJpY0VXVWZHamhoa25SazhyRlpaNUtaZElEbUp4akVsaXo1NFdhUEZKQURYYXQ2elBGblFMVHRpakdpbFdNd2RqNDhHaHVHSFcwUHROSlkzbnRuaGplZjMyZDhlQ1ZQUUtCb3R4ZHh1TjZnSWgzUEp2eFBLdEdBMFZUTE1taHJmT1JhcmdUYy9lRXhWR3k1dHRSdlZvWUJ4WWxCYVZVS21jazVjY2RhaUtQR2xseEhPSmpHSnZySGJ2dkZUTHgzODhrY24zYVB2UFZ6Y3ZRRE9sY1lxNXk2U1R6ckh3YVRLbi9wQ3YzQTR5OEpJS1oxelZpODkvL3hzWjIvL2RqMGExOG43ODlhNHhHVW9xNG1ENTRNSHY0ZmFPaU5wUzR3WlhaSVNWUUs3U1g2VU45WWdyb214SytTWURIMXBXYkV5MDZkYXlTMWYzaFVkTlFsSGF3K1l0Yy9BRUZER2tQeUFNWlo2TWdPbFNINFFTbXZvV1MwWCtKQTVQRHJod2FON2JPOU9xYXRHNG9CaXhOaUt5dFo4ZFBvQlhWaFNvZEFsR1JTejNnbVhvdCs4UUZLc3FUSmtyYW0xSkN6NlhxSkRkcU5raDUvMW1mSElVbGQ2ODNKcEkwa3ZMb2pQUGdwSkpmbG9qcm8rSWV6TTBNWEtHa1N3MGxTQ1d3U2xOczZ1cVpnNXRqYWhWU1lOMHJicnNYelBzU1N6cEF1M1hCZ1NiaFdJZytqS3MwbmtxQm02c0VsYTZjNTZGaWRMdW1WUEtsa0FYUmM0UFA1NGthK1Z2MFlwbnQwYjgyTzM5M2poNm94SlkwdGJiYkFvUkZhV29WTHM3ZFprQmFlcmtqQ3JJSFNaV1BnS2swbExud0lQVHhkOCsxM05aNTYvekxYdFZ1S1lsT0FPeHFxaWx4ZldseTRNd1pnZytWU3N2WVdocVJTMGpWSXZIRXgrK21kZnVYejN1UE4vNWVGOHlCYzQ4WklObVhJOFdia2NVMUtqeXVSL0hENzhQK3VGL3JFeDVQclZLNjBpN3lmdlNDRm0zVFJxemJITktVTFdIRDk2eUtIN09wTjlhWVBSUXE5TVVjUUlNWitIL1NrRnltWnN0V2J4eU0ya2tNaWpHT1VOeWg1aURhcVZhelFrOENHd1A3M05wTDJCRG9xY1E5RjVKNUx6QXJEbENNcWlNSXpHVy9RbkozeDA5dzdhd05ac1N5U3NKVmt5eG9EWGdZL083aEt6N0xzeEpmKzhDR2NnRjVjZFdkYzVuMFhhYVVRZkxsbDBtYnlTTUlTOUVKbjNrZVdRYUt6TTV4ZjlUOWJvdHRXYW1LV0ZUVU5FZi8rWXhWN0RaSyttcFNUZVpOQWhrMXlpVCtBTUltd3g1L3RxYXlGWVJlODBsU3Q0UnlyT3VLbXNMWWRVL05iTGVySkVieG5FSVNZc0hWM25tUjh2R0JZZEtpV00wYXhXbnNkSEEvMkZJci9vVk50WXpSdTNkdm55Qy9zY3pGcnd3b0tiMVphMnRPZ2hnYTVFVk5LMGhodFhXdXl4NW5qaFVRa3FwU1M2RzZqYm1yRnZXQTBEOTAvbXRCOVY3RSt2TUJ0VktDVW1Jekk2aUhweHplc01VUXBlV2gzQk44cm5sYzNrVWFXblg3aTIvY3VIQy9maFgvM1d2Yi9lK2ZqMGRpbUhtUExKeXVmVzZuLzg0dmdVZktpY1JXN3lwVGZlMkQvWTJyb2tpTmc2TmxSa2l6bEdjc3JjZS9BMmc3bVB6cEw1WmF6TW1hcVNnSVpjV3JTazVWOUZLZlJZVWUrQ25ncTlFU05lYkNYN1QvSzdseEFYYTVPWVNHTWJydXgrZ2Ric0ZqR053dGlhSEFKS2FkTFFFWnlZRXZyQmdkTDBROC94MlNHVFNVdmJ0T2ZoMlJoSWtkUHVrTHVMdTNJQVdJbEVFaTY3V2ljOUY5ZlhMRTR1aVB2cCtzdXNZNU1kTUIwQ2V5bHh0RWk0bUdpSzNkTTZ0U1pIUWJjSEh6RmF5Y05aekJMMW94WDV6U09oQzF0RjNVSkZZamlKdU5ORU9JME1oNG5jeVFHcHl5WWpSVW1hWFNYTmNhL3BuRGpueHRLMlI1ZWt3QXRkMlpUVm9QTkNWdzRoMFErQnhjbUM3bVJCN0NYMFlyNXdQRDdzNmJyNEJHbDBUUlc2dHQzeTA1KzV5azk5OWhxWGRzYmtsQmszaHIxcGhjMlo0RXNZUjFuWmljQXZNNW9ZOXJjc2RWSDh0WlZoWEZrYXJXbmFpdGxzVE5zMm9EVWZIWi94NWtjbmRFRkNRVHFYaWpNdTJGcWpyV0FuS2N0bFVWV0t1dExZV2hPRFlCTERrRlNLbVVsdDlyNTBjK2N2dlhGait3V2dWa3ExRjhnMGR0MGNEREdwdFJyeDAzNmpxMkpha0FDMXY3T3paeUpiODhNNU1YaVVObFIxaXlwN20zb0t3UVVPVHdPTDNsRFhtYWFXbWRwV3VVVHlLalo1emlXalN5Ri9oM0ZwMzRNU01HbklKSzgyUHQ2cUFHTXhlTGJHdDdtODh3Vk1zcVRreFBKcERZVWJBOXBpamJqUm5wNmVjRFkvNCs2OWo1Z3ZUOW5iazlzOHhzaHlkWUsxTmRQUkZtL2ZmNWVsRStucVdxVWwzWWZNd3JFa3ZhcXliODVKd0NCZENqaXJ3dkxMY0NORWJNdzhYb3BTYTlSVW0xRW5GYWxuMXRDNXdLVFdzdFlxTE0yVU12SE9uTzc1YmVxWEpwZ3FVaWNZU3F5MU1WTGNWaFcvZXlWcEtobXhlRzVzb25meWZmalNEUXdPRnF0RTV4SXhTaGVXZkpSdUxDU0NDd3lkWjNHNlpIV3lJQXdESVVhNlR0aHozaWRoR1Q3VnNyOTZkWXMvOXVJbG5yMDh3UUNwajB3YXc2UTFlSjhZQmluTWNhT3ByTVJ6S1NVOGdaZ3lUV3U0ZHRCdy85QnhscUk0d3lvWXlOUnR4VGkzNk5yU084ZGJENDZaakN5dlg5dkdLS2hyQ2JaTTVkZ1JjRk1WNHBhOEhubURoNENUdVYwNUY5TnVVNy95MHk5ZS9zdEhLLysvL043RCtRZEtGWWxGT2ErTDBXTCtwRXozVDJPaDV3dnFILy8rbmJ2SDc3NzNZWGYxU3NDN0lWdHJWVnVQTnJMUnlhTG55dFkxckwvS3ZaUDNhRWNWZFFOMUpjYjgxbWFxd3V5cXpIcVZKa0JkcGx5c1pLSVJBWWF1WlU1V3FmRExqVVF1QlJlNXZQMUZ0cHZieE5WQWlnR2ZaRDVYS2pNL2ZJak9tWFkweGZjRHh5ZEh2SFBuZmQ1Nis3dG9teG1OcGtJYUtlbWZiV05KT1hMMzlKNDhpRWFNSVJYUytsSWFsNElGQ1FpWFNodmZtTTErWDJWeGZ6RStjcEFpcDMxaXZvcU1TbHJ0T2xQTnUxU28vR0wwb0pYaXJIZkZxa3FqTGZpbEozejdrSEN0WWJDYXFWYlVqU0k1RWF3WUxZQWJTWVF1VmhYNUxGQ3JKUDFHZ2o0cnVnRVdpOGhxR1lsOVFrWGhzWXREckt6aENCbTM2T21PNTBUbkNURnlkdWFaejhWMDRxS01GbURTR0Q1M2M0Y3Z2M1NKL1dtRFZqS0RqeWVTRmFkVHhvZUVYZWY1YVFGV2xaSjFtbTAwemlYcVZyTlRWeVFGdzRQRVNudHhyNDBSYXkzanBrWWJZU1lPZytmYkh4NVRhOE9yMTJmVXRleHJCeWNnSW10MVhjNllTZ3hBY3BLMXFDcitkajVrb3M4NjVweGV2RFQ1eXMrOWV1blBIYTZHLy9QaDB1ZXlxMWpiMVJlemxvMjE1UThGNTh3LzQxZjVldnd3U2lrTG1QYyt1T05lZVBhNTZ6dGJXNS9WU3FDUEVJWHVLc0gzZ1ozWk5pb3B2djdtNzVDelJqVkczR09pZUphNUFMMlRjQUMzempiM2luNVFkSjFpR0RSdXpaN2JMRkFGcFZkRzQ1TmpNcnJPcTdkK2labTZodStYeEtHblc4eGw5MndyL0dJaHZ6dkhjcmxndWVwNC84NDczTG43RHBjTzlwbE5kZ1NzaTRuS1ZvemFDUS9uRC9udXcrOUl5SU1XMTFsZHRKN2FpbTQ3WldHZWFRU0Zsd2RRQUI4N0JMSkxPS1c1MW5sZVY0bDdKNTVIcDRIS2FrbGxpVmtPcnJLcVc3ckk0M25QMXJqaGRBaFlyUmczbGVpRVE4TDJrWHEzUlIyMHhaOWREZ1psTmFuVnhGcVRBalJhSHZDRlY1dkhNU3FGUzdJejc4OEMzVHpnUTJib0FuNklZZ25GZVRaNTlJbnVaTUZ5TGx5RGs1T0IrVHhKb1R5aEJvRnIydzFmZnY2QXI3eDRpWjJwQ0h1YURMUEtVQ2tCNVhSNVhacmkyVytNb200TXU3dUd5ZFRJelcyVlJEMzVYQUEyemVCbHRIQkJLTlZWWlRCS3k0d2ZJNzF6blBXQjZhaGhlMUlWaDFsUkRJWW91M1ZqWkVZUHNVaUsxOXlOa1BFK2J3eUJRZG5MdTZObjUzMTQvNFBqN2s2VUVUVSt0V2YvUjZMdi8yd1grZ2FwS3NnNzJMUEZ3cDJkblp4ZDJ0OS9ibmQzOTVvUEFhMnQwa1pMc1NjeExyeXlmNVVQVDkvaGNYOGZZMnRpYVozV0tTQTVpZERDQlVYdjVkZXFVOHlYc1BJYTV4VEJ5YjQ0ZUVsbThkN0kzalJsbnJ2Nk16d3ovZVA0NHlVNUJrTHdrQk5HRy9xdXd6dlJSNjlXSGQ0SERvOGU4NDF2L1M1S1I2NWR2WWxTaGhpRElPMVZTd2lCTng5K2g4UGhjUUZ5eWxvZ0preHRVRVp2QWdMek9oSEdGays4V09aMUx6ZVl6cG5QK3NCMnp0dzU5TGdvK1hTVlh2UC81Ti9WUm5PeWNod3RCcVp0emZIU01Xb3M0OGFJc0NTTEpYT1ZGY051U3oyeHdrbXlpbXlWK0w1WjBRSlVWc2hJS1N0aTFNUUlMbWw1WW9NRUx2UmRKQTBSNXpLaHpMWXhaWHdmaStUWE15d0hYRGZROVk2VHMwQU1UNmJIV0sxNDhkS1VuM3I5R3E5YzMyRmNTNkJpclJRanJVaysweGZTVlZWcGJLWFdmVEJ0clJtTk5iWld1Q1JjZjYwVmZaZFpyaEo5S0dOZDBROGtvK2xDeE5peWMwL1NqQ3VsNldOazBVVW1WVVZsSkpzdFJIbjlBWHpLTEZ6RXgxU2NjUXUra3VTYVhpY0dLMFd1akI3ZlBoaS9lSC9lZit2ZTZYQllXcGI0Q1FyT1QxK2hDeEt0MUZNY0NBM1krdzhmSGowK2ZIUm5OaDdmM3Q3ZXZtS01KY1FndXI4VTZib1ZiVFZtT2h2ei9idmZFaDF6b2IvSmZDc3pWWWpuZWJiSmkyOWNOcUplaTBFeExCT3JGU0pSSFdEb0E5NGxucm44NDN6K3hsK2c4aE15Q1dObE5tK2FNU2tFd2pDZ3RTNDJPcHJsYXNVUDNuMkhiMy92ZDdsNjlSTGowWlFZQmFFM3BpTG56S1BUZTN6bjhmY1p3aURSdkZwa25VWkxRVzVzNGZNRi9lWGFtcWxZM21pZ2kzQXBKTjZ3aVVVWHVYOGthU0sxVnFqaXQ2Wk4wVlVEeDBzbjlFNWpPRnowVE5xYXVoQS9FcGx4YmJFdWNSWXpvMnNUNlFxMHNBS05LY2tzcXNoMW84WmtNZlJ3U1JHaUtrWVNtY096aU9zVDJxZHpBNUtjY1lVUlI4NTBuV2RZRGZTcm5yNzNMQmZuYVMwS0dGbk5hOWUyK01uWHIzSnJmMEp0RkFiRnlCcEdWcE45cGgraUtLUEszdHdxRVo1TVJwYTZsZ091ZHhrZk10WVl0Q25PUExsUW81VmkzQnJCV3JRY0NLSG8vMGROUlYzWVN3azRXM2E0bUxtOFBaSk1PUy9ZZ3kwdXhkYkk0U3B6dkJpR2FLMDNxY0hXS0twS0pGSk5iV2FUcGpKdlBwai9kdWNUNmlrVS9sTjdvOCttVTR3eHludC9NY0o3UGJUYmV3OGZQbjduM1IvOFlESnFka2R0ZlQybVdJWGdWQ2pTMEpnU3oxeCtqcFA1TWUvZC96NlZOZ1ZsVmtWNXBqWXJpWndrNUMraU43ejJ6VjQxeU1QamsySjM2d1pmZVBIbitmenRmNEZ4MmllSGlOYWExZkpNQ2lOR3V0VUNhK3RDK0xGMFhjZEg5ejdpMTMvalZ3bHB5YldyVjdHbW9hcEdoUWdqUmhodkhiN05uYk1QUmZlOG5pa3JnNjNOZWZKb2dkWEZrNmlBUDFIWWZlSzJLclAzajZqSWpSb2VuQWJPVm1KMFNibXRsQlc5ZWk2YzhydkhTN1Eya09GbzFUTnRhOXBLaVBRcFplcmFTTnh4SHpGWHgxUmpnWDEwS2ZEV2lwb3RKaVczYnk0NzlQVzJ3c055bWVsV0VSUFRaa2FsakNDaEtOTkVDT05aelR2NlRnd1lWMTNlQUc1YnJSQmd2dnJ5WlM1dnRhaVVxYldtTlpyYUtrd0d5cXBRYVVHN1I2MW0zSXBLS1FMMXlERGJhcGxPTGJPWllXK25ZVEp1c1ZxRUtTVFpqMnVqbVUzRXdDT21UTzhpS3hld1J0TVlJd2R1K2JQalpZOUtpdDFKU3dqcjdZY3VLamZGZUd4cFJxYnc5em1YTUNjRUdNeWJ4R3E5MWRnYk9lWFZPMGZMTjRQMCs1R1BaN2g5dWdxOWJScjZvVWNwcmJUV0YrV3FhN0JjSDUyZEhYN3JPOS82WnJjOHJtSncxN3ozSSsrZGlpbXpXTTRKTHZEOGpkZDQrNk4zK1BEUlBWUTJJajJsTU42OE9JM21JcCtVR1hpZGk1WlEyakNlYnZQcWMxL2hqNzN5ei9OakwvNGl0MmFmSjUwRnd1Q0lJZEIzSGRaWVlVQVZKRnkrYjhVd09JNlBEL2tIdi9YcnZIUG5UVzdkdkVwdEc1U3BwUXRBVVZVTmM3ZmdtdysrelpCNnpOb1NxOGdqVlhHNlhhZjRyYjA2b2src284clg3VTVFc1RjRTNxaWtsZi9nb2NmNU5SaWwwVlpRNXZWNnFYZUp1OGNyMmtwSUpaMVBURVlWMDlyaWc0QjFrOFppdFdheGNPUlp4ZWpLaU5abWFnT05sVUlIY2V6TUdYcXZDR21ka3lZc09EY2tWTWdNWFdJb2JmVjZPNUdDRkhwd2E1MTV4ekFNTEphQllaQk81TktrNWdzM2R2aVI1dzg0MkIyaGNzWW14VWhwNmpXZm9PakJYVXpZV3JNOXE3Qlc0V09tZHdsdEZFMXJTeHBNb09zaTg5T0IwNU9PNENPbUZvUys3eUxXS3JhMkxaT3hrWFNZSWVGQ0t1NDZScm9jSzNyK3dZY2lMN1dNS3N1b05vVitMRFA2ZUtLWlRnMHBnUnZra0VzNVMreFhhellxd2h5Vnlvbm11WVBKQzJjK3Z2M080K1ZIU2luMUNjWCs2U3Iwd1RtKzhQcG4ySnBOZVh4MHRGNHhYUHhCazFKS2RjNTNiNzd6L2pmdmYvaURvK1haMGFYangvZG5qeDdlc3lmSGh6dzhmS3dhMC9EOHRkZjV6bHR2ODhHOUJ3eGVRSllVcGRqN1FSN0U0RE01Q2gwelJzWGU3Q2FmdmYwVGZQSG16L0xaeTE5akoxOW1kYmppOU9pSTFYSkJTaEhuSFNrbWJOVlExeTNlTzRadXhlQUc1b3N6bHFzbGIzNy9PL3o2UC9oVjlnOW03Ty91Z1RMU3JxZUkxcExYZXVma0R1K2N2QStxc05DS1piTXVEMHhLNTY0OFlzS29OaXVpOVhXUWlxcnRGU0xYdFBpbFBUd042SklEVnhWRzNIcUZabzNoWk9sNGROb3pxaTJyd1pPQXRyYU1hMHZ2by9ERlI4SWpQQnNDNldCTXRUK2lxdFRtMGRQRkNBTUZ6c0ZpV1JScldiSHFNOHRWeEErUnZvOTRMMDQ0eGtpUVhneHJjNGxJMzNuNlJVOC9YOUozanJPelNLTTF6KzIydkhGN245ZHU3YksvMHdvQW1SUzFna29WdDUwUy9rQ1NuM1ZueXpLcU5WMHZmbTZqVnRQVVdoU0lVYnFMdmtzTVh2NStYZW15UHRYVWphWnREVTJycVd1RmQ1bVRVMC9LZWFNZldOLzhXWW1TYmJIcU9GNE5iSTBhcnU2MVZHSUtRRlVYODlGQ3ZmWk9mbDV0RkcxcnhMSTdVa3cyTWlwa2xGR2p2ZTFtK3ZiRDVlK2Q5YjVYVC9vby90Q2IvWjlwTU81UGZlMVBNbXBINnExMzMzbWFIN0grNTdRKzlSNmRMdDk5Nzg3NzM3MS83NDYrZCtlZGd3L2UvZDc0enJ2ZlUyOSs1K3VNcWhHZmUvRkxMQjRQekIvM3JFNGR4eWNMdWk3aVBIUXUwZzNpVjNadDl3Vis1S1dmNWF1di9IbHV6ejVQLzhoeCt1QXhKNmRIZU8rSUtlQmNoM2V5NDExMVM3enorQkR3M3JGY0xUaytPZVRrNUlpUFBueWZ2L0czL3hyS2VwNjVlVU51cnVBa2VyaVpVTnVXcmwvd25mdmY1WFE0d1JoeGtURWxja2xyVlhiK0FyaFJUQnVWV3JQcEN2ZSt5Q2IzVStSSGRNWW11SGZvR1Z4bTFGaHNKVjJDZEJ6RnZsckI0WHpnZE9Xb0s4Tko1OUJHTTI0cWpGS0VLR3kwVVdNSUxuRVNFdk90QmpPVGhCT2x4YTQ1Uk1tUDl3TzRRVkpYWEJUQmkzTlNWSXRsWkJoUzhXUVg1WndmNURXUElSTmR3SFdlMWRrSzEzVXNsaDdsTlorNXZzMFhuOS9uOXVVdFp1TmE5dFV1WWFQRVFDdUVOeENqaEhBMHRXSTBOaWlsV0M0REtjTmtMQzI4YzhVVHZ2VEs0MVpUTmFxRVlTaGkwVW5JdWt4bTZITHVpNzlkRnQzNldpTlFXMDFsRENGbkZ0M0FvaDlRV25OamIwcmJHZ202eUFybmhkY3Z2SGhOUmxFVm1iRHpDVjlXakVuVWhLcXF0SjZNN0tXdGNXM2VlYno0YnUralUwOWFvcWRQSGVyKytkYy9ROWQzM0x0L2QwUHkrQVFrTW9uMFJSa1hPVDFjdXJkT2w5MThQbDljT2owKzNMMTM5d1AxblcvL0hzTnF6dTJyejdEZGJySFQ3UFB3N2pGdnZYMkgwNU1WUXgvWjI3ckVWMS8vR2w5OTlSZTR2ZmQ1M0VuZzBZY2YwWFVydERGb3JYR3VKOFNBd2hCaWtPeHlIemlibjdEcUZ2UkR4OG5wQ1RFazduendIbi83MS81ekZ0MWpubi91R1dyYmlFNCtCcXl0YU9veGxhbjQ0T2dPYjk3NUxuN3d3azVyTE5aSTdKTFNGNG85RnhwRktXNnplUmd6WVpDUXhpL294T1djT1Q0TFBEenhWSlhDVnJwdzFjR0hnZ3FYZGRMZG95VWh5U3FvQzVHMnFoZzNWZkd5RjIvMlVXM28rc0RwRUhoa0ZIYmFNcG1Zb21rWEwzWmZvcE5RWlNUS0pWekNKVmFySk9FTFRyVDR1dkQzL1pBSVNSeFkvUkFZbG81K3VhTHZQZjNLOCtMZWxDKy9lcFhMV3lPU1Q1ek5COUdlSHcvb0pIVFhqZXNMc2lZYmpRM0dLcnlYdTJEVWFzWWpLZndNTkpVdVdnWTVOTmR1UktwMEpMb1FlMEtRQThrN2ViMUhqUkVMclNSb3V0Smw0eEZsQkpGSTU4enhvcU95RlFmYkkrSDRGN1EvbHRJY2pXUVY2b3U4TmNhU2FsRWdLRjJWMmQ3cSt2Sk9lNk91MVAxdmZIajZ0anBQelBxaHQvby8wNFgramU5OG03ZmVlWWNiQndkVTFxcVlFMkZqUmZMRUQxdUlyTlFLcFlhWTd6cVg5bnFYWHgrODB2UFZvRTVPanBoTVIxeStmSVhQZi9hTGZQR3pQOGJCMW1YMmQ2N3crb3RmNEtzdmZvblBYUHM4M1hIazdnZnY4L2poUFdGNVZTMHhSbUtNcENTL08rL3czdUdHZ1ZXM3dnZUg5NTZqNHlNK2VQOWR2djZOMytHM2YvL3ZFVm54L0hQUFlLdEszZ3hiTVJyTnFPc1J4dFQwWWVEYkgzNkh4MmVQcVZLV3hKZEpoUzJwSzJzT2QwYjJyeW5KcmpxdGZaR2gyRFJscnFiRWEwcDQ2QStPSEwzUFRFWmlGa2tXd2tidkVyMkxWTWF3SER3ZkhpNnBqV1NMdTVob2FzdW9rU1NaRU1VUWNXdFVjN3J3bkRqUGFhMnB0MFpNSmxXWlJXVkxrY3FUR0xLc0kxUElESDJpNzBSdkhsd1VnVWNxbE4zU3NxY0V3eER3bldkMXNxUmJyT2dIVDVzMFg3aDlpZDFSUXpkM25KME9MRmFPK2NMUkRaS3dLeXN0ZzdXYWRtU1lUcTN3RWpLc0JqR0phQm90cTlRczZMOHZwSmFxMWxncm4wc0ZWNUhZWjJudGN6cDNLTlhGeENPaHhFMG1KVUlVWDRKY1ZnSjFMUmxaWjZ1TzA5WEFiRFJpWjFJVGszUXhhd2VqdXRaTXBvYVlSZVNqMHViY1Joc2xkbUVsYmFldTlIaC9WazlQbHU1N0h4d1hLZU9USzdmOHFSTzFwSnpaR3JjNTU2eWM5K1NzY2hUTG1YVmdvMFhNVlJ6a1VNTjBCMTdRS2V1Y0lvT0hzMDVCdGNXTm04OXorZEpWcmwyOXhrLzk1RTl6ZUhySXc3c2Y4ZkNETzN6ejY5OG1LMDNkTkJodG1DOU9HYlVqSnBNZHVja1ZwQlFFR0N5V3NhdlZpdFBUWSs3ZnY4dTlCeDl4Ly83NzlIN0ZsY3ZiSEJ4Y0U0bHF5ckl6eFdCTVE4YVNZdUwrNGo3M1RoNmdnYVkyeEJKM3V1N0tWYm14bnhEb3hieXhXekpHWGh1VE03Y1ZqRlhtcUl1c1hLS3VaSzFqakNMNkxNRGQydmVlek5uSzQySmlhMVF6N3owaEpUYVU2Z0ozcmxkM1BpVjhNYmhJcFVDRHl0aXNOamVXQzJYOWx6SnhTTGhPTk9YUlM3dHNqTm9RZm5LU05qcjZSSFF5d3crTEZjNDVpSW1idTFOMnhnMzkzQW53VnNoQ3Fvd1VRMG9jOTU2NnRrekdkak5qeHlSYkNGMHBtc1pnSzAzYktNRmZFa3dtTW52N2tJZ0JmQ2xDWFE3Q3VvQjNMc3BZc0g2UEZZcXRtUUVxY2txNFFmYmpzV1FCdE1Zd2F4dTY2WVRUeFlLdnYvK1FhWFdON2RiS0dzMEt5RHVmUjJ5bDJOMjFWRlZrZFJwd0lXTmJ3UWF5VXB0NFo2TlFsNmIxNS83NUwxejdsejQ4N3YvOUQ0NVhkNVdpelhsamcvNUVMUE9ub3REZnYvK0FGNjVmSmVlY3IreHNjVEpmc1hLTy9QR1VsNlFnVE9CcUM2OXBHZVhRd1BIangvekhmKzAvNHdmdnZzM3Q2NWVZdEEyenJTMjYxWno1NlFsVlBlTHlsWnRzYmU5aWJjVjB1aVhnMnREaW8zREsxeWk0OTQ2KzZ6ZzhPdVRldlE5NTlQZ3VEeDk5aUtreTI5dGJYTjI1Z1RXd1hNMnBxcGJ4YUF1VlJmVGluS08yaXJsYjhkNzhEcUVLTkhXTmJlUkcwbXZibDdXVWRzMkRWRVZXbTRwRGR2RzRDOEJsTWplS1RkT3lUelNOb2E2a1hWWHJiai9sTmJzZkh4S3J3ZE5ZVFYwWi9HcVFXMFVWZFY5SnVLbU1wbmNpZWdrbFB5MkZTTXdRY2xsRHVrUW9hTEl1UUpVUFV1aERIOFd5dVJ3eU9SWEFzM2pRSngrSVE4QVBRbmYxTHRCYXk2MUwyOWdJZFdVd1J1RkN3cVFrQVJ0QjlnNnJrSGd3NzlCa0t0MWlsQlpOZzFGVVZncTZzZ3Fkd0pGb0dzV2xTelhPSmU0L2pJS0NGNFpoSW1PUzdDNTZsK2xpWnJRMmdBeWlqNml0WW45TGZBZDlTSngyWGthUEV2ZzRxZ3g3c3pFaFJCNmVMUG5HKzQvNTBXY3ZNeDRidE5WWTJmNXhlaG9JVHROT0RXUkxuRWVNbFJFdHJnOXdYWDVaUGI2MU4vN1pQL3Y1cTIvOUgzN3RuZjkzZWNZZEpjWG9ZckYvYW1TcVA3aDdINEJMVzFPaWQxbldTUjlESDVVQ1Jvclhxa3o3UkkrVE02Zkh4L3k5My9ndHZyVTFZcmZWTkVwVVc2UHhtTzNkUFU1UGpwaHRiVFBkMm1NeW1hRkl0S014MDYwVnRhM3BsblBtODFNZVAzN0kvWWNmc2VxWEtDdXhUQWVYSmt4bk03VFcrRERnWE1Sb2d6WGdmY0NhaEEvbFBFbzlkMVozT1hUSHRMTVdvOFdvd0t4NTBpWDhNYWNOTGlGRmtzNnRySFBLZURTMWdsZFVZcWJnZEJueFNWaHcxaXBxSS90c240WGxGc3ZzN1dKazhKRkpXd3NoUnlzcWJiQmFqQzJHbERleXp4QVNRNGlFUmhob2J1bnBmY1pIc1pCS1F1ZkdCZEZmRTh1YXF3OTRmLzQ5cndYamErVmFCSndMZUIvd3pwT1U3S1V2YlUzWm00eW9mS1N1ek1hQ0dqUkp5Mzh2VUg2R3dlTzdnSXB3NVZKTFpZWGVXbFZhSEg4em5KNUVsb3RFTzFJc1ZwNmpvMERYeTR2b0U1dFdmVGF4eFcwb0k5YkxFaUtRamNMRlRFaVp5ZGh3c0Z2VERYS3JCeExaS0x3VDFWMmxOYlB4Q0JjRDd4MmVjckF6NXJYcDdnWUgwQ1dRYmJHTTlBSDI5aTN0UkxQcVpPc2pQcWVLMFVoVFY0cVV5Sk9SMmZ2c3JlMWYrTE9mdi9idC8vUWI5MzY3S056Y2hXNzIwMVhvNjQ5SFp3dTJqQ0trdkY0cHIrZHpuVUcxaXQweGZOR0t2MFJPb2xuWitGQ0ZtSGgwdk9Tc051eU5MUHRqUy9DQjArTVRobUhnN1BTWVp2U1FxbW1wUzI1NVRKcmxxcVB2Rnl5N000dzExSTFtTWhrem1VMnBTa0U1NXdxWnhHSnRJenZTWEFDZUdORTZvU3ZEdmVVajdxenVra3lpTW9iMVZTZzc5TUluejlKdTUzanVqcnBHakZPRzJBZTgxYnpjYUs0aGJlaXlqM0xySmlrb1pRV2N3Z3ZBbEVwcmNMSjA5Q0V5YmExa3I4VkVVd2tJV0k0VmNwWWJ2ZXNkZlVvNGJZZzUweThkcTRYRDdWYlV0cndGeFhrMnhXTGtLSEpNZkNyZWRFcHVQV0s2Z0RtVTlab0xCTy94U2I2SFcxc1R0bXBSN3NXVWkyVlc0ZlZyaXpIU3VpZWZpVWJUNWN6RDVjQmtXckcxYTdHVkhCanpSY0wxa2NWWllqd1NGNWdIOXoyTExsTlZDcU1VRmpick9hdkZoS091RkhVbDRoTnQ1UFZhazMvY2tNZ1J4aWpxQ01abHZNNDB0VVdwaUErUlNWUGg0NGlIeDJkODg4NWpMbTJQdUhVd0xseitqS2xrdGVhRGpBM2pzYVl2aFY0M210RkV0Z1FDc0dXbEVubC91M250eDU3Zis1ZmVlYkQ0Nk5zUDV1OHBzWjNTbkJ1emZQb0svWVhXY04rbDlZNWh6UlV4UmNlYkovQmFxM25lYUsydFVjckVoSTNGMHl4THo1T0JwWXYwSVRMdlBic2p6N2h4bUdWUFV5OUVER0VVSVJYeG9STFB1ZEdrRVFDb3RvekdMVlZsQ0c0Z0tZVXBzVXNwWlVhakdwVTFNU1N3cHRCdXdmbUIrOHRqUHVqdjQzUlBneFhacTlYWVJvc0VjMDBIeXFyWUlvdHVYSmY1TnhmRm1rdVpLaWF1eDhTa1VweXRJcDFMckVObXRKS1ZFaVgxdFI5S0RFN09ITTBIb2IwcU9Pc0duSThYMW1xRmhhY2g1TXl5OTZ4aXhGY3R1akw0bGFNLzdZbFhSemlyTVVVNnEzSkdkWUd3RExnRVE1R1VyczBVMTdsYldsYm9rREpHS1ZJM0VIc2hIOTJjam5saGY4cTQxamdsYkR4ZjZMSmFLK3JhME5RRzQ0TElXclhNSldlRDU4N1JpdEdXbFhna0xieno0QkxiVThQMmx1TGtMTEZjcHMwR1F5RUt0ZzMrUVNaR1lkUnBmZjU5NXB5cFNrUjF2eEMzbmtyQnpxVENwNHpUbVd3MXB0SllMNzV6ZFdzSktYSC8wWnp2M3ozaWM2OXNNeGxwUWxRMDQ1cmFSazVPQnhhbmtjVnBvdXZFKzBzM01pSlFHSmxxZzhsUTM5aHUvK1RQdm5ibDk5OTh0UGdyTWVWaGZiRjlLbEQzVC9yWXM1cVFVWjI0TmE0THZBRkd0V0o2dTlhL2VHbFVmM0YvTWpLN28wWk5LOHQyVXpHcnhHVUVNa09aYlZNV3hIcmhJc3MrMHE4Y3ExWFA0SHQ4OG9RVVFTdmFjVU03YXFpYUNtc3JVa3FFRVBDKzVGc3JUWXdKWTZ5MDdzNmhsR1k2MlVHanBXUG9sbnozL2gzZU83bkhrRDNXeUcxcnJNUTdtMkl5a1ZOQmM4dThtMHArZXdpNXBJdUs5Vkt5bXV1VjVuV2RhY2ljTENQTzV3MDVwaTZFbTFRVVZXY3I2ZlJPbHdOM2o1Y1lvNm1NNW5EUllZeGkxRmlheXVCOEZJMTJiYkZhY1hpNlltRXllWGVDcmd6UlJkcEp4ZGJlU01JaXN0eFVRNW03dlU4TW9YRHZDNkZtVFROZVh6OHBadHdRR0ZhZTFlbUN2dXRKTHZLRkszdThjbjBiaGNLVkZNTjF6REpGa1dhMUxubDVRaDlPaFJzUUVzeVhIcE0wOVpybnJoVk5wVGc5U3l4WFl0R3RqUWhqbEZKRjIwOVJFY3FvRk9NNUFwL1g2d1NsQ0gzQklyeGdOWFZ0aE5PZzlTYVdLNkhLZTJxb0trdEltYnVQNXRUR2NHMTNSTnRxc3NvczVvN1RZOC84VEVoRXVjemxhNmcwb1FqRmd5NTRsRXM1NWNEb2VPNFdIeDczdjNIUysyTjFIa1NhUHBVM3V0R2FLQ21VV29FcEhnRjFCdFZxZGZYNnVQbnNmdHZXbzZwU09XZWlQYWVQcm56ZzBqRHdzUGZjSFNMSE9VcytjNEtRSkQ1NFM0RXRiM2dxWW9iVnNzUDdTTzByNmthY1JOY0llUENKR0llTjFWSlZOU3ptQzd6M3BLam92T054dCtEeGFzNHFla3h0R0tzV1d4bnF4cDRUQXNvY0t1THpjcHVrZEo1U01nUjZuNmlEK01hM281WVhiV2JId09reTRYMW1OcmFDTWlmeEZCY2pYVEZaWERjS3l5RnVWR0N4bUc2TWFrTmRhTHdocGMxODNnK0JwUS9rblJaYlY5SlJhTTNpdUdjNWQ0emFsdWdpc1V0WXEyRnNoQVVXZlZuL1pWU1cvZm1hQnhEQytlNjhLM0ZLemdWMmJNMnR2U2txWmthTnhpZkRmSjZvS28xU01pT0hsTkVxWVkxaE5qVU1RNkJ6YXhBcmM3cnlhQ1BGdjc5Vlk2M2laQ0dxT2NsRjB4SkhWZFpveTBYRTF0SktVMWFYTVVybWt0RkZiMkMxRUczME9sUlNIcVo2cExsVWFSNmZPcktINVJCWTl1Smg2Rk5rT1hqMmQ4YWtuUGl0Tng4eXN3M1BYSm1nSzNtdXV1WDV1alNuaklzWjN5ZGlNRlRGbVZjcGlGcWkrdzduYm43L3BQdis0V3BZRm96MTA3ZGVBL2o1MXcvNG05ODc1TDArRU5JbUJsRWp4VjRCMVVGbG5wMVc5b1pXU3VXTVNnVnAxa1diUEtrc3RkSE02b3JkM3ZGaDU3anJFMTFwNTNzZ2VrR1VweXBSTlFvWGdwZ0phclU1TU9RV1R6Uk5oUThTSnFDMUtMNkM5OWpLc3VoNzdzNFhISFVkWFFvbHZkV2dmTUt2UEwwU2RsbTJpa3BCVUxwdzdPV2JXYmZzMFVlaUY0OXo1YUxNMmJYbENwbWJSWXl4V3JQT0txaktMVDZFaEMrZWJmMGd0elFwc1ZnTlFLYTJCdStqT010cXVkMTltYUcxZ3Rwb0hpMTZuQUkxRzZHMGFPY2hNeXdHWXVkSXJvYmpnVFJFd2xZanpqYUZDS0t6OE8zOXloT0dTRFVWRTh3WUplVmtjQUhYTzl5cUk4WElzd2N6ZHRwYXVwQ1lHZFVHUFlYRktxQ3N1RzZrc3RJQ09leXNOWXlVd2lVQkFKdEtjOXA3dWo3Z1hPTFNiaVByUlNWa0lhUEtqanlYbFZzOGQvYlZSbmJZT1lyK0llVUVqZDYwMFQ0S29jWFdjbXNEVEJ0Tm9xSi9GTEVaR2hSTEgzQXhzaG9jOHk0eEdUV2NMRlo4Njk0aFZ5K1AyS29NUGtEVEtJSVNUTVM3aEhlSjJpZ0NtZXhsMWFrcWhURkc5YjFmdm5uMzVLLzkyZzhlL1NmeklTelhXK2VMdS9SUFRhRXJCZVBhc09pRFN1ZEZia3ZyWGlsbzl5djdrdFY2WEJrdCtKQUkycDlnR0JpbEdGdUxHU2xhbzVpc0hIZGM1TFNrYnJvTUowSCtZV1lTcUVTbEs0a3ZjcTQ0aFlqK09BYnhxR3ViR3FNTlBnYU9WeXVXS2JJTWdTRUVPUnkweGlEcU9SODlidFhqbGgyaEg1T1pNWjZKTzBvaVFSOVFsYXphMWlTWjZBSmhpQ1FYWVZ5eFA2NTVRU1hhbURsZUpuSldqTWVtckxDZ2JUVEJaL29jQ0Y1bWJSSWNMeHhubmRzQVQ4dGhLQVlVc29yeWc4endiVk1SYytaczZVaVZJZFVXWFlxY2xNa3E0ODg4WWViRmlLTVZwNVlZTThOY2hEUzFVV2o1NFZGVm9kL0dSSXppQ1RjTUhqODRoc0d6MzdSYzN4NWpVUnNnVVZ2RnJPeklGMHRQSGhLdXVQYkdSS0hUeXB4Zks0MnVvUGV5emx1bHpMMnpucXJSN0V3cTJrWW94YmxzSG5BU3NWMjNSVEphUUQ4WlE4QzdLSHYvS1Bsc3FZUlZHaXYwVlZYQzl4U1pDc1ZFYTBKdFVTZ0dMMjdBQjdNSnk5NFJVMlkyR2ZIQjhZcnYzanZsaTgvc0Z1OTNlVTI4bDUvWGFIRzhVY1VGWjBqa0ppdTFXUGp1OTk4Ny9odi8rWGNlL04vdnpvZTduTGZzVDVCblBoVXordi80NTUvaHp1RkFiWlM2ZithVUtrRU82OWtjYUNkYVhmN2MxdWd2N2JYdGM0MnhTaXUxempaRVUwSU9Vc1FYSnhyS0F6NDJtaEdKSVdhR0M2L2NPaUs1c3JMYk5zWlExUlhXR09ySzBqWjFJWlJrZkVvY3J6cnVMeFk4NmxZczNFRE1xUVFtcnEwZTFLWk5DODRUWEdDOUxGc0hTNG9GVVVHeWM1WTRZQmNKZlNCMGpwaWdIamU4UE5hOFltVEgyM2xaUGRSVzVsSlRWRy9HZ0FzaXNYU0ZFZmZvZEVVZkl1TzJJbWZGNmNxaFVPeE1XblRSVStjRW84YXk2Z1B6MWNBd3JvaVRWbHhwT0xkc251NDBqTWMxWVZ3UnJTYTRTQmdLQzY1d3hBVytVQnMrZXZDQ2hMc2g0RmVPYnRsaFl1SzU3Umt2WGRrVzM3cVF5dzVmYms1cnhSYktlNkhNNXJLUEQ2RTQxR2dsbE9GOHdkZ2hJeXZCa0drckk2R0ltczBCTFZpbjdOeXRrWXNneEl4ejRsQWJFeWdybzVqWWQ2VjFsc2lHVkNTS1lhR3pta0p2RXhJTkc1WGJiTnhTVzROUmlzNTdqdVk5bDNiR2JFMXFRaEN3MEE4Sm94VlZhd1NqVVFwZkhwbmp1Zk8vL1lQRFgvL1B2bjN2UDdpL2NHK1gvWGxYMW12eEF1ODlmMnB1OUpQT2MrZW9SNVVvc2dMRVdhV29jOGJjYU91WGQrcm1tZFpZVTJsTkFxeE9aWCtjeUVsalZDYmtJRVlDeGJpbU1ZWkxvNXFVSE1sRmpzdk5IaktjT1hKVVNVMnlwMDJLS29IQzB3Mk92TkowMFpQSitKeHhPYUcxb2JKbUl6V05NUXJQdWtpZTFrQ1BiUnRwaFhPV3dNRE9FMWNON2JTaEh0Y29MWWt0b1pmaWliMFFTM1JiczFNcG5yWFE1c3o5ZVdBSW1kblkwTmJyR0NieEdLYzR3ZzZsUUhvWE9Wa013Z0NyTEdlZDNEYWpSa0E3SHlJeENXS3RsV0t4Y3JpVUNMVVZObTdLeENHSTJhRVNFc3VnSlJzOUZXSUpXVFlJSmtYeG9sUGw4d204VDdqZTQvdkFzQnlZbnk3d3E1NkRxdWJtenBSSmtZbUNqQitxQ0hsOEVvQnhaMWJEd3JIcWd4ai9KbERGdmtvVk1sRmxGRTBoMmFSa09GNDREQXAyUm94YVExWExlNnVNZ2hMTm5JdmxkWXdabTVHRDNjaW81NE9RZEt6VlpkVW1SN011eXJTVUZMcVdMbWk3cmFIUk5DUEwwY0xSSlVtM3JXdkJZbXlsZWVmdUViLzdnOGRzZmVZYXJkYkVjakRuS0dPRVUycERnVDFkRHNQdnZYZjA2My9yZXcvK1Q0OVg0UjN4dmFFcnhSNCtsWVFaclJUUDdEZnE5ejZZci9mbDZ4dTlKdE5zalV6NzB1N2tqMDNyZXEvU0ptdkJhNm0wcGxXS0lTWVVjV09sNUZQaS85ZmVtOFphbGwzbllkL2FlNS9oVHUrK3VlYXU2dXBtZDVOc3FqbUlFaWtPb2lRenNpSEpZMndwTmd6Qk1CSWtBV0lnK1p2ZkRwRDhTQUk0Z0JOcmNtSkxTdXpFRVNSSGxpeUpzaVZSRXdlUkl0bnNzYnE2eGplL081NXBEeXMvMWo3MzNYcjlpclJzRFYzTk9zQkZrVld2NnIyKzk2eXoxL3JXTjNnT0VYaGhhS1d3bG1tYzl3R1ZZeFRTd2RjMm9EOHVBMCtxaGhSWldia3dneldnTXJGQTFvYVFtQVNKTVZMTWxzRmFRME9CU1Mwb2JCd1pXTzFXc0pXZ2NtQ1UxUXpOZEk2MDMwRjNwWU04bDQvTjI0QlFPMm5kdmFTZVB0blR1S2hsVDF3MVFXN2thUHNFSitpdGkyaDlXWG5ValllMUFRZmpFcVYxV00weitCQlExZzRBME0zRm83eDA0dlNTNXhwbFpURXJhelFFSUVzQkgrQ3FCcUdzZ1RRQks0M1pwTUdnQ2NoSlRtSHZKVVNTbEl3Mm1nZ3F4TWdpSCtDdFIxMWFsRWN6VENjRnlubUJYdU94MWVsaExVOWwvZW1qdTZ5Sk1VN1JUQmNBOGx4alNLblFWaEZnWWhvS3NkQmlTUkUwRkhJRFdGYW9yQWNSY0RTcm9SVmhXK1ZRMm9BVTJ2QkRzZExHeVVwVC9BR2srR1JsR0UvOUpDYlhzdVNpSjRtc0g2MFFCVUNhc05JM1NETUZqQWlVS0l4S3U0aHFVZ3JvZHhNVWxjV3JkMGZZN09SNC90SXFRaVA3YzVIQUtnU1NkSjNaM0x1djN4bDk0ZGRlMnYxSEI2VjdFVUROUUFHZ1Bvc1Y5NDRvOUkrL2F3Vi8veGZmakMwVHhSVHd4Vm90WmNEOHZVOWYvTzd2dU56OUJIdlZuWTBDejBZQlJTME9KZU5SZ0haaWVXUjlRS1kwdWttQ3lqa1VIQWt1ck5CTENXdU40MFBQS0Jsdmd2Q2JESHlVR2RlWTBRbHh6ajJCUVJoc0JQZjNYZ0E1bzZPM0d3c3d0MUF0RUlHZGlHSzAxb0JTNHZsR0N0NDUyRklBcWF4cXhHVWxOVENTSWdHMkhoUVluQ2RZNnlaNHJrTkE3VkhXakpWdUlyVFdtS05XVmg0cmZZMjZsaFdYRFlJZ044NWpVdFl4Znc1b1hFRGpQUktqa0tkbUFmd3hSTWd5bWpjb214cHVmUURXU243MnlpNzIrY1FCd1VrNG9uY1UwZnBJNW5IeXY0MlNmRHVsUkhqRGdlR0xCc1Y0aHFhc2tUUU93eVRGMXFDTFhteHZLUlZQZWVBa1RGSXZ4Q09NTk5Qbzl4TVVoWXV6ZklCM1BnWlEwR0pFTXN5eWl0RWFaVzB4S2h2a21URG10TmFDZHNlVE93U2h1R3BTSU1mUnoxOCtPazFpbHhXaWMwMUxWZVc0THF5YmdNWXlNaU1keU9wQVZtcGh3dGcwR1dhMWgrT0FSQ3NnTUM1dEREQ2IxL2ppalgwTVRJTHRYaWE2MDVTZ1U4RlZqbWRGZU9uZTVHdS9jL1B3cC9aSzkxSnMwK2NSSzI1T25lYnZITlRkS01MVDJ6bHU3RmNFc0dLT0xUdVFNYUEvY24xNDlVYy92dm5EMXkrYko1RXd1NHBvZkJoUXc2UGlnRmRlRG5qalRZZjUzR004c1pqT25OeXdrUkhGTWRMSUJvZHVyWkUxZ1JYamhtUDhHaEgrZ0lGUGdmQmRZRnhZSHJnOUNSdU5JblVycUhpcUJza3JEOUg1UkVYcklKbFhOVlJFV2hFWUFVN0dDbU9nVFFJUW9TNXJORlVORlJnbUVUc2preHIwdWltZTZXa01IV05VaWoxVW1nQTJuQmhUS0VVb2FoWUtxaFg4b0xFZTQzbURvbmJvNUhJOE5zNkRPYUNUcGNpTUZrV1lEeUtzOFFHSDR6a2FCZmhPQXMzaXZjNnQxcktOdnZKQ2lMSHVoTkREU3BKY1VqQW9Da2FNVm91MnZaeVZxQnFocmZZYWo1VmVpbzJWSEoxb1R4VVBXSGtmbXdBbUlFOUU4TkZFOTlSdU4wR1dhY3htRFdvd2JJTkYraTBwQlVVeTh5cXQ1YUZCRE9jRERxZml4UWNBL1o1QmtwSUlZTnF0SmdGSnpFSVh3cENRckZydUVpa2d6MlhNS1NJNWFWNEkrSmNsQ3E1bTBFQmoyRGVvbW9ESjNDSFhoQ1pFSDNrR2NxMXdlV3NGWDcxNWdDL2ZPY0ozditjQ3Nsd2VQTllGdm44d3c1ZHU3cjMyMG1IeFUzY0w5OFZZM0tlTDNKMVNyajM2cmZ2LzhpUFg4ZC8vNjd0SU5WRjB6RjJjNXBLZVJmbC8rc250VDZ3UDZDa1hQUHdZVkpYeXFheXVFTHJuQWpaV0UxeStyREdiQkJ4UExPN3UxZGcvcWpHZE5hQXBvU2s5dkJmSEdVVUtIdFFBL0RLQWtobXZBM2dkd0JjQi9CQ0E1d0gweGZnZEZDemdGYUJTaVlOaUpiRS9rcXF5eUdLT2UxbVJWU29KbzBCd0hzN0pUbHNic3pDN2JkTm1BZ3RvYUl4QjJqZTRzcGJqNlpSUVYyS1drZW9UY29kbTBZNnJWR0ZhT0ZSVlFPbEVJbHJVRHJ2alFtNWNDR0JVV1k4UUdIbHFaTjFsNDJpZ0Vrem5GY3E2aGx2cGd0TUVLZ1FFNjhCZW5GSEUxdGd2ZE51dEdTU0JRRm9oRkRYQ3RBRWxHdFF4YUt4SDFYaHhlQzByMUtWRm1EcDBPZ2JicXowTXU3THZib1U2THJDczZHckJHZEl1U2U5R0p3bTRLejJEeEJDT2oycUVORXBObXdCS1pZQU9WblR2V2FMQW5LQnNISnJBMkI5WDBKclFHeGlJcTdKWVd3a0FLU0FtU0xvU1djbEc3YmxHM0t2TDZUNlpPWXpuRW9tZFIyV2RoeGhPcGdvWWRnMmFXbEtFQWdPVkMxR0ZTRmpwNXJpeU5jQ3JkNCt4dWRQQis1L2NRRlY3M0R1WTRzVmJCemRmUGk3Kzk3dGwrRTFtRkxISXkxTXQrenRQcHBvWndsOStZUjMvNjIvc3RDYW5DdktlcDRGaHJtOTJ0ajcwWlA3Q29FOURWdEltR2lYSUs0SGhLc1pzekVCa2pHMnVweGh1WkhBQUpsT0xnOE1hQndjVjd1K1dHRTBLYmdwR3lYd3ZBQzhDbU1hbnB3WGpWd0Y4SGNCZkFQQnBBRmZoQVYrQjRVRGNBSndIVUVjaFNmUkN3S0ZJT2dZVlhhdGIzWE9NaHhVVHdmZ3NZRzQxemhMVFNaQk1Na3NCM2N6Z1BUMkRwQXFZVk5JS1VrU1k5UklLN0MyaktEM0djd2NieEloeFdqU29Hb3M4MGJKeGNJemFPZVNaUWFJTlptV0R1bkVSbVNhTVpxVXd6Vkl0R1c0ZUNOWUpsOTJZeU1PblJldHM0aW5QaXFBRHcxZnlVQWlKaG9xTU5lOENYRzFSV3djN2QrZ3ljSDY5ai9OclBYRmNOWUljdWpyTytuRi9tbXFDYTRMSVhEdUN2cmVvZXpjM3NIMkpSUEkyRW9JZ0pCZG5wYjFXZ1pGcEJaVW5hSUpnR29leld1YjlRU0tXV0NEVVRoN1NUUEk5T2JyTkJBYmdBbFF1THJ5VlpkUzEyRWtMNjA3V2MwWXJkRktSQlpNQytsMEZhdzMyanhwcFA1VUFma29KWmZqOFdoZEgwd3EvOS9vQkVxTlF6MnArOWY3eGE3ZW45Yy91TlB3WlpwUUVsQ3duZVgwVytQYVd6dmRSTHZTWGRrdnNUUnR5Z1lrSWl1VytUamhtVlAzdGoyNDh2NzJ1bjFhYXlUa0d4MERFdE1kSTF3S0NWYWl0RW1jUUwyWUtsaGlCQ0wxdWd0NGd3WVZMUFZ5ZFdod2NWYXhmemZES0s0ZXZIYy9ySFRESzJESzUrT084QnVBbmlmQWlnQjlneGtmQTZIc0w5aGJrSFVPUkUrY1hGa2NJcFRVb1NjSEVDQlNnUmR6VjVyN0xLZ3dVL2VnakdoVUVKQ1JpQkhiUUJEemJTL0FrQWROQzdGNjFrZ2VGaXdhT1doT0tLcUFvaE1wYjFvS2dOeTdnZUZZdDVsZFpPemswem1GdHBRTUNZMTdWQUJNR25SU3pva1paMUhCRTRNUkFNUXRYSUlLV0JNbEpRMnlCaVlEZ282RkU5TlZuWmxBdkJhY2FydDBWbHhabFVhTXVQWlJsckE5U2JLLzFNZXhueURJWkoyeWs5cllVUG1QRXl5MDQyWGQzVnpUcUkwa1Y5WjdodkVlU0tuVDdCbTRTRU9oazV1WkluVldLUUVHTUl4UXJNSHZNR28vZDR3cUpJUXpJTEZCMTU4WFFBTkVvTkFSNTZQZ2c0MEd1TkpnRW9kV1F0UndCWUJmUTZXamttYXh3WTIrQ1hxNHhTeFY4N1VGYUx4eG5pQWlaTVhoNmU0ajlHM3Y0OVMvZjQ0RUtSL2NxOTAvM0hIN1ZNMmFRSWkrV2l0emhteGhFUHRLRi9zKytjQUR4dUNaaWppQWNJV0dHdmpCTTE3N3ZmZjJQckEvVnhRVWxHWktQcG5zTU0yQk1kOFZiSEVUUVNrSVBXcWM5Rno5SUJjS2dseURSaHVZbDRmWmhlV0hXMkdUVWhIcHBObXBsN1k0WnZ3YmdWUURmVDhEM00vQVVBTzBzdUpvemNiQXdtUU5yQldnZDdZTk5ORTQ0MFpjckltZ21FUzVHai9QVzVORjdCdzRCdFhNNDM4M3d2bUVPSFFRb1NnMHRySkVRcFoxMUZWQlVIa1hwVVZpSHl2cG9iVlNoYWh5eVJMTGF2UThvRzRkT3BtVTJyNFN3MHMxVEtBSm1SUVhySGZ5Z0F6WjZvUjhYSTBvRmpzSWRFWUNFdUlIUVVHM3ltQWZJR0toTWtsMnRDMmdxSjZhUFJRVXVMZnFwd3ZwS0I0Tk9KaWFLTGYwM21rTzBxU2JVWXArcFFuYzlnVFpBYmNWdXl6Y3hxRUlyckExVEdFVVlUd1JZZFg2Ull5UWdhRFJuNUJDZ1NUQ2ZVZEhBSEFBWTVrZ3lqVHdtNG5nU2ZFQUZMRnhrT2oyRE5OSFNwVENRS2tCbmFxRVAxVXB3Q0I5d29pMXdBYVNBbFlHb0E4djRjR2lUY0wwVEd1L2xRUjV1ek1aVXB6aVlnYjdrbVNleFZTK1hkT2ZmdE1nZjZVTFBqY0x0b3dhQ3NWRHJRbVRBU0FEb3YvU0J0ZXVYTHlUdlRUdElIVFBEZzN3RXdFQkFzRUExRjhCRkZHaHQyOXdtMlFuakNhM1ZjTVdZVEdwUUNFbHNoMXREQzd0MHFyY0NtcHNnL0F3eFhpVGdSeGo0TG1Za1RRME9nU256REU0WlhzZjliSmJDSkFtY09za1A0NWluRFMwK1pvd0FiMFVvMHdvMXNrNk9GeTZzUVFYZzNzU0tKM3BrbGpWV0NzMDJrcFJhV3kvaGZoSDlEeUZnNzNpK1NFbDFYdXlpbUJqZFBJSHpBVlhqRUpqUjcyVHdQcUFvS2xRTWhFRW5udER4aEZJQUd3MlY2SlBvS3g5Z2F3L1Qwd2hLQUViU2hOQVJ2SUVqS2w4VkRlcXlSalZyZ0NiZy9GWWZsODROMGMyaTlYSk1kV1dXZFJVVFlMUVVIRUY4M3pvZHd0SEl3WWY0ZG5FTW9vakNuOVZoQ2lKZ05KSUhBYUpKQnJlVXBPaE9vMWlpanBrSkI3TUdxZEhZU21Pd0FvczBOVW1GUldjZG9kL1hPSCsrQzJzWjQ2TVNSQ1E1NjNHdEdscTlRM3VQOGRKaDRtVTlseG5CVFVKVXk5VnljSEhUT05iTWFyV2pKaVBuUDJNOTc1Q3MwY3FIck5HK1lZakRJMzJpSjFxUms1TkR0d1FaSVpGUjd3YytzUElkMjJ2bXFTQUdBZVJBY0VRd0NjTjBnR2FxTVozcG1IRU8xTDU5MTNpaGlRNUJTQm5zZ0tvS2ZGdzBkRkM3cnhTT0owVFFBS2tZMTd4c3VldmovcDREOEx1YWNLQVloMHo0ODRIUmRRMFlBV1F0ZzcySE1RRjV6eVB0T2hoam9KU0dCc0RlSVpCYUJQS0Y0T0dzQlljQU1nWlptdUlEbHpidzlFb1h2LysxWFJ5TlN2amdZYTFIWS8yaUZRZkVBRkxTUWpOMHNnVDlib2FEVVlIR2U2eGsyVUtvNGtOQW5zaHNiaU1ZMkUwVGRMSUVld2RqMUpXRkgzWkJlU2FXekZIZVJYa3FOa2VScXg2OFdINjBWcDArcHF0eUlEVHl4c0VId05ZZVRXblJGRkxvbVdPczVDa3ViUFZ4YnBES3FSMGx4RkJpQVVWYVdHWmVDVUMyc1NudGRWa0t1aDJpVExjMXZiUld3Z3pYMWpJQkJ6TWxmbldWRXd0b2lQdXFEbkVGUjRDeUh2UGdjRENya2FVYTIydXBVR01WaVQ2OFpwaEVZYmlpcFUzUmdNb1VtaklJb2NZUTBseEZTeTlSd1VsT3V2ejd0Z0dxVWpnTWFTcE91cFBDUW1zaFU5bW1wcVB4akdaTnMxOENQN3RUOGY5YkJSekZrN3o2bzV6a2ozU2hYMXBOY1hmVXRBYVpxbVhDeGZsY2YrcVp3Zm1yRjlMM2RMclU5Yklnay8xbkN1ZytRdzBEbWpzR1phMWdQUllwR1o1TzVLa2NuVXVpSHdLSzJ0T2tyT3ZqeXI1Wnk2aVpBbHlDS0pHT200RUhwWUVoa3JkZTBjQ1BhY2I5RHVHdldjSzV4aUY0aVJZREVhTnBQRmdGZU9OZ2RDS25vMUlpcy9RQkZBUzExOFlBU3FIVHlmSCs4NnQ0LzBZUEw3Kytqei80K2k1czVSZHpNaEdnVEd3Yk00MlVEYklrUVZIVm1GVU85dzluY041anBaZWhjVjZZYjVFaE9PaDJRQURxUnJ6dk9wMFVzNkxDZURLSFR4T29yUlVvRlhucWtRWVdTQzBGRFVRMVlPT2dTZ3VYQ0FrbGlhb3hEb3phQllRbW9DcGxwVllXTld6aHNOMUpNTWhUS0NjemJMK3ZjWHhvTVo4N2tkZmlKTlNTUmFLTnJLc2pRRWNnSlNDbGlscDk5akVWTlJFUTd2S2xEb2FyQnJmdWxyaHpxNGxlYmRFMU5OVkFJdUVjSUlvMnpRNXZIc3dCUTFoSk5MS09BSU5jTTFaWFJMVldWQTVaUnlGSkNXVWxBcFMrMGFJS0xBTk1vbUF5V3BCdmdoZnV1b3VnWXFJSnc0NUJVVG9jSFphWUZuVzRONTNmT3k3cXc1bnp2M2kzOEw4dzh6aUlCZjdBcmx3Uk9GTVNzL1dPTEhRQTJGNUphSCs2aUdQU3l3S1dIL2pBOEYxYnErWlphSmJ6RlRFL1BBVk1ud0hOQ0kwVXRQTmkwV3VqMjR1S2ZseUl2MVlPc0V3OHJSeU5TbnRVT0Q1a0lPbXZySzVldXZyTXhWZGYvTUlySEFJVEtjTWM2cVduYkxNb2R1QStnSjlWaE4wTEhmb3ZpMERuRGl1NXBid0h1QUVDc2VTeUtRK1RhaGhqQUZMUVVmbEdTaU1valkxK0J4KzZNTVJ6d3k2Ky90bytmdjlydTJoS0oxOFhSeENUdENGOWhFUnJFTXVldWJRMWl0b2hVUkErdFJlQ2pvSkNXVmtSZ0JnTjZ6eHEyMFlrRXc0T0p5aExENzYwQWpaS3NzZ2lnNDhKRDZqMlNCRUlDcXB4MkpwV0tIc3BLbElpK29oclJSY0FiaHpta3hMemVZWFpwSVlPakxWK2dwVThRYW9JODZtREFZdFJZa2FZVGJ6NHp5UHU1Z09RWlFyOWdjSHViaU1hZENKWWlkbVJab05rbTZMaldqUFJoRzVDR0E0UzdDWTZEdnE4OE5kcnV5QkZoRnhydUlSUldvZDdCd1gwc0lOVUVUcktJQjNvT0U0UWhsME43UldJTkk0cks2MjZKc3h0cE1oNkFlcU01dWcweXlncjZYeE1OTVJzUEdObk5NZnJkNDR3cWQwWGQ1dndmOVVodkRxMTRYNFZlUGtrZjRBUXd3d1lCY1k3c2RCLytOczM4ZmszWnlqbURsaVNvcEtBY09iQ01CMitjSzM3dm8yK1BoZWNQT2x0SUFRbm5semFBdXdVeG5PTjBvdFdtZmxFWXNyeGhpRzBaQk1SVzB4bk5ZNks1bmJoNmZnOTcvK3U5MzczOS8vMVQxNTY0dWxuWC9uSzUzL2w1MzcySC96MGZEWVorWUNFUTZpWFRuVVhQNkRnZ1ZBd2ZxWFBWRDI1MmZ1dkxqTXUzVGd1TUNrOXVUcUtQRkx4V1dOeTRDaDZjY3dJVU9qbkdaNWQ2K0tUMTdhZ2JjQVhYdHpCRjEvZVExMDUrUkRqSTA5RkxyVGdEbUxRTUswYmFWc2htZVdVQUUxalJmR25jaFMxUmUwczFsYzZDQ0dndG5MRDlqc3B5cXJCZUZURGQxS0VUSU90QXhLenNKUnFYV05iYzBkUjJVbldXVDVyc09VczduUTZDTUlQaGdxRVJBUFQybUU2S1RDZmw2am5EaHVKd3JDZkkxVWFaQ1ZjOFpnWlNSblFYekhZMk5JbzQxWWhjVEt2bjcrUVFodWduSHZaWnFqb2loc2ZjdDRGT0NlU3ZjWXlhazJZMVNHR051am9ZWCtTYUNQWWdxamVlajBEVWdUYmVCeVBLeWdiTU93TWthWEFhQ1l1TWxuR0tDcEd6eWdjSEJTWVRoMHlUYWlWOFBoMTNHWjRLOVpXMW90ZnZ2ajh5VDAzbmxsODllWUJidHc5NUtuMVg5cHIrTWQzS3Y4SGZFS0VXVzdYRjd0eUFpaGRKSkg5Ty9nMFBHcUYvdTd6SFd6MkUzcDV0NVQ3UnNDM2xBaGRBTm4zdkh2d3hQZC94L0F2WHI2WVhQVmdWZ0RCQTc2UnRWYmFaOVNGeHVHeFFkTVFHazhQdU9pMVBSRUZJRFFCOE16RnpOTkx0NCthR3dVKy82NlAvc0RhZi9KMy9wdS8rdFF6TDN3d3k3dGJWNTk4OXJublAvU0pwNHJaNU9Cdzc5NmhkeTZoOXM0NXBRc09BQmNlZHhLalgzbGlvLy9VMCtlSDY1bVdUNnUyZ1p5TGlMOEg2a3ArSGFRR1R3NEgrTDUzbmNOM1hGckRmRkxqTTM5d0J5L2VQSWF6ZnNFV2F4TkZWVlJORlo0eGFjVDExYnFJakVjQXY4MjVNRWFEU0dGY1ZzZ3pnMTZlb21rc3lxcUdNUnBwb25Gd01FZFplOUJXRHk1U1BEVkZHOE9JN290b0pTQll1OGdVTTh4WVpjSktaakRwcE1JQjhQRm5xU3hHaDNOTWpzYVlqU3Y0bWNPRlFZcExteXRZelROMHRJSkpGSUlpTkZWQU1SZGQvT3FLRVVHSlVSaXVKYmowUkk2RGZZZmovVVllY25RaU9PRzRDbE9LVUZmaWUyY1NraGltSnBwZ05tRVJGdG0raDlZS3A3OFY3d1RJMTQ0TGl6eFJ5THNwa2hUb2RRbVRHU0hORGNZemgvczdWZlR0RXlBdWpiaUlpcThBZ21WWjR6TEx5WDQ4YmZENWwzZjRsZHVIUEcvOGw0ODhmbUt2Q1o4UFFvWnBYdyt3M2tnMm1DRlZCQ1gzMHp1ejBOODhhbkR6cUthaUNjU3hYU2NnWnlBM2lucC83eTlzZit5VDM5YjdnYXhMUFFUQU5ZcXFRcUdhQzRxZTl3THFzVUl4MWZCT1Rqd2JqUkVkWkZmcWc3Ui96akdjWXpvNHFuQjd4dTY1di9DZlpYL2xiLzY5Nzl3K2QvR0MwU2JwZERvMEhQYlRqWTN0cTg4OS8rM3ZYeG11MGM3OVcvZUwyZGdCcEUvUkVMbHR0OGFWMjdlQlh6NjMwdGwrNGNyNmhlY3VEZldWdFI1VzhwUTZpY0ZHSjhQMTlUNis2L28yUHYzdWkzamYrVlZvRC96MlYzZnhXMS9kd2M1UkFRcEJLSmhMM3lRUU1BdkFKQUJWZEUyT0lhRHlpbXRHRlc5R0h3amowa0dyZ05WK0RrQ2hiaHBoeFdVSjV2TUdvMUVGOUZQUWVsZDIwZEVhQ1RHUkpBU1cvYmozZ0E5UVJ2Ykp4alBXbFVMUUN0TmhCOEhJQTgzYkFEdHZjTFEvd1h3Nmd5MGJKQjY0c3RiQmhlalhudVVhU1NiK2Fva21zQlV6eWNZQmVVZHNtMWVHQ1FZcktXN2ZMRkEzUUpMUjRtbmRSaXNsU2JUZm9tanlTS0lFVTBGdW5LYjBjTFVJalFJRTVRbXhLMG1NV3RETUVQMEJSM09MZmovQmhlMGNzMWxBM2pPd2puRjRVTU5FS3E1V2hMeWowT3ZwdUxhVDk4a0c4WVEzVVJKN05LcjU5NzYyZzFkdkh6a0hmUDZZNlNkMmF2LzdjVTgrUCtza0owSWdBaWZpeHN1SUtzcDNaS0UvZDZHTE84ZTFVb29vaEtoUUEzSUErVWVmR2x6NDI1L2EvQ3Z2dXBKOUlIZ0dITWhaQmR2SW1xelRseWZ1NFo1QlhSSkN6UCt5aUMxN0M4UngzUGs2b0c2QUczZVAwZlNmMEIvNHdmOTh2ZE5meWF1NnBxS3FLWGdISWlLdE5mVjZLMnRYbjNyUEMxZXV2ZXRpVmM3M0pwT2phVjJWTFZ0ditRb0FNS25jMGRHOC9sSnFsSDF5ZS9EVXU4NE5rdWV2ck5HM1A3Rk8zL1gwTmw2NHNvYXRYb2FENHdxZmZYRVh2L1dIOTNGemQ0cXFkckp6YlFGREJUZ2xkMFo3ZDlobElUSk9abWpWYXJJQlRCMHdhc1JWWnRoTDBVa1RsSFdEdXJFQVMwTStHZGRvQXFET0Q0QThnWTdkQjBVWFIybFRSQk5LTGFpc0ZId0k2REd3a1loYmE1SWxTTDM0MlpXMXg5SGVCSHYzRDFFV0JZS1RFZVhLV2gvWHpxMmkxMDNRVFJSNmljUXhheEtqak81S0F1aVRaTnV0clFSbDRYRjg1RERvYXdRdkdXanRtNjFpZnJ4M0o2Tlo2Mk52NXg2K0RyTGZacEh0aGhBREhvMXNLWXhScUpzQVpjUUhucG5SMklBbUFENG9uTjlLUmZXMzM4VEVIdWtBbEpLTU42VWtHS05weEFhS1QxU3NPRGl1OGJrWDcrUEczZU9xNXZBYmUwei84S0RoTC91VGsveDBrWWZZSW5LdVQ4SkV5L0R2WGplUFZLRmYzKzVnSlZlME83WVVWMnJ0M2pyWGlycC81N3MzWC9qMCt3ZC90ZCtsTlpabEZ5a0FaSVdYM0Jrd21vSndmS3d4YjZJUUlqQTh5VjZWSEM5RUNvREVIRTBLajlmdUhpTi80dHRwODEwZlJoMFpOaXJHSHRkTkE2MU5USWpoN05yMVo1OSs0WVBmOWNKd2JUT01qdy8yUnFNRHg4eUtXckw2a3RDZ2FIeDE5N2o4eXU1eGNlOTRVbDNjR1pYclI1T0tidTdPOExuWER1ZzNYdHpCYjcreWo1dUhjOWpHaS8xd2UzQlJ2QnNJbUF1ZjVPUm1YbnJQYU9sWFhvSnVIWUJCcHJIYU0xQXNIdXJPT2VIaVE2R3VBNnJDZ1ZaenFQWE8wZ3dyS0QxaWlJT0thellGUUVYbFYvQ01LNzBjS3dwb2Fvc3RLS1RITmJKUmpXeHVzZTQ5dG5NREhZQ0RtY084Q2dBclhGM3ZZcGdhK2U5a3dEY1J4VmRpb2RSNkJPUWRqYTF6Q2ZaMkc0eEdnc2gzTzlIckxiYnJOZ0JWSlJSWVdjR0tHU1JjZ0s5RmI5REpOUklqdTJ1T0lCNXBjV3hWbW1LV2UvU3cxeG91TU9hbFJkcEpZSlRDd1lGNHdDVkpqSUcyWWdmZHhsYTFFZHdNUWZjYkc3Qi9VUFB2ZmVVZWJ0dzVtcFFoL1BKZW9KODRhdmpsSUI5TFcrajFVcXNlQUxCUkJBS3hpWGx5dGVjL1V1MDhVb1crMWt2dzB2MlNRdUJXYzc0NHphOXY1aHQvOTNzM2YrZ0RUM2MrNWNFRUpnb053WllFN3dpNks0ajdiS3d4bldvMEZtaENWQ0l4UThkMVRaRFpCOEV5S2d2c2pHcmNQYW94Zk8vM29MTjFsYXFxZ0hNV2pXM2dPVVFDQzhFNVI5WmFDaDQwWEYxZnYzYjkzUjg4ZC9ISko3Uk9wcVBqL1ZGWnpGclJ6UVBGN2dQamFHN2Z2SEU0di9IS3puVHRwYnZqYzErL1B6RzNEZ3ZNaW9hMForUmdKUEdSM2pEUXhDSzNjZDRtUEdqaVRVdUZ2YnprOXhDVlZhb0phWndkSzh1b0NpbHk3d01JR2tacDFITUhad2kwM1FWU0RVWTBYelFhQ2dUZjJNZ28xR0FuZkNGbEpLbWtxeFdlM3hqQWhJQ3lDZWgxTTlnNm9Da3Qwc2JCTkFGRGsrTGlvQWZGQ2dkVGk2T2lnV0hnNmtvSG1aRzhONlhpVVpZUTBrd2o2MGlZd2ZxbVFhZXI4TWJybFVSYVJVQTFiVS9Td0tpTEFGdEp0TE9PYzczWVI4dU9YOGRaWG10eHpyRXNxN3JXT1VZWitaNGhNR3JyeGNrbVVjaHlBNTBvM0x3elI4S0VQTld5Y1lqYzlsNFd3eFVCbUZ4THR4ak5LKzdzenZHN1g3bnYzN2cvMmk4UWZ1bXV3eitlT3R4Y2twcVd5OXgxSWdTdGlEVVJ0MnZUT2pEK2lEWCthQlg2Zi91WHIrRnJkK1kwS1IyQzNOY0N3a21oZC83aUIxZXYvdUNIaDM5amE5TmNDQTdNRGxRV0N2TkticHJ1WmdBYndzRkJnbkdoMERoaEo0bkJDUzJjWGp6Si94ZlZGbkIzYjRKanZZSGh1NzhidXJ1Q3BxNHhHaC9qNEhCWEF2V2NRd2dPMXRhb214b01NWjBrTXNuYTV2bW5Majd4MUF0WHJyNHJ6L0xPK1A3ZE42b2dWRHlLSjN5cnRWQUJ0QS93UzRhaE0rQmNTdFF6YlNJTGdSb0FGVDlvQnJaOFVwOTFldk9wcDRvV0VodHFVWG1pZG96S3kycFJRbFFKblVURDFRR05EYUQxSERUSUpFRFNpMXVMMWdwZUxIQmgwZ1FLNHFCQ01kM1ZlNDlMblJSUERudllPWmdCcEpBblpwR254b3BRVkE1bEpQWU1FNFBWVG9KcFkzRi9VcUdmYUp3ZjVBTHFhVUxTVmNoNkJubFhSUU5LeHZxR3dlR2h3N3lRekRiSkVaZjQ0YVlXMDB2ZkJDUkdJYzBrMlZWcmdvcXFONDVaYW9FQkRuSEhiUWlVeW96dHJiajloRWlGbGk0SHlIT0RsWlVNZGVXeGQxU2dxQnc2UnFIZk1WZ2RHS3dNdE1RcUErSTdvSUdxRm8zQm5aMHBmL1lQNzFXdjcwNitOTlA4dis4MCtMa3lZQ2NXOW13SmRMUExQSXhOUXhocVlMUUkyUGozdXg2WlF2LzA4MnY0eXUwWkhjMmQ0cE9kZVU1QXQ1L3AzdC84K09aSFAvbDgvd2ZTSEhtd2pLclFOS3MwQ2kvQmhOMSt3SHlpY1hCa1VGbkF4cGdXNzJWR3Q3SElFVjA4dkFPS2t2SG16akhLdFhkaC9ibVBZZEJmaFhVTm5IY0w3L1o1TVVOWmxiRFdncFNDOHhiTVROWTIxRFFWcjY1dURLKy82MzB2WExyeTFIT1hubmpLRmNWc2ZyQjNyNUh0RjJrU2hKZ2pSamF6d0ZjOGNCQVlteFpZZFlDT3hiM2NrVDhBd3RIU0I3a2NsSDBhQ1d3SHZ0Tmk1UkRSK2l4Ry9ib21BSU1FYXFNTEJxT3BhM0dnVlJyQmUxRHdTTkprb2Q5R2pHMnlQaUFENDMxYks5aklFdHpjSGFHVForam5Sa0lrbzdHRkpyRjBBZ0RYZUhRVGpXNUMySi9YZUhOY1liMmI0dnhhQjBsWEkrbG81TGxHVlFkVUZXTzRLc2sxeHdjaWhTMnF5S2xuamtVdXVlMVpyb1VyVDFnOERKckNnUjJRZFhRRUkrV2htZVJDaG1sREhZSm5sSTJFUTdSWWhOR0VYbTZRWnhySG94cGw0ekd2SFRnd052b3BOb1pKak02UzBNVEdBMlVUVU00QzM3NC94ZWUrdmpPN2NURDc5YkhHais4MStLd1Q5V041U2svdWw0c2NBUGUweEdCTi9IOVkvVHd5aGY3c2hSNTk0ZVlVbFEwcThBSnQ3ekRRK2ZpN1ZzNy84Q2ZYZitTNVo5TG52UW9NcjhnMUJCc1VIQlN5VGtDM0V6QTVOcGdYR3M3Sy9DMWVDWkxYWFFWR0V3bXNiQm5CQTVQQzRkWitnUjBlSUYyL2pQV05jK2ozVjVDbUdjQkFwOU9UbHRZTEI5MVpLN0xHdWtKUkZiRGVrV3NzTzF2VDJ1YTVDeGN2WC8vQTVhdlBYTnpZT3M5SEJ6dlQyWFJzVyt3b01rNVVaSWUrVHNDTnlOblpWRUNYc0JRYUloMzRnaVRUWG02cHdOV3BXUjFMdjMvNkJ0Q3gwRzMwVmRlSkJxMm44Sm9Sdkpnc2lpNWVnME9BVWdwR29sb2pRUVl4bk1GakswM3d2dTBobkhPNGN6QkZ2NWVqa3lVZ0pSYlRFbUlncVRNKzJrZ0ZUV0QyOEUyRE85TUdZK3R4L2NJQVd4czVTRXRRZ1hkU2JIbEhZM0prVWMrOTZCUWlDaGh0NG1Oa2tvcW1uL0hCRXFXaWlOejRORlBDcnFPb0pWQkFHcjN4cWxvTVFsMlE5V0dXU1ZCRm9raVNkMXhBVlRyNTJXTmdwTFVCM1N4Qm9nWFZ0dzZvR3NaODd2SGE3UkcrOFBMdW02OGR6djdWSHZqL21EaTBKbzd6TThRcEhnQ25CTzVvY01QQVBQeUhGL2tqVmVnM0R5cWFGSTRDcytLVHRyMmppRHAvN1NQcjcvOXJIMXY5Ry9tUUJ3QUJOUkU4NEFLQlBiQXlERWhTeG5pa1VaVUUxekJzSTJJRHY5VGJjb3pWYlJ3ak9PQmdWT0xPaEhFL2RIQllUREdkalpDWUZLdkRUZlI2QS9TNmZReDZLMGpTRE13U21xaTBpZEZDMHVJMlRVM0JPeXFyZ3JVMitjYm0rYWZQWDd6Ni9QVm4zbmZ1MHBXbjBtSTJhVWJIKytXaW55ZXA0UURzZWVCckFJNEl5QWpZanQyM0ZGMDh6TU9wTnAwZVV1QnRrUzlFKy9IVmZuMzdrTkFKUWE4bUNKbUM4dzdLSkRCSkFtV010S01RVEFQV2ljeFd4YUtON2Z5bFBNWFZZUi9IMHdMN2t4TGRYZ2NxTWZKQVpHSE9aWWs4SkVyclVYdS9NTGM0bWxhWVdjWithZUhCdUxUZUJiR3NRSTBXeStxbUNwZ2ZXc2xieXhTU1ZNV0M1b1daaCtNRmgwZVlhazVhY1doQ2tpbFFJaFpRcE50ODlQaHpwY0xncTVvZ0Q2TzQzVWlVc0FFYkYxQTNrZ2xuM1VtODFiU3c4QUhveFdJUERJeW1EYjU2NDVBLzkrcmVsMTQ2blAyVCt3RS8xd1Rza1p6ZXM0Y28wQUlBckJyQzBCREcvbyt2Zmg2SlFsY0E1azBnSXRLQkh3RGhPdGUzOHRVZi9aNk5IL2pRdXp1ZjlCd1l0WUJ3ZFNOYWMyMFlLK3Z5OUo4ZWFUU1ZndlcweUFOdlcxY0VBZVRhT0ovR01tN3Z6L0ZtbWFMc2IwT2xPYWJUWXh3ZjdjRlppeXp0SUVrejBYM2JCcVFWaHNQMVdPQU9uYnlEMUtUd3dVZlhWU0xuTEt4dHVEOFlEaTVjdlByc2hjdlhYbmpxbWZkZHUzcjl1WHc2UGk2T2ovYm1BSUlVTzJrSWpmblZBTHhNZ3IzbERQUlU5RlFKUzhJN2RhcklhWWsyMkw3TXFkOGprdTlDQnRBRzBCbWdCd3JVRVhNTWJlUlJJSXhCdGJoaHFDV0dwSWw4UDg5b3JFVUhqUGRzRExIV1RmSG0zZ2p6Mm1ON3JZOGtNY0pIanhSWkg4U2NvWElldGZPb0c0dFpVV0YzMmlEcnBPaDJORzRlRkxDMXgxWTNrOGpqamtLZWFSU0ZGN3ZuanVTYnQ1bm93VE80RFdKUWNXNTNqS29XZzBXT0VtVVY3YTZqZjRmZ0RrYmNWUkgvSHJOZ0VZbFJDOXBsY09LV2E2Sy9XNGhiQ0k2QWFsbUpOMTJXR2N4bWxqLy8yajU5YVhleSsvcXMvckg5eXY4Ymx1SXVUczNqN1NudURZbHlPVEM0b3doRy9mR2M1STlVb1VkYnYyVk9leFlMdmZ2cDl3MnYvcTJQci8rdHRUVTZCeWFRQlhrblJlNDkwTzBIWlAyQTZkaGdQdEpvbXBpajFaNkVVZndnb0Z6TTF3cUU4ZHppNW42Qit6UkVHR3dqU1R0SWt4VE9Oemc4M01Ga2NpZzU0VXJCZWd2dkhZeEprV1U1akRZWTlBYm9kbnN3SmtHZXB2SlFrR0loTDRGYTFPME4rcXZyVzljdlhybisvTHZmOStFcjV5OWV5dy8yNzAybmsrTnBMSGhEUkNvQWgwNU85OWNKMkNkNTBHVVJpSXhtMFcrZDMybXBWUSt0WjV1V29rWWlWRmpUQVV3R3FCeWdyQ1ZGODJJbjN1cmFlY0UxbHBOT2FSMjl5d09jODJqcUJwZnpITTlzREtFVjhPYjlFVUJLQ2ozNnJqUEp6cjhNSW1PVmdtSFUxbUUwclRCcUdGZk9yZURwOHlzWUZSYXY3RXd4U0EwdWJmWVdmbXcrQURwVkM3dnFkcXhRTVJ4Umt4aEpzSStSeHhCbmx5eFRraTBmU1lzK2dvdWtUdkxmZkJEVld5ZFRpemVSRU8ybG93ZWc2Q1ppcUVNUWEyc1ZSVEJGN1RDYTFuanhjSWFYaThhUHRQNmw0N243eGFaMlk1eFFIVTdUV1FNQXpqVHh3QkFLTC92eFA4NGlmeVFLL1JNZi96aHUzN3BGMFY2d0JlRXlJblJYdTZiN056K3grWW52ZlgvL2g3UkJBZzlhUk9ZMDhvSDJod0dVRUk3MkRhcVpHRTJJVmErZzYrSVlRWkVaRno5d0J4eU1HOXc1cWpIS3Q1R3Nua2VhNU5HOVJkNnljajdGYUxTSHFwd2pUVE4wdXdPUkdXcURMTTNSNlhTUUpBazZlUWZEd1FEZFRoZGFhNlJwQ2lKUTFkVGt2ZWNRQW1WWnB6dGMyM2p5NHFWcjczN3ZDeCs1ZHY3U1ZiTzNjM3N5bjQ1bjhXYlFFR0I4SndDdnNyenVBTGpId0lFbU12M001SjFVNjhRbzlGS04xVTZLbFR6QlNtYlFUeFd5Qk5BSndGa3M2QlJRcWFqY0tBNzc3UU1pc09pOU9RUXhyTlFhS2tqZ25DSWhobUNKSGxyVk5mTEFlRzV6RmR1REhFVmw4ZWJlQklreEdIWnorZVFJWUtOUUJrYUkyZVFLcmUxMGcrTlpoYnlUNGNsTHE5aGE2YUtiS094UGE5d2RGWGhpcTR1dGxZNDR5Y2FIRUVmVklRY3hqUlRYbHphWkZRdFBkbU9pR1VmRUVnSUxGNzZWaklwaks4ZEFDZmthSFF1N0tKMmtwRVRxcjdQUzFpc1NHNjhRYVdsYWl5YmhhRnhpT3JjOFN6Uk5VLzN5MGJqNko4Y0g4OWVaTVQ5Rlp4VVNEQ0VZV1pSem16MWZoVCtaT25yYkYvclZKNTdBYkRxbHVxazFzeFE2RVhJd2VoOTUxMkRyNzN6dnh0KzZkaUY1eGtjbW5QUlNoR0NsRmMzWEdFMUZtQnhwMUkxYTNBRGVNMDRNa05yVFFhSTNHZy9zSEpXNE53bVlkRFpnZW11aThsSUdXcWZRSmhHalNHOHhtUnhoZkx3UDV4cGtlUTlaMmdIQXFLcFNEQXVVWG1qY0U1T2drMmRRU2tjelFFV3BNWERPc1hNT2FkYnRyNnh1WEx0Mi9ibjNmT2pEbjNwcXNMS0dlM2ZmbURaMTJjUUozb0FvQktJalQzVEhBUzhINExXMVh0cTg1OExLMDVmV2UvbGFQK1d0UVVZWGhoMXM5ektzOTFKc0RIS3NaZ1o5VGRBSUtCckczRXEvcjViNmZXbzVsdkVzTThhSTE3a0VnRVZMS0duck9VWU9XV3RSejJ1Y3kzSTh1VDdBc0p2aVlGcmczdEVVL1c0SC9VNkdRSURYSkxBeWg1aHpGcjlmWUpTMVJXVWRybC9ad01YTkFhcmFvWk1ZZEkzQy9WR0JXd2NGMXZJVXd6eVJOUjVIZ002S1NFZHk0VTc4NUtJaER5aTZ1MUE4dVZzZ0l6QXRpbHQ0RkVDU0VMb2RCVU9Fc3BSUnowQU1McE5FQzZMdW93OGVBUlRrNTBpVVFtMDk1bVdESkRQWTN1eVRTdlhCN3FqOG1WdjN4ci9wYkpndXNkMFdvQnNodW9GTHNoTWMvOGtWK1NOUjZOZXVYcVg3T3p0b21rYkZRazgxVVNkTlZQcURIMXI3NEE5L2JPMkh0ZUVlbE1SNENTdFRqcEMweTBpR3dtMmZqUXdxUzZnZGlUMUhwRVdHbHJvWmFERjdqVXVQTzdzejdJUSttdUVsbUt3akhSWVJqRW1oZEFKdERMS3NDNEJnbXhLVDhTRkd4M3Z3M2lGTEpReEFKSlVPNCtrRXpqcVl4TUFIUVpvYjJ5RExVcXowQjhpeWxJeEpxSk9ubkJoRGFkNGREQWFyVjkvOWJSOSt6L3JtZVhyMTVTKy9VUld6dHRYRENlQk9ta201YnFxemxZU2VUeEVHdG02Z2lHa2xUNUVxQldVVXNzd2dTeE1ZSW9UYW9aeDd6Qm9JbDhBQnprVitQNG1UcVk0c05LMUlUQ21qa1lSU09scFN5N1BCVzR2SnRFTGlOWjVaVzhIV0lFZWVhTnc5bkdJMHJ6SHNkYUJUZ3lJRVZFSEFPRzEwTkdsVTZDUmlwVFdlVnhqMk16ejM1SmJzK1NzSEtFSW4xUmdYTlc0ZWxoalBHbHhkNjZLYko3QldEQjhwaGg5Q1NVSXNlMTZFS0N3RUpmb2toQ0ZFOGJtUEFnQ09EN2MwVmNoekxlSVR4NmhyY1g1ZDZTZGk3N3dVSWFXSllDTHp0MlVMTWpFR3ZaU1QzR0FNcnU5TnFsOTQ5ZTdvWDh6bXpSNGV0SDV5UlBDa2lKUE1RTG5BVFBqM0lzRDhVYSszdlV4Vkd3TnI3UUpESW9JT3pQcnlSdDc1NVBPRGovU0d0T1k1TUJFcHRnS3lORTcyd1FhTVVCQjhRYURBQ0t4Z3dXaGlaaFpDOUcyUHRrS2FDQllTUVR4dkdIVzZncVE3Uko3MzRwR240K0VueGdZMnFyWHl2QTh3VUJVRjNyenhFdlozNytEQ3hhdTRkT2twNkNSRFl4dlVUWVVBUnBxa011T1NRWnJtZ0pJd1Jpa3lRMG1ta0JqTlByQ3kxcDlueHFDcEt2M2M4OS8rbnUvOTgzL2pBN3YzYjkzNTJwZCs1LzdOMTErY1ZGWHB3Y3hIUlhPNzIwMCthODZ2L0dEYTBaMTgyckN1QWdWSXNIYUl2dXBhQytzdEJhSERqRWtzOU5pSm8xWU0wd0p6S2lESkdFWURSaW13Vmdqc0pZQUJVYm83ZDJoSzRJbXREamI3T1JLdDQyN2JRc2Y1dmc0QmJBVFlJcVBCSkZUVW5JQXRyYkV6cTVDa0N0Y3ZycUZqRkdhTkYvOTRCc29hbURZQkpnSGVITTN4MlpmMzhlZWV2eUEzUVJ3SHlFdUlKTWROQ1pPQWcwckgrZDB0N1NTalF3bkh0bDFyTElGdEhOZDRvaE5YaVFCemc0NkdkdzdPaW1XMkowTFZ4RWdzRm43bXNKL3pnZlc0TVMyeFg5Uy9jWGQzOXMrUHh0VjluR0VXd1N4M25VNDErOHJKU2hlUEMxMFlheWVpV3hGQkt1Sm5MK1RuUHZwczl6dVFCS01DZ1J2QVdVTFRLSEh1U0FKVUp0ejJlYWxoRWIyMW95bUJKNEluMFVmcjJNWTVBaW9RaXNxaThCcE5ydytqcEVVbkNQOVpwK0xBd3V6QnprYVpvNGRTa25EcWZJUDViSXJYWHY1RDdPM2N3WldyeitMaXBTZmhRa0FaNmJQQkIzU3lISFZseFp6Zk5paXJFcWsyR0s3MHNMRTZRRzRTN08zdWp1NjgrZkxlOXNYTEgvakU5LzNRcDc3bjAzL3AvWTMxN3EvK3lIOVI3ZTNjdnZQNTMvMzFGMi9mZk9WNGIvZE9xVmQyTVhqdkJ2cVVJWGx4SDgxMENxOUZvdzFtY0l3L1ZvbEdsZ0twamEwcFRscGRNUzQ4S1h5YWkwVjJrbmg1UDVWRVd2Z0FWTFc0bjI1MFVwd2ZaREJLSVRVS1ZXTlJWQTFTcldFaUtVWkRNdGFEVXFpQzhPTFh0Y1o0V21GdlZHSnR0WU1rUzFFMFl2cG1FZzEyQWZ2akV2UGFSVk5aeGhmdWo3RGFTL0dScDdaQU9vWXBXZ2xrUUtUTXRpZzR4MGdySDljcmlnaEpDK0tGdUZzMzBUdU9HZlU4b0trOVZLTEVsaGxpZFVVTXBFd1NQVTFSQUJNN1Fhc1lQbE44WTE3ZzNyeVpUa3I3Ni91SHhUODVPaXBldzBQTUltSjN3UndZelo5aUhiMzlUM1F4TWx5c2lCbEFOMVY0LzdYZUUyc3I2akw3aUFzSGdDMWdLeUJZZ3NwbExyTTFvU2pGek04d0l5Y1JTTUR6SWtrbGpROFN5MEJwQXlhRnd4d3BRdEtSdEpiZ0VkZ2hCUEZzU3pLaGFCcVRnaEVRbkVNNzhYTUljS0dHTVJtbTB6RmVmL1VyT0RyY3hlVXIxOUZmV1plNUZJeDVPVWNJSHRhbENNSERXNHM2QkV4bWdMVU9teHRiR0krUHk4bGtkUGt2L2NjLyt2MVBQZjM4RTJ1cnc3d29LNm9xaCt0UHZlZkN0U2VmZVorMXpoWEZyTDYvOXhWOVhIdzluNzM2TlV4bjk4bmJHaDZ5ZVJBR213R2drQ1lKMGlRQktZY0VnR0lKZ1h5QUxiZHdYSWswWVFkVTFZazFXWFJjaGlIQ2FzZGdrSXJUcW1KZ1hEYW9Hb2RCdjRkdUp3VVNLYTZxOFZDbTFYa3p5c0tpckQyNnhpQlZCblV0VTRuU2toYnJuTWRoVWNONmh0WUt5Z0RNRHA5OVl4K3J1Y0Y3cjY3RHg5aGNVUHg3TEdtbmFTYTg5TWFHcUZOWFNCTnhEMnIxNmhUdG1JbGx6eDRVdzNSakxCT0FwaExmZTFIckNlRm1WRnJKcXVPQW0vTUM5MnZMUVJQUFhiZ3pMK3d2SEJ5VS8zSTJxMjlISy9CaUNXSDNwNWpMWW9iNXVORHhNTGFueE1zb0JXdXo4MSsrWVV3dkI0WWRSbDh6ZkRScmFBUFMyUUpWb1ZCYlFyRGk2NjRBWk14SUdLaVo0ZU9zN2tqNDMxWHRNUzRjQ3QySFNuTEpRaE5EYVdndHJtVk5PUmNVT1hnWW5jYjFFeU5OT2d2ZWUvQU9wQWhOWFdKMzV4WU9EKzVqYS9zaW5uM3VCV3dRdGFpOEFBQWxja2xFUVZTc2Jva3duUm1OYmREWVJteVFYSU82cVRFdjVyQUIyRHM4Nm4vZ083L25JODgvLzhHTmxlRkcybGhIV2lra2lVS1NLa1ZJT2xvcmxlY2IyTnI4Yzl6WWoxSDkxQ0hjSjJhWUh0ekI3YS84QmlaN2QyQ2JDcFA5dXpqZTIwTlpXZ1RMMGFCQy9MRkpLY2lqYW1HV0Z3dWVIeWorRnN4cUpaZEdFOWE2S1hxNVFUYzFDTXlZRkRVQ0VUcmRGTU9WRE1vb2VCOHdyejBDeEwyMzVvRFNCMnhrQ1laWmdvb0NiRngzZVNmKzlrZXpCcnVUQmswQURCTU1FN0lzd0pMRDc5NDZ3dm5WTHRZR0dVTExmWWpPcmhSSk13dnJqeUF0QmJPMDhUNHdkQ3A3Y1hHRWpUTXlFYktvWDNkTldJQjdaZTJoaklMS0ZiUlRPSjRVdURrdmNhdXVBYTBjTi96VjhiajVtZU5SOWR0MTdTZW5GR2dQTU43T3VKOGZGL3FDMXVrY0thV1dZMmJDdEhMdU0xODUvb1BOM3VEbzBuWjJZVFhUWVpoQXdUTVN4VWdNa0JXRWJxSFJOQm8xUkVmTjBkVTFZVUtqeEphbThvd1NCSEtDNU01bURXWk9CNXV0Z0V4S0hFTE1YeFA3VVNLTkFDK2NiMUtMR1o4STRyZk9BU1pKb1pRUlJWandTTklVemxtOGNlTnIyTnU5alV1WG44S1ZLMDlqZldNYnZXNHZFblJxWVhBRkQ0S2gyWFNDM21BNDJOamNIcGg4QlVYVmtQVkFsaVlTSEZEV2xCaE5pZEZNaU5UUHRJdCtydzlGaFBXcjc4YjU5MzRNb1NuQnZzSHM0QzUyYm53VjAra0VPMisraXR1M2JtRjNWdUwrd1I3S3BvWUpBYzdaaGVOc2lPZ1RNNFA1N01ldVVjQktxcUc0bFhRR1RNb2FSaXNNdXBrOFZGVkV1VE9GbVpPSGlWR0Uwa3VrYzZlWHdQdUF5anBRbGtCRFpLTnZqaXcyTGoyRkM1bEIzdW5ESkFsZS92THZRS0hCWGwzZ04yL3M0ZnZmY3hHZFZIanJXYTVpOXlGK2JMQ0MwMWdYa0pBU3h5QVgvZlNDaUdFQ2kwcVJpSkdtNGdQbkhjTmJzWlJ5N1dZbU1NcmE0Y2JCQkY4NkdLRlV4RWFwNEVyM2gwZGorNzhkajZzLzlJSGJQZmxaSjNuNHN5enlSNkxRdmZjd3hxQ3U2NWJmNGhuQTYvdXpsMzcvOWFQLyt6L3FuL3U3Q1NQdlFJVlVFZFVXTktzWjlWaUsyMlNBVHNTaGdtS2FKenN4OERNYVNJMDRmMWpGc0dDTVM0K2Q4ZXorVGpLWmJXK2FTMW5lN1RwYmd6bkFlMGV5dzJzamxEd29FSlRTTURxTGVJSWNNY0Y3Y0hBd1NRWkFRMm1GTE92Qk5nMWVmZm5MdUhualJWeTU5aHd1WExpR0pKTUM3WFQ2NGtocUVpUkpBdVpBempXb3lnck1BYzU3T084RUJZODdmYTBWcFlrQkk0V1B1V3phR0FRdjl0RGE1T2owVnpIY3ZvcXI3LzhlQUl4aWZJUnFlZ2puUFVialkweW5JeHdmN09MMm02OWlOcHZpNlBnQVI0ZTdxS29heFh5R0VEenF1a2J3SHNab3VKaGN1SkVUdGpkWDBjOE1pQjNxbWxGYlJwN25TTE1FZWFlRHhDak1YUUNCTU5BRWsrYVl6eXI0TElVYTlMRnkrUXBXZXdOc3BpdElCNXRRYVk2Z01seWpERHJ2WVhxOGo3dTNYc2ZMTDMwWmpXZWtDYUIwd05mMngxaDlQY1gzdlBjOGxCWmNwcGs3Mk1vanliVjQzNGNJckRIRVRpb3dlbHFJTnlEQXh2dzJ4WUJ0bk96WGpSTEZHb3RoQkVBWXpScDhhZWNJcjA1bllLMUJJSnFQNnVQUlFmbExrNEF2TXJOYkt2TFRKL21mZVpFL0VvWGVTaUJ4d2xaMXpOd2NGNDM2M0kyRC96TmxmKzZwemZ4VG04TjhaYnVmZFZaN0Jva21TU0ltSW1zQjFHRkJwUTJ0T1YrVUp2cVkyc1pCNXNoSmFibXM3VmRlZnVWTFAzOTRQUHEySjk3MWJSL2Z2SERsaVRSSkI4RTdXR2ZaMnBxWTVkUUwyc1NWbTRsK1lXM2lINE5NR2szNy9jS0J4U1FabERidzN1TE83ZGR3Lys1TlpIa1BXOXNYc2JWMUNadGI1OEdreEdNTlFKWjFvSlZDVmM3aG5JV3pOZXE2UnBibHlOSVV6c2xNWDlVMUZNVHF5UVJHWWd5SU5LeXpNRTZET2NEV2N3R1gwaFQ1MWlVRVpteGZ1aTRyTHhhc3dYc1BIOXpDNlhVK0hTTUVoOTNkKzVqTkp1ajNjc3lteDBpekRndzh6Zys3Q09VYzFkRjllQkRPVCtkZ01IcmREa3plQXlrakVsaVR3U1FwdXNOdHNFcEFwZ2VUNWtKMlVBcFZWZVBnY0EvajZSano2UWczWC9rU2JyejRCOWpidVlYSjhYMEViNkdUSUk0d0RnanM4ZVhkRWE2ZDYrUHByWldZcjhZd21ZWk9TQkIwajdnYkYvWmJGcnVKcHZZZ0VoMTZhMTNOVFVEVzFYQStvR2xQODhEWW14YjQzTjFEM0c4c3lNaldZaktxL1B5d2ZxbjIvUHRNc0FRVS9GYnc3YlNJRUk4TC9SdGNJUVEyeHJUVGxvZHdDeG9BNnRaeHNYZnZxUGlmZXByK3pmbGU4dkh6Zy94RDIrdjV4b1hOenVwYUowM1dCaGsyaHhtTVVod2c2Q2tFZkNMUkxDTzJhTURjT2o0YzFUU2JOWlBLaGRkQ0NEZjI3dHg0ZGYvZW0vLzIzT1VuUDM3NXFYZC9hcmgyN2tyVzZhK2thUWZCVzY2cUdaeHRGcm5IUkpKVW91TU9uWmxqS2t3VHlTRWVRWGtvRW8wOE1VRGFvS3FtdUhYelplemNmeE5iMjVkeC92d1Y1SGtIQU5EdkQ3QTJYRU92TnhBV1dUbEg0Qm9VMmUwK3lNNlp2Y1E4ZDlNVXhtaFlMNWxlclYwU3g1Z2ZLT2xFdkhPb3lnWU1JRTFFbktLMUZtUmVtYmd6VmxqYk9BOGl4dWIybFRpek0vSThRWm9hZVpqRXJEVVhJT01NaStCalhsU1l6V3NBNHVmdXZVZFZGUUFZM1RURGREYkJ2YnQzY1hpNGo4bmtDTFBwQ0xPanU5aS85enB1MzM0REI3djN3TFpHeS9wUFVsb1ErMXVFL2FpcDhLc3YzVWNHd29XMWJzeFRFd3Foand2WklHTEdCZklldUYzRGlUNWVSOGRXWjBqMjU1RlpaeHVQTnc5bitNTGVNWTZjaDBrTWtzU2duRHZNajVwRGR1RmYxNFJiWU5UOFlMditnSy8vMjRsRy9yYStQdmF4aitHem4vMHNhYTNKZTkvQ3h3YlJkSUtKMGpoRXJobmdXaDk0NzFwT0grd202bkp1OUxuTDV3YkR5OXU5dkorYWJLdWZZMk9ZZzR4a1lkV0JVWlVlKzBjVjd1NU5VWlMybXZ2dzJSZVA1ai8rNXFoOEkyNkdhdG5mMDdYZXl2ckhubmo2dlIvZXZ2VFV0YnpiMnlCRkdRY0pMR3dSZHlLQ1RsS1pjUmt3Sm9sb3NoSHlTYlJ4RnVhV0ZGYkw5SEd1QVNtTkxCWDJuTllhYSt2bk1GZ1pvcHQzc2JxNkRtTlNwS21CTVFsNlhTSHlKRWJIT1Y5UVlxTUppaFRxeG9LSW9aU1FRWFQ4TjcxM2NNNGpCSS9FcEVoVGNZT2xpSHFIcGV4eUFlMTR3UTBIQ2F0UVIzLzNMRFZJakpLdW9yR3dUaXlncThhaUtBcFVWWW5KZElUUjZCREh4d2VvbXdhVDZSalQ2UmgxVThINEdsVHNnOG9qWUg2QUcvZDJjT2RvQnBVUW9ySjBrYmZXZXQrUmROaVJuMDc0dG5OcitPN3I1NUZyY1lneGNUMm1GU0dMTG9vVTQ1S2RGMm10VGhSYzdZVVpxQWkxRjgyRFZvVFJ2TUhyaHhPOFBKNWlGdVI5MEVZak1HSC83c1EyNCtwWFMrQi9yQmgzWXJzK1AxWG8vSFpvMXgrcFFtOHZwUlNGRUpaVmxxMG1QWXVIdFNRZWdGTXcwaFRZN0JDZVRSalhlZ2t1OVJMMXJyVis1OXlWYzRPVnJkV3NsMmx0OGl4RlVWamNQWmhqWE5SN3BRKy9mbnRhLy95TmNmVWlUbElxaVVpUlJMR3dBYkRaN1E4L2RQbnA5M3g0WS92eUMvM1ZqU2VNTVIydGt6YkRuSDN3NEJDSU9jQzVSZ0w4ak9SLzZiaHZseE5VbkZjV1ZzMWFReXNONTJ3RTlsaGE2aENRWlRtNnZRRjZ2UlYwTzEyWU9NZXZyYTFqcGRlWCtHV2RJUGlBTkUzUjZYVGdyRnR3dXZNMFJaSmtNZ29wRmI5UGd5U1ZBTVZFeDU4cjNwOGM3WmxBSnc0eXJkMVVZS0J4b3IvMzNxR3BTNHpHeDZqS09hcTZoZzhTTDFVVWN4d2ZIK0hnY0E5bFZhQ3hGWUp6VUd6UjVRbzlLcEZVaHlpTzl2SHEvV09VMXFMMFZzaE1FUVR6Y2IvUGNmWXlacGxRSWIrZkdZTVBYOWpDKzg2dklVc1ZrbFNMdUNWS1QvTmNwS00yV2wrM2diV0tnY2FKSHI2bFNlNU9LM3hwNXhoM2l3cXNGUkl0K0lvMmhnOTNwNWp0eis1d3dIOTN6UGl0dUVhYkxqUGYzaTR6K1NOYjZGcHJpckc3cDVXWHl5a3Q2ZEtKdnpBRUpXRFEwYmlZQjF3empLdHJQWFZ1a0NZWCs1bTVxSTJtd0pqT1BmL3lWdy9tUDErNGNJd1RkVkg3ZEZZQUdRbUo0RmJ0dWQ3dHJ6eHo2ZnA3dm50MTQ5d0g4MDd2K3NyYWRzOWtPWUozekRFaU9BUkgwVDRLSVRoNDd3QUMwclFEa0Y0SVJBQTUvWlhTTWVneElFVGFtbElhSUNWRjd6MjhkNUZuM3FEVDZTSExNbGhuNVdHaENGbVdZZEFiZ0Vnanl6cGdGajVDbG1VaW9lMzBvTFdDVmdaSmtnTE15UElVM3NWSVpnZ3E3WDFBRTVGNDBZeFhzSTJzQU10cUR1OGN5ckpFV2M0eG40M2hYQ01PTzFBZ1pRQ2RnTDFIbnVWUUNFanRJVkkvUTdjWkliTVRHSEpvR292WGR5YjQzSnRIZ0daa0dvdFlxWlBOUzF3RkpsRldTeWV2bUlPSmZwcmlFMWZPNGVtTkZhU3B1TXNrQ2tpaUxCVVFHMmpuV3ExRGdFbGw1UEJCL3Z0dUhFN3hwZDFqSEZvQkhUVXBLSzJRcEFiVGNjM0hkeWFXdlAvWk1lZ2Yyc0RqV09UekpRRHViVFdYUDZxRkR1LzlXWEpyZmNiTG5IcTF5MkVEb2d6TUNZREJCdUZxcW9Fc043UDdaWGlsOW1FUzE4dk4wbnFrUFhEYmZ6Y0ZLQ1ZBcy9ET2hxVFUweHZuTHIvLzByVjN2NnMzWEh0M2YyWHRjcFozdTVMR0VhUzRKUStackt2aGJBMVNBb0FsSm9XT29KMVdTbEI2cGFHb2pRd1d4SnBVRzdqWUpyNTZWT1VNekhLU2UyOFJ2QlV3elZuSkVPUG9uRW9LcEJSQ2tKV2dpYWUzanJ4MUJzR1lSRnhlbkYvUVloaGlneXlZZzV6bzdZbHZYUk9MTVdhclI4a3B4NVJUQWlNTk5RYXFRbW9DS05SWURjZElZZUdhQmxWbFFhUlJOUjZ2N1l6dzh1NElyYVNOWTZrb3hLajFOdllwT21XUWl2NTMxSXB5UkNaNnBkL0hKeTZmeDlhd0s3bm0wWVpKQ0MrU00yOXJCcWxZallxUXBScWpvc0hYOThaNDhYQ011ZmRJa2lSbTN4Rk1tcUFxSFIvY0hrTlY5ZzhLd3QrZkJieUVzN1hsL0hZN3lSL1ZRai85YzUvbHI3RHNzcVNYVG42ejlPY1VTWGJSZmdCUnBMZ284dFBoOHUzM1dlNGdVaUpLbWFGRjZZMEV3TmJLK3RaVEY1NTQ1a01yYTFzZlN0TDBlbmV3dXBsa21TU01ncGc1Y1BDT1FFVGVONkM0NHlkZ0lRbHRGWEphUzdvcVlydmRydThFRkNOWUsra2d4cVRDNEZhaUZYZXVpVTYxRmJ3VHR5cml5T3VQUEZFaUJRNnk5OWRKdWxEanRkaUJpbWtzekNITzcvSzloY01lRTgrSlFLUkJKRWI0NUJxb1pnYmpwdWk2QWx0MmdsN1hZNlk4bUFONm1RRUNZVEpyTUNzc0ZCalRlWTJ2M2gzaDFuR0JMQkc5ZkF0VTZxaWZqemJ5SUIzOTdaVE02THA5V0NrbG5uYWU4ZXphS2o3OHhEYnl4RWlLRGN1T1hNdVRHYURXZTBDK3gzRlI0OHU3eDNqbGFJS0dBN0kwaFRaR2dFbWpVRGVlRCs3T1FMTjYxd0gvd3pIak14RjhhMXYyZW1tVmhyZHJvVDh5VmxJUENabGFCajJXZlJIOXFaYzcxWTY3cFErbi9mTm1xUVU3VFhZSUQvbTNZN3RHMFJjRDg3b3M3aHp1M1A3NjRjNnRyeFd6MGN1MnFkK3dkUVZTYXFBVVpjcG9NdG9RUUt5VWdWS3lDMHlTRE5ySW5LK1ZBU0JyT1ZuUEJjaERnVUJLTDU0OVdwdkYxN1lvdkdSOXE1TUhCRWhrdFZFcnY2Q00wVWxtbW1xbHFVUlJieTVXV0VacHFCZzRFMER3cENTTUlBUVFCeGhmWVZWVk9LOG02Tlg3Nk16dllLM1p3UkFqRE1JVTNhb0VoNEJHSzhtQTF3cSs4WmpQR2xTMWcyMGM5bzduZVBPb1JHVlBpRGxheHhOYmljQkdxWk5NT1RHTG9FV211VFlhU1JUcmFLMHhiaG9rcERCTTBoaXh4SEg4RnZ4QkpTTEZiV3pBbTZNWmZ1ZldMdDRjVHhHSWtTV1NVMiswZ2xZSzg3bkYwYzRjZXRZNE1QNmZNZkJ6L3Eya21PV1RuTisyQnlYZUdkZkRDdjZCd296ZTk0NU9pdG5HQXJja3YrOU9GVExqd1F6cXNQUnIreEJ3U3c4U1QwUU1vUGJPN3Mrbm94c0hPN2UrT2puZSs0cHRtbGNuUjN1enBpN21wSFFuemZOTzF1bVJJZ1ZqTXBCU3JMU0JTVEpvSFdkMWRXTGw2R3hOek14YUd5SVFjd2pFQ0xIRmwrS1dkajNJN0txaUEwd1FkTDB0RGswNk12ZFViTEFaUHZnNFdiVC9jUXFPbFJRM1M3U1Q1RjZWMktBSkxxVlRiRFlIZUZMdDQ3bk9FUzZiTVhyTkNHRTZRc1lXWkdUVnh3NlkxaDR1QW1NbWlJZjhhRmFqYWl4R2t4S3Y3ODh3amY3ckllcXlXMldabG9XRXZDRHZ1SW9qVE9zVzA2b0o1Y0drNEFBY1Z3MDZwSkFwRFI4Q2pJcmNkaEpubklONWd5L2VPOEpYRHNZNHFoc1lreUJMTTVoVTVNZEVDdU54amRIZW5NM2NrZ0UrT3dGK29nSk95MDd0S1hycjIvWWl2TE12b2dmYi9PVjJuNVo4ejArY3BlS3ZNdm9Sd29PdHhPbC9RNStNQWd0OElKSFducEtJMHJmdGZnZkFjREJjVzF0WlAvZjhZRzN6M2NPTmN4OGRybTlmUzlPdTZLckZtMG5BdGtYT21WQlNtWm1KV3ZXVitJeUhZRUdreUpnc250U01FRVNYbWFRZEVCU3NiZUJjRTBrNzBoMW9sVWpMYlRSYzhQQ3VpZC9YZ29OSHBnSnlORWpZbzBNMVZqS0x6YlNDcmdxczVRSEJlZGpDSW91T3EwbWlNWjViN0I0M0lFTVlSMk8vcFBZWWx4YlVOYURBeUxSQ1VUa2N6U3JNeXhwdjdFMXhkOW9zVEJZWFQrWVkvWndZUWRtVFJENHMxeURHSmdHVTBJTGZycldFTTFEY01IZ0d0cklNSDk3Y3dEQ1RrNzNUTThoVGpkMTVoUy9lUDhMT3ZKSk1OanA1QUpCV0VxaDRYR04rWEhHMzhhU0JyMDZCLzNrTWZJNGZUTDZxVDQxMy9MalEveXhiRmxya2pwRmV6amdsa0kvQkJZa0NFa1dMUDBxajg4cTRBYnUzamd5bkU0OU80d1JuZ1lMSlVzRW5BREtsOU1yNnVZdFh1NFBWNTdLc2UyM2ovSlYzcjI5ZGZFWnBuVGxueFg0RzRLYXVsSE0yYUpHZ1VUdFRKMmtYN0QyQ3M2QjRldnRJMXRIR3NGWUp0TkdVcEdMUlhNN25xSnNLSEJvRTFQTGZYRGZvZW9lVUd0R2ZrMFdYR3ZTTmhXRUwxM2hrbWpEb0FIa2lwaFFjaEU3YVZBRjVydUc5WktNVmxjUGUxRUpsQ2xNbnlTZXVjSERXUStjYW9YWXdTcUZxSE9abGd4czdZN3gyVUlqVHptbVNWQ3oyUUlEUlFMY0hKSEZpRWZVWkFLM0VsVGJxREtKbks1WVZkbGU3UGJ4dmZSM3J2UXc2VTNqdGVJSlhqNllZMVUwTW5GQ0xEaUV3TUp0WnpNWU51SEtoNTFrbHdMMFo4QStPZ0Y4TndBUW43cTMxR2FmNTI3clF6VHU5MEZ1bFZVcmc2T2N2aEF0TlBMYnkyUmdDQm9rWUZYZ0dqQ0tzcERHRThPRmp3dkwvZmt2eTBhbWlYeXA0TWdEWElmajV3ZjNiKzdoLys2dEs2L3g0Lzk3Nnl0cm1lM1dTcnNhWlArVVFFSHlUZU84ZGtlckUvWFlPQW5kNy9lSDVwOWMrM3Rub2JwTW5KdlpFb1ZXM2FXUWRBL2ErM3I5emhNTzk0OVFHUjBvSHJHM202QTAxTXEyQlVRR3FHK1JGZzc0aTVOMEVXYXFSa2hMZHVSYlhVMnNCc0VhV0tUUXhJS0h4SGtrVWh6Z25SQlRMQVlvcEduZ0FOdGNJSkVwQlpZUTFTRnBRN3R2SEpWdzgrVSsvaVJxeTQvWVNiWTV5RHJoTVR2YUVBQmdWSVZSeC9mRUJDTVF4TnBvUWpZYnc1bndHSXNLVFlZQmJPM1BzbGpVY1J5OTZyVVd2enNCOFpqR2JOckNsUjJvRGQrVkRPcG9EUHowR2ZqT2NPTGllcHJnK0VrWCtMVkhvYll4TmFOUHEyamJSTDVraFF1YlFSWklxR0kwbmVPWS95dk1rbkZIOFBoYThQU2w2TnFlS3Z3cmU2NE9kMjBjSE83ZHZLSzFWdEh0V0owN09MQTQ2RWx4aG1FT3ljWDV3NGNKN3J6K3RWb2JiYUFLVER4eHFGMmJIWlRFL25PM1hSWDF2Tml0N3h3ZnpwNUp1bXA2N3VvSHpsOWZRSDZUZ0lHMitYKzFnM2t0UkZnMW1zd2JyTm1EZ0dacUY3ZVl0d3pzUG8wV2s0MXhBa29nSWlHTytlSkpJV1JXMVIrTWtCaWxBVWx2cTJxSXBIVmhMT21sUldoeFBTcnh5YjR6U0JxZ3pLbVY1TmpKdFQyeGxsODRLY0FranpSazZFNDY2N05ONUFTWkNSVEFTc2hHNFY5ZllQMmpRY05UbFV6UUNyVDNLdVlXdHhIRENlRWFQd1psOCs5MDU4TTlHd1A5bmdVT2NlTDQ5a2tYK0xWSG83Vlc4aGNwdzh2bFVIcWlXamJ2c3Y5Zm5kOVpmOEV2RjdtS0IyNGZ2LzBtekR5b3NPZ0pleGhrMEFNMXg5dS8wMHd1OWZ1ZmNlSDgrUDc0ejNpbVBpamVPOTZiM20zbXo3NnlyeWFobnV1dWRqNSsvdnIyeXZiVkt3MkdHdkp1STgyMTBSYVRBQ0VTd2VZb2pwWEZjVzVpaXdXRFdZRTByREluUTBRcE1ranJiTkVEVGlNc01HYkh0cWlzQitxcElMKzBhTWVCMG5sR1ZEWHpqNFJKSnh6azhtdUhWM1NrT1M3dllrK09Fa2ZSQUVBV2YzcDh5WU5wM3N3bUFCcnlPaGhNR0NGcGNZNElTeWx0clplV0NHSXBRQUp4bE5JN2hHdy9ySlNrbUFkQmpJSTI0akFNT1N1QWZUNEJmZE1EUkV2aDJXcEhHajlMOVQzaDgvV205eDhzMjYwdjcvRVhSMDZuZlAvMzNIdUQ1OTRiNXVjM0x3ejgzT2l5cmNsTHVCeHZtSWJEcERmT3JLeGNHM3pmYzdIOWdmV3ZRSDNZVFNwa1JHZzhPQVBVemNCcVRBcnd3d3B3TjhGYUNGQU16UXVPZ0s0dlVldlFxaHlFRGEvMGN2ZHdJQ1lVQmsycHhSVzBDQWdlTUtvdURXWTNoYWdmZUVJNUxpK2xramx4cHVOcmovdUVNTjQ5THpCcS9XS09kVHBiaGg5eVFaeUdnS1FtMjBncGNkR3RaVGRFa0l5YXdlQSt3RXpzeWpiaEQ1NU9Wa3pyNVVuaGdYQU0vT3dGKzFwMmM1TXVyTlB1UTd1MXhvVCsrenJ4Zkg3elBpWlFReTg5TVZUck5BcFJ3U1VLdXRFcTk1ejRCdzd5WGJxOWRXSGxoOCtyNnAxZTNCcy8xKzZuSkRZQzVwZEFXVjJBSmN1aUpLMDd3b3RsbUgrQWFEMmNEZ2dzaVVmVmVnTE5KaWZuTlkzU2FnQ3ZuQjdpeTBjTmFMOFd3bHlGUjRzbFcxdzczUndWR2hjWEtJQWRuR29VUHVIbnJDTE41alVsbGNWUTRpVjArZFdLZjllYndHVzhXVGowTW9oWkZDajhXdllwNFM0anpmVnZRdkZTU3hDY2RSRXU2WTRBOE1QWkVQejlsL3VsYVBQUFBDa0QwajhMTy9IR2h2MzNlNytYNzladkZwcDB1OURhT3FndkN3Qmk5c25WbDdkbnpUMjMrME9xNS9rZTcvWFJEZytCdElBb0IybmxaTDdETTFkNEZjRGNWVjFjWEJQVm1SbkFCMXNvY1RpNFd2M1d3em1OOE9NWFJHeU80MmlIWENwdURITnVyWFZ4YzY2SmpDUGRISmZaR1JiUk9OcWlaWVVQQS9lTVNvOUl1T01oMGFyQ2xoeFF3bi9HayswWkZmeFlxdXZ6cjZVQktPaGtWV3RDK0RNQy9MSWgrcW1DK2pRY1ZhWTk4a1Q4dTlMZkpwWVR0UnN3QnZGZ1R4UnVZdVYyUnQ2MzdvdER6YnJKeS9YMFhQbjd4bWUwZjdXLzB2cE44Z0xlQnZRMFVmQUNzUjhvTUJYRzVGUTl5QW5VVDJUQTRMNkJrWUFRZjRMeTA4T3c4blBVSXpnTXVvRzRzanU2TVVPN05oVFRNRERIZ1ZraUlVUHNBSDM5QWZRb0tvWWYwdVB5UW9qejlkSHRZUzMvNmE1Zi9IWDdJalBTUXJ5czA4Ry9ud0QrYUFTL0h3bDR1OHROaUZYNGs3N0hIWmZhMnVmaGhyelRMRUJsM0QyUm5iMTVjV1gzaTJhMi92bjFwNVR2WmgrQjlRQndCcEhocko0WGJlajVtQ2FpWFJzcVpFSUlROWVhTzVXVFhVYWdpVmt3TUQ1R29kdGR6cUVHeWdBZHpFTFFQcUoySFlVWVcxMXB0MXJwYXVybkNRMmFXYjNaYW41VVVlOWFidFV5QlBFczZ0bkFzT1RtYU9TTFJoUUorZVE3ODJBd1B4Qmsvc211MHg0WCtOcjVhTTBhTzNEeGVlZ0ZBZDVCenBLUExLMUxUbFNJTkh3WndBY0VGUmt4QVVackFjWTNVQmcwU0F5cFJNS2tvMW5TYlpFSllxTTBrblVYRk5GS2g0TGFwb1dtYVlHV3JCK3FJSDV1UDRGYTZXRnRLNTlCU1djT3BOcGxPRmFkNkNQcDQrdFVXK1ZuNnoyODI2K0Qwa3hFTEVJNFNvRkxBcjgyQW41b0JMOFhpUGwza0hvOEk4KzF4b2I4VGp2cDR1ajV3bkFFWTdjK1BqdlptcjFnWE9ESTVGemJTVEVBd0lrTHhMb2lyaWlJb09nSEVhS25JOVlJQUhNTU9OTUVZdGJCUE5scWowMG1ScjJkQVFvdFRjcG0rZXJxdFByMkhPbDMwK0FadC9jTmE5TE5hbjlOQXhzUCtEUlhubmt5QXRsK2VFbjY4QUc0c25lVGxHVVdPUjczSTQ4UHQ4ZlYydjZxaUJ0NjZaa3ZyeXBudWFtZGxzRFg0T0xSS09UQ0h3T1NjcEtrRWlOa0NtR0ZpbUlMM3ZNVG81L2dRaWNjd24yU1VoVWlLOFRIZVdFWFhHVklTbGV4cnNYMEpaeFFYUFFSOGV4Z285TEQ1bkw3QnlmMnd1ZjcwN3kxMURweUowdldBZ1orYkFQKzBrSGE5eGx1dG9CNFphdXZqUW4vblhhZlJkd01nNmE5MGtwWDEzc2V6ZnJacW5RY0xhSTdRY3NpakZZdk9qSmhJY3F2M1ByR3dhb3UrOVpId0xxQnB4TW9LVEZMa1BpQllMMUNoWnRTTmcyOU9lT1hxSVNmM056dGxIOVorS3p4OEZVSGY0TFEvWGVSS3FJaVVDY1h3cXczd00wZkFQNnVCZTdISWk0ZTA2KytvNjNHaFB5SlhrbWlLN2ZzRGhlNnNVOE9ON3VXVmpkNTd2UXVpM3dvQ3hpSHVqbHJuMU1TME9jbW5UdDJJcENzaXVNWmpMaDBFTk5IaUpBL1dJMWdMOXNMYjgwcUVMUlFlZnFLZU5YT3JNNHIzWVhQNjZZZUZlc2lmbi9XOUl1R0FVK0d0QndaK3F3Qis4aGo0VEFDT1kzRVhaNXprNFJ0TUZZOEwvZkgxSjN1bG1ZRno0UzJudXEwOTU3MDBHd3c3MzVGMzBvN2tkVEw1MXRvcEV2aTlaeGdqQVlJcW9sUlM1QnkxSVFwMVpYRThMa0dra0tmaVU4OFBJR3UwTUxOVXhBdHJKanlrTFQrTCtiT014dE0zbWMyL0VWMVFuYnFKbDFodVNLUk41MVFlYS9zZStKVTU4Qk5UNEE4aEFwVWFEN0ZvYm1XRy9oMVU1SThML1JHNnJqMjlpYU9ET2NVd2l3Y3NzMnp0NjhGcTk4bkJXdjVVOERLbnQwaFZDQkpGNVZrMDdGbHFvcFk5Qm1ORU1HMCtxM0Z3TklOSkRRYWRWRUlOZUxtbzRoWWdXbHBSWUNqRmFCb1BkZzk2YlMzUDNYU3FjUG5VU1h6YTZiUDE1RklQT2NYMXFaWm0yUTAwL2g1SEQ4a1FnSy9Vd0UvUGdIOVJBRy9naE5LNm5LamlJWm9uYm91OFIrRHljZXYrK1BxenVJNFBpK1VJNlFmTUxwcksyZDRnMC8xaDUvMXBtdlM4Qzl5YXNyUXRQRmpRZDYzRTJiU2xoSEZnSEIvTnNYY3dROXBKc0Ryb25BQno4WUVRV0ZSc0lXRGhWQ09uT3RBNEQxdUdzMWhuV0o0enpnTGVsZ3ZaTEozTUtSYm9PQkk2TWZGUDQwT2dmWm1sVTcrZFVPTDRjTThDdnpRSGZuSUsvRTREN09ORW5ITGE1ODIzZnplSjVuOGcrWUxIaGY3NCtsTy9PbDBEa3lqeUxpeUNZWmJxaU1wcFBSdXM5eTUwKzltekNFd2NFRlZrWWJGeUN6R0FNRXMwMGtRTUtYYnVqN0N6TzBhM24yTmp0UWZ5d3BJRHhNa21oTGpURDdGRUE4UFZqUkJxQU1tRHEvM0NHckYxU0Z4SVRQRldkYzVaVGgwdFRUYWNhdThmK0h1MFpDUnk4dS95MHA1OTZvRGZyWUIvUEFOK29RUnU4b2xaeFBJcGJuSGliY0V0S3QvK1hQTjM0UDN6dU5BZmtTdlBOWmdCYThOWjJ5ZmpyRzlzNDhiZFFYNDk3U1RuZ3c4Y0dHUmRBREhGK1Rvd0I2SFVPdXZvNW8wOTdCOU8wVi9wWVh0eklKeDNIOFNQTGFiUG5oQjRCS2xIM09tTGFTWGcyYUd1SGRpZVhaekx4YTRlQXRndGYxMWI1SDRackd1dDcrbGsvOS9PMFBGWXJnSGNhSUIvUGdQK1NRVjgxUUdqcFJPOHdoa3h4aWFhQTdUNUVPMGY0bkdoUDc3K3JLNGsxU2ptRGtwUnV4bkRxZkZWVmJObTFGMUpPOTFlOXJ3eU9nZUROWUZTcFpoRTNSN3FlVFc3ZTJ1dnVYM25JQjFQSzFwWlc4SDVjMFBvQ0xTMWFqRGdaTDdIVW5SeUNCek5HMks4c3ZjaWRhMGxQbG92RmJOYU90blA0cHFmQmJpMWxGWWRUKzJrUGNGUGRuVE1pQnB6b0dIZ1hnUDg2d0w0UndYd2I2enN5ZHM1dk1UWnFIcUlOejlydkVQM2FZOEwvZEc4YkJNV0FRNDRlNzJzbU1HVHcySjNaYjI3MWgza3o3VGJNVVhNdG5ITjNxM0RWKzdmUFB4YVpkMkdTcFArK3RZcU5qY0hsS1dKeEVhUmhFTXNDanVHTXdiclFacE9UTzZKSkxBd2xpc3pveWs5VkRnQjNHanBCa3RQbmZUTGxsR3Q3bmI1aEU4Z2N0TTJvRUdmcExLd0VsOTI2NEZkQi96Q0JQaXhFdmlWR3JnVkhnVGJxcVZaL0N6RENHNDdEUGN0Y1A4OEx2Ukg2S0xveFU1MHByQ0xBYWpndzd5Y056dkQ5YzRUV1NlOUhCejc0NzN4RzdkZTN2bk03dTN4Wi9MVjd2V1ZjOFAzREZiN3FwTVlJdThscDh5SUpSVEhsbjNCYWxNRWltbUhIbks2MHlsMVNYQUJydlRRanQvaURzTTRRZUlybktEcWV1blhoZDBPeVFrdVhId3hoSXg1RTJMMUJUUWUySjh6L3UwVStJa1o4SzhhNEpZL0NWTW96bWpUejNKcVplQkU3SUxIaGY3NGVqdGRMVkpPYXVIdWpGT0hKUU5RVFdsM3ZBMjdTdFBXYUcvMGxac3Y3ZnpNOFVINWU5dlhOdCs3ZFhYakI3dTlySnNSVVNnYjFFVU5iOFVYVGhuSlpWKzRNOFE1ZkRFY1I2WWNRNUQ0VnZrV1FvQzFEcUVLRDZ6TzJoL1B4MklQZUJEdWJpdHh1YS8yQkc3Tjloc0dsUXd1QTJZbGNGZ0YvT2FVOFpOVDRPY3Q4SEk0b2E0dWU2MHYrNjIvNVJUL2xqMGtIcGZQbzNlbEtZRVpGQU1EbDNnaWkxZEdSQmtSclRHellXWnNYbDU5OXNrWEx2L1hTdEg3bW5tdGZOV1FEdUx6N255QU1ScDVMMGZlejVHbWtvdmtyWWR6SGo0aThhSmZqejd6MFoybWFSeHMwNkE0TGpIYkxhREMyZTRhN1FrK2o1VjRGbkhtRkxtbUFYRHNaVlgydXc3NFVwRGkzby9GMnlick5LZWZGWGpRSk9KYnVzRGJ5end1bTBlMEZkUEVSRVJORTFvY3llR1VQRHVFWUltb0J3Q0R0YzZUUnVISmVscHFWelh0Q28xSlRDTEoxUTZ6ZW9aNlhxSGJ6NUYzVTRseElvQ0RnNDh4VGNRQmlqUUNpZXRpWWpRMHBYQWRCNVVvaERvOGdMQ3JVd1U4SU5sM05ieElRaVp6QXNRNUJvNFptSHJnYXhiNGJRdTg2SUE3TENkMkt5cy9YZUFPRDZiemZDTngzTGZtL2ZMNExYajBMdThsaDh4NUJoRVJuMmhMVG5zeHRQL2Z1OFlGNVd3U0dzOElJUU1qZDk1UnNKN1llZmJPd1R0SHpiekVmRHhIT1N2aGFodUZib1FRaEF2ZnN1bGFWU3RJdk5RRE0yeGg0V3Yvd0s0OHdWdGNNYmtUeVhWeHBLOUozRlp2T2VCek5mQXZLK0RuQ3VBWExmREZBQnpFd3E3eDRENzhZUzA2UHk3dXg2MzdPK3JLdXdvaGdKcXFEWU05TTA2Nkpaa1pBUDF1VnoyenV0Yjk5alRYMzBrS3p5bm1iWERJdlBjTEcrZ0ZRWWFCTkUvWlpDbElLWmpFUUNlSmhFRkhlU3N6RThCb2FvdlovVG5jcU9ia3BOcm90SEtOQVNRS2xnajNweDU3Y2RaK3hRT3ZXK0EyaStDa1hpclk1b3pUMjUveE1IdmNwajh1OUhkd29YdWdxY1BwVVhkNU5EWUFFaUxLV0hMaEU0aVE3Y3BnSlhrK3kramJRSHlKZzk4QXdsVWlyQklvYWIrSGFtT3NZblN6aEJES0dvNEpDSUhaTzBKVEJ2akN3elNCMm5ud1ZDSmx3eEpTZUQ4QUx6UGhDeDY0VXpIdUJrSE5MUjRNeFZ4T3RUMDlmNGZIeGYyNDBMODFQOGk0OHlKaXhBekdNLzNnNCttZTRZUmlQaUNnbTJjNGwyWjRSaXVjQjZHbkZNNFQwYVlpOUVpUkFZaUlrSVBaZ2tYekVnSWJXL01WV3dMc0ZxMjVWY0NNZ1NMU1Q0OENjQ01BeHdGNHcwdUxmZ2RTM0E0UFdycWRCYXFkanE3bUplVXRQNjd3eDRYK0xWdm9NUVdXT0p3Wi90aUdQcWFuUnVnV0dFOUlJVTBUV3RFS2ZWTG9FcENBU0d0Tk9UTTdZaEFUc2JlaEV5ei9lVGhzRVRCbUtmQWRCdTR4TUdKZ3dvS2M3L0VKUzIxNXIvM3ZVdHh2Q1V4UWtlenlTT1FWUHk3MHg5ZWYxSldrQ3M0R09zV2llMERhaWdmejMwNUx1cy9VbER5SXFRRVFYc3VXQmxiaVRyc09RTWtQU2tBOTNtcldlbnJXL2tiRmpkTUFXenVUdU1jZjllTkMvMWErVEtMZ2JEajkrWjRWOGF6T2VBQ2NmcDJWSUtPWC9zMkgyYmkzQlh2NmxQWjRxMFB6YVZEdDhlejl1TkFmWDM4TW56ZmhHMmZCblg0bzhFTUtYdUZzb3hoZUt2TFRwM1E0OVNCNHZQZCtYT2lQcnorRnovMWhwcXRuT1VHZDliQTRmWkx6R2FmNmNrSTFQK1JySDErUEMvM3g5U2Q4RC9BM0tlaHY5SkE0WGVqNEpzWE1EL20rajYvSGhmNzRla1R2bWNlRi9EYTUvbjhuL0thd3k5UHdQQUFBQUU5MFJWaDBZMjl0YldWdWRBQkdhV3hsSUhOdmRYSmpaVG9nYUhSMGNEb3ZMMlZ1TG5kcGEybHdaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPbFJOVGxSTmFXTm9aV3hoYm1kbGJHOHlNREV5TG5CdVp6Z2JXU01BQUFBbGRFVllkR1JoZEdVNlkzSmxZWFJsQURJd01UVXRNRFF0TVRWVU1URTZNREk2TXpNck1EQTZNRERlYkVZSUFBQUFKWFJGV0hSa1lYUmxPbTF2WkdsbWVRQXlNREUxTFRBMExURTFWREV4T2pBeU9qTXpLekF3T2pBd3J6SCt0QUFBQUVaMFJWaDBjMjltZEhkaGNtVUFTVzFoWjJWTllXZHBZMnNnTmk0Mkxqa3ROeUF5TURFMExUQXpMVEEySUZFeE5pQm9kSFJ3T2k4dmQzZDNMbWx0WVdkbGJXRm5hV05yTG05eVo0SFRzOE1BQUFBWWRFVllkRlJvZFcxaU9qcEViMk4xYldWdWREbzZVR0ZuWlhNQU1hZi91eThBQUFBWWRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNmFHVnBaMmgwQURNM00rVUF1L01BQUFBWGRFVllkRlJvZFcxaU9qcEpiV0ZuWlRvNlYybGtkR2dBTWpZMlVSOUhod0FBQUJsMFJWaDBWR2gxYldJNk9rMXBiV1YwZVhCbEFHbHRZV2RsTDNCdVp6K3lWazRBQUFBWGRFVllkRlJvZFcxaU9qcE5WR2x0WlFBeE5ESTVNRGsxTnpVeklMczBjZ0FBQUJKMFJWaDBWR2gxYldJNk9sTnBlbVVBTVRVNVMwSkNQR2FPQmdBQUFETjBSVmgwVkdoMWJXSTZPbFZTU1FCbWFXeGxPaTh2TDNSdGNDOXNiMk5oYkdOdmNIbGZaVFZsTW1RMk9XSXlNV1pqTFRFdWNHNW50VHprQndBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9wdWJsaWMvaW1hZ2VzL21pY2hhZWxhbmdlbG8ucG5nXG4gKiogbW9kdWxlIGlkID0gMzAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFNZ0FBQUQ4Q0FZQUFBQXlzK3NsQUFBQUJtSkxSMFFBL3dEL0FQK2d2YWVUQUFBQUNYQklXWE1BQUFCSUFBQUFTQUJHeVdzK0FBQ0FBRWxFUVZSNDJ1ejlkNVJsMlhYZUNmN09PZGM4Rjk1bFJQck15cXpLOHQ0REJWc0FDRThRQWtpUm9raEpORktMbEVTTlhHdTF1cWRINnFYVjZ1bGVxMmU2MVRNU3UzdEUyU1lwZ1JKQkk4SVFCVnNHaFNxVXpjektySFRoemZQWG5YUDIvSEh2aTR3cW9JMGtpc3dxNUtuMVZrYWFpSXE0NzM1MzcvM3RiMzhicnA4LzZxUGU5TEY2MDU5ZFA5ZkltM1A5L09GZjkrOEhDS2xlYi83NCtya09rQitZNjYycmo4M29ZNlhVNk8rY2lEakFWeSt1ZytTUDd1anJsK0FQN2h3OGVQRC9DQmk2QWtSWXZXclZxdzdVUlNRU0VTVWlvMzkzUGRXNkJvNjVmZ24rQUM1aWFGQW9UcHc0d2NjLzluRm1wbWZVaFFzWGxQZGVmeDlnUkVCY3ZVSWdPSG55WlB6VGYrcFBMM3oyMDMvOC9VY1BINjg5OWN5M1ZxNm5XTmZHQ2E1ZmduLy9NejQrenVUa0pNdXJ5d2pDNmRPbjFVc3Z2WVMxVmx0cjk0SWpVRW9aSUJTUkFORDFlaTM4d09NZm1INzN1OTkvZTczV3VLL0kzRHQydHR2eldXTC9DK0RwNm5QZDlhdDhIU0J2NlpwQ1JCQXZBS3JYNiswRmhhbXVid2dFVmVxa2p4NDkydnpnQno1NDZLR0gzdm1oMVpXTit3YmQ3TlRabDgvcnk1Y3ZQN3V4dHZyTGExdXJ2MTE5RFh2OThsNHYwdC9TMTA1cnJaUlNTa1IwbFU0WklGUktqVUFSQUhwcWVyTDJ4My9zSnc0ZU9YenN0cW5KbWNkNjNlRzlGeTljbkx0ODhWS3ZzN1A5cmVYVnk3K3kxZDU2WVhudDhpcVFWK0FvcWdoeVBjMjZEcEMzM1BVYUZkMjZpaExCbStvTUU0WmhlUGpRb2ZFLzg2ZC85czY1dWNWM0RnYkp2ZTN0enJHeloxOHpxeXZMNXdlOXpoZmIzWjJ2WEZtOTlOSk9aMmV6QWtPeEJ5Q1c2eXpXZFlDOGhhNlQ0bzFzVkZEVkZxR0loS00vdSttbUc1c1BQZmpJL3Z2dmUrRFJabjM4d1kyTjdkdXZYRm1lUDN2bVROcHBiNy9jNjNkL1BjMEdUNTk1L2N5WklzK1RDZ1NqaURINmRVVHhYbzhlMXdIeWxnSkZCUXdWQUJGSUFKZ29qdXNQUGZqQTlJYy85Tkg3eGllbUgxYVllNjVjWGpsdy90ejVhSG41OG5ZNkhEdzdUUHEvdGJHMS90U1YxVXNYUlhiVEo3c25Zb3g2SDQ0M05ncXZuK3NBdWFaVEtMTW5qUnJSdEFGZ2JyM2wxc21ISG5ybzhFTVBQdnlZOStiZU5NbHVQWGZ1d3Zoclo4L0t6dmJHOW5EWS81MHNTNys4dWJQeDNNcmE4c2FlS0xFM2pYSjd3TUgxcUhFZElHL1ZGQ29Fd2thalh2dmhULzd3NGJ2dnV2ZmV5Y25aUnhUbTlnc1hMazlmdW5neFhMNXlPZTEwZGk1a1dmclZYci96cFN1cmw1OGREUHVEUFdBWTFSaE9LZVVvdStaeVBXSmNCOGgvMFBuTUgvc3MyOXZibkgzdERPZlBuLy9mZStMdlBYdHZOUG5BNHgvZ2lhOCtRWklrbFBmajk0QkM4YjNVN0c2MENJSWdPbm55NU93blAvSERwMjQ4ZWVwaFcvaDduSldiWG43bFRIanA0Z1UyMTlmU3dhRDNuU1FkZkdGN1ordHJXNTJ0MTlNMEdWYVJJZDhiTVpSU1Rpbmx0ZEtDUXJ6M29wVEN1ZXN0ajJ2eFhOTjlrR2FqU1ZFVUhEeHdpQ05Iam5EbzBFSCs0ZmwvK1AxdWJrV3BaNko2SW50QWxGSXlOamJHM053Y1FSQzhHUmh2N2xtRVNxbW9paFlCRUIwK2ZMangvdmU5LzRaYmI3bnRrYVdsZysvYzJ1b3NYYm0wc2ZENjY2K3IxWlVWdDcyOXVUVWM5bDVJMCtRTFcrM05MNit1cjZ3QjJadUFNVXFydkZMS0cyMWtabnBXblBmaXZhUGQyZUdxRE92NnVRNlE3M04rOXMvOEdDKytkSnF6cjEzazBYZThpNmVlZkpJclZ5N1RxRGZvMkE1ZitOTHZxYzJORGJhMnQ5VDN1Y0ZITHlVaXRvb2V1a3hmOEZFWThjeTNueUZKRWlVaTM0K2VqYXBYS0NJbWp1UG1ZKzk4Yk4rN0hudlhyWE96K3g1dGpVM2N2N214TS9ma3Q1NkxsaTlmWm10ajNYVzZPNWV5SXZ2bTlzN203N2E3Mnk5MXVwM05OOVVYZXlPRzExcjdlcTB1ZVo2anRaS1RONXppaVc5OGlmR3hDYnozZU8rdjM0blhVNnp2UFovOXpLZjUvT2QvbTI2dmg0aXd2bmFldi9TWC8zT2VldktibkQ5L1hqbm5xRzVxcFpUU0lxSkhIZWs5VDM0RDBHZzAxSC82Ti83V0xkLzQramN1L3B2UC82dmxLb3A0cFpRb3BkVGVSaDRRS0ZRa1NEUktwMjY1K2VhcDk3NzMvYmZmZHN2dDl6WHFyWHNHdy9USTF0Yk81TVdMbDJWdFpVVjFPenY1Y05BNzN4djB2elpJZXIrOXViVnhydHZ2N0h5ZmFGR002Z3RBUkVUR3h5WmtibmFCcWFscG5uditHUTRmT3NyazVEUlBmL3ViMSsvQUgvUUljdnNkZHhESE1WRm9lUEhGbCtoMHVydDF3Ti85ci81THZ2aWxMek5NaGh3OHVLUjJkcnFJaU1xeVRJM0FVQUhFaUloV1NobWxsS2xBc2h0TjdyM243dkNuZi9wbjcxeGNQUGhYaDRQMDcveWJ6LytyMVFvTXJsTElqdlJRa1VnSkNrSENnd2NQVHR4NzczMkw5OTk3LzkySERoNTVPQXByOTEyK3N0WTZmZnJsWUhWbGhjMk5WUWI5WGpkSms5UERkUENsVG1mbmljMmR6UXRwbWd6MkZOekZucGRUU3ZrNHJra2N4VktyMVdYL3dqeG56cDlIeEpNa1F3cGJjUGJjNmV0MzNnOHFRRDc3NmNkSVhJY25mdjgxZHJiN2pJK1BVeFFGZStZZGRuUHVXKys0VHlWSm9yd1hybHhaMVh0WnBEMnk3OTFYQlN5SmEzRnc4TURCeHFjKzllbmpjN09MdDRySVRSdHIyNCs4K3RLWjVEdlBmL3NLcFl4OFZLeWJVUnBWU1Q5cTczL2Y0NGNmZWVTUlc0OGNQdmFRRW4yVDkvckloUXRyOGVYTGw5bmMySkRPenBiMEI5M3RKQm0rTUV5SHY3bTV2ZjcwMXZibWlvaU1RSkh0clMrVVVoN3dSaHR4M3NuRDk3OVR2UGY4MUkvOUxELzVaMzhFZ0Y2L2UvMXUrMEVIU0QyT3VmLytrN3gyK1F6MVJzVDJscWh2ZmZNYm1DQlU0cjN5M21sajlPNlRmemdjS3VmY1hoWkpWeEZpQkFvTm9EVEJuYmZmR2QxeHgxMExVMU16eHc0ZlBucXpDSGNOQjhuSjgrZGViMnh0YnV4c3JLOTlmbTE5N1N1dm5IbXBEVFNyZ24zMGRlS2p4NDZOUGZyd295ZnZ2dXZ1ZXc0ZE92cnVOQ21PcmExdE5GZFgxMWxiWFdObmU0TnVwMTBreWZCS2tnNmV5WXI4aWUzTzF2TWJHMnZyZTZKRldvRmpiOFNRZXIzaGpUYUVRU0RiN1czSzFORHZndVA2K1o1MFhyMlphWHpiMWlCLy9hLy9kWWJEQWErKytncFAvUDRUSERnNHE1U3hYTHl3clpJazM5dFgwSHRTbmF0RFFTSmEzbGhUS0VERmNSUWZQMzdEMkRzZWZkZlN6YWR1ZWJqVDdaK013dkJFdDl0ZjJsaGZzMnVySzYvM3V0MHpHMXZyWDkzWVdEdTl0cmwyY1UvRVVJQnFOSnFOajN6a0k0ZnZ1ZnUrZStkbTV4NW9Oc1p1U3BKczl1S2w1V0J0ZFkyTmpYWHB0bmZvOXpxRkxZclhNNXQ5WVgxejlZbjF6YlV6UlZIc1RaOUdVU1BiVTR4YnBiUnZOcHJNVE0zSW80ODh6bS84NWoraldXK3l1ckh5QTQrR0c4ZGJiR1U1bTFtK2QvQnJMOGtpYjNwZGswRDVEd0pJRkVVOCtlUzMrSTNmK0J4UFAvMk0rdTNmK20yY2Qwb1FMZjRxSUxqYWZSNjk5dllkTktESHhxZWlnd2NPdEE0ZVBEQi83T2dOeDVmMkh6b1ZtT0JVdjlkZnpMUDg0TXJLY3JHMnVyeTZ0Ylg1Yi92OXpuTmJPNXN2N1hRNzI5NjVncXY5QzFGS0JiZmVldHZrZ3c4K2RPS0IreDk4WU4rK3hZZDZuY0doelkyZCtNTGx5N0t4dGs1N1owdjFPbTBwaXF5Zlp1bXJXWjU5clRmb2Z2M2lsZGZQTyt2eXFyZ3Y5cVJVZTBFeWtvTzRNQWg5c3prbWNSU2hUY0RLNnVYcmNhSTZ0MHlNMFM0S3JnelQ3OGM0N2xVTmVONDRYdnpXQnNpdi8vcXY4NVd2ZklWLzhBLytBUUR2ZTkvNzFEUFBQTVBtNXFiS3NreDc3M2ViYlh1SzRnZ0k1K1ptV3gvNXlFZjJIVDI0T0RjelBUYTlzSFJnK3RVWFg4aS8vcFd2SlVkUDNIVFQyTVRCdTZ5WW1TSlBaOXM3MjNHbnZWMXNiVzJzZHpyYkwyL3ZiSCt0UCtpOTNoLzBMaFRXSm0vNi90V0JBd2NuMy9PZTl4eSsvYlk3N2poNTRzWUhneUErc3I2K05iNjh2QnFzckt5eXRia2g3ZTFOMWV0MnZQZDJLeS95cncrU3dkYzNOdGVmM2RyWjJ2TGVGUlV3ZkFVTWUvRGdBZk8rOTMyZzVyMzR4YVVsRnVZV3g3NzB4UytjLzQxLzgrc2RwWlEzSm5CanJYSFphVzlkUjhUZWZPbC8rTnNjK3N2L0pUM3JWQ2N2bEx6eDRjaGZPWDdrMEhlM085bHY3ZXhjNXFwWTAxK0xFZVRmcVFiNSszLy83MU92MTNmQk5SZ00rSTNmK0EwMVNwK3FJamlrR2lrVmtiRFZhbzZkT25YVDdDLys0aS9jZCtyVXlZZm1wNXZIcHNiaWVROWpwMTgrSDY5ZUtkdzk3NTd5cmFsMWsvUzdabTFGY2VIc1dyYTIzUGxPdTlkK3V0UHBuZXNuM1N2TythSE5YU2FlMnVncEZOY2F3WDMzUDdEdjRZY2V2dUdlZSs1OTRQREJRL2VzWEZtYnZuaHhOYng0OFJKYlc5dlMzdDZrMDlraHoxSlg1TmxxWHVUZjdnOTdYN2w0NWNLelNaSjBlS08wM0FQdVl4LzkyT3g3My9QNHc5MU8vMEhyM0Z5MzI1TkJaNmd2RHk4UEF4UDlIZUJiZ0JMeDZ2L3FteG9HaG1QelU5UUN3M01YMTk3ZXhjYWYvVTk1OS95TSt0cm10dHBEclVkQThFczNIai9jeW9xL1d2UCtud0xMYjZzaS9lREJnL3pTTC8wUzdYWmJaVm1tbEZLN0VVT3AzWVpiRFlqdXYvL2UrWTkrNUdPM2YvQ0hQdlN1cGNWOXAxbzFmU2hTeVVSY0Qra1BDbjdyODcvR0M1ZWVZT3h3SGl5YzBDZ0RFK1N5ZUx0U3Q3d3oxc05rY3NZejhiQlllZEFLYUtXY3kxMjd2WjJ0WER6ZnVSVFlLZmY0STUrNkkzS05rMU16QzB1Ylc5dU5MNy80b2w1ZTNhRFRHOUR0OVdqdmJDdWI1MmxXWkJlSDZmRGI3YzdPVXh0YkcrZXlMRzFYNlJLZ0JNUUQvdEZIMzlINDFBOS8rbDI0NEk5ZnViaXljUEhDK2RXZDl2WTMwUHFsTEVtNnZWN3ZmRy9ZUDFORkxnOUs4anpidlQ2MUtGRE95VzZHWFpUeUVRRXdDaVlhTmVxaFliSVJBOUFlWm05TGdQemNEVWY0OWNzcjJMSytEQlJFQXZHSGwvWXRqQlh5Tnk1MCtyZWVIZ3ovbXdvNEJkZXc1T24vRWtBZXVPY092dnZ5YWY3SlAva242dEtsUy9UNy9WRjlzZXZRSVZLNWRHaWFmLzRYZi83bVAvTlRQL09qSjI4NC9vNGcwTTJrczZXNnk2OHd0VytmYks3MzFHLys3ci9rY3ZZdGpqMFlvM1FkaGFkaWNKVVhJYXpyc0U1MHhEa2hSRkVvUldqS08yMC80bzdjT08xWG4weDQ0WXVmRDl6QUt1czlSbW5TUEFlbHFlc0E3YUJXVS9SVXZyTFczZmhxWjN2bjFmWHQ3cVl0dTlhalFqNEE0ZmJiYjUvOHhNYy9kZWYwMVB4SE9qdmRPMTU1NlpYMTVlVkwvLzF6THo3enI5dmRuZmFlNG55a3VoVVJFZWNzdytGZ1pObWowdHgrajhlVlVrb1FvWEFpWjFhM3BCRUdLS1drRmhvS3IyakVNUnVkenRzR0hIL3RocU44dGQybVd4VEtDN3A2YU5abjRxaHhVeFIrZHIzVCtjaFdrbjV4dzd2MkhvQzh0U1BJVC96RVIvakxmKzN2OFUvLzZUK2xhdDRGZTZKRlRSSFdUeHpmUHoyeDJGLzg1R2NlZXZ6VEgvN3A5eDVkT25ZRE5zRm5vcnJybDVCaXlQYWxzK3IzdnYwMDM5bjZHamZlM0NSR1VBckNVS0ZVbWFuVUFvWFdFR2lGVmhvdm1zSUozVlFZT3MvbTZWU2YvMUpIRDljeUZTcERFQVZFWVVDZ29SbUhlTzhwWEk2MkZra1N4cENsNW5UMHFjWG01STVkR3Q5S2NydSszZTJmMyt3T3orZGlsai85RXo5NytOU050N3k3MituZC9lTHpML256cjUvN2pjdVh6Ly96MXk2Y2VhMG9pcFR2bmV6Yk84aWtCTkhJRzFnNHZRY2tYcVNNVHQ1NzF4Nmt2Z09pdGZMdGdaZUpWb3VOVG9mNWVwMzFKSGxiQUtTcE5hZTdmWlU3ci9ZUU5PRm41dWZ1Sy9ySmozYlNMTXdDZlc0cjlTbHZBVmVkLzBzQStkcFh2ME9yMFZEYmVXY0VqbGdwNmlJMDdyL3J6Z01QUG5MMDNZZHVNdStUNXNiQ1hUYy9lT1R3dnNPUnozc29wVWdHQ2NtZ3g4SytBM3puaFdkNW9mY3N0ZGtJN3pXRFZBZ0NqemdJS3BBa29naFVRQlFIS1B4dTU3QVZLVGFlSFhEaGQ5cktEMkJtWWd5dEZWbG1FUy9rcmlBckxQMGtZM09yVFZHa0tEeFJFTVFnc2VBbmxOSkhZcFRzRzQrSytaWkpUVmpiamdZYms2ODg5NTNKODVldlBIWDY3S3YvNjVXVmk4OG15WENiTnc0MHZTRjZWTCsrMmVzcTV1cm83ZDRvNGdBclVDQlNDRGp2eEFJK3pYTVpyOVZFNmpHOFRRQ3lYaFJNUnhFYmVUSFN1NFduV3EzSklDMCt2dG9mSE1xOUgrd2c1OXh1bW5wdHo3Lzhud0xrWXgvN0pGLys2bGRWdTl0VlZiMFJBUTBSV2g5NS9KMG5IM3IwNko5dDdPKzlONTVNWTA5TDdadTZEWVBCT2tHVXNMRjhtVGlPNlBWNmZQM0ZKNGhiampBSUtLeW5uemppVUZHTE5Ob0l4b0RTaWppQXZMQUVXckFpS0syNDh0U0FWLzl0bXlpSWFFMkVpSUMxanNCb2N1dlkzT215c2JtTjl3V0Joc2dvNGlqR09VK2E1NWpBMEdpMENJT0kzTG9RSVFwTU1INzZPOStnOEVaV3Rucm15c3FHU2NRSDFjMmU3Z0dEZXhOQVJ1QVlGWjkxQmJYcHNjYmtaQ09lcmtkbUhKUmE3dzVYMXp1RG5UMHAydDUraXMzeTNJc3hQbmFSN0J1dnM5cDk2NE5rUGN0WnozT2xsTktJQkFMQnJjM0cvbjZhM2QyM2hSS2xPaDB2Ri9kRVpQaytqS3E4SlFEeTUvN1VwL25DMTE1aWE3dURjMjcwcEt3RHpVOSs5RU5ILzh5Zi90aGZ2RGg0NHQxZDZac3NEYVJacXpGUm44WGxHZUlkZzhHQXp0WWF4NDhmNWpzdlBvV3RiekRXQ0xIYWtSZUFhTkpjU0hLSE1ncFJpaUFRQXUwd0NIR29NRnJSUGpQZzlTKzJNY29RUlFGS3FiS1JZZ3pPTzFZMnR1bDJ1a1Rhb1FOZDN0WE9ZNHNDdEdGaVlvb29ycFBtanBYT1VBMTFRVlF6QkFwNnltSmFSazBmck4rdEZ1Zk04b1hlMzl2YUhMNVNwWStqcHVDYngyQkhUOGNhMERCYXQ5NTl5K0YzSDU0Yi80eDRtZE5halZ1UGZ2TDA1VE5UamZqM0psdTE3ZlgyOFBUNWpmWUZZRmhGbVZTZ3lKMlQzbkJJYUpSTTFtcTAwL1F0RFpDNU1LRHdYdTMycHBReU0wRndXeXJKZnUrRklEQ0RRcm5CLzA3a1VIc2VRUElXaUNEQ3p2YXFzcmJRSXJ1YXB2b0Q5OSs5NzIvOGxaLy9zd2NPTDc3N3d0ZWYxRm5xQ1FKUjNtcGNrcExwTHQ1YnJyeCtIbzFqWTNXVnAxOTlndVkrSVF3QzRzWU0zYUpEYmd1eTNPUEVZN3doQ2hTRkZYeWdNVXBoQytpZjdyUDhsVGJhR2NJb3dIblFScGRBY1o3dDlTNVNwRFFpaFhYVlZhMmlUaERYV0ppZngzbkZsZTBkL0xUanR2ZlBzbkJzakNqV0dDWGtUc2hVUUtFTjNhNjliZjFpLytmUFBMWDJqNzc3NWN2UGViZGIwQWVqcC80ZWdNUkFLelI2N09HVEJ4NDdQai81MTJxaE9UakljdElpcDNBdzFZcVhEc3hNUEJpR3hoMllIajk3YUc3aTE1Ni91UDc1blg2eU9YcGlDa2hXV0dlZFpqd08zdklUaGY5aVpaM0UrWkVLTzJnR0pneEZEZzA5OVVCcm55dTFrZTB5aUx0Z01IdG9kdldXaVNCaGM0WmFyUTRvRFJJQ3RUQUlHbi94NTM3OGZUY2VQL3krSUd5YXhmRmo3T1JYOEFXc2RYdHNiSzFUeTJPOFVwdzcvUktIOXMveHpQTXYwblhMN0crT1k3UW1DSDNWVHRVRVN0RlFndEVCVmdTdklOQ2FNUEIwencwNTgzdHJxRHdrQ0EyNUw2alhGRm1SRThmQzluYWJmbWNidk1QNWtna3JMZHcwTTlPenRNYkc2UFpUMW9jZGJuaTB4VjN2bVNkcXhReHpJUzNBTzJFOEwxRGk2VGtoTWFMSDk0ODllT3RVN2REeCsvWTllZm1GemQ5Ni9rdVhua2tIUlplckFrVlh2YUVOb0hudjhjVUhiMXFhL2tXdDFNRzBzRGdSU2wyVzVxYUQ4MWpyWXcrTU5XcTNUN2JxUnh0eFBQdTd6NTM1WmVkM1IyMjlnRGdSMTgzeXQzNktsZWNZcFZRbEg5S0hvN2d4cjRQOXE5WXBqOW8rYTR0L3NlemNkZ1VFOWE3cEtYUC96TlF0SGZFWC9xZXpyMjllYXovUC95R0xjUG5TQ3VzYm05bzVGeWlsYWtEajUzL214Mi83aWM5KzhoY2JjYlJrVElqQzhPejVaMW5kN3RQcEZ4d1pPOHhzYzRiY1dkWlhyNkM4NDh2UGZvbjlOeGthelFnZktMeTJOR0pER0NpVWdtWnNNRVlqQ3FKUUV4cll2ampnK2M5ZDVNcnJPNGdPUUFlRWdhRW9QRmx1UVdtMnRyWVpKSDBHYVk0VHdZbW5YcXN6Tjc5QXJWWm51ek5rdWIvTjNSK2Q0UjBmM28rSkRGbm0wVm9SQnFDVXBzQ0FLT28xelhoZFV6TW9FK254c2RuNlRRZHVtbm5veUtuWnFYUmdON2RYK3VrZTVxNEpOSTdPVDl4MDY4RzV2ekJXajIvTGJJRVR6K3pFT0draGlBaEJHT0FFdkFnQ3hIRVVhOFdwT0FpRzY5M2hHVjh5WEhZUGRmeTJLTlNOVWtZcSt2OUV2VDV6VzFUNzlKbCtiNzhnTmxQcXFSWHZ6d0NGZ3ZUVGM3TW41dVB3aHQvYzJINXhMVTJ2T1Irdy84TUlzcnk2T3ByTENKUWlqcU13ZnYrNzMvR08yZm5GazNtL0ozbS9xNmFDR2FhRFExd1lQSWZOSEoxK0Z4TkVySzJ2a09VWmExbkMwR3pUR0YrZ1VKcEdQU1F5R3EwVTljQVFZUEhpMGVJeHBreDVPbTNIczUrN3dNV1h0akNoSnNvS1dnMUZiajNPT1pSU1JNNHpUQk9TdEtCd3BVdW4wWXFseFdtQ0lHS3JQZUJ5ZjRmYlA3N0lpWWZteUN3MEkwMWtOTG1BYzBJelVnd01kRlZBN2lGV3dyNHB6VlRoU1p4U25ZSzUrczFUUHpFMlY3OXQra0RyVjE3NDhxWG5CcDBzQVlMait5WVBuTnczK1dQT3VUdTdhVVpvREZyZzBrWWJsS0llQitUV2t4VVdwUlNDc05NYm9vWHhBek5qUDduVzdwMjd1Tlg5eWg2R2JCUUFKVGFHN0MwNG8zNjhIbk11eVViRlJUWG9wZ01QalRMQ3kvaVUwdmNxK0tKQXNoQkZaaW9NNzF0TnN0ZWUzMmxuMTJMRDhQc0JaSGVIeFo2ZVIwMkUyczAzbnBpLzdlVHhoN0plV3c4NmJieFhaR25CUGZ2djUvVGwxN21VckxIUzNTSE5VcnFkRHRZNmxqZldtVnFLMExXUVdtU0lROEFIV09mTG1rRTBDaUhRbXRSNmhybml3dWtkTHJ5eWdkS2FNQWdwckNPekZpOGE1enpHYUxMQ1VsaUhkYTVzTW9xZ1RFQm1QYjJreDZYTkhVNThhSkg5dDgzUkcycnlITElZR3BHZ2xLY1dhTFRTQk5vVEdraXRvanNVaHM0UUJacG02S2xIbmw0bWdkbFh2L2YrVHh3L2N2anV1U2RmL05MbDMydXUrUHB0QjJZL0E5eGt0QWtVaXQ0Z1pYbW5ReFNIekUrTTR6eDRQRW9wblBjVTFpSUNzUW00c3RGWjdQU1NuNndGd2V1cHRhL3RBWW5UNVRqaVd6S1V2SlprUkZxcG92SXFCblN1SVdqRVdSd0VESXFDVUt2Sk1kRmpYZSs3OTA2TUh6b3cxcHI1L1V2TG42c0lJSHN0QStSN0hENzI5RHlhd1BoT3A5TzhzSHhCTldzUlJaWlRESWZvSzV2TXZ2UUNuM3loejJ2ZEliRzd3TTZSRFpJOHA3QTU0WFNYK2NVeFRCRFRxSVB5RVlOTWNDN0FpU1lwQm9SYWs0dW4yeGZXQjU3bGw5dll6Rk9yaFlEQ09rZVM1UlRHRUppeWdNK3RKUzhzWGdUbkhkNTd4c1luQ1lLUWRpOUJqV2x1dS84QTlWQ2psU2NyUEdtaHlHUERaTE9zZ0tJZ0FKdlJpcUVSYXdTaDd6VjlDMVpyeGtOaDJqaHF1Y1BVMVd4NGJQeERzK25SKzNsK1NKN2FXUkZGa2hWb3BVa0t5NzZaU1pJaVk2dlhJdzRDQkxET29RUzBBb1VtbDRKZW1xbnB5ZFl0b1RFUG5GN1pYR1hQZkltSVNHeU0yTGRZQlBtWEQ5N04vL3phQlg1emMzdTMvZ0RNU3BvNlo5VGFaRDJXeEZvMDNEU3YxUEV1ck56VGF0M2FFYW12aXVzcE1ISU51dGtIYndMSGJuTkhLV0tSTXVjV29SNW8xV3FFbTlOUHZmRC9TUStOM3l4TFVWZTViQjEvZW9mNkZ4SnEyekRuaEV2TEwzQ3BOVTl4OGpoRHM4SGs4WnhFTjBtdElzcGpjSnJDT25JSHViVm9aWERXMHhsNk9oM0xUcWVndTlwSFNUbDVLT0xKMG9KR3ZRRW90TmJraFNQUTVkOHBGTjRMU2huQ3FFWS9TVW5TbkhncFlwZzVnc0F3MW1nUVI1QVZHVWt1NU42amxXT3lycWpIbWlpQUtHaWl0QkJsQ1VtaEtSeWtYbEFvNHNpeFlCeGJyNlFxK1c0eU8raGxlQy9VNHlxNkZSbGhZTWp6SE9jOGVWSFFHNlNNTjJLYWNVeXIzbUNZcEF5ekRLMDF0eC9aUjJqTXhHWjM4Tk03bmY3R3hqRDlBbGZuMmwxbXJZcURRREw3MWpKNDM3RldxVDBOVkFYQlZsNjRUZXN1eG1HQUJ5Smhka0hwaHk4cC85eSt1SFpxYlppdHZOcnBHYTdSVlE5N0FhTDNkSVJySXNSQTg0YkZZT2JQZktSK3h3MkhnM3RPSEF6dU9MVHYzSTMxN0l6U1ExQ0ZwcmdwSXJNeFYzNVRjV1lqWXpVZHN2RlBQOGZzWng1azVnSFF0UnB6MFRpVHpTWFNQR04xc000Zzh3Z2U1d1RySFAxaFFiZWYwK3ZrdE5lR2RGZTZlUEZsK3VTRlVvbGVGcjU1WHFDMWh0QmdmZm41SHFoRkVVNGdTMUp5NndqRGlHRm15WE5MVVhpbXhzYW9tNURFWmVSWmhoZklDa3N0MGt3MVEzTG5LSnduVWdaTUdXR3NBN3dtODBMNlNzcjYwd09HM1lKaGxoTWFRMXBZdE5IVWc0Z3N0emlCT0lvWXI5ZkpyUVV2YUtYWmJIZnBEaExHV3pXTU5pV1RGeGcxMWFnZlhSaHZQcjR4VEorcXdKRUtXT3U5YUszZlVtbFdwQldienVFcUR3RWduSTNDK2tkblpqNmM1Zmw5UnVuQ2lrUVdIOVMxdnZGUUhCK3FhWFZqTDgyZlM1MEw5MUM4MXl4QVJycVorazFIZ3JrSGJnMU8vdmg3Nm84ZVdJenVXSnhVdHpWaXBzV2hYR3BJczRnMERSbDBEY08rWmhocExoM00rTTY1RG1jSFE5d040enkwZnhOcHppRmFNVllmb3hGTzBCNHNneWhjNGNtOXcxbEhkNWpUN21ZTU9qbURYazUzdFVmYVRWQUMxbHJFR0JTUUprUGlXcDNBR0x6M1pIbEY2NHFVRVVRSHBWZ1JSWlpiQXFNcUFIbUNKQ05OODdJTDM2b1RteFplVzNLWHM5TjJlQ3Zvc0FTYU5ocWpGVm8wRFhFNERiMHJsczBuZTNSM01rcXhvOEtLVUJTbEVGVXBVTHFrckFPdHFVVUIvU1JqcXpja3RZNUdxQWlOQmxXbWk3VXdSTHdvb3pVVGpmaWVlcUJ2U0t6dmNGVzg1OTFieUFyb0Z3N3M1MVBmZkpaOER6aUE4SGlqTWJOb3pJZGYydGkrZTJBTHNlSkpCWXhTTXpOQnNDVFd6UTd6SXFrZXlpTkd6MTVyQUNuWkJnZ0U0b2Z2akdmL24zOXA0czhkT1J4OGRNckxqSEVxU29xQVhsdEpubWlTSkNBWmFBWUR6VEJSSkVOWWExdWU3eVo4T1JsUU96bkpSLzc4YlN3ZG1jVTV3MlN0UmFBaU5ydVhHYVJEc3FLc0Z5Zzh3NlNnMXkvbzcyUU0yaW1EVGtiblNvZGttRk9QUTZ5MUtCUkdRWmFtMU9xTk1xKzNEcTBWS0UxUk9KUldvQXpPbGZWSUlZNWFLd1FCNnlETmhWQUVXL1RwOUJNYWpYR2FqUnJOUm8yRzlpVFprRFFyQ0NOTnF4NGhUb0Z6b0F4K1lHbC9zOHZxcFI2NXN5aXR5cmxlVWNSUmlOWUtvOEVXdnR4ZjRDenI3WlE4TDJoRUFVb0prNjA2NG9USWxORkR2S0NOUXNjaDQ4M2FnYmw2L05qRlh2TGluaTY3Y3Q0ejE0alp1TVlsOGJkTmp2TmFrakFmaGVwU21pblpNLzl4YTZ0MTQvb2dPZGpQTWdwRTVTSW9wUWlVaWh0YVQwOFlNM2VxMmJ4M0pnak9iRm03MStIK21obWVDbmJUSzBXQUVIem0vUlAzekt2eHoyeDhWMC9ZTWN0a00yZW5IOUh1QlNvYndpRFJaQmtNQm1YZHNMbFQ4T0p5bCs5ZTdLQ09qZlA0ejkzRzdNRnBRaFV5VVE4eFloZ21PY084SU04c2FaYVRXMGVXVzVMRU10aEo2VzRNNkcwTjJkbm9NVmp1NHEybk1MWk1wUUJSb0pSZ2JVRVl4aFhWYTlBbXhJbWd2VUxyRUVGUk9FZGhIYldXd1h0SG1sZDFpbFo0SnhUV3NUUGNRUnZOOU1RWVIrWVdDUkZRanJveFlITzJreHlOSWc0MHllbVUvcVVVSjJDOXB4NkdoSkVoQ2d5MU9DenBYYVh3enBIblpVcElYU2k4a0JlV3pqQkZLVVdqSHFOUVJFRlFwcFZaUVZwWWhua1J4S0Y1TURicTF6SW52UkZBQXEydXFZN3kvOTQ1MUtqejFGYWI3VHpmR3oxcURhT2JZMHJkdmVIc3JQV2VBc0VEU1ptN2owZEt6VVNLMnEyMStHZmVOelgxeWovZjJQaFM5Ym41dFpScTdVMnhEQkRFUlhoMGF5V3FweWtNZGd6WmdzSjV6ZnFhcGo4VXVnTlBaK2pvOVN4cDZ1Z01jN29wdlBPREg2SjF0MmQ4ZjFsdUJhSEhBRW1XazlxTXZQQWthVTZSZTlMY3NyMHpwTHVUMFY0ZnNIV2x3L1pxaCs1T0gybGJpa0pRMmhHR1VCUVcwYVZtTU04eXdqREdlNCsxa0dVRnpucUNPTUI2d1JoZGFqY1VSTFdRd2p1czgrUlc0YlRDQ3hTRkJ3WGVDeHZiSFliOWhNbkFVSitjSXRSMWhvVkZ4S0JEemJCVHNQNVNuODR3eDN0UEk0NllucWhUajBNVVpUazZHS1owaHpsWllkbnBEQ2lzSzV1ZWdMTU90S1paajZsSE5icURsTFhPSnQxQlJpL0p5S3pEbGJLTVJhUDBBcmp6akF3dVFCVnk3UVBrMzY1dW9FRDVxOE5Sc1VEOCtOemNNWXJpd2Uwa1VVNlZjZ0ZWaFlpaHMyb2VtajUzUm9WNjh0SDVtVWQvZFhQelNWZU9PZ2RjSGFLU2F3VWd1MVR2MXBicnEzMTRvd0duMkZ5TzBKSFE3ampPckJRTUUwY0F1RUpJYzh2S3hvQUhQL2dKL3N4Zi9JdWM2N3pDTjEvL05XSlR2dkdKV01SQlduaUdXVUUvdGZTU2dsNDNaV2R0UUhzcllmMzFMWFpXeXh1MXlDdytVemd2MUNpYmlWbHVzYXFjRzBtU0FXRmNwN0JsZERGQmdCZXdIb0xBNEx6SGFJMVNHbXRMRWtCclFaUW50MVdvMUtZcy9MMG5TeHpLZ3RRQzF0ZlgwVnJUYUVUVTZ4SGFHSHBuZTJ4ZTdLTzFwdFdJcUVlR0xDM1k3UFRaNnZiSnRhY3dqcUgxcEZiSUMwK1dPdEorVHQ0dlVDS2dOYTA0SURUckRMS2N6RmEwNzE3Rm0ySmNVRXRjbGM4cmtmS211aGJQVWkxbU9TMVR2OXg3cFVwQTcycjF4b09nZVhNY3YrLzg5dmFOaWJWbHZWYmxUYWI4SEsrMFJvTUJNUXRoZVB1cGlmRzVGOXFkUGxkbmF0eTFGRUVZNVgwN0hiOHBYbklqMUFTRjlqQm9LOW9keTA0N3AyWVVLTVV3TGJpeU0yUkRqM0huZzQ4aTFuRnk2amE2ZzJWZTJYZ0NyeTNlZ1JlTGRjSXdjL1NTZ28ydGhONVd3dmJsTGh1WHR0bGFhMk56aTdqeWhrNEx3WGpJTW9lSTREd29MVGpyU0NXRlhwOGdDTkFpR0JPQTB1V05XUlJsczFCUk5oQnpTODJVTllnMmdsTUs3eWtEdlFLeFVoYnkxdEVkQ29XVVRUM3JIR2xoaWJzQkd5OXVrMlNXUnF6WjZmUTVQUnd3dm1TNCtaRVpibDFZSXB5c01UWVZrK2RDbXNFd0ZkcWRnclhMQTFiT2RibjQ4aGFieTMwNnlWV05sZDV6QjFUcVBQRkNRNUNaUFd5aUVoR3N2ZmFZenh2cWRjNG1DUTFqU0oxVFVzNHM3NEpEb0g2cVhqKzAyUis4NDhwZ0dBaFhCMnM4MEZMZ1JRMVdiYkUrRUo4V1JVRXREZzdjT3phMjc0VjI1eEp2M0JGL1RVU1FVakFuWlNmMzZiUEphKzgrNVY3Yk54SGNsWXRJYnBSS25KQmtRaUFpU2VaVUw3SDVsVjY2dGpGV241aG83UnR2MU9za2FZRUpZbzQyN21RMXVNaEdkcTY2SVJWNUx2U1RncDJkbEswclhTNmYzbUI3ZVp0aEx5azc0NlhKRytJRWZKbUVpZ1dscXB2V0M0WDJLQytvTE1XRUxYSnJhZFpyTkpwTnV2MEU3MHNaU3FBMUlOUWlUYVFWZ1M3ckZ3a1Uxb1B6SG1WS3hzbXFFUnRsR2VZT0U1aXkyeTNRM3hpeWViRk5ubG5PcjNScExNTGpQM3FBZXg2ZVoyRzJSaWRYZEJPUGNvWWtLM0FXa2t5WW1ZODVjR1NNOW0xenJOeS94TmxuMW5uNUc1Y1piQS9SdkhFa3NRS0lrbElJbWZER2FVUktxZGExZGY3YWdRUDgxUXV2MDdkT3lac2lCOUM2cWRXYXU3dlorTVRMMnpzbnJKVFUvT2d1RHhVU0tVMVA4Y3BtVVp6ZmRyYlhVSW9sejlTaHVIWU0rSFoxVCtwcnBRNEo5b2pESEZCOCthWGVsY2R2bWZqY3pDMWpKMEpEeXlyWTdCU3NicWEwKzVsZjYyV25MN2J6YjV6dTJPODJ4L1FQblZvczNtK2Q0TDFpME9zUXFZQWJKdTVqZlhtWlFncGNZVWhUejlabXd2bVgxcm40OGlvNzZ4MTgxU25XU2lIZWwycGNYODU1Mk9xU0poWUNKUmdGUGhYaVNIQkZqck1PcGNCNXdaZ1FUWW92Yy9sU2k2N1Z5TDhVTklRYVJBa2FBYU94WGhBdEdGMStEYTBnMUtxVXZ5Z0ZtU1c3M0dWenMwdmJKOXo5MkRTZi9QRkRIRHJjd0ZuSUM2RS85QlM1VUZpUHN4N3hFQmlvaTBJaitER0ZVblhHbWdkb1RrUTg4N3V2MGQ5TWR2YzdxNnNYWGlxRDdmSWk3cEg3WEN1dTcxS3hUd0IvN3JYWEFGRzVMMnNPSUZKbDVKaVlpK09KRDg5Ty8vQnJPKzFQZGZNOHJ1OEpBYnBTQTFrbC9aNVN6eVFpYllGOFFnZlVvTDVRajIrTmpmbjF6TGxyQmh4dmlDRFYrNVlCd2E5OGRldmZJRFR1T3RyODQ3MkJuZnZDTSt1eTJjMlhPNFg2dmROYjJWZldCckxlck1mMVdkWDB4cGYwYXBIbllCUkJGSE5vNmlTbk4yL2lsYTFuRWV2WldPM3owdE1YdWZqU0tsbGFGcnhLVmVvODcvRWllQ2Q0VVRpNStnMGwxU09xQnRSTStlL3pMRWNIS1hHOVpMTWNHcUVVQTQ0Njc4NEovVUZCbHBSUUU5Rzd6eVNSRW9pak4xMEVjdWNwdk9CRXdDbVVWYlN2ZEJoRUdaLzltWk84ODEzelRJMlZRQllGaFN1SDBMMlVBQkduTU1hZ2NkU0NjaTU3M0F0amRhRmRBMzNISEdrNzVaa3ZuTWRtYm5mV3RFS0NVaFh6OHlZdDNEVnhtc2JBLytQUDg5bkZXZlhiRzIyNjFvNGl4Mmp5c2lIUUhBK0NpVS9Oem43Z2NyZi94OC8xK3VOQkZSS0Rxb2RnQkN6WW52Q1ZGZVFwN1NWRDZmWmtHQ0xXVWZnaUNJelcxNXBJODgwUkpBZk1TeXZKNnQvOHRTdS9mTStoK2pmSjNEM2RZVmIwSE04dUQ3aFF2YmZ4eEhodDdJWmo4NlpJQS9JMHhka0M3elE2aUVEQmdmZ0VUKzA4eDRWenk1eDk1aEtieXp2VlU3NThJdWtxeGZRaXUzSndyd1JiRGRHNHE5L1g3a1YyZ3JLRkorOFBHZGRWZDlNWWFyVzRqRVRWVGVzUlVnZnRua09MRU5VTTJpaEVsN2VqOTc2cUFEVktTb3BGS1FoVnlZTDUxQkhVNEROLzlpVHZlTThTSVpZaTh5aGRLb1lEQWNrY3pwWVZkaENBTm82UTBvVWxERFdpaEhvZ3hMRWlyaHRNZUpCQlArUEZyMTFCeWtHczNTVGJnemZxVFVXcFVvU1JJY3YrYVBwbU40K1BjMlU0d0tPSS85Yi9nQUpsUlpUZk00T3ZvQ25Rdkc5eVl0OTlqZWJIei9kNm43blk3OCtKOTFldExrZnZvMElWd2pjdWl2eHlUMWl2SzYrOXNJVldhQlNEM0c0TUMxdW9xOXpFTlRkUk9Jb2lLZUM5aUgzcXd2Qko0Q20rMTNnNDJtNFA4akRXejhZbWZteGpiVE5jWE54SHJkRWtUVlB5TktYaEl2eTVpQ2QvNjJXS1lZcW9jbmpNZVVHOElGcWhrSEphcUFLQXJxcFhlZU90NGpOUWtVZkhEcHdIOFE1ckhZVXU4TnFqamFhd2R2ZU84OTVScEo1QjdwSENvNGVPTU5Ub1FKZGQ3MERqVUhnOE9HSFF5NUJhUUtnMXhoakVleDc4MEQ3dWVYQUdtd3NPd1NpaEZpbHdaY1NLbzVpK2MxaWZJQ2hha2NhSTRKM0R1bEoyVndOOENMb1pvZzhaSHZya2NZWUR5N2xuVnhsNTR1eGVWTm05S2FScS9hQXhmeVNONVR1bkpsbUthcXlsUS9yV0t5Y3lvbkgzMWhzTnBWVGovYlBUTjh4SDRaODYzZW0rLytKZ1VCZVIzWnZLVnpkVElLZ0NYbHVILzdrTDV3QlM3N2trOXZsYlEvTkR6b3EwclgycFdvQzBkNkhwTlJWQjRPcnM5UWdzdXd0cXJ0YVVhS0NXWnRaZjNteC82K0JFOVByNjZzYUpORTB4UVlBdGNybzdPM3ozTzgvVFByMU9rQm1HbzBKY2xlQ2dpaUlpQ2cvbEV4ZTZvbG1MYWx4SkNuZXcrbitlVWJCaW9UbjBIRUk0ckJUVDRuMmNKZ1ZoR0lnU1VWcHJiSkh2QXEzSUhWdXJmY2IyTlJFdkdJRWdLK2xWRTJoOG9NdGFCUEFlaGdPTHBJNWFQY1FFd3NKTXlNMTNOQkh2c2JZU3BvYVFXWS8zamw0bWVFTEVseFN6MDVBNlQwMEhaR0lSNnhDcmlaUW1VNDVJSzVxaFozWXU0b0dQM1VBNnRGeDVlV01YSUlvM1BIRGxLdjFiUHBmaTJHQ3R4Ky9oZlpWV2pFOUd0TGYrWUR2dEQ4L01vYlRuOUtEUDBJa3F2RmRTWmtnamc0b0cwRGhRcTAwK09ENzJHTTU5K3ZtTjdYdDZlUjZFZStpbmpGMHEyNmJ3N1MzNC8yN0MwMVdXZ29pb3A0ZURiMzlvZktMZEY5bjVlcmY3Q205MHVlUmFpeUJ2Qm9uZFF6dnVmYnFaMGEvZlBuM3B0WVc3SjUvc3RuZU9KY05FSzVUcWRqcTgrTngzZWVxYlQ1SVhCYWNXRG5CbWE1V2RZVSs4dHg2RlZ3cmxCQ3RlTnBUV2w1M1hWN3hUVDZjRGQ3YklaUk5vVlJkcFI4cUhVSlJCcXhBT0JIQjdJRHhBVnR4WXQvR3NEaFU2Q0RFRVpYMWl5aWcxN0Jja2c2TFVYUnRGZ1NKUW9EeTQzQ01WcFdTcmlUODdzQ2hSNkZBNHZGUmp2S25KOC9LU0ZMNU1BNG5LNGgvcnlhU1BWeHJSa0tXZVpDZzBhd3FscFV3akhReTlMNThvcWdSdk00QzUrWmk3M24rTXRKdXhmYVU3NG5SekJUMit4d1pIQ0VOREVJUTRsNzhoNjFDVUV2b3cxcnQvN0wzZzdOVi9VMjhFQktGQ0cwVm4rLzk4blBkVW8wRXpOSnp2SjZ5bXFVcWRHOVVhb3hxcEVXamQvT0RjN0EwSHRmNzR4Vjd2azY4bnlWVHF2QXIzZkY5N1ZJZjlCSDV6SGY1Ly9USnlaSHZhSVVGTktaczZzUzhQQnQ5K3N0Tlo1bzBHR2Rla2FjTmVrTHg1ZzZ6c2lTUWF5Sk8wNkwxeWFlVmZIVHh3NU9HZHJaMmplWmJ6M0xlZjVibG5uaVhQYzZJNHBCWFUzR0cxOEVLeHBsL2Q2R3hmVmtnbUNzUXo5SjdYOEdyRk85KzN1UnV0UzVhcWs3clhYa2NCV3g0dTU4S3pPZnhtN3VTRUdxVHZhOFhtMGFiSWZCUkdSaHN2WHF4U0lyak1Zak5iTmc2OUppOFRLaFFPSzRJb2hVOHQxbmwwdmJRUlNwT2NpVERpMlA0UUw1RGJjdEpSdktJUWhUSWxJMmFDc2ora0FrRVZpbEJBcEtTampWSW9RaHhDNW9UY0ttemhpUUpGcERWamRWalkzK1RHQncveW5YOTdsclNiQ1VxMXZlSlNkWVVkVlMzVnozSUZnbk5PZWM4YlhCdWRFOXJiT1dVY1ZrSkZVaHc4MnBTeHlRaGJDSEhkU0djckpRZ1ZuWjJjS05MYy9kZ0J0RkY4L2JjdXZPR05mOC8wTk9OYTg5S2d5K1VrMDFuWjR3ajJwRlROaGpHdGp5L01QVEFGUC9meWR2dld6VFNOYzVDUkdkaWVlZG5Nd2tzOStOd0dmQ0dERGE3Nmk1WFBMSzMxWWhUUC9mN09kdnJObloxdkZDSUR2dGRlNlpvRHlQY0R5KzQzZW5pbXFhN3NKR0s5SHpGZTZVdVhWcjU3WlBIS1B6bCtjZmtYZDdZMlc2Kys5QklvajY0RnN1NEhhaVZ0djdpeDNQK3ZPNXZwK1RSbnlOVUZsOVdGY0g3UDc5MmVWTzdObmttN3N5cEEzNG9zYncvelo3dUorbHdydHUrZmJMcUhBOFVSNTRyUUlPVERuQ0xKVVhINWJETUtzZGFqcEt5R3JDOWIxZDQ2N0tDY2FQSWV4aGNpbXMyZ2pCZ0tobGxab0lkaHdFUmdFRmRLNkkzUk5FT05XUEJHbzlBNEwxZ1BtZGRrMXBjT0xSNkNVRWlMVXNucVBkUnFtc1ZERTJ5ZG5PZTFaNjhvdkt4N1llTk5QN3NxMTg2OVlWV0VlbU9mUkFRRlVua0xpd2hYTGd5OXVqZ3MwMlNGYUsybytBdEJLUnJqcFlpek5SbFRwSTRzdFh6em5RL3pYNzE4bHFlNkhiVlRGQ292MDZxZ0tzUWJBczFIcHFjWDd4dHZmZnhzcC92WjU3cTlBODY1VWNtblNnWVhaV0RvNGJ0RCtQMU4rT0lRTHUwQmhxOEVzZEY0RUVRL3NyUjBxOHJTdi9UdDdYYi8xYUo0bHF2K1k5ZVV5L3UvazNuMXNmMnowczdXNmZTVEVlTTFCUFEzWDNycFh6YnI4YUwyeVNkMzBtNTlKeCtHbTJuUEQyeitTcDdKLzlCZVNiK0x5TjRGTkk0M0dyTHRCY2IzYzl0VDN3Y2tFWkJha1hZN0xWNGNaUFkzSTYwZURJMDhJSjZiazYyMGRlSDU5ZjdrWEtQZEhJOW5hN1d3cnJReUNpa0xGY29XdG9qZ0M0dnpuanozQk5SeFVrYUZLS1FVS1JZUUJDRkpyaW55aE1BS2NRTkNvd2lxNTJibUJGZWxZb0Z5NkZDaDhTZ0hRYUJRS1BxSngzcU5HSWliQWZOSEpsaS90RTFuZlhnR3hVNmw1OXRyaFJPSWxDL2V1RnRGVmUySjhyKzlONWVTa3NpcmZ1OWRDUjZ0bE5qYysyLyt6a1dwTlVKRVJCNUs5N0Z4ZDhHRFgvazZ0NCtQMGJhVzVDbzRhaFdGMjNob2Nuei9IWTNhejcvUTduejhZcmRYWjA4NEM2NUdqTzhXOEpVdCtOMGVyRmIxZWJFblZROEZvb08xV3V1VE03TWZYT3NQL3ZoR3YzYzg4ZjUvM1ZLc2xnN0czK05COXRZQ3lDMEh4dm5XNlJVeFJvdHp1MUZFYi9kN2E3L3p6U2YvKzlucDVtL3ZGTU9scEVpUG1sRHQrRUovTmUyNGl5RHBteTZZcjZnL3YrY04vcDVOUTIvU0dvemVrNUVkYUZaOXpRaElDNUZ1NGVTN09INWR3eUZCanF4ZkdxenRyQTEzNnMxd1g2MmhiNm8xd2h2amVuQXNDdlVVV2swcHBZeW9pdVAySWxsYXFJQUp2TUFnOTlSRFRTMVE1S0Vpc3huS3FkSnZxMkhLRkNyTjBWNlRGSXBDUEhFc1ROUVZ0VkNSV2M4d28venhSTEFPYkZPejFmZHNlMEhIaXZwWXlMN2owOG13bDcrV0Rndjdwb2ZBeVBnNUh0VUFCNDYwV3RPenRUaEpuS3d0RDdMdVRwN3VlYWc0cXRYWGdGZHFWK0ZoUmJBamhpZ1pXSmNNckZmQU4rcXIzRnlibDMxUmpiT0RvVXF1MWh4eFZZdzNmMlRmd29sOWdmbkpKN2ZiSDE4WkRtdHgxVTRLUytLdG44T0xRL2lkTG54MUFHdDczdWZSamI3cnovdXhtZGxiRm9QdzQyYzZuUStzREFmVFU2anRWT3V2NVNMdVRROU8zcElBK2R6VFZ6aXlPTVhhZGw5MnVrUHZTL1VsZ090bWFkRmRTVGRIckZmWml2TnZYcEZzS1lrclVRcFJTaUdsUHhSS0s2bFBCd3cyaXUvSjhmYjhkbThOT0xxb285MkJvNmd5OEhBWitBWVFGTG1ZSXM5ZjZlN3dCS1ROSUdDK1Z0Zjc0NXErTllqMFFXM1VZVkV5SjhpNEszeGRyRldGRisyc0VCdGZEbmg1aHhkTlpBSkVLVklyR0sxUXhxQ1V3bHRMR0VLcnBtaldoR1pZcGxpWmcwNWF6ck5FQVVRYXBzZWdGVU1rbW1RN1l1SEFwTXRUbTUvOTlzcmUzU3FqYUZHYm5JckcvOFRQM3ZqZ3dlUGo5NW5RTEVXQm1zNnN6NVBVYmJTM2s5VXM4OE1rc2Yxa1VMU3ZuT3V2dnZaS1o3UGJManFkblh6QVZSK3YzVTFaNGlXbjVDYWN0ZDVmUHRkaDRJcVJybXF2ZTJianNhbXBJNHZHL0lWdjczVGVzekljQm8yckdyS2lnTmNIOEt0YjhLVzBCRWIySm1DTXpQV2lrNDNHMUFPTjFpUGV1NTk4cGIxejAzcWVxUW1CUXF0bkwzbjd3aDdXOUpvcTBQK2RBWEpwZlp2YmppL3VHamlWdmJzMzBNSzc1czN5eGg5NnQrWlFDakVSWW93bU1BRi84Ny83TkgvalQvMWpCRWc3LzZlY3Y3eUpVZlBmQnlqbSsrVHNvOS8zckdXOTMvT3Y5SHYrSzBBOUNKazFBZlBHc045N2xyWTJpeHZUMUwvYktCOFd0a3lOSWxOU3ZJV3pwWVZlWmNDZ0svTUk2NFVJUlQ4VElsTXlFSUtuR1lFVHhUQ0hZYUZRcW14UU9xT1luTktjdUtsR29LVTVISXpkOUpwYS9UMFIyVHNMRWQ3ejBPelN4ejU3N0lmM0hSMzdwREptWDZRRHdOTEVJOERDVW93dkkwUHV2TStNOTMzeHZ0UHJGYSt2WEJxK2R2bEM4dHJsQzRQenI1L3ByUzVmSEhhNHVvUTBBM0pYZUx1NU5uU3FERHQ2RDF0Vi84alN2a09QakkvL2hYLzUrc1YzYjZTcEdTK2ZQbExBeGhBK3QxT21VdWVrVExPTFBjVEs2T3VFKzhLb2RlOVk2OVNTQ1g3azNIRDR5SlZrT0tPOGx6cGdsTnJzd0c5dWV0bm1HaHlVNGo5RTFqQTkzZ0N2OENLcW02Ukt4S3V5WEVTL1NZbnBxUnJjVmFHSU1sVVR6R2lNTGxzczZiRDRnL2daM3Z6LzE5K25maGtCSlhqVHh5Tit2MzdmZXc0OC9QR2ZQUEdmVFUzcThmRmFxZXRTb2tnS3dTcFZja2FxWE5IZ1BmUXppN1lPWlhRMWthZ1lxMEV6TE8yRUNnZTlITllISlZDMENHS2g4T0N0cDkvenZQWksvL2t2L2VyWnY3dCtvWE1SS0pSUzhva2ZPM3pyZXo5ODRHZHFZL0U5dVpmQTJsSlFFNGU2bE11bzBtcFZsZXBZRkVJVVFCd0lvUllSd1ZrdldiZGoxN1kyODlQbnp5ZmYrdjNQWC9uUzY2KzBseXVnRFBZODlhbXVSUTFvSFcyMVpuNWtZZjVuWDl6YSt1a3o3VTVVSzBPQnMvQ3RUZmhueS9BdFgzNSsvaWJHTVFDQzhTQm9QRG81ZWZSd0VIeHNaWmk4NStKd3NOUnpUc2VsZjYwMElNMjArVjllRWZtZmh1STNnZjZlMU95YVNySCt2Zll6SkZuQk8yNjVFWTJoM1IrSTlSN1VtNTdxWmI5alZHTklFRUljZzgwcFpmQldzSVhIRnY0UEJPWHFqVkhGZng4U1lHOGsyN3VZTTkvejlOSnhMZENIYnBwK2RIdzhtS29GWmEvQkdGWFJ2dVZyTEpyR0FaMWhScHE0a3RvTk5HRlEycG5tYmpSN1VoWUZoUlcwVWlSV2tlWGx6dzVDUFN3TC9lWllPTldZckRVdXZ0WTVyNzFFZi9JL09mbXVkM3h3NldlYkUvRnRSbWtUYWdpMW94NlUrMU1pVStwc1BKckNLVEtyc05VMmJlWExmb2g0TktJaVk4eVVxWWMzTkNmcjl5OGNuRGphYlJlWHRsYUgzVGM5UUhRbE9td0VXamQrN01EKzkxM3BkSC8rekU1N0xBYXBnMDNnZHk3Qi83Z096OHRWRzFhL0oySkUwM0hjZXZmTTlNMlBUMDU5c3NqelAzbXUzMy8zNVdRNG1UdUhCbFU5aWJJQzlhc1hGTC9jRmI5VkVUM1p0ZFlnL0E4Q0NNRGgrZG5LbUtDUEV3ODFVT1dEVFl6Um9vMFNwVlhaT2E5dUZxVktSdWdQS1F5S01raWdFRFNpZE5uNjJBTWV1eWM5R3dGSUpZTWlPM2h5K3Rqa1hQMldLUEJsdFd3VWFRNzl6Q05vakFwTDF4SVI4clJVSnpYcWlrWkY2YVM1N0xyUWw2c1lTaTh2NTZFM0ZES2hrdHFVd0l1TU1yV3g2TWg4dlQ3ejJNTXpoeC84OE5LUEU0UUgwMEtVMFpYZVM1ZHFZVzBNY1dBSXF5VkQ0c3YraTBKR0JxWW9RWGxSU3B6Q09YQldVVmdWcWlnNE5uZDQ0czZwZlUyNWZLWjkwWmZyNGtaUk5BWWFqODNOSEF5dC9jVlh0clp2REx3bmhNMHUvTXA1K01kOVdGWGcxTlZocGdDSWJ4cHJUWDlnZnU2ZU84ZGFQNnFkKzlrWHRyYmZlWGs0M0Rjc0NxMUYwS1c1TXdyV1UvaVZDNmovcFMyeVhFV3h2VVU5Ynh1QW5GL2JZS1BiTGNGUlZRVks5aFFKY2xVU0lSWC83LzR3WlVWVmtpZlY2OGpOc0xOZWZtdkc3TkU4cWQyb0E2Q2Q5V3BzcHE2bkY1c1BtVkRYbzJyMVcrWkFTWUJ6aW02YVlCUm9yeG1tQlkyYVlyWmxhTVlscFZ1dkthTEFFQmlEVWhBSGhrQXJRaVVZVTZacHptc3lweWk4d25qUDRybkMzTEpRUDdMMDhPUXRSYUJhUmlESklYY0twVFZPTlBsSW9WWFIxSUZTYUdYUXloTWdhRHhhbFUxTHFYamdVZmFqcW1abUVBY3pFN1AxdTZmM05XVm5mYmc4N0JWdTFBeHNCbWJzTTNNTG4zMXhaK2NqV1pZRkVRemE4STlmZzM5ZGxEZXpCeVJVU3UyTG92RTdXNjJqajg5TXYzTmZFUHpZSU05LzlMVjI1Nkh6M2U1NFpxM1JWYzVkdlRJSHovZmcvMzBlZmpXRlVlUkk5eEFKMStRaW5UKzRGVmp5cG8vMzNKelh3bWx2dkVFb3UzdTBZZVFadlV1eEp2MmltRDg4Y1h2WUNBK0ZrY0pvamZPS3drS0JJZ3dDbW5HTkpIRjQ3NWlkMERUaWNyeTNIa0lqVmdTNnJGVnlwd2hVVlBaSWZHbXhHcHBTT2F6UWVBLzd2NTB4ZzVBL1hOZXVwb3dTUmFnZ0Y0MUhrenJCaXNLanlWM3BnQytpUzZCSnlaUm9WVVlSSjJVS1czbys2RjFuRjFkVjRaVmdMUjZicnQrK2NHQnNibk41Y0g3UXpWRlErL0VEQisvUVJmR3paM2ZhMHhFTStrcjl4bW40TFErWlJzbmhlajIrWjJweS83Mk41bnVPaDlHUGlIT2Z2VERvZitEeU1MbGx1VDhZeTZ4VllYVVJwY3k3eEVDN0QvOWlEZjVmYS9CdEtTVTFmVW8xZkw1SFBYRk5EaGdIL0FDZTBSeFNHRU9SZ1ZKSzVDb1huMit0RERZdW5lbCtZV0s2ZGtjOWlscDR3U0lVVXFxQW94QVNWNUNMdzFRanlFbmhhU3FvaFpyUTZNb0N5SkZaVFh1WTQ4Vmp0TUk1SWFEc3dNZFNaLzY3WGNhdjVHeCtvb1VLZGVuV29EV1pFNVFHN3hSNVZhQ0hwcXlIQnRVZ1dVQkpBZ1JLbFhRMFpiU3hYaWdzaUpOeXVMMUtRcFVxTjIvNUFNVFQySGRvN0tPUGZ2UjQ0eXVmTy9zcmJqMXZqeXYxZ1pmYjdmM2V1N3lqMUc5ZVVmcTNqOFZoNjJpdGRuUmM2NE1DTjFueEo2NGs2ZUpxa2taZVJPbnE2YUwzQUtPQ1pzL0MxN2JoYzJ2d2xJVjJCWXBrUkE0bzhLYVVyVjJ6dnZhR0grRGpxNngzWXE2aGl0U3loNGtMdXB0cGUrSGd4TzIxWm5SQXFxZTBLd1N2TkVvclFoMmlmWUN0MWtESHNhWVJhc0xBRU9xQVFKZXVpbm1oR1dhV3RCQ3lUR2gzWUdOVDJHZ0xVeThtSFB0S2g0MTMxMUhIYThURzRFUXp6SVhDVXhYZzVWeStVQm8rR2wyNkdJYlZLTEd2Tm9qNm9pUUNSTUE2UmU3S3lJRUlxYTJpU05XR0d4bGRXQ2U2TlJZZmJrNDM1bHBiTGgwYnVNZlA5Ym96eHBoWEo1cXRaMC9WNi9mT2FmT2h2cldQYitiNVk4dko4TVRsL25DeVd4VEdsSXlVcXFoQlVWZnJqRUVPVHcvaEgxK0JmN1FGTDNqbzdva2F1K0JRSUhXVXZJZUlzOWRtQ2ZLRERaQmQybnF4UlZMNjdlN1N3VmxTMk9aNEhJMVAxKzgzUm9WbFRhM0ovV2lrVjZPdFFyekZCRERaMU5RampVanBHbDlPKzRZb0lqb0R4MDViMkZpSG5iYlE2enVXWGsxNDhPdERpZ2xOKy9FVzlWWkFhZzJEVENFU0lDcGdXRGpTb3RSeEtBRkZ1UTQ3cU16cnRDcm43aU5ENWRwWWpnT0xLQXk2blBUMGlxeUFyQ2pKZzl5QzNRTVk4YUtiRTlHQjhmSGF5ZlQxN3VLWU1tWnVyQ1ZKVWR5MW5DUjNYYzdTcFU2ZXQ0YldhdWNGQXo0b0kyMUFSVjhGWmVHK2J1RTdmZmhIcS9ETG0vQmtVZFlhZ3ozRmVBNVlEYjZKWWdFdENiQ0s1MXJkemhoY2gwY1pTU3FadUsvU3JCU0lUeis3OXFXcCtjWjdVUlB2TElxQXFDYW9VSk5yalhjWktuR1lDT3BSR1ZXc294b2Q5Z1JhSStJb0NrOCtyTE95M2lmUEhJME03bjhsNDRaWEVwcVpKcDB0bSthNXJaSGw1VDZSTUNodmJpV2FXQ3RpSlFTcXREZ3RuT0I4V1l4clhmNjVGbzExdmh3OVZwWDhVeWlOd1FVUVQyRTlhVDZheHltRlQxb3BBcU5SNG8wNjBqaFFQRGpEOHBjdXNiVzV0WkNYZWlzSnlqcEN5ZFVtMCtzcC9KYUN4UmlPZStnVzhFSWJudW5DcThsVjVlNm9LYm03SlhnVU5XS1FDT0U0aG90YzJ3YmQxeU1JVUF3OVFheEtEeDdaczlzaXRUWUlUUkkzb2p0RjZYRVJRVldtY01wNVhPSFFrV0o2WE5PcWRpUjZFWXdxaTIvcmhEU051TFR1c2M0VGFzMjlUdys1NmJ0RGdseHdTb2lEa001aVFIY3lKTTA4MXBjc2w0Z2lVb1pRbFZJVlZXVi91WlZ5WWhGSUNrVmFRSkpYZnlZbFp6UVNUZUxMNzZsd1lBdU5kd3JyQkdkQmZQbHZkVlUwS0FFMUdUTVFvWDI1VythVUlCNFNWZG9EckNzNG5jQ3ZYSUxmNk1MWEhYeWxEWjlmaHQ4ZndGa0xPMVVhTmRpYlRvM0FNVkdsWTZPaG9sZTQ5djJIcndNRWNNNnhjR1FDWjcyeTJSdmVOTDI5TmxqWFJoZHhJN3pEYUJNcnJaU3VHblVheFhqVE1EOFZVRE1sY3pWaXI3d0hyV0xhM1pCdTMyR0JVMmRUYm4ybUQ5WlhYVXpCWUloWEhiMDVoWnVNaUZSUVdoTlJScU1Sc0l6V3BheWxXanprZlVVRDI5THdRbnhwZHlxK3FqV2tHaytXc2hkU0ZGS21YSVhINWxKV3hoVjVweWh0bHJ5RnhuU2ROUGZEcmJYK00wNzQxaEIrSTRIUEQrQlhPL0RyTy9CZEtldUpYZ3ByZVFtS0VXVTczQU1NcThDWlBSVHVma3JSMW1pdSs2MXdyZ09rT21QVGRicWJDZkpHcXgwRjBOa2NYZ3BDSFVXMThFWVQ2TmpvY3RGb3BEVVRZNGJaQ1ZOMXhTdmJJVk9xV0hJYjBlNHFVcStZM3l5NDU0azJSVGZIcTBvdDZEeEpWbUI2amxZVzBwOE5zQTFEVkRsR3hrRUxOWW9JbnRJOFd3bUJyaUtCSzczRWpBb0lWRUJoeS8yaXZtb1lsbWxXYVV4UkFrdHdSV25iR09TcTJwOVkwa2hLUmdXK0lKRVo3cVQyZjd1OGxmeEdBaStrOEVvR2x3cllyc0F4QXNRYnRGMjhhZFpIZ2RSQUpyanFjSEtZTWdmak9rRGVXcWUzbldJQ2piTlhQYUJHM0x6MzRuZldobWZFdVdGWUMwNEdvV2tZWTJoRWhxbXBrSW1HTGpWUW9hcDBVWWJDYWZyRGdHRnVDRXpDemQvdE1uVXVKM09PYnA2emNtaUorZnZ2SWx0ZXhlY0ZNNnBKdUFQNXlRbnFZek5ZQzRNc0pTMEtySE1VenBhcG13VGt1UzFkWWFTU2xVZ1phYXlWMHFPcm9ySlZ0WTRCTkw3cXczZ1BSbXVzbE1WNk9UUUdtb0RjT2ZvN0diM3RKQTVDM2Q3ZVRMNWhDOStwR0tpOXdNaUFUSlZzVktITHd0dnFrcmIxdWt6TmRzVlpWSjh3ZUl1QjR6cEF2cWRZRjZvSnZEZTNQaEV2c3JNK3ZKQVA4eVNzQlRlYk9LdzNXd0VIRnBvMEc0ckkrSXBtTldRRjlGTkRiaFdtbGpJdU9jZStrUk4xUGM1NStsbks1ZzNIdVAvLy9yZVF6ZzdkNzd6SUlNMHhXeWw1TDZOM3FBVktrZVlPUTFTT0NUdUhFMTN1bGM4ZG9UYlYyR0U1R3B4bXZreXBsQUlwYXhXRHBpWWVXMW00U3RWTkZ5dGsxVko1OFFwbnl4MHB5ZERTWFUvSWhsWUZjZUR5M0QzUjNVbEhrcEFoa0NxbENxWEttZ0x3VVJraGZGbDRJNDBLU2FNekdocDZxNTdyQUhuVFVVcHg3OTBuYVhjRzJLc3IwRVpLNExEWHpqWjY3YVNkWi9iZzdMNzYrTEhEWTJxc29kQ3E3SFk3cjBnTFRaWWJKTWhRZ2FXMjZWaDhNb2Uwdk5FSGVVNXg2aVp1LzlTUEVOZnJySHpoeXd5VEJIR2V5UTRNamRDYnEyUFFLRlgyVTd4WEZGYVF3cGJ6OEw3VWRoVmVTUExTTEc5azlWcEdGYXEwREp3dmF5SnZaUmRVMXBkejdiNUswL0swWU5qTzZMZFRRSWhxVVpZWC9vbk5sZDVGVkpsT2FhM3N4RXhkR2w2dzFvdmo2bmpuWHNPQzlHMTBQMXluZWQ4Y1JiencvQXZueWJJM09QRHZqU1oycWo3MTZvSDYzTVdkUzhuQmN0UmJWN3RKU2pHbUljSUVaZEdzMEtoQVVlRFJlV213SGFBWUh4OGppRUkyRDR6UldZaG9kTXQ5aUFiRjB0YzNLUUpOOTdZcEFoMlZZN3AyZ1BLT1dJZmxraURyeWIxUUlCU0ZVQlBCS1kyM3BVT2twa3lsa3RIZ1ppWFIxS0t3VXBJQVdvUWtkNGdWa2s1QmZ5dkZGUTZsSVl5aU9JeWlSdGxoS2Rkb2VTOU1UTmVsSlVJM3RjUjdDcEMzNjdrT2tEZWQvZnRuV1Y3ZVFrVDJEbHNGUUdpTU5qLzVZKysvNCs0N2p2NUVsZ3h1V3U4dHF5Z0lLc09HQWtTaHhLQXdKRDZuRm1rQ0krVGpodjZVb25uWjRUV01SeEhxeWpMYjY2djhyNE92TTMzWEJMZWM2K0M5Sjg5eUloK3cvOGtkOGxqVHZXRWNYM2hVdFNqSVdpRjNIbC8xTWJTSFFHbXNlSngxakZ3ZW5CZHNvQ204eC91eUw2TlFpQ3ZuUEF0WG1mYjUwaml2dHpFa1M0cnlheXFOUnNmYStucUZJNjBVMmdRYVVZYXQxRjU3dTlLdXAxai9jYy9kZHg2Z1hndTVlR21MS0FweHp1L2QyOWc0ZGZMQTNNLzk5QWMvY3N1cGd6OG5Qci9KdWlLWVhneVlQUmlobGNmNkhHczFpckFjdGMwS29yQk1iVElVclhNRnpTc1pWanhvamVyMHVEeHArUFhvVlhwUHJMUHZ3ZzR0cmF0NndCTVZDdE8zN015SHVGaUI5K1JaUVo1N1V1c3BDbC9PMVJTeTYzR3NVTGhxalVSUU9iYVVLKy9LNkdHZGxOSElhWktrSU04Y052RnNyL1laZEpPcll3TkdVWStpTUZvWlhycXkyWHZhWFEwVWJ0aE5wWnZhSDVqNzRqcEFnQ2lLV05vM3hpQXA2UGR6NWIzWElqS3kyV3pjZTllSi9YLzZUN3p2RnhiM1RmM0VZTmhiYkxlM0tJcWNpU1hGMkZTQXMzMnNGWks4N0g0bmhiQ1RPQnF4SnMyRVFpQ3lpdG56SHBmWnl2NnhZUHZsbDNsNUtlY2J6NXhtOW5MS2pYRzlHaEVzblJiR0pJU05oTTVDU0JFSWVlWW9xckdpSWhlSzNKYmp2Vks2THNySWZiRlNVWmUxaU1GVkRKZXQ2bzJpOEJTNW85Zk8yRmtia0hSU3ZCKzVYNElLRFhFVXEzQzVQOXhvRDcrWUlEMGcxeWpybkpjZnBIdmpPa0NBZ3dmR09QUGFGdjErcHF6MXluc1ptUmMwZ1BwWUs3cnYwUDdKWHdnRG1lNTFPOWpDNGlpWVAxckRSQmJ4V1ZsLzJMS2U3MlhDOXJDZ1dkTVlCYUZYNUMxRmE5a1NibGt5Qkt1Z09TeFl1andrT1RiT2xic211T2xLUmlzdm5WT3MwWGdSbWdtNFhzN21aQ2x4S1hKWHVzdzdqL2ErR2dtdU9uRzY3R2VvYXY3RE9jSG9FRkdDc3hhREJoR3kzTkZ2WjdSWCtpVGRsS0lva0dvbnZEWWFFd2JvclNGczVkKyttR1JmeXNVUGdVd3BaZVV0c0RmeE9rRCtBTStqRDkxTXA5dWwwOGxVVWJoZHRvcHFJUXd3MmU0TTRrdVgxbTZ4UlhwZ2ZDd0dvRGx1bUQ0VUlHUWdIdXNVM2ltVTBuUnp6eUN6dEdxS2VsU0NoSHJBTUxYVVh4NldTNFBLeFNEVU5uT09iRnZPM2pST0hMWTRkTG1QR0VVaFpiRnRyYU8rbGVPR2xxMkdKdFZTeVZ3OFZNVzJIUzJwMGFXbXpGbGZXUTE1Q2xzZ3Z0S2JPY0htam14WTBGNGYwTnNlWXEzREY1WkE2MUlaYkJScWE0ZzVzeVhkZnZhN2w3eDlSa1RTUFFEeER6UmFYQ255NndENVFUaTMzbnlZVjA4dnE4SjZKU0o3clRZYllXREd3bERQMXVKZ1hzUWV2bng1NjZSMVR1MmJiM0g4eGtuMFdFSHBmQ1E0WDg2Rk82WG9KT1crRWEwOVlWQ0NKaStFUVFqTnl6bk5RYmxnSTNPZVhNTllycmpsOVlMdGdXWFE2VkV6QnE4VnVoSW5GczdSYUZ0bXR3c0NJMlFhTWhFS0VheDNlRldCS2ZlbEk3eVVhK2pFUWV3OWVlSEluZUFLajg4Y3cwNUtaNzFQbHVTTWhnNk5NZWpFTXQ3T21WeE5VY09DRko1Y0VmK2RhZ1k5RXlnQ3BXUStDRm41anpFN2ZaM0Z1cmJPTGFlV3VIQnhIZWZZbTFiVmdOYkJwWW1qalNZL2txWFpIYlZhYlY5b1pHbVFwT3E1Rnk3ejBBTW5PSExER0plNjZ6anZDSU95VCtHcTFNYjZjbTdEZStpbGxtYWt5UXFoR0ROc1BqTEJ6TC91VVBSelVJcElTc09IcHZVYzJlNXpRVUZMeXIzdW8wMFpoUWg1Vm1BdUY5eTRsWFB6MGhqSldFQW5jT3dZUjY4R3c2WWhEeFNpTEpFRnJNZEo2Zmh0TGJTeERIMVZ0SGN5d29GbHltbVUxclFrWXF3SGRtT0lUeTJaczRRS3hrMHdiYnlMUExKcnBhVEFGeUljdzhpNWEzU0c0enBBL29ET3FaTkwvUDdYWGxWSm1xdTlSZm1OTnl6Ty9mQ0hiL3VaSzZ0clAvTGErZFdnM1VsVWJndFVvTGp6OWprKzhVT0gyV0ZZUHIyOW9MeW5zQXJyemE0UmcxYWxWaXF6Z25oYmpkcHFlcWZxWExtUXNmQ2tweDZZWFFlSnduc21neHJqdFJyT09ielNKSzcwM0txbXlyRWF1czRUcnc0Sk5nM1RYcGpJTFVOdmtWYU1yd2VvVUJObUhyR3VOTk4yNWZlemxTVzBYVVpYTExQZWcxZTRRa2g4anZGUXBBVzlKS0dVdVF0TmJWU3pGdTJMbFdzV1dkNnQ3aFZ0UmRTRkxKVVpGTFVvSk0yTDZ3QjV1NTRqQi9meDIra0xhbS9kRVJqZCtQRDdiMzczd256amc4M21mSGh3LzZSc2JIUTRmMm1UWVpyejUzLytZWTZmbk9DYlp4UEMwc0lGank5VEdPOEpkYm1TVGhzcGJWNjgwRThzWS9XUWVsVHFvcnJ2bW1DNkRiVlhodEFNcWRWajhpUWp6d3AwWVZHaHdRcmdGTGt2emE5a1pCSHRQS25MVUNnSzU4Z3JRMSsza1YxZEcxMDVVVmdsWk42VE8wZVdGL1NMblBVc3BlMHN1VktsSkY1OE9TNHJaWkd1S0J1TUNrVnRySDczcVVPemR6MzF3bXRiVldUTkJGeFB2R1JLUzB2cHQxWFgvSG9OVXAybnYvQjNlT1hNTWwvODZzdXExeDFxN3lWVXFyVDRmK2NqSjI5NDhMNkR2NVRueFpGU0dWdW9SaU5rWVdHU2ozL3dOajcwUThlcHhZNlppWmpEQ3pNY1hwaGozL1FVWTNFZHJjcjExZTJoQmUxb0JOWFdYaXM0RlBXNGpEQTZWUFRHTmMwVlI5eTFHRjBLRDhXV0hsc21MTlc4YWVISWZHbXNiU3ZxdHhBb1JscjEwblNYekhzU2F4bTZnbHpLK2ZsTUNRTnJTYXd0VGVZUWN1L1l6ak42M3VIRjc2NitNM3U4L3FRQ1NHZ01yOXVpWGx1WW5ocHYxbC9ZMk83dU1QTC9CZTgxWXJVaU1DV05mRDJDdkkzTzRZT3piRzcxMk56cUtPKzlBVUlSYXZWYTFIejNPKzU0ZjcxZXY5RzV2a1N4VWRibUZLbG5hV0dLeDk1eGdscVFnR1JNeGRYb25nNGhiSEowYm9aQkxxeHQ3UENWbDY5d2ZtZUh2R3BCeHhxOGN5Ukp3ZlI0QTZNVTNTTncvaVBUM1B5RklYS3hoNmMwWVhCQ3lVS2hDSlZDaTZLYURpazc3ZDdSTFN3ZW1BcWpraEsyam1HZVZmc09QSkVPeTM2STgxQTRYT0JSMXBFWEJZUFJVaC8ybWh5WHcvaGg1U2FPVW5nRks4T0VlRzNyN2lOTDh4K3ExYUtMYVpsUFdjQ0pGeW1zODk1N09YVmlpWmZQTEYrUElHK1hjOXZOaDNucU82K3BsYlcyRnJtNklPYUQ3NzN0bGp0dldmelpKQjN1R3c0R0trdUhXRnZRYU5UNTRBZnU1T2hTaGhxc1FLOEgzVGIwMmpEb2cxZ1VsaWd3VEUrTk15emd6S1ZObkswY1NRUjBKWVlTOFlTQlFTdG9OenpkT1lQdWVHcjljbCtpOWI0YWZ2SVVsTTA5TDZPdHVtWFU2RHZMNjhtQWxTemxpaStZUEhVamVtbU9pMlpBMm14d3RwZndhci9MemswVGJMM25DQi81MFQvTkRYZmN5N21kTGE1c2JERGF4ak95VnJRVk9LcEFoZ0U2d092ZXN6Tkk5ZVJZNDhEQmZUT3ZYVjdkdXNJYjluaUlqTFhxakkvVjJkenVYUWZJMitXOGNuYVo4eGZXZFZHNEVhM2JyTmZpOFUvODBKMGZpeVA1UUpLa3hudEI4QlJGd2QzMzNzSkQ5MCtqVjU1QnRyZncvUVRKVXZDMnROWWhRaklMYVFlbENucXA1ZWxYdHhqMFBGa201Wm8zVjViYVdlNUlDMGV6RmhJb1Q3ZnVXVjR5RkJaYWwxT3dIcVhMK2lDeGpsd0pYcFhTOVF4ZnJsbFFodkU0SmpBYXJ6WEhIM3lBRzM3cVUvemFRMFBzYmZ0NDRmazF6c2NGcXo5MmxNYjc3dVF2ZitRWHVQTTlIK0RteHg3RER3YWNmK2tsYkxVQTU4MW15aGFJV2pXMkZ5ZFk3WmI3NTlNc2J5N09UVXhycFo5dDk0YTlVYXFsd0VkUklHUE5HcHM3L2VzQWVUdWM0MGZuYUxkVDFla090SWhFVmUzUitzampkOTE2NjZuRm54c00rL1BPbGNzNnJiVk1UWXp6M3ZmZHlsVDJNbTd0RWpZcjhMNDBTTENpOGRhVnZHNWVRRHFFSWlNdkVwNi9tTEd4bXJHNVBDQk5oVncwdVMvbndZZUpwVCswUkVZVGh4QTBEWjM5QWR2amhzQnF3azZCenh5aXlvNTc2YnR3MVkxUEtjMVlFREFUaGt6cmdPVE1hMncvOHp4cXMwdDNJa051R1VPOS95RHhzVVA4K1JzK3lUdm5icVhvZHBHdFRWNzgvRy94L0t1dlFtbmJzNXRxVVFGRUFrUHR0b01NeDJxc0wyOVhWcXFGOGlLTE54eGVwRDlNWHhnbVdWcUJ4RnJycEQvTXhOcTNKK1g3QTFlREtLWFlidmVRa3RzUFJLaEZVZGk0OTg3ajczSE9IaTl5aTZlVWMzam51T1BlRXl4T2JHUFBYU0JQU2dNM0ZaUTdRMXlWemF1c1N4aUZhQlNTWnN3R2l2ME5PSmQ2TmwvdjBPa01tRDQ4d2RTQkNjYWFJYlZZTVRDZVRydGdmcTdHdnRrYXdiaGw4NTRheThjaTVsNEtXWGltei9oNmpzNXpOT0JVYWVYanRTRGVVemhQVkRVVXZSZmNsVFdPbkxjY2VDSmtjS2lKVzJoeVluR1dXMTk3a2FmY2k3ejA5Rk04OCt4M2VQSDFDM2puZHArTVY4MUpRVUtOV3hxREExTms1emFxcUZlZTFjMU9NRDg5OGNsVHgvZS91dFBwLzVwMVBnZHk3OFVuYVM2TlppekRRWFlkSUcvbDgxLzg5WS94cjMvN3VVcU11THZ6TzdyajFrT0xZMlA2SGNQQjBPaXFvTGEyWUh5c3hhbkRBV3I1T2ZMK0VPL0tpVHljeDZveUJVTU1TbXZFT3JReGFLMElWTUJTSGNLYVpudDd3TWFsbktteEZzdjlMU2IydFppYXFkT3NhNnlCSzhzSnc3NHdOcUZwMWhUUmxHYno3aG9iK3dObVh4d3lkVHFsdG0xSkJpazVZSXltd09POFEybUYxaHBsREY2RDB3RXFjMHk4MGlVNDNhZkxHcC96WDZSWDVLd2tBN2FkSzkwVktWM3IyYk9qdm9nMXc0VUd6TlNZRkNFZGxqZTdWbVYzMEZySG1kZVh4eGRubXgrS1F2MEY2L3hvSnQxcXJmeEVveTVvejdEMzl1cUwvTUNrV1BmZWNZelRaeTl6K3JVTm5lWFdVTG1aTnhyUnhFLzk2Q00vMHFpYngvdjlZV2hkZ1MweWtpVGpwcHRtdVh0MkM3dTFocGRTYStXclNieVIxeTdWNWdleG8xVU9aVGRCYTgxTGJjK2xDMTFxd1NSLy9aZitKZ3RUQjNqeXlhZXhXS0lvUkZFYXZmVUdCZDJlSlMrRXlHaHFrU0ljTjNRUFJtd2RqT2hQaFBpb1dqYVNPcXoxS0Y4NksycWpNWEdBRlU5dUxjcG9uQkdzRWdiaWNFRFhGZ3lkdzZ1UzBqWFZkNGxXRkxHbVB4blNuYTNCV0kxbXEwbGpyTUhLNVMxNm5hUUVrcXJVd2M3aFhkRXBuSHpOT3VreGNtVVhmSm9YWWlKTmM2ekdsemYvQ3YvZ2J6OXhQWUs4VmM3ODdCZ1hMcSt6c2RWSGE2V3E2QkVDMGYxM0hkMC9NejMybmpUTjZvVzEyQ0tueURMQ1FIUDcwUWpkdjB6aHl6VURlZUdxc1ZXRklPaEFJY3BYTjA4MXd1ckxNZGFGT09Ua2JNRHlYVXU4K3VReTMzejZhZjdTWC9xL01kYWE0cGYvMmY5SU50aG1ibkVNRTJyUUdsZG92UFVNdWdXTnBtRml3akJlTXhTTEVkMlpnTzFiYXJEYWhPV0Uyb1dVMm1iTzJNQXhaaUpRNWNDV1EyUENzR1Mrdk1QNWNnZHQzUVNNNllCUUNVTXRESlJqMkFqSWE0WmhwQWpxTlFJTllhalJXcE5uT2JXbVlYYXBoYmRDTnN5eG1VVWhERE4zSWdpQzkycnRWNzJYQkNnRXJIWGVHNmVabksyL3JkUytiMnVBdlBPT2c3eDZjWnRhclZ3RkhZYUJzdGFPbG1SR1lSalVINzcvMUtQTzJSczczUjFza2VFcWxlcUQ5eC9nYUt0SHNaMUIxUjMzcnV3aGVDbEJvQ3VSWCtrNldNMkM1dzRsVUE4MUoycU9WeGNiRkxmUGtzc0F2UERUUC8yelRJeFA4M2YrNi8rQzN2b0tDNGVuQ1pzaGVhQkpJME1VS25vOWFHOXJtbzJBZWwwVDFBeEJYVk1jaVVrUFJHemVPb1lrbm5nclo2d25oRnVXWUF0azZNaDlHY1ZzNWFhNGs2ZDBvenE1aitnWklhMXBDZ1dFQVFaRnZaS0tlUEZZNzhteWpNRnFnamJDNHVGSjZvMm84djYxK0dGR2IzdFkzOWxKUHVERlBERkk3TWlodlJBUktUSm40MXFnSG16OGJia09rR3Y4L0pPZmY1emFkSjAvK3ovK0h1dWJQU1dDc3RicGFxVnlETlFQSDVpWm1acU0zanNZOW12V0ZsaWI0NjNsMkxFNUhyMmxCcHRYOE9XdWdYSXF6eWlxcFRPbGp4Umx4RENNZXRCVnNXc2QrU0RqUk0wek1jdzVjc01rZ1Z0amRmdDFabWFtK2VGUGZZcUYrUVgrMi8vdTcvTDhNODh3ZDJpTTVtU0RJRFlZVTg1azFHTkR2MXVPd0VhUkpxb1pvcnBCMXd5aFViaW1wbWpXV0xjZWw0WDRKQ1liT216bThNT0NJbk1RR2ZCTm5DcTl1aG9lNHNKUjVBVVVwYm8zNllFdEhNNTZySFhrYVo5ZVA2TTEwUUJSZUFlMVZrUmp0b1VKRkkzMUx1bExheWU4eXo4d1RMZ2llelowT2V2bHpQTnJia1NHaUx6MWNmSzJyVUZlV2RuaEgzLzVaZFVaWkRxM1hqdm5qWWhFVkdwZG9QWHVkOXgwMy94Yy9ZOGxhVkxQOGd4eER1ODk3M25uQVk3RTIrVGRmcm1XeGtIaEttbEdSZnNvQmVYNnB6S3ZsM0puWTdtWG8rcDdORUtGN3lmOC9rdDk1ZzRiTHEyL1NLQ2J6RTR1Y2VMRVNlNjU4MTVlUDMySmIzL3JSWGJXMjZUOWxHRS9KeDBVRFBzWnczNU9NclNrUTB1dm05UHJGS1I5UzlLekpIMkw1QjZLY3NXQnJ2WSsrMHEzVlRtUEVzUUJZYWdKQWxQWkVrazVsbXNkK2JEQTVZNmlzT1I1d1dDUXNyMmVNQmdXUkkyUTVrU2QxbFNEOGVrYXJla2FqZW1Zc1lVVzR3dmp3Y3gwODlCVXZibThzdDY5eU5XTlhkVlNvcElCV0R3MnhjMFBIdVRLMmUzckFMbVd6azM3cG5oMXRhMnl3aW52UmN2Vjljb2pjSXpYNitIVTQrODk5WW5BcUh2VEpOUE9PbXhoT1h5Z3hmdnZDdEQ5blhMNFNBU0hYUFdVOHVYTnFGUzVQVXVaTXBwNFg1b2dxTW9pVnlodGV2WlBCbHgrdmN1WHY3M0Q1SnhuZWVzNVhyOTBGdVVpYmpoMkUrOTQ2R0hHNnVOc1hObG1ZN25EOXRvMm5jMGUzZTBoN2MwQnZlMEIzWFpDdjVPUTlESUd2YXcwZDl0SzZXNGt0TmNHZEZZSGREYUc5TGFISlAwTWEwdlhFNXQ3aXN5UzlET1Nma2EvbmJDOTBhTzdQV0RZU2NtR09iMWVuMjQvb2R0TjZHNFhwRU1ockljY3ZuV1JvM2ZzWStiUU9HTUxEY2FtNnRUR1FvSlEwWnFLbWQ0LzNwcWRIbHRxYncrZjYrd2tQZmJ1aGxTSUVxaTFZcWIzdFlqSGF1eXM5SzRENUZvNVdpbUd1VlcrbExEdnBsUkFReXMxYnJTZVhad2ZQM2J2WFljK2djaGlubWRBbFVZVkF4NDhuSU10N1hDOEw0RmdBb092RnRub2F1NERxbVU4MVJJM3JSVFZWT3VvNllMU2lwdjIxL2o2VTF2ODdwZFhtQmdQYVV3TmVmWDE3N0MxMldiZi9GRnV2L1YyYmpwK2dybUpLU0lpbE5Xa3c1eHNXTkRyWnZRN0djUDJrSDU3UUhkbndLQXozUE5LNk8wTTZPOE02VzBPNkd3UDZHOFA2RzMyNlc3MTJWbnJzTDNXb2IzWlkyZXpSMmVuUjc4L0pFMHkwalJqbUdZTVUwdWFDRFlCRTJxT1AzQ0FPOTkxQS9NSG04U3RBQk5yZEZBeWN4YUZLeHhPUXppaEo2ZG1hcTJkOWVFci9XNldWRmVpOU9KVlNCQVlqTkdzdnJwS1VjaDFnRndySjNkZWVTK2pZcndHTkl6UzQ0dFRZM2N1VHJYKzJFeXQ5cWxEKzZjZVh6bzRmZEo3RzNoWHpuWGNkSEtHYytlM1dCeHpMRTFINUxsSEJ3RkJGT0tyTVZlbEtuQlV4Z2hLd0lqYXRjc1J5amtRcGNEb2NtdG9MZExjZmJ6SnkrZDYvUDQzcnFDVjRjUk5jMngwenZIMXA1NGdTUXFPSEQ3SjB0SVMrMmJtV0ppWTV0RHNQcGFtNTVrZm4yYWlQa2FvSW9wY1VXU2VKTW5Ja3B3c3pYSFc0bTJaR2xwWHphdExhYzRnenVPY0swMGJuTU5WdnNPcVNzR3M5eFNGVUdUZ2toTGtzOGNtdWVQeDQ4d2RhS0JONldhdmZOa1A4UUtpTkNvdzVjeUwxbVppTWo0K3Q5QWMzMXdadkRybzVlbmVTSktuVnZMTU1iazRUbmRyZUIwZzE4STVQRHZGOWlCUlNxbFJyNk1lQjJicTVOTE1INXRvUkgraldZL2VGVWZtMklGRDAvTXpDNjNBMmdLUFoyYXl6cWZlTThrTnMwUE9YVW81dWk4QXI0aGFNZDVEa1JSNFcxSzZaUStoWEtta0t3WkxlVld4UVZMUnErcnFMa1NsbUJrTHVPMXduYk5YTXI3NnpTdXNyM1E1ZkhRZnpRbDQ3dVZuV052WVpISjhnVENxb3pUVW94cmpqUVlMa3pNY25Gdmc2T0oramkvdDU4RGNQTFBqVXpUaUZvakJGWjZpc0xoS3Z1NjhyenJnNVFvM1ZjMTlpSHFqKzZGemdyVWVtNEd0bGpDYldIUEh1dzl4OHM0RndrQWpJb1NCeG1oVmVnRWpGTlpqVEZuVGlCTUVNYTJKK0lhWitVWnJjM253OHJDZloreUtHWkVpczZJVnBHbkIxTDRXYVQrL0RwQS95bU9keDNtdktlZkxZNkMrT0RsMjIxZ2MvV1V0SE5OYXFXRmhtVnNhVjFOVFRXeFJJQXJlLzhBa043WTJtZElaWXcyTnFlVGl6anFzZGJpaVdsQWo0QkZNVU41eENvVWF5WkIwK1hkbzBGcnZ0cWxIbTM2bnh3ejMzampHNWZXQ0o1OWI1OUxyRzh6TVRyS3dPTWJLeG5sZXYzeVdRWktUNTQ1aE1zU0xJd2dOb1Ftb1JSSE5lb1BwaVhFV1orYzROTCtQSS9zV21adWNwaDQxNlBjejBpeEQ2ZEkwYmpTeEt5Szd0TFQzSmNBTFYrNm9kem5sTHNOS245dWNxbkhuWXdlWm1XOGdIaUp0TUVwUmk4cElhSlJtWkZ2c1M4K0lzdlpDek5oWWRHeHNzcWF1bkd1L1hPUnUxK0Vkd2VlWm96RVdTM2R6eUFmLzNMMmNmV3I1T2tEK0tNN01SSXZ1SUJudGhRbUJodEc2ZFhCNjdLT0IwUjhVd1RncmFyMDdVUHNPekRBM040YlNFUXN6ZGQ1MXNrT1k5ckM1b21GQXVYTFhoaTBFakdGa3ZZa3F1K2ZhNkhMZm53TlZEVE81aXQ1U3FNcmhVS0VxcTNNVEdFUmdvbUY0OU5aeEJpbDgvZHRidlBUY0ZVU0U2WmtXaGZTNWNQa1ZsdGV2NEp3bUdTVDBlanRrUmNJd3k4anp2REtHYzRnWGdqQ2cxYXdUQlJIYjdZVDF6UjdlT3JTNnVqUzJIRUlzMHo3bkhNNlh1eFp0RGphdjZxV0tmNXJhMytMb3ZmdlJZVkRPc1JDV1JuZlZudmM0RElpQzhuTEVrU29kVUNvcVdKQ3cyUWhQMVpweDU5TFo3VE1pdTd2bnE2MGxjT1NPQmVZT1RYRG15ZXNBK1NNNTlUZ2l5WEtsMUs3T3FsR1B3dW1GcWRZUGgyRndDMHFSV2N0T2tyTi9hWXJKeVFhTjFoZzM3RE9jbXVtVnBtcXBMNWZKVkIxeGo4TEVRVW5MU0VsUnFXcEpqb3cyeVZZN0EvMmV0ZGRLS1hTNXRMeDBPb3hDNG5wSWtUdkc2Z0YzSG11UUZvclRGd2VjZTNXVDVZdHR4TVBrZEIxUkdaM2hOb01rWWRBZk1od01LVnhDN2xOMmVoMVdOdGE1c3I3R2RxZER1OWZuaFRQbk9YOWxsVFN6S0NDS0tzSkFsUU5RenBjTGRwd0RWNVRBc0dtNUYyUlVWdXRBY2VUMmVSWnZtTUlFWmFSUXVub2dRTG5FQjA4dGdIcWtpRU9ETW9vd0tBZTh0RklZUTFpcmg0ZXM1N1dOeTkxVjlzeU9lT2ZGRlo2ajkrN2o5TmV2WEFmSUg4VnAxQ0p5YTBjT0pUSFFhTmFpeGFsbTdjZTAwUXZPZS9wSlRpZkppQ09GTVI3dkU1YVgyeHhmaW1qNEZLbWNDOFVMMWl2ODZDWXJSVmZWUWh1cTZGRStHM1ZWazFSa0ZvRlJ1enRHbkN0Um94VkVZM1Y4NGJDRkl3N2dvYnVtZUhYWmNlYlNnRjUzeU1xRk5sdHJBMnF0bU5aVWhJOHlFalVrU1JQeXBDZzFXQXBNYUFoQ2cvV096VTZIMTVmWDZTY3BTa0c5QmtGWVVzMWVLRDE3WFFrT1c1UXZsNEVVVnd1U29HWTRjdmNDZHo1OGdOWjREQ1lBNzRrRFhmWlh2Q2MybXJvQko1NTZWRFl5NHdqcXNVS1phaTdlQzBHZ3h1Tkd1TmpaeVo3djc2U2RQU0NSYkZqSTJXOHV5OUtKR1hwYnlYV0EvR0dmVmowbXlZcVJiV2dkYU15Tk4wL1VUUEFqMXRxbUV1Z09jN3BKaXRpUzVweWZhZkRzUzEyMnRnWThlbk1kZHZlVGV6d0tWdzB2YVZOUk0wSmxKRDJLRm9MUjFSNWtTclpINldxdFdiVnlXVkVxZ0ZVWVlsb3Q4cDBCdFhyQUsrczUvL3dMVzN6bXNYMHNOQ08yZWpsYk8wTldMM1ZKQmhtTnNScGpNM1hpNlJCcENKbkw2Q2NwdmQ2UVRyZlBkci9QNnRZT1RoYzB4eUtpQ0lMUTc5NlJ6cGMwdExOUVZDbVZ6OHAxYTdzM1FHdzQ4WTZEM1A2K284d3VOZ2dqZ3hLSWxNS1U1UlNoTHBGa3RERFJNTlJqUlJ3cWFnRUVScGlvR2JRV2pBRVFoZGI3Z2pnS055NzNuaTh5dTl0cEJ5UnVSTktZaUs4RDVJK0V3WnFmWWJQVDF3S2hLZ0VTTDAyUHY3TlpDeCszVG94V3FKMUJ3aUFyTzhqdGJzWVB2ZmNnZDk0NnhULzUzR3NjUERET2lhVUdVaTM1OHlKNFhSYmFRUkFRR0kzNGNrbG5FSnJkUEI5ZGRkY0JZOVRWQXBuUjBwcnFuemdnQ1BCcFJ0QTAvTGYvMnlwTE16Vis0dEVaOXRVaUZzZHFoQXA2dzVUdHJSSW8yMnQ5Yk9FSTY0Ym1YRXhqTGlLZU0wUlRtckFKNDlNeGs5TU5YQ1dWc1ZJMkxKMWNCWWROcTZneHVrMUg1SnBXM1BEZ0VuZSs3d2l0c2FqOEhDZUVDSkVSNGtCbzFJUldyZHpjNjd6UWlDcTNTQTFoVUdxNDZnR0lLazN5d3FDS3A5b2M4dWkxall1ZDEwUXExUys0U3JNbFJmYldHTEI2VzJteG5IT2o2VkV0WUxSV1lUMDBpMXBqQWczV2V0SnE4cTJ3TURNZTg4aE5FOXgvN3dJWHoyM3lLMTlvODlDdE03UWtCeTBvNXpBZXhDaWlLRUJWZDU3eVYwZG9sYXBTTFJHTTBidHJ6dnlJNy9GbFQ4UWl1Q1JIOGpaeHFQaVhYKzN4OHVzRmYrdEg1M0NKcGRYVTNMRFlJRUFSZTgvNXRSNkRJaWRaemJtdzB1WDFVQk9QMVdoTTFHbE14SGpyNmUwa0pNT2NMTE1VZVlFZ3V6YWpJM0JJeFRidFBTT2QxT1QrSnJlOTh3Q1R6UkFxS2plS0lOS084WVpCRzJqR1FqMkNYcWJwcDBJL2R3alFqTXYxYnZXZy9EbERvL0FHZ25xNW95U2ZrZkhEeHlkL29yTTIrOHFGbHplZW9aVEdGOTZKRzNZenhWdkU0L2Z0bFdMVkl0VWRwcHJLNDZvV1JSTUhaOGZmNzhUZmlxQUs1OVZtUDhHTFJ4Ujg0RjM3K2FrUFRoRG1LWGVkbXVCYnoyOXk5bEtmQjI2ZHhPYmxEdlRBbUYzSGRKemdNNC9OWGRtTXF4WnhVckZXQWhXalU3YVN5N21SRWtUR2FKeVV4Z2dyWGVIdi9mbzZuM3BzZ1Z2M1JlUlZBN0p3N0s2QjdnNHlpc3hSMDJVb2pLd2dnNEowYzBoM3BVZTYyY2QxVTBnTFZPNUlNOGd5ZHRrcFA2SnZSNlJCOVFJdzJsQnJScHg0K0FEN2JwakNlWXRSamxaTlVhdkJXRk16MXRTb0FGSXZaRkxXWFZraG1LQ3NjYnlGSlBkWVc2WnlEa1ZXVUM0WUZVV1dlV3pHdUhXU2JTejNubldGcjdvdHV6MlM2eEhrRC90czlRZElGVDBvaVptV2hvTmVSQ3RCUmgxbkFhSW80Skc3Wm1pYWdtUXdaRndGL01MSEYvaHYvdVU2bjN1cXk0ZnZhbEFNQzRMUW9iMUNrbkw0aUtxKzhLNXNGSTV1d0hKeFpsbllhNlV3V3ZCU1BxbTlCd0tGaUNldUJmenE3MjV3YURiaW9TTUJhVklRUnVXZDAyeHBwb3VBTksrek14d250VzA2dmFLMDVOSGxEMVdyYWgwRUFuUFZ1cWNtc0paQnZqcy8rOFpybzQwbXJnZk1USTN6OFk5OGxQZSs3ekZtRGs0eDhIMjZ2VFd5WkF1bnQ3REJEcGxyRXdTV3BqSU1Da09nd0ZicjIvcERYN25HbDJzYVFsMlNGS0pLZTFWTUtmV3Yxd09DTUErblpoby90UC9vOUcrZmUzR3RTem1CbUN1Rkc1K081ZVo3NS9uRzcxeTZEcEEvckROSTg5MFVDOUJqdFhCU2lkOUhXYXlxM0ZGYWVRb2NPenpPSTNkTVlZZDl4QlprdG1CZlMvUHpINWppVjc0NlpIWTI1cEVqTWZrZ0p6Q2xVREV2UEI1ZjFSdXlTK3ZxU3N6b3FuYTFsekthYUYycGYxVzV0am5VOEZyYjhOSWx4MS84eEJ3R0tVMnFOZFFpc0pIUXJDbW1XZ0dINTF2azF2R2E2ekJNSEY3SzBkZHF1M09aUmtsSjZTb0YwMkZwTWJxU1ExUXoxSnNoKy9hM21GNm9VYXNGek13M21KcXZjL2pnRXZmZGRaU0QreVk1TW5zdllWRERwUW5pSFVrK0lDbDIyQjVlWmlkOW1kUyt6S0RZSVNzMGd3eGFOVVZrTEd1YkJibVV0Y2g0WGFHMGtPVVc1eFM1YUpRSVVhU3BOUU9DMEV5T1Q5ZHZCNzVUTVlzWktLdVVFcTJWWEk4Z2Ywam5vVk1IK2ViTGwwRHRMdHpVQytQTmZVWkpTMVVEMklWM2VDblhQRDl3NnpUSHB6UjV6K0o5K1ZUTWNzZkJjYzFuSHgzbjczOStuZnBINXJsOVVwTU5IVW83ckMyZjJGcFZNOTBqcGtxejIyV25paVRpSVRRVmc2VkFlNCtKRGYvNjk5WjUrTTVwRnFkQ3V1MmNSajFBRzBXUk91b3g1SFVZeXcwTE5zSzVNY1RCeGJVdWc4VHV6cEFMNExUQ0ZvSlNEWUl3eEJZRGJyOW5ta2RQVEhIZ3hpa1dsbXJNenNiRU5iUExyR1ZXeUl1Q1YxYWU0SldWYjNML0RUdmNkZWhkQ0JyUmlucHRqTWpVbWF6dHg3cmJ5UHdLMjhtekxQZWVadE8wS1FxTlZ5RldvRGNRbEMrMzU1cEEwMnlVeW9OKzRoaGtndkthV2lPUU1OWkJveG5lSGplaXlXeVlaMEFrSXJhN25jbXpUNno0SU5SU2ppcGZCOGgvMUtPVUt2Tjg3MGNSSktpSFpqK2lXb3FTMThwOVdhQXZMb3p4b3g4OGhNa1Qwc3lYOWpvZW5DdnAyRU5OeDU5NHh3UmZmTEpOODhFSkRqZkxwcGdXUjVHNnN1ZWh5bDBhNWV5SDJwM2JIcGtjRkw3c3ZDc2xpQ3U3ejVlemdOYzNIWC9oc1NhOWJvSVdLUHBGeVg4cUJVcUlJeGhybEVvWjUydmxtMlFVeTV0OXV2MnNMTHBWK2IwZVBYR1N6L3pVVHpGM1lKNm5YLzZIM1BEZ0JQT3pOUUxsRU8vd1ZmOGp0eVVwVVRqQjVRNGxtdHdWUEhmK3R6azRmWUtGcVJ2Smt4N09KcUJpaWtyNlg0dVBjSGppQmliaVczaHgrVit3SmV1b1FtalVGTFZRMDkwcUtJYWVVQ3RVOVdlTjJOTkxvZDMzaEUybG1oTWhZUzI4ZFhaZjYvaVZjOXU3Yyt6ZUM4TkJZYXQxMG5LdEZ1MXZteUk5TFN6RHROaDFTbFJLTlk5T3Q5NHJxQWNLVU40TG03MkV4RG8rK2JHYitlbVBMV0MzMjdpaVZPbDZyM0NWc1dhV3dYUWpZSElpNW5lZUczQnNJU1J3VWhYa2dvbENNS2FNR280OXVxZnlTWTBDNjhBNWpUWmwzNlRWQ3ZoWDMreGdSUEhBOFFiRHhDSUNSaW1VVVZnL3VsTlV0YzY1QkgyZ05MVW94QmhOYmgxWmFqRkJpL2QvN0JQODBuLzV0M25QaHovRXlkdHVaK0ZZbTNyNE9vMUF5dFJ0NU9mcjlPNHE2TXg2TWlzVURrUTB3NnhMWEp2aThNTGRHRzBJNHpHQ3FJNmdNRnFqamNLNWdvZ3AwczBhL1dTRlRQZElzOUx3T3FvWnJDMXJzVnFzQ1F4RWdhSVpLMnB4K2FSb3RBTGlTRVZGN2k5ZE9ydHpocXNsMi9jRGhib09rUDlJSjhrSzlwZ3gxQ2RiOWFsanMrTWZzYzdmbU9jZWJ6MnIzUUZ6Y3kzK3MvL2tGbzQzK3lTOUZIRWVzVkl4UDFXWFhCUjVJVXpYRksxWTgrdmYyT0hJWW8xV0ZPQUt3UWtFb1NHcWhiczNzNkFRWDA0WitzckV3YnN5N1lvQzJQSUIvL0R6Vzd6bjVqcmpkWU9nQ2NJQWdqSlZjZ0tpOTNnYzdnNWxsYkw1S0Fvd0NMT0xCL21KUC85WCtaTy8rQmM0Y3VJb1JndGFHU0kxem5ENERFNFNjcWZJTEdRT1VpdGtlV2xoV2xRYmJ0WEk5N2NNV3B4WWVvakF4THRwb3RhbWxQWHJvSEx0aFZvNHdXQzFRR3JyU0pCaHRNWkVtcWdXa0RsTlVqRllVVkJLY1dxaFVJc1VKakkwcCtKd2ZxazIyeHdMMjV1cncrMHNjU043WUhXdDMxZHZHNEJVTkt1dUNzSDZWTE0rdlRSZS82SGMyaVBXS3h6Q1dydlBCejU0bkovNTZCekZ5bnJwUkZLVTh4TjVvYkNqQmx2WjRhQW9oSDJURWFyVjRMZWU3YkovTW1DcUZaVDFTdXJJVXdkYUUwUUdFK2dxZ3BUNkxPOWxsK1VLQXNYLzhydnJkUHVlVHo4Mmk2WnNxQUhrcWNOWHcwUnVqNHgrVi9Sb05EclFCQXFPM0hRSGYrd1gvak1lKzhoSHFkYzBVdVNsL0VWQkZFeXhNMWhqczNlV1FhYnBaa0l2TFJlTDVsWmhiWUQ0V3FuSUZZL1JWNzJ4RGkzZVQ3TXh5Mml5dmlRZFJ0S2E4dXNIdFJyRlFPT0tQbnBpRXdMRmVOMWdqTUVyZzBlWGFXNkZPaXRsRFJaVUg1c29tTmwvdUhYbkhmZlBIcHVkcnhYblh1MXVlQ2VhcXhiQjZ2dEZrbm96Wm1aaG5FRTN2UTZRZjk5eisrRjUxanJEMFo2UENLalBqalZtOTQzVlA1d1dmc2tIbWtJOHZhemd4ejkxbEhmZFBjVmdxMCtSRmxoYlBsVTl1bXl1alNRa1VoYWZlZXE0WWFtSmF0VDQxOS9ZNE5pK0d0UE5BR3RIQ3RsS1dtNDllZWIzeU1ETGFOS29HZGE3QmYvdzMyN3lKMzVvUDB1VEFkbWdRSnlVQUhObE9qYmFNYWdBclFGVEtvSEx2b1hpMEsyUDhNNGYrNHNjT1hrS1hJb1NoMUlHRlRZUUZGbzhXLzF0WGx0L2pqUVBHS1NhSWd2SjBoaWJ0akJ1bXNuNmZxSzZaMmg3cFl0OGxlTWNuTHVMaWRvOElydnRUWW84SzNXNDRoQlh5bjFOR0xGK3NVMC92RUlZbDdsVktWSlVSR0dKN05SQ0hJeTY3T1hYQ29LU0ZwWkFOK3JqdFJOSGpvM2RlK2o0dUZtNU5GanBkL0tpZXQvVW04QWhVRWJxbWZseDJqdURQNUlxNVcwQmtJWEpKdHU5VlBzOU15QlR6WGgrcmxIN2NPYjh2RFdLTkM4WW53cjV4YzhjWXJFSkpvNUkreWsyTFNYZ2hWZGw1N21TYVBpcUMrNDlKUDJNbzNNUlI0NU44aStlMktBV0tnNHRORXBBVlRWTTZZbFZkdFdkN0E2bU16WWU4czJMbG90cktaOTVaSnJPZG9ZdmhEd2I5VTRxTU9sU05vOHJJeEM2Yk9Sb0l5d2N2WmU3UHZ4elRNenVRNXd0YitTb1ZZb0tCY1Rsb0F3cnF5dTh1dklpdmFGaHE2MFo5RUs4cjc1dzJNUHFEWVpGdHdTMlZOMStGWExEMGlOTU51WncyUUJVYVJEbnJDMGJwQ2lVTnRnc1JTdFByejNrdWJPWFdFODNtWjhNeTFtUmlwMHdTdU9sTE5hbm01U2dvUlJ1anBpMFhnRUZwamsxVjd2ajJLbnBnL1ZXbkt4ZDZuY3JKa3Qvdi9kM09NaFVZUjBQblRqSzVhMzJkUmJyMy9XVU93RlYxWVV1dzNZOUNwcEswN0pheEJpdENnZDNIbTl4WkVvWWJQY3dVWUF4QnZ4b3M1SlUrNVhLL3NhdUFVUEZUUFcyQmh5WWF2RCsyeWI0RjE5YUpTSGdvV05OYkZHdVdIT3VIRTRxNlY5VmlhK0VRU1o4NFpsdGJsNk15THA1MldHWFVwcUNMZit0U0ttdTFWcXFUVkxsL0xlSkxCTUhUbkg4SFQ5SnJUVmRSallUb2t4VTFqM09vL0Q0b3NDN0ROWFhySzRFYk9YYkxFd0ZqRTFwbWcxUEhGUWRmd0Zmaklhb3luUXljd1ZKMWk4amx3bXdhWUxnc1hrNXptdkNDSzBOT3F6aHZURFdtbVJhbHZqQ1N4Zlk2UTY1KzJTTnVjbUF0YjVqS0JBRW10d3J1cWxodk83THVSRnRnSExpY2FhaDJCZ0lmV2RxallXeEQ5ejNnZm9kUjI2ZCtkSzNmdWZDUDN2NXliWFQxVDBaQUFtUTI4Slo1N3h2aEVZNTUrUjZCUG4zT1B1bXg5bnNEcFFUR2ExdnJwM2FQM3YzZENQNm9WNlN4NktWU25MTHh4OFo0KzRsUlRyTVFUUlpVdUF5VzlxS2lyN0tSRlZTZGFrbThoQ0ZVWkFOQzJacWlxT0xOVDczelMwUzY3bjU2RGhGN25hbjlSUlhQejhNRk92VzhNKy9zTTRQM1R0RlhKbk1pU292dkloQ0tjRWJ0UXRLY1lyQWFFd2dOTWJudWVHZFAwTno2aERLUktpZ2hnb2lsS3Flekdoc09pRHBkZWgwK2tTTktjNnVmWk1EQjRmc253OW9OUlJ4TmV3VUdVV2t5eUV2b1dTWUNrcGJ4T1B6OXpEWFhNTGFISEZGVlpocjhpVEIyUnlicFhqclVDb2dTMUxXTGwxZzA3ZFo2UTdZNkpVcDZsUTlaS3htaUFOTjdpRjNpa0ZXdWxCR3Bxd1JyUysvNjhpQVE2dlVndGEwNm1QeHpaTUhKMjZjMmRmSU91dkRuV1JRRkh2MUFFcVFXaFRLL3VsSkxtN3VYQWZJdit0Wm5CcGpvelBRNVJwblZRTnF4eGVtSGhxUGd2ZjAwMXc3clpVSkhULzJuaWxtNjZWc0FtVVFVYmhjcXRwRFZVQ3BFdUdLaWNLclhiV3VVTzRoSDY5cmpzMkcvTjV6SFRxWjU0YkZCbUtsQWxmWk0xRktVWTgxdi9mZElTdnJBejV3NTNRbEdwUmRSeFNqS1llWUtyYkxpc0lFMVlpckU0Sm9uSDMzZkJJVGpWV2hMQ3hqblN0S2crMmtUN2ZkeHF1QThibUQ5UG9ETnZ0ZlpISzZYQm9hbTFGVHN4emVLa1N3S0x6V1dDazFVNkdKT0RYL0lPUFJOUGx3UUJEWDBkcVU3dmFpMFFwc1VaQW5RNXkxRkZsR2I2Zk5VUFZvSnpzb0hiRGV0YlM3bHRob1pzYWpVdXlqTllVdkZ3ajkvOW43cnlETHN6dS9EL3djOHpmWHBxM004bFZkMWQ2ZzBSaDRqTUVNaDlUUURaZGt5QVFWakYxcFNXM0UydGpZb0tnSEJoOFllcEVlTnhUN1FHbGxka1ZSMUdvcFI4cU1Jd2ZBd0JBWUFOMW9nemJsWGZxODl1K08yNGZ6dnplekM0Mlp3WEJtaFc3MWpjam9xdXFxbTNudlBiL3pjMStUS0lIV0VZS3pnUCtuSXJvQ2x6YWdSWkJacXM5dm5CdDg5dkwxMWEycU1QY09kK1lMbmFCSXVQSWhGSFhEdkQ3aHRHOE91bHpiWG1kdk12KzR4UG85Ujd6R1JpUnJDS0s5bktVa3JBb1JwUEFPbk9UcTJTN25CdERVRnVjRnBpblJlWW9WTW1wZitaYWFhc055ZW9Ob09lWmVMTEZXQU40RU5ucWF2L0tsRGY3K040NTR0Ri94cjM1NUM2b0dhK09ZTkVrRkpzMzV6ZDk5eU5QYk9ha1NORzFwc3hqbUxpdy9Gci9XV3BLa0F0dXF2czNDbEVmamQzbWkrMFdjTlFodm91MkNNVlN6R2NZWXVtdGI1TDBWcE5SWVc2SVRReitOeWl1TmpYVy9SVkNhUU8xallEamZibEtscDV1czBCYzlURmxSellzVzZpOXd4bUNNUTByUlVvOWRwQmFicUQ2NW5xeEUrSDd0SUpNY2pCelRvdUJnWXJpd2xhRXpSWm9wcWdxYVZ1WEZCb2ZRRWkwakVtQkZCUUlCMDhCQWVSb2hWcE56L2IvOCtUOXovYW1zay8xN3IzL2ovbGRDaUpCTDZ6MzcwN21WWWltT0VjNnREYm0wc2NMdWFFby9TN2gxTVA0NGczelFZMXpVdUJPZjg2NlNzdmY4aFkxZnlKWDQ1R2hhQ3UrOUtJeEFlbmp5YklweHNTR3ZTN2VFaFRzWGEzTGo0K0U2R2FtMGl1NXRiZVJEUE43V1FVY0pYcjQyNE1hUjRkVmJjNTdjem9oR3RvSTBUZm42SGN1dmZXZWYvODJ2bkdPbEkybE1XR0tvbG4xODJ3akxWSkxFbmh2am9KTXBqamE3eU0yTFhGeDdBWVNNa2o1QU5TOUJLdm9iMitUZHpyTGtLcXNway9xcnBJa2hCTWhhcU11a2pQNCtlRWxWQzJvanFHdkJiTzRadXJNOGtUNUpNWjFocXBwaVBHVSttVEFkajJuS21tbzJ3eHJEYkR5T3Vsalc4K2p1WFhxclBkNDZ1b2NOSWU1RVJDd1pxOXB6ZUd3b0trZWFTSkpNY2VLZkM3Tjdsdm5kd1BoUmc1U3dzcHFRS29sSGtDblFCTkhVbkhOT3JvLzJ5dThVcy9yMGZGY3NTTUJDQ0hrMEs5a1pUWVdXZ292ckEvWW1CWnZETHBjMlZqbVlGaDlua0dXVGJ0M3BQWWhRU2laWm9ucENSQlZNWDljMDF2T1B2eDFZSDJpKytHemVIc3g0OEVPYlBZalQxVmpHTEdSR09mazl0R05nRVRjR2pSTUlhL25WbHdiOHhnOW5mT1hkZ2ovNWZDOHk4SFRDVjMvM1BpdXA0RXdtbVJ4YWxHNnpSWXV2RUxaZDJtbUJYaEN0ZktEVDBWZ0NveVJqM1pWTG81N2dZWHk0VDlMcDBsdmZSQ1g1WWd1MDFORWRqMkVqYzNTVW9td1VrMExqak1RMlVKbkFwREJVdGFjMmdjcDRYdHEreU02OUJ5aWQwT24xa0NvT0w4clpIS1UwRUpCYTR4cExPWmtTaEVUckhPdnEyQndFa01oSXR4V3hMSzFkNE5GT3pmSEljR1lyWjdpYVVoeGE5bDg3NHNIM3hpUStwOXZOT1ZLTy9FckM0TGtjdFpyaWNYU0hpRXVwWUQ3T24xN2Q3ajU1c0RNZXQrYzBJYUtCRFdCRENNNTY3eVpsN1pVUVlYOVdoRlRMMEVrMTk0N0dIMmVRRHdCakxYam9lUzlMTmw2K3ZQVVhCZjdLOFdST1krS0szQWJCdTd1ZVhpNjV1SkVRRmozSE1rTXNTcXQybXRWQ05CWlRlYitZenJkQnREU1NiVHpQWHVneTNPenlqNzU5ek5aNmh0ZWEvL0IvdU0rWFgxemhtYTBNWXlNRUpKWlRBdGZXNHpxVnBEcU9RYVdVcEtsRWhzRFlLMGFiUTlKT3d2bitVeWlSTXprK3BpZ3JWcytlSjhuNkxDY0pPQkFCZ2VhOXU5L0JxU256YXNEUnBNTm9LcG5QSlpPcG95Z2Q4OExTMUZFWkpRc1pyNXo5Tk5wcm5LMVJTbE9YSmNGN21xcGtPaHBUbFhPOHMxaHJFU0h3MWh0djBkUWxLbFBjbU41R0pvdHh0TUFDSmtTQmlJNkV1dkZNSjRicG9XSC91ek9tYnpiNE9sQldKWFZkSVp6RUh3djJiODFSSGVodmRIQnp5SDFnYmFoeUxhWFp1VE83WDVaMkFVdFplRXJxVTdzVDRVOUVzb1Z2TTlxd2x6T3Ztbzh6Q0NkVG8wVnBMMUl0Y3lYWWRFZ1NyVVFrTmpuOHZPRFllZjYvWDR1WWxNODluVWVlUTRoZ3dlQlAxVmIrWkcwVlR0Tm4yeUJ4TFZNUTRoNWdQR29ZZGpVL2MzM0FkM1k5TjM5M2g2cnhmUDZGTmF5TjI4ZlE4a05vTTFDYXliYjVqOHMySWVQMjNwU1dhaTNESzhtazJtVjM5QjRiU2pDWlR0bDY0aW5Tdk51UzRPTUNMemdYeGVhNktXdkRLenljSE9OdHpuaGFNcDlYR0dNd3h1S2xvSWFveEJnYzV3Ym5HU1lEVUJMbk1xeXhXR01vWm5Pa0VwVEZMTHBuQVhWWnNiOTd5SGcyNW9rckY3azNlWWd6UGpiZjdmWmRDMmdRR0FKZVNJTHpWTFduQ0I1MVh0RHZkZWp2ZGlpUGFxcXlZanlaME8xMkdjZys0MjhVek4rcTJPNTIySjAwT09IMHNOUy8rdVhuTGwwdkMvdE80OXliaDdQNm5YY2ZIdDZhbHZXRXFDcGZ0MW1sQm96endVM0x4cWRhMGNuUzhIRUdhUi85VGlhTVhUclc1bXU5L01KVDJ5di9vdlAwSytNdzFzYUQ3UU8rYVRBaTRmYUJvOStSbkYzVjdZajFGRWdRQ0Q0MnM2SEZ6L3QyZ1JqYUtBbW4vMjU3dnpXTlo2dXZ1SHB0aGIvM1B6NWdPcW41NVpmWDZFbW9tMEFRY1Z3czJ5eWxWU3l2a2hhL1ZaYWUrY3lBaDhsYVRyWFN3WVdHZDNkdTgraittTFBiVjltK2NBbThhL3NPV0hCc2czZTRzbUE4R3ZQYTdUZVpselh6U1VsVEdScGpDVktRcERtWlRoRFc0WjNqcWMzbk9OZTlURjJibUNGOWRQVU53U09rUktjcFNtbThzOXg4N3didjNyakJFOWN1a1NjWnIrMjh3MTU1VEZmSjlvS0tmdTFTUVpJSUJBb2xKTlk0alBFWUcyZzZBcjB0R2ZaVGVxNUxucVZNSmhOcTUram9uTmwremQ3T0ZLeW1tWU10Zys3azJiazhVYzhQdTlubkxtNnUvc0sxc3l1ZjZTVnFSUWhaek9xbUNlRjlqdFl0OFRNRUh3TDlQS0ZxN1B2d0s2cjk4djlMQ2hBZkVNSDdwZFRvNXFCejZmcld5cC8xaUY1alBTNTRFRkdFUVVpSkVJSEtDSDc0c0dGN1BlSDhoc1lzeHJTY05ORytEUVJhT20zc0VjUnlMQnVXZ0lnVHI3K2lkS3hvMko4N1JLTG85eFE2RVNSdFlMZ1FFQ0h5dnhkQUpDbmo1enVmbXFoRUltQzgyY2QwVXlycmVlZkJJVVVWK1BLbmY0bE8xbXR4V3UzUDVTMnVhU2dtNHlpMmJRSnYzSHVUZytJNENzeXBnRWdsU2lzRXNkRzNvVWJyakJjMlhxRXJ1aTNMTXRCVUJjNDUwaXlQa3FVKzBOUVYxaHJlZmU4bS9VR0g4OXRiN0kvMitjNmp0Nm1GSmMrU2lGNG1pc2hGWGE3b25ZTDNDT05iUjNWb0NrL1JlT28rcENiUUR4M1NOR0Z2L3hBUURBZGRqSVBqMlJ4QlFDdE5ubVVvclRIV0pkNkhvVUJjMFVKOGJyM2YrWm56NjRPdFZLdnAwYXdzSHR2Q0IydWRxSXc3SFJ0Q25Db3pnaEJjM2xybGxldm51YjE3L05FT2tCQ0NES2RVM0xlSHZXdlh0MWYvdEJCMHE4YUJFTEVra2pLQ0NZUEhXNGNUaWpzSGxyVmh3dFpRUnJoSU9OSFlYUWJNZ2l1eUNJVzJmd2d0YzNBUlBJdHMwdTBvYmg0MmZPblpGWjdienFoVndvMGppL0NPeldHS1hVb0dDWkpVRVh4Z1BqUHQyRGRnbE9Sb3EwL0lFMmFWNWQ3RGtnc3JUL0xsVC81OC9JQlZDczVFRnVCa1RGTVVlT3N3VFVPcWNuYU85N2w5K0I1U3RmcFlQbUNkcFdrYWpHMm9qV1dZYnZETXluUDR4bFBNWnhoVHhiNkFxT1ZsVElOc3M4T045MjRSZ3VYaStTMFNuYkJmanJnNXZSK2JkQzFhd1lmNGVtUVFaRUlTV3pkSmtpaFVpekZ6enROVWpxTHhFWHB5WUFraTdseEdrd2w1bHRISk1xckdNakh6S0wvVU9JUUlRZ1JFSUVTakgrY1ZQbXhyS1QrNTFzdWZ5MUo5c0Q4cDlrNmQ1K1hkSTRTUVVncWhsSllJSVFKQ0NDblpYaCt3MnN2NFovL0IvNDEvOSsvOUJ2YkhMT2svRWdIU3JpMFdTdTZkN1pYdVV4ZFhlMy9LT0o5WHhpMmhIVkpLaEZTRUVMREc0bXBMNVJUdlBtd1k1SXJ0dHR4YUhONVk1eS9VU1U2V2lKeHExZ2xpS2UwalJFQW9NQUwrMmJ0VHJ2WXpLQjFkNlZrZEpyeXpYM0h2b0tHVFJWcXRkUkhwTzUvWlZ1TTJmaStqSmFQVkRqNVRUR2FPM1oyU2l5dVgrTUtMWDRpd0RXL3hwcWFZekdtS0VtYzkzalI0NzJqcUNtVUV0L2Jlb2JCMVZGVDByUmF2Y1pqR1U5ZVdyZlE4bDdvWEtlWUZRZ2dXM3ZER05EaG5ZM0FRK09HYmIzTnd1TStWeStjWjlQdDRCei9ZZVlmRFpvUlNraUNqYUp4b0ZTU0REL1FTUlNZRTFucThpTXRQTFdnbmd5SnFqbW5vMUpKaTNDQ1ZvaWhLcHZNQ0lTU0pUaG5QYThSNVJWZHJmR0dqUlp4MXJRK0xGMUlLUWdoS0NYbCtrS2N2ZHJKa1BDN3FmUmNyaWFUOTBrQVNBdHA3cjFvSmJ4RkNFRVhWNEZ6Zy8vNWZmb1dqV2ZYUnppQ1BCVWgrZFdQNHFiT3J2VjgwMXFWVlk3SE90Mkp1b2xVMmp4V29OUlp2UFU1cGJ1d2E4a1J5ZmwwamFKY1V0QjhxY2NvVWlLSU1oUGVUcEpaVTJ3QlNTSTVMd3h1UEFwOTdla2hWR0tvbVFPTTV0NTdTN3lsZWYxRHkrcjBTcldDWUtZejFsQkhZaTdIeHlZcGhqdWxvanNhTzBaR2hMZzJmL3NUUE11Z084TTR4bjVYTWpnK0ovbFp4b2VtTXBhNUsrbG1mZTQvdWMyL3lnR0FEcG5MVWxhTXFIVlVWcDFuWFZxNHpwSXN4RGQ3RkxEcytQa1lsQ204ZFRWVng3LzVEN3Q2L3g5YVpOYnA1aHBTUk52QzdPMjlTMEpCMUU0U1dMUStmVXhLbmtWQWxqTWZZOWtJWEVVSWoyNFdyRFlIRVNKZzY2bFlFWWpxZFliMG55ek5Va053YnplZzgzU2NZVDJva25TeU4vQmdsU1pTT25CVWhrRUtzclhUemwvdWRyRHFZbGcvYUlGa2F0WjRhRXk4blg0RklzcHRWRFNIOGVGN0tSeWxBa2tVR2VYcDc5VXRyM2Z5TFJlT1ViVDh3SWFLM2haUVNLV1FVaFFzT1l3M2VPSUpNZUcrdndkakE1YzBVclZxVWFndGtYQVpDZVA4R1BMUWxWeENDTE5mMEJ3bVBKbzU3UjRhZmVhSkxPVGRMVUpGMWtBbkJtVjRDV3ZMTjk2YmMyaTI1ZENhbjExVjRCN2FGenhmRGpLcWJNajUyVEVjTlJUWG5VODkvZ3UyVjg4ekhZNHJwSE84Y3h0U3RlcnVucmtyS29tUTJuNkdzNUwzNzcxR1VKZFhjVXM0TTg3bWxLQ3pTYTE3Y3VJYWROUkVXSXlWS2FkSTBJMGt6VE5OdzQ4WXRidDYrdzhiYWdMWFZJVnBxaEpBOG11M3h3K083Q0JWSXVqcEtxbFl1Q3VhMXFoSXRHQmt0QkkwQjI0cGpTeVhST3VKMmxBUXJQWjFLVWM0TkljcFpVdGNWU1pLU3BnblQ0NHE2SjBuTzVkVGpFbEVIc2tTanBZeCs5RnJoUTBCclJaYm9YcDZvNTU4OHUzYjUydmI2cGUyMS90YTU5Y0g1clpYZTJUUEQ3cmJ6anJLeHZnMldKVm5yTVJ0RjhaRWM4NTRlOFFKQ1M5azExcW15TmdFbGhWUVM2MXpySVNoUldwTzJYaHBDU09xcW9ack84ZjBPdi9uNm5Lb0ovUGxQOTJtVmJVNkNvZlVteEorTWEzV2lTQktKVWhKcklsSHFoM2ZueUtwbWZsempXaldTdU1HTTRNQ204VnpJRlp2UHJuSXdON3l4R3lWSG56M1g1ZnhxUnQwRW1EVVVxNTZxZHBHQTVXcnU3SDZYSzczempQYU9XbWhLUXBLbVZNVU01MzBzazRMRDJvYVZiTUFGZlpGdjN2OXU2MFVZUzYwazE1eS9mSlpCT3FDdVN3Z0M1eXhsNmVuMStuam51SG5yRGpmdjN1UHl4UzAyVjFlaWcyOElXR3U1Y2ZBQUd3S3BqTDFURUlLZ1lxbm9SSVRKS0NDVkF1a0R1UkJNamFkcG9wNldTa0JxU1NyQnJRVjhCU3RWeXRHc0pzMDdOS2FoYVdxNmVjN1psUUgzSHhSVWd4eDFKdVh3ZnNWYUE0TThqWE1vSDlCS1lLeEhLa21hcVBWVXlUODc2T1FCS1oyVW9neFFXZSthMGJ6NjNsdjM5dit6MSsvc3ZRRVVMVnA0NmRMTGljZmlSektEeU5NWjVOSmEvN09kUkgyNmJwendQaXkxWlVLSXV3dXRWT3VoSWRvSlVxQ3BveGQ0MGtuWUhUdkdaZURzV2tJM2piQVNZQmt3UXNqb1Jwc0lra1JpR2s5UldvenpDTzk1KzFIRm1iVU81d2VhNEFOSk93V3pJVGIvcUJPSm9OVmMwZGV3ZTFUejlYY21QQnhicm02a0pCM05icFp4Zkd5cDVvYmdJQjJPS01jbG0vbDVFRkJWVmV3YjZvclpkSXB6RHRzMHpDWVRKcE14b2ZSOC8vVWZjdS9PSTJaSE00cFpSV1Vkbjd6MlBCZjZtMWp2c2UwU1VFcUpjNDZIRHgveTFydnZjV1pqbGF1WEwwSUlLS1ZJMDVSeFBlZU5vMXRZREZrZTdkV2tqRWFoVXAzb3Izb1hBWmtTajNXZXhnV2F4bU9NWDJaVEx5QkxCQ0VITVhMWTBpR2t4amxEV2NZczBzMXppbGxOSXdLcW45QWtVSThxZk9PanpiVno3VTdLTDh1dE9uZ3hyNHlZem12bHZjOFNKWHRwb29lRFR2YlUxa3J2VTl0cmcyRWdURWZ6cXVEOTVLendVUThRRFdSQ2lON0ZZZWNYdE9DVDFnZGhmUkRlKytVa3kzbS9IS3U2MXE1TVNJV1VDbE0zbExNYWtTYnNUZ0lQancxUG5NL3A1Mm9wTmNvcDd3OXJJL1hXdEloZ3FRUWlUZmpPUThPMWpZU1ZsbFhYYWo5SGt0S3BuaVhnYVVoUjNTMnVuTnZrcWZQck5HamVlbEJnbldYYXl6bWNORlN6QnVFOWE1dWFtL3NQbU04dFc3MnpwR2xDVVJSeGQrRWRvNk1qWnRNcGs5R0lvOE5EanZiMm1SL091WG52UG8ycE1jNnh2ckhKWjU5OENlVUMwK21JcHFsSjBnN09HZDU0NHkxdTNMN05sY3ZuT1g5Mm15eUwwSHJYV3RROW5PMXl0M2lJa0hISnFST0ZrbUpwTmVkYVBvejNnY3A2YkFCVDJjaWNiSHMrMnpnSThkS3hEdEordkdqQ2thVnBQRXBwVEZQanZLUFg3U0k5N0IyT0VWMUZPc2dvNmdaZHRnUzFGdUNwRmdMalVyWk15ZFo4TlFTS3lqQ2ZsempyaEduTWVyK1QvTXpadGNIUHBFcFYrK05pejRkd3ltWHlJeG9nYlUycGdGUkoyVG5iVDM5QkVENWhuTWVEc0c0eDZ2WFJFc0RGSUZGS0x1OFBsV2ljdDRRUW1CY052Vnd6S3VIV2JzTmFYN001MEV0b2gydVhIdTU5ZTVEWUNhbHV4cHYzQzU0WUNGS2g4TzNoa2FJTmtnV0sxM3ZrNm5XNlQvOVp3dm1mcFhmbDgzUzNudWZpRTY5dzd0ckx5UDVWOHM0WmhFK3hOVGhyV2QvU1RPZUdHL3QzR0k4bmJPYnJDQVJWT2FlWUYwekdZNmFUQ1VmNysrenQ3UERvL2lPQ3NVektpdVBaRkpFb3Z2eUZML0RVNWtYcXFpWkpOTFV4V0V0Tkd3Y0FBRzRTU1VSQlZHZTQvMkNIdXc4ZmN1SGNGaGZPYnJVbHBhZXU0bUgxd2ZQdThSMG05WVFzMHlRZEhXMGVaS3RQM1BacFVoREJpMUxHY1hacDhaWEZLckgwVGZRdXRIWjJFZndwdTVLMEVwU2pKbHJrZWs5ZDE2Z2tJYzh5eHBPU21hbklCaGsrVnpUVGhwNU1NZGJSV0ljU0NoMGxuNVkzWnBwcWRLS3hBWUtNM1Bhb2ZGTkxyZVZtTjAwL3BZUlltVlhOVzhiNTVsU1FMTDdFUnlsQUZrdlNKSVNnMTNQOUNzSDlqSEZlU0ttRWtMS0ZkeXc0SFhHc21pUUpRc1FOY0ZqMko5RjlweXhLcEZSVVh2SERCelZLd3RaUW8zVWsvbWd0OENKT2JoYTZ2QUd3Q3Q1NldQUHMrUzdCeE1BTUxXUmNob0FNQWhFQ1htVjBudm1MWk9kZTRXaHVXRjNkWURLdStPR3RQWFlPQ2hxZjBRbWJYRjU5bWlmUHY4RFRWei9CNXZBS2lSaGlqT2ZPOFFQZWVmUXVSVEZIR1NpbWMwYkhSenk0ZTU4SGQrOXp0SDlJWFVTWWlaQ0tCMGRUem15ZjUxZC80Y3ZJeG1HZEkwazdLS2w1K0dpWE8vZnZjMlp6amMzMXRhVUlkMWxWU0Jub2RUcmNIKzN6eHVGTkpJR3NvMGx5aFpTeUxWdmJ6Q29qR2tFS2daYnhkWXFJcTBjSVNTNXlKQUxqTEdWcHNNWmhUWlFuQ2tvUURodkdzd3F0TlVWWnhBTXZOYzRHRGtkVGtuNUtkelduZHA2MEJDMGtWV093THFDMEpnU1BhUnlkTkNYVlVUQ3ZzaGFWS001dXJJQVB5TmFBVkNlcXM3SFNmM3A5MEdVOHEyNVh4bGFjNkFZdnM4bEhTWHAwWVdadkR1ZjF0NFRYZjFuS2NOWTZSNVozRUY1eUN0UVdIV0hyQ05DVFNrVVlxazV3alVOcGlmZVMyV2dhYjd0K3p2L3czUWtQRGd5Lzh1a2hnNzVxYjhFb3pCYk5NbVBwbE9RWmFaNmhRb1RRQ3g5OU0wSUlyVGpEU1kzbHZVZmlVUUtLS3FKamI5MjR5WFErbzZrTHFySkVKUWtYTGw3ZzNMbHpuRDkvZ2F0clYzbitUTXE4SG5FdzNXSC80QUgzNzcxQldqbkN2T0p3YjU5eU5zZFpTOVVZVW11NTZBS2gwK2NUbi9nVWFVaVl6WS9JOGc2VHlaVHZ2Zm9EeXFibW1XdVhFZDR4R1k4bzVqT3lQR3VuUlJuallzNDc0N3MwR0hwWmlremphRmUweHFFaXlGWXhQbEtmbC9xdkFyeUs3bFRPZ3BZUzM4am9QMitpQ0xnekhsdDdhZ2ZCR0E2UHAzUTZPVTBUbUV5UDZOWXQwcm9NVFBkbWRBY3BlaldsTGgyWlZmaXFwaklXcVRURGJvS1drcXBwVUZhU2FvbDJBUzBEdGpIb0ZvSGdnMGNLUlpLbzd2YjY0Rjk3V1FqN3RkZHYvZnZXK2FWTnc2SW4rZEJua0Y2cUZsdlFCU1luS2F5YkpJSlVpZkNTdFRaMU5wNWk2MkttVUZJdGV4QWhJdXhqNFNmb1hMeGRSWXR6cXNzYVp4MUpsckV6c2V4UExSc0R6VW8vS3B0WUV4bHpXUnBsZndwcmVlOVJ3Wk1yR21maXhsZ3ViS01KcldxS0FGdGp5VWkzbjBNS3dkRzA0T3pXT29kN2U5eTdjNGVxTE9JMlcwaUtxbWIvNEpBNzkrNXc1ODQ5OXZhUHNJM2cvUHBscnA1N2xxdFhucU03MkNUcnJ0SHBEZ2xTTVM5THJoWUZ2MVFZZnNZRVhoQ2E3blJPNVJ4ajc1ak1DMzc0OWp0VXB1SGl1UzE2M1E0dWVQSThSeXVGa2dwamFwUlUvT0RSRFc2TUg1SW9SWnByWkhUVVFZbW9oYVZWN0FPY2p6dUtXR0lKbEl6OVNMU0RBK01NalRYVXhzWDNWTXFvN2xJYW10SlM3VmNjSG95WUZ4VkZWVkdXTlVFb3FycW1LaHRxWitrTVVsU3VhYnduVEF5SmlxUGV1bWxvZk93bjgwVFR5Ukx1SGt5b21vWlVhNHFpUVV0RjA5am8xQ3RsdTNqMHVwTWxGNU5FMzlrN250MXBsUUtXVGlvZitnRFo3S1hVTmdoM0N2SWNRTXl0djkzUk1rc0V6eHZydEJEZ2ZEejhXaWN0UXpEV3JGRW9MWDZZb3EzWUFuRjVKUlhZSnFKaGRhSTRuQWR1UEtqSVU4bEdSN2JOT3hHa3B4VTd4elh2M1p2enpHYUdjOUNhNFViZVNRdUlYQ0NRbS9reGZuQ1Yvdm9XMDFsSm1tYXM5SExlZWZ0dGlpSVNmcFRXcEhtK0xBZU50WXpIRXg3dDd2TE9lemU1OS9BaFpWa3hHS3h5K1lucm5MOXluU3RQUGMrVnAxN2s0cFZyZEM4L2dWanBvL3Nwb3BuamI5eWllUENJNysvczRyS0U4MmZQa0NVSjFqcXlMRVVuS1dtYVlxMmwxKzl5YjdMUDYzczM0NlVoUUdjSzYxdVdqR3dWR0lWWUlIQ1d4Q2doNGxwV3RqMktibmNrb1hVVFVqTDZJRHJqYVdxTExSem1vR0owUEtWcERNNWFwQlNvSktXcEc4cmE0QkxKY0xNYlM3TUU5aWNUM055U0tZWHpFU0ZRMUFhcEU0cmFjRGllY1BuY0tvTk9qbElLNDJ3MFFGS3lOU1JWSkVxaGxSaUNXTjBiRjE5dGpKMXpFaVFmalF3eWo2QzAwN3BLS29CY0cyYjduNzYrOHN4a1ppN015aVlxbHdnUmdYdEN0RUlMSnpmY1lpMjRYQTYyRXA1U2ljZ0JieHlKVnRpZ2VHK25wbTQ4RzRPRVBKTllGNE5yVm51c0UxemJ5cEE2ZW4wNEYxb3p6VGptRlFpRWtJalEwSlF6MGpOUG83T2NhZGx3K2Z3MlI3dVB1SGYvQVlGMklaWWthS1Zib0tWQUtyVTA2U3pMa2tlUGRybDM3d0czNzl4alZoVDArajAyenB4QmI1MmwyTnhtZnVVNjVxbm44TmVmd1o2L2dLaEtaZzhlSU05c2tIVnpDR0NkSmM5eVROTzBibHFLVVRubmQyNjh6cmlZSW9qdjJ3S2Z0ZUM1K3hDMWg3MlBDR0RaMGdZVzA2eEE3TmNXenI5U25LVDZzTmk4dHlXVU9XcVl6WXBXZ1NYRVVicEthR3BEVVJ0ME42Ry8xcUUybHNaWWlxYm13Y01Sb1Fsa1VyYVU2SGdER2V2Ukl0RE5janBwaWlRK1g1SWtTOUUrMVM2TkcrTTRubFJxYnpUL2pkcmF3MU43RWYraEQ1QjU0N2g0WmRDV08zNFpJRUtRVFVycnZ2RDhxbmo1OHVBemp3N3JaREl6N2F3K29MVkd0YmdzQ0V2NHVGUnlpZEpkckZxMTBpMXkxbE1WTlZwSzBKb2Jlelgzand4blYxT0dYYzFnb0RtY0dYN25yUWxTeEtCSnMyakFzMEFMKzNDeSsxZEtFdWI3MUNHaGYvWTZ4OU9TL3FESFJpOGhQZjRCcnFrb3JjUVQwYmhLdFpLZ1MxSlhxOStyTkNIRXBucHYvNERiZCs2emYzaU1Vb3BNUitpTVRIUGtjQTIxZFJHZWVBWXhYS2VzRzZxbVJHdUJFb3FxYW1MZ0NzRzl3MTErKzYzdk1pNW5LQ0hRV3BKbUNiSTlpTTRGYkl4NFFtTVJKcUtVWFdzY0ZMZmxzaTJ4VHZDMDdid2tCc2NTRkJwUWM1Z2R6Q25LTXU1UkFLVlVITnM2UjJFZE90ZmsvUlRuWTlacGlvckpxT0pvVkZNMVpwa1Z5ckttcmh1OGh6U0prcXJ6c2lJSTJVS0hGbllWZ2RyR2txdXNtdUpnVnY3anNqRUhwNWFIL2lNeHhmcmluN3JFT3o4NHdrY283Z0xsa0lWQXAzdSsxLyt6bnp2enBhZlc4OTd0dllyalNZMlVDenRudVZ3YVdtdEJDSlRXUzA5MDFmcWpSeHlSaWplbWM5UlZIUmQzV2NLazhyeHp2OFM2d05hS1pxLzAzRHN5SkNJd0tqeWxpZDdvcThPa1Jmd3Vsb1p4WEN3STFLTkhpTjQ1a3VFWjVtWERoWXNYVU1VdVcrYUhkSlNsY29LYUZLVVNkSklncEVBS3VTUnNoVlovZEtGd2o0REpkTWI5QjQvWU94cVI1MTA2V1ladXBVRzFWdVRyWitodm5rZGxRNXh6Vk9VY2dzZjd3Tzc0aUsrODlUM0d4UlF0Rlo0UURYanlKTzU2UEsxbFJEdXFiZHh5T2Vqa2lYUnJ0TUQyeXdPNW9CUXZsbnFDOXVmMUVJNDhvNzBKVFJQVjdyM3pVVjFGUk94Y2FRTnBSOU5ieVhET1k0eUxSTERTVU5lQmVXMFpseldkVTNzUnJTUmE2L2ozYkh4dGpmVVk1MUZLTGJQYzBXVE9nNzJ4OXpMNStxeXNiclVCMG54a0F1VFNrNnZVbFJQVGNiMVlHS1pDMEpOSzlQN2N2Lzd5bnpuLzdNYm56OHhLK2VUNXJoalBIYnRITmQ3YkJVQzdkWUh5U0tWYWxrYkVhVVhFS010YmUvSEJPbWNwNXcyMmR1UjVTaE1FdC9kclJsTkxFZURxVnNibnJ3elk2R2xXdTZwOXhraExYV3owTFhGTWpCZjRwcVNjSFRPNCtBbW1sV080TWtUcUxxTzdyek1VWTlZN0ZhT3VwUkllckVJSmZWTFBjL0x6QmVLeUxMUzNyOUlKVWlxR2d5SHJaelpJazRTRktnakJreVFKZytFYXVyT09RMk9ha3R1UDd2SE5kOTdndUpqRzl5SUVoRmFvVkpOM2RPd3BUbVA4V3lkZlJHdWFJbVc3RFcwdDZKeGYvcHpCK3lqd0hVUmJhc1ovRXBxQTJYTWNIWXl4MWthVWd3dkkxdjdPV2tmdEE3MStTbTgxdzFxSGFRY3V4bGhzRS8xWWxCQU04NFJVYTdSdWY5WTIyL29XeFdEdHlTNE1ZRHd0dUhGbmwvbXNFczc3M3kyc2ZmVWpGU0RQdlhLR2QxNDlaSEpjQysvOFFwdTNDL1QrL0Y5NTl0T2YrZktsdno1eWJrMGZsZUo4Sm5qbTZvRGpxZVhlZmhrRm10c1NLN1J2b1BOeGd1VVdyTDAySmNmdCs2S3NBV05kTk0rc0l6UmNhY1dqa2VPOTIzTXlCRm9JdEd5SlFpYlFtT2hCSXFYQTJNaHJDRDYwVXFVQ1Z4empTZWx1UDhIaGFNN2xxMWNZajZZVXUrK2dROENJbW9mTUdKZTdXTzlJWkk0U0VkRWFGbHVZOXZCTElaRktvNU9FOWJWMW5yaHlpZjZnRHlyMkVGSUlndk00NjVBQ2V0MmN3Y29HcXJ2QnVBbnNIQjVRRmhQQUk1UkFKNW9rV1Z3ZThUVVFvaWxxbEdjTk5DN0M5WDByMXlKYkNIMWoyOEhId3ZqVTB4cWRoamJEQkVJSjVzQndlRFNLVzNqakVZdWRSVnVlV2lsWVdjL0p1M3JaT3hJOHRyRTBUUlFhWHV0bzFydWQ1ZEFsVFJLVWpBMjhzYWJkMmNUcnlscFAxY1N4OHRIeERPLzl2SFR1djJvQ040a1UzbzlHZ0R6L00xdmNlT05RV0J0a0NFdkllKy9pRXl2YmYrR3ZQdk8vVlJtZk9pNmRJTlZzbEladUlyaThtV01kM050ckYybWlEUUlSeXcrSVM2aFVhNFNBSkVuUUtpRXMrcEVROEQ1T2RXempLT1kxeHJxNFlkYUtuZjJHOXg0VmpJdUljazExdTIwT29iMFJQYlk5T0l1eUF3TFZlSWZ1eGxWTXNrTGV5ZWdOMW5qMHp2Znd6UXpWT0VaQlVuY0VkWmhpL0JSbm1raHRWZWx5RHlGYXhMTFNpcnpUNDl6Mk9iYTJOcEZKN0Y4UTdmYWJnR2tNVlYxVEZCVk5ZeGdPK2x3OGY0VnpXNWZCQzZiek1jWTMwWmV4RmFwR1JnWms5R2xjS01NRWpISHhybW5WRzIwVDRTa2lSQUtXaUZRTXZBdXRkMG9NTHVzOGJ1S1o3WlpNWnlYT2V5cmpGdG8rc1lrbjRKVmk4MHdYbFltbHcxZlRtUGFTQ21nRTYzbENvaU11TEV0MHZOUkN2RDRpMzZWZEJyZTluSlNDc2pZY2p3dDg0RTRaK0hzT2psb1Fvd0hjaHpwQS9zUmZmcEppMHJEL2NDNnQ5ZEhqVXRCWFdneit4Yi8rd3AvWnVqcjhLL1BDNVZwS1hLNVpFNEZzVnBOcXdWUG5leVJhYzN1M29pZ05Bb2YzanRaNVlPbE1HdytEV0pZS1Vra1dsbTRSMGhWdnVMS3hVZEpVUkUrTXhzUEQ0NFliK3pXam1XM2gzdkhmUlEydXNOVFlpamdtZ2JjVjFlU1F3WVZuT1pvWkxsMjZ5R1JTY256L2JiQVdVeGtPSGZINVRjbm82QkdqeVE3ellvUkVrYVk1V3FjUlZwNGtEQWVyYkovWlpqRHN4WUZBV3k2R2RncmxyV1UrTDdsMTV4N3Z2WHVEZzhNRHJET3NyNjF6N2VxelhMcjRESG5XWTE2TUthbzVpTWk2eEJPWmZUYnFkQ2tub0RRSUc3M1VuUXMwMWtVUnZoQm8ybzM1WWtkdGJad0l1bmFQWkE4c3h3OG5sSFVkKzQwVzFHaERYTFJhUUNTSzlhMU85UE51c1ZaTlkyZ2FTOU5BNnFEWFhneFNxUmdvSXU2NnZBOFlaMXZVUkt3YUZ2M2J3V2pLdkt3UlVueTFoRjhMTU9ORVh1akRuVUd1djdETzI2OGVpT200a1lRb0dnZjBQdmVMbDU3OXdwKzYvSCtkMVZ3d05wQ29nRmFlcVplc1RpcTA5eWd0dUhhMnc3bTFuUHNITlllVENBaU13U0dYOFBFMFRkdkpqWTk5eW1MeTFZTGpUcU5YclFzMFZVTlpOZ1RuNHFIMGt0Mng0ZWFqbWtkSERVWHRDUzBVUTRwb0txcFVOS1B4UWRCTURoQ3FRMzdtR2g3QitVdFh1UGZPYTVUVEE3cENVazhyOXF2SW43REdVYzFtVE1iN0hCM2VwNWlQa1RJaFN6dDB1bjNXMWpaWVgxdWwyOCtXdDM0a1NVWm5IaEU4WlZIeThORXVSNGNIN08vdE1CcFBtTTduTk5hd3VyTEd0U3ZQc3IxeG1hS2NNWjBmeGJKTHFPVWtTZ0MrZHZqS1lCc2JFUWEwTjcrSjBBOXYvVkwxd2pYeHo1eGJzQnc5N3NneTJwOVNWdzJGY1RUV3gxaHE3WXBySU90b2h1dlpVaHpjR050bUVJZXBRUm5RSWFCYjZvRlNDcDNvNWVjVzJrd1M1WnA4aThzTDdCMU84TTQxWHNyL3V2RGhkOXZzc1FpUUQrOGVKTzhsakE1S1JvZVY5SFlwMk5CWGlWejVDLy9yNS8vbHpscit5MFZsVmFZRldqc2tnVmtqMGJWbHpkb0lEd0cyMTFJdW4rbHdOTGNjVGd6QnQrWXlVc1NOZXpzYWxLMXJwMnVsT1lXVTZIWWpIMExVcFFvTDI0UVFhQnBIV1J1YTJrYUJhZytUdWVQQnNlSDJZY1hPdUdIZUJMU0VQSTJUbDdxS0IyZCt2TXZnekZYbVBtZDljNTBRRkFlM1hpY0VSdzdNSnhYVHhrVmNUV1B4ZGRUTUhZK09PRGg4eUdTeVQvQ2UxZFV0Vm9ZckRBYWQ1Zmg2OFRvV2xnU21ybm0wdThmT2d3ZlVkVVdXUnd1MjJXek9hSFJNVlJhYzJ6N1BpODk5bW42K1JqR2ZVWlJUckRVb0lmRFdZNTJMSll6enVMWVJkazNNRXJhSkNGNVRXMnp0S0l1SXdYSW1VRlVHVTFvNDlveU94aGhqS0kzSHRCcGtDL3FmQWZvcktiMlZORTdQdk1jMERYVmpxWnRBVTBiZGdGUkNyNVBSeVRza1NWUWhNOVpHVlE4aDM3ZkVsS0l0cjBZejhPRmhJL2ovTkNIY2Fia2l6WWQrVWFoVEZSdHo2MlU0bFQwKysrV0x6ejd6bWEyL0ZxVFlWa0tRcHdFdFBiYUpCL1RZQmJZREpLMk1ad0RXQnBxWHJnendYbkI3cjZKdUxJZzQ1bDJRU1VLSVBKTEZndEcxQ0dIdlBTNjRKYXBWaVhZT0p1S0hacnluYml4Vlk1Y2tLdzlNNnNERG80WjdSdzM3a3diclBGa1NSODVWTWFNcEpxeGVmSUhLQ3E1Y2Y0cEhkOTVoZXZBQUh3U3JXakIwbm5wU01pK2JlT08yTk5jUUxFVTVabWZuRHJzN2QxbFpPY1BGaStkUVNZVGRKVWtTOXdzdXdtendudEY0eXNNSDl6Rk5qV2pMTTYzamJxVW9TZzRPRHdnQkxweDdnZ3RiVDlIdnJET2JUNWhPanlJcTEzbHN1L0R6MW1QcVNCR3VxeHJmT0d4dHFhdUd1b3FRa3JvMGxHVkQweGlTV3VJbmxxUGpNY1o0U2grV1VOcGtBUUFWc0xxWm81UElaemZHTFB1ZXF2Q1kxbXNsRWRETjFGSjdZTUVFOVlTbDRyNFA3U1k5elRnY3paak5TNExnclRLRS84ckRJU2M2Vys1RERUWFJpU1M0SUx4bmtUMTYzWjRlL3NxLzh0Uy9OTmpxL3BJSWFLa0NRZ2FNQ2RSMW9Db0RNK09SRGphc1cyajY0R3dnVVpMTFozSTZuWVJIQnpWRmFmSE9zWkJTRUlDeFpya2JzY1l1SjE2THNteHhPNGZXZXlOTEU1UldlQkdGcXh2bktCdExZeHkrN1dtc2hiMko0YzJITThhRnA2Zzlzb1doSkhrWHZYcUJYcjlQa3ViY2YvdjdMVmZDazByQlVBbld0S1NMSUplU1RBa2FIMXB1ZkdBeVBlYmdjSThucmx4blkvTk1pOHdYZERvWnhwallMd21veTVvN2QrOHluVTFpNlNna09vMUx3VVh6UHhxUDJOdmJ4Vm5INVl0UDhzeVRyMkFheC9IUkhtVXh3elVHMjVqSSthak5qL3plTmhaVEczd3JUbWNhUTFuVkRNbVpqd29ta3puR0I2cFRrQWpWbmxLWlNGWTNXMDY4OC9oMlgxUFhqbUllY1BiazcyZXlIYWN2bE9UYjNaQm9pVzZKVmdnUlMrYWRvekhXT3VjRnYxRUYvaW14LzFnMDZPRkRIU0RiRi90TWpwdklKQlJ4Y3ZXWlg3cncvSXVmUC9kL1VrcHRSRWV3V0djR0gvQldVRmNlVTN0MkMwL2ZCcnF0YSsyQ3l5RVR5YVV6T1UrYzdYSTBzK3djMVZIUUlMaElrSEx4OENaSmd0WXQzSnRBbXFUdE5NcEhJSmlNQ2ljK1JQUE5iaHJCYzBwS1BHQ2NvektPZVdPcEdrZlZiblByR3ZabmxvY2p4OTZrWnYvQmJjNWRmcHFROXJsNDVTcUh1enZzMzM4SDR5S00yenFQQ0o2dUVxd293WHFpNktyNFBXeGJwb3pHUjB3bVkxNTQ5a1h5Ym8raXF1bDJjcVFVV0d2am9zNDVIdTdzc2IrNzA5YnJzZGRTV2k4TlBhV1VVUWpPR282UERuSFc4Y1NWNTdsdzdpbWM5VHg2OUpDNkttTkdOUlpyYkRSSWRSNXZMY0Y3bkQzNTg2WTJLQy9aU0FmczdCNVJWZ2JiWHQzcUZNSEhBcDJCcGpmVWJYbmwyaEd5WTFaWXF1S0VreE96VGlCTjJpYTl4UThsU2R5THhNR0xJazAwODZMaCtIaUdDR0ZtaGZqUEczaXpMYS9xandSWWNXMHpGOU5SclFna0NMcENpdDdQL3Zrbi9zS1o4LzAvbWFzZzB0UUxHK0tFeVptQXJRTlZGYUhWbzdsbDNqak9lSThtb0hXYzdDd3NuTmVIS2RmTzlUQU9kbzRiNnRvUld2MWJ1V2pnMnkyeGQ0RXNTL0hFaFZaTTcvRzVySThiM3JxeGdDRFhpbUdXTU9oa1NLVUlBU3JuYWRyYXZiS3VwYWg2cWdiMmp3dW1rekZQUHZzQzNjR1FOTy96enV2ZnBxcG1yZGFWYjVkeGJsbVc5SlJnTGRYa1dtSmFkdDNoMFJIRC9pclhyejFEWlJ6T0IxYUhQY3FxanZBUEFwUHBuQWYzN21PdGFTMFFPQWtRS2Q5bkRCUkNZRGFiTVI0ZGsrVTlybDk3aWZQbnJqS2RUSm1Pai9ET1JuTFVRaURjKzZXVDExSmdvblpzRHpad2RlRFIvbkZjK3JVblU1N2lZVGdCdllFbXlVNUd0Y0VIeXRveW00Wm8zWDJLTlpjclNiZVRSY0U1MWNMeVc4ZGdLUVJKaXpQYk9Sb3pMU3FrNE4wcThKODUyRyt6UjMwSzdzNkh1UWNSMWR6R3hXQ2dzN0hkM2Y3c243enlWenVkNUlrOEN3U2NtRlFCYThBMkFWTkJWYm1JMmFvZG95WXdWSUtlOVVqWkduTGFOdHNFR1BZMDE4OTE2V2FhaDZPRzhkemlUZVRUaEJBaWVMR0Z4VWZFYXJ2cldJNFZJd1pKdDZTcTJqaXF4a2FJZFlCK2xuQjIyS2ZmeWFPQ0N0RkhvN1NPeWpwS2EybXM0MkJ2ajdObnQzbnEyV2ZST3VlOU96dThjK005bWlDaVYwaExJNDVtb3EzWVhZaldER2Z5aE5Vc0pWV0IrZVNJeTllZVozMWprOUcwWUgxMXNBd3lLUVhPT3Q1OCswMUd4MGZMUFlGdThWK3gxRHFoVHdwb05Yc0R4WHpPZERKaGErc0NMNy84QlpUSzJObDlnTFZOZEx4dFZiOUYxTEhDdThoVFQyVEsrZUVHai9hT21jeWpZRjExNnFETHRsTldpYUE3aU56M0JmaXhhaHlUcWFkNXpPRkFBeDBOZVo2UzV4bUoxbTJKRmVIN0ViMGRDWEs3aDVOZ3JRdGVpUCt1aEY5dnMwZXhHTzkrNkNtM2RXRmxDRUdIRUlVYXJqeTFldTJwVDIzOXkya3ExNVh5b3JGUW14Wk8zY1Fnc1hYVWgvSW1VRGFlSXh2WURwNmszWEJIdG1IMDV6QTJacFp6YXhsWHQ3b0lCQWNUUTFIWjFub3Fqaml6Tk80ZGFJWFJJQzREbmZmMHVqMTZ2UjdlUjRLV0RWSDl2TFp4d2pVcGExUUliSFE3bkYwWnNOckpTSlRFK2tEdFBGZXVQY25udnZUemJHeHVzYnF5d3R0djMrRFc3ZHZjdlhlUHlnam1WdEtJRkJOa0ZFWXduaVlxRCtKRGJNNjJlaDFlT3JkR0Q4T0RVdlBjY3k5UlZOSGhiTkRMcWVvbUlvWUYzTGgxaXgrODlTcXorWlNxcnFJTXFVcFFXcU4xMG1ZUzhiNGdVU3BtbVBsc0JnaWVlZVlsTmpmT2NYQjR5SFI2dkVUd2h0Qk91VndnZU1uWndScEYwZkRnWUJRdnBUWjdMTUIwQzBwZnJ5L29kQ1BlelBtSW82b2JUelZ2UDRiSGVOZVpGR1JwWEJnbWlZN3dHaW1YRUJ3Q1RPWUZoNk9aVVBESUlQNmpCbTZjR3UvYWowU0E4SDR0ck83TFAzZmg1WTJMZzEvSlV0R0xLbnpSTHMyWUtMUGoydG1oTXo0dXJxeG5aZ0tOaFcyNTBNaGR3RGFpMUtoeG9FUmdwYU80c0ptVEpwS0RtYVVvNDVSTHREdUZoU2pFQXRObFhWeUNhWjJ5dGJuT3h0cUFZYjlMa3FZMDF1SkNCQ3RhSDZnYXk3U29tRlVOa3NCS053YUpFWm8vOWN0L2h1MHpGOW5kMmVmVjc3M0szVHQzdUhYN1BSN3Q3VkkxanNZRmpCTlltV0JRMUNTVVZsQTJBdU5iUUtUM3BGcVNKSnBYNyt6enpQT2ZvRDljWVZaVWJHMnNVdGQxeXdRRVl5enZ2UHMyUitORDVzV1U4ZmlZbzZNRGl0bVk0SDJVR2NwaWVVaWJNUmVDRjFvbldHc3B5NHJ0N1lzOC8vd3J6SXVhUjN1UENPMHdJNFI0QVhWa0J4a1U5L2VPNHdiK1ZGZThFTmdOUUpiQmNFMjEyc2loN2Q4ODVUeGdhbjVFWWtFQ0hSa3RxUmRaUTdYdy9PVVV5d2VPUmpPcXlvUWc1RDh1NEw5cGw0UHpCYnprOUROL0tBUGtDMy82Q3ZmZkd3c0VDVEdEZEYvNi9QbWY2MjkyZmlITFpHS3RqM0FHQzhaRUYyVG53TnZJWFREV1U1WVc3enpITnRBVnNDWUNpWTQzbGZkRUx3L1JXaE5vUVNkVGJLOW5iUFJTYklCWjRXZ2ExNVkxN1NLcS9ZcUxxRUJSR3c1R1V5YlRBaVVrL1R4amZkQmpwWmVoWlF3dUZ3SzFENVRPVVZRTjQ2S21xQnVzY3h6c0hmRHczaDMyZHgreXUvZVFoNC91Y3YvUmZXcHJhYnluc3JIUm41WTE4OXBHcEdxUUdDZXBuYWIwaXJrVFRCclBxSFRjZUhURVlHV041NTU3Z2VtOFl0Q1A0dEZsWGFOYTB0T05HemZZMjl1SmNvVGU0NXVLWWpKaWYvY2hCenNQbVUzR09HdElkRUtTcEcyZklwRlNoaVJKUlpibUVBUWJHMmQ0NGZsUE1wdVdQTnE1ai9jRzcwQllpZkthbmRHY3BoV1hYZ1RISW5zSUlOVXdXSlBvVkM1UHYzV2VxZ2lVczNZQXlRY0VpSkxrZVVMYWpxcVZpa2M4OW9leHVkODltdUs5ditlVS9MdVY4Kysyd2ZFajJlTkRHeUFYcnErd2MyY3FRd2pwSWtCZStkTDVYOTdleWorcmRCREJCYnlYR0JQTmJZSUhZMkt6SGpPSXB5cWoxcFR6TUdvODU3U2dyeU84TkRhQzdZM1hxcnNMS2VoMk5QMU1zZFpMNkdhU2FlV1lsWEVDRlVGN0RtdmRzaCtneFNHVnhqSXBTbzZtTTZabHhHMTF0R2JZU1ZudDV1UkpySlZOQ0pnV3J5VkNvSmlOT1I0ZGNuQzR4OUhva01sMEVqRmd2Ri9ReVllNGthOU1IQ01YMWxFNlQyVTlsWVZwQTZPNXcwZFNQQysvOGpNSW5WQVVOV2MyVmlpS2F2bWNSMGNqN3R4OEIrbnMrN1E2cGZmWXVtSjBmTWorem4zMmRoNHdtMDNLTk8vY3pmSmM2eVROdEZJaVNWSzZuUzZyd3lGbnR6ZTRjUDRLby9HVWV3L3VFR3FQYjJCU1J3MnhzRmcyUE5aNzVCSzZLNUlrRjFFcVNZQnhnWExtS1djc1dabVBseE1SeGgzSVVrV2Faa3UxdjdBWU1QakEwWGpHZEY2VlVxdi9iT3I4cjRYQTlOUnkwRDJlbHo2VUFUSTlycWxMcTRLUEpWYmEwU3VmK3ZuenZ6eGN5MTZ3TGpMM3JBTm5BcWFKd0VCbklyVEIrNGovTWRhM0cxM1B1SEtSZUpXcDltWS8wYSt5clQyYlh6clRSbCtQWVNlaG55dU1jeFNOaXh2ZHhtTmFNSjV4QzVwdGZOY3Q4ZmVOYzh3Ync3U3NLYXBJTFUya1pKQWw5Rk5OSjFIWTRHbDhpTGRwQ3d0ZkhOUnc2aUNkRHBUVHBVbnJrYkhNTXFXeGxNWlJPYy9oZU15VnkxZTRmUFVhbzFuQjJjMjEyTk0xY1RNZVBOeDQ1MjJxNmZoOUZNM1RCOUY1ejd5dTZ2M0QvVjg3T056OXUyVlZmVS9ycE03elRqZkw4bTZuMDVGbk50Zm9EVHBzcksvZ2pPTFd6VHNjSHg1VHVaUDMwbjlBY0tRQ3NyNGc2MHVNanhkR2JUenpTWWg5eDQ4SmpxVVlyMmlWTEZ0YXIxUXlsbHBTTXB1WDdCeE9na2YrZW9YNDl4dm5EampCWG4xMGxCWHIwaTZ5Y1FwMHVzTjA5YVhQYmYvSjRXcnlWR05ETkt2eDBRS3Nianh4bFJGVlNFU0F1dkxZRmd0a2phT3BMRHVUQ3VVRFozT04xQXYrTkV2dWcvVWhCbG9JQ0JrUnVyMU9RcitqNmFRZ2hjY0JwUk5VN21Sa3VYalhGNFd0Ty9WNzF6YnNzOW93cVJvYTQ1Q3RXSGJaM3JDYyt0VEVCL3ozOFMvNVkvNThnUitybXdhdEZaLzl6R2RwbFZrWkRyck1pM3FwYVhYNzltMGVQcmk3RExyVHBsczJYclg3RnY0TEQvOUpXWlgzOW5ZZjNyaDc1OFkzRHc1MnY5M3Y5YzF3dUhwcFkyTXR6L0tVWHIvTGJESmo5OUUrOXgvZGo4cnhwNEpqSVlrcGlRYzc2NFBxUlFuVDJnZWFCcW9wbUdwWmhYMWdhYlc4S0FJa0lwQWtpazZlb3hPOW5KN3RqV2ZNcXVaaEVQTC9NYmYyemJhMCtwSEoxWWMrUU5xTXVUVE1PWHQ1Y09hcGx6ZC90VC9RRjYyTk43ZzMwZFhKdHZONEZjQ2JLSDlaVmJaRmt2cVdGeEZMcnJ1SGMxYTBaTHViTEUrbWIwc2wzMmFTSlhXMmRaaktVMDJtTlZJRStxbkNTVWszOFNRNkxMT0hhK2Y1cHdXWGxrR3l5QzR0eTNDeEYxbGtpdFBCSlQ3Z052K2dnL0o0d1BEWWRycVl6L25FUzU5Z3VMckp0Q2c1ZTJhZHFxN3hMU3hoTko1eTg3MjM4ZGEweXZHdG5oSVVGcjdoNEQ4TThGOER1OEFVS0oyejVXaDBkSERuem8yM2xGUUhteHZybHpmT2JLeG1hVUk1bi9IZWU3ZTRkKzhtenByMzlSdUxNZzRCYVRjR2h5YzRHOWl2SzM2M25vRzNkUGw5SktvV3o1a0NpUlNrV1VLU3RnU3hFSmhYRmZ2amVlRzgvM3VGOTc4V1lOSUd5T205Ui9pb0JVZ0s1T2V1cnB4NzR2bjF2NWhtY3FNeGNaL2hUU1FxdGVaU2VCdndOc0t1bmZWWTQxdUw1MEJkVzVxcVlUYXIrT0dqS1JkWE9wenBKVzB2MGZJMUZ0STlyY3kvY1pFQTVVT2M4VXVwNkhWU2F1UHBhOGN3ZzlWTy9Ccm0wRTBnMFRIMXQvMHdpNmM5L1NHL1Q5YnZzZjhYUHVERzVMSEFFYWRLTWZFQlpZZ21hdnFtYWNMTG4vd1UwM25OMmtxUFRwNHpMNnNvMWVQZ3hzMzNtSTBPSVdZTTI4QjdEdjRqQi84QjhGMWcxSllueFNuOGtqZkcyRnUzM3IxejVzeUdlK2FaNXovVDZYWjBzSlliTjI3enpvMGZZbXl6K0hsQ3V6RVhYdUJGeWtqMk9IYUJXN2JodjIwcS90Tm16ai9DODNYZzNmYjd5UGEvK2VOblY1d2FhNlk2Qm9oc1FZa0JPQmpObU5mbXF6WDhYUmNEZS9aWVkvNkJEam9mQmVFNGtlWXFWMHIwYmN0c002MGZ1VjZPWGxzZ1hTdDk2YXhmbnJpbWp1QzVwamI0ZGoveFA3NTl5RXEyeldibkJLem9GdjRYeFAvYTFzK2pzWjdLZUx3a0NzNFI1WCtDRFdnUkVNS1Q2UmdrUGtSL0VlTURwWUhTbm56VmxtVnRIaDdySzA0SGlPUkhnMHJ5d2YvdWRLQ2NMdGVFOTd6eCtnK1lITzJUOTliWjJUL21pY3ZuVUVvUmdtWjdlNHVMbDY5eTkrNU5iNTNkcy9CUEhmdzN3RnVQQmNYcHhsYTJodzFBM2J0MzUvV2ltSTlYVmxlM2RKS1Fwbm91aEhnbndMcUFMZFhhdUh1b2crQzNoZURYcXptN3pyRG5MWS9hc2tjQTk0QWZBUDhZdUFEMGdUOHY0RThINkg3Z1JlTEJXWWZUTVJPWFZjT2thTjR6Z2YvRXdzTlRrSklmVzFwOVZBSWtJaUM4RHpJNDcxdkZBT2RpS1NSZEpQOEgzOHFKQ0pZUUNDVUM1YnpHVmkyd3JqWTQ2MUFDYmgzUCtYOS9mNGQvK2FVdHp2V1M1VVRMaGtoMld0Qk1qUXR0MlJVNUR5NElqa3ZIUmhaYVlXeE9LTEVoTHN5MGpDVkFSOGRtMVFZd0hob0g4em9HU20yaGFjV3UzV05aWnBGaDVJOHBzOEtwVHp3OFZuNmREcWpkUjQ5NDdkWHY4dmxmK0JjNEhNMjRjc25UNzNVWVR3ejlRWStubm5rK2ZPLzE3My90OEhEdkg0UVlHTHR0U1RJL3haZHdRc1F1TFlRZ1RwMnBkRzl2ZDJjOFByNTc3dnlGcmNGd1FLL1htM2Z5N244K0w2Wkh3QmJ3cklOVkQrOEZ6ei95RmJ1bkR1MmlNdldua3QrVUNBZnBBSGNESEFqNGk4Qm1TekE4S1RHbGFNMU5JL3puZUZwTWpROS96OEQzT0xFK2FBQXYzKytCOUlIOXpZYzVPTnJsajdjdWhLWnBSN25SVDZQTkdwNm8yMlE5M29aV2JpY0tLWnZHWXBvSXkyN3FwaTI3SUpHQisrTTVmLysxWGQ0N3FwYTFsV3IzeUM3RXNXUFRPTXJTUnRKTzQ2Z3JzOFJIZVVJcjZCd3hTQkhtSHJGSXhnZE1xMjd1MjM1Sm1CYVNyR0FsZ1lHT3Y4NVZiRjRmenlUdVZBL2pUbzFMVC9jc3AvdWR4eHY5dXFyNG5hOS9EVnZQa1ZKd2VEUmhPT2dqcEVJbkNkZXVQaEZlL3NUUHZONEd4N2c5V0l1UmFDMkVzRklxMSszMi9NcHcxUXNoVHJVcW1CczNiKzRmSFIyKzFqUTFVaW82blU3ZTcvWU44RzZBWHpmdzd4ajRtdzcrUFI4MzJXTmlYekE1OWV2cHFkOHYvbXdFM0FmK253SCtWb0R2dEMzaDh2Sll2TklRQWtWWitxbzJYMm5nTjhOSjltc0FLeU5qTUlTUGNBYUpMMEpMNVQzU05nSGJlS3hwdWRBdFAwRUdscVVXN2VqVUdvZDFJYkxibW9nd2JWMGY0OFRIdzYyRGduOVE3L0ducnEvemlYTTlGanVyaFF1VWJPV0JySEZNUzR2eGdVNGlFYlNJMDdEWXk0ZmxISjRGMjg1QjFjQTRTT2lsZEZjN2tDaTZ2WVEwMTYxb1NNRFphSnRtVGZ4WlRXV3dqYWN1RzJ3WnkwWFhjc1A5ajdsQnhBZVVYa29JYnQrOHlhMGI3M0wxbVUrd2Z6am03SmsxT25sR2FTMXJhNnZ5K2hOUHZ2TGQ3NjMvZDhlam80VW5lWFBxaGc5SmtnUmE1K0FRUWhCQytCQ0NBMHdJb1M1bTB4MXJiRTBuei9KdUY1MW0vbFNKVnB4cWtPM3BXY1VIOUFUaUZEeXJPZlZ6ZkEwWUIvanJ3TStLYU9BbEZrb21MbmpLeXJ4WnV2QWZPdGc1QlVZMFJORjNNaUNUTVBNZnZRQlpsdFhPaG1CdHZET3J4c2ZsWG92M2pxUFROb09ZcU9SUmxwYjUzRktWaHFacXNPM1NRclh1ZFdFaFBDMWdkMTd4OTEvYjVlWm9sVC94NUNvcnFhSUlqcnFKY0JYajR1NmpNcDdkbWFXMG52V2V4RFZSNjFjS0VlbXhMdUJDRkdrdXFvRHhBbm1tenhPZk9zdkdoUUdEMVE1SkprbFR1ZFFMaGtnUWFwb1l6STN4MUkwakdFOWRHS3BwemV5ZzRIaW5ZSEpRTXAvVTFLVmRvbWg1ckZsZnNQUUNVV20rbXMzYzE3Lyt0ZUxhVTg5M1IvTkd6ZVlsYXl0RHFyS2kxK3R3K2RLbFo1NTUrb1VyMy94blg3MnplRG9wWlZnOEFMSzh3OUhSd2ZMYkNTRmNHeVQyZUhSODF4Z3pUcEprYTNOOUxTZ2xGK1hOdkEyVStsUXlESThsZ2NjRDVIU3l0S2V5MWU4Q2o0QXZCM2daK0V3Z1hIYlcwUmgvZjFxN2Y3K0MxOXZ2dWVCNmVDMEk3VUNTdWYvb1pwQUFoTVo0Nnh4R3RkWUV6clI5UjhzVjl5M2pyakVPVXp2cU1sSkE2NnFocXBybGhybGwwRVlsazVSV0lBMENqcS9mUHVMUnBPYVhuMXBqTlpITWF4ZU9wdFZvVnRsUjJkaFFPZDhrVXMwcUc1NTlNQXY5U1JsN0RPTUR0WFBZVm1IUWVxZ2RuTDIyd291L2RJVkxUNi9SNlNwc2dFVEpwWklIb1hWcEVvb1EwaGJDRWkzY25QT3RDSUpET0krdExPUDlrc085a3YxSE13N3VUeGp2RjdncVprWEh5ZXVLbTJtQmdxa2pmUE90dDkrNk5UN2UvOU5aZi9QUy90R0U2MWZQbzdRaVpGbllXRnNiWExsODlhWHZmUGNiMzdEV3FsUDd5bGltMWRFNit2VG4wZVpKQzlpMzMzN3IwWmQrOWhkSFNwL2Y2blE3U1pxbXZWTUhlNUdWSGcrSUg2bDRya0c0dGNRRnYyOUt2bml1dThCLzRlQy9xd0t2S0J2K1ZST2NiUUwvY09MRFYwL3RPMm9pUWRIbldvYkNlT2EvWDNYeUVjZ2dJS1R3Rm9Gc09SSTJab01RUVBvUTE5ckVocjJxYkx6OVRTeXRuRFV0aXk1KzlNdU51WWdRaDlEYVY2RUN0MFl6L3VIYmhxMzFIb2xLYmg4OExQL2p5YXpaQ1FGcGZKQU8rYW5HdUJkc09JRm1mOUFqeVJUWFh6bkxoV3NyZEhPSlZBSWxKRm5yWGVGOERPWVREVndKSXNKbitpa2syak9aRytwYTBaRVpQakhrV3JCMnZzZmw1OWVaSHRmczNwM3c4TjBqRGgvTUtPY1JYSmxsQW1wSXBhS1RwODI4TWQ5L3RMUHo5djA3dDU1NDl1V3RDMGZIVTNuNWdxWFg2ekp1ak9nUGVzbUZjeGUvY1BueUUvL281czEzcHhHZTVSZEV2L0NYL3RKZjRoLyt3Mys0ZkYxcnE2dU14bU1mRlk1Q2VPdXROM2VLWW40elNaS24rNE8rVE5OVW53NEVJVVJJMDh6WGRmM2pwcXdBM1A3UnovenhGc3kwaDc4MDhFOG5ubGVERHpaRUNaL0YvNnRQN1czRHpQZy9XUG4rWVl1S3l4ZFd1ZnRnOUw0L0s2Wk5XWlYrbkFvWm5XTGJEWjFvc1NLaHRMRnpiQnp6ZVVNeHJXaUtCdGNZdkluam9pamhFeWROSis2MnB5MExJTXNrSWRVY0NZV3QzTGZ1SGRUZnhua0hxRzRudXpMTTFCY2JVM2FjRDcvbmEraXY1cHg5WW9pV0N5TWVRUkRRK0VBaUZZbUs2b1c2RmE3ekJMUUc0U0x4UGxHZ0I0cXBpbVVqTW1vQWF5M3BEV0J0TldWMW84UDVxeXM4dWp2bHdidEhqSGRtTk1hZ2N3RlZRRW01bXFmNjZteGF2dm9iLytRM3Z2YkVVOCs5WkVUbjdOSHhoSzNOTlNhVEdWa240OXk1N1d1ZmVQR1RMOXk4K2U3TnhWNVBDQ0hXMTllRnRUYWNHT2hBbnVjd0hvZTJ4SExqOFdSZUZQUGRzaWg5SjgvMTZzcnFabXp6aEFvaHlCQ0NjTTZKMzZkUGZyeTNDby9OSzhMSmdoOE5hQitiK2RQL2I5RTNlUlZuTnUvYjV2OWVqdy9WRkt2ZlQzbjExLzdQQzduOVphcmZ1VHNwcHBQbVR0MjB1NDUyNisxc29MR3hQekMxcFN3TVZkRlFGVTNzUFJxejlMb1RDTlJDT2JEbE1Dd0ZHTnJ5SzgwVVNaYWdFM1ZzU3Z0ZG5KOEJkYUkxVyt1RFgxUktQdWwvbitBQVdEM1RKZTlHeGIvR2hSYWo1YkV0akVVUUZWV2tGR1NwWnBnbkRGSk5KeEVnQXZNcU1DK2puWUtRSURPSnlpVkpJcEVpUXJ3SGc0VDFNMTNPUDduTzlVOWY0SVV2WGViQ0UrdGtnd1F2QTg1NWxXcjFYS3BsL3VvUGZ2RHU3cVA3NzNUeWhQM0RNVklLdXQwT1VtdFdoNE9WYzl2blhob01ocjEyTWFzaWRqR0lLMWV1dnY4d3FjVzdoUmRDV09kOXRiKy9kMmk5YzJ2cmEzSjliWDJiOTN1WEsydU4rSEVRa3QrdnRENDEwRnRta0ZQbFZIbHFYMk9rbEU0S0VYUWNTK1AvZ04vb1F4RWdXYXE1dUQ1QTFYRDFDLzh1U3N2VENWbUdKb2o2MkFoYnh3V2hDQ3lYZ28zMVZFQlJPNmJqa25KZTR4c0RMZ29ueUNnUmhTT1NsS3h2WWVzK1lMMWZndU9TUk5McFpLaFUrMkQ5OXlkN3hadUxEMlpyWStYcW9OdjUrZUJEOG51di8rUEF2cmVhUjdjbHdOSGFHYlRXQXJVTjJDQkpFa1UzMC9SU1RTZU5xdVZTeDJEUW1VUXJTU0xqZjlORWthWFJYVWtpU0dTQ1ZvbzhUVmdaWnB6WjZyTjZZWVZMejIxejhaa3RPbXM1ZGQwRVFqaVhhclZtcloxODQ1dS84elhobXRsa1hqS1p6bGxiR1NDVXB0ZnZpNjB6V3ovNzdEUFBYd1ZTSVVRYVFsQ3oyWXpCWVBqK1RGNFd3Y2YwdTJ5a0h6NjRmNk91NjNManpMcDQ1cG1uMXBWVW5UWkFzbE9COG9jSkVqNEE1cmJJSkxXSVgwYUFWVXI1MWVFd2JLNnRoWi8wRy96VVEwMHViQTZwRzB1V0tHcm54S3hzaEhOK0FlUHBBTjN0MWU2VkRabjhaUVBiSVZOeGhGckgwYTJySGZOWlRUR3RtVTlMeXFMRzFURkFGblRaVmh6OVpGZlFOck90eXpCQ1FyZVRrSFV6cE5iVDJWSDk5NDUzaXg4Q1FRb2hMcDNkK0hOYXlTL041d1ZsWllUN2NjSFJyc0V2UHJQQjl1VStRZ3FTVHVRc2VCUTJTSHlJbS9oK3F1aG9qVllzRlFJRFVZWnpJVnp0Q0sxV2ZQd2hsVlFvSVpjY2N1ZWo3cStTT3NyZ0tFbWFwM2dYbU94TVVVSWtOb1R2Tk5iZkxvcjU5Qk12dmZSYzJsM2R4bnV4dWJIS3ZLanczZ2M4dmRGbzlPNmJQM3o5clpOREdQeFh2L3FWOEhmLzduL0FkRG9Cb0N5cjB4ZXZBaEx2WFBXSkYxLyswdXI2eHRsRTZvRzE5dFk3Nzc1OVAwUjNXZmQ3d1R6K3NFTWJDU0dKVUphZ1d2UFdxcTRwcWlxVzN4K0ZBUG5WTHp6Zjhva0ZzN0poV2pXaU5rNzRFRlFiSExtSXNJUCtoZlgrSjlmVDlIL0YyR1N6V1MwYUdkTjkwemhNWXltbkZiTkpSVG12Y1kwaDJMZ1FWRklzZTQwVGFaZ0Y4Nno5MUNTa3FhVFh5WkNKeGxSaC8vakIvTDgyMWg4QURBZmR6VXZuenZ3VlkrejV1cTRwcWtiWXh6NERJU0h0Q0pTQ1hqL2p5VmUyR0d4MlNESUZpYVJ5RUZScmxpTUZtWklrUXBDb3lQUUxyYWkyOVM0S2JpT1dwV0NzTlFXeWxUZ0w3UkxadU1XaVVrVHAveER3VW9LSWxnOUhENlo0WTVGSzNxeU1lMzFlRk1WVDE2NTFMMXk4L01sNWJkWDJtVFdFRUJIRWFLMXFqSjIvOWZici82eXFxc1VXMmdraHZOYWFzaXpiSm4wRGE2M3czaS8yRm1veUdUZGJtMXVyZ2VSVEcyZk9yRjA2ZCtHbEs1Y3VqNzczNm5mZmN3dFI0dmRQcC81bzRCV0xkMG1JZjY0SS9La05rSi8veEJQYzJ4L3g4R0FpYW1PbGMxNkdGc2JRWm80K01BUTZGOWNHbnp3ejZQNUNLbVdTTjRHZEJ5T21SWFQyTGF2WWxGZnpHdHNZaEl1UWNpbkY4b0RSNmxxRmNHTEJ0aWl0SXBzd0lVMFRSS0k1M2ltYWFtSys0dVBzWFY0NXYvWHA5WlhCcjFhTnlhMHhvcHhYMkhCeWhTSmhzSm93SENaa1BjVm4vc1JWemw5ZkF5WFF1Y0lwQlRJYVRrbzhlUklQZUxBdWJ1T0RpeWFnSW5hWGl5QU9CQklwQ0Y2MFpXRXJGbEZaZkJNSXJhakNZdWdnWkpRaGNpR0tUeGRIbFNoSGhaUkNGcVgxdngxQ3FBVmg5c0lMTDc1czBCdmRMR1ZqZllYeFpDcVVRTXhuODI1UlZkKzljK2ZXbzBYNUpJVHdXWmFIdi9FMy9nWmYrY3B2czdheXdYUTJSaXh1R1JET09mSGVqZmR1Qmk5ZFk4S3o2NXNiMjVjdlhIcmhpYXZYSnUvZWVPZm12SmdiZmhUby9NK2RSdnhqQ0FNK1NnRnlhWE9GMzNuekxyT3lGbVZ0cFBNbldZTTR5T2tEdlFzYmcwdWZ1TEwxSnphSG5TLzFPOGsxcmJYTXN3UmxBKys4czgvdW95blZ2TVlaZ3pVUmF4VmNwTktxVmhSTnlDajVFd2l0NjlIQ1N5TGUvRW1pb25sT3FqRU5qUGJMUjk3NS96YkFWQ3ZWZWZyYWhUK25sWHJGR0NPOU5iaTZSSVpBMmxxTjliWTZuSDFpeU1wcWoyYy90YzIxbDg1Z2drQWxFaEpKMGxVTXNnUVJBbEpMT2pxU3RyU1NKRXFTS0IzTkxnUExxVm9nTEoyWm5BL1kya1pER1JjSXRTY1lHMUhJQW9MMUpDb0tybW1wa1VMR2lkbmNNcm8vQWlIdWxOYi9GdEE4ZVBSbytza1hYenk3Y2ViY0M4Wll1WDFtbGJxeFdHc0p4dWZUMmZ6K0cyKys5bG9Jb1drRHhKNC9meTRrU2NxYmI3N0JiRDdoMHRuTFZFMGx2UFBMbnFLcXErYk83UnR2elNmRnZicHhGODlzYjEyL2VQSGlwNTk3K3JsdU1aKzlldi9oL2VLUEk1UDhVVHgrS2dOa3Bac3pyeHBSTlZhY3lobzUwQVA2dzI2MjlZVm5MdnpTY3hjMi9uZmJxNzIvMU1uU0o1VldXaWZSSFVwcmhiZWUwYWhnUEdxbzV6WnlQMXIxaklYaGZkd09MZ3hsV2laaU85SU54T0JRa1VXRVJ6SGFyYXd0N0s4RitPMEFmbnR6N2Z6RnMyZitKUUhiUG5pQ014QU1lUUpaS2doNXd2VXZYbUw3NmpyYmwxWTQvOHdhVHFzbytKQklzbzRpelRUZFRKT21FcTJpS21BL1ZmUVNIZmNWV3BNb3ZTUXplUkUzOGpHRHhON0VGUTdSQUczUTBjSmNIQUlSWXBrcWlYNkptZ1RySEUxcE9iNHpJb1N3V3puLzZ5SEVMYk0xemV5NTUxNzhyQWxxdURyb01SajBtTTRLSkNoampOM1pmZml0dzZQREdTYytmbUZsWlNWc2JXM3g0TUVEdGplMk1kWlFOL1VDYUJPQVlLeXhEeDdkZVc5eWRQVEdkRnAxZlJBWHoyeHVmWEZqNDJ6di9vTjczeHlOajh2SE1zbkhBZkxqQXlTamlKbERuc29jUFNFWWZQS0pzeTkrNXRyWnY3YTkwdnZYbEJUUEdPdVNoZmhuOVBHVDdiaFJraW9aM2FBcWgya2lNSEJ4K0Z0WVZNUlR0WXpCQlhwV0NFaDBWQW4zSXRieHMyTkROVFd2aWNpSk9BVENsUXZiTDJ5dURmK2M5NjRqQkFobkVBSTZuUlN0RkwwclE1Nzg0Z1ZXMXpPNnF3bWlxM0d0NExOS0JXaUZ5aFJwS3NrVHdTRFRaRnF3a2lVTXM1eWtOY1hNZGJiRWlXblpsa3dDVXRsYTUwaUpTR0ptY0czUVM5V1dYa1NyWlJvSUZtb2ZKMzJ1dGh6Y0dlRWFjNzl4L0xvUFlTNkU4SWVIaDVOUGZ1SVRUdy9Yemp3TklXeWRXUmZ6ZVlsM2xycHM4cVB4NlBzM2JyNTdYd2hoUXdpMmFScDMrL2F0Y1AzNmRlN2N1Y1BHNmdiVzJRanRqNXFncHpNRHgrUEQzZHUzM3ZucWREeC9mVDR2MHFacStqdTdELzdwd2VIKzZQRy8rMU9COC90cERKQkh4N01Gc0hCQml1cGNQN2QrOGVXclc3KzZtcWYvb2pYdUNXT3NYRGdxTDh6cmc0MXpIU0dnbHlXc0QzcG9LZWdtYy9ZbUpWVVRoZVNVQnFkQjVDRGJ5VkNyenQvSy80Q1FzVEZ1R3FqbW5tRFlrMEw4ZlJQQzNRV2NxWk9ubDVXU1E2WGpCQ2trQ3RuTlNiUm1VdFdjKyt4WlZzOW15TnBqaEVRa0trSjRsY0NLU0NzZEtFRW5FYXltQ1YydHNONlFoT2k5bnFvTTUyUFg3VVA4U1pXUWFDdVJ3Wk9uQWg4a1RrZFJITzFCV05GT3dnSkNCS1l6aTY4Q01naGNEUUVaelRaOWlHVWVvdkt4WkRJaEJGOVdsWHZublRkLzYrekZKNzQ0bnVpMXVxN3A5N3ZVWlJsV1YxYzJ0ODlzdjVJa3liZU1NUW1ndlBleTIrMzZvNk9qQVBEdW5YZllXRm1uMSttSEVJS3Y2bktCMjFxMEJVblZWUFYzWC8zNmYvL2V1NjkvYlgxMUkzbDA4UERSajRPWi9NLzkrS25iZy95clAvOFMxbmtSVGhRbzAyNnFoODlkV1AvWHo2NFAveThxVGE4TEtXVkFMdDFRbytLM3BhcWEyR2UwdUNjdEJaMU96b1d0ZGE1dHIzS21sNUVLZ1ROUWx6Q2Z3bXdXcU9zV2V0NkNmYXlEb29UcEtEQWJCWHdkR09ya0lNdnltNHNQVVNzbFU2MHVLeW1Va2hMZG1tTjJPemxwa2pDODJPWHMwME02U1J3bEo1bEc2emhGa2kwQk8wa0V5SURTa0dxTEVrMXN2TnZ6bENTU05JazdrU3hOa0VvdXhTU0VoNklTZUNkYjF5U0pGTEhDVWlGZzZuYkxIZ0pOYVNrYnp6ekF2REVZYTNIR29XTTUxcHpTbGFpQitwLys5ai81OXRIQjdxdnpzdVo0TkdWbDJFZWxpZWozdStycWxTZCtibVBqekVaN2NTVWhCRm5YdFZqSTZ3QU1CdXZNaWlsNW5nV3Q5ZWxsWHRVdThFcWdtUlNUL2RzUGI5MnJtN281TmZMOU9FQityOGZHc0xzWXRTNlVYSkorbnA3ZjJ4Lzk0cnQzZGpvcVNVS24xMWt5eDd4dFllQW1MaTFFdS9uelFKWXFlbmxLSjg5WUhmYTV2TFhLNWZVZXE2bEVBOVpDV1VJeGczSVdnNllxb0poQ09RMDBGU2dmRzU5Y3NObE45TG4yUXhSWnFqdWRQRDBucFFxSlZrRUowRXFRWlFuV09GYXVEK2l2SkdDaU4wWFNlZ09tU3FDMUlORlJIVVhwYUJZam9yTTBpVzUxblZLRmt0QkpGVW03UkV6VEJLbDA5Q3lKSmlidEprU2NiTm5heFdjRWJVS3VKWjFCQWdxOGpHSjFUVzFwNWsxN2tZaFltWjFhc3UzdEh4dy91bi83V3pLNDR2Qm9pbEtLUE0vUmVjYnF5c3JWVno3NTZaY1hsNWNBRlVJUUJ3Y0h5eC9oOXYzM0tLdUNFQUtEL2lBb3FieVN5cC8rSG0ydzFBSnhHdW9lZnRxeXlFOWRnSHo3M1Flb2lDVlpMcHY2ZVhxMk1YN2o1dDBkWG52cmxwZ1dOWWxXcU5iU0xMUjZ1Tlo1WnZPSzJhekFHb3NTZ2w2cXliVkNTMG1hSkd5czlMbDBac2o1WWNhS2x1Z1F4NmV1QVZQR0w5ZkVQMU5FVG1jaUlBUTMxTUpmRUNLaXR2cmQvRnczenk1REVGSWl2TE5ScERtQVM2QjNOa01SOENhNkh1V3BJRk9DWEVkSlU5K3lIaXNyS0t4bmFnTktKMlNKSUUyaVhYUEF0UnoyZ0F1V3hubWtsTkVuVVNaVVZsSVlRZFV5RUtXTTJVVEk2RmdsazRnNDBFa01TT21qSjBoZE5walNZaG9YRUJTbnR0Qkx5TWJYdi82MXI1dHFkdmQ0T21jMG5qSWM5SkZLaGRXVllmL0phMDk5ZmpnYzlvR2tIYUtvaHc4Zi9zaG5PUnFQT0RvKzR2L3dtYjlLSW5VQXZCVFNTU0d0RU1JSUlZeVF3aWlsbkZMS0s2VVdHZWZqQVBseGoyKzhmWDlCVjEwRWlNNVRmUlpCSnFUZzRlNCszMzM5WGU3dEhpRzBKTTlUa2xTUnBoR3NCMUZDMDFqYkdrVjZaUEJrS2pyUEtpRVpkTHFjM1ZqbHlwa2hsMVk3YlBjeWhwa21hVFZxRTNFeU50TW55Qjh0Q1N0Q1JpeFNuaVpiU29vMVNmeEJmU3NnWFZVTk1oTnNiMllreHFPa1FNbklUMWZDazRoQXFsc2daVnZUS2NBRXljZzQ2aER3d3FPMEo5RkV3VTBSczR6enhKNUVwbFJCTTNlU2lRVkQ3RVdVMUNBVVBrU3dZN1JhaTZsV0s0SDAwZk12Qm9jTndUanZQWGZDQ1M5akFVTTNyNzcrZzl1M2JyejkxZUM5MnpzWTBlOTFTTkpNZEhzOXViVjU1b1hMRjYrZWJRY29pZmQrcVNQeHdnc3YvTWhuK25kLzkrKzNtRTdJMHl5a092R3BUcnhBZU8rOWQ4NTU1MXh3emkxb0poOEh5Tyt6QzEwc1FoV2dNeVV2U1NFUzFkNlFWVjF6Ky80T1A3ejFpSVB4RElFZ1VRcWxZeCtRcGduSlFuTFNXSlFJZEJKRnF1V3lGRW0wcHQrTGdYTHQzQWJQWE5qa3liT3JiUFl5Y2lXV0lLRkZ3dmMrU0d0Y1p4RzR2VzVuUFFSa25IRkZlTHNneW1QS05ERElKTnJGUGloUkFpVUNDUUVsQkRvUlpMbHFIWk1pWDEwaElVUXNsaEFTajRjV1loSVZWT0xHZlc0RjR5WXdkMkNGQkJYZmsrQWxaUk81N2NaQll5SWV6YmU3SFFFSUhZMWpiR1dBSUVLZ2FieTdGVUl3ajJXUkNpaGZmLzM3WHcyMkdoK041MHNYWEoybHJBeUhUenoxMUxNdm4rcERWQWhCNW5uT0cyKzh3ZU9IdkxJMXB2V2xEeUg4bmpXVWMrN2pBUG1EN1VLWE5FdFpObmJxUW5DeUZTTU9MV2ZpOEhqTTI3Y2Y4ZGFkSFE3R0JjN0ZRTWtUM1lMMU5KMDhYY3EvNUlraTBSSVJhRWxKMFpJc3l6SUcvUjdiNjZ2MGVsMXE5eU1pclNHRVlLMTE0L2FLazZsV0F4Kzg5QzFHYWdFdjlqNmcwemlPbFM0ZzJ3VmZvZ1JoTG1uRzhmOHBGWHVIcGxWeUYwS1Fxb1JPa3BHcUZDMFVCSStTR3VkaFdqVk1Dc2YrcE9Gd1ZsTlZEbUdoRXlRcVNGd1ZtRTA5NHhvbUJnb3JxS3pBV1VGd0F1OWpNRHJUTnU4K0JPLzhiZ2pjNTRSOGRMb1hhWDd3ZzFmZmZYVC96dGVheG5BMG50THZkNUZhTTF3WkRwNjRjdTBYenB6WlhtbEJoenFFSUlVUTh0LzhHLy9tNy9uSmxrMUZiV3BxMCtDRDU2Zjk4ZE9NNWhVdDNrZ05lL2xHdjVzcmlBWTJjc0c4Q3dGckxVZWpDZS9lZmNpRHZXT005NWdvSjRLV2lsVHJwWkdLRkpBcFJackVjaXdHVzJRYjB2TFd0UkE0WXJPdnhiSnJGQUZxNC8xZUM0WUsxanJqdlEvT091RzliL1dYNHJnNDYybEVpR2ppUklTbGN2elJqWnJEQnhOYzY0NnJaY1NEMWM3VE9JY0xua3luOUxNaGlwVGdVOWE2ejlOVVhYYjJ4K3dmVE5uYm4zSjBXREFmVjFRelF6R3p6R2FPMGdscUJQTTZNQzhDNWR3eHE2RXVBMVVUSjNNSWlTa3NNb0NycmZBKzNEYys3UEYrT3VzeVNBNlBSOGYzN3R6NGFsMFZrNzNERVZtVzB1dDI2WFE3Ykc1dXZuRDE2clh6UUNLRVNJUVEwbG9yYnQyK0pmZ0lQZlJQYjJ6RUxleEtKK3VhdW41UjU2bk9Pd25IbzNsc0FrUmNoQWtmb1JkMTdibjdjSitEb3dtRFFZK04xUjZxbThkYXZ6M3dDa1dlSzVSMTFNWVNoSXlhV1NHbTlnQ1VkWU1nR3RNVFRuNFNEN3ROV0pMYnZMRzJEaUVFWTJ6d1FZaVdSb2RXa3F5akVSNkVqVHdTbFlLWmV3NXZUQm0rb0FoQ2tMUkxTaHNudlZTTnhTUXB0WUNkNllSeFVUS2QxemovVmVyYVJDU0E5Y2dRRUU1Z2dvOVU0amJoUmwvRVdGSjU1L0VtWUJSNG9RbkdnZzE0TDJobUJ1czk5Ynp4enZtM2pBOGpUamplaXlYZGN1VDc5VzkrN1h2UHZmakttNk5KNy9QVGVjSEt5b0RwWkJJMk45YTNuN3IrOUdlLys5MS85clp6TGdNcTU1ejlqZC80RFY1NTVaV1BBK1QvWHc4UHBtNXNQWnZObzFtTDBoUjFROUlxZC90VFZabHpudkdrNEhoU3Nycy9abjIxejdtdFZYcWRoRHlQSElteU5uanZTTFdLQVNZbFdrZnlVbEZXbEdXTldzanp0RjBvVXBBUDgvRzBzcU9vQ0VFSTNtbHZuWkE2V3FrUkZvTFgwUTh4dUZhUlVVZThjSFhIVTQ4cmtzNGFlSlpiOGlCaVExMDNnV1BybUxnNVZWVzFyclVTNjR1b0ZHa0Qwa01pQkY1R0k1N0crVk4rNWUyeTFIazhBUktKOEpFVDd4MjR4dUZxUnpPdDhIaWF3b3ljQzI5Njd4Y2FWNmVGRTVhODhWdTM3K3c4dkhmcm4vYlh0ai81YU9jd2YvcjZKWkkwcGRQcDZDZXZQZlhGMWRYMWYzeDR1RDlmbEZtajBjalBaclB3VVFrUStkTWRHL2hKV2M4YzRRZk9Pak1aRmRqYTBlMTBxSkdVTHZienNsVWpVUXFrRWdnQ1JkbHdlK2VJNzc1OW43ZnY3SE00S2FpTUpkR1JTS1IxSkJzcGRZS1FyYXJveXdIUUlKQTZOdnBLU3phdnJBN1d0M3U5eGJ4ZUVGeFJSRTJwTE5HY0hGSEJmR3lpVjNncng0TVJUQjg0bEpRa2FSNmhIMG9RSlBRU2dmRFFWSUhqU2MyMHREUk9ZSzNBV1pBK01sSVh5UENGd1NYT0kzMlVIZkl0eWN1M01rZStjVWpuVWQ1SEgvVVFDRUpRSE14Ym1ySEROZjVoRS9qaEtVelZhZW4vMHpUVytxdGYrKzNmS1diak8vdkhFMEtBNGNwQTVKMWNySyt1WFgvbGs1KzZzcGhtdGMyNmNNN3hpNy80U3g4SHlCOXpsOTRLb0FjN2EreHJRc3A2QVYrZlRVb1NCR21hVUFkQjdWci9qeFpvU0l2RURRSG1kY1BOUjBkODY4MjdmUFBOTzd6NzRJREtlb2I5SG11clEvSXNReEE5QjR1cWp2S2lMWkF4WFhDdE93bjl6YnliNWFxM0NGenJ3OXdZNDIxcnA0eVFMZlpJSUlTa2lsb1FNUlBORmVXb1puV3RqOGdrUVFxVTlYUzFKSlV5U3ZiTHFPTlVXeFAxdkFnRUVmdVNFQ0w4UlVwUUtxQ0ZJNVdnWklTODY5WWUyWnBvWFMwaDZtVlpqL2ZSRjhTV2h2bFJnVmNDWjd3emxYdWo5bjczVkxid1FGQlNCdkUrSVhlYTkyNjhlKy9SL1Z0ZnIrdkc3UjBlaDdXMUZXU1MwQi8wejF5Nyt1VG4walR0dGhNdExZUVFtNXViNHVNTThzY1pIU2ZZSFF1NFVXRnVOUzU4MjRNbFJMKy9xbXpBT0ZLbHNGSlNJcU5jWjhzSlgrcE5oOFdvMGJFem12UGFuVjErNTgyN3ZIYnpFVWZUQXEwam5kVTdSMVUzTkNGNjd5WHRpRmhLd2VyWlBqS1J6dFoyWVlia2xKUzJtMmVoS211TXNVdGJzaEE4OWR4U2xORkl4M3Z3RThtNmxLejBOVElMcElsa1FSbzJMbG9xS0JubzVUbzY3Z0pDU1VMTDBVMVNUWkpGOUcrM28rbDNOU3Y5bEZRTE1objdtYVRseitQYkNWMEwydzgrWUsybkdsVk1KeVcxc1pqS0ZiVnp2eE5DV0tCeWw4eStKeTlkSU04eVRyMy9WVm5WeFp1dmYvODM1OVBSenFQZEk2R1ZvdFB0ME8xMjB1MHoyMSs2ZXZYNm1jWElGMUNqMFVpODl0cXIvTTIvK1RjLzdrSCt1R0trVmVremdKblg1aUJWMlgvYTYzU3UyYUs2c25DaXJSdUhzSjRrMDZTZGxOSTRqTEhvVmtQcU5MTi9vUThWZkdCVzFyejFZSitiTzBlc3IvUlk3M2R3eGxEVmJUbmlQSGs3S3VpdDVLeWVHNkNFUUVYQ3Z3T29yUnZsV2RJVVZkTXRxNW84VDBGSTZzYmc1NEppNXBBOVJlb0ZlbTRScGFHV2dvN01VRm9oRW5YaWtXRURuVlRTeVZvZFlDZm9KeG5XTjJSYTBjLzdUTW9qYW1Nd1Z1Q3RwcWMzZVRqZVkxN01jUjU4aUo0bjBld25uT3hBdk1kVmp0SCtGR01NS2xlWXhyMVdOdTcxVTFuQ0NTRkNsRGRLNkhRNlZFMFRRZ2pMTXVzNzMvbG5Oejd6aFY5NDlYaTRkcUZxREJzYmE4d21VN2EzdDY4Ky9lUXpUNy96emx2M2hCQkpDRUZaYTkxa01nbDVub2VQTThnZjhlTlhQL01NVDUzYldOaFMrQVg4WWRqck5HYzNCNnJieTJoTytXNVlIeWhLUTFrYU9scVNwSXBDQ3NwVFl4blArNEUrVVZrUWF1dDRjRGpoamJ0NzNOd2I0WnluSTZJZXJoVFJxcWgvcG92S0ZONzV1cW5zZkhIYmxyWFpNeTRjWm9sbVBpK3BqVU9xQkdzTnhhUms5S2lJUzhEU1Vkd2ZVNVIxaExsN2dVd2tzdTJCdEpKME9pbURUa0kvbGF4MFVqYUhYVFpYZXB4Yjc3TXgxR1JKUlQ4WEREdWFiZ1pLMTh6c0VRNkxsU0txeTdjd2ZkdkNTWFMwbHNVMW5xUDd4OHlPWmxFeFJZaWl0djUvcXAzYmF3Ky9qUkFRUWk5TGdFRFoyQWdGUG5uL20vRjBPcnJ6M2crL1ZsZmwrTkhPQWIxZWh5VExRci9mWDd0ODhjclA5M3E5ZmdpaHRUYjBNb1JBMDlpUFM2dy9yaEpMUy9tK2lVcmRORWVqVVRGUkNQSkVZc1NKV0d3REZOWnhQRzlvckVmTHFETmx4ZnM3ME1lOS9SWURaUjhDcnRYbVRZanE4QWdZbnNsSmh4cm5IZDc2bmVta1hnaVIyY2E0VVdQZENDR0NGSVR4ZUE0aUFnbHRZemw2VUZEWEh2L0lNSGs0cDdLV3VqRFU5MHJNVG9XYjIwakdVWUkwVitTSnBKTkFQeE9zZGhYcmd5NVBiRDNEU3JkRG9tcnl4TFBXRzNCKzVSemRGQndUZ3FoSUZTUmRGYlUwV3pkWGIzM0VseG5QWkhmSzZNRW9OdTVDRUJEM1MyUGU0dVR0aSs1d0lZTEszcjU1Q3lFRWlkS2hGYVIyaTdmNUsxLzlKOStZalE3ZmZMaDdoUGVCWHI4bnNqd1RseTlkK2ZUV21iTUxTWi9XTUVySWIzN3pHK0xqQVBsamVEeXh2WUtKMDZTbENkTzhjZnRGMWR3ZXpXdWtFUFNVd0l0VG56Qng5RGszbnNKRVh3ak5pVmJtYVk3eTR5S3dwMjNLUW9BZ0JMMjFsTTVhQ2xLRTRJT1p6WnJ2endzelhnUklVZFhqdWpHN1VnaVJhZ1hlMFZoUEVCcnJIVWNQWjB5T0dxb0RnMnNpQzdDY0Z4eCs5WUI3LytBaGQvN0xCOXovSDNZNC92NEllOUNRS0VtcUJZTU1WdktFVGlMcFpwcEJwMGVlYVFLZWNYbklwTnFMSUVZUlluRElRS0pERkhmd2NSeXNJallHTTI4bzl1ZjR4cUdrUUNwSmdBZVQvV0xodjJFQUo1VWs2NmZMaHEyWVQ3bDgrVEpabXJGNGE0VVE5Y09kUjNzUDc5MzhSbG1VOW1nMFlYdHJneVRQV1YwWmJuL3k1VTg5ZjdvUGNjNktiMzd6Ry94Yi85YUh1dy81cVdNVXZ2M3drSnU3bzRVejBBS1BsVFRXeWJWQloyVldtODhXenFlT2FCb3Z4U2s5eVZNcnh0UG1Fbzlia1hrK1dBZzJ5Z1pDMGs5WU9aT2p0Q2JKRXFFU09kN2ZtZituNDZQcVZudnpPaCtDV0IvMnRvZmQvRFBPQisyOXA2b2JncENVUllsem5qVFJkQnFGS1IyTnN4UzFpZU5nQy9XNG9kNXZtTitjTTdrOVkrVktuNVgxbEVRS3VsbUhFR3FNSGRQWWdzcVVXR2V3em1LY3dkZ1RnVHpUdEdhbHRjYzBuZ3pvcHdMYk9NWjdCYlA5T2Q0NkFwNnNteG9YK0o5MmI0KytSaXZtTEFSR2FlbUg2eDJPajRybGUvSGNzODh4R28ySXNxREx0MUFyUVhudHlXZCtSdXBzOCtMNU0weG1jMXhqMHFhMjd1YnQ5NzQ5bjgrS05xQmNudWUrYVdydTNyMzNjUWI1STkrbEN4QkNoQmI1WVFFenFacTNFT0xJQldnQ0ZDNmlvUG95YWdDZFB2eVArL3M5Ymlaek9tZ1dtVVMxMisxQlY2TmFxSGdRZ2FxeWJ4OGRsTytlTGpkQ0NFMVJtemQ4NERCUjBVVlZpUWhiMFRxbEttcU83ODBKQmp5dFpuQ3JQb0tNTDhxMEVQM3BvNEwzZnZNUjAzbERqV1ZtSnRoUVU5dUcydG5ZaExkQ3djRkh4UlVaSXFjbFlBbk9JYXhEK29BeGpxYnhsTE9HeWVFTVV6V0VFUHNTcE5nYkg1UmZKeXdOY0t5UTBnODJPanl1Q0dtdHBTaUxjRXEveWdETnE2OTkvL2FqQjNlL3ZuODRjdk9pWW0xdGhhelRFUnRyNjg5c2JteGRPTFVUa2ZQNVhIN2pHOTlrWmJqeWNZRDhVVC9pdUhiaDFCRVR3cnkyRDlPdS92WCthdFlnbzk1UjdWdjVlaEZSYytxeGdIaGNReC9lTHcvKy9xQ01lQ3FWUk1VVEh6eEJpdEFZLzhOaTFreE9sU1VHTUVlVFlrZm85RUdTeHVZMjBUcmFTTXZvMFQ0OUxxSXBqNEFzMFMxb01pckJhYVZhWXBoQUtjWGtWc0dOcng2eWMyUEMwY0dNc3FweFFpQlVpbGV4NTJwOGRNVTFKcUJEbjFUbUtOa0t5Ym1BclF6RnpIQndXSEcwUDZlWUZGaG42Q1pkOHJ4RFkveXJCdzhtNzUzcTdRSWhoR3JXaEtOSDAvZTlGOS82OXJlV3FGeHhhbGpTV0ZmY3VmWE9OK2ZUeWQ3dTNqSHJhNnVrZWNiRzV2cjVwNjQvOVltMnpGbzA2MElnUktLVGo4ZThmenpOK3NuU1VBaUM4Yjc4MUpmUHZmdnN5eHYyamU4ZnBxOTlZNWZ4UVlrRHFuQVNBTWxqWmRiakRySGlzUXl6TUo5b2ZDQ1ZBcW1qQUlMUUVxRlZZMHB6dzFsL09qZ0VZQTVIMDRONTFieTNPdWg4U211dHBJb2I5Y1lZcE5aVWphTnBZak9lYWswdkQ2UnR0dkZDVUJ1REowUWVod3ZjL3EwZDduOWQwRnZKR0d4bTlGWTZTQ1h3MGtQcVVRT0o2RXBDcGdsYUVFaVFVaUNDd3pjZVYzdHM1U2ptRmRPakFsTWF2QThrT3NNcU81K001bDgzbFQxTmJ3M2VCOHBwODRIdmY5TTBpNC9oZll2RHIzemx0MTU5N3NWUGZlZnVvek4vN3ZMRkxkSHQ5ZWdQaDUxclY2Ly8zTnJhK3Y5MEhHczFEVWpublQ4YUhZV1BBK1NQcWRJNjNVWUlnZGpjN2x3OWQ3bWZiMTdxaDJ2UHJvbnZmWFdIZDE0L3BKeWRmTWp1QTBxb0QzSjlQUjBvZ1ZpMlpWSWcyNG1RVERWSk56R2l0T1dwUTdWNE9nUE1IKzRkZlNWTHp2NkswTm1hZEpaRUp5UkpTcS9yd0ZxODk1SDlLQVM5TE1VNnQ0U3pLQ214MW1LQ0pVOFNza1NqaGNTTVBYdUhjM0RUT0pxVkFxMGxMZ1JJUUs5bzh2VTU2WHFHN1ZscUMxWHBLT2FHK2F4aGNsd3dQWmlSTnRGSGFGcU04S242NGVTZ2ZQTURFQXMvQ2JMQkFzMWtOaCsvODlZUHZySng3dkl2SG8ybS9lMnREYWJqTVpjdlhYN2gwb1hMbDQrUGovWVdMVjJyOUM3NEtSUmsrRkEyNlkrZDRkTWF2UDNCU3JiKzJTK2YvOVY4a0Y0UFFqQmNTY1dsYXl1c2IvVm9hazlkTzV6MXl5dVBEeWl2T1BWcGhjZWFldzEwYzhsZ28wZFFFdEZKNksxMnkvbWsrYzNEaDlNYm5MSTdYdndUSldSWVh4bDhQc0RacUNhaThkNjFFcCtDUWI0UWE0c1NvTXM5akpDa2JkbTFFQWNXUk1uVUpGR2tXZVNsNnpSdTZFVzB2OEkySGpOMUZMc2xzL3N6aWdjVjlxREJUQ3pUY2Nsa1VuSjBNQ2FyQkpmeUlUMlprbmlKYXFnekw1c1F1RmRaZDhTSlg0Yi9DVDhUQlNSMVhUVFBQZnZDcC9MdTROelZ5MmM1SGsyQzhDSWRqNmNQWDMvejFlOExJUmI5bXZ1d0JzZFBlNEFzVkUwV2duRzk1NS9kL01TTG45LzZWM3dxQjBJSVlXMFVtTzZ0Wkp5N3VzTDJsVFdTWEdOdHdEWVI2aUYrVEpCd2FnUzhhTm96b05kUEdXNnMwQWhITnN6cER2SmllbFQ5azZPSDA5dWNXQjh2Tm1DNmJreXp0dEkvbHlYSlo0eTFDQ21GVmhHNkVyd25PTWZlNFpTamFjbnh0R1JjTkJTbG9XZ2NSZFcwNEdDeEZNOVdVaUJsaEt5NEVDZFYxbmxzaTl3VkxXWkxxcWgwMHRVcGZ1WlFjMHZmQ0hwT01rUnphVGhrcFp2VHlSSjZhVW92U1ZjSG5mU1ZicGFhdlVueHJSRENUeG9nNHFSVkU4bDROR291WGJveUdLNXRmZmJNNXJwU1NvcGlYaWhuWGZqaE8yOSthejZmVGZsUkdQM0hBZkpIbUQwV2lvcGRvUGZVK2ExclAvOXpsLytOL3NYa2VTZUZwRlZmdHpZcW03Z0FLdGNNTjd1c25PbVNwUXBob2dsbWFIbXlRWHh3ZlNFWFh3STZRNDNQQXpMVGRJZGQwazRpaXVQeSt3Y1Bwejg4dFZ4YmVvTzNUTHBKbnFYUFN5blBlTytsRHlDbFFpdUJyV3VzaVNCR2F4Mk50ZFRHVWxRTjA3Sm1XallVdFkwK0pvM0YrV2hJRTlyZ1FBaVVraWd0RWVMRXpEbEpvaW84eEt3bHBBUWZ5S1Zta0dUTFY2ZUVJTkVxSXBlbDBGVmo3ejhjemI4YVFpZzRaY2o1aDhraXE4TkJPSHZoNnVjR2crSGFwWXZiak1ZVGd2V2RuZDJkTis3ZXUzMzc5SzdsNHdENTR5bXRjbUN3dVRiWSt2SXIxLzZOYzgvMC9vemFFTm80bG53TFp5TXcwUVV3RnFyR2c1QWtXcEpwZ1phV0xBOTBPcG84a1VnWkQ2Qm9SOG1jYXU2VkZ2VFhFdEk4SWNsU2REY2x6WlFlM1o4MG8vM2lteUh1RHQ1bjVRV0lhVkhPSnZQaVZYQXVTZVZUQXBHR0ZoTnJxd3J2SXhOeWNiaVhCejBzbHBNQzZ3THpxbVpXTm94bk1YQ3F4bExWTWFBcTQ1YUs5RkZvRzR5MTFIVVRSYXR0VkgvM2VJeVBGN2FXSjh4TFk1MjR0WE8wZC90Zy9QK2FHM3VIeHh4ci80QUgrTFJocnQ3WmVWUS85K3h6VzNsdjlhVXJGN2RsWXd5bWFUcnpXWEg4dlZkLzl6dTgzL2Y4UXhrZytxYzBRQlppMVYyZys3T3ZYUCtWbFdIeUsvU0RRc3JseHRpN1FQVGZqRTIxcDBYQkJvK1VDdHNxTjJsaWswd0k1RFlTaUx3RlkzMzBBQWxSWmlmSkZEcFhDQlViWTBuRU5DVjU4cWxVeXljcTZ4K2Nxc3hPaTYzTlowVjEwOWptUDE3ZGtoZGw1bjU1TnJFb0U2SlpUNVIxWUdGWDVyekRCNDlvUFQxaTMrS1hRd1VYQW1WdG1KY04zcmZLS0ZwR2t4d1ZKWXlpbW1SQWlrQW5TMXNKMWJBczFiejM3V1JETFkyQ3RsWjc1cUEwaHJMSjJzdm5ORm5xRDlKSXY2OVpyNXRtOXNZUHZ2Yzc1eTQ5K1dmM0RrWmJ3K0dBNDI1SFhMeHc0WlVucmo1NTd1YXRkeWZ0NTFoL1dCdDE5Vk1hSE12UzZzV25Majc5L05Vei8wZWQrTXU5NndsV2dUY2lpZys0Z0xFeFFJd0wxRTBFN1ZrWHZjdkwwa1E3QU90UVFrU2VlR3R4SUZSVU5NeHpSWkpEMXBXa0hZM1NHcDBvMEFxZEtQcTlOQVR2eGVIRDZiY2E0OS9sUkJySFBiYUhGTTRGbDNlVDQvV3ozZWRJdzRhWk43akt4cEtwUlJNdUxOYWtVRWlpaG02TTNaWVVKWWpNeVphTEVrSmMycm5nYWF4bFZsU01pem5UZWNueHZHQmVOOHdyUzFIYlphL2lRMERMT0U2T0pxQVJvOVhOay82Z2syNlV0WDF2VnBzamZyd3YrUjkwc3BoTUo2UDZtYWRmZUc2NHRuSDk2dVd6WVR5ZUNoRkM3K0R3NE0zM2JyenpuaERpZlh5VGp3UGtqNll4ejREZTFzYnd6TTkvK3FtL3FyejdzczZEenA5SU1CNWNIWjFzdlk5bzN1am5FYjBJR3hPd0xtTGR2ZkZJRDk0NlpFdmVYdkJGcEloMlpRdUFuMmdGMTdJa1JXZ1YvVHUwb3R2Tm1FOXF2Mzl2OG0xai9adWM0Q1B0WXdFU0FERTZya1pTeTJKMW8vdWltb1YrUFRjSUVaYXN4WVZtcEd5RkcwUkxXaEZ0dlNlVk9yRTM4QjRwRjJXWWIwdXpFS1Y3WElQM2poQWt6bmlxeGpBckd5WkZ6YVNzbUZlV3NySEw5eWQrZnlrNmlicTQyc3N2Vk5iL1lGcldrOGVDNUNlZGFPbXlxc0w2MnBvK2MvYml6MTI2ZUM1cGVmcjY4T0JnOHYzWHZ2dXRVKy9YVDZXMDZJY3BRSmJaUXdoNlFQZGYrTG1YL3N5RnplRmZLNmV6ZnBJSnNnc2FpOERiUUdnRHhQc284WThVbU5yVE5DNytQb0JzRDRhUFRLcW9Ya0tJSllzNDhRVVJNaXFjS0NYUmFZcHV1UnBabGpMb2Q4WGh6a1NVUi9XZDJ2cHZoeEFXbzE2N2ZJckhYc040VkIza1hzcU9rNThVSHJVb3JYeUkwcCtodFlnTy90VFlWNmtvTEtGVUxDR2RmOSt6V3VjUklzVEFDdEhlUUFsTm9wTG9zOWlLeElYMkVvaURnSnA1MVZBMmx0cUdHRERPaTFUSmN5dWQ3S0x6L3UxeDJSdzhGaURoSjdqTUZKQUU3OHlsSzAvK3pNYm01dmJaN1ExeGZEd1d1TkQ1NFRzLy9OWjRNam84MWF4LzZMS0krbW5OSHR1YksyZS85TXBULzN0cjdETlZXUVd0cEVnMk5ENERWMGNIVytmam9ZdVRVa2xWTzZxbWhic1RVTFNDQ0xYQldZOElVZDVuYWJPMmNKV1ZFcTAxU2l1a2pwbkVBM21Xa21qSjRiMlJkSE16cTV6L0o5NkhHZEFJZ2QxY0hYcEEySlBESEY5RFFQV0Yza3kxL2h4QzVNRjdzY2dRcmpVKzlON0hiYjJVeS9MY3Qxd09RZHNEU1JtZGJOc1NUU3dNUDF1QjY0V1BlZ2lSSnF5RWpCYldiU3V0MjZDVFF1STkxTVl4SzJ2R3Mwb2FZNjk0Ni9OcGJiN2g0c2ozSjIybUYyV1dIay9HOXZ6NXkydG56cHg3NWZxMVMzcFdsSGhydTVQSjlON2I3N3oxNW9kNW1pVi95akxJWW5xVnZQRGsrUmM2V2ZKY1dkWFVqUlYxNGJEVHNEVDRjRzJ2NFh6YmN6amYrbWRJTWlVWTV0RjNRNmVLdEpPU1pnbGFxK1ZOSGhEdFpDa2VNcWxrRkw0bXN2UGlweDhZSDArWkhCWklJVktCMEtmV0ptSmUxbUo3YlJpa0ZLZmhYUjRJTzlQaTdlT2krdGJPZUJaMjV6VjcwNUo1N1JCU1JiYUVhQXVmbGtRZng5RStmc0hpTCtDOXhYbmJUcjlpb0lUZ1kwK0Z3RHNYU3kwZmx0ckFVUThzTnZTSlRscVllMERJZURsNDc2bWFSdFJOYzFWTE1UajFtbjZTeDZKWnI1MXoxV3ZmLzlaWDc5NjdkL2Q0TkdGamZaVnV2NTg5ZWUycHo2ME1WemM0NFlrby9uQnV0di9MRFpBMFRkOTNHeTAyNTljdWJuMWVDdGFxcXFheEZtc2M5WjdGMjhYWkNUVFcweGkvNUg3ckpONnUxa2F0V3lzaXJpckxOWG1tbDJWTU5IWnNoUkhhM21DaEhPSmFsUkNGd0JyTHdhTVo5YXhCS3BVbldpMll1RElFUkZIVkhJMW43ZTMrL2diMjhwbmhtYXRuQnBjSG1aTHplY1grdk9idXVPRG04Wno3MDVyRDJqSnQ0dmkyTVZINFdyUkJlN3BwRDRBeFpqbjVha3pUcXFWSWxGSXhvN1QraWhIQ0V0b3AxZ21jWlFIQzlLMkdtRkF4U0l4MTA4WjU4NGM0dUQvaVVYN2p2WGR1UDdoMzk5djNIdXo2YnJkRHA5Zmw4cVZMeno3N3pQUFhPT0dKTE05YnY5Ly9PRUQrd0trajFoL0xtdmJLK1kweksvM3U4d0dobXNZU2ZNQjRUL0dvd2U4NVhEaVI5TFF1QnNvQ3JaMjB0Z0RHeGNtbFVCSFNrZVVaZVphM0I2cUZkclRqVWluanFqQlJTV3V4SEorN21GWWNQNXpHVWszS1ZFclJPYlZYRkFDMXNTSVFSR2gxaElGa3BaZjNyMjZ1L0dXdDVITnJMWFYyTGRka0NweDF6Q3JEL3JUaS9xVGc5dkdjdStPQ25Ybk5ZVkZ6UEN1b0dyTVFjR3dIQ1BGblhFNjJmSWhJNHhZanN4Q25DTjYvTHlHTHRrSHkvZ1NKRmdQUDQ1d0xDUEhJbmFBQ2Z0TEg2UUJwakRXejExLzd6ajk1OEdEbk9DQVlEQWVzcnE5dlBmdlVzNThUUWl5ODBUVWdoUkFpdnVjZjcwSCtNRDJJZnZySzJTdDVsbHczMW9FUVZJMUZhOFZrV3BQZTBlaG5OTzdVYXNzYWozTlJnVVMwczFGalBLRVZndFpaRXBHSXVhQnVtbGc4MlRoK0ZTRldSVW9tNURxbjlsVTB4N1NPdzUwNTljelFUUk9Va3NOdWxtNU9pMHFlRHBLcU1lR1VxVzBLcEpmV0I2K1l4bnltTm8wZ3dOcEtqMTR2cDJvYXF0cGlYS0F4anNZNGF1OHgxbFBaaGxIVmJyNVZUU2RSZEhSMHYxVWhSREZ1RVdJVDN3YXg5NjZkYUxuV1JLZk5LREptRkU1bERpRVcvOGEzL3o0NEYveHVDSDlvS01qcExOSUF6WnR2dnZiNnJaczNmdmY0RTgvOXlZMk5WWTRPRHRYMTYwLyt3dmx6Ri8vaGc0ZjNwbTBXYVlRUWZqYWI4V0hvUi81bkQrUDJKaEcwWkQ0aDBPdkQvak9wMXF2V2VkSXN3emdmaVVEV2N2aGdqcm50Y0Uzc1JZS05YSWpHUk5ja1p6M1dSM0tTYzNITUcwVEFhd2c2a0dVSlNzZXNraVpSREZ0SlFRaVd4cFd0VnEvamNIZk9hSzlDU1lsT05BS3htaWJKcFRZUWxuMUllSC92bEc2djlMWnlHZjdDNGZGMG82d2kyU240Z0phYWJwYXhOdWh5ZG0zQXBUT3JYTmxlNWVybWdFdHJQYzROY2xZelRTSUV4bHBHUmMyalNjbWQ0NExibzVMYngzTWVqRXNPQ3NPb2FHSnBabDBjVzUrU1Y0VjJqeUpsTlBpMER1ZHNGSlVMY1RybXJNUDZZR29iOWlIODgweVhsbGxFQ05ITTU5UFJ6ZmZlL3NxdDIvZkticmNqK3NNQlcxdmJsNjVmZStyWkQrcEQvdmJmL3RzZlo1RGY3MkdNV1NMUEErZ3MwV21lSjllRkV0bzZGNlFVUWdoQjJWaVVGSlRUQ3Z1T1o3UHBJellWZG1IZjdBS05kT0Ria2lJRXRCSm9LeEhFZmlTb2dFNFZtVTlhSUdIQUJHSjk3Mk1XTWo0d09hNlpIMXVTMEJLZEpDQkVvb1U4czVDMjRmMHMzc1htUDFuckpDK1ZaZlhwc3FpRWxJbzBTeGRxSWpHcVZMdXBiOTE0aFl5bW42TFZDYTRiUTJNTXhqcHE0MklndUdpQlVEblBjV1hpaGs2SzViZzZFWUZNT1RLbjZLUnBPK0dLM3UrK0xhbENxMEp2bllVZ2FPK1ErZ1AyT1QvcHd3TzJCVC9Xcjc3Nm5XOS8rak9mZStPcHA2NStabVYxR0lhcks5Mm5yai8xMmE5ODdiZCttMmk5cGdHamxQcFE3RVIrV2txc3BkWEJtZlhoNnVwSzk1TDNIcVVVV1pxaGs0VFpkRTQzVHpIZWNUQXBLTisyckIvMzZHNHF5aXpnaE1jRkVRa1FIcnl4Y1JGSXRCcVFTcUJUaVVBaFE0STFsaVk0a0tMZFlBdktzbUY4YktsbkR1MmpJbnVFaUVpRUVJbFU2cEpXS2pYV25tYnRoa1dBRExwWlR4RytWSmYxaW5NK0NyYlZEVXJGWmpsNG90SjhWQmRwQTZRRkl5cU5raEdoMjhuaUlmZXRldjBKeU5GUk5vN0tlYXdQMURhY0VwN3d5TXFTU2tNcW85VmJsbWk2V1VxYWFJSjNXR3VSVXNZTTRweHhJU3hrak53L1I1bkY2VjdrN3QyYkQyN2RlUGQzZGw1ODdwUFhucmljZEhwZDhlVDFKejkxK2RMVkMzZnYzUjR0c3UvNit2ckhQY2dmc0VFL2ZRdUxsVUYzSTgvU0M4NEZvYVFrelZKNnZTNkh4eE9vVGJ5eVBCeE5DOGF6Z3ZXRERwMlZsSFNZVVBmQXlkQjZpZ3VvQTA0NU5GSGNRU2xKVUFMWEx0Ujg2L0RuaktlYU9ZcXB3emJ0QUVDMFM2SVduaExMUWJHbWxjeU1mWCtqdmdqdVlaWnNtc2ErT0M5dDJ4NmZESVo4cTR0cUY1eVFFRkF0ekVUSnVIOVoyS2RGVGtpS2xQR0NTSk5BSHVJRUtqaFBiVXljN0ZsUDdUeVZkWEhVN1dPV0tkdmpLaXFMbmplUmR4S1hMM1F5NVhWZ3Y3SCtvWWQ5L2ptOXlTTncwaThwdVVEMTFhLzk1bTk5Nll0Zi9OTVhMNXg5SmxHU0xPdGVmT25GVHo1Lzk5N3ROeGZ2VmV0cEdENE9rSjlzNlVTYTZKNVdxaC85UEFSS1NySThKODh6WnJPQ1RwWkdrS0gzMU5ZeTNhMUk5aVY1bGlBN0tla2dKUnRxa2tSZ2Jjd3NXa3QwRUhIcDV0dXhqeFdFTWpBZlcrWXpTMVc2cGN0dHE2SzQvUHk4ajlBVUplWFpicDZ0bDNYemdCOWw4R0tNM1J4YmQzN2VTdStJMXA1TnV0TXZNcHhDRXNmbmQ4S2h2SThMUU9MaVQydERrbXAwa2tUQW9vcndkcGtva2tSalhic3phZjNJUTRoMkVFMWJsdFUyd2t5TUQ1Uk5zNXp5ell3VFdhSmZDMTc4QStQY2ZmNDV2Y21sbE1FNXZ3UXdDaUhxZS9mdTNMeDE4OTJ2bjl2ZWVtbzhuWEh2d2M1UXllekowOThqaE1EZitUdC81K01NOGdkcDBwMXp5ejVFSzVrcUlWWGNjcXVvK2FRMXF5c3J6R1lsczNsRjNzbnh6bE5IcENKZU9PWlZqVHVHVE90NHdCS0owZ3VIV0pZTnJXMGNkZDFRVkphNmNwU05QUkh3WGM2YVc3VjBJTGhBcjV1aXRZNzdiU0VVN3dmc0xSK3p5Z2hDVU0zanFTV2NOQ3ludTNzVkJVNFFoUGJYc1hjQWNOWmdqQ0dFa2hCaTlsdU1lNVdLdllXVUVwMG1DQi81SVprUURMdWRPR2lJUG84MDFsRmJROW51WEl3TEtDbWY5VnFGdWl6THgwcWxuL2dScDRjS0g3RXhoa0RWTkkzODFqZS84ZDhFcDc1WU51YVpCM2Z2VmFQRGczdnR0R3NaakgvcmIvMHQvdTEvKzkvK09FQitra3pTTk5iNkVIeG9OOHdCMEVxU1pDa2JHMnM4ZUxoTE15M0kwbGl6THh5aXBGUUlIQzQ0ckRGVVRZVERPK3ZhV3Q1SHBxRUxpemJsUjA1R05PWnBFYlJ4WUUrV3BXamRMdU1JdFl1TE5mRUI0MDQ4NFREQUxROHZ0NFpXNytQSGh3OUlPNHZnRWE0MVB4U0xZQXBJZS9MdlRDdUdSMXYrTGNsZXJUYVlsSkdxbTZRdHhUZjRsbXlsR1dRWks1MDh5Zy9GNmRmNW9yRi9va1I4MzUrNjFQOHdnZktsTC8wUzMvNzIxMExUdUFDNFFLZ0IrVnRmK2MzdjcrMGQvVHY5YnYvUGVXdHU3aDN1L3ZmOC85bzcweDdKcnJPTy81NXo3cjIxOVRMZE01NnhUU1k0bVRna0lnc1FDUkVKeEFmZ08vQWwrQnJBT3paRlNFamhGUkJGa1ZoZUlCR0VreGppRURDVHhJb2R4K1BKYkQzVGV5MjM3dGtlWHB4YjNiZHJlcExZRG5ZUHJqTXExZTJxYnZXZDZ2TS96LzcvZHlZTUwxMjY5RlMwbkh6Z0FPa0lQa3JlSnhvVlNjWUl0S2RncjllamJBSzl3WkR0SzVmWmViaUhPazlsTFFsQlRTdk9hUzJ4clcvUWNVRzAxYzlZNkhXYzUveWU1RzViOEdUNlRVdGg3VW1HeXhibFNmL3RPYldBMUlUMDRNcm02QysyK3VVZlBEb1l2emgyOGN3MDB2THZqVHcrSzM4Q21LVnJQZk9aZGU0NTVaZ0x6VnJ4dHZIdGFPNXBnVkRJMXRSWXliWEh3dGdVOUZmS3dvNmFFSlQzMVA2aG1mMGtGMW9XTlJGVU5kNTg3YnYvV0dLLzdva0xiZlFGRTJ4cUNlbFdBUGs1QUhMbWo5TXJ5NktxU3VOY3BxeFo1UFo3WlVIb1ZmVDdRNTU1UnRqYjNhTnVQRlhaQ29HMFlYRm93WURJaWQ4ZGt0TDJDRDcyV0k2MkU3bUJzREpDWVNXM2JFUWh4a2lFMmtjL1gvTGJGMEZ1c05iVU42NXVQdDh6UEdlU1U3ZGZ5elRxWXlrZldkcjBaM2lDbDk2WGMzNW1rVFpMUzhVWUV0aVVMWkdZOW50VGkxOGZ6d0JUalJGVEZzSjc1SmYrNWplL3prbHZ6R2wvMXVLanRKNDQ3eHdpaTlaNm5VNm5LNEM4dTZ3SVJrUk1VWlM1aGFSdFFyVFcwdXRWREFlUkVCTWJtNWVvNS9NY1FmdjVhU2VzNUpQVG1PeXVoRmJBTHpmckNTR3JMdWRtS2oxTEppY2lsTVpnRi9KdUtlV2dQaVc4RDVBNERpSFY1N2dqQ1FoR3BMbTljM0N0TUtxaXFtMlNhaUVoS09jQlpmbGFsc0M3REtMRjkzU0hLL1NjbEZwS3ArRG5QR0NxeGhDaWZ3LzFqOGROMnVudGhBNSt1NitmMUZ1TU1YclI0NCtMbU1VU1k4UldoU0dJVXVVV0QxempjVDRmVEVXcmIxNldKVlhkd3psUGpEM2N2TVkzVFdzcEZ1S2Nnb3JGRnBuOXZEUUY0aHhoVVlIdUFNTUNoWUFoWmVWejFUWnpaVnNSbXBDQWV6NmM0Y2c2VWNJQ25BL1JQaml1dnlUQ3R3MzhEc3FuREh3VTJGSllpR1hJZWF5UFhhQnd6dnV5dE5tWDBabk9BZHl5OVpFT21Dd2tUY254aTUzUmVKSTNlZWEyTmErVkJYazNNY2o2YUxCWldHdnp6SGJPM2xTOUhtc2lHR1B4UGpLckhkN0hsbHVxSkJoRFNsbWJ0cWdVYXczenBnRVhzRVZCTTNjazUvQ053L2x3SW1adlcyQ1k3a2tvZWRaN01ZK0JRSXBKU2RJRUg5NklLVFU4WG5sT2dHL2xvbStqN0VSNEdiZ3M4REdCand0OEJ2aGw0RVVEYTlyNTdGUEhtOUtmQWhBOXgvVTZ6eHJ4Qkt0elNodEJpS28zQXh6emYwUEw4ek90VXIvZlp6NmZyd0R5anRPK3dycW1aR0RSUWk2SUpLcXlwQ3JLL0Z6VmpDYzF6bWVXd3BRaWE4TWhjK2V6NHBJUFZMMCtWWld5aExJcXRpaUpLbGwzTUdiZHZnWFZ6em4zZ0xUZHM0SmdiU0hHMm9sTDZVSEhsMDRDYXEwbDVPaC9VVTJtNDR0UEZlNHJ2QUo4RGRnV3VBN2NFUGlzd01jVm5qT3dKakE0eDdKbzErcm96MU5JV25MVDVOUjNUUWtta21YWC9qM0FYd1B2bHZyblBSK0tUd000TG1TYTEvdkFlTmJRNjFjWkhLYmRIZTJtSGZRckZLVXNMRWZqR1kxckZXRmp3aHJEK21pRU1aYXF5b1RKODhZeG5jNllUYVljSFkxeElROWJtVGJ6cGUyT01pMTVXMDR0WjJzbHhwTDVkaFZqelZISXFrd0xqeWFKRVIzMWU4em1qWVlZazU2ZXhvRk8renVudlZwSENyY1Z2ZzE4RmJqU3VtQ2ZVUGlrNU91UENGd1JLRnEzNll6WDFYR2w1SjBjMlJhU2lQeGRVUDFYNEkwRTl6a2x3bnVxMlE4L1RBRFJhZDBjN1I5TjQxWWJtSWVZUUExaVRvblVxcUpBK3lBTW1OYWV1dkU1RmtrUkh5THpwbVkybXhKQ0RxNWQ0L0RPSVNsUnlLS09rRnZocGMwTUxFWlRBY1MyTE94Q081Y0J4dGpEdVpzZGRHSU9UVWtKTVdoWldISm1PY1dZVHVRQ3BKTWtzNTFIMFFIT1lZSzN5TzdZVUdBYmVGN2dvd3FmQkY0QUxnT2J3RWpBMkhZcytUd3IwZjE2a1J3NGlZNVZiU0ZTQjNpMTVmZWF0UUI1cC9Taks0QjhrQ3Y0a0hiM0Ruanc2SURucjExaGMyT0VzZm5vVEcyRlc4a0ZzbDVWb3BpV3hkQlNGSmJHNVd0TmVmNjdjWjZxS3ZHdW9xb3FuSE5vVElUZzJtTTRUOWN0Z3ZWRmExanVpRFZ0czZOVlU1aGQ1L3preEwxcUozZC80OFViZk9mMU4vbTE2OWYwNXQySFdkL3YxTlBwS3I5MUd4eTdnRmxZbUdPRlhlQk5QVzBONzVOQnN5bHdTVE5JcmlyY01QQnMrOTVWemR6RkJXQU5yUUpEYTIwNjk3S2pxbSszNEpoeXlvbjFUb2pqVmdCNS85TzZaN0tmYWttVitybFV4bkQzOWwzMk45YjR5UE5YNlZjVkVpT2VISGRrYWZLOGthM0ptdW1MMFZOcDVaaEpCVlZWWmI2b0VMTGlhM3NkUWlDR3pGYW9LZUZiTHQyVUV0N2w5MXRLZWJYV3hLUzgxYlowdHhrc1VWQmV1dmthQUsvZDN5WEVNd2V4dHJXS1JSeXhyUGhtbGg1ZEM5Tjlmc1JwemRDMDRPbkZiSEUyZ2VmSTRCa0lyQ3RjVm5nMjVkZDZ3RnpnYllHWGd1cS9jR285RnRSRkszQThCUmJraFBUQWhUQVRWUjJXaG1FcFRLYkgzTGsxeC9TR2JLeXZzYjQyeVBvYUxUQjZWWUZJaEpCbkhxcXl5QVczbEVnbVlkSXArNGN4T1ZaSk1SSlR3bmxQREJGckRDTVJmTXhVbmpIVldEU3pGU1lWWTYyYmh2Q210dkpyN2VOTTVtZzhkei9QLzVHbHpCZFBzREJkMEp4MzNlMVNlVzN4L21Mc3R3VlIxZjdNbkp5dHFtbTdiVm5RRnVXU2tLNzhxNHR0UWJxTUlIbzhhZlpVbVNzeVNra3ByTUZvWkhhd3g4SGVQcWJzc2JHeHp1WHREY3JLWXF5aHNKYW1yUlFybWdHVVltc1ZGR1AxcEhrUElqRkZpakxUL05UMW5LS3dESHA5SnRNcFBrUjZneDdCNWJrSmcySUx1OS9VemR0MFNOYU1pQTc3UGNiMWs3TXg4YjBCWnZsaE90ZjJIQXNrUzlleVZLZFpNRUtldEhzc1pvUm5LeHhjWElDa2xPajhJVk5JT2xIMHdJVjRPYWFzM2dya0pyeWs3QjhmTXAwY016aytwdXoxMmR4WXA5L3ZaVXRpQkdzeXlWcEtCV1hNWTZtbGFtNWxiOFZzeXNLYzZBVWE2ZU5Ed0FXSHNZYlJhTWk4bmxPM282bkdHcHdQYjgyYjVuNjdzWUlJeVZxald4dWpud3FRZDJGRnp5dC9QQ21UZXg1d2xoOTBzMjdkQkVNYklPbkt0M3A2WEt3RTZMaHVkbWVOdjEyVnhRMWpoS0lvSk1aNFF0dTVQaHhTU0tLUWdLK1AyVyttbEwwK1pka0RNYVNXNjZxd0JxekZGa3J3bnRDMm9tU1FGRWhNaEtnblRDREdXUHI5Z3VCRFMrYlc3a1NEcTEzejhxeHgrOTNUVjBRWXo1cjM0M041N1BxY05LK2NBNkluWllHMWs5Mm1YbUhncVFGSUJHSTk5OU5wN1haSHZRcHJiY3RZM2s0RWxnVmlsYW93akliOWxwMVE4RDVTTnhPY0M3aTRJSklERVp0cklyMlNzaXd3YlREdm5LTnU1c1FZc2RZdzdQY3dZbWphQmtuVDNwR3FFb0ovdS9aK1FlWHZ5T1RyNm56UVlhLzNRWDltNTEyZmRXR1hycnZ4eGlyMmVBb0FZb3pSbFB1eUUrQmRpSzRKNlQvTFh2VjcxdGpSb0YrMjlZb3NraE5qeXRhQlBPN3BmZWJOcW9vc0MyQmNJTm5NbGRVMERmVThNQmxuTFkyZ3JXQ21RRmxhUnNQaENTRzBkNEhnQXpGR3BwTXBrK2xVTmZxQWtYODdydjJiZE9nelJWQWp3c0Y0OG9FajQ1MHV5Nm9xK0RTbWViVVRBUHVqbWJzMTkzRzNWOGhvTVVrWDJ3bkMwdHJzRnJVTWlURzFMT2pTRWpwYmk0aFNTdWExTGFvQzV4elNDRFlwS2JwTTE2a2wwK0R6cEdISXFkK1VJaUY0NmxsTm5EdXhwZDJiQlAxR1NqcW1vK21uZWtxeGM5R1gvb0tBOVdGZEh6aDV0YlUyRXpxZlptZUs4V3l1MTY5dWZVYUVHeUxJc05jamhNaDg3akVpakdjMXgwMk5WaEZIcEltQnVnbE1HNGQzNFlUMTNmbHdJbi9XS3l5bE5SU21aUk5wd3g0aFlTUW5Bd1FsZUlkM0hrMlJKUExTc1V0L2sxU1AyMlJQWTBUUzlxaXYwOGF2ZHMvS2dyenZoMTBBL0x6eCsvY2VIZjN6Qzg5dGYzSHZZTEpSKzRiK2hrVzJBcklaV1MrRjllMFIvV0ZCOUltNmprd25rYkZMQklSK2FXQWFzZnZDNFo3RGVVV3NJY1dFemlPdXptenZWWjR6YndkN0ljVFdtdmlJd3Q0OHBIL3dNUjEyNG85a1JMUW9aTFZ6VmdCNWY5WkNySjZ6WXZYTjJ6djcvM0ZwZmZEOVIwZkhYL3o0TDEzaWM3LzlMTFpvcHdNVEZNYmdYVUlOOUVyRDl0WWFZMk9vaTBDbGltMENjVlp4TFl6d1lwa0ZaVHgxbFBQSS9MRGg2TkdNNmFNYWR4eW9UQ3VJcVlyM2dSaFNFMFcrTW9ucFpYSmhyZE96cExwenRNcjlyRnlzRHpBc0FjeTg4V0U4cWYzNkwvVS9jZTJqbTF1WE5ncFpXeTl5ekdJRUZTZ2xUdzFhd0JRVmM0UzVEeFJSS1h6Q0JpRWx5Zk1pSWxTbFpkZ3JHSXhLTmk0UHVIUjF5R2l6eElmQTBWR05td2VhdXRHbytxMXA0czlkNGg2NU5hTnVBYUpKWVZEWVZybHB0VllBZVgrQjBYMDJNK2Z2WFgxdWJYYnB5dWdMMDFrY2JHNldsSlVsU3I3dEZCTHFjeHh6N0J3UER4c0dBNXM3L2J4U3BpcnphMnBrZjdmT0RDQXRiWWtnVktWaGZhMWlzRlp3NTg0K096c3pqT3JOdWZLSGRkUWZkc0RoQlZKaFJKT3lBc2NLSUJjaThaTGx6QTdtdTl2UERLNEZNWitlVG9Kc2J2ZFEyOHF3TlRHcjNZcmhlOS9iMDBiaDhsWmZEQWtiRXNsSEVrcVRZT2Z1aEdwVTBCOFdrREpQYmxsWW10cno5dXM3N0QwYzc4MW1laXZDWDg0U0w3VkIrYXlOUDZJSTJtdG4ybGRyQlpDTFlFa0FpQ0hGWnVidmIxOGIvZnFzanM5TTY4QndWR0ZESWpTNVYyb3lqL0U3MzM3dzZKa1hObTIvWjB1WlIyZ2lNUWZiQkRXNmMzK2ExcmI2Wmpnb0tjUWdDdFBqUnQvNi9uMTVkT2RnYjk3b24weHEvVk92dkFxTTZXaWlDMmhoUktXbC9sMnRGVUF1MGpLemladjJlMFc5dGw1OWJuYllqQTRmenJBSit1M2t3NzM3MDRlM2ZqTCs4WTFQYnovZkV5bU1TMFNmaUFGVURTRWwvNlBYOW1aYjEwWlZXVmhwSmczM2ZyVEg3ZS9kazhPSHg0ZU41Ni8yajlMWFltS0gzUGs2NjRBaldjbXQ2ODJxOUx3Q3lBVjB0eFNRZzkzWjNiVzFNcTZOcXMvTXgwMXZmMmNxdmttcTF1cXIvN1h6eXRyVnRmTDY5ZldQOVpPU1hDSWxwYVJIb1FOYzdjZXYvV0Rud1pYbjF6Y1A3eC9iSDMvM05udTNkL0ZOdkRmM2ZPblJYdnlLRDdyYldvNFR0d3FJaFVEUDVESGR1Tm92SzRCY3dGZ0VXdktUZzkzNjFtaTkwdEdsL3E4YW9UY1pOL0xnM21UdjFsdEhMMTE1ZHZSNURYRnIvR2pHNGFNSmV3L0dITzdPMkxsendPMGZQOXk5YzJmOGhwdlUxL2R2UFN6RDFLSEtuWm1YUDN1NEg3OGFnaDRDa3k0NGpFRUhBME8vYi9TemxYS3JXVzJXRCtNcUx2ajlMV2oxQlRET1JYN3dQdysvL0tuUFg1czkrOHpnOTFGOTdzRlBEbDRPUGgwZTNOcTdzdnVHYTV0V0V0R0hMQlVkRW8zVHlYVENxMGNQd2hjMitsSUZsVzhlMStuTEI4ZitsWlE0YnNGUnQ3OHJHQ05xQkIwTkxZT0I0VnMvV2RtT2xRVzVhSkc2UEdaSkZFZ3hxdHU1Tzc1WmxlWU9wTFdITy9YZmJtMzFYeXdJWC9RdVNFcXFJU2FKSVpGaVpxb1NhMTZmT2Y1K1VQQnBNZktOdmJIKzhlRTQvYmNxa3lWd1JBRzF4cWdDdlY1T0M0OG5LNENzTE1oRjg2OFVyTTBraERGcTZJSUU4Sy8vY1ArZlJzUGlwZ3ZhYkcvM2Y5Tzd1QTg2RUtVa2FmNlhLYzZuS1pudnhCQi9ORzM0bytONWVyMmU2dzZuZ2krTEpzUW9nb3BCVTB4c1hGbGpiM2V5MmlFZjhuV2htNHArNjNjL3dpdmZ1RXVNMmgwMVBkRURCRW9SNmErdEZaY3Q2UVZyOWJvMVBCdWpOakhIRmZPVTJKa0hlY3Q1UGVLVXlTTjBuaGNzSmRyeVg1TlcyYXJWZWhvQU1oaVd4SkJ3N3FUYnR6dGkydVdYNmlxb0x1YXlseG5GdThCWXZMNndTQUFxc3BwQlhhMm5DQ0EvNDU2N1RCOUY1MkdXM0xIWXNSUUwwdW5FK1RQZ3E3VmFUejFBdXZlOVRGN1FsV2J1eW9Da3BhOVh3Rml0LzljQWVSSlluaGp6cjBDeFd1OW0vUzlaaFpaSUNWZmtRd0FBQUVwMFJWaDBZMjl0YldWdWRBQkdhV3hsSUhOdmRYSmpaVG9nYUhSMGNEb3ZMMlZ1TG5kcGEybHdaV1JwWVM1dmNtY3ZkMmxyYVM5R2FXeGxPbFJOVGxSU1lYQm9ZV1ZzTWpBeE1pNXdibWVrYlgvSEFBQUFKWFJGV0hSa1lYUmxPbU55WldGMFpRQXlNREUxTFRBekxUQTNWREl6T2pVd09qUTJLekF3T2pBd3BUYnBNZ0FBQUNWMFJWaDBaR0YwWlRwdGIyUnBabmtBTWpBeE5TMHdNeTB3TjFReU16bzFNRG8wTmlzd01Eb3dNTlJyVVk0QUFBQkdkRVZZZEhOdlpuUjNZWEpsQUVsdFlXZGxUV0ZuYVdOcklEWXVOaTQ1TFRjZ01qQXhOQzB3TXkwd05pQlJNVFlnYUhSMGNEb3ZMM2QzZHk1cGJXRm5aVzFoWjJsamF5NXZjbWVCMDdQREFBQUFHSFJGV0hSVWFIVnRZam82Ukc5amRXMWxiblE2T2xCaFoyVnpBREduLzdzdkFBQUFHSFJGV0hSVWFIVnRZam82U1cxaFoyVTZPbWhsYVdkb2RBQXpOVFJKVWt6U0FBQUFGM1JGV0hSVWFIVnRZam82U1cxaFoyVTZPbGRwWkhSb0FESTRNVkg0LzZvQUFBQVpkRVZZZEZSb2RXMWlPanBOYVcxbGRIbHdaUUJwYldGblpTOXdibWMvc2xaT0FBQUFGM1JGV0hSVWFIVnRZam82VFZScGJXVUFNVFF5TlRjM01qSTBOcmRENzBNQUFBQVNkRVZZZEZSb2RXMWlPanBUYVhwbEFERTFORXRDUXM0TVZ0c0FBQUF6ZEVWWWRGUm9kVzFpT2pwVlVra0FabWxzWlRvdkx5OTBiWEF2Ykc5allXeGpiM0I1WDJSbVpqVXdaREUwT1ROa1ppMHhMbkJ1Wi9aWEVvMEFBQUFBU1VWT1JLNUNZSUk9XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vcHVibGljL2ltYWdlcy9yYXBoYWVsLnBuZ1xuICoqIG1vZHVsZSBpZCA9IDMwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L34vbG9kYXNoL19nZXRQcm90b3R5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0hvc3RPYmplY3QgPSByZXF1aXJlKCcuL19pc0hvc3RPYmplY3QnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fFxuICAgICAgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT0gb2JqZWN0VGFnIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmXG4gICAgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZHV4L34vbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=